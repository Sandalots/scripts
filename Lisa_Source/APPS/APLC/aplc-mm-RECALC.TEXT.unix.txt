
                            {'Copyright 1983, 1984, Apple Computer Inc.'}

(*$S LCcalculator *)
function GetCellBits(rowId, colId : integer) : TPtrCell;
var cnHContents : THContents;
    pCel        : TPCel;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   pCel := FindPcel(rowId, colId, false);
   GetCellBits := nil;
   if pCel <> nil then
      with pCel^ do
         if attributes.pkHasRule then begin
            cnHContents := pointer(MakeHnd(oh));
            GetCellBits := @cnHContents^^.rule.lbits
         end
end;


(*$S LCcalculator *)
procedure detLogOrder(* orderOp : orderType *);
var rowId, colId : integer;
    curLogCell   : TPtrCell;            {current logical cell}
    curRow       : integer;
    curCol       : integer;
    nRow, nCol   : integer;
    curRange     : range;
    cheat        : ^longint;            {cheat to clear the first 4 bytes of information}
    curForm      : TPtrCell;
    sonCell      : TPtrCell;
    GlobalCell   : TPtrCell;

(*$IFC DEBUGVERSION *)

    (*$S LCdebug *)
    procedure printOrder;
    var tcell      : pident;
        x          : integer;
        theCell    : TPtrCell;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       writeln('sizeof(cellbools): ',sizeof(cellbools):1,'   sizeof(tCell): ',sizeof(tcell):1,
               '   circular: ',circularFlag,'  FirstLogCell: ',FirstLogCell.length:1,',',
               FirstLogCell.start:1);
       tcell.start  := FirstLogCell.start;
       tcell.length := FirstLogCell.length;
       x := 0;
       if tcell.start <> nullSnip then
          repeat
             theCell := GetCellBits(tcell.length, tcell.start);
             with theCell^ do begin
                x := x + 1;
                writeln(x:1,'.  ','  cell: ',tcell.length:1,',',tcell.start:1,
                    '   circluar: ',b.circular,'  link: ',nextLogCell.length:1,',',nextLogCell.start:1);
                tcell.length := nextLogCell.length;
                tcell.start  := nextLogCell.start
             end
          until tcell.start = nullSnip
    end;
(*$ENDC *)


    (*$S Circling *)
    procedure doDependent;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       if CoordInRange(nRow, nCol, curRange) then SetCirBit(curRow, curCol, true, true)
    end;


    {The ancestor flag is set for all formulae in the current ancestoral tree.  If
     a son is found with its ancestor flag already set, then this must be a circular
     reference.  The personal and global circular reference flags are set for the cells
     in the circular loop just discovered,  i.e., the loop starting at the curForm
     and progressing backwards through fathers to the sonCell (which according to its
     ancestor flag is an ancestor of curForm).
    }
    (*$S LCcalculator *)
    procedure SetCRFlgs(indexProblem : boolean);
    var tempCell : TPtrCell;
        stopCell : TPtrCell;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
       if debug[6] then writeln('Circular reference: ',curRow:1,',',curCol:1,'  indexProblem: ',indexProblem);
(*$ENDC *)
       circularFlag := true;
       tempCell     := curForm;
       tempCell^.b.circular := true;
       if orderOp = lCircular then SetCirBit(curRow, curCol, true, true);
       if indexProblem then stopCell := globalCell
       else stopCell := sonCell;

       while tempCell <> stopCell do begin
          with tempCell^ do begin
             if orderOp = lCircular then SetCirBit(father.length, father.start, true, true);
             tempCell := GetCellBits(father.length, father.start)
          end;
(*$IFC DEBUGVERSION *)
          if debug[6] then writeln('  father: ',tempCell^.father.length:1,',',tempCell^.father.start:1);
(*$ENDC *)
          tempCell^.b.circular := true;
       end
    end;


    {advance to the next coordinate.  The coordinate will be considered a son of the current formula.
     Coordinate ranges will be iterated through to get all of the sons.  The function returns true if
     there is a next son to get.  The formula information will be updated to reflect the current index
     into the formula and the formula iteration count, if necessary.  CurRow & CurCol will be set to
     the coordinates of the son.
    }
    (*$S LCcalculator *)
    function  GetNextSon : boolean;
    label 1,2;
    var index        : integer;
        lastIndex    : integer;
        opCode       : byte;
        advanceIndex : boolean;
        takeCoord    : boolean;
        sym          : variantType;
        tempCell     : TPtrCell;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       GetNextSon := false;

       {get the current formula index}
       lastIndex := curForm^.b.formindex;
       index     := 0;
       lastFormula.coordCnt := 0;

       while true do begin
          opCode := lastFormula.ptr^[index];
          case opCode of
             PUSHEND : goto 1;
             PUSHNOP : begin
                          index  := index + 1;
                          opCode := lastFormula.ptr^[index]
                       end
          end;
          if opCode <= ENDCOORD then begin

             getOperand(lastFormula.ptr, index, curRow, curCol, opCode);

             if index >= lastIndex then begin
                {if the current opCode is a range, then we must evaluate the range to look for its
                 sons.  This involves iterating through the range and considering each cell referenced
                 as a son.  For example:  A1:A10 would check every cell from A1 through A10.
                }
                advanceIndex := true;
                takeCoord    := true;
                case opCode of
                   PUSHECRANGE,
                   PUSHECOORD : takeCoord := false;
                   PUSHCOORD  : begin
                                   nCol := VT.coordVar.start;
                                   nRow := VT.coordVar.length
                                end;
                   PUSHCRANGE : with curForm^ do begin
                                   normCoords(VT.rangeVar);
                                   advanceIndex := false;
                                   if b.iterating then begin
                                      nCol := b.col + 1;
                                      nRow := b.row;
                                      if nCol > VT.rangeVar.second.start then begin
                                         nCol := VT.rangeVar.first.start;
                                         nRow := nRow + 1;
                                         if nRow > VT.rangeVar.second.length then begin
                                            takeCoord   := false;
                                            b.iterating := false
                                         end
                                      end
                                   end
                                   else begin
                                           nCol := VT.rangeVar.first.start;
                                           nRow := VT.rangeVar.first.length;
                                           b.iterating := true
                                        end;
                                   b.row := nRow;
                                   b.col := nCol
                                end;
                end;
                if takeCoord then begin
(*$IFC DEBUGVERSION *)
                   if debug[6] then
                      writeln('possible son at: ',nRow:1,',',nCol:1,'  formula: ',CellHasRule(nRow, nCol),'  index: ',index:1);
(*$ENDC *)
                   if advanceIndex then NextPcode(lastFormula.ptr, index)
                   else lastFormula.coordCnt := lastFormula.coordCnt - 1;
                   if orderOp = lDependent then doDependent;
                   tempCell := GetCellBits(nRow, nCol);
                   if tempCell <> nil then begin
                      GetNextSon := true;
                      curForm^.b.formindex := index;
                      sonCell := tempCell;
                      exit(GetNextSon)
                   end
                   else goto 2
                end
             end
          end
          else begin
                  sym.byteVar := opCode;
                  case sym.lexeme of
                     INDEXop,
                     LOOKop  : SetCRflgs(true);
                     REGRESSop,
                     LINSYSop,
                     COEFFop : GlobalRecalc := true
                  end
               end;
          NextPcode(lastFormula.ptr, index);
       2:
       end;
    1:

(*$IFC DEBUGVERSION *)
       ;if debug[6] then writeln('no more sons at :',curRow:1,',',curCol:1)
(*$ENDC *)
    end;


    {advances rowId & colId to point at the next formula in the matrix.  This is done when current
     progress of going from the father to all of its sons has exhausted all of the possible sons
     of the father.  The function returns true to signal that no more formulas in the matrix exists that
     have not already been looked at.  "NextFormulas"  will be determined through row ordering where the
     next formula occurs.
    }
    (*$S LCcalculator *)
    function  GetNextCell : boolean;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       GetNextCell := true;
       if NextFormula(rowId, colId) then begin
          GetFormula(rowId, colId, false);           {get the next formula info without loading its value}
          GlobalCell  := lastFormula.lBitsPtr;
          curForm     := GlobalCell;
          curRow      := rowId;
          curCol      := colId;
          GetNextCell := false
(*$IFC DEBUGVERSION *)
       ;if debug[6] then writeln('New Cell at :',curRow:1,',',curCol:1)
(*$ENDC *)
       end
(*$IFC DEBUGVERSION *)
       else if debug[6] then writeln('no more Cells after :',curRow:1,',',curCol:1)
(*$ENDC *)
    end;


    (*$S Circling *)
    procedure initDependents;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       curRange := circleRg;
       expandRange(curRange, true)

(*$IFC DEBUGVERSION and false *)
       ;if debug[6] then writeln('Dependent range: ',wRg(curRange),'  start at: ',rowId:1,',',colId:1);
(*$ENDC *)
    end;


(*$S LCcalculator *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   debug[6] := true;
   if debug[6] then writeln('FormulaChanged: ',formulaChanged);
(*$ENDC *)

   rowId := 1;                                          {reset all the formula bits}
   colId := 0;
   while NextFormula(rowId, colId) do begin
      curForm := GetCellBits(rowId, colId);
      cheat   := @curForm^;
      cheat^  := 0
   end;

   FirstLogCell.start := nullSnip;                      {set the global first logical cell to nil}
   circularFlag       := false;                         {clear the global circular reference flag}
   FormulaChanged     := false;
   GlobalRecalc       := false;

   rowId        := 1;
   colId        := 0;
   curLogCell   := nil;

   if orderOp = lDependent then initDependents;
   if GetNextCell then exit(detLogOrder);               {get the first cell - end if necessary}
   with curForm^ do begin
      b.ancestor   := true;
      father.start := nullSnip
   end;

   while true do
      if GetNextSon then begin
         with sonCell^ do begin
            if b.ancestor then SetCrFlgs(false)
            else if not b.done then begin              {goto the next son if it has not already been done}
                    b.ancestor    := true;             {set ancestor flag for circularity checking}
                    b.iterating   := false;            {since this is a new son - we can't be iterating yet}
                    b.formindex   := 0;                {set the formula index to the start of the formula}
                    father.start  := curCol;
                    father.length := curRow;           {set the father link for going back to the father}
(*$IFC DEBUGVERSION *)
                    if debug[6] then
                       writeln('moving to son ',nrow:1,',',ncol:1,'  father: ',curRow:1,',',curCol:1);
(*$ENDC *)

                    curRow        := nRow;
                    curCol        := nCol;
                    GetFormula(curRow, curCol, false);     {get the next formula info without loading its value}

                    curForm       := sonCell               {pass the buck onto the son}
                 end
            else if b.circular then SetCrFlgs(true)
         end
      end
      else begin
              with curForm^ do begin                   {no more sons.  Therefore}
                 b.ancestor := false;                  { ... no ancestors after this}
                 b.done     := true                    { ... and this branch is done}
              end;

              {Since this is the first cell done, set the first logical cell to it}
              if FirstLogCell.start = nullSnip then begin
                 FirstLogCell.start  := curCol;
                 FirstLogCell.length := curRow
(*$IFC DEBUGVERSION *)
                 ;if debug[6] then Writeln('FirstLogCel: ',curRow:1,',',curCol:1);
(*$ENDC *)
              end;

              if curLogCell <> nil then
                 with curLogCell^.nextLogCell do begin
                    start  := curCol;                  {add the curForm to the logical linked list}
                    length := curRow
(*$IFC DEBUGVERSION *)
                    ;if debug[6] then Writeln('curLogCell^.nextLogCell: ',curRow:1,',',curCol:1);
(*$ENDC *)
                 end;
              curLogCell := curForm;                   {update current logical ptr to point at new cell}
(*$IFC DEBUGVERSION *)
              if debug[6] then Writeln('checking curForm^.father: ',curForm^.father.length:1,',',curForm^.father.start:1);
(*$ENDC *)

              {if the curForm is the founding father then look for another founding father}
              if curForm^.father.start = nullSnip then begin
                 while curForm^.b.done do                     {get the next cell in the given order.  If that}
                    if GetNextCell then begin
                       curLogCell^.nextLogCell.start := nullSnip;
(*$IFC DEBUGVERSION *)
                       if debug[6] then printOrder;
(*$ENDC *)
                       exit(detLogOrder)                      {cell does not exist, we are all done}
                    end;
                 with curForm^ do begin
                    father.start := nullSnip;
                    b.formIndex  := 0;
                    b.iterating  := false;
                    b.ancestor   := true
                 end
              end
              else begin
                      with curForm^ do begin
                         curRow := father.length;
                         curCol := father.start
                      end;
(*$IFC DEBUGVERSION *)
                      if debug[6] then writeln('moving to father: ',currow:1,',',curCol:1);
(*$ENDC *)
                      GetFormula(curRow, curCol, false); {get the next formula info without loading its value}
                      curForm := lastFormula.lBitsPtr
                   end
           end

end;


(***************************************.*******.********************************************************
   recalc2 - performs the recalculation of the matrix.

             This routine is also responcible for causing the circles to be displayed for the ShowCircles
             command.  During a recalcuation, if an assumption must be made to determine a formula's
             value, it will be circled.  The possible assumptions are:

                a. The cells reference by the function (i.e., sum) are blank.
                b. The coord/range are currently error coords/range.

             `status` will be set to:
                userStopped - recalculation was aborted by the user
                RECALCERR   - ran out of time during the recalculation.
                OUTOFMEM    - ran out of memory.
                DSpaceErr   - ran out of disk space.
                OK          - everything is fine.
             Recalculation stops immediately when an error occurs, thus the matrix will not display
             the correct values.

****************************************.*******.*******************************************************)
(*$S LCcalculator *)
procedure recalc2(var status : integer);
label 2;
var rowId, colId  : integer;
    x             : integer;
    changeCnt     : integer;
    completed     : boolean;
    doCalculation : boolean;
    notEqual      : boolean;
    doDisplay     : boolean;
    dispState     : boolean;
    didGlobal     : boolean;
    calcVal       : ValueType;
    xNumber       : extended;
    text1, text2  : ptrData;
    endTime       : longint;
    rg            : range;

(*$IFC DEBUGVERSION *)
    (*$S LCdebug *)
    procedure dumpinfo(num : integer);
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       case num of
          1 : writeln('cell: ',rowId:1,',',colId:1,'  c/v: ',
                      wNUM(calcval.val.lrealvar),'/',wxNUM(lastformula.val.val.xrealvar),
                      '  NAN: ',wNAN(calcval.nan),'/', wNAN(lastformula.val.nan),
                      ' chg:', changecnt:1);
          3 : begin
                writeln('changecnt: ',changecnt:1,'  numPasses: ',numpasses+1:1,'  time: ',time - endTime + recalcTime * 100:1,
                        '   completed: ',completed);
             end;
       end
    end;
(*$ENDC *)


(*$S LCcalculator *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   endTime     := time + recalcTime * 100;      {start the calculation timer}
   numPasses   := 0;                            {start the pass counter}
   completed   := false;                        {reset the completed recalculation flag}
   didGlobal   := false;

(*$IFC DEBUGVERSION *)
   if debug[10] and not debug[23] then timestart(10);
(*$ENDC *)

   if formulaChanged then detlogOrder(lCalc);

(*$IFC DEBUGVERSION *)
   if debug[10] and not debug[23] then timepeak(10);
(*$ENDC *)

   repeat
      rowId       := FirstLogCell.length;
      colId       := FirstLogCell.start;
      changeCnt   := 0;
      while colId <> nullsnip do begin

         GetFormula(rowId, colId, true);
         doCalculation := true;
         doDisplay     := false;
         if numPasses > 0 then
            if not GlobalRecalc then doCalculation := lastformula.lBitsPtr^.b.circular;

         if doCalculation then begin
            calculate(calcVal, rowId, colId);

(*$IFC DEBUGVERSION *)
            if debug[3] then dumpinfo(1);
(*$ENDC *)

            {if the old value for the formula is not the same as the newly calculated value then remember
             the number of cells that changed.  The recalculation will stop when the number of cells that
             change become zero.
            }
            notEqual := true;
            if calcVal.nan = lastformula.val.nan then
               case calcVal.nan of
                  syNone  : begin
                               D2X(calcVal.val.lrealvar, xNumber);
                               notEqual := (relx(lastformula.val.val.xrealvar, xNumber) <> EQ)
                            end;
                  syText  : with lastformula.val.val.textinfo, calcVal.val do begin
                               text1 := @hContents^^;
                               text2 := @textinfo.hContents^^;
                               notEqual := not CompChrIdentity(@text1^[index], @text2^[textinfo.index],
                                            len, textinfo.len, CompWeak)
                            end;
                  syDate  : begin
                               X2D(lastformula.val.val.xrealvar, lastformula.val.val.lrealvar);
                               with lastformula.val.val.date, calcVal.val do
                                  notEqual := (year <> date.year) or (month <> date.month) or (day <> date.day)
                            end;
                  syParts : with lastformula.val.val.dateParts, calcVal.val do
                               notEqual := (monthAC <> dateParts.monthAC) or (dayAC <> dateParts.dayAC) or
                                           (yearAC <> dateParts.yearAC);
                  otherwise notEqual := false
               end;
            if notEqual then begin
               changeCnt := changeCnt + 1;
               PutValue(rowId, colId, calcVal, true, status);
               if status <> 0 then goto 2;
               if numPasses = 0 then begin
                  doDisplay := true;
                  dispState := true
               end
            end
         end
         else if numPasses = 1 then begin
                 doDisplay := true;
                 dispState := false
              end;

         if doDisplay then
            if lastformula.wInvalid <> dispState then begin
               SetCellBit(rowId, colId, dispState, BInvalid);
               DisplayCell(rowId, colId)
            end;

         lastFormula.lBitsPtr := GetCellBit(rowId, colId);
         with lastFormula.lBitsPtr^ do begin
            rowId := nextLogCell.length;
            colId := nextLogCell.start
         end
      end;

      completed := (changeCnt = 0);
      if numPasses = 0 then completed := completed or not circularFlag;
      if GlobalRecalc then
         if completed and not didGlobal then begin
            didGlobal := true;
            completed := false
         end
         else didGlobal := false;

(*$IFC DEBUGVERSION *)
      if debug[6] then dumpinfo(3);
(*$ENDC *)

      numPasses   := numPasses + 1;
      if not completed then begin
         if abort then status := userStopped;
         if (time > endTime) and not RecalcNow then status := RecalcErr
      end;

      {stop the recalculation if: out of time and not doing a calcNow,  the user said to stop,
       or finally, the recalculation is compelte.
      }
   until completed or (status <> 0);

2: SetRgBits(rg, BInvalid, false, 6 + ord(app.BusGraph))

(*$IFC DEBUGVERSION *)
   ;endTime := time - endTime + recalcTime * 100;
   writeln('number of passes: ',numPasses:1,'  time: ',endTime:1);
   dispPasses(numPasses, status = ok)
(*$ENDC *)

end;


(***************************************.*******.********************************************************
   CellFormula - Depending upon the `mode` (mmRead or mmWrite), "CellFormula" will either parse a
                formula or return the text for a formula.

                 With `mode` set to mmRead, the text of the formula at `rowId, colId` will be placed
                 into the area pointed to by `formula`.   `status` on mmRead's will always be ok.

                 With `mode` set to mmWrite, the text pointed to by `formula` will be parsed to
                 determine if it is a valid formula.  The # of characters in the formula is specified
                 by `numBytes`.  If the formula parses correctly, it will be placed in the matrix at
                 `rowId, colId`.  Parsing errors messages will be returned through `error` with `status`
                 set to ParseErr.  The formula will be evaluated to get its initial value.

   NOTE: when the routine is called, `numBytes` should be set to the max # of characters to be passed
         back.  The routine will set NUMBYTES equal to the # of characters actually returned.  If the
         text for the formula is not available during a mmRead, `numBytes` will be returned as 0.
****************************************.*******.*******************************************************)
(*$S LCmatMgrSeg *)
procedure CellFormula
  (* mode         : IOModeType;         {reading/writing mode flag}
     rowId, colId : idType;             {location of the cell}
     formula      : ptrData;            {ptr to fthe ormula characters}
     var numBytes,                      {max # of chrs /actual # chrs returned}
         status   : integer;            {error status number}
     var error    : errRecord           {error message information}
  *);
var PRdata     : TPPRrecord;                    {dummy paste relative info ptr: not used}
    cell       : cnRecord;                      {cell info}
    formPtr    : THFmla;                        {handle to the formula}
    hContents  : THContents;                    {handle to the cell}
    calcVal    : valueType;                     {calculated value of the formula}
    bNumBytes  : integer;                       {numbytes for a blank line}
    total      : integer;                       {total # of bytes in parsed formula}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   if mode = mmRead then TraceMess(17)
   else DebugMess(19);
(*$ENDC *)

   status := ok;
   if mode = mmRead then begin
      GetFormula(rowId, colId, false);          {get the formula information}
      if lastformula.ptr <> nil then            {if the formula exist, decompile it}
         decompileformula(formula, numBytes, rowId, colId, PRdata, false, false, false, false)
      else numBytes := 0
   end
   else begin
           {First, entering a new formula will freeze any previous changes, thus the undo buffer can
            be reclaimed.  Second, the text will be parsed and if no error occurs, the formula will be
            entered into the matrix with an initial calculated value.  Lastly, if the parsing discovers
            that the formula text is really a blank line it will be entered as a blank text string.
           }
           claimUndoBuffer(true);
           if parse(PFormula, formula, numBytes, rowId, colId, error) then begin

              {compute the # of bytes in the formula}
              total := 0;
              repeat
                 NextPcode(@eval[0], total)
              until eval[total] = PUSHEND;
              total := total + 1;

              {get the information for the cell}
              CellContents(mmRead, rowId, colId, false, cell, status);

              {try to allocate space for the formula and its cell information}
              hContents := allocBlock(sizeof(TRule) + sizeof(TVinfo));
              if hContents <> nil then formPtr := pointer(ord(allocBlock(total + sizeof(integer))))
              else formPtr := nil;

              {insure that the allocation when alright before going on}
              if (hContents <> nil) and (formPtr <> nil) then begin

                 {remove references to the previous formula}
                 if cell.cnHasRule then DecRefCnt(cell.cnHcontents, true, true);

                 {set up info about the new formula - the new formula will be initialized
                  with a value of ERROR.
                 }
                 cell.cnHcontents     := hContents;
                 cell.cnInvalid       := true;
                 cell.cnIs1Marked     := false;
                 cell.cnIs2Marked     := false;
                 cell.cnDollar        := false;
                 cell.cnInCopy        := false;
                 cell.cnHasRule       := true;
                 cell.cnSize          := sSymbol;
                 cell.cnSymbol        := syError;

                 formPtr^^.shared := fSingle;                   {the new formula will not be shared}

                 {set up linkage to the new formula}
                 with cell.cnHContents^^.rule do begin
                    ohFmla     := GetOH(ord(formPtr));
                    value.long := VofZero
                 end;

                 {copy formula to the formula area and attempt to save the info on it}
                 moveLfast(@eval, @formPtr^^.vecOp, total);
                 CellContents(mmWrite, rowId, colId, true, cell, status);
                 lastformula.PRdata   := nil;
                 lastformula.ptr      := @formPtr^^.vecOp;
                 lastformula.absolute := true;
                 lastformula.refcnt   := 1;
                 lastformula.formPtr  := formPtr;
                 lastformula.shared   := false;
                 lastformula.coordcnt := 0;

                 {if saving was alright, calculate the value for the new formula}
                 if status = ok then begin
                    calculate(calcVal, rowId, colId);
                    PutValue(rowId, colId, calcVal, true, status);
                    SetCellBit(rowId, colId, true, BInvalid)
                 end
              end
              else begin
                      {reclaim anything that was allocated, keep track of the handles allocated and set OutOfMem}
                      if hContents <> nil then begin
                         FreeH(mxHz, pointer(ord(hContents)));
                         numHandles := numHandles - 1
                      end;
                      if diskErr then status := DSpaceErr
                      else status := OutOfMem
                   end
           end
           else if error.status = BlankLine then begin
                   bNumBytes    := 0;
                   error.status := 0;
                   CellValue(mmWrite, rowId, colId, formula, false, bNumBytes, status)
                end
           else status := ParseErr
        end

(*$IFC DEBUGVERSION *)
   ;if mode = mmRead then TraceMess(18)
   else DebugMess(20);
   StatusMess(status)
(*$ENDC *)

end;


(***************************************.*******.********************************************************
   CellInterval - returns the text for the formula at `rowId, colId` along with interval information
                  about the location of each coordinate/range that maybe contained within the text of
                  the formula.  The text will be placed into the area pointed to by `formula` and the
                  interval information will be returned via `PRdata`.  `relstr` states if the relative
                  or absolute version or the formula is to be generated.

                  The `PRdata` information should have been set up with the appropriate paste relative
                  information before "CellInterval" was called.

   NOTE: if `relstr` is false (meaning to generate the absolute version of the formula) the `PRdata`
         record is not changed.  When the routine is called `numBytes` should be set to the max # of
         characters to be passed back.  The routine will set `numBytes` equal to the # of characters
         actually returned.  If the text for the formula is not available during a mmRead, `numBytes`
         will be returned as 0.
****************************************.*******.*******************************************************)
(*$S LCmatMgrSeg *)
procedure CellInterval
  (* rowId, colId  : idType;            {location of the cell}
     formula       : ptrData;           {ptr to the formula characters}
     PRdata        : TPPRrecord;        {Paste Relative record}
     relstr        : boolean;           {relative/absolute information: y/n}
     var numBytes  : integer;           {max # of chrs /actual # chrs returned}
     resetPRdata   : boolean            {reset the `PRdata` information}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetFormula(rowId, colId, false);
   if lastformula.ptr <> nil then
      decompileformula(formula, numBytes, rowId, colId, PRdata, relstr, true, false, resetPRdata)
   else numBytes := 0
end;


(***************************************.*******.********************************************************
   displaycell - causes the cell at `rowId, colId` to be displayed.  If recalculation is on (automatic)
                 and the application type is LisaCalc then information about what snips are visible
                 will have been set up in `SnipVis`.  Before the cell is displayed, `SnipVis` will be
                 checked to see if the snip is even visible.  If it is not visible, no drawing will
                 be done.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure displaycell
  (* rowId, colId : integer             {location of cell to be displayed}
  *);
var rg        : range;                          {range which represents the cell to be displayed}
    doDisplay : boolean;                        {will the cell actually be drawn: y/n}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   DebugMess(21);
   if debug[10] and not debug[23] then timestart(5);
(*$ENDC *)

   doDisplay := true;
   if recalcflag and app.LisaCalc then          {determine if the cell should be displayed}
      doDisplay := SnipVis[rowKind, rowId] and SnipVis[colKind, colId];
   if doDisplay then begin
      rg.rKind := a1CellRg;                     {set up range to represent the cell}
      rg.loRow := rowId;
      rg.loCol := colId;
      rg.hiRow := rowId;
      rg.hiCol := colId;
      DisplayRange(rg)                          {cause the cell to be displayed}
   end;

(*$IFC DEBUGVERSION *)
   ;if debug[10] and not debug[23] then timepeak(5);
   DebugMess(22)
(*$ENDC *)
end;


(*$IFC DEBUGVERSION *)
(*$S debug2 *)
(***************************************.*******.********************************************************
    dumpTable - cause the information for the entire table to be printed.  Maybe stopped by hitting
                the mouse button.  Nuff said.
****************************************.*******.*******************************************************)
procedure dumpTable;
label 1;
var row, col : integer;
    temp14   : boolean;
    temp11   : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   temp14 := debug[14];
   temp11 := debug[11];
   debug[14] := true;
   debug[11] := true;
   repeat until not getbutton;
   meminfo(-1, -1, false);
   for row := 1 to FinalSnip(rowKind) do if SnipExists(rowKind, row) then
      for col := 1 to FInalSnip(colKind) do if SnipExists(colKind, col) then begin
         if getbutton then begin
            writeln;
            writeln(chr(7), 'Stopping dumpTable');
            goto 1
         end;
         if cellHasRule(row, col) then GetFormula(row, col, true)
         else begin
                 write(row:1,',',col:1,'  ');
                 meminfo(row, col, true)
              end;
         writeln
      end;
1: debug[11] := temp11;
   debug[14] := temp14
end;
(*$ENDC *)


(***************************************.*******.********************************************************
   SetLastFormula - sets up the global `lastFormula` record from the shared formula pointed to by the
                    formula handle `formPtr`.

   NOTE: the formula handle, `formPtr`, is assumed to be pointing to a shared formula.
****************************************.*******.*******************************************************)
(*$S LCmatMgrSeg *)
procedure SetLastFormula
  (formPtr : THFmla                     {handle to the formula}
  );
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with formPtr^^ do begin
      lastformula.formPtr  := formPtr;                  {remember the handle to the formula}
      lastformula.coordcnt := 0;                        {start the coordinate count at zero}
      lastformula.dh       := sData.info.dh;            {remember the base cell displacements}
      lastformula.dv       := sData.info.dv;
      lastformula.row      := sData.info.rowId;         {remember the coordinates of the base cell}
      lastformula.col      := sData.info.colId;
                                                        {get direct pointer to the formula}
      lastformula.ptr      := pointer(ord(@sData.vecOp)+sData.info.numcoords div 4+1);
      lastformula.shared   := true;                     {assume the formula is shared}
      lastformula.absolute := (shared = fAbsolute);     {if it is shared, are all the relative info set to absolute?}
                                                        {set the pointer to the paste relative information}
      if lastformula.absolute then lastformula.PRdata := nil
      else lastformula.PRdata := @sdata.vecOp
   end
end;


(***************************************.*******.********************************************************
   SetCirBits - turns on/off the circling mode bits.  This make cause the heap to move seo the pointer
                the last formula is recalculated.  Note that the circle bit must be set before the invalid
                bit to insure that the cell exists.
****************************************.*******.*******************************************************)
(*$S Circling *)
procedure SetCirBit
  (* rowId, colId : integer;
     cir, inv     : boolean;
  *);
var coordCnt : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   assumption := true;
   SetCellBit(rowId, colId, cir, BCircle);
   SetCellBit(rowId, colId, inv, BInvalid);  {set the invalid bit to force the cell to be drawn with the circles showing}
   coordCnt := lastFormula.coordCnt;
   with lastFormula.formPtr^^ do
      if shared <> fSingle then SetLastFormula(lastformula.formPtr)
      else lastformula.ptr := @vecOp;
   lastformula.coordCnt := coordCnt
end;


(***************************************.*******.********************************************************
   GetFormula - sets up the global `lastFormula` record for the formula at `rowId, colId`.  If a formula
                does not exists at `rowId, colId`, then `lastFormula.ptr` will be set to nil.  If
                `getValue` is true, then the current value of for the formula will be placed in
                `lastformula.val`.
****************************************.*******.*******************************************************)
(*$S LCmatMgrSeg *)
procedure GetFormula
   (* rowId, colId : idType;            {location of the cell}
      getvalue     : boolean            {retrieve value for the formula: y/n}
   *);
var cell   : cnRecord;                          {cell info}
    assume : boolean;                           {value assumption flag}
    status : integer;                           {error status}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   DebugMess(17);
(*$ENDC *)

   {get the information for the cell}
   CellContents(mmRead, rowId, colId, false, cell, status);

   {set up default `lastformula` info}
   lastformula.coordcnt := 0;
   lastformula.refcnt   := 0;
   lastformula.PRdata   := nil;
   lastformula.shared   := false;
   lastformula.absolute := true;
   lastformula.wInvalid := false;

   {if the cell has a formula, set up any info concerning it}
   if cell.cnHasRule then
      with cell.cnHContents^^ do begin
         lastformula.val.pCel := cell.cnPCel;
         lastformula.pCel     := cell.cnPCel;
         lastformula.lBitsPtr := @rule.lBits;
         lastformula.formPtr  := pointer(MakeHnd(rule.ohFmla));
         lastformula.wInvalid := cell.cnPCel^.attributes.pkInvalid;
         with lastformula.formPtr^^ do
            if shared <> fSingle then begin
               lastformula.refcnt := sData.info.refcnt;
               SetLastFormula(lastformula.formPtr)
            end
            else begin
                    lastformula.ptr := @vecOp;
                    lastformula.refcnt := mInfSnip
                 end;
(*$IFC DEBUGVERSION *)
         if getvalue or debug[14] then begin
(*$ELSEC *)
         if getvalue then begin
(*$ENDC *)
            unPackValue(cell.cnHContents, @rule.value, true, lastformula.val, assume)
         end;
(*$IFC DEBUGVERSION *)
         if debug[14] then begin
            write(rowId:1,',',colId:1,'  ');
            meminfo(rowId, colId, true);
            dumpshared(lastformula.formPtr)
         end;
(*$ENDC *)
   end
   else lastformula.ptr := nil

(*$IFC DEBUGVERSION *)
   ;DebugMess(18)
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   PutValue - takes the value variant VALUE and stores it in the cell at `rowId, colId`.  The value will
              be stored within a rule or as a value depending upon the `inRrule` flag.  The `status`
              that could be returned would be OutOfMem or DSpaceErr for out of memory or disk space,
              meaning that the value could not be saved.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure PutValue
 (* rowId, colId : integer;             {location of the cell}
    value        : valueType;           {value to be saved into the cell}
    inrule       : boolean;             {does the value belong to a rule: y/n}
    var status   : integer              {error status number}
 *);
var cell        : cnRecord;                     {cell info}
    oldcnSize   : cnSizeKind;                   {prev size info for the cell}
    oldOhFmla   : TohFmla;                      {prev handle oh to the formula}
    oldLBits    : TCell;
    pValue      : TPValue;                      {ptr to the value info}
    hContents   : THContents;                   {handle to the cell info}
    numValue    : variantType;                  {packed version of `value`}
    typeOfNum   : numType;                      {type of packing used on NUMVALUE}
    forcedalloc : boolean;                      {force an alloc of the cell's value}
    allocsize   : integer;                      {size to allocate for the cell's value}
    opCode      : integer;                      {type of value to be allocated}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   DebugMess(15);
(*$ENDC *)

   {get the information for the cell}
   CellContents(mmRead, rowId, colId, false, cell, status);

   {set up default cell information}
   numValue       := value.val;
   cell.cnInvalid := inrule;
   cell.cnDollar  := false;
   cell.cnSymbol  := value.nan;
   allocsize      := sizeof(TVinfo) + (sizeof(TRule) - sizeOf(TValue)) * ord(inrule);
   oldcnSize      := sWord;

   {force an allocate of the new value if one does not already exist or if for a rule
    there exist a coordinate calculated through displacements (ala paste relative).  If
    a forced allocation is not done, the previous space the value occupied will be
    resized and reused.
   }
   with lastformula do
      forcedalloc := not((absolute or (refcnt = 1)) and inrule) or
                     (cell.cnInCopy and ((refcnt > 1) or not absolute)) or
                     (cell.cnHContents = nil);

   {get other info not received from the "CellContents" call.  This was done this way for speed.}
   if cell.cnHContents <> nil then
      with cell.cnHContents^^ do begin
         if cell.cnHasRule then begin
            oldOhFmla := rule.ohFmla;
            oldLBits  := rule.lBits
         end;
         cell.cnSize      := vinfo.data.TCsize;
         cell.cnIs1Marked := vinfo.data.marked1;
         cell.cnIs2Marked := vinfo.data.marked2
      end
   else begin
           cell.cnSize      := sSymbol;
           cell.cnIs1Marked := false;
           cell.cnIs2Marked := false
        end;

   {determine how the new value should be packed and stored}
   case value.nan of
      syDate  : typeOfNum := dateKind;
      syText  : typeOfNum := textKind;
      syParts : typeOfNum := partsKind;
      otherwise begin
                   packnum(value.val.lrealvar, numValue, typeOfNum);
                   oldcnSize := cell.cnSize
                end
   end;

   {setup non-default information}
   cell.cnSize := sSymbol;
   case typeOfNum of
      lRealKind : begin
                     cell.cnSize   := sLong;
                     cell.cnNumber := cNumber;
                     opCode        := PUSHLREAL
                  end;
      sRealKind : begin
                     cell.cnSize   := sShort;
                     cell.cnNumber := cNumber;
                     opCode        := PUSHSREAL
                  end;
      intKind,
      byteKind  : begin
                     cell.cnSize   := sWord;
                     cell.cnNumber := cNumber;
                     opCode        := PUSHINT;
                     if typeOfNum = byteKind then numValue.intvar := numValue.bytevar
                  end;
      partsKind : opCode := PUSHPARTS;
      dateKind  : opCode := PUSHDATE;
      textKind  : begin
                     opCode        := PUSHTEXT;
                     allocsize     := allocsize + value.val.textinfo.len + 1
                  end;
      nanKind   : begin
                     oldcnSize     := sWord;
                     opCode        := PUSHNOP
                  end
   end;

   {compute the amount of space needed for the new value and allocate it or re-used
    previously allocated space.
   }
   allocsize := allocsize + pcodesize[opCode];
   if not inRule and (opCode = PUSHTEXT) and (numValue.textinfo.len <= 0) then hContents := nil
   else if forcedalloc then hContents := allocBlock(allocsize)
   else if oldcnSize = cell.cnSize then hContents := cell.cnHContents
   else if cell.cnHContents <> nil then begin
           hContents := cell.cnHContents;
           ChangeBlockSize(@hContents^, allocsize, false, status);
           if status <> ok then hContents := nil
        end
   else hContents := allocBlock(allocsize);

   {copy the data into the space allocated for the value if space was available.  A
    nil in `hContents` when the `opCode` is PUSHTEXT is the way blank cells are created
   }
   if ((hContents = nil) and (opCode = PUSHTEXT)) or (hContents <> nil) then begin

      {get a direct pointer to the area for the value}
      if hContents <> nil then
         with hContents^^ do
            if inrule then pValue := @rule.value.bytes
            else pValue := @value.bytes;

      {set up proper information for a the opcode type and copy in data}
      case opCode of
         PUSHTEXT : if inRule or (hContents <> nil) then begin
                       numValue.ptrToData := @value.val.textinfo.hContents^^;
                       moveLfast(@numValue.ptrToData^[value.val.textinfo.index], @pValue^, value.val.textinfo.len);
                       numValue.ptrToData := @pvalue^;
                       numValue.ptrToData^[value.val.textinfo.len] := 0
                    end;
         PUSHNOP  : ;
         otherwise  moveLfast(@numValue, @pValue^, pcodesize[opCode]);
      end;

      {replace the handle oh for formulas/the reference count for values}
      if cell.cnHContents <> nil then
         if cell.cnHasRule then begin
            if inrule then
               with hContents^^.rule do begin
                  ohFmla := oldOhFmla;
                  lBits  := oldLBits
               end
            else DecRefCnt(cell.cnHcontents, true, hContents <> cell.cnHContents)  {3rd argument should always be true}
         end;

      {setup any last minute information and try to save the new value}
      cell.cnHasRule   := inrule;
      cell.cnHContents := hContents;
      cell.cnInCopy    := false;

      CellContents(mmWrite, rowId, colId, true, cell, status)
   end
   else if diskErr then status := DSpaceErr
   else status := OutOfMem

(*$IFC DEBUGVERSION *)
   ;if debug[11] then begin
      writeln(rowId:1,',',colId:1,'  PutValue: nan: ',wnan(value.nan),'  val: ',
              wNUM(value.val.lrealvar),' ',forcedalloc);
   end;
   DebugMess(16);
   StatusMess(status)
(*$ENDC *)

end;


(*$S calculator *)
procedure SetVisSnips;
var tempPtr    : ptrData;                       {kludge to clear the snipVis structure quickly}
    snip       : snipKind;                      {snip type within a particular view}
    loId, hiId : idType;                        {low and high snipIds visible in a particular view}
    row        : integer;                       {loop iterator}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   tempPtr  := @SnipVis;         {lets quickly zero the SnipVis array to false - its a packed structure}
   for loID := 0 to sizeof(SnipVis)-1 do tempPtr^[loId] := 0;

   {Set the SnipVis array to reflect the currect snip visible in all of the bands}
   tmSaveBands;
   repeat
      tmNextBandRg(snip, loId, hiId);                   {move from band to band}
      if loId <> nullsnip then begin                    {does information exist on what is visible}
         if loId = minfSnip then loId := 1              {determine the low/high extent of the band}
         else if loId = pInfSnip then loId := idMax;
         if hiId = minfSnip then hiId := 1
         else if hiId = pInfSnip then hiId := idMax;
         for row := loId to hiId do SnipVis[snip, row] := true  {save the information in `SnipVis`}
      end
   until loId = nullsnip;
end;


(***************************************.*******.********************************************************
   recalc - triggers a recalculation of the matrix.  `rowId, colId` are used to determine which cell
            was changed that triggered the recalculation.  This information is supplied during fast
            data entry, otherwise both coordinates are set to -1.

            "recalc" also sets up the `SnipVis` structure which tells if a given snip, snipId is
            visible of the screen.  This structure is used to make sure unnecessary drawing is not
            done.

            During recalculation, there is a possibility that not enough space will be available to
            save the recalculated valued, thus `status` could also be set to OutOfMem or DSpace error
            to signal that  condition.  Additionally, `status` would be set to RecalcErr to signal
            that the results from the recalculation may not be correct, more passes might be necessary.
****************************************.*******.*******************************************************)
(*$S calculator *)
procedure recalc
  (* rowId, colId : idType;             {location of the cell that changed}
     var status   : integer;            {error status number}
     inrule       : boolean             {does the cell have a newly entered rule: y/n}
  *);
var rg : range;                {range which represents the location of the cell that changed}
    x  : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   for x := 1 to 10 do timeclear(x);
   timestart(4);
(*$ENDC *)

   calcTime := time;            {start the calculation timer}
   SetVisSnips;

   {Do the recalculation if the recalculation flag is on, otherwise just update the display}
   status := ok;
   if recalcflag then begin
      case circleState of
         cMissing,
         cCircular,
         cDependent : SetRgBits(rg, BNone, true, 2)
      end;
      recalc2(status)
   end
   else begin

           {determine if only one cell has changed,  if so the cell will be set not invalid and only
            it will be drawn.  Otherwise, the entire matrix will have to be scanned to clear any
            invalid cells.
           }
           if CoordInMatrix(rowId, colId) then begin
              SetCellBit(rowId, colId, false, BInvalid);
              displayCell(rowId, colId);
              if app.BusGraph and imageflag then FxNewRgImg
           end
           else SetRgBits(rg, BInvalid, false, 6 + ord(app.BusGraph))
        end;
   calcTime := time - calcTime          {compute the total recalculation time}

(*$IFC TIMEVERSION *)
   ;writeln('recalc time: ',calcTime);
(*$ENDC *)
(*$IFC DEBUGVERSION *)
   ;timestop(4);
   StatusMess(status);
   if debug[20] or debug[5] then meminfo(-1, -1, false)
(*$ENDC *)

end;

