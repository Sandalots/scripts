

                            {'Copyright 1983, 1984, Apple Computer Inc.'}

(***************************************.*******.********************************************************
   FindStr - returns a range `rg` which is the location of the next circled cell in the matrix.
             `rg` is passed in containing the location of the current selection.  The next circled
             cell is found by scanning the remaining columns in the current row and proceeding to the
             next row until the end of the matrix is reached.  If a  circled cell does not exist, a
             Null range will be returned.
****************************************.*******.*******************************************************)
(*$S FindDiBox *)
procedure FindStr(* rg : range *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   SetRgBits(rg, BNone, true, 14)
end;


(***************************************.*******.********************************************************
   FirstCell - returns a range `rg` which is the location of the next circled cell in the matrix.
               `rg` is passed in containing the location of the current selection.  The next circled
               cell is found by scanning the remaining columns in the current row and proceeding to the
               next row until the end of the matrix is reached.  If a  circled cell does not exist, a
               Null range will be returned.
****************************************.*******.*******************************************************)
(*$S Circling *)
procedure FirstCell
  (* var rg     : range                 {location of the current selection/location of next cell}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   SetRgBits(rg, BCircle, true, 4)
end;


(***************************************.*******.********************************************************
   FixRange - takes a range, `rg`, and makes sure it is a valid range type.  `rg.rKind` must be set to
              the type of range desired and any patricular information about the range must be filled in.
              (i.e., for a column range the low/high column information should be filled in and "FixRange"
              will fill in the low/high row information).  Valid range syntax can be found in the
              table manager.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure FixRange
  (* var rg : range                     {range to be fixed}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with rg do
      case rKind of
         a1CellRg : begin
                       hiRow := loRow;
                       hiCol := loCol
                    end;
         aNullRg  : begin
                       loRow := nullSnip;
                       hiRow := nullSnip;
                       loCol := nullSnip;
                       hiCol := nullSnip
                    end;
         aWTBoxRg : begin
                       loRow := mInfSnip;
                       hiRow := pInfSnip;
                       loCol := mInfSnip;
                       hiCol := pInfSnip
                    end;
         aRowRg,
         aRowGrid : begin
                       loCol := mInfSnip;
                       hiCol := pInfSnip
                    end;
         aColRg,
         aColGrid : begin
                       loRow := mInfSnip;
                       hiRow := pInfSnip
                    end
      end
end;


(***************************************.*******.********************************************************
   GetModeInfo - returns the internal matrix manager mode information.  `flags` is the state of the modes
                 the matrix manager is operating in.  It does not include all the modes of the matrix
                 manager, just those the outside world might be interested in.  This is done through
                 a procedure because the outside world should not be able to change the matrix manager
                 modes except through defined procedure calls.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure GetModeInfo
  (* var flags : ModeInfo              {matrix manager mode information}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with flags do begin
      fInVals     := FindInVals;
      fInForms    := FindInForms;
      pState      := printState;
      calcMode    := recalcflag;                {recalculation mode}
      circleMode  := CircleState;               {show circles mode}
      formulaMode := tblPars.shoFormula;        {show formulas mode}
      Tfid        := CT^.TableFont;             {current table font}
      application := appType                    {application type}
   end
end;


(***************************************.*******.********************************************************
   GetOH -
****************************************.*******.*******************************************************)
function GetOH
  (* addr : longint
  ) : integer *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetOH := aGetOH(addr - ord(mxHz))
end;


(***************************************.*******.********************************************************
   GetRefCnt - returns the current reference count for the formula or cell pointed to by the handle
               `hContents`.  `inrule` states wheter the reference count for a cell or a formula is
               desired.  If `hContents` is nil or the rule is not shared, the reference count will
               be a mInfSnip.

   NOTE: if `inrule` is true, "GetRefCnt" assumes that the cell pointed to by `hContents` in fact, has
         a rule.  If it does not, that almost gurantees a bus error or address error.
****************************************.*******.*******************************************************)
(*$S LCmatMgrSeg *)
function  GetRefCnt
  (* hContents : THContents;            {handle to the cell data to get reference count for}
     inrule : boolean                   {return reference count information for the formula: y/n}
  ) : integer *);                       {current reference count}
var rule : THFmla;                              {pointer to the rule for the cell}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetRefCnt := mInfSnip;               {set default reference count}
   if hContents <> nil then             {does the cell data exist?}
      if inrule then begin
         rule := pointer(MakeHnd(hContents^^.rule.ohfmla));          {get pointer to the rule}
         with rule^^ do
            if shared <> fSingle then                                   {if the rule is shared, get reference count}
               GetRefCnt := sdata.info.refcnt
      end
      else GetRefCnt := hContents^^.vinfo.data.refcnt                   {get the cell reference count}
end;


(***************************************.*******.********************************************************
   GetSnipId - returns the `snipId` of a `snip` determined by `mode` within the current table:
                  mmFirst, mmLast   - 1, idMax
                  mmNext, mmPrior   - `refId` +/- 1
                  mmFraction        - wholeSize*`position`, where `position` in [0..1000]

               "GetSnipId" is used mostly bythe table editor to determine information about snipIds and
               there neighboring snipIds.  The current table may be the main matrix or the scrap
               depending upon what `CT` is pointing to.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure GetSnipId
  (* snip       : snipKind;             {type of information desired: row or column}
     mode       : idModeType;           {mode of information desired: first/last...}
     position   : fract;                {position in [0..1000] for fraction oper}
     refId      : idType;               {reference snip for next/prior oper}
     var snipId : idType                {resulting snip information}
  *);
var highSnip : integer;                         {highest snipId in the current table}
    lowSnip  : integer;                         {lowest snipId in the current table}
    temp     : longint;                         {used to calculate the mmFraction position}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with CT^ do begin
      highSnip := idMax;                {set up the high/low snipIds of the current table}
      lowSnip  := 1;
      if SnipBds.rKind <> aWTBoxRg then
         if (snip = rowKind) and (SnipBds.rKind <> aColRg)  then begin
            highSnip := SnipBds.hiRow;
            lowSnip  := SnipBds.loRow
         end
         else if (snip = colKind) and (SnipBds.rKind <> aRowRg) then begin
                 highSnip := SnipBds.hiCol;
                 lowSnip  := SnipBds.loCol
              end;

      {based on `mode` determine what snipId should be returned}
      case mode of
         mmfirst    : snipId := lowSnip;
         mmlast     : snipId := highSnip;
         mmnext     : if refId = mInfSnip then snipId := lowSnip
                      else if refId = pInfSnip then snipId := pInfSnip
                      else if refId < highSnip then snipId := refId + 1
                      else snipId := pInfSnip;
         mmprior    : if refId = mInfSnip then snipId := mInfSnip
                      else if refId = pInfSnip then snipId := highSnip
                      else if refId > lowSnip then snipId := refId - 1
                      else snipId := mInfSnip;
         mmfraction : begin
                         temp := Cmin(Cmax(position, 1), 1000);
                         temp := highSnip * temp div 1000;
                         if temp < 1 then temp := 1;
                         snipId := temp
                      end
      end
   end
end;


(***************************************.*******.********************************************************
   GetStatusInfo - switches to display either the scrap or the main table.
****************************************.*******.*******************************************************)
(*$S StatusDiBox *)
procedure GetStatusInfo{itemNum : integer; var statusRec : statusInfo};
var rowId   : integer;
    col     : integer;
    hVecCel : THVecCel;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with statusRec do begin
      case itemNum of
         1, 2 : begin
                   scrapHeapSize := scrapSize;
                   modelSize     := mmMemSize - mxHz^.cbFree - scrapHeapSize - 4 * (mxHz^.ippoolmac - numHandles)
                end
      end;
      valueCount   := 0;
      formulaCount := 0;
      case itemNum of
         3, 4 :  for rowId := 1 to idMax do
                    if vecSnip[rowKind, rowId] <> absent then begin
                       hVecCel := hVecOfRow(rowId);
                       for col := 1 to cStoredCols do
                          with hVecCel^^[col] do begin
                             if attributes.pkHasRule then formulaCount := formulaCount + 1
                             else if oh <> 0 then valueCount := valueCount + 1
                          end
                    end
      end
   end
end;


(***************************************.*******.********************************************************
   GetValue - retrieves the information about the value at `rowId colId`.  The information will be
              unpacked and returned via the packing/unpacking value variant `result`.  The form that the
              information is returned is depended upon `fullinfo`.  With `fullinfo` true, the actual
              value or else a descriptor to how to get the actual value will be returned.  The descriptor
              result normally is a result from the value being not-a-number (i.e., text).  `fullinfo`
              set to false, will return a zero for some cases where a descriptor would have otherwise been
              returned (this information is dependent upon the application; LisaCalc will get different
              results than Business Graphics).  See "unPackValue" for a description of what `fullinfo` does.
              `result` will return the following information:

                   result.nan           type of information returned.  Describes how to read `result.val`.
                   result.pCel          pointer to the cell information `result.val` comes from.
                   result.val           packing/unpacking variant that contains the actual value.  To
                                        determine the value, `result.nan` needs to be consulted.  See
                                        "unPackValue" for a description of the values returned.

              If an assumption was made about the data such that a zero was returned instead of the
              actual value and circle mode is on, the cell's circle bit will be set to true (i.e., the
              cell was blank or `fullinfo` was not returned about the cell.

   NOTE: see "unPackValue" for a more complete description of how `result` and FP0 are setup.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure GetValue
  (* rowId, colId  : integer;           {location of cell}
     fullinfo      : boolean;           {return full description on value: y/n}
     var result    : valueType          {value stored for the cell}
  *);
var hContents : THContents;                     {handle to cell data}
    tval      : TPValue;                        {pointer to cell's value}
    assume    : boolean;                        {assumption made about data: y/n}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   DebugMess(34);
(*$ENDC *)
   assume      := true;                                 {assume an assumption will be made}
   result.pCel := FindPcel(rowId, colId, false);        {get pointer to cell information}
   result.nan  := syNone;                               {assume the result will be a zero so set the type}
   result.val.xrealvar := xVofZero;                     {and set the value}

   hContents := GetHContents(result.pCel);   {get handle to the cell data}
   if hContents <> nil then begin            {does the cell data exist?}
      with hContents^^ do
         if result.pCel^.attributes.pkHasRule then tval := @rule.value       {get pointer to the cell's value}
         else tval := @value;
(*$IFC DEBUGVERSION *)
      if debug[11] then write(rowId:1,',',colId:1,'  ');
(*$ENDC *)
      unPackValue(hContents, tval, fullinfo, result, assume);                {unpack the value information}
   end;
   if assume and (circleState = cMissing) then
      SetCirBit(rowId, colId, true, true);                             {set the circle bit if an assumption was made about the value}

(*$IFC DEBUGVERSION *)
   ;DebugMess(35)
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   MakeHND -
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function MakeHND
   (* oh : integer
   ) : longint *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   MakeHND := aMakeHnd(oh) + ord(mxHz)
end;


(***************************************.*******.********************************************************
   mmBreakSnip - returns true if a page break (forced or optional) is set for the snip given.  `aKind`
                 is the snip type, `aSnip` is the snipid.

   NOTE: if the `usingScrap` is true, page breaks will always be off.
****************************************.*******.*******************************************************)
(*$S pBreakCode *)
function  mmBreakSnip
  (* aKind : snipKind;                  {type of information desired: row or column}
     aSnip : idType                     {snipId to check for a page break}
  ) : boolean *);                       {was a page break set: y/n}
var temp : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if printSelection then temp := false
   else temp := mmPageBreak(false, aKind, aSnip);
   mmBreakSnip := (mmPageBreak(true, aKind, aSnip) or mmPageBreak(false, aKind, aSnip)) and not(usingScrap or printState.preview)
end;


(***************************************.*******.********************************************************
   mmMapSnip - maps `oldSnipId` into a `newSnipId` with the type of mapping being returned through
               `status`.  The type of snip of `oldSnipId` is of the type that `snip` describes.  The
               mapping comes in three flavors:

                  mmRename      `oldSnipId` has been renamed to the `newSnipId`
                  reDel         `oldSnipId` does not exist
                  rmOk          `oldSnipId` has not changed thus is equal to `newSnipId`

               This mapping is done whenever a cut/paste/insert is done on the matrix.  The type of
               snipId that is to be mapped is passed through `snip`.  The actual mapping information
               is accessed through `pVector`.  This pointer is not nil only when a cut/paste/insert
               operation is being done (only when mapping information is valid).

   NOTE: the remapping is only valid during the progress of the cut/paste/insert operation.  Once the
         operation is done, the remapping will always return rmOk for `status`.
****************************************.*******.*******************************************************)
(*$S CutPaste *)
procedure mmMapSnip
  (* snip          : snipKind;          {type of snips to be remapped}
     oldSnipId     : idType;            {the old snipId to be remapped}
     var newSnipId : idType;            {the resulting new snipId}
     var status    : integer            {mapping status}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   status    := rmOk;
   newSnipId := oldSnipId;
   if pVector <> nil then begin
      newSnipId := pVector^[snip, oldSnipId].newSnipId;
      status    := pVector^[snip, oldSnipId].mapType;
      if status = 0 then status := pInfSnip
   end

(*$IFC DEBUGVERSION *)
   ; if debug[7] then begin
      write('mmMap(',pVector <> nil,'): ',wSnip(snip),':',oldSnipId:1,',',newSnipId:1,'  status: ');
      case status of
         rmRename : writeln('rmRename');
         rmOk     : writeln('rmOk');
         rmDel    : writeln('rmDel')
      end;
   end
(*$ENDC *)

end;


(***************************************.*******.********************************************************
   mmPageBreak - returns true if a page break is set for the `snip` and `snipId` given.  `snip` is the
                 type of snip (row or column) and `snipId` is the id within that snip.  `forced` states
                 wheter to check for a forced break entered by the user or optional page break.

    NOTE: page break information may exist in the undo state information.  In this case infromation is
          read from the undo state information instead of the information in `vecBreaks`.
****************************************.*******.*******************************************************)
(*$S pBreakCode *)
function  mmPageBreak
  (* forced : boolean;                  {check forced page breaks: y/n}
     snip   : snipKind;                 {type of information desired: row or column}
     snipId : integer                   {snipId to check for a page break}
  ) : boolean *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   mmPageBreak := vecBreaks[forced, snip, snipId];      {get page break information}

   {if an page break undo state exists, check to see if the requested page break information is in the
    range of breaks specified in the undo information.  If so the information is derived from the undo
    information.
   }
   with mmUndoInfo do
      if (op = uBreak) and state then                   {is a page break undo in affect? y/n}
         if forced = info.forced then begin
            if rg.rKind = aWTBoxRg then mmPageBreak := false    {whole table boxes are always false}
            else if (snipId >= info.lowsnip) and (snipId <= info.highsnip) and (snip = info.snipinfo) then
                    if snipId = info.lowsnip then mmPageBreak := info.state
                    else mmPageBreak := false
         end
end;


(***************************************.*******.********************************************************
   mmSetBreak - allows a page break to be set.  Either an automatic page break or a user specified break
                may be set.  The type of page break to be set is specfied by `forced`.  `aRg` specfies
                the range of snips to be affected and `state` is the state the page break should be set
                to.  The page break information is stored in `vecBreaks` but is not set directly by
                "mmSetBreak" if `forced` is true for a user set page break.  "mmSetBreak" sets up the
                undo state information which will later be incorporated into `vecBreaks` by "claimUndoInfo"
                if the user does not undo the operation.  If the user does decide to undo the operation,
                only the undo state information need be cleared, not the `vecBreaks` information.

   NOTE: the only range types accepted by "mmSetBreak" are aColRg, aColGrid, aRowRg, aRowGrid or aWTBoxRg.
         The validation of the range type should be done by the calling routine if necessary.
****************************************.*******.*******************************************************)
(*$S pBreakCode *)
procedure mmSetBreak
  (* forced  : boolean;                 {set a forced page breaks: y/n}
     state   : boolean;                 {set or clear the break: y/n}
     aRg     : range                    {range of snips to be affected}
  *);
var temp : UndoRec;                             {last undo state information}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   temp := mmUndoInfo;                          {remember the last undo state information}
   if forced then claimUndoBuffer(true);        {claim any undo information}
   mmUndoInfo.op := uBreak;                     {set up new undo state information for a page break}
   mmUndoInfo.rg := aRg;                        {set the range of cells selected}
   mmUndoInfo.state       := true;              {inable the undo state information}
   mmUndoInfo.info.state  := state;             {was page breaks being set or cleared: y/n}
   mmUndoInfo.info.forced := forced;            {was it forced or automatic page breaks: y/n}
   with mmUndoInfo.info do begin                {set up high/low snipId information}
      SetHighLowSnip(aRg, lowsnip, highsnip, snipinfo, 1);
      case aRg.rKind of
         aRowGrid,
         aColGrid : lowsnip := highsnip
      end
   end;

   {if an automatic page break was being set, the information must be incorporate immediately into `vecBreaks`
    and theoriginal undo state information restored.  Otherwise, when automatic breaks are recomputed, what
    is considered undoable will not be correct.
   }
   if not forced then begin
      SetVecBreaks;
      mmUndoInfo := temp
   end
end;


(***************************************.*******.********************************************************
   mmSetWids - turns on/off the show formulas mode based on the state of `shoFormula`.  "mmSetWids" will
               cause row title heights and column widths to be recomputed to display the formulas.  When
               show formulas mode is turned off heights and widths will return to normal.

    NOTE: when in show formulas mode, the column widths are forced to be greater or equal to the number
          characters specified in `dftColWidth`.
****************************************.*******.*******************************************************)
(*$S showForms *)
procedure mmSetWids
  (* tableStyle : tblMode               {turn of/off showformulas mode: y/n}
  *);
var x         : integer;
    rg        : range;
    inPreview : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if tableStyle <> tPreview then TblPars.shoFormulas := (tableStyle = tFormulas);   {set state information}
   inPreview          := printstate.preview;
   printstate.preview := (tableStyle = tPreview);
   tableState         := tableStyle;
   if tableStyle <> tPreview then
      with printstate do begin
         pColHeadings := (tableStyle <> tValues);
         pGrids       := pColHeadings
      end;

   with CT^ do begin
      if printstate.preview then begin
         snipBds.hiRow := 1;
         for x := 1 to lastSnip[rowKind] do
            if mmPageBreak(true, rowKind, x) or mmPageBreak(false, rowKind, x) then snipBds.hiRow := snipBds.hiRow + 1;
         snipBds.hiCol := 1;
         for x := 1 to lastSnip[colKind] do
            if mmPageBreak(true, colKind, x) or mmPageBreak(false, colKind, x) then snipBds.hiCol := snipBds.hiCol + 1
      end
      else begin
              snipBds.hiRow := idMax;
              snipBds.hiCol := idMax
           end;

      if inPreview then begin
         moveLfast(@PRinfo, @FBufBuffer[0], sizeof(PRinfo));            {restore the table editor info}
         RWTabledata(mmRead, tblPars)                                   {and read it back into the table editor}
      end
      else if printstate.preview then begin
              RWTabledata(mmWrite, tblPars);                            {remember the table editor info}
              moveLfast(@FBufBuffer[0], @PRinfo, sizeof(PRinfo));       {and save it in PRinfo - which is not used right now}
              rg       := SnipBds;
              rg.rKind := a1CellRg;
              ReBldTbl(rg)
           end
   end;

   if TblPars.shoFormulas then begin
      claimUndoBuffer(true);            {claim any undo information}
      NumOfFormulaFolds                 {compute the heights and widths or rows and columns}
   end
   else FillConst(@dftWidth[rowKind], sizeof(integer), @vecWid[rowKind, 0], 1, idMax)
end;


(***************************************.*******.********************************************************
   NextCell - returns a 1-cell range in `nxtCell` depending on the value of `mode` and on the upper-left
              corner of `curCell`.  The two range arguments may be the same variable.  `mode` may be:

                 mmRight mmLeft mmUp mmDown - obvious
                 mmNone                     - same cell
                 mmBegOfRow                 - beginning of next row.

   NOTE: The only range types accepted by "NextCell" are aColHedRg, a1CellRg or aRowHedRg.  The
         validation of the range types should be done by the calling routine if necessary.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure NextCell
  (* mode        : mcType;              {direction to move}
     curCell     : range;               {location of current selection}
     var nxtCell : range                {new location of the selection based upon `mode`}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with nxtCell do begin
      rKind := curCell.rKind;
      loRow := curCell.loRow;
      loCol := curCell.loCol;
      case mode of
         mmLeft     : if curCell.rkind <> aRowHedRg then loCol := CMax(loCol-1, 1);
         mmRight    : if curCell.rkind <> aRowHedRg then loCol := CMin(loCol+1, idMax);
         mmUp       : if curCell.rkind <> aColHedRg then loRow := CMax(loRow-1, 1);
         mmDown     : if curCell.rkind <> aColHedRg then loRow := CMin(loRow+1, idMax);
         mmBegOfCol : begin
                         loCol := CMin(loCol+1, idMax);
                         loRow := 1
                      end;
         mmBegOfRow : begin
                         loRow := CMin(loRow+1, idMax);
                         loCol := 1
                      end
      end;
      hiRow := loRow;
      hiCol := loCol
   end
end;


(***************************************.*******.********************************************************
   NextFormula -
****************************************.*******.*******************************************************)
(*$S LCcalculator *)
function NextFormula
   (* var rowId,
          colId     : idType;              {location of cell}
   ) : boolean *);
label 3;
var hVecCel   : THVecCel;
    col       : TidRng;
    lastRowId : integer;
    lastColId : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   NextFormula := false;
   with CT^ do begin
      lastRowId := lastSnip[rowKind];
      lastColId := lastSnip[colKind]
   end;

   repeat
      if vecSnip[rowKind, rowId] <> absent then begin
         hVecCel := hVecOfRow(rowId);
         repeat
            colId := colId + 1;
            if colId > lastColId then goto 3
            else begin
                    col := vecSnip[colKind, colId];
                    if col <> absent then
                       with hVecCel^^[col] do
                          if attributes.pkHasRule then begin
                             NextFormula := true;
                             exit(NextFormula)
                          end
                 end
         until false
      end
      else begin
           3: colId := 0;
              rowId := rowId + 1
           end
   until rowId > lastRowId
end;


(***************************************.*******.********************************************************
   RginScrap - returns the range describing the cells in the scrap.  If a scrap does not exist, aNullRg
               is returned.
****************************************.*******.*******************************************************)
(*$S scrapCode *)
procedure RginScrap
  (* var rg : range                     {range of cells in the scrap}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if ScrapPtr <> nil then rg := ScrapInfo^.SnipBds
   else rg.rKind := aNullRg;
   FixRange(rg)                 {insure a valid range is returned}
end;


(***************************************.*******.********************************************************
   ScrapAbsent - returns true if there is nothing in the local scrap.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function ScrapAbsent(* : boolean *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   ScrapAbsent := (ScrapPtr = nil)
end;


(***************************************.*******.********************************************************
   SetCellAttr - allows the attributes `attrRec` to be set for a particular `field` for the cells in
                 `rg`.  The attribute information is stored in `vecAttrs` and/or the attributes for the
                 cells given in `rg` but is not set directly by "SetCellAttr".  "SetCellAttr" sets up
                 the undo state information which will later be incorporated into `vecAttrs` by
                 "claimUndoBuffer" if the user does not undo the operation.  If the user does
                 decide to undo the operation, only the undo state information need be cleared, not the
                 `vecAttrs` and/or cell attribute information.  The screen will be refreshed to display
                 the new attributes unless protection is being (protection does not change the screen
                 image).
****************************************.*******.*******************************************************)
(*$S attributes *)
procedure SetCellAttr
  (* attrRec    : attrRecord;           {unpacked attribute information}
     field      : attrType;             {type of information to be stored}
     rg         : range                 {range of cells to be affected}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   claimUndoBuffer(true);                               {claim any undo information}
   expandrange(rg, true);                               {expand `rg` to represent the whole matrix}
   if rg.rKind = aWTBoxRg then rg.rKind := aColRg;      {a whole table box is changed to be aColRg}
   mmUndoInfo.op := uAttr;                              {set up new undo state information for a attributes}
   mmUndoInfo.rg := rg;                                 {set the range of cells selected}
   mmUndoInfo.state        := true;                     {inable the undo state information}
   mmUndoInfo.info.field   := field;                    {remember which field was being changed}
   mmUndoInfo.info.attrRec := attrRec;                  {remember what attributes was being changed}

   if field <> aProtect then begin
      if (field = aAlign) and (circleState = cInvis) then SetCircleMode(cInvis);
      DisplayRange(rg)                                  {refresh the screen to display the new formatting}
   end
   else if circleState = cProtect then SetCircleMode(cProtect)
end;


(***************************************.*******.********************************************************
   SetCellBit - allows a particular bit `bitType` to be set for the cell at `rowId, colId` if the cell
                exists.  If the cell does not exist, nothing is set.  However, if a circle bit is being
                set, the cell will be allocated if it does not exist such that the bit can be set and
                the cell circled.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure SetCellBit
  (* rowId, colId : idType;             {location of the cell}
     state        : boolean;            {state to set the bit to}
     bitType      : bitKind             {which bit to set}
   *);
var pCel      : TPCel;                          {ptr to the cell informatiom}
    hContents : THContents;                     {handle to the cell data}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   pCel := FindPCel(rowId, colId, (circleState = cMissing) and (bitType = BCircle) and state);
   if pCel <> nil then                                          {does the cell exist?}
      with pCel^ do
                                                                {these bits are directly off the pointer to the cell}
         case bitType of                                        {set the state of the appropriate bit}
            BInvalid  : attributes.pkInvalid := state;
            BCircle   : attributes.pkCircle  := state;
            BInCopy   : attributes.pkInCopy  := state;
            otherwise   if oh <> absent then begin              {these bits are off the handle to the cell data}
                           hContents := GetHContents(pCel);     {get handle to the cell}
                           with hContents^^.vinfo.data do       {set the state of the appropriate bit}
                              case bitType of
                                 BCellSeen : cellseen := state;
                                 B1Marked  : marked1  := state;
                                 B2Marked  : marked2  := state
                              end
                        end
         end
end;


(***************************************.*******.********************************************************
   SetCharInfo - sets up the row/col widths and height for the table display dependent upon the font
                 information given in `fontId`.

   NOTE: changing the table font might cuase the coulmn widths to be recomputed.
****************************************.*******.*******************************************************)
(*$S FontChanging *)
procedure SetCharInfo
  (* fontId : TLfntId                   {font information}
  *);
var fError : integer;                           {font manager error flag}
    colId  : integer;                           {snipId of column whoses width is to be changed}
    fInfo  : FontInfo;                          {font information record}

(*$IFC DEBUGVERSION *)
    (*$S debug2 *)
    procedure dumpinfo;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       writeln('linespace,ascent,width: ',fInfo.Ascent + finfo.Descent + finfo.Leading:1,
               ',',fInfo.ascent:1,',',finfo.widMax:1);
       writeln('Rows: Title height: ',dftRowHeight:1,'  Title Width: ',ct^.rowTitleWdth:1,
                   '  dftWidth: ',dftWidth[rowKind]:1);
       writeln('Cols: Title height: ',ct^.colTitleHght:1,'  dftWidth: ',dftWidth[colKind]:1,
                   '  maxwidth: ',91 * finfo.widmax,'  minFormWidth: ',minFormWidth:1);
    end;
(*$ENDC *)


(*$S FontChanging *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if FMFontMetrics(fontId, fInfo, fError) then begin           {get font information record from FontMgr}

      {This information is used when "SnipWidth" is asked about row/column title widths}
      with CT^ do begin
         RowTitleWdth  := 4 * finfo.widMax;                     {row title widths is 4 * a character width}
         ColTitleHght  := fInfo.ascent + 3;                     {column title height has no descenders or leading in column titles}
      end;

      {`dftRowHeight` is the minimum height of a row in show formulas mode}
      dftRowHeight      := fInfo.ascent + finfo.Descent;        {row height does not include leading}

      {`dftWidth` is used primarilty when set default table widths for new rows/columns or show formulas
       mode.  The default row height comes from `dftRowHeight` and the default column width is
       a character width * the default # of chrs in a column + some padding.
      }
      dftWidth[colKind] := fInfo.widMax * dftColWidth + TblPars.FieldPad;
      dftWidth[rowKind] := dftRowHeight;

      {depending upon the state that the matrix is in,  the column width may have to change or reset based
       on the new table font.
      }
      case matState of
         mmOpen  : begin
                      claimUndoBuffer(true);
                      for colId := 1 to idMax do
                         ChgSnipWidth(vecWid[colKind, colId], TabFWidth.w, fInfo.widMax)
                   end;
         mmClose : FillConst(@dftWidth[colKind], sizeof(integer), @vecWid[colKind, 0], 1, idMax)
      end;

      {`TabFWidth` is used all over the place!!!
           h = height = a full character height
           W = width  = a character width
      }
      TabFWidth.h  := fInfo.Ascent + finfo.Descent + finfo.Leading;
      TabFWidth.w  := fInfo.widMax;

      {`minFormWidth` is the minimum column width in show formulas mode}
      minFormWidth := TabFWidth.w * dftSFwidth;

      {set genreal table information which is used all over the place!!!}
      with CT^ do begin
         TableFont := fontId;
         fWidths   := TabFWidth
      end;

      {reset the row heights to their defaults}
      FillConst(@dftWidth[rowKind], sizeof(integer), @vecWid[rowKind, 0], 1, idMax);

      {and if in show formula mode recompute the row heights and column widths}
      if (matState <> mmClose) and tblPars.shoFormula then mmSetWids(tformulas)

(*$IFC DEBUGVERSION *)
      ;if traceMMgr or debug[5] then dumpinfo
(*$ENDC *)
   end
(*$IFC DEBUGVERSION *)
   else FatalMess(19)
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   SetCircleMode - turns on/off the circling modes.  If circle mode is being turned off, all circled cells
                   will be uncircled.
****************************************.*******.*******************************************************)
(*$S Circling *)
procedure SetCircleMode
  (* state : circleType;
  *);
var rg        : range;
    rgMode    : integer;
    orderMode : orderType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   circleState := state;
   rgMode      := 0;
   orderMode   := lCalc;
   SetRgBits(rg, BNone, true, 2);
   case circleState of
      cError     : rgMode    := 12 * ord(doingMove);    {circle any cells involved in a move}
      cInvis     : rgMode    := 11;                     {circle any invisible cells}
      cProtect   : rgMode    := 13;                     {circle any protected cells}
      cDependent : orderMode := lDependent;             {circle any cells dependent upon the selection}
      cCircular  : orderMode := lCircular;              {circle any cells in a circular reference}
   end;
   if rgMode <> 0 then SetRgBits(rg, BNone, true, rgMode);
   if orderMode <> lCalc then begin
      formulaChanged := true;
      detLogOrder(orderMode)
   end;
   if circleState <> cMissing then begin
      SetVisSnips;
      SetRgBits(rg, BInvalid, false, 6)
   end
end;


(***************************************.*******.********************************************************
   SetImage - turn on or off the redrawing of calculated results in view seperate from the table (ie, in
              the Business Graphics graph pane).  This is primarilily used during fast data entry such
              that the graph in BG in not displayed while the numbers are being entered.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure SetImage(* state : boolean *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   imageflag := state
end;


(***************************************.*******.********************************************************
   SetMapVectors - set of the map vector `vector`.  This vector is setup whenever a cut/paste/insert
                   is done on the matrix.  All of the snipIds are represented
   mmMapSnip - maps `oldSnipId` into a `newSnipId` with the type of mapping being returned through
               `status`.  The type of snip of `oldSnipId` is of the type that `snip` describes.  The
               mapping comes in three flavors:

                  mmRename      `oldSnipId` has been renamed to the `newSnipId`
                  reDel         `oldSnipId` does not exist
                  rmOk          `oldSnipId` has not changed thus is equal to `newSnipId`

               This mapping is done whenever a cut/paste/insert is done on the matrix.  The type of
               snipId that is to be mapped is passed through `snip`.  The actual mapping information
               is accessed through `pVector`.  This pointer is not nil only when a cut/paste/insert
               operation is being done (only when mapping information is valid).

   NOTE: the remapping is only valid during the progress of the cut/paste/insert operation.  Once the
         operation is done, the remapping will always return rmOk for `status`.
****************************************.*******.*******************************************************)
(*$S CutPaste *)
procedure SetMapVectors
  (* var vector : mapInfoRec
  *);
var snip      : snipKind;
    rename    : boolean;
    snipId    : idRange;
    lowSnip   : integer;
    highSnip  : integer;
    reMapDisp : integer;
    tempId    : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   for snip := rowkind to colKind do begin
      if reMapLevel <= 0 then lowSnip := idMax + 1
      else if snip = rowKind then begin
              highsnip := reMapRg.hiRow;
              lowsnip  := reMapRg.loRow
           end
      else begin
              highsnip := reMapRg.hiCol;
              lowsnip  := reMapRg.loCol
           end;
      reMapDisp := highsnip - lowsnip + 1;
      if reMapSrc <> mmBlank then reMapDisp := -reMapDisp;
      if highsnip = pInfSnip then highsnip := idmax;
      if lowsnip  = mInfSnip then lowsnip  := 1;

      for snipId := 1 to idMax do
         with vector[snip, snipId] do begin
            rename    := false;
            newSnipId := snipId;
            mapType   := rmOk;
            if snipId < lowSnip then mapType := rmOk
            else if snipId > highSnip then rename := true
            else if reMapSrc <> mmBlank then mapType := rmDel
            else rename := true;
            if rename then begin
               if (reMapDisp <> 0) and (reMapRg.rKind <> a1CellRg) and (reMapRg.rKind <> aRectRg) then begin
                  mapType   := rmReName;
                  tempId    := snipId + reMapDisp;
                  if tempId > idMax then tempId := 0;
                  newSnipId := tempId
               end
            end
         end
   end
end;


(***************************************.*******.********************************************************
   SetReCalc - turn on or off recalculation mode.  With recalculation turned off, the matrix will not be
               updated when a cell value is changed or when a cut/paste is done.  The matrix is also
               calculated on demand through this routine by setting `state` to mmCalcNow.  `state` is
               set to mmCalcMan to turn off recalculation and mmCalcAuto for automatic recalculaton.
****************************************.*******.*******************************************************)
(*$S LCmatMgrSeg *)
procedure SetReCalc(* state : calcState *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   reCalcNow  := (state = mmCalcNow);
   reCalcFlag := (state <> mmCalcMan)
end;


(***************************************.*******.********************************************************
   SetRgBits - a short hand routine to blitz through the entire matrix and do things dependent upon the
               `action` given:

                0 - Clears the marker bits for the cells in the specified range.
                1 - Sets the invalid bit for the cells in the specified range.
                2 - Finds cells which are circled.  Clears their circle bit and sets them cell to invalid.
                3 - Swaps the cell moved marking bits.
                4 - Finds the next circled cell that does not contain a rule.
                5 - Sets the attributes for the cells.
                6 - Finds cell which are invalid.  Clears their invalid bit and causes them to be displayed.
                7 - Same as 6 with the addition that Business Graphics is told to change its structures.
                8 - clears cell seen and invalid bits.
                9 - returns the location of the first protected cell found in rg
               10 - clears cell seen bits.
               11 - sets the circle bits for the cells that are invisible.
               12 - sets the circle bits for the cells that are involved in a move.
               13 - sets the circle bits for the cells that are protected.
               14 -
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure SetRgBits
  (* var rg  : range;
     bitType : bitKind;
     state   : boolean;
     action  : byte
  *);
label 1,2;
var row, col  : integer;
    colId     : integer;
    direc     : integer;
    loopStart : integer;
    loopEnd   : integer;
    overRide  : boolean;
    contScan  : boolean;
    doingFind : boolean;
    Lrg       : range;
    pCel      : TPCel;
    VT        : variantType;
    hVecCel   : THVecCel;
    startCell : range;
    hContents : THContents;

    (*$S FindDiBox *)
    function doFindText : boolean;
    var dPtr     : ptrData;
        numBytes : integer;
        status   : integer;
        errRec   : errRecord;
        strLen   : integer;
        disp     : integer;
        x        : integer;
        done     : boolean;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       dPtr       := @FBufBuffer;
       doFindText := false;
       for x := 1 to 2 do begin
          numBytes := idMax;
          if x = 1 then begin
             if FindInForms then begin
                if hVecCel^^[colId].attributes.pkHasRule then
                   CellFormula(mmRead, row, col, dPtr, numBytes, status, errRec)
                else numbytes := 0
             end
             else numBytes := 0
          end
          else if FindInVals then CellValue(mmRead, row, col, dPtr, true, numBytes, status)
          else numBytes := 0;
          if numBytes > 0 then begin
             strLen := length(StrToFind);
             disp   := 0;
             done   := false;
             while (strLen + disp <= numbytes) and not done do begin
                if CompareChar(cChr(dPtr^[strLen - 1 + disp]), StrToFind[strLen], CompVeryWeak) then
                   done := CompChrIdentity(@dPtr^[disp], pointer(ord(@StrToFind) + 1), strLen, strLen, CompVeryWeak);
                disp := disp + 1
             end;
             if done then begin
                doFindText := true;
                Lrg.rKind  := a1CellRg;
                Lrg.loRow  := row;
                Lrg.loCol  := col;
                FixRange(Lrg);
                exit(doFindText)
             end
          end
       end
    end;


    (*$S Circling *)
    procedure findStep(stepNo : integer);
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       case stepNo of
          1 : begin
                 startCell.loRow := CMax(1, rg.loRow);
                 startCell.loCol := CMax(0, rg.loCol);
                 if Lrg.hiCol < startCell.loCol then startCell.loCol := Lrg.hiCol;

                 if rg.loRow = pInfSnip then startCell.loRow := idmax;
                 if rg.loCol = pInfSnip then startCell.loCol := idmax;
                 Lrg.loRow := startCell.loRow
              end;
          2 : begin
                 loopStart := Lrg.loCol;
                 loopEnd   := Lrg.hiCol + 1;
                 direc     := 1;
              end;
          3 : begin
                 contScan := ((col > startCell.loCol) and (row >= startCell.loRow)) and contScan;
                 contScan := contScan or (row > startCell.loRow);
                 if contScan then startCell.loCol := 0
                 else if (col = startCell.loCol) and (row = startCell.loRow) then startCell.loCol := 0
              end
       end
    end;


    (*$S Circling *)
    function doCirFind : boolean;
    var attr : TAttr;
        doIt : boolean;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       doCirFind := false;
       with hVecCel^^[colId].attributes do begin
          case action of
             2 : with hVecCel^^[colId].attributes do
                    if pkCircle then begin
                       pkCircle  := false;
                       pkInvalid := true
                    end;
             4 : if ((circlestate <> cMissing) or not pkHasRule) and pkCirCle then begin
                    Lrg.rKind := a1CellRg;
                    Lrg.loRow := row;
                    Lrg.loCol := col;
                    FixRange(Lrg);
                    doCirFind := true
                 end;
             12: if CellBit(row, col, B1Marked) then begin
                    pkCircle  := true;
                    pkInvalid := true
                 end;
             13,
             11: begin
                    GetCellAttr(@hVecCel^^[colId], attr, row, col);
                    case action of
                       11 : doIt := (attr.pkAlign = aInvis);
                       13 : doIt := (attr.pkProt <> protNone)
                    end;
                    if doIt then begin
                       pkCircle  := true;
                       pkInvalid := true
                    end
                 end
          end
       end
    end;

(*$S matMgrSeg *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   doingFind := false;
   case action of
      1,5,9    : Lrg := rg;
      otherwise with CT^ do begin
                   Lrg.loCol := 1;
                   Lrg.hiCol := lastsnip[colKind];
                   Lrg.loRow := 1;
                   Lrg.hiRow := lastsnip[rowKind];
                   case action of
                      4,
                      14 : begin
                              doingFind := true;
                              findStep(1)
                           end
                   end
                end
   end;
   overRide := ((rg.rKind = aRectRg) or (rg.rKind = a1CellRg)) and (action = 5);
   for row := Lrg.loRow to Lrg.hiRow do
      if (vecSnip[rowKind, row] <> absent) or overRide then begin
         if not overRide then hVecCel := hVecOfRow(row);

         if doingFind then begin
            findStep(2);
            if loopEnd < loopStart then goto 2
         end
         else begin
                 loopStart := Lrg.hiCol;
                 loopEnd   := Lrg.loCol - 1;
                 direc     := -1;
                 if (loopEnd > loopStart) or (loopStart = 0) then goto 2
              end;

         col := loopStart;
         repeat
            if overRide then contScan := true
            else begin
                    colId := vecSnip[colKind, col];
                    contScan := (colId <> absent);
                    if doingFind then findStep(3)
                 end;

            if contScan then

               case action of
                  1   : hVecCel^^[colId].attributes.pkInvalid := true;
                  0,
                  3   : with hVecCel^^[colId] do
                           if oh <> absent then begin
                              hContents := GetHContents(@hVecCel^^[colId]);
                              with hContents^^.vinfo.data do begin
                                 if action = 3 then begin
                                    marked1 := marked2;
                                    marked2 := false
                                 end
                                 else if bitType = B1Marked then marked1 := false
                                 else marked2 := false
                              end
                           end;
                  2,
                  4,
                  11,
                  12,
                  13  : if doCirFind then
                           if action = 4 then goto 1;
                  14  : if doFindText then goto 1;
                  5   : begin
                           pCel := FindPcel(row, col, true);
                           if pCel <> nil then begin
                              GetCellAttr(pCel, VT.attrinfo, row, col);
                              pCel^.attributes := VT.attrinfo
                           end
                        end;
                  7,
                  6   : with hVecCel^^[colId].attributes do
                           if pkInvalid then begin
                              pkInvalid := false;
                              displaycell(row, col)
                           end;
                  10,
                  8   : with hVecCel^^[colId] do begin
                           if action = 8 then attributes.pkInvalid := false;
                           if oh <> absent then begin
                              hContents := GetHContents(@hVecCel^^[colId]);
                              hContents^^.vinfo.data.cellseen := false
                           end
                        end;
                  9   : if isProtected(hVecCel^^[colId].attributes) then begin
                           Lrg.rKind := a1CellRg;
                           Lrg.loRow := row;
                           Lrg.loCol := col;
                           FixRange(Lrg);
                           goto 1
                        end;
               end;
            if loopEnd <> loopStart then col := col + direc
         until col = loopEnd
      end;

2: case action of
      4,
      9,
      14 : begin
              Lrg.rKind := aNullRg;
              FixRange(Lrg);
           1: rg := Lrg
           end;
      7  : if imageflag then FxNewRgImg
   end
end;


(***************************************.*******.********************************************************
   SetSnipWidth - sets the width (supplied in pixels) of the snip.

   Note: The only range types accepted by "SetSnipWidth" are aColRg or aWTBoxRg.
   The validation of the range type is done by the calling routine.
****************************************.*******.*******************************************************)
(*$S ColWidth *)
procedure SetSnipWidth(* rg : range ; width : integer *);
var temp   : integer;
    tempRg : range;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   if usingScrap then FatalMess(5)
   else if not printState.preview then begin
(*$ELSEC *)
        if not printState.preview then begin
(*$ENDC *)
           tempRg := rg;
           claimUndoBuffer(true);
           expandrange(rg, true);
           temp  := TabFWidth.w;
           if width div TabFWidth.w > maxLenWav then width := maxLenWav * TabFWidth.w;
           width := Cmax(((Cmin(maxColWidth, width)+temp div 2) div temp)*temp, temp) + TblPars.FieldPad;
           mmUndoInfo.op    := uWidth;
           mmUndoInfo.rg    := rg;
           mmUndoInfo.state := true;
           mmUndoInfo.info.width := width;
           mmUndoInfo.info.snip  := colKind;
           cWidened(true);
           if not app.LisaCalc then begin
              FxRgChged(tempRg);
              FxNewRgImg
           end;
           if TblPars.shoFormulas then begin
              mmSetWids(tValues);
              mmSetWids(tFormulas)
           end
        end
end;


(***************************************.*******.********************************************************
   SetVecWidth - permanently sets the state of the snip widths from the temporary
                 width information in VECWID.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure SetVecWidth
  (* snip  : snipKind;
     width : integer;
     rg    : range
  *);
var row, col : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if snip = rowKind then for row := rg.loRow to rg.hiRow do vecWid[rowKind, row] := width
   else for col := rg.loCol to rg.hiCol do vecWid[colKind, col] := width
end;


(***************************************.*******.********************************************************
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure ShrinkSegMemory
  (* Hz         : THz;
     beSmart    : boolean;
     var errNum : integer
  *);
var  bytesRemoved : longint;
     NewDSize     : longint;
     NewMSize     : longint;
     ds_refNum    : integer;
     info_rec     : DSInfoRec;
     sErrNum      : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   errNum := 0;

   if beSmart then
      if hz = mxHz then begin
         if app.BusGraph then NewMSize := BGhzLim
         else NewMSize := LChzLim;
         if hz^.cbFree < NewMSize then exit(ShrinkSegMemory)
      end;

   bytesRemoved := CBShrinkHz(hz, hz^.cbFree);          {ask the stoarge manager to comapct the heap}

   Sched_Class(sErrNum, false);
   Info_Address(errNum, ord(hz), ds_refNum);
   if errNum = 0 then Info_DataSeg(errNum, ds_refNum, info_rec);
   Sched_Class(sErrNum, true);

   if errNum = 0 then begin

      Sched_Class(sErrNum, false);
      Size_DataSeg(errNum, ds_refNum, -(info_rec.mem_size - CBofHz(hz)), NewMSize, 0, NewDSize);
      Sched_Class(sErrNum, true);

      if (errNum = 0) and (hz = mxHz) then begin
         mmMemSize  := NewMSize;
         mmDiskSize := NewDSize
      end
   end
(*$IFC DEBUGVERSION or WRITELNS *)
   ;if hz = mxHz then
      writeln('ShrinkSegMemory:  mxHz old: ',mmMemSize:1,',',mmDiskSize:1,'  new: ',NewMSize:1,',',NewDSize:1,
              '   error: ',errNum:1)
    else writeln('ShrinkSegMemory:  theHeap  old: ',info_rec.mem_size:1,',',info_rec.disc_size:1,
                 ' new: ',NewMSize:1,',',NewDSize:1,'   error: ',errNum:1);
    writeln('   CbofHz: ',cbofhz(hz):1,'/',NewMSize:1);
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   SnipExists - return true if the particular snip exists inside the matrix
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function  SnipExist
  (* snip   : snipKind;                 {type of snip to be tested}
     snipId : idType                    {the id for the snip}
  ) : boolean *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   SnipExist := (vecSnip[snip, snipId] <> absent)
end;


(***************************************.*******.********************************************************
   SnipLT - returns TRUE if the snip whose identifier is in Snip1Id is
            before the snip whose identifier is in Snip2Id.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function  SnipLT(* snip : snipKind; snipId1, snipId2 : idType) : boolean *);
begin
   if snipId1 = snipId2 then SnipLT := false
   else if (snipId1 = mInfSnip) or (snipId2 = pInfSnip) then SnipLT := true
   else if (snipId1 = pInfSnip) or (snipId2 = mInfSnip) then SnipLT := false
   else SnipLT := snipId1 < snipId2;
end;


(***************************************.*******.********************************************************
   SnipWidth - returns the width in pixels of snip SnipId.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function  SnipWidth(* snip : snipKind; var snipId : idType) : integer *);

    (*$S scrapCode *)
    procedure ScrapSnipWidth;
    var FBufOrig : THptrData;
        oper     : undotype;
        lastIds  : pIdent;
        width    : integer;
        status   : integer;
        rg       : range;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       width     := dftWidth[snip];
       FBufOrig  := FBufPtr;
       FBufPtr   := ScrapPtr;
       if FBufPtr <> nil then begin
          ReadHeader(oper, rg, lastIds, status);
          if status = ok then begin
             if snip = rowKind then begin
                if (snipId >= rg.loRow) and (snipId <= rg.hiRow) then
                   FBufPt := FBufPt + sizeof(integer) * (rg.hiCol - rg.loCol + 1 + snipId - rg.loRow)
                else status := -1
             end
             else if (snipId >= rg.loCol) and (snipId <= rg.hiCol) then
                     FBufPt := FBufPt + sizeof(integer) * (snipId - rg.loCol)
             else status := -1;
             if status = ok then unstuffinteger(width, status)
          end
       end;
       SnipWidth := width;
       FBufPtr   := FBufOrig
    end;


    (*$S showForms *)
    procedure nonStdSnipWidth;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       if snip = colKind then begin
          if printState.preview then SnipWidth := CT^.fWidths.w * (length(pageText) + 6)
          else SnipWidth := Cmax(vecWid[colKind, snipId], minFormWidth)
       end
       else if printState.preview then SnipWidth := CT^.fWidths.h
       else SnipWidth := Cmax(vecWid[rowKind, snipId], dftRowHeight)
    end;


(*$S matMgrSeg *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if snipId = mInfSnip then
      with CT^ do begin
         if snip = rowKind then SnipWidth := ColTitleHght
         else if printState.preview then SnipWidth := dftPColWidth * fWidths.w
         else SnipWidth := RowTitleWidth
      end
   else if UsingScrap then ScrapSnipWidth
   else if tableState <> tValues then nonStdSnipWidth
   else begin
          SnipWidth := vecWid[snip, snipId];
          if mmUndoInfo.state then
             if (mmUndoInfo.op = uWidth) and (mmUndoInfo.info.snip = snip) then
                if CoordInRange(snipId, snipId, mmUndoInfo.rg) then SnipWidth := mmUndoInfo.info.width
        end
end;


(***************************************.*******.********************************************************
   SwitchTable - switches to display either the scrap or the main table.
****************************************.*******.*******************************************************)
(*$S scrapCode *)
procedure SwitchTable
  (* ScrapTable    : tableType;         {table to switch to}
     var tableInfo : tableRecord        {table information for that table}
  *);
var rg : range;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if usingscrap <> ScrapTable then begin
      if ScrapTable then begin
         usingScrap := true;
         CT         := ScrapInfo;
         RWTabledata(mmWrite, tableInfo);
         TableInfo.ShoFormula := false;
         rg         := CT^.SnipBds;
         rg.rKind   := a1CellRg;
         ReBldTbl(rg)
      end
      else begin
              usingScrap := false;
              CT := MatrixInfo;
              RWTabledata(mmRead, tableInfo)
           end
   end
(*$IFC DEBUGVERSION *)
   else FatalMess(2);
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   WordFromLexeme - given a `lexeme`, "WordFromLexeme" returns the corresponding text string associated
                    with the lexeme.  The text string is stored at the place pointed to by `word` with
                    upto a maximum of `maxBytes` number of characters stored.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure WordFromLexeme
  (* lexeme   : symbol;                 {lexeme for which text is desired}
     maxBytes : integer;                {max number of characters to store}
     var word : PtrStrType              {pointer to where the chr's are to go}
   *);
var bufPtr : ^byte;                             {index into lexeme buffer}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   bufPtr := @WordBuffer^^[words[lexeme]];      {get index to the text for the lexeme}
   movelfast(@bufPtr^, @word^, CMin(maxBytes, bufPtr^ + 1))
end;



