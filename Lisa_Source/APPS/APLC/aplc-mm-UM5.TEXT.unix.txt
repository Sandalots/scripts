
                            {'Copyright 1983, 1984, Apple Computer Inc.'}

{aplc/mm/UM5.TEXT = implementation of UM}

const ScrapVersion= 500;

(*$IFC RELone *)
      fileversion = 130;                        {file format version number - increases in steps of two}
(*$ELSEC *)
      fileversion = 136;                        {file format version number - increases in steps of two}
(*$ENDC *)

      susVerNum      = 125;
      FlushSize      = 511;
      LCpassWord     = 30693;

type              {cell attributes}


      pkGrpKind   = (g0, g1, g2, gMoney, g4, g5, g6, gMisc); {8 choices-3 bits}
      pkDecKind   = (dDecimal, dScientific);    {2 choices-1 bit}
      pkMoneySet  = 0..7;                       {alias for 3-bit moneySet}

    { alFmt:
           -----------------------------------
          |  0  |  1  |  1  |  .  |  ,  |  .  |   money
           -----------------------------------
          |  1  |  1  |  1  |  f m t K i n d  |   date, integer, standard
           -----------------------------------
          |  0  | d e c i m a l   p l a c e s |   decimals   (places < 24)
           -----------------------------------
          |  0  | d e c i m a l   p l a c e s |   scientific (places < 24)
           -----------------------------------
    }
      alFmtKind   = packed record                     {fancy packing-6 bits}
                       padding :  0..3; {to right-justify}
                       case alias of
                          twdlDee :                      {used when decPlaces>=16+8}
                            (case alGrp : pkGrpKind of   {3}
                               gMoney : (alMoney:  pkMoneySet);      {3}
                               gMisc  : (alMisc:   fmtKind));        {3}
                          twdlDum :                      {used when decPlaces<16+8}
                            (alDec     : pkDecKind;     {1}
                             decPlaces : TDecPlaces);   {5}
                          twdlDoe :
                            (alFormat:      pkFmtKind);    {6}
                    end;


                  {cell arrays}
      TPVecCel    = ^TVecCel;
      THVecCel    = ^TPVecCel;
      TVecCel     = array [TidRng] of TCel;              {row of cells (sparse)}

      FBufType    = record                      {cell with no rule}
                       case alias of
                          twdlDye : (word   : integer); {2 bytes}
                          twdlDoe : (short  : real);    {4 bytes}
                          twdlDum : (long   : longreal);{4 bytes now, 8 later}
                          twdlFye : (band   : tmBand);
                          twdlFoe : (rg     : range);
                          twdlFum : (pCel   : Tcel)
                    end;

      pageInfo    = packed array [boolean, snipKind, TidRng] of boolean;

      TablePtr    = ^TableData;
      TableData   = record
                       ColTitleHght : integer;          {column title height, in pixels}
                       RowTitleWdth : integer;          {row title width, in pixels}
                       TableFont    : TLfntId;
                       fWidths      : FontWidths;
                       SnipBds      : range;
                       lastSnip     : array [snipKind] of idType;
                    end;

      FileStamp   = record
                       case alias of
                          twdlDee : (stamp   : integer);
                          twdlDye : (reserve : array [0..13] of byte)
                       end;

      PrinterStamp= record
                       case alias of
                          twdlDee : (config  : TPrRec);
                          twdlDye : (reserve : array [0..205] of byte)
                       end;

      fileHeader  = packed record
                       password : integer;
                       version  : FileStamp;
                       printer  : PrinterStamp;
                       segSize  : longint;
                       app      : appKind;
                       nHandles : longint
                    end;

      UndoRec     = record
                       op    : undoType;
                       rg    : range;
                       ptr   : TablePtr;
                       state : boolean;
                       info  : variantType
                    end;

      vecHz       = array [0..LChzLim] of byte;         {array for the heap}

var   FBufPtr     : THptrData;                  {ptr to undo buffer}
      FBufDPtr    : THptrData;                  {data ptr to undo buffer}
      ScrapPtr    : THptrData;                  {ptr to scrap buffer}
      FBufSave    : THptrData;                  {temp ptr to undo buffer}
      FBufFile    : ^pathname;                  {ptr to file name}
      newFBuffer  : boolean;
      useDopeInfo : boolean;
      dopeSize    : integer;
      FBufpt      : longint;
      THmaxSize   : longint;
      THdataSize  : longint;
      minSwapSpace: longint;                   {minimum swap space need for application}
      scrapCel    : TCel;

      pVecHz      : ^vecHz;
      theAlFmt    : alFmtKind;                  {for coercing fmtKinds}
      attrBlank   : TAttr;                      {default attributes of blank}
      celBlank    : TCel;                       {TCel record of a blank cell}
      FIOtype     : IOtype;                     {place where IO is going}
      reMapSrc    : srcType;                    {type of information in remapping}
      modeOpened  : IOModeType;                 {state which IO was opened}
      mmUndoInfo  : UndoRec;
      ScrapInfo   : TablePtr;
      MatrixInfo  : TablePtr;
      CT          : TablePtr;
      PRdataArea  : PRrecord;
      appType     : appKind;
      pVector     : pMapInfoRec;
      reMapRg     : range;

      dftRowHeight: integer;                    {row title height, in pixels}
      minFormWidth: integer;
      absent      : integer;                    {0 : signifies unalloc col}
      blockcnt    : integer;
      FileRefnum  : integer;
      reMapLevel  : integer;
      cStoredCols : integer;                    {count of cols allocated}

      TableArray  : array [0..2] of TableData;

      PRinfo      : record
                       rh,rv    : integer;
                       dh,dv    : integer;
                       row      : integer;
                       col      : integer;
                       rg       : range;
                       butInfo  : PRflags;
                       aFormula : array [0..PRStrLength] of byte;
                       rFormula : array [0..PRStrLength] of byte
                   end;

      vecTimer    : record
                       last : boolean;
                       cnt  : integer
                    end;

      UsingScrap  : boolean;

      vecBreaks   : pageInfo;
      vecSnip     : vecInfo;
      vecWid      : vecInfo;

      numbyte1    : integer;                    {max # of chrs /actual # chrs returned}
      numbyte2    : integer;                    {max # of chrs /actual # chrs returned}

      vecAttrTime : packed array [snipKind, TidRng] of 0..255;
      vecAttrs    : array [snipKind, TidRng] of TAttr;
      dftWidth    : array [snipKind] of integer;        {default col width/row height}
      FBufBuffer  : array [0..FlushSize] of byte;

   (***************************************.*******.*********************************
      Non-interface routines - external routines
   ***************************************.*******.**********************************)
   function aGetOH
     (addr : longint
     ) : integer;
         external; {in aplc/mm/LCASM - assembly language}

   function aMakeHND
     (oh : integer
     ) : longint;
         external; {in aplc/mm/LCASM - assembly language}

   function  cChr
      (* x : integer
      ) : char *);
         external; {in aplc/mm/LCASM - assembly language}

   procedure CellFormula
     (* mode         : IOModeType;      {reading/writing mode flag}
        rowId, colId : idType;          {location of cell}
        formula      : ptrData;         {ptr to formula characters}
        var numBytes,                   {max # of chrs /actual # chrs returned}
            status   : integer;         {error status number}
        var error    : errRecord        {error message information}
     *); external; {in aplc/mm/RECALC - Unit Calc}

   procedure CellInterval
     (* rowId, colId  : idType;         {location of cell}
        formula       : ptrData;        {ptr to formula characters}
        PRdata        : TPPRrecord;     {Paste Relative record}
            relstr    : boolean;        {relative/absolute information: y/n}
        var numBytes  : integer;        {max # of chrs /actual # chrs returned}
        resetPRdata   : boolean
     *); external; {in aplc/mm/DECODE - Unit CALC}

   procedure CellRange
     (* coordinate : ptrData;           {ptr to range characters}
        numBytes   : integer;           {max # of chrs /actual # chrs returned}
        var result : range;             {resulting range from parsing}
        var status : integer;           {error status number}
        var error  : errRecord          {error message information}
     *); external; {in aplc/mm/LEX - Unit Parse}

   procedure ClrFormErrors;
         external; {in aplc/mm/CALC - Unit Calc}

   procedure convertformula
     (* rowId, colId : idType;          {location of cell}
        pFormula     : TPFmla           {ptr to formula}
     *); external; {in aplc/mm/CALC2 - Unit CALC}

   function  CoordInMatrix
     (* rowId, colId : idType           {coordinate to be checked}
     ) : boolean *);                    {coordinate was within the matrix}
         external; {in aplc/mm/LCASM - assembly language}

   procedure cWidened
      (undoable : boolean
      ); external; {in aplc/FEGLOBALS - Unit FEGLOBALS}

   procedure detLogOrder
     (* orderOp : orderType
     *); external; {in aplc/mm/RECALC - Unit CALC}

   procedure displaycell
     (* rowId, colId : integer          {location of cell to be displayed}
     *); external; {in aplc/mm/RECALC - Unit CALC}

   procedure FoldedFormula
     (* rowId, colId : idType;          {location of cell}
        formula      : ptrData;         {ptr to formula characters}
        var numBytes : integer          {error status number}
     *); external; {in aplc/mm/DECODE - Unit CALC}

   procedure FxDataStuff
     (* mode       : FIOkind;
        var status : integer
     *); external; {in aplc/FEXEC - Unit LCfexec}

   procedure FxNewRgImg
     ; external; {in aplc/FEXEC - Unit LCfexec}

   procedure FxRgChged
     (rg : range                        {range which to signal application about}
     ); external; {in aplc/FEXEC - Unit LCfexec}

   procedure GetPRcoords
     (* var rowId, colId : integer
     *); external; {in aplc/mm/DECODE - Unit CALC}

   procedure initparser                 {initializes the parser information}
     (* var status   : integer
     *); external; {in aplc/mm/INIT - Unit PARSE}

   function  IsTextstring
     (* var number   : valueType;       {value if string, if string is a number}
        var money    : boolean          {was the number a money value? }
     ) : boolean *);                    {was it a text string: y/n}
        external; {in aplc/mm/DECODE - Unit CALC}

   procedure mmMapFormulas
     (* pasting      : boolean;
        uRg,
        sRg          : range;
        passNum      : mmMapKind;
        var vector   : mapInfoRec;
        var estimate : longint;
        var resFlag  : boolean
     *); external; {in aplc/mm/CALC2 - Unit CALC}

   procedure mmSendPRinfo;
         external;       {shared formula information}

   procedure moveLfast
     (* p1,p2    : ptrData;             {p1, p2 = ptrs to data}
        numBytes : integer              {number of bytes to move}
     *); external; {in aplc/mm/LCASM - assembly language}

   procedure moveRfast
     (* p1,p2    : ptrData;             {p1, p2 = ptrs to data}
        numBytes : integer              {number of bytes to move}
     *); external; {in aplc/mm/LCASM - assembly language}

   function NumOfCoords
     (* formula     : ptrData;          {direct ptr to formula}
        rg          : range;            {inclusion range to check coords against}
        aFormula    : ptrData;          {direct ptr to formula to remap (maybe nil)}
        vector      : mapInfoRec;       {range being pasted into}
        mapExternal : boolean;          {should external references be changed: y/n}
        relative    : boolean;          {paste releative operation: y/n}
        setRelInfo  : boolean;          {setting rel/abs info: y/n}
        var relInfo : PRTfmla           {rel/abs bits}
     ) : integer *);
        external; {in aplc/mm/RECALC - Unit CALC}

   procedure NumOfFormulaFolds;
        external; {in aplc/mm/DECODE - Unit CALC}

   function  parse
     (* operation : parseKind;          {parse operation}
        dataline  : ptrdata;            {ptr to line to be parsed}
        numBytes  : integer;            {# bytes in line}
        row, col  : integer;            {circular reference information}
        var error : errRecord           {error infomation}
     ) : boolean *);                    {parse succesful? }
        external; {in aplc/mm/PARSE - Unit Parse}

   procedure PutValue
     (* rowId, colId : integer;         {location of cell}
        value        : valueType;       {value to be saved into the cell}
        inrule       : boolean;         {does the value belong to a rule: y/n}
        var status   : integer          {error status number}
     *); external; {in aplc/mm/RECALC - Unit CALC}

   procedure recalc
     (* rowId, colId : idType;          {location of cell}
        var status   : integer;         {error status number}
        inrule       : boolean          {does the cell have a newly entered rule: y/n}
     *); external; {in aplc/mm/CALC - Unit Calc}

   procedure resetPRdata
     (* PRrow, PRcol : idType;
        PRdata       : TPPRrecord
     *); external; {in aplc/mm/recalc - Unit CALC}

   procedure rstr
     (* number         : extended;      {the number to be formatted}
        var result     : resultStr;     {the resulting string}
        decplaces,                      {# digits to the right of the dec. pt}
        format         : byte;          {format code number}
        numdigits      : integer;       {# digits desired}
        dataInReg      : boolean;
        var scientific : boolean        {value was displayed in sci. notation? }
     *); external; {in aplc/mm/LEX - Unit PARSE}

   procedure SetBits
     (pCel  : TPcel;
      cnRec : cnRecord
     ); external;  {in aplc/mm/ASM - assembly language}

   procedure SetCirBit
     (* rowId, colId : integer;
        formPtr      : THFmla
     *); external; {in aplc/mm/recalc - Unit CALC}

   procedure SetVisSnips;
         external; {in aplc/mm/calc - Unit CALC}

   procedure SfromB
     (* var strg : stringType;
        pBytes   : ptrData;
        numBytes : integer
     *); external; {in aplc/mm/LCASM - assembly language}

   procedure StoB
     (* strg         : resultStr;
        pBytes       : ptrData;
        var numBytes : integer
     *); external; {in aplc/mm/ASM - assembly language}

   procedure unPackValue
     (* hContents  : THContents;
        pValue     : TPValue;
        fullinfo   : boolean;
        var result : valueType;
        var assume : boolean            {asumption made about the data: y/n}
     *); external; {in aplc/mm/DECODE - Unit CALC}

   procedure xStoB
     (* strg         : str255;
        pBytes       : ptrData;
        var numBytes : integer
     *); external; {in aplc/mm/ASM - assembly language}

(*$IFC DEBUGVERSION *)
   {all these routines are in unit stubs unless otherwise noted}
   procedure DebugMess
     (messnumber : integer
     ); external;

   procedure dumpformula
     (formula : ptrData
     ); external;

   procedure dumpFP; external;

   procedure dumpPRinfo
      (infonum   : integer;
       aFormula,
       rFormula  : ptrData;
       numbyte1,
       numbyte2  : integer;
       PRdata    : PRrecord;
       offAxis   : boolean
      ); external;

   procedure dumpshared
     (formPtr : THFmla
     ); external;

   procedure dumpTable;
        external;

   procedure FatalMess
     (* messnumber : integer
     *); external;

   procedure meminfo
     (rowId, colId : integer;
      cellinfo     : boolean
     ); external;

   procedure OSerror
      (routine,
       mmerror : str40;
       error   : integer
      ); external;

   function  RodStuff
      (menuItem: integer
      ): boolean; external;

   procedure startTMtime; external;

   procedure StatusMess
     (status : integer
     ); external;

   procedure timestop
     (* slot : integer
     *); external;

   procedure TraceMess
     (messnumber : integer
     ); external;

   function  wAttr
     (value : TAttr
     ) : char;
        external;

   function  wNAN
     (value : cnSymKind
     ) : char;
        external;

   function wRg
     (rg : range
     ) : char;
        external;

   function  wSHR
     (value : shareKind
     ) : char;
        external;

   function  wSNIP
     (value : snipKind
     ) : char;
        external;
(*$ENDC *)


   (***************************************.*******.*********************************
      Non-interface routines - forward references
   ***************************************.*******.**********************************)
   procedure BubbleLeft
     (howFar           : integer;
      pConstFill       : ptrData;
      sizeOfElement    : integer;
      pZerothElement   : ptrData;
      indexOfFirstDest : integer;
      indexOfLastDest  : integer
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure BubbleRight
     (howFar           : integer;
      pConstFill       : ptrData;
      sizeOfElement    : integer;
      pZerothElement   : ptrData;
      indexOfFirstDest : integer;
      indexOfLastDest  : integer
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure ClrDopeInfo;
        forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure FBufFlush
     (var status : integer              {error status number}
     ); forward; {in aplc/mm/UM7 - Unit matMgr}

   procedure FBufIO
     (var status : integer              {error status number}
     ); forward; {in aplc/mm/UM7 - Unit matMgr}

   procedure FillConst
     (pConstFill       : ptrData;
      sizeOfElement    : integer;
      pZerothElement   : ptrData;
      indexOfFirstDest : integer;
      indexOfLastDest  : integer
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure FreeBufList;
        forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure FreeContents
     (pCel : TPcel                      {pointer to cell to be removed}
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure FreeSnips
     (snip    : snipKind;               {type of snip to be removed}
      snipId1,                          {range of snips to be removed}
      snipId2 : idType
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure GetCellAttr
     (pCel         : TPCel;
      var attr     : TAttr;
      rowId, colId : idType
     ); forward; {in aplc/mm/UM2 - Unit matMgr}

   function  GetHContents
     (pCel : TPCel                      {pointer to cell information}
     ): THContents;                     {handle to cell information}
        forward; {in aplc/mm/UM3 - Unit matMgr}

   function  hVecOfRow
     (rowId : idType
     ) : THVecCel;
        forward; {in aplc/mm/UM3 - Unit matMgr}

   function  IdInRange
     (rowId, colId  : integer;          {location of cell to be checked}
      var rg        : range;            {range which inclusion was tested}
      var lastIds   : pIdent
     ) : boolean;                       {was the cell within the range: y/n}
        forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure IncRefCnt
     (hContents : THContents;
      inRule    : boolean
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   function  isProtected
     (attr : TAttr                      {packed cell's attribute information}
     ) : boolean;                       {is cell protected: y/n}
        forward; {in aplc/mm/UM3 - Unit matMgr}

   function  mmPageBreak
     (forced : boolean;
      snip   : snipKind;
      snipId : integer
     ) : boolean;
        forward; {in aplc/mm/UM2 - Unit matMgr}

   procedure patchFormats
     (rowId    : idType;
      hVecCel  : THVecCel;
      lowSnip,
      highSnip : idType
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure PBtoB
     (src,
      dest         : ptrData;
      var numBytes : integer
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure ReallocRow
     (rowId      : idType;              {row to be reallocated}
      var status : integer
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure ReadHeader
     (var op      : undoType;           {type of operation stored}
      var rg      : range;              {range of information stored}
      var lastIds : pIdent;
      var status  : integer             {error status number}
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure SetCellFormat
     (var attr : Tattr;
      attrRec : attrRecord
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure SetDopeInfo
     (loCol, hiCol : integer;
      onAbsent     : boolean
     ); forward; {in aplc/mm/UM3 - Unit matMgr}

   procedure SetVecAttr;
        forward; {in aplc/mm/UM2 - Unit matMgr}

   procedure SetVecBreaks;
        forward; {in aplc/mm/UM2 - Unit matMgr}

   procedure unstuffinteger
     (var value,                        {value to be unstuffed from the buffer}
          status : integer              {error status number}
     ); forward; {in aplc/mm/UM3 - Unit matMgr}



(*$IFC DEBUGVERSION *)
   procedure CheckCompiler;
        forward; {in aplc/mm/UM3 - Unit matMgr}

(*$ENDC *)


(***************************************.*******.************************************
   initTable -
*)
(*$S OpenClose *)
procedure InitTable
  (var TableInfo : tableRecord
  );
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with TableInfo do begin
      SplitTable     := true;
      RectBorder     := true;
      Marquee        := true;
      ColHandles     := false;
      ColGrids       := true;
      ColGridHandles := true;
      ColRangeOk     := true;
      EditColTitle   := false;
      InsertCols     := true;
      EdBlankCol     := true;
      RowHandles     := false;
      RowGrids       := true;
      RowRangeOk     := true;
      RowGridHandles := true;
      EditRowTitle   := false;
      InsertRows     := true;
      EdBlankRow     := true;
      EditTable      := true;
      ShoFormulas    := false;
      Preview        := false;
      RectRgOk       := true;
      FieldPad       := 2;
      scrollincr[rowKind] := 360;
      scrollincr[colKind] := 720;
   end
end;


(***************************************.*******.************************************
   mmGetPRinfo - returns the text for both the relative and absolute formulas for
                 the next cell in the paste relative dialog.  The next cell info
                 is in PRinfo.ROW,COL which are global variables.  The routine saves
                 the paste relative information int the area pointed to by PRdataPTR.
                 A maximum # of chrs (specified by the NUMBYTES) will placed in the
                 area specified by the FORMULAS with the actual # of chrs placed being
                 returned through the NUMBYTES.  If a formula does not exist at
                 PRinfo.ROW,COL, then the cell is skipped until another formula is found
                 or the end of the paste relative dialog is encountered.

   NOTE: most of the information in PRDATA is generated by this routine, however
         PRDATA.NUMCOORD is generated by the call to "CellInterval" when the relative
         string is requested.  The rel/abs info is not setup until later by the call
         to "mmSendPRinfo".
*)
(*$S PRdialog *)
procedure mmGetPRInfo
  (* aBoxLabel    : ptrData;            {resulting absolute checkboxes}
     Formula      : ptrData;            {resulting formula}
     rBoxLabel    : ptrData;            {resulting absolute checkboxes}
     var numBytes : integer;            {max # of chrs /actual # chrs returned}
     CellLabel    : ptrData;            {resulting cells display label}
     var numLByte : integer;            {max # of chrs /actual # chrs returned}
     var butData  : PRflags;            {button state data}
     mode         : idModeType          {movement mode}
  *);
var status     : integer;                       {status info - should always be ok}
    destPt     : integer;
    boxPt      : integer;
    boxCount   : integer;
    coordNum   : integer;
    nextCoord  : integer;
    absPt      : integer;
    x,y        : integer;
    temp       : integer;
    sRow, sCol : integer;
    oRow, oCol : integer;
    errCnt     : integer;                       {number of coordinates with errors}
    done       : boolean;                       {end of dialog encountered}
    offAxis    : boolean;
    sRg        : range;                         {range of values in scrap}
    FBufOrig   : THptrData;                     {temporarys to save FBufPtr state}
    bufptr     : integer;
    maxChrs    : integer;


    (*$S PRdialog *)
    procedure CopyChars(relative, rowCoords, inRange : boolean);
    var y         : integer;
        intervals : ^PRinterval;
        strData   : ptrData;
        ch        : byte;
        markBox   : boolean;
        start     : integer;
        stop      : integer;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       if relative then begin
          intervals := @PRdataPtr^.relStr;
          strData   := @PRinfo.rFormula;
          ch        := chkChrCode
       end
       else begin
               intervals := @PRdataPtr^.absStr;
               strData   := @PRinfo.aFormula;
               ch        := unChkChrCode
            end;

       markBox := false;
       with intervals^[coordNum] do begin
          if rowCoords then begin
             start   := lpFst + colDh + 1;
             stop    := start + rowDh;
             if inRange then begin
                start := stop + 2 + xcolDh + 1;
                stop  := start + xrowDh
             end
             else begin
                     markBox := ((PRinfo.dv <> 0) and (PRinfo.dh <> 0)) or offAxis;
                     if PRinfo.dv <> 0 then boxCount := boxCount + 1
                  end
          end
          else begin
                  start    := lpFst;
                  stop     := start + colDh;
                  if inRange then begin
                     start := stop + 2 + rowDh;
                     stop  := start + xcolDh + 1
                  end
                  else begin
                          markBox  := true;
                          boxCount := boxCount + 1
                       end
               end;
          if markBox and (boxPt <= maxChrs) then begin
             rBoxLabel^[boxPt] := ch;
             boxPt := boxPt + 1
          end;
          for y := start to stop do begin
             if boxPt <= maxChrs then begin
                rBoxLabel^[boxPt] := ord(' ');
                boxPt  := boxPt + 1
             end;
             if (y <= maxChrs) and (numBytes + 1 <= maxChrs) then begin
                numBytes := numBytes + 1;
                Formula^[numBytes] := strData^[y]
             end
          end
       end;
       boxPt := boxPt - ord(markBox)
    end;


(*$S PRdialog *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   butData.next := false;
   butData.prev := false;
   butData.curr := true;
   maxChrs      := CMin(PRStrLength + 1, numBytes);
   repeat
      done   := false;
      errCnt := -1;
      with PRdataPtr^, PRinfo do
         if row <= rg.hiRow then begin
            if CellHasRule(row + dv, col + dh) then begin
               if mode <> mmLast then begin

                  rowId      := row + dv;
                  colId      := col + dh;
                  offsetH    := dh;
                  offsetV    := dv;

                  FBufOrig   := FBufPtr;                   {save FBufPtr info and scrap use flag}
                  bufptr     := FBufPt;
                  FBufPtr    := ScrapPtr;                  {swtich to point at the scrap}
                  UsingScrap := true;
                  numbyte1   := Cmin(maxChrs, PRStrLength + 1);
                  numbyte2   := Cmin(maxChrs, PRStrLength + 1);
                  CellInterval(row, col, @aFormula, PRdataPtr, false, numbyte1, (mode = mmFirst));
                  UsingScrap := false;
                  FBufPtr    := FBufOrig;
                  FBufPt     := bufptr;
                  sRow       := rowId;
                  sCol       := colId;
                  GetPRcoords(sRow, sCol);

                  {calculate example cell.  make sure that example cell is off the axises of the
                   original cell.
                  }
                  if (dh = 0) and (sCol = colId) and (rh <> 0) then colId := colId + rh;
                  if (dv = 0) and (sRow = rowId) and (rv <> 0) then rowId := rowId + rv;

                  {get the abs/rel bits for the new formula}
                  case mode of
                     mmPrior,
                     mmNext : resetPRdata(rowId, colId, PRdataPtr)
                  end;

                  CellInterval(rowId, colId, @rFormula, PRdataPtr, true, numbyte2, (mode = mmFirst))
               end;
               if numCoords >= 0 then begin

                  {determine if the example cell is off the axis from the real cell}
                  offAxis := (rowId <> row + dv) and (colId <> col + dh);

                  temp    := numLByte;
                  CellValue(mmRead, minfsnip, colId, CellLabel, false, temp, status);
                  if temp = 0 then numLByte := 0
                  else numLByte := numLByte - temp;
                  CellValue(mmRead, rowId, minfsnip, @CellLabel^[temp], false, numLByte, status);
                  numLByte := numLByte + temp;
                  boxCount := -1;
                  numBytes := -1;
                  boxPt    := 0;
                  absPt    := 0;

                  nextCoord := absStr[0].lpFst;
                  coordNum  := 0;
                  repeat
                     if (nextCoord < 0) or (absPt < nextCoord) then begin
                        if boxPt <= maxChrs then begin
                           rboxLabel^[boxPt] := ord(' ');
                           boxPt  := boxPt + 1
                        end;
                        if numBytes + 1 <= maxCHrs then begin
                           numBytes := numBytes + 1;
                           Formula^[numBytes] := aFormula[absPt]
                        end
                     end
                     else with info[coordNum], absStr[coordNum] do begin
                             if not(relStr[coordNum].IsError or IsError) then begin
                                CopyChars(colRelative, false, false);
                                CopyChars(rowRelative, true, false);
                                absPt  := lpFst + colDh + 1 + rowDh;
                                if IsRange then begin
                                   CopyChars(colrelative, false, true);
                                   CopyChars(rowRelative, true, true);
                                   absPt := absPt + xcolDh + xrowDh + 3
                                end
                             end
                             else begin
                                     errCnt      := errCnt + 1;
                                     colRelative := false;
                                     rowRelative := false;
                                     absPt := absPt - 1
                                  end;
                             coordNum := coordNum + 1;
                             if coordNum > numCoords then nextCoord := -1
                             else nextCoord := absStr[coordNum].lpFst
                          end;
                     absPt := absPt + 1
                  until absPt > numByte1;

                  butData.curr := (errCnt <> numCoords);
                  if not butData.curr then mmSendPrInfo;
                  done := butData.curr;
                  for y := 0 to numBytes do begin
                     case rBoxLabel^[y] of
                        chkChrCode   : x := unChkChrCode;
                        unChkChrCode : x := chkChrCode;
                        otherwise      x := blkChrCode
                     end;
                    aBoxLabel^[y] := x
                 end
(*$IFC DEBUGVERSION *)
                 ;if debug[22] then
                    dumpPRinfo(1, @aFormula, @rFormula, numByte1, numByte2, PRdataPtr^, offaxis);
(*$ENDC *)
               end
            end;
            oRow := row;
            oCol := col;
            if not done then begin
               if mode = mmPrior then begin
                  PrevPRcell;
                  if (oRow = row) and (oCol = col) then mode := mmNext
               end;
               case mode of
                  mmFirst,
                  mmNext : NextPRcell
               end
            end
            else begin
                    case mode of
                       mmFirst,
                       mmNext  : begin
                                    butData.prev := (mode = mmNext);
                                    repeat
                                       NextPRcell;
                                       done := (row > rg.hiRow)
                                    until CellHasRule(row + dv, col + dh) or done;
                                    butData.next := not done
                                 end;
                       mmPrior : begin
                                    butData.next := true;
                                    butData.prev := false;
                                    repeat
                                       sRow := row;
                                       sCol := col;
                                       PrevPRcell;
                                       done := (sRow = row) and (sCol = col)
                                    until CellHasRule(row + dv, col + dh) or done;
                                    butData.prev := not done
                                 end;
                       mmLast  : butData := butInfo
                    end;
                    done  := true;
                    row := oRow;
                    col := oCol
                 end
         end
         else begin
                 butData.curr := false;
                 done  := true
              end
   until done;
   PRinfo.butInfo := butData
(*$IFC DEBUGVERSION *)
;if debug[5] then
   with butData do writeln('Buttons(p,c,n): ',prev,' ',curr,' ',next);
(*$ENDC *)
end;


(*$S PRdialog *)
procedure mmPRchkBox
  (* absolute    : boolean;
     chrinterval : interval;
     boxLabel    : ptrdata;
     numBytes    : integer;
     var bitset  : boolean
  *);
label 2;
var boxCount  : integer;
    boxNum    : integer;
    x,y       : integer;
    coordNum  : integer;
    newBitSet : boolean;
    singleBox : boolean;
    state     : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with PRdataPtr^, PRinfo do
      singleBox := ((offsetH = 0) or (offsetV = 0)) and ((rowId = row + dv) or (colId = col + dh));
   boxCount := -1;
   bitset   := false;
   state    := not absolute;

   for x := 0 to numbytes-1 do begin
      if (boxLabel^[x] = unChkChrCode) or (boxLabel^[x] = chkChrCode) then begin
         boxCount := boxCount + 1 + ord(singleBox);
         if (x >= chrInterval.lpFst) and (x < chrInterval.lpLim) then begin
            newBitSet := true;
            with PRdataPtr^ do begin
               boxNum := -1;
               for y := 0 to numCoords do begin
                  coordNum := y;
                  if not(absStr[y].IsError or relStr[y].IsError) then begin
                     boxNum := boxNum + 1 + ord(singleBox);
                     if boxNum = boxCount then goto 2;
                     if not singleBox then begin
                        boxNum := boxNum + 1;
                        if boxNum = boxCount then goto 2
                     end
                  end
               end;
            2:
            end;
            with PRdataPtr^.info[coordNum] do begin

(*$IFC DEBUGVERSION *)
               if debug[22] then
                  writeln(singlebox,' ',boxCount:1,':',coordNum:1,' ',state,colrelative,rowrelative);
(*$ENDC *)
               if odd(boxCount) then
                  if rowRelative <> state then begin
                     if singleBox then colRelative := state;
                     rowRelative := state
                  end
                  else newBitSet := false
               else if colRelative <> state then begin
                       if singleBox then rowRelative := state;
                       colRelative := state
                    end
                    else newBitSet := false
            end;
            bitset := bitset or newBitSet
         end
      end
   end
end;


(*$S PRdialog  *)
procedure NextPRcell;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with PRinfo do begin
      col := col + 1;
      if col > rg.hiCol then begin
         col := rg.loCol;
         row := row + 1
      end
   end
end;


(*$S PRdialog  *)
procedure PrevPRcell;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with PRinfo do begin
      col := col - 1;
      if col < rg.loCol then begin
         row := row - 1;
         if row < rg.loRow then begin
            row := rg.loRow;
            col := rg.loCol
         end
         else col := rg.hiCol
      end
   end
end;


(*$IFC DEBUGVERSION *)
(***************************************.*******.************************************
   timeclear - clears all the time values for a particular slot.  The values have
               the following meanings:
                  peak - has timer gone past alloted time: y/n
                  prev - previous accumlated time
                  tot  - total accumlated time
                  cnt  - # of active invocations on the timer
                  time - current time starting point
*)
(*$S LockDown *)
procedure timeclear
  (* slot : integer
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if slot < 1 then writeln(chr(7),'hit zero');
   with timer[slot] do begin
      peak := false;
      prev := 0;
      time := 0;
      cnt  := 0;
      tot  := 0
   end
end;


(***************************************.*******.************************************
   timepeak - accumulate any time for a particular timer.  If the timer is past its
              alloted time (or its previous accumlated time is past the alloted time)
              then the hourglass cursor will be put up.  Once a timer "peaks" no
              further time will be accumlated by this routine.
*)
(*$S LockDown *)
procedure timepeak
  (* peakslot : integer
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with timer[peakslot] do
      if not peak and (cnt > 0) then begin              {is the timer running? }
         tot  := tot + (elapstime - time - 145);        {accumlate time}
         cnt  := cnt - 1;
         time := elapstime;
         if peakslot > 1 then timer[4].time := time
      end
end;


(***************************************.*******.************************************
   timestart - starts a timer.  A count is kept such that nested calls may be made
               to this routine and still have the time accumlated via "timepeak".
*)
(*$S LockDown *)
procedure timestart
  (* slot : integer
  *);
var temp : longint;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if (slot > 1) and (slot <> 4) then
      with timer[4] do begin
         temp := elapstime - time - 145;
         tot  := tot + temp
      end;
   if slot = 4 then startTMtime;
   with timer[slot] do begin
      if cnt > 0 then timepeak(slot)
      else begin
              {check if hourglass cursor should be put up immediately, if the
               previous accumlated time is past the alloted time
              }
              if slot = 0 then timepeak(slot);
              time := elapstime
           end;
      cnt  := cnt + 1
   end
end;


(*$ENDC *)
ÿ