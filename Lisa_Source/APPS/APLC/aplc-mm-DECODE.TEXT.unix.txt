
                            {'Copyright 1983, 1984, Apple Computer Inc.'}

(***************************************.*******.********************************************************
   NextPcode - advances `formIndex` which is the index into the `formula` to the next p-code.  The
               new index is returned via `formIndex`.

   NOTE: an assumption is made that when `formIndex` is passed into the routine, it already points to
         a p-code.
****************************************.*******.*******************************************************)
(*$S calculator *)
procedure NextPcode
  (formula       : ptrdata;             {ptr to the formula}
   var formindex : integer              {index to next p-code}
  );
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   {if currently on a text pCode, bump the formula index pass the text.  Otherwise move the formula
    index by the amount of data represented by the pCode.}
   if formula^[formindex] = PUSHTEXT then formindex := formindex + formula^[formindex+1] + 2
   else if formula^[formindex] < ENDPCODE then formindex := formindex + pcodesize[formula^[formindex]];
   formindex := formindex + 1
end;


(***************************************.*******.********************************************************
   getoperand - retrieves the operand data for a specific pCode.  The pCode is contained in the byte
                array pointed to by `formula`, and is positioned `formIndex` away from the start of the
                array.  The operand for the pCode will be unpacked and stored in the global variable `VT`.
                `row, col` are used in the calculation of relative coordinates that are generated by a
                shared formula.  `opCode` is used to return the correct error pCode for a coordinate or a
                range when the relative calculation yeilds a reference to a cell not within the matrix.
                Otherwise `opCode` returns the pCode or operator for which data was retrieved.

   NOTE: For the relative calculation, the globals `lastFormula` must be setup thru a call to
         "GetFormula" otherwise 'lastFormula.PRdata` should be set to nil.
****************************************.*******.*******************************************************)
(*$S calculator *)
procedure getoperand
  (formula    : ptrData;                {ptr to the formula}
   formindex,                           {index to the pCode}
   row, col   : integer;                {coords of this particular formula}
   var opCode : byte                    {pCode for which data is to be retrieved}
  );
var dh, dv    : integer;                {relative displacements}
    tempCoord : integer;                {index to paste relative coordinates}
    displace  : boolean;                {displacements available: y/n}

(*$IFC DEBUGVERSION *)
    (*$S debug2 *)
    procedure dumpinfo;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

     writeln('Getoperand: ',row:1,',',col:1,'  rowrel: ',
               lastformula.PRdata^[lastformula.coordcnt * 2],
               '  colrel: ',lastformula.PRdata^[lastformula.coordcnt * 2 + 1],
               '  coordcnt: ',lastformula.coordcnt:1,'  dh,dv: ',dh:1,',',dv:1)
    end;
(*$ENDC *)


(*$S calculator *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   {get the pCode, be it an operator or a pCode.}
   opCode := formula^[formindex];

   {is it really a pCode or just an operator? }
   if opCode <= ENDPCODE then begin

      {retrieve data for the pCode based on the size of data associated with the pCode}
      moveLfast(@formula^[formindex + 1], @VT, pcodesize[opCode]);

      {was the pCode a coordinate.  If so, we might have to do a relative calculation}
      if opCode <= ENDCOORD then begin

         {relative calculation information is pointed to by `PRdata`; and if it is nil, then we don't have
          to do much.  Otherwise, look at the `rowRelative` and `colRelative` info stored in `PRdata` and
          setup the displacements `dh, dv` and keep track of which coordinate we are on.
         }
         displace := false;
         if lastformula.PRdata = nil then begin
            dh := 0;
            dv := 0
         end
         else begin
                 tempCoord := lastformula.coordcnt * 2;
                 if lastformula.PRdata^[tempCoord] then begin
                    displace := true;
                    dv := lastformula.dv + (row - lastformula.row)
                 end
                 else dv := 0;
                 if lastformula.PRdata^[tempCoord + 1] then begin
                    displace := true;
                    dh := lastformula.dh + (col - lastformula.col)
                 end
                 else dh := 0;
(*$IFC DEBUGVERSION *)
                 if debug[13] then dumpinfo;
(*$ENDC *)
                 lastformula.coordcnt := lastformula.coordcnt + 1
              end
      end;

      {verify the data retrieved and place it into `VT` if not already done so.}
      case opCode of
         PUSHECOORD,
         PUSHCOORD     : if displace then
                            if addDhDv(dh, dv, VT.coordvar) then opCode := PUSHECOORD;
         PUSHECRANGE,
         PUSHCRANGE    : if displace then begin
                            if addDhDv(dh, dv, VT.rangevar.first) then opCode := PUSHECRANGE;
                            if addDhDv(dh, dv, VT.rangevar.second) then opCode := PUSHECRANGE
                         end;
         PUSHINT       : I2X(VT.intvar, VT.xrealvar);
         PUSHBYTE      : I2X(VT.bytevar, VT.xrealvar);
         PUSHSREAL     : S2X(VT.srealVar, VT.xrealvar);
         PUSHLREAL     : D2X(VT.lrealVar, VT.xrealvar)
      end
   end
   else VT.bytevar := opCode
(*$IFC DEBUGVERSION *)
   ;if debug[13] or debug[11] then writeln('GetOperand:  opcode: ',opcode:1,'  num: ',wxnum(VT.xrealvar))
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   decompileformula - decodes the formula pointed to by the information in `lastFormula` and produces a
                      textual description of it in the area pointed to by `formStr`.  The maximum amount
                      of the text to be returned is described by `numBytes`.

                      The formula is stored in postorder notation.  The `lastFormula` information is used
                      to build a tree representation of the formula.  The tree is then traversed in an
                      inorder fashion to produce an infix version of the formula.  `getPRinfo` is a flag
                      that determines if paste relative interval information is to be gathered about the
                      generated text.  If so, `relStr` states if the information is to be about the
                      relative string (true) or the absolute string (false).  The information that is
                      generated is passed back through `PRdata`.  `foldlines` is used to signal that
                      the resulting textual description should be folded across mulitple lines
                      (depended upon the width of the cell).  `restPRdata` is used to reset the paste
                      releative information in `PRdata` to that in the formula.

                      An array `nodes` is used to store the tree that is built.  This array is
                      allocated to have as many nodes as the # of bytes in the `eval` array.  This
                      should insure that there is always space to generate the formula, since the
                      array that "parse" used to generate the formula. `eval`, is of the same size and
                      could not generate a tree larger than the # bytes in the formula.  However, in
                      case this does not hold true, a "FatalMess" call will be made to signal a fatal
                      error.  Also, this routine is not used while the some of the larger swapping
                      sections of code are in, thus the large amount of space which is allocate for
                      `nodes` will always exist (approx. 6 bytes * `evalMax` = 6 * 255 = 1.5K).

    NOTE: if `getPRinfo` is false, the `PRdata` record is not used.  Also that the `lastFormula`
          information should be setup before this routine is called. Also, the `eval` array is used to
          save markers as to the positions of the operators/pCodes within the formula.  `eval` is the
          same array used by the "parse" to generate the formula, thus is will always be large enough
          to be used to mark the operators/p-code positions.
****************************************.*******.*******************************************************)
(*$S decompile *)
procedure decompileformula
  (formstr      : ptrdata;              {ptr to where the decoded formula is to go}
   var numBytes : integer;              {# of bytes to be generated}
   row, col     : integer;              {coordinates of the formula}
   PRdata       : TPPRrecord;           {handle to the paste relative information}
   relstr,                              {generate info for the relative or absolute string: y/n}
   getPRinfo    : boolean;              {gather paste relative info: y/n }
   foldlines    : boolean;              {fold the formula across multiple lines: y/n}
   resetPRdata  : boolean               {reset `PRdata` paste relative information to formula information: y/n}
  );
type noderec = record
                  olexeme : integer;    { if >= 0 ptr into formula array else -ord(some lexeme)}
                  left    : integer;    {left sub-tree pointer}
                  right   : integer     {right sub-tree pointer}
               end;
var nodes     : array [0..evalmax] of noderec;
    treehead  : integer;                {ptr to the head of tree}
    evalsize  : integer;                {index into the opcode positions}
    nodecount : integer;                {# of tree nodes generated}
    formindex : integer;                {index into the formula}
    formula   : ptrData;                {ptr to the formula}
    intervals : ^PRinterval;            {ptr to the paste relative interval info}


    (* saveInterval - produces the wording for coordinate/range occurances. Interval information about
                      the wording generated will be computed if the `getPRinfo` flag is true.  The
                      parameters to the routine describe the following:  `coord` = the coordinate to
                      be worded, `inRange` = was the coodinate part of a range and `inError` = was
                      the coordinate from a PUSHECOORD or PUSHECRANGE pCode.  `countOff` is set to true
                      if the first part of a coordinate is being generated.  It is set to false if the
                      second part, which only occurs with coordinate ranges, is being generated.
    *)
    (*$S decompile *)
    procedure saveInterval(inRange, inError : boolean; coord : pident; countoff : boolean);
    var startInterval : integer;        {starting position of interval}
        endInterval   : byte;           {ending position of interval}


       (*$S PRdialog *)
        procedure doGetPrInfo;
        begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

           {save the interval information about the wording just generated}
           with PRdata^ do begin
              numCoords := Cmin(maxPRcoords, numCoords + ord(countoff));
              with intervals^[numcoords] do

                 if countoff then begin

                    {reset the `PRdata` information to the information found in the formula}
                    if resetPRdata then
                       with info[numCoords], lastformula.formptr^^ do begin
                          rowRelative := sdata.PRdata[numCoords * 2];
                          colRelative := sdata.PRdata[numCoords * 2 + 1]
                       end;

                    IsRange := inRange;
                    IsError := inError;
                    lpFst   := startInterval;
                    colDh   := endInterval - 1;
                    rowDh   := messagelen - startInterval - colDh - 1;
                    xrowDh  := 1;
                    xcolDh  := 1
                 end
                 else begin
                         xcolDh := endInterval - 1;
                         xrowDh := messagelen - startInterval - xcolDh - 1
                      end
           end
        end;


    (*$S decompile *)
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       startInterval := messagelen + 1;

       {generate the wording for the coordinate}
       if inError then begin
          writeword(ERRORop);
          endInterval := messagelen - startInterval - 1
       end
       else writecoord(coord, endInterval);

       if getPRinfo then doGetPrInfo    {generate the paste relative information if necessary}
    end;


    (*
       inorder - traverses the tree built by "treebuild" in an inorder fashion and produces any
                 wording needed.  The routine also determines the correct placement of the parenthesis
                 for functions and parentheisized expressions.  `nodePtr` is the pointer to the current
                 node to be worded.
    *)
    (*$S decompile *)
    procedure inorder(nodePtr : integer);
    var sym      : variantType;         {used to coerse a byte into a lexeme}
        currnode : noderec;             {current nodes' information}
        x        : integer;             {loop iterator}
        opCode   : byte;                {opcode for current node}
        tempSpot : integer;             {the position past the current pCode being worded}
        dateStr  : resultStr;           {string used to format dates}
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       {does this node exist in the tree? }
       if nodePtr <> nilval then begin
          currnode := nodes[nodePtr];

          {determine the lexeme associated with tree node}
          if currnode.olexeme < 0 then sym.bytevar := -currnode.olexeme
          else if formula^[currnode.olexeme] > ENDPCODE then sym.bytevar := formula^[currnode.olexeme]
          else sym.lexeme := JUNKop;
          {if at a right paren node, generate associated left paren}
          if sym.lexeme = RPARENop then writechar('(');

          inorder(currnode.left);

          {generate operator - skipping if at a right paren node}
          if sym.lexeme <> RPARENop then
             if sym.lexeme = JUNKop then begin

                {determine the type of pCode and get its operand to be worded}
                getoperand(formula, currnode.olexeme, row, col, opCode);
                tempSpot := currnode.olexeme + pcodesize[opCode] + 1;
                case opCode of
                   PUSHTRUE    : writeword(TRUEop);
                   PUSHFALSE   : writeword(FALSEop);
                   PUSHECOORD,
                   PUSHCOORD   : saveInterval(false, opCode = PUSHECOORD, VT.coordvar, true);
                   UNARYMINUS  : writechar('-');
                   PUSHECRANGE,
                   PUSHCRANGE  : begin
                                    saveInterval(true, opCode = PUSHECRANGE, VT.rangevar.first, true);
                                    writechar(':');
                                    saveInterval(false, opCode = PUSHECRANGE, VT.rangevar.second, false)
                                 end;
                   PUSHDATE    : begin
                                    writechar('"');
                                    dateString(VT.date, dateStr);
                                    writestring(dateStr);
                                    writechar('"')
                                 end;
                   PUSHTEXT    : begin
                                    writechar('"');
                                    for x := 1 to formula^[tempSpot] do
                                       writechar(chr(formula^[tempSpot + x]));
                                    writechar('"')
                                 end;
                   otherwise     begin
                                    opCode := formula^[tempSpot];
                                    case opCode of
                                       PUSHDOLLAR,
                                       PUSHCDOLLAR : begin
                                                        if dataFormat.dSignPos then writeString(dataformat.dSign);
                                                        writefnum(VT.xrealvar, opCode = PUSHCDOLLAR);
                                                        if not dataFormat.dSignPos then writeString(dataformat.dSign)
                                                     end;
                                       otherwise     writenum(VT.xrealvar)
                                    end
                                 end
                end
             end
             else if (sym.lexeme = COMMAop) and dataFormat.useSColon then writechar(';')
             else writeword(sym.lexeme);

          inorder(currnode.right);

          {generate right paren for functions and expressions}
          if token[sym.lexeme] in [RPAREN, FUNC2, FUNC3] then writechar(')')
       end
    end;


    (*
       treebuild - takes the postordered formula in `formula` and generates an associated binary tree.
                   The tree is headed by `treeHead`.  Some tricks in how the tree is built are performed
                   to accomadate modifiers, functions and unary operations which are not binary type
                   operators like + or mod.  The `eval` array has information about the position of the
                   pCodes/operators and is used to go backwards from opcode to opcode.
    *)
    (*$S decompile *)
    procedure treebuild(var nodePtr : integer);
    var newnode  : integer;             {index to the new node}
        currnode : ^noderec;            {ptr to the new node}
        done     : boolean;
        lexord   : byte;                {ordinal value of the current lexeme or p-code}
        lextoken : integer;             {token value for the current lexeme}
        sym      : variantType;         {used to coerce a byte into a lexeme}
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       if evalsize >= 0 then begin

          {allocate a new node and fill in data}
          nodecount := nodecount + 1;
          if nodeCount > evalMax then begin
             evalsize := -1;
             exit(treebuild)
          end;
          newnode   := nodecount;
          currnode  := @nodes[newnode];
          with currnode^ do begin
             left        := nilval;
             right       := nilval;
             sym.intvar  := 0;
             sym.byteNum := eval[evalsize];
             olexeme     := sym.intvar;
             lexord      := formula^[olexeme]
          end;

          {make the previous node point to the new node}
          nodePtr  := newnode;
          evalsize := evalsize - 1;

          {determine if we have an operator?}
          if (lexord > ENDPCODE) or (lexord = ord(NOTop)) or (lexord = UNARYMINUS) then begin

             {unpack lexeme for the operator}
             sym.bytevar := lexord;
             if sym.bytevar = UNARYMINUS then sym.lexeme := SUBop;
             lextoken := token[sym.lexeme];

             {is lexeme a function with arguments?  If so grab its arguments.  Functions are an
              anomally which require the generation of extra nodes which represent the commas between
              arguments.  Yes, this is how we make a function look like a binary operation by using the
              commas as operators.
             }
             if (lextoken = FUNC2) or (lextoken = FUNC3) then begin
                repeat

                   {allocate a new node, making it into a comma node}
                   nodeCount := nodeCount + 1;
                   if nodeCount > evalMax then begin
                      evalSize := -1;
                      exit(treeBuild)
                   end;
                   with nodes[nodecount] do begin
                      left    := nilval;
                      right   := nilval;
                      olexeme := -ord(COMMAop)
                   end;
                   if currnode^.right = nilval then currnode^.right := nodecount
                   else currnode^.left := nodecount;
                   newnode  := nodecount;
                   currnode := @nodes[newnode];

                   {build function argument to the right of the newly created comma node and stop if the
                    end of the function is reached.
                   }
                   treebuild(currnode^.right);
                   done := (lextoken = FUNC3) or (evalSize < 0);
                   if not done then begin
                      sym.intvar  := 0;
                      sym.byteNum := eval[evalSize];
                      done := (formula^[sym.intVar] = PUSHMARKER)
                   end
                until done;

                if lextoken <> FUNC3 then evalsize := evalsize - 1;
                {change the last comma node to a left paren}
                currnode^.olexeme := -ord(LPARENop)
             end

             {build sub-trees - avoiding left subtree on unary, not, constant funcs and paren ops, and
              avoiding the right subtree for modifiers
             }
             else if lextoken <> FUNC1 then begin
                     if lextoken <> MODIFIER then treebuild(currnode^.right);
                     if lextoken <> RPAREN then
                        if (lexord <> ord(NOTop)) and (lexord <> UNARYMINUS) then treebuild(currnode^.left)
                  end
          end
      end
   end;

(*$S decompile *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if getPRinfo then begin
      PRdata^.numCoords := -1;
      if relstr then intervals := @PRdata^.relStr[0]
      else intervals := @PRdata^.absStr[0]
   end;

   {determine the opcode positions for the marker array}
   formula   := lastformula.ptr;
   evalsize  := -1;
   nodecount := -1;
   formindex := 0;
   while formula^[formindex] <> PUSHEND do
      case formula^[formindex] of
         PUSHDOLLAR,
         PUSHCDOLLAR,
         PUSHNOP      : formindex := formindex + 1;
         otherwise      if evalsize < evalMax then begin
                           evalsize := evalsize + 1;
                           eval[evalsize] := formindex;
                           NextPcode(formula, formindex)
                        end
                        else begin
                                numBytes := 0;
                                exit(decompileformula)
                             end
      end;

   {build the tree}
   treehead := nilval;
   treebuild(treehead);

   {produce the wording for the tree}
   if nodecount <= evalmax then begin
      startwrite(formstr, numBytes);
      inorder(treehead);
      if foldlines then begin
         writechar('=');
         writechar(chr(13))
      end;
      numBytes := messagelen + 1
   end
(*$IFC DEBUGVERSION *)
   else FatalMess(26)
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   FoldedFormula - calculates the # of folds necessary for the formula at located `rowId, colId` such
                   that it will fit into the column.  The text of the formula will be placed into the
                   area pointed to by `formula`.  A maximum # of chrs (specified by `numBytes`) will be
                   placed in the area specified by `formula` with the actual # of chrs placed being
                   returned through `numBytes`.  If a formula does not exist at `rowId, colId`,
                   `numBytes` will be set to zero.  The folds will consist of carraige returns (chr13)
                   embedded in the formula.
****************************************.*******.*******************************************************)
(*$S showForms *)
procedure FoldedFormula
  (* rowId, colId : idType;             {location of the cell}
     formula      : ptrData;            {ptr to the formula characters}
     var numBytes : integer             {error status number}
  *);
var PRdata    : TPPRrecord;             {dummy paste relative info : not used}
    chrsInCol : integer;                {# chrs to fit into of the column}
    count     : integer;                {# folds to put into the formula}
    spot      : integer;                {current fold being put in the formula}
    temp      : integer;                {current spot in the formula}
    maxBytes  : integer;                {max # of chrs to fit in the formula}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetFormula(rowId, colId, false);             {get the formula information}
   if (lastformula.ptr <> nil) and not printstate.preview then begin         {test if the formula exists}

      {get the decompiled version of the formula.  A chr13 will already be at the end of the folded formula}
      maxBytes := numBytes;
      decompileformula(formula, numBytes, rowId, colId, PRdata, false, false, true, false);

      {determine the number of folds need to be placed in the formula text}
      numbytes  := numbytes - 1;
      chrsInCol := SnipWidth(colKind, colId);
      count     := (TabFWidths.w * numBytes) div chrsInCol;
      chrsInCol := chrsInCol div TabFWidth.w;
      numbytes  := numbytes - 1;

(*$IFC DEBUGVERSION *)
      if debug[5] then begin
         writeln('count,numbytes, chrsInCol: ',count, numbytes, chrsInCol);
      end;
(*$ENDC *)

      {if the number of folds that must be added to the formula plus the # of characters already
       in the formula will be longer than the maximum number of bytes, then reduced the number of
       folds to be added.
      }
      if count + numBytes + 1 > maxBytes then count := maxBytes - numBytes - 1;

      {add the folds to the formula text}
      for spot := 1 to count do begin
         temp := chrsInCol*spot + spot-1;
         numBytes := numBytes + 1;
         moveRfast(@formula^[temp], @formula^[temp + 1], numBytes - temp);
         formula^[temp] := 13
      end;

      {make sure that the last byte of the formula has a chr13 at the end}
      if formula^[numbytes] <> 13 then begin
         numBytes := numbytes + 1;
         formula^[numbytes] := 13
      end;
      numbytes := numbytes + 1;
      count := count + 1

(*$IFC DEBUGVERSION *)
      ;if debug[5] then begin
         for spot := 0 to numbytes - 1 do write(formula^[spot]:4);
         writeln
      end
(*$ENDC *)
   end
   else numBytes := 0
end;


(***************************************.*******.********************************************************
   GetPRcoords - returns the location of the first shared located at `rowId, colId`.  The location is
                 returned through `rowId, colId`.

   NOTE: an assumption is made that a formula with shared information exists at `rowId, colId`.
****************************************.*******.*******************************************************)
(*$S PRdialog *)
procedure GetPRcoords
  (* var rowId, colId : integer         {location of the cell}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetFormula(rowId, colId, false);     {get the formula information}
   rowId := lastformula.row;            {return the shared cell location}
   colId := lastformula.col
end;


(***************************************.*******.********************************************************
   IsTextstring - determines if the newly parsed formula in `eval` is a text string or non text string.
                  True is returned as the value of the function if there is a text string.  If the
                  formula is found to be a non text value, the value will be return via `number`.  A
                  special flag `money` is returned if the numeric value is actually a money value.

   NOTE: this routine expects a newly parsed formula to exist in `eval` and that the parsing operation
         that generated the formula was PValue (for parse value).
****************************************.*******.*******************************************************)
(*$S compile *)
function  IsTextstring
  (* var number   : valueType;          {value of string, if string is a number}
     var money    : boolean             {was the number a money value? }
  ) : boolean *);                       {was it a text string: y/n}
var pos      : integer;                         {position of a possible unary operator with `eval}
    tempOp   : byte;                            {opCode for a possible number modifier}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if eval[0] = PUSHTEXT then begin                     {was text generated, if so return that fact}
      money := false;
      IsTextstring := true
   end
   else begin
           IsTextstring := false;                       {otherwise, determine if a money figure was entered}
           lastformula.PRdata   := nil;
           lastformula.ptr      := @eval[0];
           calculate(number, -1, -1);
           pos := ord(eval[0] = UNARYMINUS);
           tempOp := eval[pos + pcodesize[eval[pos]] + 1];
           money := (tempOp = PUSHDOLLAR) or (tempOp = PUSHCDOLLAR)
        end
end;


(***************************************.*******.********************************************************
   NumOfFormulaFolds - changes the row heights for each row such that the height will accomadate the
                       longest formula in that row when it is folded.

   NOTE: the `eval` array is used to temporarily hold the folded formula.  This array is definitily
         long enough to hold the formula, but may not be long enough to hold the formula with the
         embedded carraige returns which represent the folds.
****************************************.*******.*******************************************************)
(*$S showForms *)
procedure NumOfFormulaFolds;
var row, col : integer;                 {row/column loop iterators}
    x        : integer;
    rowmax   : integer;                 {maximum # of folds on the current row}
    count    : integer;                 {# of folds in the formula}
    numBytes : integer;                 {maximum # of bytes for the formula}
    rg       : range;                   {used to set the row heights}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   for row := 1 to FinalSnip(rowKind) do begin
      {`rowmax` will be the count of the largest # of rows needed to display the formulas in a given row}
      rowmax := 0;
      for col := 1 to FinalSnip(colKind) do begin
         numBytes := evalmax + 1;

         FoldedFormula(row, col, @eval[0], numBytes);   {fold the formula at `row, col`}

         count := 1;                                    {count the number of rows needed for the folded formula}
         if numBytes > 0 then
            for x := 0 to numBytes-1 do
               if eval[x] = 13 then count := count + 1;

(*$IFC DEBUGVERSION *)
         if debug[5] then writeln(row:1,',',col:1,' count: ',count:1);
(*$ENDC *)

         if count > rowmax then rowmax := count         {keep track of the maximum number of rows}
      end;
      rowmax  := rowmax * TabFWidths.h;                 {determine the actual row height}
      if SnipWidth(rowKind, row) < rowmax then begin    {set the row height for the row if necessary}
         rg.loRow := row;
         rg.hiRow := row;
         SetVecWid(rowKind, rowmax, rg)
      end
   end
end;


(***************************************.*******.********************************************************
   unPackValue - retrieves the information about the value pointed to by the handle `hContents` and the
                 pointer within the value `pValue`.  The information will be unpacked and returned via
                 the variant `result`, normally, and also appear in FP0 if appropraite.  The information
                 will only appear in FP0, not `result`, if `inCalc` is true which means that a formula
                 is being calculated and will only look for results in FP0.  This is done mainly for
                 speed.  For information that cannot be represent in FP0, `result` will be set (ie, for
                 date parts}

                 The form that the information is returned is depended upon `fullInfo`.  With `fullInfo`
                 set to true, the actual value or else a descriptor to how to get the actual value will
                 be returned.  The descriptor result normally is a result from the value being
                 not-a-number.  `fullInfo` set equal to false, will return a zero for some cases where
                 a descriptor would have been returned (this information is dependent upon the
                 application; LisaCalc will get different results than Business Graphics).

                 If an assumption was made about the data such that a zero was returned instead of the
                 actual value, `assume` will be set to true.

   NOTE: the is no check made to insure that `hContents` and `pValue` are not nil.  It is assumed that
         both are pointing at real data, and that `pValue` points to some value field (eiter rule.value
         or value).
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure unPackValue
  (* hContents    : THContents;         {handle to the value}
     pValue       : TPValue;            {ptr to the value}
     fullinfo     : boolean;            {return full information: y/n}
     var result   : valueType;          {the result, of course}
     var assume   : boolean             {asumption made about the data: y/n}
  *);
var dataPtr : ptrdata;                          {pointer into text}
    lResult : valueType;                        {temporary to hold the result - done for codesize & speed}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   assume  := false;                            {lets start with no assumptions}
   lResult := result;                           {and whatever result we already have}
   with hContents^^, pValue^ do begin

      lResult.nan := syNone;                    {set the type of what we have to be kosher}

      {determine exactly what it is we have and set the information in `lResult` has approriate}
      case vinfo.data.TCsize of
         sWord   : I2X(word, lResult.val.xrealvar);          {16 bit quantities}
         sShort  : S2X(short, lResult.val.xrealvar);         {32 bit real}
         sLong   : D2X(long, lResult.val.xrealvar);          {64 bit real}
         otherwise begin
                      {we have something that is non-a-number.  Depending if full information is
                       desired, set up a NAN situation or a kosher '0' value situation.  This
                       information may later change if fursther information about the value is found.
                      }
                      if fullinfo then begin
                         lResult.nan := vinfo.data.TCsymbol;
                         lResult.val.xrealvar := VofNAN
                      end
                      else begin
                              lResult.nan := syNone;
                              lResult.val.xrealvar := xVofZero
                           end;

                      {determine any further information about the value}
                      case vinfo.data.TCsymbol of
                         syTrue  : I2X(1, lResult.val.xrealvar);     {a true value equals a one}
                         syFalse : lResult.val.xrealvar := xVofZero; {a false value equals a zero}
                         syPinf  : begin                {positive infinity value}
                                      if app.LisaCalc then lResult.nan := syPinf;
                                      lResult.val.xrealvar := VofPinf
                                   end;
                         syMinf  : begin                {negative infinity value}
                                      if app.LisaCalc then lResult.nan := syMinf;
                                      lResult.val.xrealvar := VofMinf
                                   end;
                         syDate  : if fullinfo or app.LisaCalc then begin
                                      lResult.nan := syDate;
                                      lResult.val.lrealvar := VofZero;
                                      moveLfast(@bytes, @lResult.val, pcodesize[PUSHDATE]);
                                      D2X(lResult.val.lrealvar, lResult.val.xrealvar)
                                   end
                                   else assume := true;
                         syParts : if fullinfo or app.LisaCalc then begin
                                      lResult.nan := syParts;
                                      moveLfast(@bytes, @lResult.val, pcodesize[PUSHPARTS])
                                   end
                                   else assume := true;
                         syText  : if fullinfo then begin
                                      lResult.val.textinfo.hContent := hContents;
                                      lResult.val.textinfo.index    := ord(pValue) - ord(hContents^);
                                      lResult.val.textinfo.len      := 0;
                                      dataPtr := @bytes;
                                      while dataPtr^[lResult.val.textinfo.len] <> 0 do
                                         lResult.val.textinfo.len := lResult.val.textinfo.len + 1
                                   end
                                   else assume := true;
                         otherwise begin
                                      lResult.nan := vinfo.data.TCsymbol;
                                      lResult.val.xrealvar := VofNAN
                                   end
                      end
                   end
      end
   end;
   result := lResult

(*$IFC DEBUGVERSION *)
   ;if debug[11] then begin
      writeln('UnpackValue(',fullinfo,') nan: ',wnan(result.nan),'  val: ',wxNUM(result.val.xrealvar))
   end

(*$ENDC *)
end;


ÿ