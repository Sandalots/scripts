
                            {'Copyright 1983, 1984, Apple Computer Inc.'}

(***************************************.*******.********************************************************
   aRgInScrap - determines if the scrap has cells on it.  If it does not, the function result will be
                false and `numBytes` will be returned as 0.  If the scrap does have cells on it, the
                character representaion of the top-left cell will be filled into the area pointed to
                by `value`.  The characters returned will be formatted like the wide angle view
                if `wideFlg` is true.  `numBytes` will be set to the number of characters actually
                returned which could be 0 if the top left cell is empty.

   NOTE: when the routine is called, `numBytes` should be set to the max number of characters to be
         passed back.  The routine will set `numBytes` equal to the number of characters actually
         returned.  If the character representation is not available, `numBytes` will be returned as 0.
****************************************.*******.*******************************************************)
(*$S TxtCutPaste *)
function aRgInScrap
  (* value        : ptrData;            {ptr to where the characters are to go}
     wideFlg      : boolean;            {format for the wide angle display? }
     var numBytes : integer             {max # of characters /actual # of characters returned}
  ) : boolean *);
var oper      : undoType;                       {type of info in the scrap}
    sRg       : range;                          {range of values on the scrap}
    lastIds   : pIdent;                         {boundaries of the range of values}
    FBufTemp  : THptrData;                      {temps to save FBufPtr state}
    scrapBool : boolean;                        {temp for using scrap flag}
    valuePres : boolean;                        {value was present in the top-left cell flag}
    status    : integer;                        {status info - should always be ok}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   valuePres := false;
   if ScrapPtr <> nil then begin                {is there a scrap to look at?}
      FBufTemp  := FBufPtr;                     {save FBufPtr info and scrap usage flag}
      scrapBool := UsingScrap;
      FBufPtr   := ScrapPtr;                    {switch to point at the scrap informatiom}
      ReadHeader(oper, sRg, lastIds, status);   {read header information from the scrap}
      expandRange(sRg, true);                   {expand the range info to get top left coordinate}
      UsingScrap := true;                       {switch to read cell info from the scrap}
      CellValue(mmRead, sRg.loRow, sRg.loCol, value, wideFlg, numBytes, status);
      valuePres := (status = ok);
      UsingScrap := scrapBool;                  {restore FBufPtr state and scrap flag}
      FBufPtr    := FBufTemp
   end;
   aRgInScrap := valuePres;                     {set function result}
   if not valuePres then numBytes := 0
end;


(***************************************.*******.********************************************************
   AllocBlock - allocates a new block of data on the local heap using the standard storage allocator.
                `NumBytes` is the number of bytes to be allocated.  The function result will be set to
                the handle of the block.  A count of the number of blocks allocated in the heap (`mxHz`)
                is kept in `numHandles`.

   NOTE: if the block cannot be allocated, the result of the function will be set to nil.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function allocBlock
  (* numBytes : integer                 {# of bytes to allocate}
  ) : THContents *);                    {handle to allocated block}
var hContents : THContents;                     {handle returned by storage allocator}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   timer[10].cnt := timer[10].cnt + 1;
   if debug[10] and not debug[23] then timeStart(8);
   if debug[16] and debug[19] then writeln('allocBlock: ',timer[10].cnt:1);
   if debug[16] and (timer[10].cnt mod 10 = 0) then hContents := pointer(ord(hnil))
   else
(*$ENDC *)

   hContents := pointer(ord(HAllocate(mxHz, numBytes)));        {allocate the block}
   if ord(hContents) = ord(hNil) then hContents := nil          {if stoarge allocator failed, set result to nil}
   else numHandles := numHandles + 1;                           {otherwise increment the handle counter}
   allocBlock := hContents                                      {set function result}

(*$IFC DEBUGVERSION *)
   ;if debug[10] and not debug[23] then timePeak(8);
   if debug[19] or debugMx or traceMMgr then
      writeln('allocating ',numBytes:1,' bytes ',hcontents<>nil,' ',ord(hcontents));
   if debug[26] then begin
      writeln('MxHz ok: ',FcheckHzOK(mxHz, numbytes),'  # blocks: ',numbytes:1,'/',numHandles:1);
      if numHandles <> numBytes then
          writeln(chr(7),'allocBlock: numHandles <> numBlocks: ',numHandles:1,'/',numbytes:1)
   end
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   CellAttr - reads the packed attribute record of a cell and returns it unpacked.  The location of the
              cell is given by `rowId, colId`.  The unpacked information is returned through 'attrRec'.

   NOTE: if `rowId, colId` points to cell which is not allocated, the attributes of a blank cell will be
         returned.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure CellAttr
  (* rowId, colId : idType;             {location of the cell}
     var attrRec  : attrRecord          {unpacked attributes for the cell}
   *);
var pCel    : TPCel;                            {ptr to the cell information}
    attr    : TAttr;                            {packed cell attributes}
    variant : variantType;                      {packing variant used to unpack money format}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   DebugMess(23);
(*$ENDC *)

   with attrRec do begin
      pCel := FindPCel(rowId, colId, false);            {get pointer to the cell}
      GetCellAttr(pCel, attr, rowId, colId);            {get the packed attributes for the cell}

      attAlign  := attr.pkAlign;                {unpacked alignment information}
      attProt   := attr.pkProt;                 {unpacked protection information}
      if attAlign = aInvis then attProt := ProtAll;

      theAlFmt.alFormat := attr.pkFormat;       {get the formatting information}
      case theAlFmt.alGrp of                    {unpack the formatting information}
         gMisc   : begin                {misc. format}
                      attFormat := theAlFmt.alMisc;
                      attPlaces := 0
                   end;
         gMoney  : begin                {money format}
                      attFormat := fMoney;
                      variant.unByte := theAlFmt.alMoney;
                      attMoney  := variant.unMoney
                   end;
         otherwise begin                {decimals & scientific format}
                     case theAlFmt.alDec of
                        dDecimal    : attFormat := fDecimal;
                        dScientific : attFormat := fScientific
                     end;
                     attPlaces := theAlFmt.decPlaces
                  end
      end
   end

(*$IFC DEBUGVERSION *)
   ;DebugMess(24)
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   CellBit - sets the function result to the state of the specified bit `bitNum` for the cell at
             `rowId, colId`.  If the cell does not exist, the function result will be false.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function  CellBit
  (* rowId, colId : idType;             {location of the cell}
     bitNum       : bitKind             {bit to be inquired}
  ) : boolean *);                       {state of the bit}
var pCel      : TPCel;                          {ptr to the cell informatiom}
    attr      : TAttr;                          {packed cell attributes}
    hContents : THContents;                     {handle to the cell data}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   pCel    := FindPCel(rowId, colId, false);            {get pointer to the cell}
   CellBit := false;                                    {set default function result}
   if pCel <> nil then begin                            {does the cell exist?}
      GetCellAttr(pCel, attr, rowId, colId);            {get the cells packed attributes}
      case bitNum of                                    {check the state of the appropriate bit}
                                        {these bits are directly off the pointer to the cell}
         BInvalid  : CellBit := attr.pkInvalid;
         BCircle   : CellBit := attr.pkCircle;
         BInCopy   : CellBit := attr.pkInCopy;
         otherwise   begin              {these bits are off the handle to the cell data}
                        hContents := GetHContents(pCel);        {get handle to the cell}
                        if hContents <> nil then                {does the handle exist?}
                           with hContents^^.vinfo.data do       {check the state of the appropriate bit}
                              case bitNum of
                                 BCellSeen : CellBit := cellseen;
                                 B1Marked  : CellBit := marked1;
                                 B2Marked  : CellBit := marked2
                              end
                     end
      end
   end
end;


(***************************************.*******.********************************************************
   CellBlank - sets the function result to true if the cell at `rowId, colId` is not blank (has a value}.
               If the cell does not exist, the function result will be true.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function  CellBlank
   (* rowId, colId : idType             {location of the cell}
   ) : boolean *);                      {state of the cell}
var pCel : TPCel;                               {ptr to the cell information}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   pCel := FindPCel(rowId, colId, false);       {get pointer to the cell}
   if pCel = nil then CellBlank := true         {does the cell exist?}
   else CellBlank := (pCel^.oh = 0)             {cell will be blank if it has no value}
end;


(***************************************.*******.********************************************************
   CellContents - depending upon `mode`, reads or writes the contents record `cnRec` for the cell at
                  `rowId, colId`.  During a mmWrite, `cnRec` will be packed and stored away in the matrix.
                  If the cell cannot be written to the matrix, `status` will be returned set to OutOfMem or
                  DSpaceErr dependeding in the error.

                  A mmRead will unpack the record and return it through `cnRec`.  `fullinfo' determines
                  if `cnRec` gets completly filled in or abbreviated with some fields not set.  The
                  abbreviated form is used when most of the fields in `cnRec` are about to be changed
                  or are not needed.  (i.e., when a new value is about to be put in the matrix using
                  "PutValue").  The abbreviated form sets the following information:

                       cnPCel      : TPCel;             {pointer to cell information}
                       cnHContents : THContents;        {handle to cell data}}
                       cnInCopy    : boolean;           {cell involved in a copy}
                       cnHasRule   : boolean;           {cell has rule}

                 `status` will be returned set to ok (0) if everything went alright.

   NOTE: a FatalError will occur if the scrap is active during a mmWrite.  This should never happen.
         On a mmRead, if `rowId, colId` point to cell which are not allocated, the attributes of a
         blank cell will be used.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure CellContents
  (* mode         : IOModeType;         {reading/writing mode flag}
     rowId, colId : idType;             {location of the cell}
     fullinfo     : boolean;            {return the full cnRecord info: y/n}
     var cnRec    : cnRecord;           {record to be read/written}
     var status   : integer             {error status number}
  *);
var pCel : TPCel;                               {ptr to the cell information}
    attr : TAttr;                               {packed cell attributes}
    Cel  : TCel;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   DebugMess(25);
(*$ENDC *)

   status := ok;
   {get pointer to the cell, creating one on a write if necessary}
   pCel   := FindPCel(rowId, colId, mode = mmWrite);

   {get the attribute information for the cell}
   if fullinfo then GetCellAttr(pCel, attr, rowId, colId);

   with cnRec do
      if mode = mmRead then begin                       {unpacked the contents record for the cell}
         cnHContents := GetHContents(pCel);     {set handle do cell data}
         cnPCel      := pCel;                   {set pointer to cell information}
         if cnHContents <> nil then begin       {does the cell exist?}
            if fullinfo then                    {set all the bit information for the cell}
               with cnHContents^^.vinfo.data do begin
                  cnHasRule   := attr.pkHasRule;
                  cnInCopy    := attr.pkInCopy;
                  cnInvalid   := attr.pkInvalid;
                  cnDollar    := attr.moneyBit;
                  cnRepeat    := (attr.pkAlign = aRepeating);
                  cnSize      := TCsize;
                  cnIs1Marked := marked1;
                  cnIs2Marked := marked2;
                  cnNumber    := TCnumber;
                  if cnSize = sSymbol then cnSymbol := TCsymbol
               end
            else with pCel^.attributes do begin
                    cnHasRule := pkHasRule;
                    cnInCopy  := pkInCopy
                 end
         end
         else begin                                     {set up bit information based on a blank cell}
                 cnHasRule := false;
                 cnInCopy  := false;
                 if fullinfo then begin
                    cnInvalid   := false;
                    cnSize      := sSymbol;
                    cnSymbol    := syText;
                    cnRepeat    := false;
                    cnDollar    := false;
                    cnIs1Marked := false;
                    cnIs2Marked := false
                 end
              end
      end
(*$IFC DEBUGVERSION *)
      else if UsingScrap then FatalMess(5)
(*$ENDC *)
      else if pCel <> nil then begin                    {was the cell allocated?}

              SetBits(pCel, cnRec);

(*

              {pack the contents record for the cell}
              with pCel^.attributes do begin
                 pkInvalid := cnInvalid;
                 pkHasRule := cnHasRule;
                 pkInCopy  := cnInCopy;
                 moneyBit  := cnDollar
              end;
              if cnHContents <> nil then
                 with cnHContents^^.vinfo.data do begin
                    marked1  := cnIs1Marked;
                    marked2  := cnIs2Marked;
                    TCsize   := cnSize;
                    TCnumber := cnNumber;
                    if cnSize = sSymbol then TCsymbol := cnSymbol
                 end;
*)

              if cnHContents <> GetHContents(pCel) then begin
                 Cel := pCel^;
                 with pCel^ do
                    if cnHContents = nil then oh := 0
                    else begin
                            oh := GetOH(ord(cnHContents));
                            cnHContents^^.vinfo.data.refCnt := 1
                         end;
                 FreeContents(@Cel)
              end
           end
      else if diskErr then status := dSpaceErr
      else status := OutofMem

(*$IFC DEBUGVERSION *)
   ;DebugMess(26);
   StatusMess(status)
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   CellFlags - returns the packed attribute flags through `attr` for the cell located at `rowId, colId`.

   NOTE: if `rowId, colId` point to cell which are not allocated, the attributes of a blank cell will
         be returned.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure CellFlags
  (* rowId, colId : idType;             {location of the cell}
     var attr     : TAttr               {cell's packed attributes}
   *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetCellAttr(FindPCel(rowId, colId, false), attr, rowId, colId)
end;


(***************************************.*******.********************************************************
   CellHasRule - sets the function result to true if the cell at `rowId, colId` has a rule associated
                 with it.  If the cell does not exist, the attributes of a blank cell will be
                 returned (false).
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function CellHasRule
  (* rowId, colId : idType              {location of the cell}
  ) : boolean *);                       {state of the cell}
var attr : TAttr;                               {packed cell attributes}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   CellFlags(rowId, colId, attr);       {get the packed attributes for the cell}
   CellHasRule := attr.pkHasRule        {set function result}
end;


(***************************************.*******.********************************************************
   CellHasValue - sets the function result to true if the cell at `rowId, colId` has a numeric value
                  associated with it.  If the cell does not exist, the attributes of a blank cell will
                  be returned (false).
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function CellHasValue
  (* rowId, colId : idType              {location of the cell}
  ) : boolean *);                       {state of the cell}
var typeOfCell : cellKind;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   CellType(rowId, colId, typeOfCell);
   CellHasValue := (typeOfCell = tNumber)
end;


(***************************************.*******.********************************************************
   CellInfo - returns the packed alignment and hilight information for the cell located at `rowId, colId`.
              The unpacked information will be returned through `cellRec`.   If the cell does not exist,
              the attributes of a blank cell will be used.  If `colId` is mInfSnip then information about
              the row title will be returned, `rowId` equally mInfSnip will return information about the
              column title.

   NOTE: A fatal error will occur if `mode` does not equal mmRead or `parName` does not equal cRecord.
         A different fatal error will occur if both `rowId` and `colId` are mInfSnip.  Both errors
         should never happen.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure CellInfo
  (* parName      : cellParType;        {which parameter to read/write}
     mode         : IOModeType;         {reading/writing mode flag}
     rowId, colId : idType;             {location of cell}
     var cellRec  : cellRecord          {record to be read/written}
  *);
var pCel   : TPCel;                             {ptr to the cell information}
    attr   : TAttr;                             {packed cell attributes}
    snipId : idType;                            {temporary column snipId}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   TraceMess(11);
   if debug[5] or debug[20] then begin
      write(rowid:1,',',colid:1,'  ');
      meminfo(rowId, colid, true)
   end;
   if (mode <> mmRead) or (parName <> cRecord) then begin
      FatalMess(38);
      exit(CellInfo)
   end;
(*$ENDC *)

   with cellRec do begin
      hiLite  := false;         {set default information}
      dim     := false;
      numRuns := 0;
      align   := left;                  {assume the alignment will be to the left}
      font    := CT^.TableFont;         {set the font to current table font}

      if (rowId <> minFsnip) and (colId <> minFsnip) then begin         {check for row/column titles}
         pCel := FindPCel(rowId, colId, false);         {get pointer to the cell}
         GetCellAttr(pCel, attr, rowId, colId);         {get attributes for the cell}

         protected := isProtected(attr);                {set protection}
         hiLite    := attr.pkCircle and not printState.preview;                    {set circle hilight}
         case attr.pkAlign of                           {set alignment}
           {aRepeating : align := left; }
           {aLeft      : align := left; }
            aRight     : align := right;
            aCenter    : align := center;
            aStandard  : if CellHasVaule(rowId, colId) then align := right
                        {else align := left }
         end;
         if printState.preview then align := left
      end
(*$IFC DEBUGVERSION *)
      else if rowId = colId then FatalMess(13)
(*$ENDC *)
      else begin
              if rowId = mInfSnip then begin    {set information for a column title}
                 align := center;
                 if app.BusGraph then begin     {set column dimming for Business Graphics}
                    snipId := colId;
                    if (GType = Pie) and (snipId > 2) then dim := true
                    else if snipId > 9 then dim := true
                 end
              end;
             {else align  := left}

              protected := true
           end
   end

(*$IFC DEBUGVERSION *)
   ;TraceMess(12)
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   CellRun - Returns the number of text formatting runs for the cell located at `rowId, colId` in
             `numRuns`.  In LisaCalc or Business Graphics the number of runs is always 0.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure CellRun
  (* mode         : IOModeType;         {reading/writing mode flag}
     rowId, colId : idType;             {location of the cell}
     value        : ptrRuns;            {ptr to run info}
     var numRuns,                       {# of runs}
         status   : integer             {error status number}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   numRuns := 0;
   status  := ok
end;


(***************************************.*******.********************************************************
   CellType - returns the type of the cell at `rowId, colId`.  The type is returned through `result`.
              If the cell does not exist, `result` will be set to be a blank cell.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure CellType
  (* rowId, colId : idType;             {location of the cell}
     var result   : cellKind            {cell's packed attributes}
  *);
var pCel      : TPCel;                          {ptr to the cell information}
    hContents : THContents;                     {handle to the cell}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if printState.Preview then result := tPage
   else begin
           pCel   := FindPCel(rowId, colId, false);     {get pointer to the cell}
           result := tBlank;                            {set default result}
           if pCel <> nil then                          {does the cell exist?}
              if pCel^.oh <> 0 then begin               {does the cell have data?}
                 hContents := GetHContents(pCel);       {get handle to the cell data}
                 with hContents^^.vinfo.data do         {set the type of the cell}
                    if TCsize <> sSymbol then result := tNumber
                    else case TCsymbol of
                            syText  : result := tText;
                            syParts : result := tParts;
                            syDate  : result := tDate;
                            otherwise result := tNumber
                         end
              end
        end
end;


(***************************************.*******.********************************************************
   CellValue - depending upon `mode`, reads or writes the character representation of the cell at
               `rowId, colId`.  During an mmWrite, `value` points to the characters which are to stored
               in the matrix with `numBytes` equally the number of characters to save.  Those characters
               are parsed to determine if they form a value of sometype or form only text.  The value is
               then put into the matrix and the cell set inValid.  If the value is a number and was
               entered with a dollar sign ($) in front, an implied dollar format is set for the cell.
               This implied format temporarily overrides any format that might be set for the cell.  The
               actual format for the cell will be restored when the next value is enetered.  If `numBytes`
               equals 0, a blank cell will be saved.  If the cell cannot be written to the matrix,
               `status` will be returned set to OutOfMem or DSpaceErr.

               A mmRead will cause the character representation of the cell to be filled into the area
               pointed to by `value`.  The characters returned will be formmated like the wide angle view
               if `wideFlg` is true.  `numBytes` will be set to the number of characters actually
               returned which could be 0 if the cell is empty.  The character representation will be
               formatted and justified according to the cell attributes.  If the cell is invalid,
               `status` will be set to InvalidCell and `numBytes` equal to 0.  If the cell is blank or
               does not exist, `numBytes` will be set to 0.  If `colId` is mInfSnip then information about
               the row title will be returned, `rowId` equally mInfSnip will return information about the
               column title.

               The wide angle view is formatted differently than the cell view.  The wide angle view
               ignores any format that is set for the cell and uses the default floating decimal format
               with no display overflow (asterisks) if the number is too large.  The wide angle view will
               have a maximum of `maxDecPlaces` (23) digits with numbers overflowing into scientific
               notation.

               `status` will be returned set to ok (0) if everything went alright.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure CellValue
  (* mode         : IOModeType;         {reading/writing mode flag}
     rowId, colId : idType;             {location of the cell}
     value        : ptrData;            {ptr to where the chrs are to go}
     wideFlg      : boolean;            {format for wide angle display? }
     var numBytes,                      {max # of chrs /actual # chrs returned}
         status   : integer             {error status number}
  *);
var cnRec     : cnRecord;                       {cell information record}
    error     : errRecord;                      {parsing error return}
    pCel      : TPCel;                          {ptr to the cell information}
    moneyval  : boolean;                        {set implied money information}
    hContents : THContents;                     {handle to cell data}
    title     : resultStr;                      {titles for rows and columns}
    fDefault  : integer;                        {formatting set for cell}
    numPlaces : integer;                        {number of decimal places in cell format}
    parsedVal : valueType;                      {value returned by parser}
    attr      : TAttr;                          {packed cell attributes}

    (*
        ExtractValue - extracts the character repreentation for the cell.  `pValue` is a pointer to
                       the value information.
    *)
    (*$S matMgrSeg *)
    procedure ExtractValue(pValue : TPValue);
    label 1;
    var format    : integer;                    {format to use on numbers}
        decplaces : integer;                    {number of decimal places to use on numbers}
        maxBytes  : integer;                    {maximum number of bytes to save}
        bytecnt   : integer;                    {number of bytes that will fit in the cell/wide angle view}
        sgn       : integer;
        variant   : variantType;                {packing/unpacking variant}
        result    : resultStr;                  {result from formatting}
        enote     : boolean;                    {scientific notation flag}
        lexeme    : symbol;                     {lexeme to get wording for}
        doWordFrom: boolean;                    {signal to get lexeme name for word information}
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
       TraceMess(13);
(*$ENDC *)

       maxBytes := numBytes;                            {remember the maximum # of characters to fill in}
       if cnRec.cnSize = sSymbol then begin             {unpack non-numeric values}
          doWordFrom := true;
          case cnRec.cnSymbol of
             syTrue  : lexeme := TRUEop;                {save value in result and save later in `value`}
             syFalse : lexeme := FALSEop;
             syNa    : lexeme := NAop;
             syError : begin
                          IsErrorCell := true;
                          lexeme      := ERRORop
                       end;
             syDzero,
             syPinf  : begin
                          IsErrorCell := true;
                          lexeme      := PINFop
                       end;
             syMinf  : begin
                          IsErrorCell := true;
                          lexeme      := MINFop
                       end;
             syText  : begin
                          doWordFrom := false;
                          PBtoB(@pValue^.bytes, value, numBytes);       {save value directly into `value`}
                       end;
             syParts : begin
                          doWordFrom := false;
                          variant.pDatePart := @pvalue^.bytes;
                          partsString(variant.pDatePart^, result)
                       end;
             syDate  : begin
                          doWordFrom := false;
                          variant.pDate := @pvalue^.bytes;
                          dateString(variant.pDate^, result)
                       end;
(*$IFC DEBUGVERSION *)
             otherwise begin
                          doWordFrom := false;
                          writeln('cnHcontents: ',GetOH(ord(cnrec.cnHcontents)), wNAN(cnRec.cnSymbol));
                          FatalMess(9);
                          goto 1
                       end
(*$ENDC *)
          end;
          if doWordFrom then WordFromLexeme(lexeme, 80, @result);
          if cnRec.cnSymbol <> syText then StoB(result, value, numBytes)
       end
       else begin
               GetValue(rowId, colId, false, parsedVal);                {get the numeric value for the cell}
               GetFormat(rowId, colId, decplaces, format);              {get the format for the cell}
               {calculate the number of characters which can fit into the column}
               bytecnt := (SnipWidth(colKind, colId)-TblPars.FieldPad) div CT^.fWidths.w;

               if wideFlg then begin                            {set up wide angle view formatting}
                  if maxDecPlaces > bytecnt then bytecnt := maxDecPlaces;
                  format := 13;
                  if cnRec.cnDollar then format := 14           {preserve implied dollar format}
               end
               else if cnRec.cnDollar then format := 10;        {preserve implied dollar format}

               case ClassX(parsedVal.val.xrealvar, sgn) of
                  sNan,
                  qNan    : WordFromLexeme(ERRORop, 80, @result);
                  otherwise begin                      {make sure value is a number}
                               rstr(parsedVal.val.xrealvar, result, decplaces, format, bytecnt, enote);
                               if wideFlg then                               {check for display overflow}
                                  if result[1] = '*' then                    {reformat in scientific if was in display overflow}
                                     rstr(parsedVal.val.xrealvar, result, 0, 13, bytecnt, enote);
                            end
               end;
               StoB(result, value, numBytes)                    {save result directly into `value`}
            end;

       {if repeating format and the matrix is not closing, nor is formatting beign done for the wide angle view,
        fill the column with the result.
       }
       if cnRec.cnRepeat then
          if (matState <> mmClose) and not wideFlg then begin
             moveLfast(@value^[0], @value^[numBytes], maxBytes - numBytes);
             numBytes := maxBytes
          end;
    1:

(*$IFC DEBUGVERSION *)
       TraceMess(14)
(*$ENDC *)
    end;


    (*$S showForms *)
    procedure ComputePage(snip : snipKind; snipId : idType; var firstSnip, lastSnip, pageCnt : integer);
    var x        : integer;
        continue : boolean;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       firstSnip := -1;
       lastSnip  := 1;
       pageCnt   := 0;
       x         := 1;
       repeat
          if x > idMax then continue := true
          else continue := mmPageBreak(true, snip, x) or mmPageBreak(false, snip, x);
          if continue then begin
             pageCnt := pageCnt + 1;
             if pageCnt <= snipId then begin
                firstSnip := lastSnip;
                lastSnip  := x
             end
          end;
          x := x + 1
       until pageCnt > snipId;
       lastSnip := lastSnip - 1
    end;


    (*$S showForms *)
    procedure GetPrintTitle(snip : snipKind; snipId : idType; base : integer; baseCH : char);
    var firstSnip  : integer;
        lastSnip   : integer;
        pageCnt    : integer;
        firstTitle : resultStr;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       ComputePage(snip, snipId, firstSnip, lastSnip, pageCnt);
       SfromN(firstTitle, firstSnip, base, baseCH);
       SfromN(title, lastSnip, base, baseCH);
       title := concat(firstTitle,'..',title)
    end;


    (*$S showForms *)
    procedure ExtractPrintValue;
    var temp       : integer;
        rPageCnt   : integer;
        pageNumber : resultStr;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       with CT^ do begin
          ComputePage(rowKind, rowId, temp, temp, rPageCnt);

(*$IFC DEBUGVERSION *)
          if debug[1] then writeln('rPageCnt: ',rPageCnt:1,'  hiRow: ',snipBds.hiRow:1);
(*$ENDC *)

          SfromN(pageNumber, CMax(1, snipBds.hiRow * (colId - 1) + rPageCnt - 1), 10, '0');
          StoB(concat(pageText, ' ', pageNumber), value, numBytes)
       end
    end;


(*$S matMgrSeg *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   TraceMess(15);
   if debug[10] and not debug[23] then timestart(7);
(*$ENDC *)

   status := ok;                        {assume all will go well}
   IsErrorCell := false;
   if (rowId <> mInfSnip) and (colId <> mInfSnip) then begin            {check for row/column titles}
      if mode = mmRead then begin                                       {unpacked the value for the cell}
         CellContents(mmRead, rowId, colId, true, cnRec, status);       {get cell contents information}
         if printstate.preview then ExtractPrintValue
         else if cnRec.cnInvalid then begin                             {check for an invalid cell}
                 numBytes := 0;
                 status   := InvalidCell
              end
         else if cnRec.cnHContents = nil then numBytes := 0             {check for cell with no data}
         else begin
                 if not(TblPars.shoFormulas or wideFlg) then begin
                    GetCellAttr(cnRec.cnPCel, attr, rowId, colId);
                    if attr.pkAlign = aInVis then numbytes := -1
                 end;
                 if numBytes < 0 then numBytes := 0
                 else if cnRec.cnHasRule then ExtractValue(@cnRec.cnHContents^^.rule.value)  {extract value}
                 else ExtractValue(@cnRec.cnHContents^^.value)
              end
      end
      else begin
              claimUndoBuffer(true);            {claim any undo information}

              {parse the characters given to determine what type of value was entered}
              if parse(PValue, value, numBytes, -1, -1, error) then begin

                 {determine what type of value was parsed and place it in `parsedVal'.  'moneyval' will be
                  true if the characters formed a number preceded by a dollar sign.  If a text string was
                  parsed, set up value information to be saved in the matrix.
                 }
                 if IsTextstring(parsedVal, moneyval) then begin
                    with parsedVal do begin
                       nan := syText;                           {set value type}
                       val.textinfo.len       := numBytes;      {number of bytes in the text string}
                       val.textinfo.hContents := @value;        {pointer to the characters}
                       val.textinfo.index     := 0              {and index into the text}
                    end
                 end;

                 {save the value into the matrix.  `status` may come back set to OutOfMem or DSpaceErr.}
                 PutValue(rowId, colId, parsedVal, false, status);
                 if status = ok then begin
                    pCel := FindPCel(rowId, colId, false);              {get pointer to the cell}
                    hContents := GetHContents(pCel);                    {get handle to the cell data}
                    if hContent <> nil then begin                       {does the cell have data? always yes???}
                       GetFormat(rowId, colId, numPlaces, fDefault);    {get the format for the cell}
                       if fDefault <> 0 then moneyval := false;
                       pCel^.attributes.moneyBit := moneyval
                    end;
                    SetCellBit(rowId, colId, true, BInvalid)            {set the cell invalid to force it drawn}
                 end
              end
           end
   end
(*$IFC DEBUGVERSION *)
   else if mode <> mmRead then FatalMess(3)
(*$ENDC *)
   else begin                                   {generate the row/column title information}
           case rowId of
              pInfSnip,
              mInfSnip : case colId of
                            mInfSnip,
                            pInfSnip : WordFromLexeme(EDGEop, 40, @title);
                            otherwise  if printState.preview then GetPrintTitle(colKind, colId, 26, 'A')
                                       else SfromN(title, colId, 26, 'A')
                         end;
              otherwise  if printState.preview then GetPrintTitle(rowKind, rowId, 10, '0')
                         else SfromN(title, rowId, 10, '0')
           end;
           StoB(title, value, numBytes)
        end

(*$IFC DEBUGVERSION *)
   ;if debug[10] and not debug[23] then timepeak(7);
   TraceMess(16);
   StatusMess(status)
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   ChangeBlockSize - changes the size of the handle pointed to by `hContents`.  The new size for the
                     handle will be `newSize`.  If `noSizeErr` is false, then handles will not be allowed
                     to be grown larger than THdataSize (32000).  `status` will be set to:

                        OutOfMem  - No memory space for expansion
                        DSpaceErr - No disk space for expansion
                        SizeErr   - requested size is greater than THdataSize (32000)
                        Ok        - everything is fine

****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure ChangeBlockSize
  (* hContents  : THContents;           {handle to be changed}
     newSize    : longint;              {size to change handle to}
     noSizeErr  : boolean;              {allow sizes larger than THdataSize (32000)}
     var status : integer               {error status number}
  *);
var tempZone : THz;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   tempZone := HzfromH(@hContents^);                    {determine the zone the handle came from}

(*$IFC DEBUGVERSION *)
   status := ok;
   timer[10].cnt := timer[10].cnt + 1;
   if debug[10] and not debug[23] then timeStart(8);
   if debug[19] or debugmx or traceMMgr then
      writeln('changeblock: actual/request: ',CbDataOfH(tempZone,@hContents^):1,'/',newSize:1,
              '  oh: ', ord(hContents));
   if debug[26] then begin
      writeln('changeblock(before): zone ok: ',FcheckHzOK(tempZone, status),'  # blocks: ',status:1);
      status := ok
   end;

   if debug[16] then begin
      if debug[19] then writeln('changeblock: ',timer[10].cnt:1);
      if (timer[10].cnt mod 10 = 0) and (CbDataOfH(tempZone, @hContents^) < newSize) then
         status := OutOfMem
   end;
   if status = ok then
(*$ENDC *)

   if noSizeErr or (newSize < THdataSize) then begin                            {can resizing be allowed?}
      ChangeSizeH(tempZone, @hContents^, newSize);                              {change the size of the handle}
      if diskErr then status := DSpaceErr
      else status := OutOfMem;
      if CbDataOfH(tempZone, @hContents^) >= newSize then status := ok          {did the resize occur?}
   end
   else status := SizeErr

(*$IFC DEBUGVERSION *)
   ;if debug[10] and not debug[23] then timePeak(8);
   if debug[26] then
      if status = ok then begin
         writeln('changeblock(after): zone ok: ',FcheckHzOK(tempZone, status),'  # blocks: ',status:1);
         if numHandles <> status then
             writeln(chr(7),'changeblock: numHandles <> numBlocks: ',numHandles:1,'/',status:1);
         status := ok
      end;
   if debug[19] or debugmx or traceMMgr then
      writeln('   NewSize: ',CbDataOfH(tempZone,@hContents^):1,'/',newSize:1,
              '  status: ', status:1,'  oh: ', ord(hContents))
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   claimUndoBuffer - reclaims any information set aside for the undo buffer and the scrap.  The undo
                     buffer should be cleared before any operations are started such that all available
                     memory can be freed to perform the operation.  The undo buffer will consist of only
                     the undo record `mmUndoInfo` when page breaks, column widths and cell formats are
                     being undone.  "claimUndoBuffer" will take the undo information for those operations
                     and incorporate them into the matrix.  The undo buffer consists of the undo record
                     `mmUndoInfo` and additional information in the heap when cut/copy operations are
                     being undone.  `FBufPtr` points to the area in the heap (scrap or undo buffer) which
                     is to be cleared.  In the case of the scrap, `ScrapPtr` and `FBufPtr` may point to
                     the save thing.  `reclaim` is used to determine if cells are to be reclaimed from
                     the area pointed to by `FBufPtr` and undo record mmUndoInfo` reset.  When
                     "claimUndoBuffer" is done, `FBufPtr` will always be set to nil and the undo record
                     `mmUndoInfo` reset if the data was to be reclaimed.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure claimUndoBuffer
  (* reclaim : boolean                  {should info be reclaimed: y/n}
  *);
var row, col : integer;                         {cell coordinates to be reclaimed}
    status   : integer;                         {status of the read through `FBufPtr`}
    width    : integer;                         {row/column width read throguh `FBufPtr`}
    length   : integer;                         {length of data read through `FBufPtr`}
    diff     : boolean;                         {are the scrap and undo information one in the same}
    temp     : bitKind;                         {type of bit to be cleared}
    rg       : range;                           {range of values on the scrap}
    lastIds  : pIdent;                          {boundaries of the range of values}
    oper     : undotype;                        {type of info in scrap}
    pCel     : TPCel;                           {ptr to the cell information}
    Cel      : TCel;                            {holder for cell information}
    dCutCopy : boolean;                         {cut or copy operation in the buffer}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   {incorporate the info for page breaks, cell formats and column widths if those are what is
    in the undo information record.
   }
   with mmUndoInfo do
      if state then begin
         diff := true;
         case op of
            uBreak  : SetVecBreaks;
            uAttr   : SetVecAttr;
            uWidth  : SetVecWidth(info.snip, info.width, rg);
            otherwise diff := false
         end;
         if diff then begin
            mmUndoInfo.state := false;
            mmUndoInfo.op    := uNone
         end
      end;

   if FBufPtr <> nil then begin                 {does `FBufPtr` point to useful information?}
      diff := (ScrapPtr <> FBufPtr);            {does `FBufPtr` not point to the scrap?}
      if reclaim then begin                     {are the cells point to be `FBufPtr` to be reclaimed?}

         (*
         if diff then temp := B2Marked          {reset all the mark bits for cells that are being moved}
         else temp := B1Marked;
         *)
         if doingMove and not diff then SetRgBits(rg, B1Marked, false, 0);

         {remove all of the undo information if appropriate}
         if not(mmUndoInfo.op in [uBreak, uAttr, uWidth]) then begin
            ReadHeader(oper, rg, lastIds, status);      {read header information from the scrap}
            dCutCopy := (oper = uCut) or (oper = uCopy);
            case oper of
               uWipe,           {reclaim data for cells that have been cut, copied, cleared or wiped out}
               uClear,
               uCut,
               uCopy : begin
                          pCel := @Cel;         {point at the holding area for the cell information}
                          for length := 1 to rg.hiCol-rg.loCol+1 + rg.hiRow-rg.loRow+1 do
                             unstuffinteger(width, status);             {skip by the row/column widths info}
                          for row := rg.loRow to lastIds.length do      {loop through data}
                             for col := rg.loCol to lastIds.start do begin
                                FBufStuff(fPCel, @pCel^, length, status);       {get pointer to cell info}

                                {if we are not reclaiming the scrap then we can free up the pointer and
                                 decrement the reference count of the formula if the data was cut or copy
                                 (shouldn't this happen for uClear, uWipe???)
                                }
                                if diff then begin
                                   if dCutCopy then
                                      if Cel.attributes.pkHasRule and not Cel.attributes.pkInCopy then
                                         DecRefCnt(GetHContents(pCel), true, true);
                                   SetCellBit(row, col, false, BInCopy);
                                   FreeContents(pCel)
                                end
                                else if dCutCopy then DecRefCnt(GetHContents(pCel), false, true)
                             end
                       end
            end
         end
      end;
      if diff then FreeBufList          {if scrap was not touched, free up the list of pointer for the undo info}
      else doingMove  := false;         {clear moving flag if scrap was operated on}
      FBufPtr := nil
   end;
   if reclaim then begin                {if the information was reclaimed, clear the undo status}
      mmUndoInfo.state := false;
      mmUndoInfo.op    := uNone
   end
end;


(***************************************.*******.********************************************************
   clearBuffers - the outside worlds way to tell the matrix manager to clear its undo information and
                  also the scrap if `claimScrap` is true.  The outside world should call this routine
                  before any operations are started such that all available memory can be freed to
                  perform the operation.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure clearBuffers
  (* claimScrap : boolean               {should the scrap be claimed?}
  *);
var FBufTemp : THptrData;                       {temp to save FBufPtr state}
    x        : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   if debug[19] then write('clearUndoBuffer: ');
(*$ENDC *)

   claimUndoBuffer(true);               {claim the undo information}
   if claimScrap then begin             {should the scrap be claimed?}
      FBufTemp := FBufPtr;              {save FBufPtr info and scrap use flag}
      FBufPtr  := ScrapPtr;             {switch to point at the scrap informatiom}
      claimUndoBuffer(true);            {claim the scrap information}
      ScrapPtr := nil;                  {clear the scrap pointer}
      FBufPtr  := FBufTemp              {restore the undo pointer}
   end;

(*$IFC DEBUGVERSION *)
   ;if debug[19] then writeln(' MxHz ok: ',FCheckHzOK(mxHz, x),'  # blocks: ',x:1,'/',numHandles:1);
(*$ENDC *)
end;


(***************************************.*******.********************************************************
   CoordInRange - Determines if the coordinate pair `rowId, colId` are within the the range `rg`.
                  Returns true as the value of the function if inclusion exists.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function  CoordInRange
  (* rowId, colId : idType;             {coordinates to be checked}
     rg           : range               {range to be checked against}
  ) : boolean *);                       {coordinates was within the range}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   CoordInRange := (rowId >= rg.loRow) and (rowId <= rg.hiRow) and (colId >= rg.loCol) and (colId <= rg.hiCol)
end;


(***************************************.*******.********************************************************
   dateString - Takes the date information from `date` and produces a text string `result` which is the
                date formatted based on the formatting information in `dataformat.dateformat`.
                `dataformat.dateformat` is a four character string which describes the order which mm,
                dd or yyyy appear in `result` and also what delimiter is placed between the date parts.
                For example: 'dmy-' means that January 19, 1983 will appear as 19-01-1983.  If the
                month or day portions of the date is less than 10 it will be padded with a space or
                a zero depending what is appropriate for the date part's position in `result`.
                The year formatting is truncated to 2 digits if the year is between 1900 and 2000.
****************************************.*******.*******************************************************)
(*$S dateCalc *)
procedure dateString
  (* date       : dateType;             {date to be converted to a string}
     var result : resultStr             {resulting string}
  *);
var delimiter : string[1];
    dayStr    : resultStr;
    monthStr  : resultStr;
    yearStr   : resultStr;
    x         : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   delimiter := '';
   if date.month < 10 then delimiter := '0';
   SfromN(monthStr, date.month, 10, '0');       {convert the month}
   monthStr := concat(delimiter, monthStr);

   delimiter := '';
   if date.day < 10 then delimiter := '0';
   SfromN(dayStr, date.day, 10, '0');           {convert the day}
   dayStr := concat(delimiter, dayStr);

   if date.year div 100 = 19 then date.year := date.year mod 100;
   delimiter := '';
   if date.year < 10 then delimiter := '0';
   SfromN(yearStr, date.year, 10, '0');         {convert the year}
   yearStr := concat(delimiter, yearStr);

   delimiter := ' ';
   delimiter[1] := dataFormat.dateFormat[4];    {get the data part delimiter}
   result    := delimiter;
   for x := 1 to 3 do                       {position the date parts based on `dataformat.dateformat`}
      case dataFormat.dateFormat[x] of
         'm','M' : result := concat(result, monthStr, delimiter);
         'd','D' : result := concat(result, dayStr,   delimiter);
         'y','Y' : result := concat(result, yearStr,  delimiter)
      end;
   result := copy(result, 2, length(result) - 2);       {remove the beginning and eding delimiters}
   if result[1] = '0' then result[1] := ' '             {if first character is a zero, change to a space}
end;


(***************************************.*******.********************************************************
   DecRefCnt - Decrements the reference count for the object pointed to by the handle `hContents`.  The
               decrementing maybe done to a formula(rule) or to a data handle, the flag `inrule` states
               which type is to be decremented.  If `claimData` is true when `inRule` is true, then an
               assumption is made that a call to "DecRefCnt" will be made to reclaim the data handle
               after the "DefRefCnt" is done on the rule.  `claimData` is not looked at when a data
               handle is being reclaimed.  If during decrements, the handles reference count
               goes to zero, the handle will be recycled back to the heap.

   NOTE: the reference counts go up to `fRefCntMax` (127) for formulas and `cRefCntMax` (127) for cells.
         If the reference counts are set to these maxmimums they represents an infinity number of
         references.  Thus, a handle which has a reference count equal to `fRefCntMax` (or `cRefCntMax`)
         will not be decremented and never reclaimed by this routine.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure DecRefCnt
  (* hContents : THContents;            {handle to the object}
     inrule    : boolean;               {is object a rule: y/n}
     claimData : boolean                {will data handle be claimed later: y/n}
  *);
var rule  : THFmla;                             {handle to the formula}
    claim : boolean;                            {reclaim handle flag: y/n}

(*$IFC DEBUGVERSION *)
    (*$S debug2 *)
    procedure dumpinfo(infonum : integer);
    begin
 (*$IFC fTraceLC *) LogCall; (*$ENDC *)

      case infonum of
          1 : begin
                 write('DecRef(',wSHR(rule^^.shared),'): ',hContents^^.rule.ohfmla:1,'/',
                      GetOH(ord(hcontents)):1,' = ');
                 if rule^^.shared <> fSingle then write(rule^^.sdata.info.refcnt:1,'/',hContents^^.vinfo.data.refcnt:1)
                 else write('not decremented: ',hContents^^.vinfo.data.refcnt:1);
                 writeln('  claimed/data: ',claim,' ',claimData)
              end;
          2 : writeln('DecRef(data): ',GetOH(ord(hcontents)):1,' = ',
                      hcontents^^.vinfo.data.refcnt:1);
       end
    end;
(*$ENDC *)


(*$S matMgrSeg *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if hContents <> nil then             {does the cell data exist?}
      if inrule then begin              {is a rule to be decremented?}

         {get handle to the rule data}
         rule := pointer(MakeHND(hContents^^.rule.ohfmla));
         with rule^^ do begin
            {if rule is shared, bump reference count and determine if it is to be reclaimed.  It will be
             reclaimed when the formula refernce count reaches zero and the data reference count goes
             to zero.  If the rule is not shared, then it will be reclaimed only if its data handle is
             not shared.
            }
            with hContents^^.vinfo do
               if shared <> fSingle then begin
                  if sdata.info.refcnt < fRefCntMax then sdata.info.refcnt := sdata.info.refcnt - 1;
                  claim := (sdata.info.refcnt = 0);
                  if claim then
                     if (data.refcnt > 1) or ((data.refcnt = 1) and not claimData) then begin
                        claim := false;
                        sData.info.refcnt := 1
                     end
               end
               else claim := (data.refcnt = 1);

(*$IFC DEBUGVERSION *)
            if debug[12] then dumpinfo(1);
(*$ENDC *)
            if claim then begin
               numHandles := numHandles - 1;                    {adjust the number of handles allocated in `mxhz`}
               FreeH(mxHz, pointer(ord(rule)))                  {reclaim the handle}
            end
         end
      end
      else with hContents^^.vinfo.data do begin
              if refcnt < cRefCntMax then refcnt := refcnt - 1;
(*$IFC DEBUGVERSION *)
              if debug[12] then dumpinfo(2);
(*$ENDC *)
              if refcnt = 0 then begin                  {reclaim the handle if the refcnt goes to zero}
                 numHandles := numHandles - 1;                  {adjust the number of handles allocated in `mxhz`}
                 FreeH(mxHz, pointer(ord(hContents)))           {reclaim the handle}
              end
           end
end;


(***************************************.*******.********************************************************
   DisplayRange - causes the range `rg` to be displayed by the application.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
procedure DisplayRange
  (* rg : range                         {range to be displayed}
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   NewRgImg(rg);                                {tell the table manager to draw the cell}
   if not app.LisaCalc then FxRgChged(rg)       {tell Business Graphics that the table was updated}
end;


(***************************************.*******.********************************************************
   FinalSnip - returns the snipId for the last snip of a particular type.  The type of snip is passed
               through `snip` (for row or column snips).  The function is useful for finding the extent
               the matrix had be expanded because of data being entered.   This function does not give
               the current extent of matrix based on the where values are within the matrix.  To get
               this information one must start at the snipId returned by "FinalSnip" and check for
               non-blank values in that snip.
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function  FinalSnip
  (* snip : snipKind                    {type of information desired: row or column?}
  ) : integer *);                       {last snipId allocated for the given snip}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   FinalSnip := CT^.lastSnip[snip]
end;


(***************************************.*******.********************************************************
   FindPCel - Determines whether the cell at `rowId, colId` is allocated in the matrix and returns a
              pointer to its data if it exists.  If it doesn't exist, then if `canCreate` is true, the
              cell is created and a pointer to it will be returned.  If the cell could not be created
              a nil will be returned.  The routine also returns pointers to cells allocated in the scrap
              if `usingScrap` is true.  In this case, the `canCreate` flag is not used.

   NOTE: The pointer returned by this procedure becomes invalid if the zone, mxHz is compacted!!!
****************************************.*******.*******************************************************)
(*$S matMgrSeg *)
function  FindPCel
  (* rowId, colId : idType;             {location of the cell}
     canCreate    : boolean             {create cell if it does not exist: y/n}
  ) : TPCel *);                         {pointer to the cell information}
label 1;
var hVecCel   : THVecCel;                       {handle to the row vector}
    row, col  : TidRng;                         {column index into row vector}
    rg        : range;                          {range of cells in the scrap}
    status    : integer;                        {status of the read through `FBufPtr`}
    length    : integer;                        {length of data read through `FBufPtr`}

    snipId  : idType;
    int     : integer;
    x       : idtype;
    snip    : snipKind;
    vecId   : array [snipKind] of idType;
    vecInt  : array [snipKind] of ToH;
(*$IFC DEBUGVERSION *)
    myOwnKeys : keySet;
(*$ENDC *)



    (*$S scrapCode *)
    procedure GetScrapPCel;
    var FBufOrig  : THptrData;                  {temps to save flush buffer state}
        lastIds   : pIdent;                     {boundaries of the range of values}
        rowsize   : longint;                    {# cells in the row for the scrap}
        colsize   : longint;                    {# cells in the columns for the scrap}
        rColSize  : longint;                    {real # columns - taking into account absent columns}
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       FBufOrig := FBufPtr;              {save FBufPtr info ptr}
       FBufPtr  := ScrapPtr;             {switch to point at the scrap informatiom}

       {get the coordinate range stored in the scrap and determine if the coordinates passed are
        within the scrap.
       }
       if IdInRange(rowId, colId, rg, lastIds) then begin

          {calculate displacements into the scrap and produce the pointer to the data}
          rowsize  := rg.hiRow - rg.loRow + 1;
          colsize  := rg.hiCol - rg.loCol + 1;
          rcolsize := lastIds.start - rg.loCol + 1;
          status   := ok;

          {if coordinate is outside the range of snipIds with data but within the coordinate range
           stored in the scrap, then return that cell as a blank.
          }
          if (rowId > lastIds.length) or (colId > lastIds.start) then begin
             scrapCel := celBlank;
             status   := ok
          end                    {move to the appropriate position within the data pointed to by `FBufPtr`}
          else if FBufMoveTo(FBufPt + sizeof(integer) * (rowsize + colsize) +
                             sizeof(TCel) * (rcolSize * (rowId-rg.loRow) + colId-rg.loCol), FBufPtr) then
                  FBufStuff(fPCel, @scrapCel, length, status)
          else status := PtrErr;
          if status = ok then FindPCel := @scrapCel
       end;
       FBufPtr := FBufOrig               {restore FBufPtr state}
    end;


(*$S matMgrSeg *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   if debug[29] then begin
      getKeys(myOwnKeys);
      if 116 in myOwnKeys then if rodstuff(-2) then ;
   end;
(*$ENDC *)

   FindPCel := nil;                     {assume the worst}
   if UsingScrap then GetScrapPcel
   else if (rowId >= 1) and (rowId <= idMax) and (colId >= 1) and (colId <= idMax) then begin
           {determine if cell exists in the sparse matrix.  If so, produce the pointer otherwise try and
            allocate the cell and get the pointer from the allocation routine.
           }
           col := vecSnip[colKind, colId];
           row := vecSnip[rowKind, rowId];
           if (row <> absent) and (col <> absent) then begin
              hVecCel  := pointer(MakeHND(row));
              FindPCel := @hVecCel^^[col]
           end
           else if canCreate then begin
                   vecId[rowKind] := rowId;
                   vecId[colKind] := colId;
                   for snip := rowKind to colKind do begin
                      snipId := vecId[snip];
                      int    := vecSnip[snip, snipId];
                      if int = absent then begin
                         status := ok;
                         if snip = rowKind then begin
                            hVecCel := pointer(ord(allocBlock(cStoredCols * sizeof(TCel))));
                            if hVecCel = nil then begin
                               if diskErr then status := DSpaceErr
                               else status := OutOfMem;
                               goto 1
                            end;
                            with CT^ do begin
                               if snipId > lastSnip[rowKind] then lastSnip[rowKind] := snipId;
                               vecSnip[rowKind, snipId] := GetOH(ord(hVecCel));
                               FillConst(@celBlank, sizeof(TCel), @hVecCel^^[0], 1, cStoredCols);
                               PatchFormats(snipId, hVecCel, 1, lastSnip[colKind])
                            end
                         end
                         else with CT^ do begin
                                 cStoredCols := cStoredCols + 1;
                                 for row := 1 to lastSnip[rowKind] do begin
                                    {lengthen each row vector - if OutOfMem shrink those rows that were
                                     lengthen back down
                                    }
                                    if vecSnip[rowKind, row] <> 0 then ReallocRow(row, status);
                                    if status <> ok then begin
                                       if diskErr then status := DSpaceErr
                                       else status := OutOfMem;
                                       cStoredCols := cStoredCols - 1;
                                       for x := 1 to row - 1 do begin
                                          ReallocRow(row, length);
(*$IFC DEBUGVERSION *)
                                          if length <> ok then FatalMess(45)
(*$ENDC *)
                                       end;
                                       goto 1
                                    end
                                 end;

                                 if snipId > lastSnip[colKind] then lastSnip[colKind] := snipId;
                                 AdjDopeVec(snipId, snipId);
                                 for row := 1 to lastSnip[rowKind] do
                                    if vecSnip[rowKind,row] <> 0 then begin
                                       hVecCel := hVecOfRow(row);
                                       BubbleRight(1, @celBlank, sizeof(TCel), @hVecCel^^[0],
                                                   vecSnip[colKind, snipId]+1, cStoredCols);
                                       PatchFormats(row, hVecCel, snipId, snipId)
                                    end
                              end;
                      1: int := vecSnip[snip, snipId]
                      end;
                      vecInt[snip] := int
                   end;
                   if status = ok then begin
                      hVecCel  := pointer(MakeHND(vecInt[rowKind]));
                      FindPCel := @hVecCel^^[vecInt[colKind]]
                   end

                end
        end
end;

