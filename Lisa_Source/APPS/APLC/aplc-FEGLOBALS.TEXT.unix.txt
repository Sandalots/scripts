 unit feGlobals;                         {'Copyright 1983, 1984, Apple Computer Inc.'}
     intrinsic;

interface

uses (*$U UnitStd.obj *)                UnitStd,
     (*$U UnitHz.obj *)                 UnitHz,
     (*$U Storage.obj *)                Storage,
     (*$U QuickDraw.obj *)              QuickDraw,
     (*$U Fontmgr.obj *)                FontMgr,
     (*$U dbenv.obj *)                  dbenv,
     (*$U FEdec.obj *)                  FEdec,
     (*$U fld.obj *)                    fieldedit,
     (*$U teenv.obj *)                  teenv,

     (*$U libos/SysCall.obj *)          Syscall,
     (*$U FPlib.obj *)                  FPlib,
     (*$U PMDecl *)                     PMDecl,
     (*$U PrStdInfo *)                  PrStdInfo,
     (*$U PrPublic.obj *)               PrPublic,
     (*$U aplc/mm/matmgr.obj *)         matmgr,

     (*$U wm.events.obj *)              events,
     (*$U wm.folders.obj *)             folders,
     (*$U wm.menus.obj *)               menus,
     (*$U AlertMgr.obj *)               AlertMgr,

     (*$U WMLstd.obj *)                 WMLstd,
     (*$U WMlsb.obj *)                  WMlsb,
     (*$U WMlgrow.obj *)                WMlgrow,
     (*$U tm.obj *)                     tm,

     (*$U scrap.obj *)                  scrap;

{$setc fDebug := DEBUGVERSION }
{$SetC Extra  := fDebug }

const

{$IFC NOT fDebug }
       PrintEvents = false;
       tracing = false;
       traceCoMgr = false;
       traceFormMgr = false;
       traceLCSMgr = false;
       traceLCExec = false;
       traceDi = false;
       traceLCPR = false;         {+}   { trace printing }
       TraceOC   = false;         {+}   { trace open/close }
       TempCode = false;
{$ELSEC }
      TempCode = true;
{$ENDC }

       {Define all menus}

         LCFilePrint = 2;
            LCCloseAll     = 1;
            LCCloseOne     = 2;
            { .            = 3; }
            LCSavePutBack  = 4;
            LCSaveContinue = 5;
            LCFileRestore  = 6;
            { .            = 7; }
            LCPrAsIs       = 8;
            LCPrSelection  = 9;
            LCPrFormat     = 10;
            LCPrDialog     = 11;
            LCPrProgress   = 12;

         MenuEdits  = 3;
            UndoItem    = 1;
            RestOrig    = 2;
            { .         = 3; }
            Cut         = 4;
            feCopy      = 5;
            PasteM      = 6;
            PasteR      = 7;
            PasteV      = 8;
            { .         = 9; }
            Clr         = 10;
            ClrTem      = 10;
            ClrTxt      = 10;
            { .         = 11; }
            LCInsrtCol  = 12;
            { .         = 13; }
            Selecall    = 14;

         LCTypeStyle = 4;
            FTmodern    = 1;
            FTclassic   = 2;
            { .         = 3; }
            Fnt20       = 4;
            Fnt15       = 5;
            Fnt12       = 6;
            Fnt10       = 7;
            { .         = 8; }

            NPrinterFonts = 7;

            FMFirst     =  9;       { first font-mode item }
            FMPrinter   =  9;   { "show table with Printer Font" }
            FMSmall     = 10;   { "show table with Small Font"   }
            FMMedium    = 11;   { "show table with Medium Font"  }
            FMLarge     = 12;   { "show table with Large Font"   }
            FMLast      = 12;       { last font-mode item  }

            FT20        = 1;
            FT15        = 2;
            FT12        = 3;
            FC12        = 4;
            FT10        = 5;
            FC10        = 6;

         LCPageLayout = 5;
            CWidth      = 1;
            { .         = 2; }
            DoSetBreaks = 3;
            DoClrBreaks = 4;
            {.          = 5; }
            DoPreview   = 6;
            DoNoPreview = 7;
            {.          = 8; }
            DocFPrint   = 9;
            DocStatus   = 10;


         LCFormat     = 6;
            AlStandard  = 1;
            AlLeft      = 2;
            AlCenter    = 3;
            AlRight     = 4;
            AlRepeat    = 5;
            { .         = 6; }
            FMDefault   = 7;
            FmInteger   = 8;
            FmDecimals  = 9;
            FmScientific= 10;
            MoneyDCP    = 11;   {D means show dollar sign;  }
            MoneyCP     = 12;   {C means show commas;       }
            MoneyDP     = 13;   {P means show decimal point.}
            MoneyP      = 14;
            MoneyDC     = 15;
            MoneyC      = 16;
            MoneyD      = 17;
            MoneyPlain  = 18;

         MenuProtect = 7;
            PUnProtect  = 1;
            PProtect    = 2;
            PRulesOnly  = 3;
           { .          = 4; }
            alInvisible = 5;
            alVisible   = 6;

         LCCalculate = 8;
            CalcAuto      = 1;
            CalcMan       = 2;
            CalcNow       = 3;
            { .           = 4; }
            DoShowForms   = 5;
            DoShowVals    = 6;
            { .           = 7; }
            DoCircles     = 8;
            DoFindCircles = 9;
            { .           = 10; }
            DoFindDialog  = 11;
            DoFindSame    = 12;
            { .           = 13; }
            FuncHints     = 14;

         MenuScrap = 9;               {Functions as the Scrap Menu}
            SCloseAll     = 1;
            SCloseOne     = 2;
           {.             = 3; }
            SMonitor      = 4;

         MenuSummary = 10;

         MenuTrace = 11;
            PrtEvnts    = 1;
            ClrTrace    = 2;
            TMmgr       = 3;
            TSmgr       = 4;
            TTmgr       = 5;
            TFmgr       = 6;
            TFexec      = 7;
            TXTmgr      = 8;
            TCoMgr      = 9;
            TFormMgr    = 10;
            TLCSMgr     = 11;
            TLCexec     = 12;
            TDiMgr      = 13;
            TLcPr       = 14;
            TAlert      = 15;
            TOC         = 16;
            TEvents     = 17;
            TFont       = 18;

         MenuAlert  = 12;
            HitGoTo     = 1;
            HitKey      = 2;
            ChgColWid   = 3;
            HitRight    = 4;
            HitDown     = 5;
            HitNewRow   = 6;
            HitNewCol   = 7;
            HitEnter    = 8;
            SelEnter    = 9;
            ClickOutDi  = 10;
            HitUp       = 11;
            HitLeft     = 12;
            FldFldMove  = 13;

         MenuBuzz = 13;
            cantInsert  = 1;
            InsertRow   = 2;
            InsertCol   = 3;
            SameItem    = 4;
            RelItem     = 5;
            NumChrItem  = 6;
            DecPlacItem = 7;
            ValMsg      = 8;
            FormMsg     = 9;
            DBoxMsg     = 10;
            CloseMsg    = 11;
            PageWord    = 12;
            AxMin       = 13;            LCRowInsert  = 13;
            AxOrig      = 14;            LCColInsert  = 14;
            AxMax       = 15;
            AxIncrement = 16;
            XAxMin      = 17;
            XAxOrig     = 18;
            XAxMax      = 19;
            AxStandard  = 20;
            AxMessage   = 21;

         MenuStat = 14;
            PRFormItem  = 1;
            SCellsItem  = 2;
            ValueItem   = 3;
            ValNum      = 4;
            ValText     = 5;
            ValDate     = 6;
            ValDatePart = 7;
            ValBlank    = 8;
            CellItem    = 9;
            SelForm     = 10;
            SelCoord    = 11;
            FormItem    = 12;
            CellsItem   = 13;
            ValPage     = 14;
            GraphWord   = 15;
            TableWord   = 16;
            AsIsWord    = 17;
            PrintWord   = 18;


         MenuRod        = 15;
            Quit          = 1;
            doSwitches    = 2;     {+}

         LCmenuLast     = 15;


         BGFilePrint = 16;
            BGCloseAll     = 1;
            { .            = 2; }
            BGCloseOne     = 3;
            BGSavePutBack  = 4;
            BGSaveContinue = 5;
            BGFileRestore  = 6;
            { .            = 7; }
            BGPrintDoc     = 8;
            BGForPrntr     = 9;
            BGPrintTable   = 10;
            BGPrintGraph   = 11;
            BGPrProgress   = 12;


         BGEdits  = 17;
            BGUndoLast  = 1;
            BGRstrEntry = 2;
            { .         = 3; }
            BGCut       = 4;
            BGCopy      = 5;
            BGPaste     = 6;
            { .         = 7; }
            BGClr       = 8;
            { .         = 9; }
            BGInsrtCol  = 10;
            { .         = 11; }
            SelecTable  = 12;
            SelecGraph  = 13;


         BGTypeStyle = 18;
            BGPlainText = 1;
            BGUnderLine = 2;
            BGBold      = 3;
            BGItalic    = 4;
            BGHollow    = 5;
            BGShadow    = 6;
            { .         = 7; }
            BGmodern    = 8;
            BGclassic   = 9;
            { .         = 10; }
            BG20Pitch   = 11;
            BG15Pitch   = 12;
            BG12Pitch   = 13;
            BG10Pitch   = 14;
            BG12Point   = 15;
            BG14Point   = 16;
            BG18Point   = 17;
            BG24Point   = 18;

         MenuBGPageLayout = 19;
            BGCWidth      = 1;
            { .           = 2; }
            BGFull        = 3;
            BGHalf        = 4;
            BGThird       = 5;
            BGQuarter     = 6;
            { .           = 7; }
            BGActual      = 8;
            BGReduced     = 9;

         BGFormat     = 20;
            BGStndrd    = 1;
            BGLeft      = 2;
            BGCenter    = 3;
            BGRight     = 4;
            { .         = 5; }
            BGDefault   = 6;
            BGDecimals  = 7;
            BGInteger   = 8;
            BGScientific = 9;
            BGDCP        = 10;   {D means show dollar sign;  }
            BGCP         = 11;   {C means show commas;       }
            BGDP         = 12;   {P means show decimal point.}
            BGP          = 13;
            BGDC         = 14;
            BGC          = 15;
            BGD          = 16;
            BGPlainMoney = 17;

         MenuBGType = 21;
            BGBar          = 1;
            BGLine         = 2;
            BGScatter      = 3;
            BGPie          = 4;
            BGStackBar     = 5;
            BGSolidBar     = 6;
            BGAreaGraph    = 7;
            BGExtraGraph   = 8;

         MenuBGOptions = 22;
            BGGridOn        = 1;
            BGGridOff       = 2;
            { .             = 3; }
            BGLegOn         = 4;
            BGLegOff        = 5;
            { .             = 6; }
            BGYAxSpec       = 7;
            BGXAxSpec       = 8;
            { .             = 9; }
            BGShowBar       = 10;
            BGShowLine      = 11;
            { .             = 12; }
            BGRgrsOn        = 13;
            BGRgrsOff       = 14;
            { .             = 15; }
            BGMarkOn        = 16;
            BGMarkOff       = 17;

         MenuBGLCTypestyle = 23;

         MenuLast  = 23;

       {Define the LC/BG-specific buttons}
       BtnGoAway   = 2;
       BtnDoIt     = 3;
       BtnPrevious = 4;
       BtnNext     = 5;
       firstBtn    = 2;
       lastBtn     = 5;

       {Define keyboard keys}
       chEnter     = 3;
       chApple     = ccApple;
       chBack      = 8;
       chLarrow    = 8;
       chDarrow    = 10;
       chUarrow    = 11;
       chRArrow    = 12;
       chReturn    = 13;
       chCtlS      = 19;
       chEscape    = 27;
       chLeft      = 28;
       chRight     = 29;
       chUp        = 30;
       chDown      = 31;

       {Now, other constants...}
       MaxMoves = 10;                  {dimension of movespecs array}
                                       {movespecs[10] contains a ctrl - z forever}

       { Panels 0 to 5 are declared in TEEnv }
       ccoPnl      = 6;
       cformPnl    = 7;
       cBGPnl      = 8;
       ctCoPnl     = 9;
       ctWidePnl   = 10;
       ctFormPnl   = 11;
       cStCoPnl    = 12;
       cScoPnl     = 13;
       cStblPnl    = 14;

       numPnls = 14;

       mmLDSN      = 4;
       printLDSN   = 3;
       CopyDocLdsn = 2;
       lcLDSN      = 1;

       LargeFont   = p10Tile;
       SmallFont   = p15Tile;

type
                                        {Data Structures for enter moves}

        HoldKey = (nokey,shftKey,CmdKey,SpecKey);

        KeyPair = Record

                    Key:char;
                    keyHeld : holdkey;
                  end;


        MoveDir = (MvRight, MvLeft, MvUp, MvDown, MvNewRow, MvNewCol, MvStay, NoMove);

        scrapKind = (cellsKind, txtKind, noKind, unKnownKind, graphKind);

        undoOpKind = (uCutTxt, uCopyTxt, uKey, uPasteTxt, uCutRg, uCopyRg, uPasteRg,
                      uInsrt, uAttrChg, uEnter, uNothing, uClrTem, uUndo,
                      uClrTxt, uGoTo, uPasteRel, uPasteVal, uColWid, uBreaks,
                      uRestore, uFldFldMove, uFontChg, uCircle, uPrintOpt,
                      uGtype, uBGpreview, uGraphProportion, uLegends, uGrid, uBGcut,
                      uBGcopy, uBGkey, uBGpaste, uBGclr, uBGAxis, uBGTypeStyle, uBGhybrid,
                      uBGCopyGraph, uBGRgrsn, uBGMark);

        TFMode  =   FMPrinter..FMLarge  ;
          { the four table-font modes}


        FexecVar = record    {Collection of all the folder exec variables that must be
                           saved/loaded on close/open}

               { sw note:  many of these turn out not to play a role in save/restore, but
                           remain here (and in every lisaCalc file ever stored on disk) for
                           historical reasons }

                      padding    : string[16];          {string currently drawn in the tWidePnl}
                      attributes : attrRecord;          {Last setting of attributes}
                      formatItem : integer;             {item index last selected in
                                                           the format menu}
                      ModernFont : boolean;             {True iff modern font}
                      autoCalc   : boolean;             {True iff in auto-calc mode}
                      LCFlag     : boolean;
                      BGFlag     : boolean;
                      ActivePnl  : PnlIndex;            {panel with the selection in it}
                      lastActPnl : pnlIndex;            {The previous ActivePnl}
                      pnlWithChg : pnlIndex;            {Last panel that we edited in
                                                         and actually changed}
                      pnlToEnter : pnlIndex;            {The pnlWithChg at the time that
                                                         the dialog box goes up for format}
                      curRange   : Range;               {Contains the current range}
                      curNbrhood : rect;                {the current neighborhood}
                      MenuIndex  : integer;             {Menu selected}
                      ItemIndex  : integer;             {Menu item selected}

                      curTimeout : INTEGER;             {current timeout}
                      reEntrdCell: boolean;             {True iff: the last time the mouse went down,
                                                          it re-entered the one-cell current range.}
                      curPrFont  : integer;             {ItemIndex (from font menu)}
                                                        {of current printer font}
                      TabFontMode: TFMode               {current 'mode' of table-font choice}
                  end;


var Folder              : grafptr;                      {LisaCalc/BG Folder's port}
    g                   : FexecVar;
    WMEvent             : EventRec;                     {The last event record from the Window Mgr}
    MoveAct             : moveDir;

    QuitRequest         : boolean;                      {True when quit menu item selected}
    downIgnored         : boolean;                      {The last mouse down was ignored}


    myMenus             : array [2..MenuLast] of MenuInfo;     {Array of menus}
    MoveSpecs           : array [0..Maxmoves] of        {enter move keys and the directions}
                             Record                     {they imply}
                                keys      : keypair;
                                direction : movedir;
                             end;

{$IFC fDebug}
    PrintEvents         : boolean;             {Tracing Flags }
    tracing             : boolean;
    traceCoMgr          : boolean;
    traceFormMgr        : boolean;
    traceLCSMgr         : boolean;
    traceLCExec         : boolean;
    traceDi             : boolean;
    traceLCPR           : boolean;    {+}
    traceOC             : boolean;    {+}
    NMIAllowed          : boolean;

    Switches            : array[1..10] of boolean ;   {+}
    UnsusOld            : boolean;                      { needed for backward compatibility to support unSuspend of old files }
{$ENDC }

    undoRec             : record
                             undoOp  : undoOpKind;
                             undoPnl : pnlIndex;
                          end;

     tblCharWid         : integer;                      {The width of a character in the table (from the
                                                         center of one char to the center of another)}


     CalcPending        : boolean;
     docDirty           : boolean;

     LrgFInfo           : FontInfo;                     { Larger of sysfont or the current table font}
     tblFInfo           : FontInfo;                     { Font Metrics about the current table font }
     sysFInfo           : FontInfo;                     { Font Metrics about the system font        }
     Tblfntid           : TLfntid;                      { Font Mgr long font ID for the Table font  }
     sysfntid           : TLfntid;                      { Font Mgr long font ID for the system font }


        { Panels 0 to 4 are declared in TEEnv. They get initted during the
          InitPnls call. These Panel VARS are initted in aplc/LCFexec/InitFexec
          just prior to the call to InitPnls.
        }
     coPnl              : PnlIndex;
     formPnl            : PnlIndex;
     BGPnl              : PnlIndex;
     tCoPnl             : PnlIndex;
     tWidePnl           : PnlIndex;
     tFormPnl           : PnlIndex;
     StCoPnl            : PnlIndex;
     ScoPnl             : PnlIndex;
     StblPnl            : PnlIndex;

     pnlLineDv          : integer;                      {Height of a 1-line formula panel, value panel, etc.}
     coBase             : integer;                      {Vertical baseline relative to the coPnl for text}
     formBase           : integer;                      {Vertical baseline relative to the formPnl for text}

     LCsbList           : TSbList;                      { Scroll bar list as defined in WMLSb }
     ScrapSBList        : TSbList;                      { Scrap scroll bar list               }
     LChsbV             : THsb;                         { Handle to the vertical scroll bar   }
     LCHsbH             : THsb;                         { Handle to the horizontal scroll bar }
     LCHsbGray          : THsb;                         { dummy gray area scroll box          }

     HsbVScrap          : THsb;
     HsbHScrap          : THsb;                         { Scrap scroll bars }

     BGhsbV             : THsb;                         { Handle to the BG vertical scroll bar}
     BGHsbH             : THsb;                         { Handle to the BG horizontal scroll bar }

     PrevPrFontIndex    : integer ;                     { index of previous printer font choice, for undo }
     PrevTblFontMode    : TFMode  ;                     { previous table-font mode, for undo }
     PrevFontMenuItem   : integer ;                     { most recent item selected from typestyle menu }

     coDh               : integer;                      {width of coPnl}

     NumdocsOpen        : integer;
     DiagSBlist         : TSbList;
     hsbVDiag           : THsb;
     hsbHDiag           : THsb;

     c                  : record
                             clkRect        : rect;     {Neighborhood set by last mouse down.}
                             Check2or3Click : boolean;  {True when looking for a dbl or trpl clck}
                             FndDouble      : boolean;  {True when we have Found a Double click}
                             FndTriple      : boolean;  {True when we have found a Triple click}
                             mouseHasMoved  : boolean;  {True when mouse has moved after mse down}
                             lastMsePnl     : pnlIndex; {Last panel the mouse went down in}
                             lastUpTime     : longInt;  {time when mouse last went up}
                             preDownTime    : integer;  {curTimeout just before the last mouse down}
                          end;


{***************************************     LCpr variables     *************************************}
     printRange         : range;
{***************************************     LCpr routines     *************************************}
procedure lcprFmt      ;  { called in response to 'intended for printer...' }
procedure lcprinit     ;  { one-time initialization}
procedure lcPrint(selOnly : boolean; thePRmode : PrMenuSuppress);  { print the worksheet or juct the selection}
procedure LCReDoBreaks ;  { recompute page breaks }

procedure resolveFont;   { arbitrate between Print Mgr and the TypeStyle menu }

function  FamFromIndex ( index:  integer )  :  TFam    ;     { converts an index into the TypeStyle menu
                                                                into the corresponding font family }
       { NB:  at one time, famFromIndex had to be in the Interface; currently it is not called from
              outside lcpr, but it is at least for the moment being left in the interface }

function FinalDataSnip ( aKind: SnipKind ) : idtype   ;     { determines the final snip of the given
                                                               kind which has actual data (as opposed
                                                               to having only Rules) ; at present,
                                                               called by LCUT as well as used here in LCPR }


{***********************************    Feglobals routines    ***********************************}

procedure ClrScrapFld;

procedure cWidened(undoable : boolean);

function  doCautionAlert(alertNum : integer) : boolean;

procedure doDTalert(DTM : longint; var whenString : TParamAlert);

procedure doPnlDrawAlert(alertNum : integer; pnl : pnlIndex);

procedure doGetAlert(alertNum : integer; MessPtr : TPStr255);

procedure doInitMP
   (myHeap         : Thz;
    toolPreFix     : str40;
    ptrToAlertProc : procPtr;
    phraseversion  : integer;
    var error      : integer
   );

procedure doNoteALert(alertNum : integer);

procedure doParamAlert(maxNum : integer);

procedure doReadALert(alertRefNum, alertVerNum : integer);

procedure doStopALert(alertNum : integer);

procedure doWaitALert(alertNum : integer);

procedure doWouldALert(alertNum : integer);

procedure DrwScrScrollBars(state : boolean);

procedure FailedAlert;

procedure getKeyPair(var Keys : keyPair);

procedure GetScrKind(var sKind: scrapKind);

procedure GetWordInfo(MessPtr: TPStr255);

Procedure PackField (
    HFld              : hndField;    { Handle to field to pack }
    HFS               : hndFState;   { handle to corresponding field state }
    HBuffer           : hnddata;     { handle to buffer onto which to pack data }
    var bufLen        : integer;     { Length of buffer (may be changed by this proc) }
    var lenInstalled  : integer      { number of bytes hung on HBuffer^^            }
  ) ;

procedure putSysStr (h,v: integer; strng: str80);

procedure setUndo(op: undoOpKind; pnl : pnlIndex);

procedure shoScrapFld;

Procedure UnpackField (
    HFld      :  HndField   ; { the field whose contents need restoring       }
    HFS       :  HndFState  ; { the field state whose contents need restoring }
    HBuffer   :  HndData      { the buffer from whence unpacking takes place  }
 ) ;

(*$IFC fDebug *)
procedure FatalError(module:str40; proc:str40; msg:str40);

procedure LCtraceMess
  (messNum : integer
  );
procedure printMess(itemNum : integer);
(*$ENDC *)

{********************************************************}

implementation

(*$R- *)

(*$IFC teSym *)
(*$D+ *)
(*$ELSEC *)
(*$D- *)
(*$ENDC *)



(*$ifc not fDebug *)
CONST
  TraceBreaks = false;
(*$endc *)

{$S fexec }


TYPE
        axis = VHSelect { = (v, h) };

VAR
   allAlerts          :         TAlertFile; {Pointer to the Alert Record for LC/BG}

   ttyCRect           :         rect;      { print rect of current cell}

   nHedLns            :         array[axis] of integer; { room for header info }
   sKindOfAxis:    array[axis] of snipKind; {lexicon}
   axisOfSKind:    array[snipKind] of axis; {lexicon}

   curPxy:         array[axis] of integer; {last position set by setTTY}

   fstTbl:         array[snipKind] of idType; {initial    tbl snip to print}
   limTbl:         array[snipKind] of idType; {beyond last   "   "    " }
   fstPg:          array[snipKind] of idType; {initial    snip on curr page}

   CurRow:         idType;                    {current Row being processed}
   CurCol:         idType;                    {current Col being processed}

   pgChLeadMargin:     array[axis] of integer; {printer leading margins (in characters) (left,top)}
   pgChTrailMargin:    array[axis] of integer; {printer trailing margins (in characters) (right,bottom)}

   scrChD:         array[axis] of integer; {Screen Character width or ht }
   ttyChD:         array[axis] of integer; {Printer  "         "   "     }
   ttyPgD:         array[axis] of integer; {Printer  Page      "   "     }
   pgChLim:        array[axis] of integer; {initial char of right margin}
   cellChars:      array[axis] of integer; {num of chars in current cell}
   cellD:          array[axis] of integer; {pixel extent of   "      "  }

   chWall:         array[axis] of integer; {num of blanks between cells}
   wallD:          array[axis] of integer; {pixel distance   "      "  }

   ttyChPos:       array[axis] of integer; {printer postion in units of
                        characters, page relative; initial is 0}

   PageNumber:     integer; {current page number}

   pseudoLeading : integer ; { computed leading for the printer font }
   checkErrors   : boolean;


{$IFC fDebug }
   TraceBreaks:    boolean;  { special trace flag for detailed breaks tracing }
{$ENDC }


procedure NewPrFont(itemIndex: integer) ;       external; {in aplc/LCMenus - UNIT TEEXEC}
procedure ChgTblFont ( newFontFam: tFam )  ;    external; {in aplc/LCMenus - UNIT TEEXEC}
procedure LCBGReconfig;                         external; {in aplc/LCFexec - UNIT LCfexec} {so we can get to BGReconfig }
procedure updFolder(forceUpdate : boolean);     external; {in aplc/LCExecSubs - UNIT LCfexec}
procedure chkScrapSize;                         external; {in aplc/LCExecSubs - UNIT LCfexec}

(*$IFC fDebug *)
function wRect(aRect : rect) : char; external;
(*$ENDC *)


procedure printCell;                                             forward;
procedure printHed;                                              forward;
procedure printPage;                                             forward;
procedure printRow;                                              forward;
procedure printWS;                                               forward;

procedure setTTY;                                                forward;
function  snipChars (aSnip: idType; u: axis): integer;           forward;
function  succSnip (aKind: snipKind; aSnip: idType): idType;     forward;


(***************************************.*******.************************************
   ClrScrapFld - clears the image in the scrap folder and draws appropriate scroll
                 bars.  The current grafport is temporarily changed to be the
                 ScrapFolder
****************************************.*******.***********************************)
(*$S fexec *)
procedure ClrScrapFld;
var oldPort : GrafPtr;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   ChkScrapSize;
   GetPort(oldPort);
   SetPort(ScrapFolder);
   with ScrapFolder^ do begin
      ClipRect(portrect);
      EraseRect(portRect)
   end;

   { Draw/Erase the scroll bars and grow box }
   DrwScrScrollBars(ScrapFolder = ActiveFolder);
   SetPort(oldPort)
end;


{$S fexec}
procedure cWidened(* undoable : boolean *);
        {Set the undo info and refigure the breaks for column widened.
        This procedure is provided so that matMgr can inform the folder
        exec when a grid handle has been dragged.}
     begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
        if tracing then LCtraceMess(4);
{$ENDC }
        if undoable then begin
           setUndo(uColWid, tblPnl);
           doWouldAlert(ChgColWid)
        end;
        lcReDoBreaks;
     end;


(*$S AlertProcs *)
function doCautionAlert{alertNum : integer) : boolean};
var temp : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   temp := CautionAlert(allalerts, alertNum);
   doCautionAlert := temp;
   if alertNum <> 156 then updFolder(true)
end;


(*$S OpenClose *)
procedure doDTalert{DTM : longint; var whenString : TParamAlert};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   DTalert(allAlerts, DTM, whenString)
end;


(*$S specialCase *)
procedure doPnlDrawAlert{alertNum : integer; pnl : pnlIndex};
var marginRect : rect;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   SetPnlPort(pnl);
   GetPnlRect(pnl, marginRect);
   with marginRect do begin
      right  := right - dhsBox + 1;
      bottom := bottom - dvsBox + 1
   end;
   ClipRect(marginRect);
   eraseRect(marginRect);
   TextFont(sysText);
   TextFace([]);

   if marginrect.right - marginRect.left < sysFinfo.widMax * 10 then
      marginRect.right := marginRect.left + sysFinfo.widMax * 10;
   insetRect(marginRect, charWidth(' '), charWidth(' '));
   DrawAlert(allalerts, alertNum, marginRect)
end;


(*$S initial *)
procedure doGetAlert{alertNum : integer; MessPtr: TPStr255};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetAlert(allalerts, alertNum, MessPtr)
end;


(*$S initial *)
procedure doInitMp
  (* myHeap         : Thz;
     toolPreFix     : str40;
     ptrToAlertProc : procPtr;
     phraseversion  : integer;
     var error      : integer
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   InitMP(myHeap, toolPreFix, ptrToAlertProc, phraseversion, @myMenus, allAlerts, error)
end;


(*$S AlertProcs *)
procedure doNoteAlert{alertNum : integer};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   NoteAlert(allalerts, alertNum);
   if (alertNum <> 132) and (alertNum <> 145) and (alertNum <> 117) and ((alertNum < 20000) or (alertNum > 20016)) then
      updFolder(true)
end;


(*$S AlertProcs *)
procedure doParamAlert{maxNum : integer};
var myStr   : resultStr;
    XmaxNum : extended;
    error   : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   I2X(maxNum, XmaxNum);
   rstr(XmaxNum, myStr, 0, 0, 3, error);
   ParamAlert(myStr, '', '')
end;


(*$S initial *)
procedure doReadAlert{alertRefNum, alertVerNum : integer};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   allAlerts := ReadAlerts(alertRefNum, alertVerNum)
end;


(*$S AlertProcs *)
procedure doStopAlert{alertNum : integer};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   StopAlert(allalerts, alertNum);
   if (alertNum < 20000) or (alertNum > 20016) then updFolder(true)
end;


(*$S AlertProcs *)
procedure doWaitAlert{alertNum : integer};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   WaitAlert(allalerts, alertNum);
   updFolder(true)
end;


(*$S fexec *)
procedure doWouldAlert{alertNum : integer};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   WouldAlert(myMenus[MenuAlert], alertNum)
end;


(***************************************.*******.************************************
   DrwScrScrollBars - depending upon STATE the scroll bars for the scrap will be
                      cleared or filled in.

   NOTE: the current grafport should be set to the SCRAPFOLDER before this routine
         is called.  Also hsbHScrap & hsbVScrap should be initialized.
****************************************.*******.***********************************)
(*$S fexec *)
procedure DrwScrScrollBars{state : boolean};
var rH : TR;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   ChkScrapSize;
   if state and (WMEvent.what <> FolderDeactivate) then begin
      PaintSBar(hsbHScrap);
      PaintSBar(hsbVScrap);
      PaintGrow
   end
   else HideSBorder(ScrapFolder^.portrect)
end;


(***************************************.*******.************************************
    FailedAlert - To tell the user that the Alert Manager has failed.
****************************************.*******.***********************************)
(*$S specialCase *)
procedure FailedAlert;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   doStopAlert(2);
end;


{$IFC fDebug}
{$S LCdebug}
procedure FatalError{module:str40; proc:str40; msg:str40};
        {Implementation error detected.  write out error msg then quit.}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   ParamAlert(module, proc, msg);
   StopAlert(allAlerts, 129); {Fatal Error}
   if (module <> 'MatMgr') or (proc <> 'Status Message') then begin
      hidecursor;
      halt
   end;
end;
{$ENDC }



{$S fexec}
Procedure getKeyPair{var Keys : keyPair};
        {Store the key pair of the last key typed into keys.}
        {NEEDED FOR TEexec}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(5);
{$ENDC }
  With WMEvent, keys do begin
      key := ascii;
      if ShiftKey then keyHeld := shftKey
      else if appleKey then keyheld := cmdkey
      else if codeKey Then keyHeld := specKey
      else KeyHeld := nokey;
   end
end;


(***************************************.*******.************************************
   getScrKind - Return the scrapkind for the current scrap.
*)
(*$S fexec *)
procedure getScrKind{var sKind: scrapKind};
var scrapKind : scrapType;
    dataPtr   : TH;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(6);
{$ENDC }
   GetScrap(scrapKind, dataPtr);
   case scrapKind of
      ScrapFE    : sKind := txtKind;
      ScrapMtx   : sKind := cellsKind;
      ScrapNil   : sKind := noKind;
      ScrapUG,
      ScrapDwg,
      ScrapBgraf : sKind := graphKind;
      otherwise    sKind := unKnownKind
   end;
{$IFC fDebug}
   if tracing or debug[1] then begin
      write('GetScrapKind',(scrapProcess = my_id),':  ptr: ',ord(dataPtr),'  ');
      case scrapKind of
         ScrapFE    : writeln('txtKind');
         ScrapMtx   : writeln('cellsKind');
         ScrapNil   : writeln('noKind');
         ScrapDwg   : writeln('drawing');
         ScrapUG    : writeln('universal graph');
         ScrapBgraf : writeln('graphKind');
         otherwise    writeln('unKnownKind')
      end
   end
{$ENDC }
end;


(*$S initial *)
procedure GetWordInfo{MessPtr: TPStr255};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetAlert(allalerts, 11, MessPtr)
end;


{$S OpenClose}             { 17Aug82--20:20 }
Procedure PackField (*
    HFld              : hndField;    { Handle to field to pack }
    HFS               : hndFState;   { handle to corresponding field state }
    HBuffer           : hnddata;     { handle to buffer onto which to pack data }
    var bufLen        : integer;     { Length of buffer (may be changed by this proc) }
    var lenInstalled  : integer      { number of bytes hung on HBuffer^^            }
  *) ;

  { Takes the field/fieldstate represented by HFld and HFS and packs away their guts in HBuffer^^;
      On entry, all three handles must be allocated, and bufLen must correctly reflect the
      size of HBuffer^^;  the buffer may be expanded by this procedure, and on return, bufLen will
      reflect the corrected size.  LenInstalled is set to the number of bytes hung on HBuffer

     NOTE:  data packed by this routine should be unpacked by the companion procedure UnPackField

     The format of the data packed is:
        <1>  the Field itself (handles inside it NOT valid on reload)
        <2>  the Field state  (handles inside it NOT valid on reload)
        <3>  the array of runs
        <4>  the curValue array   ( an even number of bytes packed...)     }

   VAR
       pd            :   ptrdata;
       runSize,                         { bytes consumed by the runs }
         ValSize ,                      { space consumed by the curValue array-- always an even number }
         FldSize ,                      { space consumed by a field--rounded up to even number }
         FSSize      :                  { space consumed by a field-state--rounded up to even  }
                         integer ;

   function makeEven( aNumber: integer ) :  integer;
      begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

         makeEven := aNumber+ord(odd(aNumber))
      end;

   BEGIN
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$ifc fDebug}
      if traceOC then writeln('PackField--on entry, bufLen is ',bufLen:3);
{$endc }
      FldSize := MakeEven(sizeOf(field));
      FSSize  := makeEven(sizeOf(fieldState));

      runSize := makeEven(HFld^^.maxFmts * sizeOf(run));
      valSize := makeEven(HFld^^.maxLen);

      LenInstalled :=    FldSize                             { the field itself }
                       + FSSize                              { the field state vector }
                       + runSize                             { the runs }
                       + ValSize  ;                          { the current value }

      if bufLen < lenInstalled then  { insufficient space allocated to the handle HBuffer }
         begin
            { make more space }
            ChangeSizeH ( hzFromH ( POINTER(ORD(HBuffer)) ) , POINTER(ORD(HBuffer)), LenInstalled )  ;
            bufLen := lenInstalled
         end ;
{$ifc fDebug }
      if traceOC then writeln(' new bufLen: ',bufLen:4,' new lenInstalled: ',lenInstalled:4);
{$endc }

      { write out the field }
      moveLeft ( Hfld^^ , HBuffer^^ , fldSize ) ;
      pd := pointer(ord(HBuffer^) +  fldSize ) ;    { now points just past field data }

      { write out the field state }
      moveLeft ( HFS^^  ,  pd^ ,  fsSize ) ;
      pd := pointer(ord(pd) + fsSize ) ;     { now points just past fieldState data }

      { write out run array }
      moveleft ( HFld^^.fmtinfo^^, pd^, runSize );
      pd := POINTER(ORD(pd) + runSize );             { now points to area just past where runs are stashed }

      { write out value array }
      moveleft( HFld^^.curvalue^^, pd^, valSize )

   end;


(***************************************.*******.************************************
   putSysStr - Put the string (strng) at location h,v, relative to the port that is
               currently set.  Use the system font.  If the string happens to have
               a '|' vertical bar in it, this is substituted with the apple
               (from whatever font).  Assume the port and clipping have been set up.
****************************************.*******.***********************************)
{$S fexec}
procedure putSysStr {h,v: integer; strng: str80};
var x : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(7);
{$ENDC }
   TextFont(systext);  { systext is exported by the Font Mgr }
   TextFace([]);
   MoveTo(h,v);
   repeat
      x := pos('|', strng);
      if x <> 0 then begin
         DrawString(copy(strng, 1, x-1));
         Move(0, -12);
         TextFont(WMfont);
         DrawChar(chr(chApple));
         Move(0, +12);
         TextFont(sysText);
         strng := copy(strng, x+1, length(strng) - x);
      end
      else DrawString(strng);
   until (x = 0) or (length(strng) = 0)
end;


(***************************************.*******.************************************
   setUndo - Set the info in the undoRec to op, the new operation that UNDO would
             apply to, and pnl, the panel that UNDO would apply to}
****************************************.*******.***********************************)
{$S fexec}
procedure setUndo{op: undoOpKind; pnl: pnlIndex};
{$IFC fDebug}
var status : integer;
begin
   if tracing then LCtraceMess(9);
   if debug[26] then writeln('theHeap ok: ',FCheckHzOK(theHeap, status),'  # blocks: ',status:1);
{$ELSEC }
begin
{$ENDC }
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with undoRec do begin
      undoOp := op;
      undoPnl := pnl;
   end;
   case op of
      uNothing,
      uFldFldMove,
      uGoto,
      uKey,
      uCopyRg,
      uCopyTxt,
      uUndo : ;
      otherwise docDirty := true
   end
end;


(***************************************.*******.************************************
   shoScrapFld - draws the image of the field in the scrap along with the
                 appropriate scroll bars.

   NOTE: before this routine is called, it should have been determined that the
         scrap has a field in it.
****************************************.*******.***********************************)
(*$S fexec *)
procedure shoScrapFld;
var errNum : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(10);
{$ENDC }
   ClrScrapFld;
   DrawScrap(errNum);
   DrwScrScrollBars(ScrapFolder = ActiveFolder)
end;


{$S OpenClose}
Procedure UnpackField (*
    HFld:        HndField;    { the field whose contents need restoring       }
    HFS       :  HndFS   ;    { the field state whose contents need restoring }
    HBuffer   :  HndData      { the buffer from whence unpacking takes place  }
*) ;

{ Takes field data which has been packaged by PackField onto HBuffer, and restores
  the field and field-state to HFld & HFS (which must already be valid)

  The expectation is that the MaxLen and MaxFmts properties of the packaged data
  are the same as those of the field to be stored into, but in case they are not,
  the heap allocations for the curValue and/or the Runs arrays are adjusted such
  that they match the specifications of the packaged data }

VAR
   BufFldPtr     :  ptrField  ;     { pointer to the field area of the packed data }
   BufFSPtr      :  ptrFState ;     {    "           field-state          "        }
   BufRunPtr     :  ptrRuns   ;     {    "              runs              "        }
   BufValPtr     :  ptrdata   ;     {    "          curValue array        "        }

   TempValHndl   :  HndData   ;
   TempFmtHndl   :  HndRuns   ;

   xlen          :  integer   ;     { new length for a handle that may need to be expanded }
   RunBytes      :  integer   ;     { number of bytes occupied in saved version by array of runs }
   valBytes      :  integer   ;     { number of bytes occupied in saved version by curval array }

   function makeEven( aNumber: integer ) :  integer;
      begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

         makeEven := aNumber+Ord(odd(aNumber))
      end;


BEGIN
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$ifc fDebug }
   if traceOC then writeln('unPackField');
{$endc }

   BufFldPtr := Pointer( ORD(HBuffer^) );


   xlen := makeEven( BufFldPtr^.maxfmts * sizeOF(run) );    { space required to hold array of runs }

   IF BufFldPtr^.maxfmts <> HFld^^.maxfmts then             { if not maxFmts doesn't match, }
         changesizeH(hzfromH(POINTER(ORD(HFld^^.fmtinfo))), { force to packed size          }
                             POINTER(ORD(HFld^^.fmtinfo)),
                             xlen);

   BufFldPtr  :=  Pointer(ORD(HBuffer^));
   xlen       :=  makeEven(BufFldPtr^.maxlen);

   IF xlen <> HFld^^.maxlen then         { if maxLens don't match, insist on the packed version}
       changesizeH(hzfromH(POINTER(ORD(HFld^^.curvalue))),
                             POINTER(ORD(HFld^^.curvalue)),
                             xlen);

   {save handles in field data structures;}
   BufFldPtr  :=  Pointer(ORD(HBuffer^));    { protect against ill effects of compaction }
   TempValHndl := HFld^^.curValue ;
   TempFmtHndl := HFld^^.fmtinfo  ;

   HFld^^ :=   BufFldPtr^ ;                               { restore the field       }

   BufFSPtr := pointer(ord(bufFldPtr) + makeEven(sizeOf(field)))  ;
   HFS^^  :=    BufFSPtr^ ;                               { restore the field state }

   with HFld^^ do
     begin
        curvalue := TempValHndl ;                  { reinstate correct handle to curValue array }
        fmtinfo :=  TempFmtHndl                    { reinstate correct handle to runs           }
     end;

   runBytes := makeEven(bufFldPtr^.maxFmts*(sizeOf(run))) ;
   bufRunPtr   := POINTER( ord(HBuffer^) +  makeEven(sizeOF(field)) + makeEven(sizeOf ( fieldState ) ) );
   moveleft( bufRunPtr^ , HFld^^.fmtinfo^^ , runBytes );           { restore array of runs }

   BufFldPtr  :=  Pointer(ORD(HBuffer^));
   bufValPtr  :=  POINTER(ORD(bufRunPtr)  + runBytes );
   valBytes   :=  makeEven ( bufFldPtr^.maxLen ) ;
   moveleft( bufValPtr^ , HFld^^.curvalue^^ , valBytes )  { restore array of contents }
end ;


(*$IFC fDebug *)
(*$S LCdebug *)
procedure LCtraceMess
  (* messNum : integer
  *);

  procedure doMess1;
  begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

     case messNum of
        1  : writeln('comgr  pnlSetPortClip');
        2  : writeln('feGlobals  cntClkDn');
        3  : writeln('feGlobals  cntClkUp');
        4  : writeln('feGlobals  cWidened');
        5  : writeln('feGlobals  getKeyPair');
        6  : writeln('feGlobals  getScrKind');
        7  : writeln('feGlobals  putSysStr');
        8  : writeln('LCfexec  LCCkGrow ');
        9  : writeln('feGlobals  setundo');
        10 : writeln('feGlobals  shoScrapFld');
        12 : writeln('CoMgr  emptyCoDisp');
        13 : writeln('CoMgr  findCoFld');
        14 : writeln('CoMgr  getCoRg');
        15 : writeln('CoMgr  initCo');
        16 : writeln('CoMgr  putCellCo');
        17 : writeln('CoMgr  putCoChars');
        18 : writeln('CoMgr  putSnipCo');
        19 : writeln('CoMgr  putSnipCo');
        20 : writeln('CoMgr  shoNewCo');
        21 : writeln('formMgr  enterForm');
        22 : writeln('formMgr  emptyFormDisp');
        23 : writeln('formMgr  findFormFld');
        24 : writeln('formMgr  initForm');
        25 : writeln('formMgr  reDrawForm');
        26 : writeln('formMgr  shoNewForm');
        27 : writeln('diMgr  buttonWasPushed');
        28 : writeln('diMgr  addDiBox');
        29 : writeln('diMgr  clrLbl');
        30 : writeln('diMgr  drawLbl');
        31 : writeln('diMgr  findDiPart');
        32 : writeln('diMgr  findNxtDiFld');
        33 : writeln('diMgr  initDi');
        35 : writeln('diMgr  PutChkRow');
        36 : writeln('diMgr  PutButton');
        37 : writeln('diMgr  putDiFld');
        38 : writeln('diMgr  putDiLbl');
        39 : writeln('diMgr  putGraphics');
        40 : writeln('diMgr  reDrawChks');
        41 : writeln('diMgr  reDrawDi');
        42 : writeln('diMgr  rmvDiBox');
        43 : writeln('diMgr  setDiPnl');
        44 : writeln('diMgr  setDiSize');
        45 : writeln('diMgr  shoButton  do show it');
        46 : writeln('diMgr  shoButton  do hide it');
        47 : writeln('LCSMgr  doPnlAct  Activate');
        48 : writeln('LCSMgr  doPnlAct  DE-Activate');
        49 : writeln('LCSMgr  doPnlSel');
        otherwise writeln('Unknown Message #',messnum:1)
     end
  end;


  procedure doMess2;
  begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

     case messNum of
        50 : writeln('LCSMgr  drawPnlFld');
        51 : writeln('LCSMgr  endOtherSel');
        52 : writeln('LCSMgr  endPnlSel');
        53 : writeln('LCSMgr  findPnlFld');
        54 : writeln('LCSMgr  jumpAField');
        55 : writeln('LCSMgr  nullSelIn');
        56 : writeln('LCSMgr  nullSelIn');
        57 : writeln('LCSMgr  newNbhPnl');
        58 : writeln('LCSMgr  peekAtNewSel');
        59 : writeln('LCSMgr  pnlEdit');
        62 : writeln('LCSMgr  pnlKey');
        63 : writeln('LCSMgr  pnlMseUp');
        64 : writeln('LCSMgr  pnlSelAll');
        65 : writeln('LCSMgr  pnlSelFld');
        66 : writeln('LCSMgr  pnlTimOut');
        67 : writeln('LCSMgr  pnlUndo');
        68 : writeln('LCSMgr  pnlWSel');
        69 : writeln('LCSMgr  restoreLCS');
        70 : writeln('LCSMgr  saveLCS');
        71 : writeln('LCSMgr  shoPnlErr');
        72 : writeln('LCMenus  chgPnlSel');
        73 : writeln('specEnter  appEnter');
        74 : writeln('LCMenus  undoCR');
        75 : writeln('LCMenus  unNewSnips');
        76 : writeln('LCMenus  unTxtEdit');
        77 : writeln('LCfexec  LCCkGrow');
        78 : writeln('LCfexec  fxDataStuff');
        79 : writeln('LCfexec  NewInitFexec');
        80 : writeln('LCfexec  startSelect');
        81 : writeln('LCfexec  MenuCommand');
        82 : writeln('LCfexec  doTimeEvent');
        83 : writeln('LCfexec  doKeyEvent');
        84 : writeln('LCfexec  newActPnl');
        85 : writeln('LCfexec  doDeActEvent');
        86 : writeln('LCfexec  mainloop');
        88 : writeln('LCfexec  ProcessEvent');
        89 : writeln('LCfexec  doActEvent');
        90 : writeln('LCfexec  doDownEvent');
        91 : writeln('LCfexec  doMenuAct');
        92 : writeln('LCfexec  doUpEvent');
        93 : writeln('LCfexec  groSelect');
        94 : writeln( 'appDiBox  checkHit');
        95 : writeln( 'appDiBox  cleanUpRep');
        96 : writeln( 'appDiBox  disMissDi');
        97 : writeln( 'appDiBox  doAxisBox');
        99 : writeln( 'appDiBox  doCWidPrecBox');
        otherwise writeln(chr(7),'Unknown Message #',messnum:1)
     end
  end;


  procedure doMess3;
  begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

     case messNum of
        100 : writeln('LCmenus  chgMenuBG');
        101 : writeln('LCmenus  chgMenuLC');
        104 : writeln('LCmenus  chgTypeStyle');
        105 : writeln('LCMenus  setTblFont');
        106 : writeln('LCMenus  ChgTblFont');
        107 : writeln('LCMenus  NewPrFont');
        108 : writeln('LCMenus  NewTblFontMode');
        110 : writeln('LCmenus  deskTop');
        111 : writeln('LCmenus  doTblMenu');
        112 : writeln('LCmenus  doUndo');
        115 : writeln('LCmenus  flipTrace');
        116 : writeln('LCmenus  hiConfMenu');
        117 : writeln('LCmenus  newAlignProt');
        118 : writeln('LCmenus  newFont');
        119 : writeln('LCmenus  newFormat');
        121 : writeln('LCmenus  offTrace');
        122 : writeln('LCfexec  putUpMenus');
        124 : writeln('LCmenus  setNewFormat');
        141 : writeln('TEexec  doKeyedMove');
        142 : writeln('LCmenus  enterCalc');
        144 : writeln('TEexec  enterReSelect');
        146 : writeln('TEexec  forceCalc');
        147 : writeln('TEexec  initMSpecs');
        148 : writeln('TEexec  moveAction');
        149 : writeln('TEexec  tblEditPnl');
        otherwise writeln(chr(7),'Unknown Message #',messnum:1)
     end
  end;


  procedure doMess4;
  begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

     case messNum of
        150 : writeln('TEexec  tblMseDn');
        151 : writeln('TEexec  tblMseMvd');
        152 : writeln('TEexec  TEclrRg');
        153 : writeln('TEexec  TEclrTxt');
        154 : writeln('TEexec  TEcopy');
        155 : writeln('TEexec  TEcut');
        156 : writeln('TEexec  TEedits');
        157 : writeln('TEexec  TEkey');
        158 : writeln('TEexec  TEmseUp');
        159 : writeln('TEexec  TEpaste');
        160 : writeln('TEexec  TEreInit');
        161 : writeln('TEexec  TERestore');
        163 : writeln('TEexec  wideMseDn');
        165 : writeln('LCfexec  appKey');
        167 : writeln('LCfexec  chgStatPnl');
        168 : writeln('LCfexec  dividPnls');
        170 : writeln('LCfexec  doGoTo');
        172 : writeln('LCfexec  drawTWide');
        173 : writeln('LCfexec  editTried');
        175 : writeln('LCfexec  endLastSel');
        177 : writeln('LCfexec  fxNewRgImg');
        178 : writeln('LCfexec  fxRgChged');
        179 : writeln('LCfexec  goToRg');
        180 : writeln('LCfexec  ignoreEv');
        181 : writeln('LCfexec  initAppMgrs');
        183 : writeln('LCfexec  MapTitlePt');
        184 : writeln('LCfexec  MseDnApp');
        186 : writeln('LCfexec  selecCoord');
        187 : writeln('LCfexec  selecForm');
        188 : writeln('LCfexec  setAppPnls');
        189 : writeln('LCfexec  setApp2Pnls');
        195 : writeln('LCfexec  shoNewRx');
        196 : writeln('LCfexec  sizeScrap');
        197 : writeln('LCfexec  updateCursor');
        198 : writeln('TEexec  wideMseMvd');
        199 : writeln( 'appDiBox  doRepBox');
        otherwise writeln(chr(7),'Unknown Message #',messnum:1)
     end
  end;


  procedure doMess5;
  begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

     case messNum of
        200 : writeln( 'appDiBox  endCWidPrecBox');
        202 : writeln( 'appDiBox  endAxisBox');
        203 : writeln( 'appDiBox  endRepBox');
        204 : writeln( 'appDiBox  initDiFlds');
        205 : writeln( 'appDiBox  nextHit');
        206 : writeln( 'appDiBox  prevHit');
        207 : writeln( 'appDiBox  prntLblFld');
        208 : writeln( 'appDiBox  putAxisBox');
        209 : writeln( 'appDiBox  putCWidPrecBox');
        210 : writeln( 'appDiBox  putNewRep');
        212 : writeln( 'appDiBox  putRepBox');
        213 : writeln( 'appDiBox  RepGrafix');
        214 : writeln( 'LCfexec   updFolder');

        221 : writeln  ( 'coMgr  coMgStuff' );
        222 : writeln  ( 'LCSMgr  LcSmStuff' );
        224 : writeln  ( 'AppDiBox  removeDiBox' );
        225 : writeln  ( 'LCMenus3  fontCommand' );

        231 : writeln  ( 'lcpr  lcprInit') ;
        232 : writeln  ( 'lcpr  resolveFont');
        236 : writeln  ( 'lcpr  lcprFmt');
        238 : writeln  ( 'lcpr  lcPrint');
        239 : writeln  ( 'lcpr  lcreDoBreaks');
        240 : writeln  ( 'lcpr  PrintHed');
        241 : writeln  ( 'lcpr  printPage');
        242 : writeln  ( 'lcpr  PrintWS');
        otherwise writeln(chr(7),'Unknown Message #',messnum:1)
     end
  end;


begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if messNum in [1..49] then doMess1
   else if messNum in [50..99] then doMess2
   else if messNum in [100..149] then doMess3
   else if messNum in [150..199] then doMess4
   else if messNum in [200..249] then doMess5;
end;



(*$S debug2 *)
procedure printMess{itemNum : integer};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   case itemNum of
      1 : writeln('After processing event, new g.curTimeout is ', g.curTimeout);
      2 : writeln('After handling timeout, new g.curTimeout is ', g.curTimeout);
      7,
      3 : with WMEvent do begin
             write('Who: ');
             if who = folder            then writeln('Folder')
             else if who = ScrapFolder  then writeln('Scrap')
             else if who = DialogFolder then writeln('Dialog Box')
             else if who = FilerFolder  then writeln('Filer')
             else if who = menuFolder   then writeln('Menu Bar')
             else if who = AlertFolder  then writeln('Alert Box')
             else writeln('You got me ... ?', ord(who));
             write('what: ',ord(what):3,'');
             case what of
                abortEvent       : writeln('abortEvent');
                diedEvent        : writeln('diedEvent');
                nilEvent         : writeln('nilEvent');
                folderUpdate     : writeln('folderUpdate');
                folderDeactivate : writeln('folder Deactivate');
                folderActivate   : writeln('folder Activate');
                FolderMoved      : writeln('folder Moved');
                keyDown          : writeln('keyDown');
                ButtonDown       : writeln('ButtonDown');
                ButtonUp         : writeln('ButtonUp');
                filerEvent       : writeln('filerEvent');
                otherwise          writeln('unknown')
             end;
             writeln('Where: ', where.h:4, '/', where.v:4);
             writeln('When: ', when);
             writeln('g.ActivePnl before event processed is ', ord(g.ActivePnl));
             if itemNum = 7 then begin
                ParamAlert('Warning', 'ProcessEvent', 'Unknown event');
                doStopAlert(129)
             end
          end;
      4 : writeln('Event received for AlertFolder');
      5 : writeln('FolderMoved event');
      6 : writeln('Non event..');
      8 : writeln('** DEACTIVATE EVENT **');
      9 : writeln('** ACTIVATE EVENT **');
      10: Writeln('LCFexec/doDeactevent has scrapfolder DeActivate');
      11: writeln('Mouse down in null pnl');
      12: writeln('** SHIFT-CLICK **');
      13: writeln('** MOUSE DOWN **');
      14: writeln('g.ActivePnl: ', g.ActivePnl);
      15: writeln('**KEY EVENT**', WMEvent.ascii);
      16: writeln('**MENU EVENT** ', g.MenuIndex, ':', g.ItemIndex);
      17: writeln('**TIMEOUT EVENT** -- ', g.curTimeout);
      18: writeln('** MOUSE UP EVENT **');
      19: writeln('This menu not implemented yet.');
      20: FatalError('LCSMgr', 'pnlWSel', 'Select word for Button???');
      21: FatalError('LCfexec', 'initFexec', 'InitPnls bad');
      22: FatalError('diMgr', 'findDiPart', 'No fields in dialog box');
      23: FatalError('LCSMgr', 'pnlUndo', 'Can''t undo this');
      24: FatalError('diMgr', 'FindNxtDiFld', 'plainTxt selection but no fields');
      25: FatalError('LCfexec', 'editTried', 'No room for runs');
      26: FatalError('diMgr', 'FindNxtDiFld', 'Can''t find the current field');
      27: FatalError('Teexec', 'TeCopy', 'bad status in PutScrap');
      28: FatalError('Teexec', 'TEcut', 'bad status in PutScrap');
      31: FatalError('Teexec', 'TEPaste', 'bad status in PutScrap');
      32: begin
             ParamAlert('Warning', 'upDfolder', 'error drawing universal graphics scrap');
             doStopAlert(129)
          end;
      37: FatalError('LCfexec', 'setTblFont', 'FMFontMetrics doesn''t like our tblFntId');
      38: FatalError('LCfexec', 'setTblFont', 'FMFontMetrics doesn''t like our sysFntId');
      40: begin
             ParamAlert('Warning', 'upDfolder', 'asked to draw an unknown scrap');
             doStopAlert(129)
          end;
      otherwise writeln('Unknown Message #',itemnum:1)
   end
end;

(*$ENDC *)

(*$I aplc/lcpr.text *)

(*$S initial *)
END.

