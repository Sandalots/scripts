
unit TEexec;                            {'Copyright 1983, 1984, Apple Computer Inc.'}
     intrinsic;

               {procedures called by fexec to run the Table Editor}

interface

uses (*$U UnitStd.obj *)                UnitStd,
     (*$U UnitHz.obj *)                 UnitHz,
     (*$U Storage.obj *)                Storage,
     (*$U QuickDraw.obj *)              QuickDraw,
     (*$U Fontmgr.obj *)                FontMgr,
     (*$U dbenv.obj *)                  dbenv,
     (*$U FEdec.obj *)                  FEdec,
     (*$U fld.obj *)                    fieldedit,
     (*$U teenv.obj *)                  teenv,

     (*$U libos/SysCall.obj *)          Syscall,
     (*$U FPlib.obj *)                  FPlib,
     (*$U PMDecl *)                     PMDecl,
     (*$U PrStdInfo *)                  PrStdInfo,
     (*$U PrPublic.obj *)               PrPublic,
     (*$U aplc/mm/matmgr.obj *)         matmgr,

     (*$U wm.events.obj *)              events,
     (*$U wm.folders.obj *)             folders,
     (*$U wm.menus.obj *)               menus,
     (*$U AlertMgr.obj *)               AlertMgr,

     (*$U WMLstd.obj *)                 WMLstd,
     (*$U WMlsb.obj *)                  WMlsb,
     (*$U WMLgrow.obj *)                WMLgrow,
     (*$U tm.obj *)                     tm,

     (*$U aplc/feglobals.obj *)         feglobals,
     (*$U aplc/comgr.obj *)             coMgr,
     (*$U scrap.obj *)                  scrap,
     (*$U aplc/mm/bgenv.obj *)          bgenv;

{**************************************   LCmenus   ***************************************}

procedure chgMenuLC;

procedure chgMenuBG;

procedure ChgMenuScrap;

procedure ChgTblFont ( NewFontFam: TFam );

procedure doUndo;

procedure FontCommand ( undoing: boolean; var newCR:  boolean);

procedure newAlignProt(field : attrType);

procedure newFormat;

procedure putUpMenus;

procedure setNewformat(numPlaces: integer);

procedure setTblFont(NewFontFam: TFam);

(*$IFC fDEbug *)
procedure flipTrace;

procedure offTrace;

procedure RodDrawProc(menu : menuInfo; menuRect : rect);

procedure rodFlags;

procedure TraceDrawProc(menu : menuInfo; menuRect : rect);
(*$ENDC *)


{*******************************************   TEexec   ********************************}

procedure doKeyedMove (dir: moveDir; var status: integer);

procedure DrwCellScrap;

procedure enterCalc(firstEnter: boolean; reSelCR: boolean;
                    calcOnEnterOnly: boolean; delayCalc: boolean;
                    var status: integer);

procedure enterReSelect(var status: integer);

procedure forceCalc(reSelCR: boolean);

function  forceEnter(var status : integer) : integer;

procedure initMSpecs;

procedure insertSnip (numSnips : integer; var newCR: boolean);

function  moveAction (ch: char): moveDir;

procedure ReturnRgFB(var timeout : integer);

procedure selectRg(newRg: range; hilite: cellseltype);

procedure SelInLeftCorner;

function  tblEditPnl (aPnl: pnlIndex): boolean;

procedure tblMseDn (mouseRel: point; var newCR: boolean);

procedure tblMseMvd (mouseRel: point; var newCR: boolean);

procedure TEedits (var status: integer; var txtChg: boolean; var newCR: boolean);

procedure TEkey (ch: char; var wasMove: boolean; var status: integer);

procedure TEmseUp (mouseRel: point; var newCR: boolean);

procedure TEreInit (freshStart: boolean);

procedure TERestore;

procedure wideMseDn(mouseRel: point);

procedure wideMseMvd(mouseRel: point);


implementation

var moveAlertCnt : integer;
    menuXXX      : integer;

(*$R- *)

(*$IFC teSym *)
(*$D+ *)
(*$ELSEC *)
(*$D- *)
(*$ENDC *)

(******************************************  external references ************************************)

procedure BGDrawScrolls; external;                                      {in aplc/LCscroll - UNIT LCFEXEC }
procedure chgStatPnl(keepFormula: boolean); external;                   {in aplc/LCexecsubs - UNIT LCFEXEC }
procedure chkScrapSize; external;                                       {in aplc/LCexecsubs - UNIT LCFEXEC }
procedure dividPnls; external;                                          {in aplc/LCexecsubs - UNIT LCFEXEC }
procedure doGoTo (newRange: range); external;                           {in aplc/LCexecsubs - UNIT LCFEXEC }
procedure fxNewRgImg; external;                                         {in aplc/LCexecsubs - UNIT LCFEXEC }
procedure FxRgChged(rg : range); external;                              {in aplc/LCexecsubs - UNIT LCFEXEC }
procedure lcBGSetGrfx; external;                                        {in aplc/LCfiler - UNIT LCFEXEC }
procedure LCBGReconfig; external;                                       {in aplc/LCfiler - UNIT LCFEXEC }
procedure LCDrawScrolls; external;                                      {in aplc/LCscroll - UNIT LCFEXEC }
procedure setApp2Pnls; external;                                        {in aplc/LCexecsubs - UNIT LCFEXEC }
procedure shoNewRx(oldRg: range; newRg: range; just: rgJust); external; {in aplc/LCexecsubs - UNIT LCFEXEC }
procedure updFolder(forceUpdate : boolean); external;                   {in aplc/LCexecsubs - UNIT LCFEXEC }

(*$IFC fDebug *)
function wRg(rg : range) : char; external;
(*$ENDC *)


(****************************************** forward references ************************************)
procedure chgTypeStyle; forward;
procedure chgBGTypeStyle; forward;
procedure formEnter(var status: integer; var timeout: integer; var wasEnter: boolean); forward;

procedure TEpaste(theSelKind : selKind; pasteKind: srcType; var status: integer; var txtChg: boolean;
                  var newCR: boolean); forward;
procedure unNewSnips (rgOp: undoOpKind); forward;
procedure unTxtEdit (txtOp: undoOpKind); forward;


(*$S fexec2 *)
procedure doKeyedMove {dir: moveDir; var status: integer};
        {Move the selection and current range to the cell indicated by dir.
        Assume last cell (if any) has been entered successfully and range
        feedback has been removed.  Give an exception  and return non-zero
        status if g.curRange is not a1CellRg. If move attempted, set status to 0
        and g.ActivePnl to tblPnl.}
                {Not called directly by BG's Fexec}
var oldRange : range;
    newRange : range;
    direc    : mcType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
  if tracing then LCtraceMess(141);
{$ENDC }
   if g.curRange.rKind = a1CellRg then begin
      oldRange := g.curRange;
      case dir of
         MvRight  : direc    := mmRight;
         MvLeft   : direc    := mmLeft;
         MvDown   : direc    := mmDown;
         MvUp     : direc    := mmUp;
         MvNewRow : direc    := mmBegOfRow;
         MvNewCol : direc    := mmBegOfCol;
         MvStay   : newRange := oldRange
      end;
      if dir <> MvStay then NextCell(direc, oldRange, newRange);
      selectRg(newRange, SelectCell);
      status := ok
   end
   else begin
           selectRg(g.curRange, SelectCell);
           doStopAlert(113);          {Move ignored because single cell not selected}
           status   := 1
        end
end;


{$S scrapCode}
procedure DrwCellScrap;
        {A range has just been cut or copied successfully.  Draw the scrap.
        The current range is the selection in the folder after the scrap draw}
var scrapRect : rect;
    spareRect : rect;
    scrapRg   : range;
    theStr    : str40;
    ModeData  : ModeInfo;
    errNum    : integer;
    tField    : hndField;
    tState    : hndFstate;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   ChkScrapSize;
   if NumDocsOpen <= 0 then errNum := -1
   else if scrapAbsent then begin                       {scrap is not present, must read in}
           ReadMMscrap(errNum);
           {since scrap was not around, "DrwCellScrap" must be for an update event.  Reset the update
            visible region such that the entire scrap will be drawn not just the part uncovered.  This
            is necessary to insure that any message that may be in the scrap is removed.
           }
           if errNum = 0 then EndUpDate(ScrapFolder)
        end
   else errNum := 0;

   if errNum = 0 then begin
      {Draw the dividing lines and the gray to the right of the Cells display}
      SetPnlPort(cScrapPnl);
      if ActiveFolder <> ScrapFolder then WMOpenPicture(ScrapFolder);
      GetPnlRect(cScrapPnl, scrapRect);
      with scrapRect do begin
         right  := right - dhsBox + 1;
         bottom := bottom - dvsBox + 1
      end;
      ClipRect(scrapRect);

      EraseRect(scrapRect);
      PenNormal;
      MoveTo(0, pnlLineDv);
      LineTo(scrapRect.right, pnlLineDv);
      MoveTo(coDh, pnlLineDv);
      LineTo(coDh, 0);
      SetRect(spareRect, coDh + 1, 0, scrapRect.right, pnlLineDv);
      FillRect(spareRect, ltGray);

      {Show the "Cells:" Display}
      SetPnlPort(StCoPnl);
      GetItem(myMenus[MenuStat], SCellsItem, @theStr);
      putSysStr(4, coBase, theStr);

      {Show the Table part of the scrap}
      tblPnl := StblPnl;
      SwitchTable(true, tblPars);
      tmShoNewTbl;
      tblPnl := cTblPnl;

      {Put in the Coordinates themselves}
      RgInScrap(scrapRg);
      GetModeInfo(ModeData);
      SetRunFormat(ScoFldH, nil, ModeData.Tfid.Fam, setFont, errNum);

      {swap the regular panel and field information with that of the scrap.  This is necessary,
       because the normal routines to draw the coordinates display will be used to draw the
       scrap's coordinate display.  However, the state information for the regular coordinate display
       must be preserved.  Once the scrap's coordinate display is drawn, the panel and field information
       will be swapped back.
      }
      coPnl  := ScoPnl;
      tField := coFldH;
      tState := coFSH;
      coFldH := ScoFldH;
      coFSH  := ScoFSH;
      shoNewCo(scrapRg);
      coPnl  := cCoPnl;
      coFldH := tField;
      coFSH  := tState;

      {Reset clipping for the scrap to the whole scrap}
      SetPnlPort(cScrapPnl);
      DrwScrScrollBars(ScrapFolder = ActiveFolder);
      if ActiveFolder <> ScrapFolder then begin
         SetPnlPort(cScrapPnl);
         WMClosePicture;
         InvalRect(ScrapFolder^.portRect)
      end;
      SwitchTable(false, tblPars);
      if ActiveFolder = Folder then ReturnRgFB(g.curTimeout)
   end
   else begin
           EndUpDate(ScrapFolder);
           if errNum = -1 then errNum := 154
           else if errNum = DSpaceErr then errNum := 186
           else errNum := 126;
           doPnlDrawAlert(errNum, cScrapPnl);
           SetPnlPort(cScrapPnl);
           DrwScrScrollBars(ScrapFolder = ActiveFolder)
        end
end;


{$S fexec2}
procedure enterCalc{firstEnter: boolean; reSelCR: boolean;
                    calcOnEnterOnly: boolean; delayCalc: boolean;
                    var status: integer};
        {If firstEnter is true, then do an enter and give the appropriate
         error response.  If the enter went well or there wasn't an enter
         and if reSelCR is true, then re-select the current range.  If
         calcOnEnterOnly is true, then trigger a calculation iff something was
         entered; otherwise trigger a calculation in any case.  BUT, if
         delayCalc is TRUE, set flags so that ReCalc does not result in
         a recalculation of the matrix, nor in a redrawing of the BG graph.
         Give an alert response if something went wrong on the enter.  Return the
         status of the enter, not of the recalculation.  Note also that this routine
         is called by other routines within TEexec that are called directly by BG's
         fexec.
        }
var calcStat   : integer;
    eRow, eCol : integer;
    wasEnter   : boolean;
    OldCF      : boolean;
    OldIF      : boolean;   { temporaries for CalcFlag and ImageFlag }
    alertUp    : boolean;
    doEnter    : boolean;
    hadFormula : boolean;
    rFormChged : boolean;
    wInfo      : windowInfo;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if traceLCexec then LCtraceMess(142);
{$ENDC }
   wasEnter := false;
   status   := 0;
   eRow     := -1;
   eCol     := -1;
   if firstEnter then begin
      if doingMove and (g.pnlWithChg in [ctblPnl, cwidepnl, cformPnl]) then begin
         doEnter := doCautionAlert(110);
         if doEnter then begin
            moveAlertCnt := moveAlertCnt + 1;
            if odd(moveAlertCnt) then
               if doCautionAlert(159) then ClrFormErrors
         end
      end
      else doEnter := true;
      if doEnter then begin
         {If g.curRange is not a1CellRg or a header, just end the current range; otherwise
          do an enter.  Return a non-zero status if there's an error on entering (like an
          edit check error).  Give all error diagnostics before returning.  If there is no
          error, end the current range.  Returns wasEnter = true iff there was something to enter.
         }
         if g.curRange.rKind = a1CellRg then begin
            {If all goes well, set status to zero and g.pnlWithChg to nullPnl before
             returning; otherwise, set status to a non-zero value.
            }
            wasEnter   := false;
            status     := 0;
            eRow       := g.curRange.loRow;
            eCol       := g.curRange.loCol;
            hadFormula := CellHasRule(eRow, eCol);
            case g.pnlWithChg of
               ctblPnl,
               cwidePnl : begin
                             ClrUndo;
                             EnterSelection(status);
                             if status = 0 then setUndo(uEnter, tblPnl);
                             wasEnter := true;
                          end;
               cformPnl : begin
                             formEnter(status, g.curTimeout, wasEnter);
                             if wasEnter then FormulaChanged := true
                          end
              {otherwise  do nothing}
            end;
            rFormChged := formulaChanged;
            case status of
               DSpaceErr,
               OutOfMem : begin
                             case g.pnlWithChg of
                                cTblPnl,
                                cWidePnl : SelAllTxt(g.curTimeout);
                                cFormPnl : PnlSelAll(FormPnl, g.curTimeout)
                             end;
                             if status = DSpaceErr then dostopAlert(187)
                             else doStopAlert(121)
                          end;
               ok       : begin
                             g.pnlWithChg := nullPnl;
                             g.curTimeout := dfltTimeout
                          end;
            end
         end
         else wasEnter := false;
         if status = 0 then begin
            nullCR;
            if g.curRange.rKind = a1CellRg then begin
               DumpSel;
               NewRgImg(g.curRange)
            end;
            if wasEnter then formulaChanged := formulaChanged or hadFormula
         end
         else g.ActivePnl := g.pnlWithChg
      end
      else begin
              doNoteAlert(152);
              setUndo(uEnter, tblPnl);
              g.pnlWithChg := nullPnl
           end
   end;

   if (not calcOnEnterOnly) or ((status = 0) and wasEnter) then begin
      alertUp := false;
      if DelayCalc then begin
         OldCF := ReCalcFlag;
         OldIF := ImageFlag;
         SetReCalc(mmCalcMan);
         SetImage(false)
      end
      else if reCalcFlag and (calcTime > 1500) then begin
              GetWindInfo(alertFolder, wInfo);
              if not wInfo.visible then begin
                 alertUp := true;
                 doWaitAlert(131)
              end
           end;

      Recalc(eRow, eCol, calcStat, true);

      if DelayCalc then begin
         if oldCf then SetReCalc(mmCalcAuto)
         else SetReCalc(mmCalcMan);
         SetImage(OldIF);
         CalcPending := true   { set global flag showing that calc pends...}
      end
      else CalcPending := false;

      if alertUp and (calcStat = 0) then begin
         EndWaitAlert;
         updFolder(true)
      end;

      case calcStat of
        DSpaceErr,
        OutOfMem    : doStopAlert(10007 + ord(calcStat = DSpaceErr));      {Not enough memory to finish}
        ReCalcErr   : doNoteAlert(10000 + ord(circularFlag));   {Calculation error}
        userStopped : doNoteAlert(10005 + ord(circularFlag))    {calculation stopped}
      end
   end;
   if wasEnter and rFormChged then
      case circleState of
         cCircular,
         cDependent : SetCircleMode(circleState)
      end;

   if (status = 0) and reSelCR then selectRg(g.curRange, selectCell)
end;


{$S fexec2}
procedure enterReSelect{var status: integer};
        {Enter the current range and then reselect it.}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(144);
{$ENDC }
   if g.curRange.rKind = a1CellRg then enterCalc(true, true, true, false, status)
   else status := 0
end;


{$S fexec2}
procedure forceCalc {reSelCR: boolean};
        {Force a calculation and give alert box response to a calc error.
         Don't do an enter.  Reselect the current range iff reSelCR = true.}
var status: integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(146);
{$ENDC }
   enterCalc(false, reSelCR, false, false, status)
end;



{$S fexec}
function forceEnter {var status : integer) : integer};
        {Force an enter and calculation if the enter succeeds}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   enterCalc(true, false, true, false, status);
   forceEnter := status
end;



{$S LCfexec}
procedure formEnter(* var status: integer; var timeout: integer; var wasEnter: boolean *);
        {The g.pnlWithChg is in the formula panel and an enter has been requested.  Do the enter.
         Return status = 0 iff all went well, give error diagnostics if it did not, and return
         the new timeout value if status <> 0.
        }
var errRec   : errRecord;
    enterRow : integer;
    enterCol : idType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if traceLCSMgr then LCtraceMess(73);
{$ENDC }
   GetEditCell(enterRow, enterCol);
{$IFC fDebug}
   if traceLCSMgr then
      writeln('EditRow and EditCol are ',enterRow:1,',',enterCol:1);
{$ENDC }
   ClrUndo;
   endPnlSel; {Clean up the new formula before entering.}
   enterForm(enterRow, enterCol, status, errRec);
   if status <> 0 then begin
      setRg(g.curRange, a1CellRg, enterRow, enterCol, enterRow, enterCol);

      ExitSel;
      shoNewRx(g.curRange, g.curRange, nearJ);
      g.lastActPnl := g.ActivePnl;
      g.ActivePnl  := formPnl;
      case status of
         OutOfMem,
         DSpaceErr : ;
         otherwise shoPnlErr(formPnl, status, errRec, timeout)
      end
   end
   else begin
           {Remove any knowledge of a selection in the table so the Table Editor will know to get
            the new value from the matMgr, not the sMgr.
           }
           wasEnter := true;
           DumpSel;
           nullPnlSel;
           setUndo(uEnter, formPnl);
           if errRec.status <> 0 then doNoteAlert(errRec.status)
        end
end;


{$S initial}
procedure initMSpecs;
        {Initialize move-key/move-action mappings for LisaCalc and Business Graphics}
var i : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
    if tracing then LCtraceMess(147);
{$ENDC }

     With MoveSpecs[0] do begin
           keys.key := chr(chTab);
           keys.keyheld := NoKey;
           direction := Mvright;
           end;
        With MoveSpecs[1] do begin
           keys.key := chr(chTab);
           keys.keyheld := shftKey;
           direction := MvLeft;
           end;
        With MoveSpecs[2] do begin
           keys.key := chr(chReturn);
           keys.keyheld := noKey;
           direction := MvNewRow;
           end;
        With MoveSpecs[3] do begin
           keys.key := chr(chReturn);
           keys.keyheld := shftKey;
           direction := MvNewRow;
           end;
        With MoveSpecs[4] do begin
           keys.key := chr(chEnter);
           keys.keyheld := noKey;
           direction := MvStay;
           end;
        With MoveSpecs[5] do begin
           keys.key := chr(chRight);
           keys.keyheld := NoKey;
           direction := Mvright;
           end;
        With MoveSpecs[6] do begin
           keys.key := chr(chDown);
           keys.keyheld := noKey;
           direction := MvDown;
           end;
        With MoveSpecs[7] do begin
           keys.key := chr(chLeft);
           keys.keyheld := NoKey;
           direction := MvLeft;
           end;
        With MoveSpecs[8] do begin
           keys.key := chr(chUp);
           keys.keyheld := noKey;
           direction := MvUp;
           end;
        For I := 9 to maxMoves do With MoveSpecs[i] do begin
           keys.key := 'Z';
           keys.keyheld := shftKey;
           direction := noMove;
           end;

     end;


{$S CutPaste}
procedure InsertSnip {numSnips : integer; var newCR: boolean};
        {Insert a blank snip at the grid line, which is the Current
        Range.  Set newCR if all went well.}
var status    : integer;
    continue  : boolean;
    sAlertNum : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   continue := true;
   newCR    := false;
   if doingMove then
      if doCautionalert(110) then begin
         doNoteAlert(103);
         ClrFormErrors;
         forceCalc(true)
      end
      else continue := false;
   if continue then begin
      ClrUndo;
      nullCR;

      if g.curRange.rKind = aColGrid then begin
         g.curRange.hiCol := CMax(0, g.curRange.loCol) + numSnips;
         if g.curRange.hiCol > idMax then g.curRange.hiCol := pInfSnip
      end
      else begin
              g.curRange.hiRow := CMax(0, g.curRange.loRow) + numSnips;
              if g.curRange.hiRow > idMax then g.curRange.hiRow := pInfSnip
           end;


      newSnips(g.curRange, mmBlank, false, false, status);
      setUndo(uInsrt, tblPnl);
      if status <> ok then DoSelCR(g.curRange, g.curTimeout, selectCell);
      formulaChanged := true;
      case status of
         ok        : begin
                        sAlertNum := 0;
                        newCR     := true;
                        forceCalc(true)
                     end;
         InsertErr : sAlertNum := 114;          {Table too big.  Can''t insert}
         DSpaceErr : sAlertNum := 183;
         OutOfMem  : sAlertNum := 140           {No Memory to do the paste}
      end;
      if sAlertNum <> 0 then doStopAlert(sAlertNum);
   end
   else doNoteAlert(152)
end;


(*$S fexec2 *)
function moveAction {(ch: char): moveDir};
        {Inspect the last key pair typed in and return the direction it
        implies.  If not a move key, return noMove.  ch is a dummy parameter,
        provided only to make it clear that moveAction is a function, not
        a variable.  This routine also calls WouldAlert with the key action.}
                {Not called directly by BG's Fexec}
var i          : integer;
    keysread   : keypair;
    theMoveDir : moveDir;
    direc      : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(148);
{$ENDC }
   theMoveDir := noMove;
   getKeyPair(keysread);
   if keysread.keyheld = SpecKey then keysread.keyheld := noKey;
   for i := 0 to MaxMoves - 1 do
      with moveSpecs[i] do
         if (keysread.keyheld = keys.keyheld) and (keysread.key = keys.key) then theMoveDir := direction;

   moveAction := theMoveDir;
   case theMoveDir of
      MvRight  : direc := HitRight;
      MvLeft   : direc := HitLeft;
      MvUp     : direc := HitUp;
      MvDown   : direc := HitDown;
      MvNewRow : direc := HitNewRow;
      MvNewCol : direc := HitNewCol;
      MvStay   : direc := HitEnter;
      NoMove   : direc := HitKey
   end;
   doWouldAlert(direc)
end;


(***************************************.*******.************************************
   ReturnRGFB - returns the range feedback based on the current range.  If the
                currently active panel is managed by the table editor, it is
                responcible for updating the range feedback and the caret flashing.
                If the current panel is not a table editor panel LC will be
                responcible and will basically do nothing except tell the table
                editor to redraw the range feedback.
****************************************.*******.***********************************)
{$S fexec}
procedure ReturnRGFB{var timeout : integer};
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if tblEditPnl(g.ActivePnl) then RestoreRGFB(g.curTimeOut)
   else tmSetRgFB(g.curRange, false)
end;


{$S fexec2}
procedure selectRg {newRg: range; hilite: cellseltype};
        {Remove any table feedback for the g.curRange.  Make newRg the g.curRange,
        make sure it's showing in the table, select it (according to hilite),
        and set the g.ActivePnl to the tblPnl.}
var oldRange:  range;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   oldRange := g.curRange;
   g.curRange := newRg;
   endCR;
   shoNewRx(oldRange, g.curRange, nearJ);
   DoSelCR(g.curRange, g.curTimeout, hilite);
   g.ActivePnl := tblPnl
end;


{$S fexec2}
procedure SelInLeftCorner;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   {put the selection in the upper left hand corner
    of these following range types.
   }
   case g.curRange.rKind of
      aColRg  : g.curRange.loRow := 1;
      aRowRg  : g.curRange.loCol := 1
   end;
   case g.curRange.rKind of
      aRowRg,
      aColRg,
      aRectRg : begin
                   g.curRange.rKind := a1CellRg;
                   FixRange(g.curRange);
                   nullCR;
                   doGoto(g.curRange);
                   chgStatPnl(false)
                end
   end
end;


{$S fexec}
function tblEditPnl{(aPnl: pnlIndex): boolean};
        {Return true iff aPnl is tblPnl or widePnl}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
if tracing then LCtraceMess(149);
{$ENDC }
   tblEditPnl := (aPnl = tblPnl) or (aPnl = widePnl);
end;


{$S fexec}
procedure tblMseDn {mouseRel: point; var newCR: boolean};
        {The mouse button has gone down in the tblPnl.  Do all implied
        Table Editor actions, eg, enter value, begin new selection,
        get new g.curRange, extend selection-type to word or paragraph,
        or whatever...  If the mouse down starts a new g.curRange, then
        set newCR to true, otherwise false.}
var status: integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(150);
{$ENDC }
   g.curTimeout := dfltTimeout;
   newCR := false;

   {if this mouse down starts a new g.curRange, then do an enter first}
   if not PtIn1cRg(mouserel, g.curRange) then begin
      {Mouse down in a new g.curRange}
      g.reEntrdCell := false;
      if undoRec.undoOp = uEnter then doWouldAlert(SelEnter);
      if forceEnter(status) = ok then begin
         tmCurVwSet(mouseRel);
         newCR := true;
         SelNewCell(mouserel, SelectCell, g.curNbrhood, g.curTimeout);
         adjrect(tblPnl, g.curNbrhood)
      end;
      c.FndDouble := false;
      c.FndTriple := false
   end
   else begin
           {Mouse down in same one-cell g.curRange}
           tmCurVwSet(mouseRel);
           g.reEntrdCell := true;
           if c.FndDouble then begin
              NewWSel(mouseRel, tblPnl, g.curNbrhood, g.curTimeout);
              adjRect(tblPnl, g.curNbrhood)
           end
           else if c.FndTriple then begin
                   SelAllTxt(g.curTimeout);
                   NewRgImg(g.curRange);
                   g.curNbrhood := dfltNbrhood
                end
           else begin
                   ExitSel;
                   DoTblSel(mouserel, g.curNbrhood, g.curTimeout);
                   adjrect(tblPnl, g.curNbrhood)
                end
        end;
   GetCR(g.curRange)
end;


{$S fexec2}
procedure tblMseMvd {mouseRel: point; var newCR: boolean};
       {The mouse has moved out of g.curNbrhood with the button down, and
       the button went down within the tblPnl.  Extend the selection
       appropriately.  Set newCR to true iff the g.curRange changed.}
var oldRange : range;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
    if tracing then LCtraceMess(151);
{$ENDC }
   if WMEvent.shiftKey then ExtendSel(mouserel, g.curNbrhood, g.curTimeout)
   else NewNbh(mouserel, g.curNbrhood, g.curTimeout);
   adjrect(tblPnl, g.curNbrhood);
   oldRange := g.curRange;
   GetCR(g.curRange);
   newCR := not rgEq(oldRange, g.curRange);
end;


(*$S CutPaste *)
procedure TeCheckKeys(CopyMenu : boolean);
var myKeys : keySet;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)
   IsCopyCells := false;
   if g.LCflag then begin
      GetKeys(myKeys);
      if (78 in myKeys) or (124 in myKeys) then
         if 126 in mykeys then IsCopyCells := doCautionAlert(191 + ord(CopyMenu))
   end
end;


(*$S CutPaste *)
procedure TEclrRg(theSelKind : selKind; var status: integer; var txtChg: boolean; var newCR: boolean);
        {The user has selected the clear menu item or
        has hit the clear key.  Do the clr and return status.  Return
        txtChg = false, since a text change is impossible.  Set newCR to false,
        since this operation cannot change the current range.}
label 100;
var ignoreUndo : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
  if tracing then LCtraceMess(152);
{$ENDC }
   ignoreUndo := false;
100:
   txtChg := false;
   newCR  := false;
   status := 0;
   case theSelKind of
      aRectRgSl,
      aRowRgSl,
      aColRgSl,
      a1CellSl,
      aWTBoxSl : begin
                    ClrUndo;
                    DumpSel;
                    NewSnips(g.curRange, mmClear, ignoreUndo, false, status);
                    setUndo(uClrTem, tblPnl);
                    case status of
                       ok         : begin
                                       forceCalc(true);
                                       newCR := true
                                    end;
                       undoErr    : begin
                                       ignoreUndo := doCautionAlert(116); {Not undoable.  Do it anyway?}
                                       if ignoreUndo then goto 100;
                                    end;
                       ProtectErr : begin
                                       doNoteAlert(115); {The protected cells  were not cleared}
                                       forceCalc(true);
                                       newCR := true
                                    end
                    end
                 end
   end
end;


{$S TxtCutPaste}
procedure TEclrTxt(theSelKind : selKind; var status: integer; var txtChg: boolean; var newCR: boolean);
        {The user has selected the clrTxt menu item and the g.ActivePnl is tblPnl
        or widePnl.  Do the clrTxt and return status.  Return txtChg = true iff a
        text change is attempted.  Set newCR to false, since clrTxt can't
        change the current range.}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(153);
{$ENDC }
   status := 0;
   newCR  := false;
   txtChg := false;
   case theSelKind of
      aCellTxtSl,
      a1CellSl : begin
                    txtChg := true;
                    ClrUndo;
                    ClearSel(status);
                    if status = 0 then setUndo(uClrTxt, tblPnl)
                 end
   end
end;


{$S TxtCutPaste}
procedure TEcopy(theSelKind : selKind; var status: integer; var txtChg: boolean; var newCR: boolean);
        {The user has selected the copy menu item and the g.ActivePnl is tblPnl
        or widePnl.  Do the copy and return status.  Return txtChg = false,
        since copy can't change the text.  Set newCR to false, since copy can't
        change the current range.}

    (*$S CutPaste *)
    procedure copyNewSnips;
    var ignoreUndo : boolean;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       TeCheckKeys(true);
       ignoreUndo := false;
       NewSnips(g.curRange,mmCopy, ignoreUndo, false, status);
       case status of
          ok      : begin
                       InheritScrap(true);
                       PutScrap(ScrapMtx, nil, status);
(*$IFC fDebug *)
                       if status <> 0 then PrintMess(27);
(*$ENDC *)
                       drwCellScrap;
                       setUndo(uCopyRg, tblPnl)
                    end;
          dSpaceErr : doStopAlert(185);
          undoErr   : doStopAlert(124); {Out of memory}
{$IFC fDebug}
          otherwise PrintMess(27)
{$ENDC }
       end
    end;


{$S TxtCutPaste}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(154);
{$ENDC }
   ClrUndo;
   status := 0;
   newCR  := false;
   txtChg := false;
   case theSelKind of
      aCellTxtSl : begin
                      CopySel(status);
                      if status = 0 then setUndo(uCopyTxt, tblPnl)
                      else txtChg := true
                   end;
      aRowRgSl,
      aColRgSl,
      a1CellSl,
      aRectRgSl,
      aWTBoxSl  : copyNewSnips
   end
end;


{$S TxtCutPaste}
procedure teCut(theSelKind : selKind; var status: integer; var txtChg: boolean; var newCR: boolean);
        {The user has selected the cut menu item and the g.ActivePnl is tblPnl
        or widePnl.  Do the cut and return status.  Set txtChg to true iff
        the cut attempted was of text.  Set newCR to true if a range was cut.}

    (*$S CutPaste *)
    procedure cutNewSnips;
    label 2;
    var ignoreUndo    : boolean;
        ignoreProtect : boolean;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       ignoreUndo    := false;
       ignoreProtect := false;
       moveAlertCnt  := 0;
    2: nullCR;
       NewSnips(g.curRange, mmNull, ignoreUndo, ignoreProtect, status);
       setUndo(uCutRg, tblPnl);
       if status <> ok then DoSelCR(g.curRange, g.curTimeout, selectCell);
       case status of
          ok         : begin
                          InheritScrap(true);
                          if ignoreUndo then PutScrap(ScrapNil, nil, status)
                          else PutScrap(ScrapMtx, nil, status);
(*$IFC fDebug *)
                          if status <> 0 then PrintMess(28);
(*$ENDC *)
                          newCR := true;
                          forceCalc(true);
                          if ignoreUndo then ClrScrapFld
                          else drwCellScrap;
                       end;
          dSpaceErr  : doStopAlert(183);
          OutOfMem   : doStopAlert(140); {No Memory to do the paste}
          undoErr    : begin
                          if diskErr then ignoreUndo := doCautionAlert(184)
                          else ignoreUndo := doCautionAlert(125); {Can't put anything in scrap}
                          if ignoreUndo then goto 2
                       end;
          ProtectErr : begin
                          ignoreProtect := doCautionAlert(130);
                          if ignoreProtect then goto 2
                       end
       end
    end;


{$S TxtCutPaste}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(155);
{$ENDC }
   ClrUndo;
   status := 0;
   newCR  := false;
   txtChg := false;
   case theSelKind of
      aCellTxtSl : begin
                      txtChg := true;
                      CutSel(status);
                      if status = 0 then setUndo(uCutTxt, tblPnl)
                   end;
      aRowRgSl,
      aColRgSl,
      a1CellSl,
      aRectRgSl,
      aWTBoxSl   : cutNewSnips
   end
end;


{$S TxtCutPaste}
procedure TEedits {var status: integer; var txtChg: boolean; var newCR: boolean};
        {The user has selected an item in the edits menu and the g.ActivePnl
        is the tblPnl or the widePnl.  Do the appropriate clear, cut, copy,
        or paste.  Set txtChg to true if a text change is attempted; set newCR
        to true if the Current Range changes.}
var theSelKind : selKind;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(156);
{$ENDC }
   status := 0;
   newCR  := false;
   txtChg := false;

   if g.ItemIndex <> feCopy then shoNewRx(g.curRange, g.curRange, nearJ);
   GetSelKind(theSelKind);
   case g.ItemIndex of
      restOrig,
      feCopy  : ;
      otherwise formulaChanged := formulaChanged or (theSelKind <> aCellTxtSl)
   end;
   case g.ItemIndex of
      feCopy   : TEcopy(theSelKind, status, txtChg, newCR);
      cut      : TEcut(theSelKind, status, txtChg, newCR);
      pasteM   : begin
                    TEpaste(theSelKind, mmScrap, status, txtChg, newCR);
                    IsCopyCells := false
                 end;
      pasteR   : TEpaste(theSelKind, mmRelative, status, txtChg, newCR);
      pasteV   : TEpaste(theSelKind, mmValue, status, txtChg, newCR);
      clr      : if (theSelKind = aCellTxtSl) or (g.ActivePnl <> tblPnl) then
                    TEclrTxt(theSelKind, status, txtChg, newCR)
                 else TEclrRg(theSelKind, status, txtChg, newCR);
      restOrig : TERestore
   end;
   if (g.ItemIndex <> feCopy) and FormulaChanged then
      case circleState of
         cError     : if g.ItemIndex = cut then SetCircleMode(cError);
         cCircular,
         cDependent : if not txtChg then SetCircleMode(circleState)
      end
end;


{$S fexec2}
procedure TEkey {ch: char; var wasMove: boolean; var status: integer};
        {Called when a key (ch) has been typed and the g.ActivePnl is either
        the tblPnl or the widePnl.  If the key is an enter-move key,
        do the appropriate enter and move; if not an enter-move key,
        insert the character, if appropriate, into the value under-edit.
        If the key was a move key, set wasMove to true, otherwise false.
        Return status = 0 if the move happened successfully or the key
        was accepted.  Note that this routine calls enterCalc.  Read the
        comments there.}
var response  : diResponse;
    NextEvent : EventRecord;
    SkipCalc  : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(157);
{$ENDC }
   status  := 0;
   moveAct := MoveAction(ch);
   if MoveAct <> noMove then begin
      SkipCalc := false;
      wasMove  := true;
      response := OkAction;
      if curDiHeight > 0 then
         disMissDi(MenuAlert, HitEnter, response);
      if response = IgnoreAction then wasMove := false
      else begin
              if (g.BGflag or g.AutoCalc) and (g.ActivePnl = TblPnl) then {look at next event}
                 if PeekEvent(NextEvent) then {there is an event queued}
                    with NextEvent do
                       if (what = keydown) and not AppleKey then SkipCalc:=true;
              enterCalc(true, false, true, SkipCalc, status);
              if status = 0 then DoKeyedMove(moveAct, status);
           end
   end
   else begin
           wasMove := false;
           response := OkAction;
           if curDiHeight > 0 then disMissDi(MenuAlert, HitKey, response);
           if response <> IgnoreAction then begin
              if tableState <> tValues then doStopAlert(10004) {Can''t type while formulas are showing}
              else begin
                      SelInLeftCorner;
                      if g.curRange.rKind = a1CellRg then begin
                         ClrUndo;
                         InKey(ch, WMEvent.shiftKey, WMEvent.appleKey, false, g.curTimeout, status);
                         if status = 0 then setUndo(uKey, tblPnl)
                      end
                      else doStopAlert(104) {No text selection. Key ignored}
                   end
           end
        end
end;


{$S fexec2}
procedure TEmseUp {mouseRel: point; var newCR: boolean};
        {The mouse button has just gone up and the g.ActivePnl is the tblPnl
        or the widePnl.  Handle any entering and g.curRange changing that may
        result.  Set a new g.curTimeout.  Note that this calls enterCalc.  See
        the comment there.  If the mouse up changes the g.curRange, then newCR
        is set to true.}
     var status      : integer;
         savedRg     : range;
         enterRow    : idType;
         enterCol    : idType;
         newSelKind  : selKind;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(158);
{$ENDC }
   newCR := false;
   {if mouse was dragged outside of the cell, do an enter}
   if g.ActivePnl = tblPnl then GetSelKind(newSelKind)
   else newSelKind := aNullSl;

   if (g.ActivePnl = tblPnl) and g.reEntrdCell then begin
      if (newSelKind = aRectRgSl) then begin
         savedRg := g.curRange;
         GetEditCell(enterRow, enterCol);
{$IFC fDebug}
         if tracing then writeln('EditRow and EditCol are ', ord(enterRow),'/ ', ord(enterCol));
{$ENDC }
         setRg(g.curRange, a1CellRg, enterRow, enterCol, enterRow, enterCol);
         status := forceEnter(status);
         doWouldAlert(SelEnter);
         if status = 0 then g.curRange := savedRg;
         DoSelCR(g.curRange, g.curTimeout, selectCell);
         newCR := true
      end
      else MseUp(mouserel, g.curTimeout)
   end
   else begin
           if (g.ActivePnl = tblPnl) and (g.curRange.rKind = aRectRg) then newCR := true;
           MseUp(mouserel, g.curTimeout);
           if newSelKind = aRectRgSl then DumpSel
        end
end;


{$S TxtCutPaste}
procedure TEpaste{theSelKind : selKind; pasteKind: srcType; var status: integer; var txtChg: boolean;
                  var newCR: boolean};
        {The user has selected the paste menu item and the g.ActivePnl is tblPnl
        or widePnl.  Do the paste and return status.  Return txtChg = true iff a
        text change is attempted.  Return newCR = true iff the Current Range
        changes.  PasteKind is mmScrap for a regular paste and mmValue for
        PasteValues.}
var numBytes   : integer;
    ScrapInfo  : scrapType;
    rScrapInfo : scrapType;
    scrapPtr   : TH;
    ScrapCont  : TB;
    scrapVal   : array [0..maxFormLen] of byte;

    {$S TxtCutPaste}
    procedure strPaste(dPtr : ptrData);
       {Paste the text from the value of the single cell in the
       scrap into the current text selection and set txtChg and
       the undo information}
    var i, keyStatus, timeout: integer;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       txtChg := true;
       for i := 0 to numbytes - 1 do begin
          InKey(chr(dPtr^[i]), false, false, false, Timeout, keyStatus);
          if keyStatus <> 0 then status := keyStatus
       end;
       if status = 0 then setUndo(uPasteTxt, tblPnl)
    end;


    {$S TxtCutPaste}
    procedure txtPaste;
       {Paste the text from the scrap into the current text selection
       and set txtChg and the undo information}
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       txtChg := true;
       PasteSel(false, maxLenWav, status);
       ReDrawSel(true);
       if status = 0 then setUndo(uPasteTxt, tblPnl)
    end;


    (*$S CutPaste *)
    procedure pasteNewSnips;
    label 4;
    var ignoreUndo    : boolean;
        ignoreProtect : boolean;
        scrapRg       : range;
        sAlertNum     : integer;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       if ScrapInfo = ScrapFE then TeCheckKeys(false);
       ignoreUndo    := false;
       ignoreProtect := false;
       sAlertNum := 0;
    4: if (ScrapInfo = ScrapFE) or (ScrapInfo = ScrapMtx) then begin
          status := ok;
          nullCR;
          DumpSel;
          if (ScrapProcess <> My_ID) or ((ScrapProcess = My_ID) and ScrapAbsent) then
             {if the scrap handle is nil, then whoever owned the scrap crashed and never
              made its data available to the masses.  Therefore, we'll assume responsibility
              for the scrap and tell the user that there is nothing to paste.
             }
             if (scrapPtr = nil) and (ScrapInfo = ScrapMtx) then begin
                InheritScrap(false);
                PutScrap(ScrapNil, nil, status);
(*$IFC fDebug *)
                if status <> 0 then PrintMess(31)
                else
(*$ENDC *)
                AcceptInheritScrap;
                status := NoScrapErr
             end
             else if ScrapInfo = ScrapMtx then begin
                     ReadMMscrap(status);
{
                     if status = 0 then begin
                        ClaimScrap;
                        AcceptInheritScrap
                     end
}
                  end
             else if ScrapCont = 0 then FEterminate;
          if status = ok then begin
             if g.BGflag then pasteKind := mmValue;
             NewSnips(g.curRange, pasteKind, ignoreUndo, ignoreProtect, status)
          end;
          if status <> ok then DoSelCR(g.curRange, g.curTimeout, selectCell);
          case status of
             ok         : begin
                             if pasteKind = mmRelative then begin
                                putRepBox;
                                newCR := false;
                             end
                             else begin
                                     if pasteKind = mmScrap then SetUndo(uPasteRg, tblPnl)
                                     else SetUndo(uPasteVal, tblPnl);
                                     forceCalc(true);
                                     newCR := true
                                  end
                          end;
             undoErr    : begin
                             ignoreUndo := doCautionAlert(116); {Not undoable.  Do it anyway?}
                             if ignoreUndo then goto 4
                          end;
             pasteErr   : begin
                             RgInScrap(scrapRg);
                             case scrapRg.rKind of
                                aRectRg,
                                a1CellRg : sAlertNum := 146; {Can''t paste this scrap to this selection}
                                otherwise  sAlertNum := 158
                             end
                          end;
             InsertErr  : sAlertNum := 114; {Table too big.  Can''t insert}
             FileErr,
             OpenErr,
             BadFile,
             NoScrapErr : sAlertNum := 139; {Data does not really exist in Scrap}
             RepeatErr  : sAlertNum := 120; {Can''t move to more than one place}
             DSpaceErr  : sAlertNum := 183;
             OutOfMem   : sAlertNum := 140; {No Memory to do the paste}

             ProtectErr : begin
                             ignoreProtect := doCautionAlert(127);
                             if ignoreProtect then goto 4
                          end
          end
       end
       else if ScrapInfo = ScrapNil then sAlertNum := 118 {Can''t paste an empty scrap}
       else sALertNum := 102; {Scrap and Selection incompatible}
       if sAlertNum <> 0 then doStopAlert(sAlertNum)
    end;


{$S TxtCutPaste}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
  if tracing then LCtraceMess(159);
{$ENDC }
   ClrUndo;
   SetUndo(uNothing, nullPnl);
   GetScrap(rScrapInfo, scrapPtr);      {Check application specific scrap}
   GetCsScrap(ScrapCont);               {Check universal text stream}
   ScrapInfo := rScrapInfo;
   if (ScrapInfo <> ScrapMtx) and (ScrapCont <> 0) then ScrapInfo := ScrapFE;
   status := ok;
   newCR  := false;
   txtChg := false;
   case theSelKind of
      aCellTxtSl : case ScrapInfo of
                      ScrapFE    : txtPaste;
                      ScrapMtx   : begin
                                      numbytes := maxFormLen + 1;
                                      if aRgInScrap(@scrapVal, true,numbytes) then strPaste(@scrapVal)
                                      else if ScrapCont <> 0 then txtPaste
                                      else doStopAlert(108)       {You can''t paste cells to a text selection}
                                   end;
                      ScrapNil   : doStopAlert(118);
                      otherwise    doStopAlert(102)
                   end;
      a1CellSl   : if rScrapInfo = ScrapFE then txtPaste
                   else pasteNewSnips;
      aRectRgSl,
      aRowRgSl,
      aColRgSl,
      aRowGrdSl,
      aColGrdSl,
      aWTBoxSl   : pasteNewSnips
   end
end;


{$S OpenClose}
procedure TEreInit { freshStart:  boolean };
        {ReInitialize the Table Editor: init the Table Editor variables and
        put up a table.  Assume that a table has been shown already.
        Don't change menus, trace flags, move keys, or jfract.
        Not called directly by BG's Fexec
        if freshStart is true, then reinit entire table; otherwise, assume that
        selction mgr has valid data, and restore its feedback in the table
        }
     var isCells    : boolean;
         theSelKind : selKind;
     begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
        if tracing then LCtraceMess(160);
        if traceOC then writeln('TEReinit, mode=',freshStart:1 ) ;
{$ENDC }
        if freshStart then begin
           reInitSelMgr;
           g.reEntrdCell := false
        end;
        GetCR(g.curRange)  ; { will be null if fresh start, otherwise will have been set by initDisplay }

        getSelKind ( theSelKind ) ;   {++TMSProcs++}
        isCells := (theSelKind <> aCellTxtSl );
        tmSetRgFB (g.curRange , isCells ) ;
        tmShoNewTbl;

{$IFC fDebug}
        if switches[7] then  NewRgBorders ( g.curRange, false )      {+}
{$ENDC }
     end;


{$S undoCode}
procedure TERestore;
        {Does a Restore Original, ie, dumps the current edited selection and
         reselects the current range without changing what the Matrix Mgr
         still believes to be its contents.  Assume that this can be called
         only when the current range is a single cell and there is something
         to enter, ie, some editing of value or formula has taken place.}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(161);
{$ENDC }
   ClrUndo;
   DumpSel;
   g.pnlWithChg := nullPnl;
   selectRg(g.curRange, selectCell);
   SetUndo(uRestore, nullPnl);
   chgStatPnl(false)
end;


{$S fexec2}
procedure wideMseDn{mouseRel: point};
        {The mouse button has gone down in the widePnl.  Do the appropriate
        selection initiations or extensions in the Table Editor.}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(163);
{$ENDC }
   g.curTimeout := dfltTimeout;
   if c.FndDouble then begin
      NewWSel(mouseRel, widePnl, g.curNbrhood, g.curTimeout);
      adjrect(widePnl, g.curNbrhood)
   end
   else if c.FndTriple then begin
           SelAllTxt(g.curTimeout);
           NewRgImg(g.curRange);
           g.curNbrhood := dfltNbrhood
        end
   else begin
           DoWavSel(mouserel, g.curNbrhood, g.curTimeout);
           adjrect(widePnl, g.curNbrhood)
        end
end;


{$S fexec2}
procedure wideMseMvd{mouseRel: point};
        {The mouse has moved out of g.curNbrhood with the button down, and
        it went down within the widePnl.  Extend the selection appropriately.}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(198);
{$ENDC }
   NewNbhWav(mouserel, g.curNbrhood, g.curTimeout);
   adjrect(widePnl, g.curNbrhood)
end;

{$I aplc/LCmenus.text}
{$I aplc/LCmenus2.text}
{$I aplc/LCMenus3.text}
{$I aplc/undo.text}

(*$S initial *)
END.
