
                            {'Copyright 1983, 1984, Apple Computer Inc.'}

(*********** aplc/lcfiler - lisacalc file management code - unit lcfexec **************)

  { --------------------------------------------------------------------------------------------- }

(*$S OpenClose *)
procedure fxDataStuff
  (* mode       : FIOkind;
     verNumPres : boolean;
     var status : integer
  *);

{ read or write lc/bg fexec state to a file.  If 'verNumPres' is true, it means that the
  file being read was created since we started stuffing lc-fexec info to a file;
  if false, it's an old-style file without lc/bg fexec info }

  const SMSusLength   =    444 ; { size to set HndSusData^^ to }
        CLCCurVersion =      8 ; { current LC-stuff version    }
        cTrailer      =     91 ; { synch checker               }

        { History of LC-Stuff-version numbers and corresponding file formats:
           1  29July82:  VersionNumber only

           4  15Aug 82:
                      (1) Version Number
                      (3) SelMgr data size (0 if none)
                      (4) SelMgr data contents (absent if item 2 is zero)
                      (5) g-vector for FEGlobals
                      (7) trailer -- an integer to ensure we're still in synch

           5   18Aug82:  as above, but with item <6> inserted, being the field/fieldstate
                         packing of the formula field, iff g.activePnl = formPnl

           6   22Sep82: as above, but  items (2) added: the TM State--iff (un)suspending

           7   1 Nov82: as above, but item 5 1/2, the tWideStr, stuffed between [5] and [6]

           8  29 Nov83: g.tabFontMode and g.curPrFont changed for new typestyle menu
}


  var
      HndSusData:            HndData;  { for calls to package/unpackage selection-mgr state}
      LenInstalled, NewLen:  integer;  {                    "                              }
      Reading,                            { is this an open or unsuspend or new ?  }
        Writing,                          { is this a close or suspend?            }
        SuspOrUnsusp:        boolean;     { is this a suspend/unsuspend operation? }

      ModeData:              ModeInfo;  { for getting MM data on modes,font... }
      DataSize:              integer;   { for use with fBufStuff           }

      LcVers:                integer;   { lc-stuff version number to/from file }
      gSaved:                FExecVar;  { for reading in saved copy of G-vector }

      trailer:               integer;   { packed/unpacked at end of stuff for safety }

      aTMstate:              tmState;   { table manager state }

       procedure CheckStatus ;  { checks status from FBufStuff calls, exits if bad }
         begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

            if status <> 0 then
               begin
                  if tempCode then writeln('FxDataStuff: rotten status:',status);
                  exit ( FxDataStuff )
               end
         end ;{ checkStatus }

 begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if tracing then LCtraceMess(78);
   if skipFlag or tracing or TraceOC then
      writeln('fxDataStuff: Mode passed is ', ord(mode):1,' version # present: ',verNumPres);
   UnSusOld := false ; { temp flag for handling backward-compatibility }
{$ENDC }

   Reading := ( mode in [ mmUnSuspend, mmOpen] ) ;
   Writing := not Reading ;
   SuspOrUnsusp := ( mode = mmSuspend ) or (mode = mmUnSuspend ) ;

   if Writing then lcVers := CLCCurVersion ; { set up version and mode stuffed for output }
{$IFC fDebug}
   if Reading then if not verNumPres then
                         begin
                            LCVers := 0;
                            Writeln('WARNING-old file, no LC Stuff version')
                         end;
{$ENDC }


   if verNumPres or Writing then begin
      DataSize := SizeOf( LCVers ) ;   {  stuff/unstuff the lc-stuff version number }
      FBufStuff ( fRawData, @LCVers , DataSize , status );
      CheckStatus;
{$ifc fDebug}
      if traceOC then if reading then writeln('LC Version=',lcVers:1) ;
{$endc}

      if Reading then
         begin
{$ifc fDebug}
            if LcVers > CLCCurVersion then
               begin
                  status := NewerFile ;
                  writeln ('File version more recent than software version!');
                  exit ( FxDataStuff )
               end
            else if LcVers < CLCCurVersion then
                       writeln('WARNING--file has lcstuff version ',lcVers:1,
                                   ' ; prog has version ',CLCCurVersion:1);
            if (LcVers < 4) and (SuspOrUnSusp)
             then UnSusOld := true  {flag for InitDisplay to handle unsuspending old file}
{$ELSEC }
            if LcVers > CLCCurVersion then status := NewerFile;
{$endc}
         end ; { version worries over }

      if ((lcVers >= 6) and suspOrUnSusp)  then    { load/dump tm State }
         begin
            if writing then begin
               tmSaveState ( aTMState ) ;      { get state from TM }
{$ifc debugVersion}
               if traceOC then with aTMState do
                  begin
                        writeln('MarqSaved=',marQsaved:4,'/isSel=',isSel:4,'/isOn=',isOn:4,
                              '/isBorder:',isBorder:4);
                        with rg do writeln('TM-State range:  rgType=',ord(rKind):2,' [',
                        loRow:1,',',loCol:1,'] - [', hiRow:1,',',hiCol:1,'] ');
                  end
{$endc}
            end ;  { writing tm state }
            dataSize := sizeOf ( tmState ) ;                 { read/write the state }
            fBufStuff(fRawData,@aTMState,dataSize,status);   {    to/from the file  }
            checkStatus;
            if reading then
               begin
                  tmLoadState( aTMState );         { send state to TM  }
{$ifc debugVersion}
                  if traceOC then with aTMState do
                     begin
                        writeln('MarqSaved=',marQsaved:4,'/isSel=',isSel:4,'/isOn=',isOn:4,
                              '/isBorder:',isBorder:4);
                        with rg do writeln('TM-State range:  rgType=',ord(rKind):2,' [',
                        loRow:1,',',loCol:1,'] - [', hiRow:1,',',hiCol:1,'] ');
                     end
{$endc}
               end
         end;

      if lcVers >= 4 then    { **** Load/dump Selection Manager state **** }
         begin
            { create block on heap for data transfer }
            if SuspOrUnSusp then begin
               HndSusData := pointer(ord(HAllocate(TheHeap, SMSusLength) )) ;
               case mode of
                 mmSuspend:
                    begin
                        PackSMgr (HndSusData, 0, SMSusLength, LenInstalled, NewLen ) ;
                        dataSize := sizeOf(LenInstalled);
                        fBufStuff(fRawData, @LenInstalled , dataSize, status);
                        checkStatus;
                        fBufStuff(fRawData, HndSusData^, LenInstalled , status )     ;
{$ifc fDebug}
                        if traceOC then writeln('Stuffing smgr state; lenInstalled=',lenInstalled:1);
{$endc }
                        checkStatus
                    end;

                 mmUnSuspend:
                    begin
                        dataSize := sizeOf(LenInstalled);
                        fBufStuff(fRawData, @LenInstalled , dataSize, status);
                        checkStatus;
                        if SMSusLength < LenInstalled then  {more Smgr data written than we expect!}
                           begin
                              status := NewerFile ;
                              exit (fxDataStuff)
                           end;
                        fBufStuff( fRawData, HndSusData^, LenInstalled , status );
                        checkStatus;
{$ifc fDebug}
                        if traceOC then writeln('UnStuffing smgr state; lenInstalled=',lenInstalled:1);
{$endc }
                        UnPackSMgr ( HndSusData , 0)
                    end
               end { case } ;

              { release heap space used for packaging/unpackaging SelMgr state }
               FreeH ( TheHeap, pointer(ord(HndSusData)) ) ;

            end { save/restore Selection Manager State }
            else {  in non suspend/unsuspend case, pack/unpack just a zero }
               begin
{$ifc fDebug}
                  if traceOC then writeln('SelMgr state: just (un)stuffing a zero');
{$endc}
                  lenInstalled := 0;
                  dataSize := sizeOf(LenInstalled) ;
                  fBufStuff(fRawData, @LenInstalled , dataSize, status);
                  checkStatus
               end
         end ; { dealing with selection-mgr state }


      if writing then    { (un)Stuff  the g-array of FEGlobals }
         begin
            DataSize := SizeOf(g);
            fBufStuff ( fRawData, @g, DataSize , status );
{$ifc fDebug}
            if TraceOC then writeln('Stuffed G-array');
{$endc}
            checkStatus ;

            DataSize := sizeOf(tWideStr);        { stuff title to WAV }
            fBufStuff ( fRawData, @tWideStr , dataSize, status ) ;
            checkStatus
         end
      else if ( lcVers >= 4 ) then   { reading a file that has g-vector stuffed }
         begin
            dataSize := sizeOf ( fExecVar ) ;
            fBufStuff ( fRawData, @gSaved , dataSize , status ) ;
            checkStatus;

            if (lcVers >= 7) then  { unstuff title to WAV }
               begin
                  DataSize := sizeOf(tWideStr);        { stuff title to WAV }
                  fBufStuff ( fRawData, @tWideStr , dataSize, status ) ;
                  checkStatus
               end;
{$ifc fDebug}
            if TraceOC then writeln('Saved G-array read back in');
{$endc}
            with gSaved do
               begin        { transfer relevent items into the true G-array }
                  g.curPrFont   :=  curPrFont ;
                  g.TabFontMode :=  TabFontMode;
                  if (mode = mmUnSuspend) then
                     begin
                        if (activePnl <> cCoPnl)  then           {:}
                           begin
                              g.padding      := '';
                              g.ActivePnl    := ActivePnl;
                              g.lastActPnl   := lastActPnl;
                              g.pnlWithChg   := pnlWithChg;
                              g.pnlToEnter   := pnlToEnter;
                              g.curRange     := curRange;
                              g.curNbrHood   := curNbrHood;
                              g.curTimeOut   := curTimeOut;
                              g.reEntrdCell  := reEntrdCell
                           end { restoring g-vector on unSuspend }
                        else { Cells pnl was active at time of suspend }  endCR  {++TMSProcs++}
                     end { unsuspending }
               end  { moving from gSaved to actual G }
         end { unstuffing FExecVar vector }

   end ; { all cases except reading an old file which lacks all fx stuff data }


   { Call the various module-specific stuffing routines }

   CoMgStuff (mode, LcVers, status) ;  { ++CoMgr++   } { results in possible stuffing of form field  }
   CheckStatus;

   { nb: CoMgStuff must be called BEFORE LCSMStuff, since it must reestablish the
         fields before their handles are recorded by LCSMgr }
   LCSMStuff (mode, lcVers, status) ;  { ++LCSMgr++  } { sorts out LCSmgr handles }
   CheckStatus;

(*   AppDStuff (mode, LcVers, status) ;  { ++AppDiBox++} { Stuff App-specific Dialog info    }
   CheckStatus;
*)

   if reading {$ifc fDebug} and not unSusOld {$endc} then   { unpack the trailer and check it }
      begin
         dataSize := sizeOf ( Trailer ) ;
         fBufStuff ( fRawData , @Trailer , dataSize , status ) ;
         checkStatus;
{$ifc fDebug}
         if traceOC then writeln ( 'Trailer unstuffed, value= ', trailer:2);
         if trailer <> CTrailer then writeln('trailer read back in does not match')
{$endc }
      end
   else if writing then  { pack the trailer }
      begin
         Trailer := cTrailer;
         dataSize := sizeOf ( Trailer ) ;
         fBufStuff ( fRawData, @Trailer, dataSize , status );
         checkStatus;
{$ifc fDebug}
         if traceOC then writeln('Stuffed trailer')
{$endc }
      end;

   if Reading then { set up font info and also set up app panels }
      begin
         GetModeInfo(ModeData); { get the Font & mode information from the matrix-manager }
         with modeData do
            begin
               g.autoCalc   := calcMode;
               g.ModernFont := (Tfid.Fam <> p12Cent) and (Tfid.Fam <> p10Cent);
               if lcVers <= 7 then g.TabFontMode := g.TabFontMode + 1;
               SetTblFont(Tfid.Fam);
               SetApp2Pnls;
               if tblPars.shoFormula then mmSetWids(tFormulas);
               if printState.preview then mmSetWids(tPreview)
            end
      end;

   {**************  Load the application specific info   ************}
   if g.BGFlag then iFxBGstuff(mode, status, BGProcInfo.FxBGstuff)
end ; { FxDataStuff }


(***************************************.*******.************************************
    The Sys_Terminate exception handler.  Gets called when the program terminates
    normally (i.e., last statement executed) or abnormally (e.g., bus error)

*)
(*$S OpenClose *)
procedure LastWishes
  (* environPtr   : P_env_blk;
     excepDataPtr : P_ex_data
  *);
var filererror  : integer;
    scrapInfo   : ScrapType;
    ptr         : TH;
    forceUpdate : boolean;
    rg          : range;
    titleTab    : str255;
begin
   ImDying;
(*$IFC fTraceLC *) LogCall; (*$ENDC *)


{$IFC fDebug }
   writeln('LastWishes:  exception #',excepDataPtr^[0]:1);
   if not quitRequest then write('   Abnormal ')
   else write('   ');
   write('Death in');
   if g.LCflag then write(' Lisa Calc')
   else write(' Business Graphics');
   writeln('.  Notifying the filer.');
   writeln('Halting');
   getKeys(myOwnKeys);
   if 118 in myOwnKeys then begin
      write(chr(7));
      skipFlag := true
   end;
{$ENDC }

   procsDying  := true;
   forceUpdate := false;
   Dialogfolder^.grafProcs := nil;

   {If I own the scrap but have not written the data out for it into the scrap data segmen,
    then clear the type for that scrap such that no one will think that there is real
    data in the scrap data segment.
   }
   if ScrapProcess = My_Id then begin
      GetScrap(scrapInfo, ptr);
      if (scrapInfo = ScrapMtx) and (ptr = nil) then begin
         AcceptInheritScrap;
         PutScrap(ScrapNil, nil, filerError);
         WMKillPicture(ScrapFolder);
         forceUpdate := true
      end
      else forceUpdate := (activeFolder = Scrapfolder);
      if forceUpdate then begin
         {force the new owner of the scrap to update the image in the scrap}
         SetPort(ScrapFolder);
         InvalRect(ScrapFolder^.portrect)
      end
   end;

   if not quitRequest then HideFolder(alertFolder);                  {remove alertfolder}

   {clear the image in the table}
   if Folder <> nil then begin
      SetPort(Folder);
      with thePort^ do begin
         ClipRect(portrect);
         EraseRect(portRect);
         ValidRect(portrect);
         HideSBorder(portrect)
      end;
      WMKillPicture(Folder)
   end;

   if numDocsOpen >= 1 then begin
      BeginUpdate(folder);
      EndUpdate(Folder);
      GetFldrTitle(Folder, titleTab);
      ParamAlert(titleTab, '', '');
      doPnlDrawAlert(148, FolderPnl);

{$IFC fDebug }
      if not (debug[5] or skipflag) then
{$ENDC }
      doFilerEvent(true);
   end;
   FeTerminate;
   halt
end;


(*$S initial *)
procedure checkFormat(var errnum : INTEGER; alertNumber : INTEGER; VAR messageText : pathName);
const defDateFormat    = 'mdy/';
      defDSign         = '$';
      defDollarBracket = '()';
      defDecPt         = '.';
      defTSep          = ',';
      blankTSep        = $20;           {regular blank}
      nonBreakSpace    = $CA;           {non breaking space}

var str4      : char;
    str123    : string[3];
    tmpStr    : string[255];
    str       : string[255];
    found     : boolean;
    rightMost : integer;
    rightNum  : integer;
    tmpErrNum : integer;
    x, y      : integer;

{  errnum = (0,1..19), settable to any range: 0,errnum+1,...,errnum+19

          =  0      no error

          =  1      no thousand separator found;
                    default is different from decimal point character

          =  2      there is no unique decimal point;
                    default is the rightmost separator encountered

          =  4      no decimal point found;
                    default is '.'

          =  8      unrecognizable characters in number/currency string;
                    default currency symbol is '$'

          =  any sum of above error numbers gives the combination

          = 16      empty number/currency string;
                    default is '$9,999.'

          = 17      use of semicolon is not recognized;
                    default is 'Yes'

          = 18      date order string is not accepted;
                    default is 'mdy/'

          = 19      debit/credit char's are not correct (1 on each side);
                    default is dollarBrackets = '[]'

 }

BEGIN
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

doGetAlert(alertNumber, @str);
CASE alertnumber OF
1001:
   BEGIN  {CASE alertnumber = 1001; number/currency string}

   x := length(str);
   tmpstr := str;
   tmpErrNum := errNum;
   if x = 0 then begin
                     errnum := errnum + 16; {empty number/currency string}
                    { goto 100; ?????????????????????????????? }
                 end;


   { Find Decimal Point: toolFormat.decPt }
   { x = position of (fictive) decimal point in str throughout this section }

   rightmost := 0;
   rightnum := 0;
   found := false;
   while not found and (x > 0) do
     case str[x] of
         '0','1','2','3','4','5','6','7','8','9':
             begin            {find rightmost digit in case there is no decPt}
                if rightnum < x then rightnum := x;
                x := x - 1
             end;
         defDecPt, defTSep:            { list of decimal point characters }
             begin
                found := true;
                toolFormat.decPt := str[x];
                { check for another decPt }
                y := x - 1;
                while found and (y > 0) do
                    if str[y] = toolFormat.decPt then begin found := false;
                                                  {str[x] can't be decPt}
                                                  if x > rightmost then
                                                            rightmost := x;
                                                            {save decPt-position}
                                                  x := x - 1;
                                            end
                                       else begin y := y - 1;
                                            end;
              end;
          otherwise
              x := x - 1;
       end; { case str[x] }

   if (x = 0) and (rightmost = 0) then
          begin
(*$IFC DEBUGVERSION *)
              writeln('no decimal point found');
(*$ENDC *)
             errnum := errnum + 4; {no decimal point given; defDecPt is taken}
             toolFormat.decPt := defDecPt;
             if rightnum > 0 then x := rightnum + 1    {assumed a missing decPt}
                             else x := length(str) + 1;
          end;

   if rightmost > 0 then begin
      x := rightmost;           {take rightmost separator}
      errnum := errnum + 2;     {there was a non-unique decimal point; the rightmost separator is taken}
      toolFormat.decPt := str[x];
   end;


   { find thousand separator }

   found := false;
   y    := x - 1;
   while not found and (y > 0) do
      if (str[y] in [defTSep, defDecPt, '''', chr(blankTsep), chr(nonBreakSpace)]) and
         (y > 1) and (str[y - 1] in ['0'..'9']) then begin
         toolFormat.tSep := str[y];
         found := true
      end
      else y := y - 1;

   if (y = 0) or (toolFormat.tSep = toolFormat.decPt) then begin

(*$IFC DEBUGVERSION *)
      writeln('no thousand separator found left of decPt');
(*$ENDC *)

      {no thousand separator was given or is equal to the decimal point character.
       default is set to be different from the decimal Point character
      }
      errnum := errnum + 1;
      if toolFormat.decPt = defDecPt then toolFormat.tSep := defTSep
      else toolFormat.tSep := defDecPt
   end;



   { find number of decimal places right of decimal point and
     delete decimal point, number digits and thousand separators }

   found := true;
   y    := 0;
   if (str[x] = toolFormat.decPt) and (length(str) >= x) then DELETE(str,x,1);  {delete the decimal point}

   while found and (length(str) >= x) do
      if str[x] in ['0'..'9'] then begin
         DELETE(str,x,1);
         y := y + 1
      end
      else if (str[x] = toolFormat.tSep) and (length(str) > x) and (str[x + 1] in ['0'..'9']) then
              DELETE(str,x,1)
      else found := false;



   { find all number digits and thousand separators left of decimal point
     and delete them }

   found := true;
   x     := x - 1;
   while found and (x > 0) do
      if str[x] in ['0'..'9'] then begin
         DELETE(str, x, 1);
         x := x - 1;
      end
      else if (str[x] = toolFormat.tSep) and (x > 1) and (str[x - 1] in ['0'..'9']) then begin
              DELETE(str,x,1);
              x := x - 1
           end
      else found := false;


(*$IFC DEBUGVERSION *)
   writeln('remaining str (without number digits) is: ', str);
(*$ENDC *)


   { find currency symbol and its position }

   if ( ((x = 0) or (x = length(str))) { everything else should be scanned by now }
        and (length(str) <= 3)         { max. characters for currency symbol }
        and (length(str) >= 1)        )
   then
       begin
          if tmpErrNum = errnum then errnum := 0;
          toolFormat.dSign := str;     { how is dSign going to be adjusted ???????????????? }
          if x > 0 then  toolFormat.dSignPos := true   { currency symbol in front of number }
                   else  toolFormat.dSignPos := false;
(*$IFC DEBUGVERSION *)
          writeln('currency symbol: ',toolFormat.dSign);
          if toolFormat.dSignPos then writeln('currency symbol in front of number')
                      else writeln('currency symbol behind number');
          writeln('number&currency string is parsed');
(*$ENDC *)
       end
   else
       begin
(*$IFC DEBUGVERSION *)
          writeln('default currency symbol: $');
          writeln('unrecognizable characters were encountered and/or key characters are missing');
(*$ENDC *)
          toolFormat.dSign := defDSign;     {default currency symbol }
          toolFormat.dSignPos := true;      {default in front of number}
          errnum := errnum + 8; {unrecognizable characters in number/curr. string}
       end;

(*$IFC DEBUGVERSION *)
   writeln('errnum:', errnum);
   writeln('decPt: ', toolFormat.decPt);
   writeln('tSep : ', toolFormat.tSep);
   writeln('dSign: ', toolFormat.dSign);
   writeln('dSignPos:', toolFormat.dSignPos);
(*$ENDC *)

      if errnum = 0 then
          begin
               messageText := CONCAT('Number/currency format ''',
               tmpstr, ''' is okay');
          end
        else
          begin
               messageText := CONCAT('Sorry, bad number/currency format ''',
               tmpstr, '''');
          end;

   END;  {CASE alertnumber = 1}

1002:
   BEGIN {CASE alertnumber = 2; useSColon in function argument lists}
      found := false;
      if (str[1] = 'y') or (str[1] = 'Y') or (str[1] = ';')
                      then
                         begin
                            found := true;
                            errnum := 0;
                            toolFormat.useSColon := true;
                            messagetext := 'SemiColon will be used';
                         end;
      if (str[1] = 'n') or (str[1] = 'N')
                      then
                         begin
                            found := true;
                            toolFormat.useSColon := false;
                            errnum := 0;
                            messagetext := 'SemiColon will not be used';
                         end;
      if not found then  begin
                            errnum := errnum + 17;
                            messagetext := 'Sorry, make useSemiColon y or n !';
                         end;
   END;

1003:
   BEGIN {CASE alertnumber = 3; date order}
      str123 := COPY(str,1,3);
      str4   := str[4];

      if (str4 in ['.', '/', '¥', '-', chr(blankTSep), chr(nonBreakSpace)]) and
         ( (str123 = 'dmy') or (str123 = 'dym') or (str123 = 'mdy') or
           (str123 = 'myd') or (str123 = 'ymd') or (str123 = 'ydm')
         )
      then
         begin
         toolFormat.dateFormat := COPY(str,1,4);
         errnum := 0;
         messageText := CONCAT('Date order format ''',toolFormat.dateFormat, ''' is okay');
         end
      else
         begin
             errnum := errnum + 18;
             toolFormat.dateFormat := defDateFormat;
             messageText := CONCAT('Sorry, bad date order format ''',str, '''');
         end;
   END; {CASE alertnumber = 1003; date order}

1004:
   BEGIN {CASE alertnumber = 1004; credit/debit signs}
      if length(str) >= 2 then
                 begin
                      toolFormat.dollarBracket := COPY(str,1,2);
                      errnum := 0;
                      messageText := CONCAT(
                       'Credit/debit characters ''', toolFormat.dollarBracket, ''' are okay');
                 end
            else begin
                   errnum := errnum + 19;
                   toolFormat.dollarBracket := defDollarBracket;
                   messageText := CONCAT(
                              'Sorry, bad credit/debit characters  ''', str, '''');
                 end;
   END;  {CASE alertnumber = 1004; credit/debit signs}

OTHERWISE begin
               EXIT(checkFormat);
          end;

END; {CASE alertnumber}

END; { procedure checkFormat }


(*$S initial *)
procedure InitUTProcs(PCellValue : procPtr);
begin
   InitLCutProcs                        {init procedure pointers for LCut}
     (@CellBlank,
      @CellInfo,
      PCellValue,
      @FinalDataSnip,
      @GetSnipId,
      @RgInScrap,
      @SnipWidth,
      @SwitchTable
     )
end;


(***************************************.*******.************************************
   NewInitFexec - initialize the entire application specific but non-folder dependent
                  variables.  These are routines & variables that get initialzed once
                  during the life of the LC/BG process.  Any folder dependent
                  initialization is done later when a document is opened.
*)
(*$S initial *)
procedure NewInitFexec{var initStatus : integer};
var x           : integer;
    app         : appKind;
    toolName    : str40;
    dSegName    : PathName;
    LCHeapAddr  : longint;
    LCDiskSize  : longint;
    LCMemSize   : longint;
    THRefNum    : integer;                      {ref number for 'the heap'}
    aRefNum     : integer;
    tPnlDh      : integer;
    appleWidth  : integer;                      {width of the apple character}
    pnlLabel    : str40;
    triples     : Tstr;
    info_rec    : dsInfoRec;                    {segment info for data segment}
    Proc_info   : ProcInfoRec;
    menufile    : text;                         {File for all menus}
    tempFntId   : TLfntId;
    tempFInfo   : FontInfo;
    sErrNum     : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if tracing then LCtraceMess(79);

   PrintEvents     := false;                {Init all trace flags}
   tracing         := false;
   traceMMgr       := false;
   traceLCexec     := false;
(*$IFC not teProduction *)
   fldtest         := false;
   traceFMgr       := false;
   traceTMgr       := false;
   traceXTMgr      := false;
   traceSMgr       := false;
   fTstStd         := false;
   fTstHz          := false;
(*$ENDC *)
   traceLcPr       := false;
   traceCoMgr      := false;
   traceFormMgr    := false;
   traceLCSMgr     := false;
   traceDi         := false;
   NMIAllowed      := false;
   traceWouldAlert := false;
   UnSusOld        := false ;                  { init backward-compatibility flag }
   for x := 1 to 10 do Switches[x] := false;   { init debugging switches }
{$ENDC }

   InitProcInfo                         {Init procedure pointers for TM}
     (@CellInfo,
      @CellRun,
      @CellValue,
      @FoldedFormula,
      @GetSnipId,
      @mmBreakSnip,
      @mmMapSnip,
      @SetSnipWidth,
      @SnipLT,
      @SnipWidth,
{$IFC fDebug }
      @FatalError
{$ELSEC }
      nil
{$ENDC }
     );

   InitUTProcs(@CellValue);

   initStatus  := ok;                   {Init some state information}
   QuitRequest := false;
   calcPending := false;
   ProcsInited := false;
   dumpToScrap := false;
   finishOpen  := false;
   throwAwayDoc:= false;
   preserving  := false;
   procsDying  := false;
   NumDocsOpen := 0;
   docName     := '';
   Folder      := nil;

   Sched_Class(sErrNum, false);
   Info_Process(initStatus, My_ID, Proc_Info);
   Sched_Class(sErrNum, true);

   if initstatus <> 0 then begin
{$IFC fDebug }
      writeln(chr(7),'Init_Process - error: ',initstatus:1);
{$ENDC }
      exit(NewInitFexec)
   end;
   x := 1;
   repeat
      x := x + 1
   until Proc_info.ProgPathName[x] = '-';
   Proc_info.ProgPathName := copy(Proc_info.ProgPathName, 1, x);

   if g.LCflag then begin
      toolName  := '{T3}';
      LCMemSize := LCHeapMax
   end
   else begin
           toolName  := '{T2}';
           LCMemSize := BGHeapMax
        end;

(*$IFC fDebug *)
   if not relflag then begin
      write('Memory size for the ''theHeap'' (enter ',LCmemSize:1,'): ');
      if debug[5] or skipFlag then writeln
      else begin
              readln(LCMemSize);
              if LCmemSize <= 0 then begin
                 if g.LCflag then LCMemSize := LCHeapMax
                 else LCMemSize := BGHeapMax;
              end
           end
   end;
(*$ENDC *)

   if abort then begin
      initStatus := userStopped;
      exit(NewInitFexec)
   end;

   {try to allocate 'theHeap' on the tool disk.  If that fails, try to allocate on the boot disk}
   dSegName   := concat(Proc_Info.ProgPathName, toolName, SegExtension);
   LCDiskSize := LCMemSize;
   Sched_Class(sErrNum, false);
   Make_DataSeg(initStatus, dSegName, LCMemSize, LCDiskSize, THRefNum, LCheapAddr, lcLDSN, ds_private);
   Sched_Class(sErrNum, true);

   if initStatus <> 0 then begin
      dSegName := concat(toolName, SegExtension);

      Sched_Class(sErrNum, false);
      Make_DataSeg(initStatus, dSegName, LCMemSize, LCDiskSize, THRefNum, LCheapAddr, lcLDSN, ds_private);
      Sched_Class(sErrNum, true);

   end;

   Sched_Class(sErrNum, false);
   if initStatus = 0 then Info_DataSeg(initStatus, THRefNum, info_rec);
   Sched_Class(sErrNum, true);

   if initStatus <> 0 then begin
{$IFC fDebug }
      writeln(chr(7),'Cannot create a ',LCMemSize:1,
              ' byte data segment in NewInitfexec: ',dsegName,'.  Error: ',initStatus:1);
{$ENDC }
      exit(NewInitFexec)
   end;
   InitHeap(pointer(LCheapAddr), pointer(LCheapAddr + info_rec.mem_size), @OutOfHeapSpace);
(*$IFC fDebug *)
   if skipflag then if rodstuff(21) then if rodstuff(22) then ;
(*$ENDC *)
   resultRgnH  := newRgn;                {Init the regions}


   doInitmp(theHeap, concat(Proc_Info.ProgPathName, toolName), @FailedAlert, alertVerNum, initStatus);
(*$IFC fDebug *)
   myMenus[menuTrace].DrawProc   := @TraceDrawProc;
   myMenus[menuTrace].menuHeight := 17 * 15;
   myMenus[menuTrace].menuWidth  := 8 * 16;
   myMenus[MenuRod].DrawProc     := @RodDrawProc;
   myMenus[MenuRod].menuHeight   := 22 * 15;
   myMenus[MenuRod].menuWidth    := 8 * 25;
(*$ENDC *)

   getWordInfo(@triples);

   for x := 1001 to 1004 do begin               {reading formatting information from alerts}
      checkFormat(initStatus, x, dSegName);
(*$IFC DEBUGVERSION *)
      write ('while reading alert file: ',dsegName);
      if initStatus <> 0 then
         write(':  Error #',initStatus:1);
      writeln;
(*$ENDC *)
   end;
   if initStatus <> 0 then begin
(*$IFC DEBUGVERSION *)
      writeln('Error #',initStatus:1,' while doing LcPrInit');
(*$ENDC *)
      initStatus := OpenErr;
      exit(NewInitFexec)
   end;

   LcPrInit;                            {Init lc printing}

   if abort then begin
      initStatus := userStopped;
      exit(NewInitFexec)
   end;

   with sysFntId do begin               {Init the system font & table font}
      Fam      := SysText;
      seteface := [];
      dev      := devScreen
   end;

   with TblFntId do begin
      Fam      := SysText;      { forces computation in SetTblFont at first real call, in [ }
      seteface := [];
      dev      := devScreen
   end;

   with tempFntId do begin
      Fam      := SmallFont;
      seteface := [];
      dev      := devScreen
   end;

  { Get the system font information.}
   if not FMFontMetrics(sysFntId, sysFInfo, initStatus) then begin
{$IFC fDebug}
      PrintMess(38);
{$ENDC }
      exit(NewInitFexec)
   end;

   { Get the system font information.}
   if not FMFontMetrics(tempFntId, tempFInfo, initStatus) then begin
{$IFC fDebug}
      PrintMess(38);
{$ENDC }
      exit(NewInitFexec)
   end;

   TextFont(WMfont);
   TextFace([]);
   appleWidth := charWidth(chr(chapple));
   TextFont(SysText);                   {Init panel displacements}
   TextFace([Bold]);
   tPnlDh    := StringWidth(' ');
   GetItem(myMenus[MenuStat], CellsItem, @pnlLabel);
   tCoDh     := StringWidth(pnlLabel) - CharWidth('|') + appleWidth + tPnlDh;
   GetItem(myMenus[MenuStat], FormItem, @pnlLabel);
   tFormDh   := StringWidth(pnlLabel) - CharWidth('|') + appleWidth + tPnlDh;
   GetItem(myMenus[MenuStat], ValDatePart, @pnlLabel);
   tWideDh   := StringWidth(pnlLabel) + tPnlDh;
   twideStr  := pnlLabel;
   TextFont(LargeFont);
   TextFace([]);
   coDH      := tCoDh + 1 + StringWidth('MM255:MM255 ');

   {# chrs allowed in Wide-Angle View
   maxLenWav := (720 - dhSBox - (coDh + 2 + twideDH)) div tempFInfo.widMax;
   }
   maxLenWav := 80;

   SetPort(DeskPort);
   FEinit(theHeap, @triples, initStatus);           {Init Field Editor}
   if initStatus <> 0 then begin
{$IFC fDebug }
      writeln(chr(7),'FEinit - error: ',initstatus:1);
{$ENDC }
      exit(NewInitFexec)
   end;

   InitWmlCrs(initStatus);              {Init cursors and scroll boxes}
   if initStatus <> 0 then begin
{$IFC fDebug }
      writeln(chr(7),'InitWmlCrs - error: ',initstatus:1);
{$ENDC }
      exit(NewInitFexec)
   end;

   InitPnls(initStatus);                {Init the panel numbers}
   if initStatus <> 0 then begin
{$IFC fDebug }
      PrintMess(21);
{$ENDC }
      exit(NewInitFexec)
   end;

   coPnl    := cCoPnl;          allocPnl(coPnl);
   formPnl  := cFormPnl;        allocPnl(FormPnl);
   BGPnl    := cBGPnl;          allocPnl(BGPnl);
   tCoPnl   := cTCoPnl;         allocPnl(tCoPnl);
   tWidePnl := ctWidePnl;       allocPnl(tWidePnl);
   tFormPnl := ctFormPnl;       allocPnl(tFormPnl);
   StCoPnl  := cStCoPnl;        allocPnl(StCoPnl);
   ScoPnl   := cScoPnl;         allocPnl(ScoPnl);
   StblPnl  := cStblPnl;        allocPnl(StblPnl);


   if abort then begin
      initStatus := userStopped;
      exit(NewInitFexec)
   end;

                                        {Init the matrix manager}
   if g.LCFlag then app := aLisaCalc
   else begin
           app := aBusGraphics;
           iInitBGstorage(BGProcInfo.InitBGstorage)
        end;
   InitMatMgr(initStatus, app);
   if initStatus <> ok then begin
(*$IFC fDebug *)
      writeln('InitMatMgr - error: ',initstatus:1);
(*$ENDC *)
      exit(NewInitFexec)
   end;
{$IFC fDebug }
   if rodflag then begin
      if rodstuff(-2) then
   end;
{$ENDC }

   tmInit;                              {Init Table Manager - in libte/TM4}
   InitSelMgr(true, maxLenWav, 0, 0);   {Init Selection Manager}
   initDi;                              {Init dialog box manager - in aplc/DiMgr - UNIT COmgr}
   initDiFlds;                          {Init dialog box fields - in aplc/AppDiBox - UNIT COmgr}
   initCo;                              {Init coordinate display fields}
   if g.LCflag then initForm;           {Init formula display fields}

   initMspecs;                          {Init the movement keys}
   SetUpSBars;                          {Init scroll bar information}
end;


{$IFC fDebug }
(*$S debug2 *)
procedure dumpMMstatus(status : integer; var loadName : PathName);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   case status of
      OutOfMem : writeln('Ran out of memory while opening the file: ',loadname);
      MakeErr  : writeln('Could not ''make'' the file: ',loadName);
      OpenErr  : writeln('Could not ''open'' the file: ',loadName);
      PWordErr : writeln('Password Error');
      DSpaceErr: writeln('Out of Disk Space Error');
      NewerFile: writeln('Incountered a newer file');
      BadFile  : writeln('Incountered a file that could not be read');
      FileErr  : writeln('Had an error while reading the file');
      userStopped : writeln('The user has stopped the operation');
      ok       : ;
      otherwise  writeln('unknown error from OpenMatrix: ',status:1)
   end
end;
{$ENDC }


(***************************************.*******.************************************
   findSDoc - Takes the current DOCNAME and determines the type of document associated
              with it.  The document may be suspended (has an SFextension), closed
              (has no extension) or does not exist.  The value returned by "findSDoc"
              tells wheter the document found was suspended.  The name of the file
              actually found will be passed back through LOADNAME.  The attributes for
              the document, FILEATTR will be valid if LOADNAME is not null.  The
              IGNORESUSPEND boolean makes the routine skip the check for the
              suspended document.
*)
(*$S OpenClose *)
function findSDoc(ignoreSuspend : boolean; var loadName : PathName; var fileAttr : FS_Info) : boolean;
var errNum : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   loadName := concat(docName, SFextension);
   LookUp(errNum, loadName, FileAttr);         {Check for a suspend File}
   if ignoreSuspend or (errNum <> 0) then begin
      loadName := docName;
      Lookup(errNum, loadName, FileAttr);      {Check for a normal closed file}
      if errNum <> 0  then loadName := '';     {File does not exist - must be a new file}
      findSDoc := false;
   end
   else findSDoc := true
end;



(***************************************.*******.************************************
   InitDisplay - Put up the LisaCalc or Business Graphics folder once the windowPtr
                 has been received from the Filer.  All the initialization that
                 is folder dependent is handled here.
*)
(*$S OpenClose *)
procedure InitDisplay(Fldr : grafptr; var filerReason : FReason; checkAbort, ignoreSusPend : boolean;
                      var susFileFound : boolean);
var tempPt     : point;
    status     : integer;
    errNum     : integer;
    fileOp     : FIOkind;
    FileAttr   : Fs_Info;
    fileName   : PathName;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   getkeys(myOwnKeys);
   if 118 in myOwnKeys then skipFlag := true;
(*$ENDC *)

   (**********************************************************************************
      Cleanup any left over information from the last process, if any.
   **********************************************************************************)
   ProcsInited := false;
   pendingNote := ok;

   (**********************************************************************************
      Initialize the world to its default state in case there is not matrix to be read.
      If there is a matrix, these values will be re-initialized laster during the
      "OpenMatrix" call.
   **********************************************************************************)
   g.TabFontMode := FMPrinter;          {set default table-font-mode}
   g.curPrFont   := FT12;               {default printer font choice}
   g.ModernFont  := true;
   setTblFont(p12Tile);                 {Init a table font}
   g.autoCalc    := true;               {start off in auto-calc mode}
   setDiPnl;                            {Init dialog panel height to 0 - in aplc/DiMgr - UNIT COmgr}

   {Set event-processing variables and parameters}
   c.Check2or3Click := false;           {four flags for deciphering mouse actions}
   c.FndTriple      := false;
   c.FndDouble      := false;
   c.mouseHasMoved  := false;
   calcPending      := false;
   g.ActivePnl      := nullPnl;         {the last panel with a selection in it}
   g.lastActPnl     := nullPnl;         {the previous g.ActivePnl}
   g.pnlWithChg     := nullPnl;         {the last panel with a successful edit in it}
   setUndo(uNothing, nullPnl);

   (**********************************************************************************
      Initialize the folder specific panels to either their default state or from
      information passed from the filer.
   **********************************************************************************)
   SetPort(ScrapFolder);                {Init the scrap panel from Filer info}
   SetPt(tempPt, 0, 0);
   with thePort^.portrect do
      SetUpPnl(cScrapPnl, ScrapFolder, right-left, bottom-top, tempPt);
   sizeScrap;                           {Init scrap sub-panels - in aplc/LCexecsubs - UNIT LCfexec}

   Folder := Fldr;                      {Init the folder panel from Filer info}
   SetPort(Folder);
   SetPt(tempPt, 0, 0);
   with thePort^ do begin
      ClipRect(portrect);
      with portrect do
         SetUpPnl(FolderPnl, Folder, right-left, bottom-top, tempPt)
   end;

   {Set up timeouts and nbrhoods.  For now, no timeout except what
   is necessary to find double and triple clicks}
   g.curTimeout := -1;
   SetRect(nullNbrhood, 0, 0, 0, 0);
   GetPnlRect(FolderPnl, dfltNbrhood);
   g.curNbrhood := dfltNbrhood;


   SetUpPnl(DialogPnl, DialogFolder, 720, 0, tempPt);

   setAppPnls;                          {Init panel structures}


   if g.BGflag then Begin

      { tells BG1.0/InitBGPnl (called by initAppMgrs) NOT to allocate any fields.
        NOTE: BGFld = Pointer(-1) implies alloc all except the fields,
              BGFld = Pointer( 1) implies alloc the fields only,
              BGFld = Nil         implies alloc nothing since it's all been done already }

      BGFld := Pointer(-1);
      initAppMgrs;        {Init panel managers for BG - LC's is done
                           later because formula panel can't be done yet}

      { tells BG1.0/InitBGPnl to alloc fields. If BG1.0/FXBGStuff is called to read in a file, it will
        create the fields and set BGFld back to Nil. This ensures the fields only get allocated once }
      BGFld := Pointer(1);
   end;


   PrPrfDefault(curConfig);          { set up the default pref record }

   fileName := concat(docName, Textension);     {remove the old temporary file - if it exists}
   Kill_Secure(errNum, fileName, thePassword);

   (**********************************************************************************
      Open the matrix by reading the document.  If the document already exists, some
      of the previously initialized values will be re-initialized with information
      from the document.  If the document was suspended then some of the suspended
      state will be preserved.  LC/BG makes no attempt to recover bad data that might be
      in the file, therefore if any problem occurs while opening the matrix, the open
      attempt will be stopped and the Filer informed that the document has not been
      opened.  If the open suceeds, the document is displayed (it is not necessary
      to wait for the activate to do this).
   **********************************************************************************)
   preserving   := FindSDoc(ignoreSusPend, fileName, FileAttr);
   susFileFound := preserving;
   if preserving then fileOp := mmUnSuspend
   else fileOp := mmOpen;

(*$IFC DEBUGVERSION *)
   if skipFlag then writeln('Loading file: ',fileName,' len=',length(fileName):1);
   if traceOC then
      if preserving then writeln('InitDisplay, Preserving')
      else writeln('InitDisplay, not Preserving');
(*$ENDC *)

   OpenMatrix(@fileName, true, checkAbort, fileOp, TblPars, status);
   if checkAbort then
      if abort then status := userStopped;

   case status of
      userStopped : filerReason := aUserAbort;
      OutOfMem    : filerReason := noMemory;
      DSpaceErr   : filerReason := noDiskSpace;
      OpenErr     : filerReason := cantRead;
      PWordErr    : filerReason := wrongPassword;
      FormatsBad,
      OldFileErr,
      ok          : begin
                       case status of
                          OldFileErr : (*$IFC fDebug *) pendingNote := 117  (*$ENDC *);
                          FormatsBad : pendingNote := 160
                       end;
                       filerReason := okButNoMore
                    end;
      NewerFile   : filerReason := newerDoc;
      otherwise     filerReason := badData
   end;

   finishOpen   := (filerReason = okButNoMore);
   throwAwayDoc := false;

   if finishOpen then begin
      TakeWindow(WMEvent.who);
      ValidRect(Folder^.portrect);
      ShrinkSegMemory(mxHz, false, errNum);
{$IFC fDebug}
      if errNum <> 0 then writeln('ShrinkSegMemory: mxHz - error: ',errNum:1);
{$ENDC }
      ShrinkSegMemory(theHeap, false, errNum);
{$IFC fDebug}
      if errNum <> 0 then writeln('ShrinkSegMemory: theHeap - error: ',errNum:1);
{$ENDC }
   end
   else begin
           Folder := nil;
           Close_dataSeg(errNum, mmRefNum)
        end;

(*$IFC DEBUGVERSION *)
   if not FinishOpen then dumpMMstatus(status, fileName);
(*$ENDC *)
end;


(*$S OpenClose *)
procedure FinishInitDisplay;
var tempRg     : range;
    errNum     : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   finishOpen   := false;
   throwAwayDoc := false;

   SetPnlPort(folderPnl);
   EraseRect(Folder^.portrect);

   {Draw panel dividing lines within folder and fill in titles in title panels}
   if g.activePnl = nullPnl  then
      GetItem(myMenus[MenuStat], ValueItem, @tWideStr); {if from suspend, current rep is valid
                                                            if active panel not forced to null }
   dividPnls;

   lcRedoBreaks;
   tmResize;

   if {$IFC DEBUGVERSION} unSusOld or {$ENDC} not Preserving then begin
      g.CurRange.rKind := aNullRg;
      FixRange(g.curRange);
      setCr(g.curRange);              {change current range & fill-in status panels}
      initAppMgrs;                    {Init panel managers for LC.  initAppMgrs calls initBGpnl which
                                       keys off BGFld to determine whether to alloc fields or not}

      EraseWav;
      chgStatPnl(false)

   end   { special processing for an open }
   else begin { a true unSuspend }
           SetRunFormat(coFldH, coFSH, tblFntId.Fam, setFont, errNum);
           emptyCoDisp;
           reDrawCo;     {gets rectangles set up right}
           if g.LCFlag then SetRunFormat(formFldH, formFSH, tblFntId.Fam, setFont, errNum);
           SetCr(g.curRange);
           if g.activePnl = formPnl then begin { suspended with formula panel active }
{$ifc DEBUGVERSION}
              if traceOC then writeln('restoring suspended formPnl editing state');
{$endc }
              { restore formula-panel editing state }
              shoNewCo(g.curRange);         { fill coord pnl as per curRange     }
              editForm := true ;            { formula editing taking place       }
              reDrawForm                    { fill formula pnl as per saved info }
           end
           else begin{ active panel is not formula panel }
                   if g.LCflag then begin
                      emptyFormDisp;
                      reDrawForm         { gets rects right }
                   end;
                   chgStatPnl(false)  { put up coords, formula, and wide-title as per g.curRange }
                end;

          if g.curRange.rKind = a1CellRg then reDrawSel(true)
          else EraseWav;         { in file TMSProcs3 }
       end;
   teReInit(not Preserving);             {reInit the Table Editor and put up a table}

   {Show the first graph and setup scroll bars}
   if g.BGFlag then begin
      BGSBInit;                          {Init BG scroll bars - in aplc/LCScroll - UNIT LCfexec}
      iBGSetGrfx(BGProcInfo.BGSetGrfx);

      setRg(tempRg, aWTBoxRg, mInfSnip, mInfSnip, pInfSnip, pInfSnip);
      fxRgChged(tempRg);
      fxNewRgImg;
   end
   else LCSBInit;                       {Init LC scroll bars - in aplc/LCScroll - UNIT LCfexec}
   ClearScroll;

   docDirty    := preserving or (pendingNote = 117);
   ProcsInited := true;
   procsDying  := false;
   ValidRect(Folder^.portrect)

{$IFC fDebug}
   ; if not traceOC then offTrace;       {Clear all trace flags and un-shade the items in the trace menu.}
{$ENDC }

end;


{$IFC fDebug }
(*$S OpenClose *)
procedure dumpFParams(filerParams : FilerExt);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   write('Received Filer event: ');
   case filerParams.theFlrOp of
      fcTerminate : writeln('fcTerminate');
      fcResume    : writeln('fcResume: ',filerParams.thePrefix);
      fcNone      : writeln('fcNone: ',filerParams.thePrefix);
      fcPut       : writeln('fcPut: ',filerParams.thePrefix);
      fcCopy      : writeln('fcCopy: ',filerParams.thePrefix);
      fcClose     : writeln('fcClose: to docName: ',docName);
      fcShred     : writeln('fcShred: to docName: ',docName);
      fcSuspend   : writeln('fcSuspend: to docName: ',docName);
      otherwise     writeln(chr(7),'Unknown filer event: ',ord(filerParams.theFlrOp))
  end
end;
{$ENDC }


(*$S OpenClose *)
procedure CloseFile
  (var newDocName  : PathName;
   closedDoc       : boolean;
   DoNotSuspend    : boolean;
   var fileOp      : FIOkind;
   var filerReason : FReason;
   var filerReply  : FReply;
   checkAbort      : boolean;
   closeSegment    : boolean
  );
var filerError  : integer;
    errNum      : integer;
    status      : integer;
    x           : integer;
    tempName    : PathName;
    saveName    : PathName;
    killName    : PathName;
    chgName     : e_name;
    oldFileAttr : FS_info;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   setUndo(uNothing, nullPnl);
   filerReason := internalError;
   filerReply  := docNotClosed;

   if not closedDoc then begin
      if curDiHeight > 0 then removeDiBox  ;            {++appDiBox++   get rid of dialogue box... }
      if g.ActivePnl <> formPnl then endPnlSel          {++LCSmgr++    for now, clear out co/form sel }
   end;

   ShrinkSegMemory(mxHz, false, status);
{$IFC fDebug}
   if status <> 0 then writeln('ShrinkSegMemory: mxHz - error: ',status:1);
{$ENDC }
   ShrinkSegMemory(theHeap, false, status);
{$IFC fDebug}
   if status <> 0 then writeln('ShrinkSegMemory: theHeap - error: ',status:1);
{$ENDC }

   LookUp(errNum, docName, oldFileAttr);                        {get attributes for the old file}
   if errNum <> 0 then oldFileAttr.DTC := -1;                  {attributes does not exist}

   repeat
      closedDoc := not closedDoc;
      if closedDoc then begin
         saveName := docName;
         fileOp   := mmSuspend;
         docDirty := true
      end
      else begin
              saveName := newDocName;
              fileOp   := mmClose;
              killname := concat(saveName, SFextension);        {kill off the suspend file - if it exists}
              if not throwAwayDoc then Kill_Secure(errNum, killName, thePassWord);
{$IFC fDebug }
              case errNum of
                 0,
                 894,
                 -1293 : ;
                 otherwise writeln('kill off the suspend file: UnKnown Kill_Secure error: ',errNum:1)
              end;
{$ENDC }
           end;

      tempName := concat(saveName, Textension);

      { save the file under a temporary name }
      if docDirty then CloseMatrix(@tempName, fileOp, oldFileAttr.DTC, checkAbort, status)
      else begin
              matState := mmClose;
              status   := ok
           end;

{$IFC fDebug }
      if debug[5] or skipFlag then begin
         if closedDoc then write('suspending')
         else write('closing');
         writeln(' to: ',tempName,'  docDirty: ',docDirty,'  throwAway: ',throwAwayDoc,'  status: ',status:1)
      end;
{$ENDC }

      case status of
         userStopped
                 : begin
                      filerReason := aUserAbort;
                      closedDoc   := true
                   end;
         OpenErr : filerReason := cantWrite;
         MakeErr : filerReason := noDiskSpace;
         PWordErr: filerReason := wrongPassword;
         ReSizeErr,
         ok      : begin
                      if docDirty then begin
                         {remove the old file}

                         if closedDoc then killName := concat(saveName, SFextension)
                         else killName := saveName;

                         Kill_Secure(errNum, killName, thePassword);     {remove the old file}
                         case errNum of
                            0,
                            894,
                            -1293 : begin
                                       {rename the temporary file to the new file name}
                                       x := 1;
                                       repeat
                                          x := x + 1
                                       until killName[x] = '-';
                                       chgName := copy(killName, x + 1, length(killName) - x);
                                       Rename_Secure(errNum, tempName, chgName, thePassword);
                                       if errNum = -1293 then errNum := 0
                                    end
                         end;
                         if errNum = 0 then begin
                            if not closedDoc then begin
                               {kill the suspended file if it exists - ignore normal errors}
                               tempName := concat(saveName, SFextension);
                               Kill_Secure(errNum, tempName, thePassword);
                               case errNum of
                                  0,
                                  894,
                                  -1293 : begin
                                             Flush(errNum, -1);
                                             errNum := 0
                                          end
                               end
                            end
                         end
                         else status := fileErr;
(*$IFC fDebug *)
                         if errNum <> 0 then writeln('OS error ',errNum:1,' while closing')
(*$ENDC *)
                      end;

                      case status of
                         ReSizeErr,
                         fileErr     : filerReason := noMemory;
                         otherwise     filerReason := allOk
                      end;
                      filerReply  := docClosd;
                      docDirty    := false;
                      closedDoc   := true;
                      if closeSegment or (filerReason = noMemory) then Close_dataSeg(errNum, mmRefNum)
                   end;
         otherwise begin
                      Kill_Secure(errNum, tempName, thePassword);
{$IFC fDebug }
                      if errNum <> 0 then
                         writeln('???: UnKnown Kill_Secure error: ',errNum:1);
{$ENDC }
                      case status of
                         DSpaceErr : begin
                                        filerReason := noDiskSpace;
                                        if not closedDoc then DoNotSuspend := true
                                     end;
                         FileErr   : filerReason := cantWrite;
                         otherwise   filerReason := internalError
                      end
                   end
      end
   until closedDoc or DoNotSuspend;
   case filerReason of
      allOk,
      noMemory : ;
      otherwise  Kill_Secure(errNum, tempName, thePassword);         {kill the temporary file if close did not succeed}
   end
end;


(*$S OpenClose *)
function  CreateMMseg(var newDocName : PathName) : boolean;
var mmSegName : PathName;
    status    : integer;
    x         : integer;
    sErrNum   : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   x := 1;
   repeat
      x := x + 1
   until NewDocName[x] = '-';
   mmSegName  := concat(copy(NewDocName, 1, x), SegExtension);
   if g.LCflag then mmMemSize := LChzLim
   else mmMemSize := BGhzLim;
   mmDiskSize := mmMemSize;

   Sched_Class(sErrNum, false);
   Make_DataSeg(status, mmSegName, mmMemSize, mmDiskSize, mmRefNum, mmHeapAddr, mmLDSN, ds_private);
   Sched_Class(sErrNum, true);

{$IFC fDebug }
   if status <> 0 then
      writeln(chr(7),'Cannot create a ',mmMemSize:1,' byte data segment: ',mmSegName,'.  Error: ',status:1);
   writeln('mmRefNum: ',mmRefNum:1);
{$ENDC }
   CreateMMseg := status = 0
end;


(*$S OpenClose *)
procedure doFilerEvent(* forceSuspend : boolean *);
var filerParams  : FilerExt;
    filerReason  : FReason;
    filerReply   : FReply;
    filerError   : integer;
    fileOp       : FIOkind;
    fileDocSize  : longint;
    susFileFound : boolean;
    when1String  : TParamAlert;
    when2String  : TParamAlert;
    titleTab     : str255;
    FileAttr     : FS_Info;
    loadName     : PathName;
    oDocDirty    : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if forceSuspend then begin
      filerParams.theFlrOp    := fcSuspend;
      filerParams.thePassWord := thePassword
   end
   else GetAddParams(filerError, WMEvent, filerParams);
(*$IFC DEBUGVERSION *)
   if (filerError <> 0) and not forceSuspend then writeln('FilerError from "GetAddParams": ',filerError:1);
   if debug[5] or skipFlag then dumpFParams(filerParams);
(*$ENDC *)
   case filerParams.theFlrOp of
      fcNone     : begin
                      filerReply  := docClosd;
                      filerReason := noMoreDocs
                   end;
      fcResume   : begin
                       if NumDocsOpen = 0 then begin
                          if CreateMMseg(filerParams.thePrefix) then begin
                             docName     := filerParams.thePrefix;
                             thePassword := filerParams.thePassWord;
                             InitDisplay(WMEvent.who, filerReason, true, false, susFileFound);
                             case filerReason of
                                cantRead,
                                badData : if susFileFound then begin
                                             if CreateMMseg(filerParams.thePrefix) then
                                                InitDisplay(WMEvent.who, filerReason, true, true, susFileFound);
                                             if filerReason = okButNoMore then begin
                                                susFileFound := findSDoc(false, loadName, FileAttr);
                                                doDTAlert(FileAttr.DTM, when1String);
                                                susFileFound := findSDoc(true, loadName, FileAttr);
                                                doDTAlert(FileAttr.DTM, when2String);
                                                GetFldrTitle(Folder, titleTab);
                                                ParamAlert(when1String, titleTab, when2String);
                                                pendingNote := -156
                                             end
                                          end
                             end
                          end
                          else filerReason := noDiskSpace
                       end
                       else filerReason := noMoreDocs;
                       if filerReason = okButNoMore then begin
                          NumDocsOpen := NumDocsOpen + 1;
                          if activeFolder = Folder then doActEvent(false)
                       end
                       else filerReply := docClosd
                    end;
      fcClose,
      fcSuspend,
      fcShred     : if NumDocsOpen > 0 then begin
{$ifc fDebug}
                       if (Switches[1] and (filerParms.theFlrOp = fcClose) ) then
                           filerParms.theFlrOp := fcSuspend;   {eases testing of suspend}
{$endc}
                       if (filerParams.theFlrOp <> fcClose) or (docConsistCheck(filerError) = ok) then begin
                          thePassword := filerParams.thePassWord;
                          CloseFile(docName, (filerParams.theFlrOp = fcClose), false,
                                    fileOp, filerReason, filerReply, false, true)
                       end
                       else begin
                               filerReason := dirtyDoc;
                               filerReply  := docNotClosed
                            end;
                       if filerParams.theFlrOp = fcShred then begin
                          filerReason := allOk;
                          filerReply  := docClosd;
                          Close_dataSeg(filerError, mmRefNum)
                       end;
                       if filerReason = noMemory then filerReason := allOk;
                       if filerReason = allOk then begin
                          NumDocsOpen := NumDocsOpen - 1;
                          Folder      := nil;
                          if g.BGflag then iFxBgFree(BGProcInfo.FxBgFree)
                       end
                    end
                    else begin
                            filerReason := internalError;
                            filerReply  := docNotClosed
                         end;
      fcPut,
      fcCopy      : begin
                       oDocDirty := docDirty;
                       docDirty  := true;
                       if docConsistCheck(filerError) = ok then begin
                          thePassword := filerParams.thePassWord;
                          CloseFile(filerParams.thePrefix, true, false, fileOp, filerReason, filerReply,
                                    false, (filerParams.theFlrOp = fcPut))
                       end
                       else begin
                               filerReason := dirtyDoc;
                               filerReply  := docNotClosed
                            end;

                       if (filerReason <> aUserAbort) and (filerReply = docClosd) then filerReply := docXfered
                       else filerReply := docNotXfered;

                       if (filerReason = allOk) and (fileOp = mmSuspend) then begin
(*$IFC fDebug *)
                          if debug[5] or skipFlag then
                             writeln('copydoc from: ',concat(docName, SFextension),
                                     ' to: ',concat(filerParams.thePreFix, SFextension),
                                     ' using ldsn: ',CopyDocLdsn:1);
(*$ENDC *)
                          CopyDoc(filerError, concat(docName, SFextension),
                                  concat(filerParams.thePreFix, SFextension), CopyDocLdsn,
                                  fcDocCopy, fileDocSize);
                          filerReply := docNotXfered;
                          case filerError of
                             fceCantWrite      : filerReason := cantWrite;
                             fceCantRead       : filerReason := cantRead;
                             fceOutOfDiskSpace : filerReason := noDiskSpace;
                             fceAborted        : filerReason := aUserAbort;
                             otherwise           filerReply  := docXfered
                          end
                       end;
                       if (filerReason = allOk) and (filerParams.theFlrOp = fcPut) then begin
                          NumDocsOpen := NumDocsOpen - 1;
                          Folder      := nil;
                          if g.BGflag then iFxBgFree(BGProcInfo.FxBgFree)
                       end
                       else begin
                               docDirty := oDocDirty;
                               matState := mmOpen
                            end
                    end;
      fcDfClose   : begin
                       filerReason := internalError;
                       filerReply  := dfNotClosed
                    end;
      fcTerminate : quitRequest := true;
   end;
   if (filerParams.theFlrOp <> fcTerminate) and (filerReason <> okButNoMore) and not forceSuspend then
      TellFiler(filerError, filerReply, filerReason, WMEvent.who)
(*$IFC fDebug *)
   ;if debug[5] or skipFlag then writeln('TellFiler: Error: ',filerError:1,'  Reply: ',ord(filerReply):1,
           '  Reason: ',ord(filerReason):1);

(*$ENDC *)
end;


(*$S initial *)
procedure initBGprocs
  (* AnotSelect     { parameters} : ProcPtr;
     BGDown         { parameters} : ProcPtr;
     BGExit         { parameters} : ProcPtr;
     BGGetThumb     { parameters} : ProcPtr;
     BGKey          { parameters} : ProcPtr;
     BGMenuCommand  { parameters} : ProcPtr;
     BGMove         { parameters} : ProcPtr;
     BGNewRgImg     { parameters} : ProcPtr;
     BGScroll       { parameters} : ProcPtr;
     BGSetGrfx      { parameters} : ProcPtr;
     BGTmOut        { parameters} : ProcPtr;
     BGUp           { parameters} : ProcPtr;
     DoBGAct        { parameters} : ProcPtr;
     DrawGraph      { parameters} : ProcPtr;
     EraseBG        { parameters} : ProcPtr;
     FxBGStuff      { parameters} : ProcPtr;
     InitBGPnl      { parameters} : ProcPtr;
     InitBGStorage  { parameters} : ProcPtr;
     TtlSelect      { parameters} : ProcPtr;
     BGReConfig     { parameters} : ProcPtr;
     BGrgChged      { parameters} : ProcPtr;
     FxBgFree       { parameters} : ProcPtr
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   BGProcInfo.AnotSelect     := AnotSelect;
   BGProcInfo.BGDown         := BGDown;
   BGProcInfo.BGExit         := BGExit;
   BGProcInfo.BGGetThumb     := BGGetThumb;
   BGProcInfo.BGKey          := BGKey;
   BGProcInfo.BGMenuCommand  := BGMenuCommand;
   BGProcInfo.BGMove         := BGMove;
   BGProcInfo.BGNewRgImg     := BGNewRgImg;
   BGProcInfo.BGScroll       := BGScroll;
   BGProcInfo.BGSetGrfx      := BGSetGrfx;
   BGProcInfo.BGTmOut        := BGTmOut;
   BGProcInfo.BGUp           := BGUp;
   BGProcInfo.DoBGAct        := DoBGAct;
   BGProcInfo.DrawGraph      := DrawGraph;
   BGProcInfo.EraseBG        := EraseBG;
   BGProcInfo.FxBGStuff      := FxBGStuff;
   BGProcInfo.InitBGPnl      := InitBGPnl;
   BGProcInfo.InitBGStorage  := InitBGStorage;
   BGProcInfo.TtlSelect      := TtlSelect;
   BGProcInfo.BGReConFig     := BGReConfig;
   BGProcInfo.BGrgChged      := BGrgChged;
   BGProcInfo.FxBgFree       := FxBgFree
end;


(*$S BGspecif *)
procedure lcBGSetGrfx;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   iBGSetGrfx(BGProcInfo.BGSetGrfx)
end;


(*$S BGspecif *)
procedure lcBGReConFig;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   iBGReConfig(BGProcInfo.BGReConfig)
end;


ÿ