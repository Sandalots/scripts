{$SETC ForOS := TRUE }
{$DECL IsIntrinsic}
{$SETC IsIntrinsic := TRUE}
{$DECL WithUObject}
{$SETC WithUObject := FALSE}

{$IFC NOT WithUObject}
    {$SETC LibraryVersion := 30 } { 10 = 1.0 libraries; 13 = 1.3 libraries; 10 = Pepsi, 30 = Spring, etc. }
{$ENDC}

unit MatMgr;                            {'Copyright 1983, 1984, Apple Computer Inc.'}
     intrinsic;

interface

(*$SETC UCutPaste := true *)

uses (*$U UnitStd.obj *)                UnitStd,
     (*$U UnitHz.obj *)                 UnitHz,
     (*$U Storage.obj *)                Storage,
     (*$U QuickDraw.obj *)              QuickDraw,
     (*$U Fontmgr.obj *)                FontMgr,
     (*$U dbenv.obj *)                  dbenv,
     (*$U FEdec.obj *)                  FEdec,
     (*$U fld.obj *)                    fieldedit,
     (*$U teenv.obj *)                  teenv,

     (*$U libos/syscall.obj *)          syscall,
     (*$U libos/Psyscall.obj *)         Psyscall,
     (*$U FPlib.obj *)                  FPlib,
     (*$U PMDecl *)                     PMDecl,
     (*$U PrStdInfo *)                  PrStdInfo,
     (*$U PrPublic.obj *)               PrPublic,
     (*$U wm.events.obj *)              events,
     (*$U scrap.obj *)                  scrap,
     (*$U WMLstd.obj *)                 WMLstd,
     (*$U WMlsb.obj *)                  WMlsb,
     (*$U tm.obj *)                     tm,
     (*$U international *)              International,
(*$IFC UCutPaste *)
     (*$U libut/uunivtext *)            uuniversaltext,
(*$ENDC *)
     (*$U aplc/mm/BGenv.obj *)          BGenv;


(*$SETC DEBUGVERSION  := false *)
(*$SETC TIMEVERSION   := false *)
(*$SETC RELone        := false *)
(*$SETC MMINITCODE    := true  and DEBUGVERSION *)
(*$SETC WRITELNS      := true  and DEBUGVERSION *)
(*$SETC DoTraceLC     := true *)
(*$SETC fTraceLC      := DoTraceLC and ftrace *)

const sCopyRight  = 'Copyright 1983, 1984, Apple Computer Inc.';
      LChzLim     = 16384;              {initial heap size in bytes for LC}
      BGhzLim     = 2048;               {initial heap size in bytes for BG}
      mmDate      = '3/29/84';          {matrix manager version date}
      dftColWidth = 8;                  {Default # of chrs in a column for show values mode}
      dftPColWidth= 12;                 {Default # of chrs in a column for print preview mode}
      dftSFwidth  = 12;                 {Default # of chrs in a column for show formulas}
      maxCoeffVars= 31;                 {maximum # of coefficient variables - 1}
      fRefCntMax  = 127;                {maximum # of references to a formula}
      cRefCntMax  = 127;                {maximum # of references to a cell}
      idMax       = 255;                {Max row or column number}
      maxColWidth = 719;                {maximum width of a column in pxels}
      maxDecPlaces= 23;                 {maximum # of decimal digits in a number}
      FPAccurracy = 15;                 {accurracy of the "double" floating point}
      maxPRcoords = 38;                 {max # of paste relative coordinates}
      pennyPlaces = 2;                  {# of digits to right of dec. pt}
      maxPDigits  = 9;                  {max # digits in pennt format}
      RecalcTimer = 30;                 {max # of secs in recalculation}
      evalMax     = 255;                {evaluate list size (bytes)}
      CalcStkMax  = 25;                 {calculation stack maximum}
      SemStkMax   = 50;                 {semantics stack maximum}
      PRStrLength = 230;                {max length of paste relative formula string}
      nilval      = -1;                 {integer nil value}
      minbyte     = -128;               {min/max byte range}
      maxbyte     = 127;
      minint      = -maxint;            {min integer value}

                  {character code definitions used in paste relative dialog box}
      blkChrCode  = 32;                 { ord(' ') }
      chkChrCode  = 64;                 { ord('@') }
      unChkChrCode= 46;                 { ord('.') }

                  {status codes - used especially by matMgr}
      ProtectErr  = 10020;              {a cell within the range is protected}
      RepeatErr   = 10021;              {cells are being replicated on the completion of a move}
      OpenErr     = 10022;              {error in opening resource}
      BlankLine   = 10023;              {a blank line was parsed}
      fileErr     = 10024;              {error while reading/writing resource}
      RecalcErr   = 10025;              {recalculation did not complete in finite amount of time}
      InsertErr   = 10026;              {the row or column could not be inserted}
      PasteErr    = 10027;              {the selection to be pasted does not agree with the range in scrap}
      BadFile     = 10028;              {the file to be read is more recent than the tool}
      MakeErr     = 10029;              {resource could not be made (i.e., make_file)}
      SizeErr     = 10030;              {data segments could not be sized down by OS}
      DSpaceErr   = 10031;              {out of disk space error}
      NoScrapErr  = 10032;              {scrap does not exist}
      PtrErr      = 10033;              {error while accessing data within the scrap}
      userStopped = 10034;              {user aborted the current operation}
      reSizeErr   = 10035;              {data segments could not be resized}
      OldFileErr  = 10036;              {the file read was created by an older version of the tool}
      InConsErr   = 10037;              {document is inconsistent (when is this used???) }
      FormatsBad  = 10038;              {formatting style of document different from the tool}
      NewerFile   = 10039;              {the file to be read is more recent than the tool}
      PWordErr    = 10040;              {wrong password supplied during docOpen}

type  stringType  = string[255];        {largest string possible}
      PtrStrType  = ^stringType;        {pointer tot he largest string possible - used to read any string}
      str80       = string[80];         {string of 80 characters}
      resultStr   = string[80];         {result string of 80 characters}
      THptrData   = ^ptrData;           {handle to an array of bytes}
      wordPtr     = ^integer;           {pointer to a word}
      longreal    = double;             {basic data type for numbers}

      Toh         = integer;            {hz + oh = h}
      TidRng      = 1..idMax;           {allowable range of row/col snipIds}
      idRange     = 0..idmax;           {zero based allowable range of row/col snipIds}
      vecInfo     = array [snipKind, TidRng] of integer;


      {WARNING: the order which the names within all these enumerated types should never change.  This
                will cause a problem when reading in an old file.  New names have to be added to the
                end of the type.
      }
                  {alias type - used in definition of variant records}
      alias       = (twdlDee, twdlDye, twdlDoe, twdlDue, twdlDum, twdlFee, twdlFye, twdlFoe, twdlFue, twdlFum,
                     twdlBee, twdlBye, twdlBoe, twdlBue, twdlBum, twdlRee, twdlRye, twdlRoe, twdlRue, twdlRum,
                     twdlSee, twdlSye, twdlSoe, twdlSue, twdlSum, twdlPee, twdlPye, twdlPoe, twdlPue, twdlPum,
                     twdlZee, twdlZye, twdlZoe, twdlZue, twdlZum, twdlMee, twdlMye, twdlMoe, twdlMue, twdlMum
                     );

      appKind     = (aLisaCalc, aBusGraphics);
      bitKind     = (BInvalid, B1Marked, B2Marked, BCircle, BNone, BInCopy, BCellSeen, BFormSeen, BFormAll);
      circleType  = (cNone, cMissing, cInvis, cError, cProtect, cDependent, cCircular);
      orderType   = (lCalc, lDependent, lCircular);
      shareKind   = (fSingle, fShared, fSeen, fAbsolute, fASeen);
      FIOkind     = (mmSusPend, mmUnSusPend, mmOpen, mmClose);
      mmMapKind   = (mmEstimate, mmMarkFirst, mmMarkSecond, mmClrFormErrors);
      calcState   = (mmCalcMan, mmCalcAuto, mmCalcNow);
      tblMode     = (tValues, tFormulas, tPreview);
      srcType     = (mmNull, mmBlank, mmScrap, mmUndo, mmCopy, mmRemove, mmClear, mmWipe, mmValue, mmRelative);
      IOtype      = (oDisk, oMem, oBuffer, oScrap);
      parseKind   = (PValue, PFormula, PCoordinate);
      undoType    = (uAttr, uCut, uCutUndo, uInsert, uInsertUndo, uCopy, uCopyUndo, uPaste, uPasteUndo, uNone,
                     uWidth, uClear, uClearUndo, uWipe, uWipeUndo, uBreak);
      cellKind    = (tNumber, tText, tDate, tParts, tBlank, tPage);

                  {FBufKind - this type is used in conjuction with the "FBufStuff" routine to state which type of
                   information is to be stored into the flush buffer (the scrap or undo buffer).  Each type has
                   the following meaning:

                      fSymbol      a text symbol
                      fWord        a 16-bit value
                      fShort       a single precision floating point number (32-bits)
                      fLong        a double precision floating point number (64-bits)
                      fPCel        a matrix manager's cell information
                      fRange       a range value
                      fTmBand      the band information from the table editor
                      fRawData     a block of data
                      fNull        no data - used for skipping
                  }
      FBufKind    = (fSymbol, fWord, fShort, fLong, fPCel, fRange, fRawData,            {9 choices - 4 bits}
                     fTmBand, fNull
                    );

                  {symbol - lexemes used during lex/parse phase.  There is a lexeme for each keyword or key
                   character tha`t the parser understands.  `JUNKop` is for things the parser does not
                   understand.  `BOUNDop` is the end-of-line marker.  Any changes in `symbol` should be
                   reflected in "initlex" and "initkeys" in the `token` & `words` arrays and maybe
                   the `sopChar` and `dopChar` arrays.  LEXLAST must be the last lexeme in the type.
                  }
      symbol      = (MULTIop, DIVop,     ADDop,    SUBop,     POWop,     MODop,   INTDIVop,  EQop,
                     NEop,    LTop,      LEop,     GEop,      GTop,      ORop,    ANDop,     NOTop,
                     SUMop,   MINop,     MAXop,    COUNTop,   AVGop,     NPVop,   LOOKop,    PIop,
                     ABSop,   INTop,     EXPop,    SQRTop,    LNop,      LOGop,   SINop,     ASINop,
                     COSop,   ACOSop,    TANop,    ATANop,    SQRop,     TODAYop, NAop,      ERRORop,
                     PENNYop, DROUNDop,  ROUNDop,  MINFop,    ALLop,     PINFop,  ELLIPSEop, COMMAop,
                     LINEop,  RNUMBERop, DOLLARop, CDOLLARop, PERCENTop, IDENTop, COORDop,   TRUEop,
                     FALSEop, LPARENop,  RPARENop, MONTHop,   DAYop,     YEARop,  WEEKop,    MONTHSop,
                     DAYSop,  YEARSop,   WEEKSop,  SEARCHop,  ANNUITYop, COMPop,  EDGEop,    DATEop,
                     JUNKop,  BOUNDop,   IFop,     CELLop,    RESULTop,  STDop,   INDEXop,   SIGNop,
                     IRRop,   COEFFop,   XRRop,    NFVop,     REGRESSop, LINSYSop,DETop,     HSINop,
                     HCOSop,  HTANop,    LEXLAST
                    );                                                                  {91 choices - 7 bits}


                  {letter classes - each character has an associated class (i.e., letter or digit).  `sop` and
                   `dop` stand for single character and double character operators.  `other` is special
                    characters that may precede a number (i.e., dollar sign).
                  }
      letterclass = (other, quote, letter, digit, sops, dops, junk, endfile);           {8 choices - 3 bits}

                  {cell format attributes type}
      attrType    = (aProtect, aAlign, aFormat, aNone);                                 {4 choices - 2 bits}

                  {cell alignments}
      alignKind   = (aLeft, aRight, aCenter, aStandard, aRepeating, aCont, aInVis);     {7 choices - 3 bits}

                  {cell protections}
      protKind    = (protNone, protRules, protAll);                                      {3 choices - 2 bits}

                  {cell types -   Each type has the following meaning:
                      sWord     a 16-bit quantity
                      sShort    a 32-bit quantity
                      sLong     a 64-bit quantity
                      sSymbol   a special symbol described by `cnSizeKind`
                  }
      cnSizeKind  = (sSymbol, sWord, sShort, sLong);                                    {4 choices - 2 bits}

                  {cell symbol}
      cnSymKind   = (syNone, syError, syNa, syText, syTrue, syFalse, syDate, syPinf,
                     syMinf, syDzero, syParts, syPenny);                                {12 choices-4 bits}

      cnNumKind   = (cNumber, cPenny, cOther);                  {3 choices-2 bits}

      TDecPlaces  = 0..31;
      pkFmtKind   = 0..63;                      {alias for 6-bit alFmtKind}
      moneySet    = set of (mDollar, mComma, mCents);

                  {don't rearrange the values of fmtKind; miscFmtKind is a subrange of it!}
      fmtKind     = (fDate, fInteger, fStandard, fDecimal, fScientific, fMoney);

      dFormat     = record                      {data formatting record}
                       decPt        : char;             {character to use for the decimal point seperator}
                       tSep         : char;             {character to use for the thousands seperator}
                       dSign        : string[3];        {string to use for dollar sign}
                       dSignPos     : boolean;          {where to position dollar sign; true is in front}
                       useSColon    : boolean;          {use semi-colon for comma seperator}
                       dateFormat   : string[4];        {format for date strings}
                       dollarBracket: string[2]         {characters to use for negative money bracket}
                    end;

      FontWidths  = record                      {font information record}
                       w    : integer;                  {width of a character in the font (bWidMax)}
                       h    : integer                   {height of a character in the font (ascent + descent + leading) }
                    end;

      ident       = record                      {lexeme identifier record (also used to represent coordinates) }
                       start  : idRange;                {index to start of lexeme (colId for a coordinate)}
                       length : idRange                 {length of the lexeme (rowId for a coordinate) }
                    end;

      pident      = packed record               {packed version of lexeme identifier (also used to represent coordinates) }
                       start  : idRange;                {index to start of lexeme (colId for a coordinate)}
                       length : idRange                 {length of the lexeme (rowId for a coordinate) }
                    end;

      rangeType   = record                      {range record - represents a coordinate range from code generator}
                       first  : pident;                 {top left coordinate}
                       second : pident                  {bottom right coordinate}
                    end;

      PdateType   = ^dateType;                  {date record - represents a date from the code generator}
      dateType    = record
                       year  : integer;                 {year - can be anything}
                       month : byte;                    {month - 1..12}
                       day   : byte                     {day - 1..31}
                    end;

      PdateACs    = ^dateACs;                   {date part record - represents a date part from the code generator}
      dateACs     = record
                       monthAC : longint;               {month accumlator}
                       dayAC   : longint;               {day accumlator}
                       yearAC  : longint                {year accumlator}
                    end;

      TAttr       = packed record               {Cell attribute word}
                       pkInvalid : boolean;             {1}
                       pkHasRule : boolean;             {1}
                       pkInCopy  : boolean;             {1}
                       pkCircle  : boolean;             {1}
                       pkFormat  : pkFmtKind;           {6}
                       pkAlign   : alignKind;           {3}
                       pkProt    : protKind;            {2}
                       moneyBit  : boolean              {1}
                    end;


                  {cell (fixed-length part)}
      TPCel       = ^TCel;                        {pointer to a TCel}
      TCel        = record
                       attributes : TAttr;        {cell attribute word}
                       oh         : Toh           {oh = if blank cell: 0 else: heap offset of rule/val cell }
                    end;

      pMapInfoRec = ^mapInfoRec;
      mapInfoRec  = packed array [snipKind, TidRng] of
                       packed record
                          newSnipId : idRange;
                          mapType   : byte
                       end;

      attrRecord  = record
                       attAlign       : alignKind;
                       attProt        : protKind;
                       case attFormat : fmtKind of
                          fDecimal,
                          fScientific : (attPlaces : TDecPlaces);
                          fMoney      : (attMoney  : moneySet)
                    end;

                  {interval information for a coordinate or range (used with the paste relative record - `PRrecord`).
                   The information is a packed representation of 4 normal intervals.  The first interval
                   describes the column portion of a coordinate.  The second interval describes the row portion.
                   Example: in AA123, the column portion = AA and the row portion = 123.  The packed representation
                   takes 16 bits while the normal interval information would have taken 128 bits.  The buffer is
                   large enough to hold information on `maxPRcoords` (40) coordinates.  The packed interval can
                   be expanded into 4 normal intervals by using the following code sequence:

                      1st interval: first.lpFst := lpFst;
                                    first.lpLim := lpFst + colDh + 1;

                      2nd interval: second.lpFst := lpFst + colDh + 1;
                                    second.lpLim := lpFst + colDh + 1 + rowDh + 1;

                   `IsRange` is a flag which states if the interval describes a coordinate range instead of a
                   single coordinate.  The whole range can be constructed by using the above code sequence to
                   get the first coordinate, and the following sequence to get the second coordinate:

                      3rd interval: third.lpFst := lpFst + colDh + 1 + rowDh + 1;
                                    third.lpLim := lpFst + colDh + 1 + rowDh + 1 + xcolDh + 1;

                      4th interval: fourth.lpFst := lpFst + colDh + 1 + rowDh + 1 + xcolDh + 1 + 1;
                                    fourth.lpLim := lpFst + colDh + 1 + rowDh + 1 + xcolDh + 1 + 1 + xrowDh + 1;

                   `IsError` is a flag which states if the interval describes an error coordinate or range.
                  }
      PRinterval  = array [0..maxPRcoords] of           {16 bits}
                       packed record
                          IsRange : boolean;            {1 bit  - is coordinate a range?}
                          IsError : boolean;            {1 bit  - is coordinate an error?}
                          lpFst   : 0..255;             {8 bits - index to start of coordinate}
                          colDh   : 0..1;               {1 bits - # of digits in column coordinate (0 based)}
                          rowDh   : 0..2;               {2 bits - # of digits in row coordinate (0 based)}
                          xcolDh  : 0..1;               {1 bits - # of digits in second column coordinate (for a range)}
                          xrowDh  : 0..2                {2 bits - # of digits in second column coordinate (for a range)}
                       end;

      PRrelInfo   = array [0..maxPRcoords] of
                       record
                          rowRelative : boolean;        {1 bit}
                          colRelative : boolean         {1 bit}
                       end;

                  {paste relative information.  This record contains all the information for the LisaCalc to
                   conduct a dialog concerning the relative/absoulte nature of the cells being relocated.  It
                   also is the vehicle which the LisaCalc relates the information obtained from the user to
                   the matrix manager.
                  }
      TPPRrecord  = ^PRrecord;
      PRrecord    = record
                       numCoords : integer;             {# of coordinates to query about}
                       rowId     : integer;             {coords of example cell}
                       colId     : integer;
                       offsetH   : integer;             {offsets from original cells}
                       offsetV   : integer;
                       absStr,                          {interval info for coords}
                       relStr    : PRinterval;
                       info      : PRrelInfo            {pointer to absolute and relative bits}
                    end;

       PRflags    = record
                       next : boolean;
                       prev : boolean;
                       curr : boolean
                    end;

                  {compiled formula}
      PRTfmla     = packed array [0..7] of boolean;
      TPRTfmla    = ^PRTfmla;
      SFmlaData   = packed record
                       rowId, colId : idRange;          {2 bytes}
                       dh, dv       : integer;          {4 bytes}
                       split        : boolean;
                       refCnt       : 0..fRefCntMax;    {1 bytes}
                       numcoords    : 0..255            {1 byte}
                    end;

      STFmla      = record
                       info : SFmlaData;
                       case alias of
                          twdlDee : (PRdata : PRTfmla);
                          twdlDye : (vecOp  : data)
                    end;

      TPFmla      = ^TFmla;
      THFmla      = ^TPFmla;
      TohFmla     = integer;                    {hz + ohFmla = HFmla}
      TFmla       = record
                       case shared : shareKind of
                          fASeen,
                          fSeen,
                          fAbsolute,
                          fShared : (sData  : STFmla);
                          fSingle : (vecOp  : data)          {byte-coded expr}
                    end;


                  {cell (variable-length part)}
      TPValue     = ^TValue;
      TValue      = record                      {cell with no rule}
                       case alias of
                          twdlDee : (bytes  : data);    {terminated by byte=0}
                          twdlDye : (word   : integer); {2 bytes}
                          twdlDoe : (short  : real);    {4 bytes}
                          twdlDum : (long   : longreal) {8 bytes}
                    end;

     CellBools    = packed record
                       row, col  : 0..255;
                       formIndex : 0..255;
                       pad7      : boolean;
                       pad6      : boolean;
                       pad5      : boolean;
                       ancestor  : boolean;
                       done      : boolean;
                       iterating : boolean;
                       pad1      : boolean;
                       circular  : boolean;
                    end;

     TPtrCell     = ^TCell;
     TCell        = record
                       b  : cellbools;
                       case boolean of
                          true  : (father      : pIdent);
                          false : (nextLogCell : pIdent)
                    end;

      TRule       = record                      {cell with rule and value}
                       lBits  : TCell;
                       ohFmla : TohFmla;        {the formula of the rule}
                       value  : TValue          {its value}
                    end;

      TVdata      = packed record
                       cellseen : boolean;                      {1 bit}
                       refcnt   : 0..cRefCntMax;                {7 bits}
                       marked1  : boolean;                      {1 bit}
                       marked2  : boolean;                      {1 bit}
                       case TCsize : cnSizeKind of              {2 bits}
                          sSymbol : (TCsymbol : cnSymKind);     {4 bits}
                          sWord,
                          sShort,
                          sLong   : (TCnumber : cnNumKind)      {2 bits}
                    end;

      TVinfo      = record
                       data : TVdata
                    end;

      TPContents  = ^TContents;
      THContents  = ^TPContents;
      TContents   = record
                       vinfo : TVinfo;
                       case alias of
                          twdlDee : (value : TValue);
                          twdlDum : (rule  : TRule)
                    end;

      PtextType   = ^textType;
      textType    = record
                       index     : integer;
                       len       : integer;
                       inFormula : boolean;
                       hContents : THContents
                    end;

      printInfo   = record
                       pGrids       : boolean;
                       pColHeadings : boolean;
                       pPageHeader  : boolean;
                       preview      : boolean;
                    end;

                  {packing information variant.  This is used by the parser to pack
                   different information into a formula.
                  }
      variantType = record
                       case alias of
                          twdlDee : (lrealvar   : longreal);
                          twdlDye : (srealvar   : real);
                          twdlDoe : (intvar     : integer);
                          twdlDue : (bytevar    : byte);
                          twdlDum : (coordvar   : pident);
                          twdlFee : (rangevar   : rangetype);
                          twdlFye : (lexeme     : symbol);
                          twdlFoe : (unMoney    : moneySet);
                          twdlFue : (unFmt      : fmtKind);
                          twdlFum : (unByte     : byte);
                          twdlBee : (unAlign    : alignKind);
                          twdlBye : (unProt     : protKind);
                          twdlBoe : (operValue  : integer);
                          twdlBue : (padding    : byte;
                                     oper       : undotype);
                          twdlBum : (date       : dateType);
                          twdlRee : (token      : integer);
                          twdlRye : (pDatePart  : PdateACs);
                          twdlRoe : (pDate      : PdateType);
                          twdlRue : (dateParts  : dateACs);
                          twdlRum : (textinfo   : textType);
                          twdlSee : (ptrToData  : ptrData);
                          twdlSye : (pennyvar   : longint);
                          twdlSoe : (rangeinfo  : range);
                          twdlSue : (xrealvar   : extended);
                          twdlSum : (attrinfo   : TAttr);
                          twdlPee : (snip       : snipKind;
                                     width      : integer);
                          twdlPye : (field      : attrType;
                                     attrRec    : attrRecord);
                          twdlPoe : (forced     : boolean;
                                     state      : boolean;
                                     lowsnip    : idType;
                                     highsnip   : idType;
                                     snipinfo   : snipKind
                                    );
                          twdlPue : (appPadding : byte;
                                     appType    : appKind
                                    );
                          twdlPum : (strType    : string[1]);
                          twdlZee : (lintvar    : longint);
                          twdlZye : (myEnviorn  : Environ);
                          twdlZoe : (bytePad    : byte;
                                     byteNum    : byte
                                    );
                          twdlZue : (thePrintInfo  : PrintInfo);
                          twdlZum : (theCircleInfo : circleType);
                          twdlMee : (theTableInfo  : tblMode);
                    end;

      valueType   = record
                       val  : variantType;
                       nan  : cnSymKind;
                       pCel : TPCel
                    end;

      ModeInfo    = record
                       calcMode    : boolean;
                       circleMode  : circleType;
                       formulaMode : boolean;
                       Tfid        : TLfntId;
                       application : appKind;
                       fInVals     : boolean;
                       fInForms    : boolean;
                       pState      : printInfo
                    end;

      cnRecord    = record
                       cnPCel      : TPCel;
                       cnHContents : THContents;      {nil means vacant cell}
                       cnInvalid   : boolean;         {false for vacant cell}
                       cnHasRule   : boolean;         {false for vacant cell}
                       cnInCopy    : boolean;
                       cnDollar    : boolean;
                       cnIs1Marked : boolean;
                       cnIs2Marked : boolean;
                       cnRepeat    : boolean;
                       case cnSize : cnSizeKind of      {undefined for vacant cell}
                          sSymbol : (cnSymbol: cnSymKind);
                          sWord,
                          sShort,
                          sLong   : (cnNumber: cnNumKind)
                    end;

       statusInfo = record
                       scrapHeapSize : longint;
                       modelSize     : longint;
                       formulaCount  : longint;
                       valueCount    : longint;
                       undoHeapSize  : longint;
                    end;


var   recalcflag  : boolean;
      recalcNow   : boolean;
      imageflag   : boolean;
      assumption  : boolean;
      doingMove   : boolean;
      circularFlag: boolean;
      diskErr     : boolean;
      FindInForms : boolean;
      FindInVals  : boolean;

      FormulaChanged : boolean;
      printSelection : boolean;

      VofZero     : longreal;
      VofOne      : longreal;
      xVofZero    : extended;
      VofHalf     : extended;
      VofPinf     : extended;
      VofMinf     : extended;
      VofNan      : extended;
      VofPI       : extended;
      VofLOG10    : extended;

      mxHz        : THz;                        {heap zone}
      circleRg    : range;
      FirstLogCell: ident;
      curConfig   : TPrRec;                     {current printer's config}
      thePassWord : E_Name;
      pageText    : string[12];
      PRdataPtr   : TPPRrecord;
      printstate  : printInfo;
      circleState : circleType;
      tableState  : tblMode;
      StrToFind   : stringType;                 {text editing field for find dialog box}
      dataFormat  : dFormat;
      toolFormat  : dFormat;                    {formatting characteristics of the tool}
      matState    : FIOKind;                    {'open' or 'closed' for matrix state}

      CloseTime   : longint;                    {last known "closeMatrix" time}
      OpenTime    : longint;                    {last known "OpenMatrix" time}
      calcTime    : longint;                    {last recalculation time}
      numHandles  : longint;
      mmHeapAddr  : longint;                    {head address for mm heap}
      mmMemSize   : longint;                    {initial mm heap size : mem/disk}
      mmDiskSize  : longint;
      mmRefNum    : integer;
      numpasses   : integer;                    {# of passes in recalculation counter}
      maxLenWav   : integer;                    {max #chars allowed in the Wide-Angle View.}

                  {the text strings associated with each lexeme.  Used to decompile the formula}
      wordBuffer  : hnddata;
      words       : array [symbol] of integer;
                  {the token that is assocaited with each lexeme.  Used when appling the grammar}
      token       : array [symbol] of integer;

      monthLens   : array [1..13] of integer;
      TabFWidths  : FontWidths;
      app         : record
                       LisaCalc : boolean;
                       BusGraph : boolean
                    end;


(*$IFC DEBUGVERSION *)
      debugMx     : boolean;                    {turns on extra checking}
      traceMMgr   : boolean;                    {turns on trace output}
      debug       : array [0..45] of boolean;
      FPsaveCnt   : integer;
      indentation : integer;
      timer       : array [0..15] of
                       record
                          peak : boolean;
                          cnt  : integer;
                          prev : longint;
                          time : longint;
                          tot  : longint
                       end;
    skipFlag  : boolean;
(*$ENDC *)
      oppKind     : array [snipKind] of snipKind;       {rowKind <-> colKind}
      IsErrorCell : boolean;
      IsCopyCells : boolean;

(******************************* Interface routines *********************************)
   function aRgInScrap
     (value        : ptrData;           {ptr to where chrs are to go}
      wideFlg      : boolean;           {format for wide angle display? }
      var numBytes : integer            {max # of chrs /actual # chrs returned}
     ) : boolean;

   function allocBlock
     (numBytes : integer                {# of bytes to allocate}
     ) : THContents;                    {handle to allocated block}

   function  cChr
     (x : integer
     ) : char;

   procedure CellAttr
     (rowId, colId : idType;
      var attrRec  : attrRecord         {unpacked attributes for cell}
     );

   function  CellBit
     (rowId, colId : idType;
      bitNum       : bitKind
     ) : boolean;

   function  CellBlank
     (rowId, colId : idType
     ) : boolean;

   procedure CellContents
     (mode         : IOModeType;        {reading/writing mode flag}
      rowId, colId : idType;
      fullinfo     : boolean;           {return the full cnRecord info: y/n}
      var cnRec    : cnRecord;          {record to be read/written}
      var status   : integer            {error status number}
     );

   procedure CellFlags
     (rowId, colId : idType;
      var attr     : TAttr              {cell's packed attributes}
     );

   function  CellHasRule
     (rowId, colId : idType
     ) : boolean;

   function  CellHasValue
     (rowId, colId : idType
     ) : boolean;

   procedure CellInterval
     (rowId, colId  : idType;
      formula       : ptrData;          {ptr to formula characters}
      PRdata        : TPPRrecord;       {Paste Relative record}
          relstr    : boolean;          {relative/absolute information: y/n}
      var numBytes  : integer;          {max # of chrs /actual # chrs returned}
      resetPRdata   : boolean
     );

   procedure CellRange
     (coordinate : ptrData;             {ptr to range characters}
      numBytes   : integer;             {max # of chrs /actual # chrs returned}
      var result : range;               {resulting range from parsing}
      var status : integer;             {error status number}
      var error  : errRecord            {error message information}
     );

   procedure CellType
     (rowId, colId : idType;
      var result   : cellKind           {type for the cell}
     );

   procedure ChangeBlockSize
     (hContents  : THContents;
      newSize    : longint;
      noSizeErr  : boolean;
      var status : integer
     );

   procedure claimUndoBuffer
     (reclaim : boolean                 {should info be relcaimed: y/n}
     );

   procedure clearBuffers
     (claimScrap : boolean              {should scrapInfo be claimed: y/n}
     );

   procedure CloseMatrix
     (fileName   : PtrStrType;          {file where data is to be written}
      closeInfo  : FIOKind;             {Type of file to open}
      DTC        : longint;             {date/time created of previous file - if it existed}
      checkAbort : boolean;             {should user aborts be checked}
      var status : integer              {error status number}
     );

   procedure ClrFormErrors;

   procedure convertformula
     (rowId, colId : idType;
      pFormula     : TPFmla             {ptr to formula}
     );

   function  CoordInMatrix
     (rowId, colId : idType             {coordinates to be checked}
     ) : boolean;

   function  CoordInRange
     (rowId, colId : idType;            {coordinates to be checked}
      rg           : range              {range to be checked against}
     ) : boolean;

   procedure dateString
     (date       : dateType;            {date to be converted to a string}
      var result : resultStr            {resulting string}
     );

   procedure DecRefCnt
     (hContents : THContents;           {handle to the object}
      inrule    : boolean;              {is object a rule: y/n}
      claimData : boolean               {will data handle be claimed later: y/n}
     );

   procedure detLogOrder
     (orderOp : orderType
     );

   procedure displaycell
     (rowId, colId : integer
     );

   procedure DisplayRange
      (rg : range                       {range to be re-displayed}
      );

(*$IFC DEBUGVERSION *)
   procedure FatalMess
     (messnumber : integer              {message number}
     );
(*$ENDC *)

   procedure expandrange
     (var rg : range;                   {range to be expanded/expanded range}
      whole  : boolean
     );

   procedure FBufClose
     (var status : integer              {error status number}
     );

   procedure FBufInit
     (mode       : IOModeType;          {reading/writing mode flag}
      buffertype : IOtype;              {where to send buffer IO}
      filename   : PtrStrType;          {file where IO is to take place}
      usePassWord: boolean;             {use the user supplied password}
      var status : integer              {error status number}
     );

   procedure FBufStuff
     (sizekind    : FBufKind;           {type of information to be stuff/unstuffed}
      value       : ptrData;            {pointer to the data area}
      var length,                       {# of bytes to read/write}
          status  : integer             {error status number}
     );

   function  FinalSnip
     (snip : snipKind                   {type of information desired: row or column?}
     ) : integer;

   function  FindPCel
     (rowId, colId : idType;
      canCreate    : boolean            {create cell if it does not exist: y/n}
     ) : TPCel;                         {pointer to cell information}

   procedure FindStr
     (var rg : range
     );

   procedure FirstCell
     (var rg     : range                {location of the current selection/location of next cell}
     );

   procedure FixRange
     (var rg : range
     );

   procedure FxDataStuff
     (mode       : FIOkind;
      verNumPres : boolean;
      var status : integer
     );

   procedure GetModeInfo
     (var flags : ModeInfo
     );

   function GetOH
     (addr : longint
     ) : integer;

   procedure GetPRcoords
     (var rowId, colId : integer
     );

   function  GetRefCnt
     (hContents : THContents;
      inrule    : boolean
     ) : integer;

   procedure GetStatusInfo
     (itemNum        : integer;
       var statusRec : statusInfo
     );

   procedure GetValue
     (rowId, colId  : integer;
      fullinfo      : boolean;          {return full description on value: y/n}
      var result    : valueType         {value stored for the cell}
     );

   procedure InitMatMgr
     (var status  : integer;            {initialization status}
      application : AppKind             {type of application}
     );

   procedure initparser                 {initializes the parser information}
     (var status   : integer
     );

   function  IsTextstring
     (var number   : valueType;         {value if string, if string is a number}
      var money    : boolean            {was the number a money value? }
     ) : boolean;                       {was it a text string: y/n}

   function MakeHND
     (oh : integer
     ) : longint;

   procedure mmMapFormulas
     (pasting      : boolean;
      uRg,
      sRg          : range;
      passNum      : mmMapKind;
      var vector   : mapInfoRec;
      var estimate : longint;
      var resFlag  : boolean
     );

   procedure mmPRchkBox
     (absolute    : boolean;
      chrinterval : interval;
      boxLabel    : ptrdata;
      numBytes    : integer;
      var bitset  : boolean
     );

   procedure mmGetPRInfo
     (aBoxLabel    : ptrData;           {resulting absolute checkboxes}
      Formula      : ptrData;           {resulting formula}
      rBoxLabel    : ptrData;           {resulting absolute checkboxes}
      var numBytes : integer;           {max # of chrs /actual # chrs returned}
      CellLabel    : ptrData;           {resulting cells display label}
      var numLByte : integer;           {max # of chrs /actual # chrs returned}
      var butData  : PRflags;           {button state data}
      mode         : idModeType         {movement mode}
     );

   procedure mmSendPRinfo;              {shared formula information}

   procedure mmSetBreak
     (forced,
      state      : boolean;
      aRg        : range
     );

   procedure mmSetWids
     (tableStyle : tblMode
     );

   procedure moveLfast
     (p1,p2    : ptrData;               {p1, p2 = ptrs to data}
      numBytes : integer                {number of bytes to move}
     );

   procedure moveRfast
     (p1,p2    : ptrData;               {p1, p2 = ptrs to data}
      numBytes : integer                {number of bytes to move}
     );

   procedure NewSnips
     (var rg         : range;           {range of snips to be operated on}
      source         : srcType;         {type of operation to perform}
      ignoreUndo     : boolean;         {continue operation even if can't be undone}
      ignoreProctect : boolean;         {continue operation even if cells are protected}
      var status     : integer          {error status number}
     );

   procedure NextCell
     (mode        : mcType;
      curCell     : range;
      var nxtCell : range
     );

   function NextFormula
     (var rowId,
          colId : idType
     ) : boolean;

   procedure NextPRcell;

   function  NumOfCoords
     (formula     : ptrData;            {direct ptr to formula to check}
      rg          : range;              {inclusion range to check coords against}
      aFormula    : ptrData;            {direct ptr to formula to remap (maybe nil)}
      vector      : mapInfoRec;         {range being pasted into}
      mapExternal : boolean;            {should external references be changed: y/n}
      relative    : boolean;            {paste releative operation: y/n}
      setRelInfo  : boolean;            {setting rel/abs info: y/n}
      var relInfo : PRTfmla             {rel/abs bits}
     ) : integer;

   procedure NumOfFormulaFolds;

   procedure OpenMatrix
     (fileName      : PtrStrType;       {file to retrieve data from}
      loadFile      : boolean;          {load file data: y/n}
      checkAbort    : boolean;          {should user aborts be checked}
      openInfo      : FIOKind;          {Type of file to open}
      var tableInfo : tableRecord;      {table information about data}
      var status    : integer           {error status number}
     );

   function OutOfHeapSpace
     (hz          : THz;                {zone which which ran out of space}
      bytesNeeded : integer             {# bytes needed in the zone}
     ) : integer;                       {# bytes zone increase by}

   function  parse
     (operation : parseKind;            {parse operation}
      dataline  : ptrdata;              {ptr to line to be parsed}
      numBytes  : integer;              {# bytes in line}
      row, col  : integer;              {circular reference information}
      var error : errRecord             {error infomation}
     ) : boolean;                       {parse succesful? }

   procedure PrevPRcell;

   procedure PutValue
     (rowId, colId : integer;
      value        : valueType;         {value to be saved into the cell}
      inrule       : boolean;           {does the value belong to a rule: y/n}
      var status   : integer            {error status number}
     );

   procedure ReadMMscrap
     (var status : integer
     );

   procedure recalc
     (rowId, colId : idType;
      var status   : integer;           {error status number}
      inrule       : boolean            {does the cell have a newly entered rule: y/n}
     );

   procedure resetPRdata
     (rowId, colId : idType;
      PRdata       : TPPRrecord
     );

   procedure RginScrap
     (var rg : range
     );

   procedure rstr
     (number         : extended;        {the number to be formatted}
      var result     : resultStr;       {the resulting string}
      decplaces,                        {# digits to the right of the dec. pt}
      format         : byte;            {format code number}
      numdigits      : integer;         {# digits desired}
      var scientific : boolean          {value was displayed in sci. notation? }
     );

   function  ScrapAbsent : boolean;

   procedure SetCellAttr
     (attrRec    : attrRecord;          {unpacked attribute information}
      field      : attrType;            {type of information to be stored}
      rg         : range                {range of cells to be affected}
     );

   procedure SetCellBit
     (rowId, colId : idType;
      state        : boolean;           {state to set cell's value to}
      bitType      : bitKind            {which mark bit to set}
     );

   procedure SetCharInfo
     (fontId : TLfntId                  {font # information concerns}
     );

   procedure SetCirBit
     (rowId, colId : integer;
        cir, inv     : boolean
     );

   procedure SetCircleMode
     (state : circleType                {state to set the calculate strict mode}
     );

   procedure SetImage
     (state : boolean                   {state to set application specific drawing}
     );

   procedure SetMapVectors
     (var vector : mapInfoRec
     );

   procedure SetReCalc
     (state : calcState                 {state to set automatic recalculation flags}
     );

   procedure SetRgBits
     (var rg  : range;
      bitType : bitKind;
      state   : boolean;
      action  : byte
     );

   procedure SetVecWidth
     (snip  : snipKind;
      width : integer;
      rg    : range
     );

   procedure SetVisSnips;

   procedure SfromB
     (var strg : stringType;
      pBytes   : ptrData;
      numBytes : integer
     );

   procedure SfromN
     (var answer : resultStr;
      num        : longint;
      base       : integer;
      alphabet   : char
     );

   procedure ShrinkSegMemory
     (Hz         : THz;
      beSmart    : boolean;
      var errnum : integer
     );

   function  SnipExist
     (snip   : snipKind;                {type of snip to be tested}
      snipId : idType                   {the id for the snip}
     ) : boolean;

   procedure StoB
     (strg         : resultStr;
      pBytes       : ptrData;
      var numBytes : integer
     );

   procedure SwitchTable
     (ScrapTable    : boolean;        {table to switch to}
      var tableInfo : tableRecord       {table information for that table}
     );

(*$IFC DEBUGVERSION *)
   procedure timeclear
     (slot : integer
     );

   procedure timepeak
     (peakslot : integer
     );

   procedure timestart
     (slot : integer
     );

   procedure timestop
     (slot : integer
     );
(*$ENDC *)

   procedure unPackValue
     (hContents  : THContents;
      pValue     : TPValue;
      fullinfo   : boolean;
      var result : valueType;
      var assume : boolean              {asumption made about the data: y/n}
     );

   procedure WordFromLexeme
     (lexeme   : symbol;
      maxBytes : integer;
      word     : PtrStrType
     );

   procedure WriteMMscrap
     (var status : integer
     );

   procedure xStoB
     (strg         : str255;
      pBytes       : ptrData;
      var numBytes : integer
     );


(***********************   Common Interface Rouitnes   ***************************)
   procedure CellFormula
     (mode         : IOModeType;        {reading/writing mode flag}
      rowId, colId : idType;
      formula      : ptrData;           {ptr to formula characters}
      var numBytes,                     {max # of chrs /actual # chrs returned}
          status   : integer;           {error status number}
      var error    : errRecord          {error message information}
     );

   procedure CellInfo
     (parName      : cellParType;       {which parameter to read/write}
      mode         : IOModeType;        {reading/writing mode flag}
      rowId, colId : idType;
      var cellRec  : cellRecord         {record to be read/written}
     );

   procedure CellRun
     (mode         : IOModeType;        {reading/writing mode flag}
      rowId, colId : idType;
      value        : ptrRuns;           {ptr to run info}
      var numRuns,                      {# of runs}
          status   : integer            {error status number}
      );

   procedure CellValue
     (mode         : IOModeType;        {reading/writing mode flag}
      rowId, colId : idType;
      value        : ptrData;           {ptr to where chrs are to go}
      wideFlg      : boolean;           {format for wide angle display? }
      var numBytes,                     {max # of chrs /actual # chrs returned}
          status   : integer            {error status number}
     );

   procedure FoldedFormula
     (rowId, colId : idType;
      formula      : ptrData;           {ptr to formula characters}
      var numBytes : integer            {error status number}
     );

   procedure GetSnipId
     (snip       : snipKind;            {type of information desired: row or column}
      mode       : idModeType;          {mode of information desired: first/last...}
      position   : fract;               {position in [0 .. 1000] for fraction oper}
      refId      : idType;              {reference snip for next/prior oper}
      var snipId : idType               {resulting snip information}
     );

   function mmBreakSnip
     (aKind : snipKind;
      aSnip : idType
     ) : Boolean;

   procedure mmMapSnip
     (snip          : snipKind;         {type of snips to be remapped}
      oldSnipId     : idType;           {the old snipId to be remapped}
      var newSnipId : idType;           {the resulting new snipId}
      var status    : integer           {mapping status}
     );

   procedure SetSnipWidth
     (rg         : range;               {range of cells to be operated on}
      width      : integer              {width of those cells}
     );

   function  SnipLT
     (snip     : snipKind;              {type of snips to be tested}
      snipId1,                          {snips to be compared}
      snipId2  : idType
     ) :  boolean;

   function  SnipWidth
     (snip   : snipKind;                {type of information desired}
      snipId : idType                   {snip for which the data is desired}
     ) : integer;                       {width of the snip}

implementation

(*$R- *)

(*$IFC teSym *)
(*$D+ *)
(*$ELSEC *)
(*$D- *)
(*$ENDC *)

   (*$I aplc/mm/um5.text *)
   (*$I aplc/mm/um7.text *)
   (*$I aplc/mm/um6.text *)
   (*$I aplc/mm/um3.text *)
   (*$I aplc/mm/um1.text *)
   (*$I aplc/mm/um2.text *)
   (*$I aplc/mm/um4.text *)

(*$S initial *)
END.
