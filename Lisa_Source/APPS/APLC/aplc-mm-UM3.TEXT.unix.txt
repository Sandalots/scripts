
                            {'Copyright 1983, 1984, Apple Computer Inc.'}

(***************************************.*******.************************************
   AdjDopeVec - recomputes dope vector for all columns in [colId1..colId2] and
                non-absent columns after colId2.
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure AdjDopeVec
  (colId1,
   colId2 : idType
  );
var col   : TidRng;
    colId : idType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   col := cStoredCols;
   with CT^ do
      for colId := lastSnip[colKind] downTo colId1 do
        if (vecSnip[colKind, colId] <> absent) or (colId <= colId2) then begin
           vecSnip[colKind, colId] := col;
           col := col - 1
        end
end;


(***************************************.*******.************************************
   BubbleLeft - to be machine-coded some day.
                BubbleLeft(10, pc, sizeof(v[0]), @v[0], a, b) is equivalent to:
                for i := a to b do v[i] := v[i+10];
                if pc <> nil then for i := b+1 to b+10 do v[i] := pc^;
****************************************.*******.***********************************)
(*$S CutPaste *)
procedure BubbleLeft(* howFar : integer; pConstFill : ptrData;
                       sizeofElement : integer; pZerothElement : ptrData;
                       indexOfFirstDest : integer; indexOfLastDest : integer *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   moveLeft (pZerothElement^ [(indexOfFirstDest + howFar) * sizeofElement],
             pZerothElement^ [indexOfFirstDest * sizeofELement],
             (indexOfLastDest+1-indexOfFirstDest) * sizeofElement);
   if pConstFill <> nil then
      FillConst(pConstFill, sizeofElement, pZerothElement, indexOfLastDest + 1, indexOfLastDest + howFar)
end;


(***************************************.*******.************************************
   BubbleRight - to be machine-coded some day.
                 BubbleRight(10, pc, sizeof(v[0]), @v[0], a, b) is equivalent to:
                 for i := b downTo a do v[i] := v[i-10];
                 if pc <> nil then for i := a-10 to a-1 do v[i] := pc^;
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure BubbleRight(* howFar : integer; pConstFill : ptrData;
                        sizeofElement : integer; pZerothElement : ptrData;
                        indexOfFirstDest : integer; indexOfLastDest : integer *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   moveRight(pZerothElement^ [(indexOfFirstDest - howFar) * sizeofElement],
             pZerothElement^ [indexOfFirstDest * sizeofElement],
             (indexOfLastDest+1-indexOfFirstDest) * sizeofElement);
   if pConstFill <> nil then
      FillConst(pConstFill, sizeofElement, pZerothElement, indexOfFirstDest - howFar, indexOfFirstDest - 1)
end;


(*$IFC DEBUGVERSION *)
(***************************************.*******.************************************
   CheckCompiler - checks that compiler packing isn't getting worse.
****************************************.*******.***********************************)
(*$S debug2 *)
procedure CheckCompiler;

    (*$S debug2 *)
    procedure Chk(typeName : str40; actual, expected : integer);
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       if expected <> actual then begin
          writeln('sizeof(', typeName, ')=', actual:1,' <> ',expected:1,chr(7));
       end
    end;

begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   Chk('TVinfo', sizeof(TVinfo), 2);
   Chk('TAttr', sizeof(TAttr), 2);
   Chk('TCel', sizeof(TCel), 4);
   Chk('TValue', sizeof(TValue), 8);
   Chk('TRule', sizeof(TRule), 16);
   Chk('TFmla', sizeof(TFmla), 12);
   Chk('PRrecord', sizeof(PRrecord), 244);
   Chk('STFmla', sizeof(STFmla), 10);
   Chk('tmBand', sizeof(tmBand), 10);
   Chk('vecattrs', sizeof(vecattrs), 1020);
   Chk('vecBreaks', sizeof(vecBreaks), 128);
   Chk('vecattrtime', sizeof(vecattrtime), 512);
   Chk('vectimer', sizeof(vectimer), 4);
   Chk('modedata', sizeof(modeinfo), 16);
   Chk('Prinfo', sizeof(Prinfo), 490);
   Chk('Printer Stamp', sizeof(PrinterStamp), 206);
   Chk('File Version Stamp', sizeof(FileStamp), 14);
   Chk('ScrapInfo', sizeof(ScrapInfo^), 26);
   Chk('vector', sizeof(mapInfoRec), 1020);
   with theAlfmt do begin
      alFormat := 0; alGrp := gMoney;
      if alFormat <> 24 then writeln('gMoney*8 = ', alFormat);
      alFormat := 0; alGrp := gMisc;
      if alFormat <> 56 then writeln('gMisc*8 = ', alFormat);
      alFormat := 0; alMoney := 3;
      if alFormat <> 3 then writeln('[mDollar,mComma] = ', alFormat);
      alFormat := 0; alMisc := fStandard;
      if alFormat <> 2 then writeln('fStandard = ', alFormat);
      alFormat := 0; alDec := dScientific;
      if alFormat <> 32 then writeln('dScientific*32 = ', alFormat)
   end
end;
(*$ENDC *)


(***************************************.*******.************************************
   ChgSnipWidth - used when pasting in a new column and also when changing the table
                  font.  Needs to be split across two segments, FontChanging & CutPaste.
****************************************.*******.***********************************)
(*$S FontChanging *)
procedure ChgSnipWidth(var width : integer; oldWidth, newWidth : integer);
var numBytes  : integer;
    remainder : integer;
    temp      : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   temp      := width - TblPars.FieldPad;
   numBytes  := temp div oldWidth;
   remainder := temp mod oldWidth;
   width     := Cmin(numbytes * newWidth + TblPars.FieldPad + remainder * newWidth div oldWidth, maxColWidth)
end;
(*$S CutPaste *)
procedure CTChgSnipWidth(var width : integer; oldWidth, newWidth : integer);
var numBytes  : integer;
    remainder : integer;
    temp      : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   temp      := width - TblPars.FieldPad;
   numBytes  := temp div oldWidth;
   remainder := temp mod oldWidth;
   width     := Cmin(numbytes * newWidth + TblPars.FieldPad + remainder * newWidth div oldWidth, maxColWidth)
end;


(***************************************.*******.************************************
   ClrDopeInfo - reallocates all the row vectors to be their correct size.  The row
                 vector sizes will now be based on CSTOREDCOLS instead of dopeSize.
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure ClrDopeInfo;
var row    : integer;
    status : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   writeln('clearing dope size: ',dopeSize:1,'/',cStoredCols:1);
(*$ENDC *)

   useDopeInfo := false;
   if cStoredCols <> dopeSize then
      for row := 1 to idMax do
         if vecSnip[rowKind, row] <> absent then ReallocRow(row, status);
   dopeSize := 0;
end;


(***************************************.*******.************************************
   expandrange -
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure expandrange(* var rg : range; whole : boolean *);
var highrow : integer;
    highcol : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if whole then begin
      highrow := idMax;
      highCol := idMax
   end
   else with CT^ do begin
           highrow := lastsnip[rowKind];
           highcol := lastsnip[colKind]
        end;

   with rg do
      case rKind of
         aWTBoxRg : begin
                       loRow := 1;
                       hiRow := highRow;
                       loCol := 1;
                       hiCol := highCol
                    end;
         aRowRg,
         aRowGrid : begin
                       loCol := 1;
                       hiCol := highcol
                    end;
         aColRg,
         aColGrid : begin
                       loRow := 1;
                       hiRow := highrow
                    end
      end
end;


(***************************************.*******.************************************
   FillConst - to be machine-coded some day.
               FillConst(pc, sizeof(v[0]), @v[0], a, b) is equivalent to:
               for i := a to b do v[i] := pc^;
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure FillConst(* pConstFill : ptrData; sizeofElement : integer;
                      pZerothElement : ptrData; indexOfFirstDest : integer;
                      indexOfLastDest: integer *);
var firstByte : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if indexOfFirstDest<=indexOfLastDest then begin
      firstByte := indexOfFirstDest * sizeofElement;
      moveLeft(pConstFill^, pZerothElement^[firstByte], sizeofElement);
      moveLeft(pZerothElement^[firstByte],
               pZerothElement^[firstByte+sizeofElement],
               (indexOfLastDest-indexOfFirstDest)*sizeofElement);
   end
end;


(***************************************.*******.************************************
   FreeBufList -
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure FreeBufList;
var FBufTemp  : THptrData;
    ptrToLInt : ^longint;
    nextBuf   : longint;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   nextBuf := ord(FBufPtr);
   repeat
      FBufTemp := pointer(nextBuf);
      if CbDataOfH(HzfromH(@FBufTemp^), @FBufTemp^) > THdataSize then begin
          ptrToLInt := @FBufTemp^^[THdataSize];
          nextBuf   := ptrToLInt^
      end
      else nextBuf := -1;
      numHandles := numHandles - (ord(HzfromH(@FBufTemp^) = mxHz));
      FreeH(HzfromH(@FBufTemp^), @FBufTemp^)

(*$IFC DEBUGVERSION *)
      ;if debug[5] or debug[24] or debug[19] then writeln('freeing up oh: ',ord(FBufTemp))
(*$ENDC *)
   until nextBuf < 0
end;


(***************************************.*******.************************************
   FreeContents - frees the contents of the indicated cell and makes the contents nil
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure FreeContents(* pCel : TPCel *);
var hContents : THContents;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   DebugMess(7);
(*$ENDC *)

   if pCel <> nil then begin
      hContents := GetHContents(pCel);
      pCel^.oh  := 0;
      DecRefCnt(hContents, false, true)
   end

(*$IFC DEBUGVERSION *)
   ;DebugMess(8)
(*$ENDC *)
end;


(***************************************.*******.************************************
   FreeSnips - frees storage for one or more snips numbered snipId1 to snipId2
****************************************.*******.***********************************)
(*$S CutPaste *)
procedure FreeSnips(* snip : snipKind; snipId1, snipId2 : idType *);
var firRealcol : TidRng;
    status     : integer;
    howMany    : integer;
    hVecCel    : THVecCel;
    done       : boolean;
    rowId      : idType;
    colId      : idType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   DebugMess(9);
(*$ENDC *)

   with CT^ do begin
      if snip = rowKind then begin
         for rowId := snipId1 to snipId2 do
            if vecSnip[snip, rowId] <> absent then begin
               hVecCel := hVecOfRow(rowId);
               FreeH(mxHz, pointer(ord(hVecCel)));
               numHandles := numHandles - 1;
               vecSnip[snip, rowId] := absent
             end
      end
      else begin
              howMany := 0;                     {count deleted columns}
              for colId := snipId2 downto snipId1 do
                 if vecSnip[snip, colId] <> absent then begin
                    howMany    := howMany + 1;
                    firRealcol := colId
                 end;
              if howMany > 0 then begin
                 cStoredCols := cStoredCols - howMany;
                 for rowId := 1 to lastSnip[rowKind] do
                    if vecSnip[rowKind,rowId] <> absent then begin
                       {shorten each row vector}
                       hVecCel := hVecOfRow(rowId);
                       BubbleLeft(howMany, nil, sizeof(TCel), @hVecCel^^[0],
                                  vecSnip[colKind, firRealcol], cStoredCols);
                       ReallocRow(rowId, status);
(*$IFC DEBUGVERSION *)
                       if status <> ok then FatalMess(45);
(*$ENDC *)
                    end;
                 AdjDopeVec(snipId2+1, snipId2);
                 FillConst(@absent, sizeof(integer), @vecSnip[snip, 0], snipId1, snipId2);
              end
           end;

      {if one of the snips freed was the lastsnip, find the new last snip}
      if snipId2 = lastSnip[snip] then begin
         done := false;
         repeat
            snipId1 := snipId1 - 1;
            if snipId1 >= 1 then done := (vecSnip[snip, snipId1] <> absent)
         until (snipId1 < 1) or done;
         lastSnip[snip] := snipId1
      end
   end

(*$IFC DEBUGVERSION *)
   ;DebugMess(10)
(*$ENDC *)
end;


(***************************************.*******.************************************
   GetCellAttr - returns the attributes for the cell at ROWID,COLID with
                 PCEL being a pointer to the cell's handle oh and attribute info.
                 The actual attribute is returned through ATTR.

   NOTE: PCEL is not checked to see if it really is the pointer to the cell info at
         ROWID,COLID.
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure GetCellAttr
  (* pCel         : TPCel;
     var attr     : TAttr;
     rowId, colId : idType
  *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   {if the cell does not exist, get the attribute information for the row/col
    attribute vector, which ever is the most current.
   }
   if pCel = nil then begin
      if vecAttrTime[colKind, colId] >= vecAttrTime[rowKind, rowId] then attr := vecAttrs[colKind, colId]
      else attr := vecAttrs[rowKind, rowId]
   end
   else attr := pCel^.attributes;

   {if an attribute undo state exists, check to see if the attribute should come
    from the undo buffer.
   }
   if mmUndoInfo.state and (mmUndoInfo.op = uAttr) then
      if CoordInRange(rowId, colId, mmUndoInfo.rg) then
         with mmUndoInfo.info do
            case field of
               aAlign   : attr.pkAlign := attrRec.attAlign;
               aProtect : attr.pkProt  := attrRec.attProt;
               aFormat  : SetCellFormat(attr, attrRec)
            end;
end;


(***************************************.*******.************************************
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure GetFormat(rowId, colId : integer; var decplaces, format : integer);
var attr : attrRecord;
    cht  : packed record                      {to circumvent compiler bug}
              case alias of
                 twdlDee : (m : moneySet);
                 twdlDum : (b : 0..31;
                            bCents,
                            bComma,
                            bDollar : boolean
                           )
              end;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   CellAttr(rowId, colId, attr);
   decplaces := 2;
   case attr.attFormat of
      fInteger    : format := 2;
      fStandard   : format := 0;
      fDecimal    : begin
                       decplaces := attr.attPlaces;
                       format    := 3
                    end;
      fScientific : begin
                       decplaces := attr.attPlaces;
                       format    := 1
                    end;
      fMoney      : begin
                       format := 4;
                       cht.m  := attr.attMoney;
                       if cht.bDollar then format := format + 2;
                       if cht.bComma  then format := format + 1;
                       if cht.bCents  then format := format + 4
                    end
   end
end;


(***************************************.*******.************************************
   GetHContents - returns a handle on the contents of the indicated cell.
                  if pCel is nil or its oh is 0, nil is returned
****************************************.*******.***********************************)
(*$S matMgrSeg *)
function  GetHContents(* pCel : TPCel) : THContents *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if pCel = nil then GetHContents := nil
   else if pCel^.oh = 0 then GetHContents := nil
   else GetHContents := pointer(MakeHnd(pCel^.oh))
end;


(***************************************.*******.************************************
   hVecOfRow - returns a handle on the cell vector of the indicated row
****************************************.*******.***********************************)
(*$S matMgrSeg *)
function  hVecOfRow(* rowId : idType ) : THVecCel *);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

(*$IFC DEBUGVERSION *)
   if vecSnip[rowKind, rowId] = absent then begin
      Fatalmess(6);
      hVecOfRow := nil
   end
   else
(*$ENDC *)
   hVecOfRow := pointer(MakeHnd(vecSnip[rowKind, rowId]))
end;


(***************************************.*******.************************************
   IdInRange -
****************************************.*******.***********************************)
(*$S matMgrSeg *)
function IdInRange(* rowId, colId : integer; var rg : range; var lastIds : pIdent) : boolean *);
var oper   : undotype;
    status : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   rg.rKind  := aNullRg;
   IdInRange := false;
   if FBufPtr <> nil then begin
      ReadHeader(oper, rg, lastIds, status);
      if rowId = mInfSnip then rowId := rg.loRow
      else if colId = mInfSnip then colId := rg.loCol;
      if status = ok then IdInRange := CoordInRange(rowId, colId, rg)
   end
end;


(***************************************.*******.************************************
   IncRefCnt -
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure IncRefCnt
  (* hContents : THContents;
     inRule    : boolean
  *);
var rule : THFmla;                              {pointer to the rule for the cell}

(*$IFC DEBUGVERSION *)
   (*$S debug2 *)
   procedure dumpinfo;
   begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

      if hContents <> nil then begin
         write('IncRef: ');
         if inRule then begin
            rule := pointer(MakeHnd(hContents^^.rule.ohfmla));
            write('(formula): ',GetOH(ord(rule)):1,' = ');
            if rule^^.shared = fSingle then writeln('no refcnt')
            else writeln(rule^^.sdata.info.refcnt:1)
         end
         else writeln('(data): ',GetOH(ord(hcontents)):1,' = ', hContents^^.vinfo.data.refcnt:1)
      end
      else writeln('IncRef: hContents = nil')
   end;
(*$ENDC *)

(*$S matMgrSeg *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if hContents <> nil then
      with hContents^^.vinfo.data do
         if inrule then begin
            rule := pointer(MakeHnd(hContents^^.rule.ohfmla));          {get pointer to the rule}
            with rule^^ do
               if shared <> fSingle then
                  sdata.info.refcnt := CMin(sdata.info.refcnt + 1, fRefCntMax)
         end
         else refcnt := CMin(refcnt + 1, cRefCntMax)
(*$IFC DEBUGVERSION *)
   ;if debug[12] then dumpinfo
(*$ENDC *)
end;


(***************************************.*******.************************************
   isProtected - predicate to determine if the cell whose packed attribute record
                is attr is protected
****************************************.*******.***********************************)
(*$S matMgrSeg *)
function isProtected(* attr : TAttr) : boolean *);
var prot : protKind;
    temp : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   prot := attr.pkProt;
   case prot of
      protNone  : temp := false;
      protRules : temp := attr.pkHasRule;
      protAll   : temp := true
   end;
   isProtected := temp or (attr.pkAlign = aInvis)
end;


(***************************************.*******.************************************
****************************************.*******.***********************************)
(*$S dateCalc *)
procedure partsString
  (parts      : dateACs;
   var result : resultStr
  );

    (*$S dateCalc *)
    procedure extract(singular, plural : symbol; num : longint);
    var title    : resultStr;
        partName : resultStr;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       if num <> 0 then begin
          SfromN(title, num, 10, '0');
          if num <> 1 then singular := plural;
          WordFromLexeme(singular, 40, @partName);
          if plural = YEARSop then result := concat(',', result, title, partName)
          else result := concat(result, ',', title, partName)
       end
    end;


(*$S dateCalc *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   result := ',';
   extract(YEARop, YEARSop, parts.yearAC);
   extract(MONTHop, MONTHSop, parts.monthAC);
   extract(DAYop, DAYSop, parts.dayAC);
   if result = ',' then begin
      WordFromLexeme(DAYSop, 40, @result);
      result := concat(',,0',result)
   end;
   delete(result, 1, 2)
end;


(*$S matMgrSeg *)
procedure patchFormats(* rowId : idType; hVecCel : THVecCel; lowSnip, highSnip : idType *);
var timeCnt : integer;
    col     : TidRng;
    colId   : idType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   timeCnt := vecAttrTime[rowKind, rowId];
   for colId := lowsnip to highsnip do begin
      col := vecSnip[colKind, colId];
      if col <> absent then
         with hVecCel^^[col] do
            if oh = 0 then begin
               if vecAttrTime[colKind, colId] >= timeCnt then attributes := vecAttrs[colKind, colId]
               else attributes := vecAttrs[rowKind, rowId]
            end
            else if oh < 0 then oh := 0
   end
end;


(***************************************.*******.************************************
   PBtoB - copies bytes from src to dest until a null byte is reached.  Does not
           copy the null byte.  Sets numBytes to the number of bytes copied.
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure PBtoB(* src, dest : ptrData; var numBytes : integer *);
var bytes : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   bytes := 0;
   while (bytes < numBytes) and (src^[bytes] <> 0) do begin
      dest^[bytes] := src^[bytes];
      bytes := bytes + 1
   end;
   numBytes := bytes
end;


(***************************************.*******.************************************
****************************************.*******.***********************************)
(*$S matMgrSeg *)
function OutOfHeapSpace
  (* hz          : THz;                 {zone which which ran out of space}
     bytesNeeded : integer              {# bytes needed in the zone}
  ) : integer *);                       {# bytes zone increase by}
var errNum         : integer;
    ds_refNum      : integer;                   {refnum for data segment}
    increment      : longint;                   {amount heap was incremented by}
    curHzSize      : longint;                   {cuurent size of the heap that must be enlarged}
    NewMsize       : longint;                   {new memory size}
    NewDsize       : longint;                   {new disk size}
    minIncrement   : longint;                   {minimum increment to enlarge heap by}
    unusedSegSpace : longint;                   {unused space in the data segment}
    swapSpace      : longint;                   {amount of sysytem memory available for swapping}
    dataSpace      : longint;                   {amount of memory taken by data}
    cur_codeSize   : longint;                   {current code segment size}
    max_codeSize   : longint;                   {largest code segment}
    info_rec       : dsInfoRec;                 {segment info for data segment}

    (*$S matMgrSeg *)
    procedure doSize(theMemSize, theDiskSize : longint);
    var sErrNum : integer;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       Sched_Class(sErrNum, false);
       Size_DataSeg(errNum, ds_refNum, theMemSize, NewMsize, theDiskSize, NewDsize);
       Sched_Class(sErrNum, true)
    end;


(*$S matMgrSeg *)
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   Info_Address(errNum, ord(hz), ds_refNum);
   if errNum = 0 then Info_DataSeg(errNum, ds_refNum, info_rec);
   if errNum = 0 then begin

      {amount of unused space in data segment}
      unusedSegSpace  := info_rec.disc_size - info_rec.mem_size;

      {the current size of the heap that needs to be enlarged}
      curHzSize       := CBofHZ(hz);

      {minumim increment to enlarge heap - based on the original bytesneeded}
      if hz = mxHz then begin
         if app.BusGraph then increment := BGHzLim
         else increment := LChzLim;
         increment := increment div 1024 div 2 - 1
      end
      else increment := 0;
      minIncrement   := ((ord4(bytesNeeded) + 1023) div 1024 + increment) * 1024;
      if minIncrement > maxInt then minIncrement := maxInt;

      {check if the current mem_size + unused space in the data segment will accomodate
       the to be enlarged heap.  If so, the mem_size will be enlarged to the new size of the heap.
       The disc_size in this case would not be changed.
      }
      if info_rec.mem_size + unusedSegSpace >= curHzSize + bytesneeded then begin

         {Make an additional check to see if the mem_size already allows the heap to be grown
          without changing the data segment.
         }
         if curHzSize + bytesneeded > info_rec.mem_size then begin

            {data segment must be resized.  Try to increase the mem_size by the minimum increment.
             Failing that, an attempt will be made to increase the mem_size by the amount requested.
            }
            if curHzSize + minIncrement <= info_rec.mem_size + unusedSegSpace then doSize(minIncrement, 0)
            else errNum := -1;
            if errNum <> 0 then doSize(bytesneeded + unusedSegSpace, 0);
            increment := NewMsize - curHzSize
         end
              {the heap can be grown without affecting the data segment.  Check if the heap can
               be grown by the minimum increment instead of what was requested.  If this cannot
               be done, then use the amount requested.
              }
         else begin
                 NewMsize  := mmMemSize;
                 NewDsize  := mmDiskSize;
                 increment := info_rec.mem_size - curHzSize
              end
      end
      else begin
              {could not get away with just enlarging the mem_size of the data segment.  Must
               increase the disc_size.  The disc_size will be increased by the minimum increment
               to try and avoid running out of space immdeiately.  If the data segment cannot be
               grown by the minumum increment, then an attempt will be made to grow the data segment
               by the amount requested.  The mem_size will be set to be the same as disc_size.  A check
               is made to insure that the machine will not start to thrash because the data segment id
               becoming too large.  Basically, LisaCalc is estimated to take up 316K with BG requiring
               an additional 46K to run efficiently.  If the swapspace will become less than that, do
               not enlarge the data segment.
              }
              Mem_Info(errNum, swapSpace, dataSpace, cur_codeSize, max_codeSize);
(*$IFC DEBUGVERSION or WRITELNS *)
              writeln('Mem_Info: swap: ',swapSpace:1,'  data: ',dataspace:1,'  cur_code: ',cur_codeSize:1,
                       '  max_code: ',max_codeSize:1);
(*$ENDC *)

              if swapSpace > minSwapSpace + minIncrement then doSize(minIncrement, minIncrement - unusedSegSpace)
              else errNum := -1;
              if errNum <> 0 then
                 if swapSpace > minSwapSpace + bytesNeeded then doSize(bytesNeeded, bytesNeeded - unusedSegSpace);
              increment := NewMsize - curHzSize
           end
   end;

   if errNum <> 0 then begin
(*$IFC DEBUGVERSION or WRITELNS *)
      writeln('OutOfHeapSpace:  need ',bytesneeded:1,'/',minIncrement:1,' more bytes');
      writeln('cannot complete operation (whatever it is???)');
      writeln('OutOfHeapSpace: cbFree/CurHzSize: ',mxhz^.cbFree:1,'/',curHzSize:1);
(*$ENDC *)
      diskErr   := (errNum = 309) or (errNum = 311);
      increment := 0
   end
   else if hz = mxHz then begin
           mmMemSize  := NewMsize;
           mmDiskSize := NewDsize
        end;

(*$IFC DEBUGVERSION or WRITELNS *)
   write('OutOfHeapSpace in ');
   if hz = mxHz then write('mxHz')
   else if hz = theHeap then write('theHeap')
   else write('Unknown heap');
   writeln(': needed ',bytesNeeded:1,'/',increment:1,'/',curHzSize:1,'.  New size: ',NewMsize:1,',',NewDsize:1);
(*$ENDC *)

  {return the amount allocated - the difference between then new and old memory sizes}
   if increment > maxInt then increment := maxInt;
   OutOfHeapSpace := increment
end;


(***************************************.*******.************************************
   ReadHeader - opens undo buffer and reads header out of it.  The type of undo
                information that is in the buffer is returned in OP and the undo
                range in RG.
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure ReadHeader
  (* var op      : undoType;
     var rg      : range;
     var lastIds : pIdent;
     var status  : integer
   *);
var length  : integer;
    variant : variantType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   FBufInit(mmRead, oMem, @status, false, status);
   unstuffinteger(variant.operValue, status);
   op := variant.oper;
   FBufStuff(fRange, @rg, length, status);
   unstuffinteger(length, status);
   lastIds.length := length;
   unstuffinteger(length, status);
   lastIds.start  := length

(*$IFC DEBUGVERSION *)
   ;if debug[28] then
      writeln('lastIds: ',lastids.length:1,',',lastIds.start:1,' ',ord(op):1,' ',wrg(rg));
(*$ENDC *)
end;


(***************************************.*******.************************************
   ReAllocRow - reallocates the cell vector for rowId to have cStoredCols cells.
                Copies data from the old to the new space.
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure ReallocRow
  (* rowId      : idType;
     var status : integer
  *);
var newSize : longint;
    tHandle : THContents;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   newSize := cStoredCols * sizeof(TCel);
   tHandle := pointer(ord(hVecOfRow(rowId)));
   if useDopeInfo then begin
      status  := ok;
      newSize := dopeSize * sizeof(TCel);
      if CbDataOfH(mxHz, @tHandle^) >= newSize then exit(ReallocRow);
   end;
   ChangeBlockSize(tHandle, newSize, true, status)
end;


(***************************************.*******.************************************
   RWTabledata - read or writes pertinent table editor information into the Flush
                 buffer.  The information is not protected while it is inside the
                 buffer, thus care must be taken to not overwrite it by accident.
****************************************.*******.***********************************)
(*$S scrapCode *)
procedure RWTabledata(mode : IOmodeType; var tableInfo : tableRecord);
var status   : integer;
    dataLen  : integer;
    vwPt     : point;
    aTMband  : tmBand;
    aTMstate : tmState;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

    FBufInit(mode, oBuffer, @status, false, status);
    tmSaveState(aTMstate);
    dataLen := sizeof(aTMstate);
    FBufStuff(fRawData, @aTMstate, dataLen, status);
    dataLen := sizeof(TableInfo);
    FBufStuff(fRawData, @TableInfo, dataLen, status);
    tmCurVwPt(vwPt);
    dataLen := sizeof(vwPt);
    FBufStuff(fRawData, @vwPt, dataLen, status);
    if mode = mmRead then begin
       tmNewPars;
       tmLoadState(aTMstate);
       tmLoadBands
    end
    else begin
            TableInfo.RectBorder := false;
            TableInfo.Marquee    := false;
            TableInfo.EditTable  := false;
            tmSaveBands
         end;
    repeat
       if mode = mmRead then begin
          FBufStuff(fTmBand, @aTmBand, dataLen, status);
          tmLoadNextBand(aTmBand)
       end
       else begin
               tmSaveNextBand(aTmBand);
               FBufStuff(fTmBand, @aTmBand, dataLen, status)
            end
    until aTmBand.tmbLoId = nullsnip;
    if mode = mmRead then tmCurVwSet(vwPt)
end;


(***************************************.*******.************************************
   SetCellFormat -
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure SetCellFormat
  (* var attr : Tattr;
     attrRec : attrRecord
  *);
var variant : variantType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   case attrRec.attFormat of
      fDecimal    : begin
                       theAlFmt.alDec     := dDecimal;
                       theAlFmt.decPlaces := attrRec.attPlaces
                    end;
      fScientific : begin
                       theAlFmt.alDec     := dScientific;
                       theAlFmt.decPlaces := attrRec.attPlaces
                    end;
      fMoney      : begin
                       theAlFmt.alGrp   := gMoney;
                       variant.unMoney  := attrRec.attMoney;
                       theAlFmt.alMoney := variant.unByte
                    end;
      otherwise     begin
                       theAlFmt.alGrp  := gMisc;
                       theAlFmt.alMisc := attrRec.attFormat
                    end
   end;
   attr.pkFormat := theAlFmt.alFormat
end;


(***************************************.*******.************************************
   SetDopeInfo - set up doping information such that any row vectors that must be
                 reallocated will be sized to that set in DOPESIZE instead of
                 CSTOREDCOLS.  A subsequent call to "clrDopeInfo" MUST be may to
                 reset the normal state when the doping effect is not needed.
****************************************.*******.***********************************)
(*$S CutPaste *)
procedure SetDopeInfo(* loCol, hiCol : integer; onAbsent : boolean *);
var numAbsent : integer;
    numPres   : integer;
    col       : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   useDopeInfo := true;
   numPres     := 0;
   numAbsent   := 0;
   for col := loCol to hiCol do
      if vecSnip[colKind, col] <> absent then numPres := numPres + 1
      else numabsent := numabsent + 1;
   if onAbsent then  dopeSize := numAbsent
   else dopeSize := numPres;
   dopeSize := dopeSize + cStoredCols
(*$IFC DEBUGVERSION *)
   ;writeln('Setting dope size: cols: ',loCol:1,'...',hiCol:1,'  absent/pres: ',numAbsent:1,'/',numPres:1,
           '  dopesize: ',dopeSize:1,'/',cStoredCols:1)
(*$ENDC *)
end;


(***************************************.*******.************************************
  SET HIGH & LOW SNIP - set up the high/low values for particular type of snip.  RG
                        is used to compute the high & low values.  The values are
                        returned through HIGHSNIP/LOWSNIP with the type of the snip
                        being retruned through SNIP.
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure SetHighLowSnip
  (rg           : range;
   var lowsnip,
       highsnip : idType;
   var snip     : snipKind;
   lowestVal    : idType
  );
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   case rg.rKind of
      aWTBoxRg  : begin
                     lowSnip  := 1;
                     highSnip := idmax;
                     snip     := colKind
                  end;
      aColGrid,
      aColRg    : begin
                     lowsnip  := rg.loCol;
                     highsnip := rg.hiCol;
                     snip     := colKind
                  end;
      aRowGrid,
      aRowRg    : begin
                     lowsnip  := rg.loRow;
                     highsnip := rg.hiRow;
                     snip     := rowKind
                  end
   end;
   if lowestVal > lowsnip then lowSnip := lowestVal;
   if highsnip < 1 then highsnip := idMax
end;


(***************************************.*******.************************************
   SetRgInvalid - sets the invalid bit for all allocated cells with in a range RG.
****************************************.*******.***********************************)
(*$S CutPaste *)
procedure SetRgInvalid(rg : range; reDisplay : boolean);
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

  expandrange(rg, false);
  SetRgBits(rg, BInvalid, true, 1);
  if reDisplay then NewRgImg(rg)
end;


(***************************************.*******.************************************
   SetVecAttr - permanently sets the cell attributes from the temporary information
****************************************.*******.***********************************)
(*$S attributes *)
procedure SetVecAttr;
var snipId   : integer;
    highsnip : integer;
    lowsnip  : integer;
    timeSet  : integer;
    snipTest : boolean;
    snip     : snipKind;
    VT       : variantType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with mmUndoInfo.rg do begin
      SetRgBits(mmUndoInfo.rg, BNone, true, 5);

      if (rKind = aColRg) or (rKind = aRowRg) then begin
         snipTest := (rKind = aColRg);
         SetHighLowSnip(mmUndoInfo.rg, lowsnip, highsnip, snip, 1);
         if vecTimer.last = snipTest then begin
            timeSet := 256;
            for snipId := 1 to idMax do begin
               if vecAttrTime[rowKind, snipId] > 0 then
                  timeSet := Cmin(timeSet, vecAttrTime[rowKind, snipId]);
               if vecAttrTime[colKind, snipId] > 0 then
                  timeSet := Cmin(timeSet, vecAttrTime[colKind, snipId])
            end;
            timeSet := timeSet mod 256;
            for snipId := 1 to idMax do begin
               if vecAttrTime[rowKind, snipId] > 0 then
                  vecAttrTime[rowKind, snipId] := vecAttrTime[rowKind, snipId] - timeSet + 1;
               if vecAttrTime[colKind, snipId] > 0 then
                  vecAttrTime[colKind, snipId] := vecAttrTime[colKind, snipId] - timeSet + 1
            end;
            vecTimer.cnt  := Cmin(vecTimer.cnt - timeset + 1 + ord(timeset > 0), 255);
            vecTimer.last := not snipTest
         end;
         for snipId := lowsnip to highsnip do begin
            vecAttrTime[snip, snipId] := vecTimer.cnt;
            VT.attrinfo := vecAttrs[snip, snipId];
            with mmUndoInfo.info do
               case field of
                  aAlign   : VT.attrinfo.pkAlign := attrRec.attAlign;
                  aProtect : VT.attrinfo.pkProt := attrRec.attProt;
                  aFormat  : SetCellFormat(VT.attrinfo, attrRec)
               end;
            vecAttrs[snip, snipId] := VT.attrinfo
         end
      end
   end
(*$IFC DEBUGVERSION *)
;if debug[5] then writeln('SetVecAttr: ',vectimer.cnt:1,' ',vectimer.last,timeSet)
(*$ENDC *)
end;


(***************************************.*******.************************************
   SetVecBreaks - permanently sets the state of the page breaks from the temporary
                  state info generated by "mmPageBreak" and MMUNDOINFO.
****************************************.*******.***********************************)
(*$S pBreakCode *)
procedure SetVecBreaks;
var snipId : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   with mmUndoInfo.info do
      for snipId := lowsnip to highsnip do begin
         vecBreaks[forced, snipinfo, snipId] := mmPageBreaks(forced, snipinfo, snipId);
         if mmUndoInfo.rg.rKind = aWTBoxRg then
            vecBreaks[forced, rowKind, snipId] := mmPageBreaks(forced, rowKind, snipId)
      end
end;


(***************************************.*******.************************************
   SfromN - base is 10 or 26; alphabet is '1' or 'A'. Converts the number num to
            a string in radix base ala LisaCalc row and column headings
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure SfromN(* var answer : resultStr; num : longint; base : integer;
                   alphabet : char *);
var absNum  : longint;
    tempStr : string[12];
    chrStr  : string[1];
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if num = 0 then tempStr := '0'
   else begin
           absNum  := abs(num);
           tempStr := '';
           chrStr  := '$';
           while absNum > 0  do begin
              chrStr[1] := chr(((absNum - ord(base = 26)) mod base)+ord(alphabet));
              tempStr := concat(chrStr, tempStr);
              absNum  := (absNum - ord(base = 26)) div base
           end;
           if num < 0 then tempStr := concat('-', tempStr)
        end;
   answer := tempStr
end;


(***************************************.*******.************************************
   stuffinteger - places an integer VALUE into the flush buffer.  The entry into
                  the flush buffer is only performed if STATUS is equal to OK upon
                  entry into the routine otherwise not happens and STATUS is unchanged.
****************************************.*******.***********************************)
(*$S CutPaste *)
procedure stuffinteger
  (value      : integer;
   var status : integer
  );
var length : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if status = ok then begin
      FBufStuff(fWord, @value, length, status);
(*$IFC DEBUGVERSION *)
      if debug[15] then status := FileErr;
(*$ENDC *)
   end
end;


(***************************************.*******.************************************
   unstuffinteger -
****************************************.*******.***********************************)
(*$S matMgrSeg *)
procedure unstuffinteger(* var value, status : integer *);
var length : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   FBufStuff(fWord, @value, length, status);
(*$IFC DEBUGVERSION *)
   if status <> ok then FatalMess(15)
(*$ENDC *)
end;

ÿ