
                            {'Copyright 1983, 1984, Apple Computer Inc'}

(*********** aplc/appdibox - lisacalc application dialog box manager - unit comgr **************)

{$S PRdialog}
procedure checkHit (theFldH: hndField; chkIntrvl: interval);

        {Called when a check box has been hit.  Redraw the check boxes
        and the formula with the new information, if warranted.}
var redraw : boolean;
    done   : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then begin
      LCtraceMess(94);
      if (theFldH = chkRowA.chkFldH) then writeln('Absolute:')
      else if (theFldH = chkRowR.chkFldH) then writeln('Relative:')
      else writeln('Where?');
      writeln('Interval is: ', chkIntrvl.lpFst:1, '/', chkIntrvl.lpLim:1);
   end;
{$ENDC }
   mmPRchkBox(theFldH = chkRowA.chkFldH, chkIntrvl, chkRowA.chkFldH^^.curvalue^, numChkBytes, redraw);
   if redraw then PutNewRep(mmLast, false, done);
end;


{$S PRdialog}
procedure cleanUpRep;
        {Clean up any temporary storage used for replicate}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(95);
{$ENDC }
   RemoveField(ChkRowA.ChkFldH);
   RemoveField(ChkRowR.ChkFldH)
end;


(***********************************************************************************
   ClrUndo - this procedure is called when we're about to do a new operation that
             may be undoable.  The matrix manager is informed so that it can
             release memory space that may have been used for the last undoable
             operation.  Information in the matrix manager's private scrap will
             also be reclaimed if the scrap no longer is owned by us or does not
             contain cells.
***********************************************************************************)
(*$S fexec *)
procedure ClrUndo;
var sKind : ScrapKind;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   GetScrKind(sKind);
   if not ((curDiHeight > 0) and (curDiBox = diReplicate)) then
      ClearBuffers((sKind <> cellsKind) or (ScrapProcess <> My_Id));
   AcceptInheritScrap;
   SetUndo(uNothing, nullPnl)
end;


(*$S DiSeg *)
procedure disMissDi{menu: integer; menuIndex: Integer;
                    var response: diResponse};
        {Determine whether the action defined by menu/menuIndex is allowed,
         given the current dialog box.  Set response to: OkAction if the
         action makes sense for the current dialog box; IgnoreAction if the
         action should be ignored; and DiGone if this routine dismissed
         the Dialog Box in response to this action.  This routine will be
         totally rewritten when its desired workings are defined.}
var usable : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then begin
      LCtraceMess(96);
      writeln('Menu: ', menu:1, ' index: ', menuIndex:1)
   end;
{$ENDC }
   case menu of
      MenuEdits : usable := (menuIndex in [undoItem, feCopy, cut, pasteM, clr]);
      MenuAlert : usable := (menuIndex = hitKey);
{$IFC fDebug }
      MenuRod,
      MenuTrace : begin
                     response := OkAction;
                     exit(dismissDi)
                  end;
{$ENDC }
      otherwise   usable := false
   end;
   if usable and (curDiBox <> diReplicate) then response := OkAction
   else begin
           doStopAlert(128);
           response := IgnoreAction
        end
end;


{$S DiSeg}
procedure doCWidPrecBox;
        {The user has hit DoIt for the ColWidth or Precision dialog box.  Respond to
         the new value by setting the new column width or new format with precision
         if the number is valid.}
label 1;
var placesInt : integer;
    maxNum    : integer;
    next      : integer;
    title     : stringType;
    xNumber   : extended;
    myDecimal : Decimal;
    error     : boolean;
    newCR     : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(99);
{$ENDC }
   endOtherSel(dialogPnl);

   { Convert the user entered bytes to a Real Value }
   with diHfld[1]^^ do begin
      SfromB(title, curValue^, curlen);
      next := 1;
      Str2Dec(title, next, myDecimal, error);
      Dec2X(myDecimal, xNumber);
      error := (next <= curlen)
   end;

   if not error then begin
      case curDiBox of
         diInsert    : maxNum := idMax;
         diPrecision : maxNum := maxDecPlaces;
         otherwise     maxNum := maxLenWav
      end;
      ClearXcps;
      X2I(xNumber, placesInt);
      if TestXcp(INEXACT) or (placesInt > maxNum) or (placesInt < 1) then begin
         doParamAlert(maxNum);
         doStopAlert(123);      {Number too large}
         pnlSelAll(DialogPnl, g.curTimeout);
         SetPnlPort(DialogPnl);
         l.newSelection := true;
         PushButn(BtnDoIt, false)
      end
      else begin
              case curDiBox of
                 diInsert    : begin
                                  InsertSnip(placesInt, newCR);
                                  if newCR then chgStatPnl(false)
                                  else goto 1
                               end;
                 diPrecision : setNewFormat(placesInt);
                 otherwise     begin
                                  SetSnipWidth(g.curRange, placesInt * tblCharWid);
                                  ShoNewWid(colKind, g.curRange.loCol, g.curRange.hiCol);
                                  DoSelCR(g.curRange, g.curTimeout, SelectCell)
                               end
              end;
              rmvDiBox
           end
   end
   else begin
           doStopAlert(122); {Number not valid}
        1: pnlSelAll(DialogPnl, g.curTimeout);
           SetPnlPort(DialogPnl);
           l.newSelection := true;
           PushButn(BtnDoIt, false)
        end
end;


{$S Circling}
procedure doCirBox;
label 2;
var buttonHit : integer;
    status    : integer;
    mode      : circleType;
    errorRg   : range;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   KillPicture(HintsPicture);
   HintsPicture := nil;
   rmvDiBox;
   for buttonHit := 1 to 7 do
      if chkBoxInfo.boxes[true].b[buttonHit] then begin
         circleRg.rKind := aNullRg;
         FixRange(circleRg);
         case buttonHit of
            1 : mode := cNone;
            2 : mode := cMissing;
            3 : mode := cInvis;
            4 : mode := cError;
            5 : mode := cProtect;
            6 : begin
                   mode     := cDependent;
                   circleRg := g.curRange
                end;
            7 : mode := cCircular
         end;
         SetCircleMode(mode);
         if mode <> cNone then begin
            with errorRg do begin
               rKind := a1CellRg;
               loRow := 1;
               loCol := 1;
               hiRow := 1;
               hiCol := 1
            end;
            if mode = cMissing then begin
               enterCalc(true, true, false, false, status);
               if not g.autoCalc then goto 2
            end;
            FirstCell(errorRg);
            if (errorRg.rKind = aNullRg) and not CellBit(1, 1, BCircle) then begin
               status := 10009 + ord(mode);
               doNoteAlert(status)
            end
         end
      end;
2: endPnlSel;
   enterReselect(status)
end;


(*$S FindDiBox *)
procedure doFinds{var newCR : boolean};
var errorRg  : Range;
    alertNum : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   errorRg := g.CurRange;
   if g.ItemIndex = DoFindCircles then FirstCell(errorRg)
   else FindStr(errorRg);
   if errorRg.rKind <> aNullRg then begin
      ClrUndo;
      SetUndo(uGoto, coPnl);
      doGoTo(errorRg);
      newCR := true
   end
   else begin
           selectRg(g.curRange, selectCell);
           if g.ItemIndex = DoFindCircles then alertNum := 10002
           else begin
                   ParamAlert(StrToFind, '', '');
                   alertNum := 10003
                end;
           doNoteAlert(alertNum)
        end
end;


{$S FindDiBox}
procedure doFindBox;
var newCR : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   { Convert the user entered bytes to a string to be found }
   with diHfld[1]^^ do SfromB(StrToFind, curValue^, curlen);
   with chkBoxInfo.boxes[true] do begin
      FindInVals  := b[1];
      FindInForms := b[2]
   end;
   rmvDiBox;
   doFinds(newCR);
   if newCR then chgStatPnl(false)
end;


{$S funcHints}
procedure doFuncHints;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   KillPicture(HintsPicture);
   ClrUndo;
   HintsPicture := nil;
   rmvDiBox
end;


{$S PrintDiBox}
procedure doPrintBox;
var title : stringType;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   KillPicture(HintsPicture);
   HintsPicture := nil;
   rmvDiBox;
   with chkBoxInfo.boxes[true] do begin
      printState.pPageHeader  := b[1];
      printState.pColHeadings := b[2];
      printState.pGrids       := b[3]
   end;
   lcReDoBreaks;     { recompute page breaks }
   if printState.preView then tmReDoViews
   else tmShoBreaks
end;


{$S PRdialog}
procedure doRepBox;
        {The DoIt button has been hit in a replicate dialog box, or the user
        has hit the Next button and there is no next box.  Finish the replicate
        and end the dialog.}
var status : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(199);
{$ENDC }
   mmSendPRInfo;
   forceCalc(true);
   cleanUpRep;
   rmvDiBox;
   chgStatPnl(false);
   SetUndo(uPasteRel, tblPnl)
end;


{$S specialDiSeg}
procedure DrawDialog;
var myGrafProcs : QDProcs;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   SetPnlPort(DialogPnl);
   SetStdProcs(myGrafProcs);
   with myGrafProcs do begin
      rectProc := @StdRectProc;
      textProc := @StdTextProc
   end;
   Dialogfolder^.grafProcs := @myGrafProcs;
   drawPicture(HintsPicture, HintsPicture^^.picFrame);
   Dialogfolder^.grafProcs := nil
end;


{$S funcHints}
procedure DrawHints;
var tempRect : rect;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   SetPnlPort(DialogPnl);
   PenNormal;
   PenSize(1, 2);
   MoveTo(0, DoItButTop);
   Line(DialogFolder^.portRect.right - dhsBox, 0);
   SetOrigin(HintsOffset.h, HintsOffset.v);
   with scrollArea do begin
      tempRect.top    := top + HintsOffset.v;
      tempRect.bottom := bottom + HintsOffset.v;
      tempRect.left   := left + HintsOffset.h;
      tempRect.right  := right + HintsOffset.h
   end;
   ClipRect(tempRect);
   drawPicture(HintsPicture, HintsPicture^^.picFrame)
end;


{$S DiSeg}
procedure endCWidPrecBox;
        {The user has hit GoAway for the ColWidth or Precision dialog box.  Remove
         the box and reselect the current range in the table,
         leaving the g.ActivePnl at tblPnl.
        }
var status : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(200);
{$ENDC }
   endPnlSel;
   ClrUndo;
   if (curDiBox = diPrecision) and (g.curRange.rKind = a1CellRg) then enterReSelect(status)
   else DoSelCR(g.curRange, g.curTimeout, SelectCell);
   rmvDiBox
end;


{$S PRdialog}
procedure endRepBox;
        {The user has hit GoAway in a replicate dialog box.  Undo any
         replicate actions that have been done so far, and end the dialog.}
var status : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(203);
{$ENDC }
   NewSnips(g.curRange, mmUndo, false, false, status);
   ClrUndo;
   selectRg(g.curRange, SelectCell);
   cleanUpRep;
   forceCalc(true);
   rmvDiBox
end;


(*$S specialDiSeg *)
procedure GetLisaDrawPic(fileName : str40);
var myKeys    : Keyset;
    PicData   : picHandle;
    numBytes  : integer;
    dataLen   : integer;
    status    : integer;
    Proc_Info : ProcInfoRec;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   Info_Process(status, My_ID, Proc_Info);
   status := 1;
   repeat
      status := status + 1
   until Proc_info.ProgPathName[status] = '-';
   Proc_info.ProgPathName :=  concat(copy(Proc_info.ProgPathName, 1, status), fileName);

(*$IFC true or DEBUGVERSION or MMINITCODE *)
   GetKeys(myKeys);
   if 78 in myKeys then begin

      GetGrScrap(PicData);       {Check application specific scrap}
      if PicData <> nil then begin
         StartGetScrap(numBytes);
         numBytes := cbdataOfH(HzFromH(@PicData^), @PicData^);
(*$IFC DEBUGVERSION or MMINITCODE *)
         writeln('Pic Size: ',numBytes);
(*$ENDC *)
         if 126 in mykeys then begin
            ParamAlert('the Dialog Box', '', '');
            doWaitAlert(138);
            FBufInit(mmWrite, oDisk, @Proc_info.ProgPathName, false, status);
            dataLen := sizeof(numBytes);
            FBufStuff(fRawData, @numBytes, dataLen, status);
(*$IFC DEBUGVERSION or MMINITCODE *)
            writeln('written Pic Size: ',numBytes);
(*$ENDC *)
            FBufStuff(fRawData, @PicData^^, numBytes, status);
            FBufClose(status);
            HideFolder(alertFolder)
         end
         else begin
                 HintsPicture := Pointer(ord(newHandle(numBytes)));
                 moveLfast(@PicData^^, @HintsPicture^^, numBytes);
                 EndGetScrap(numBytes);
                 exit(GetLisaDrawPic)
              end;
         EndGetScrap(numBytes)
      end
   end;
(*$ENDC *)

   FBufInit(mmRead, oDisk, @Proc_info.ProgPathName, false, status);
   dataLen := sizeOf(integer);
   FBufStuff(fRawData, @numBytes, dataLen, status);

(*$IFC DEBUGVERSION or MMINITCODE *)
   writeln('Read in Pic Size: ',numBytes);
(*$ENDC *)

   HintsPicture := Pointer(ord(newHandle(numBytes)));
   if ord(HintsPicture) = ord(hNil) then begin
      HintsPicture := OpenPicture(DialogFolder^.portRect);      {create a blank picture if can't allocate real one}
      doPnlDrawAlert(188, DialogPnl);
      ClosePicture
   end
   else FBufStuff(fRawData, @HintsPicture^^, numBytes, status);
   FBufClose(status);
   chkBoxInfo.boxes[true].l  := 0;
   chkBoxInfo.boxes[false].l := 0

end;


{$S initial}
procedure initDiFlds;
        {Set up the field and fieldstate for the dialog box, and initialize to
        an empty string.  Don't set coords or do InitFstate.}
var i        : Integer;
    nullRect : rect;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(204);
   Dialogfolder^.grafProcs := nil;
{$ENDC }
   SetRect(nullRect, 0, 0, 0, 0);
   for i := 1 to 4 do begin
      diHfld[i] := CreateField(nullRect, maxDiStrng + 1, 0, left, 4, 1, 0, sysFntId.Fam, false);
      diHfs[i]  := pointer(ord(newHandle(sizeof(fieldstate))))
   end;
   HintsPicture := nil;

end; (* initdiFlds *)



{$S PRdialog}
procedure nextHit;
        {The user has hit the Next button in a replicate box.  Put up the
         next replicate box, if there is one, or complete the replicate
         and end the dialog if there isn't one.}
var status : integer;
    done   : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(205);
{$ENDC }
   mmSendPRinfo;
   NextPRcell;
   PutNewRep(mmNext, true, done);
   if done then doRepBox;
end;


{$S PRdialog}
procedure prevHit;
        {The user has hit the Prev button in a replicate box.  Put up the
         previous replicate box, if there is one.}
var done : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(206);
{$ENDC }
   mmSendPRinfo;
   PrevPRcell;
   PutNewRep(mmPrior, true, done);
end;


{$IFC fDebug }
{$S LCdebug}
procedure prntLblFld{lblX: lblFldX};
        {For debugging only: print out elements of lbl field}
var myLabel : str40;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

    if traceDi then LCtraceMess(207);
    with lblX^ do begin
       write('label type: ',ord(lbl):1,'  ');
       if lbl = lNull then writeln(lStr^)
       else begin
               GetItem(myMenus[lMenuNum], lMenuItem, @myLabel);
               writeln(myLabel)
            end;
       writeln('label box: ',wrect(lblBox));
       writeln('lblH = ', lblH, ' and lblV = ', lblV);
       if assocFldH = nil then writeln('assocFldH nil')
       else writeln('assocFldH not nil');
       if assocFSH = nil then writeln('assocFSH nil')
        else writeln('assocFSH not nil');
    end
 end;
{$ENDC }


{$S Circling }
procedure PutCircleBox;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   clrUndo;
   addDiBox(FindCircleSize, @doCirBox, @rmvDiBox, false, true);
   GetLisaDrawPic('{T3}CircleBox');
   g.pnlToEnter  := g.pnlwithChg;
   g.ActivePnl   := dialogPnl;
   curDiBox      := diCircle;
   if circleState <> cDependent then chkBoxInfo.boxes[true].b[ord(circleState) + 1] := true;
   PutGraphics(@DrawDialog)
end;


{$S DiSeg}
procedure putCWidPrecBox{diBox : diBoxKind; initStr: resultStr};
        {Put up a dialog box to query the desired column width/precision.  The default
        string to put in the field is initStr}
var status    : integer;
    ButHeight : integer;
    ButWidth  : integer;
    menuitem  : integer;
    FldMsgV   : integer;
    LblLeft   : integer;
    LblLen    : integer;
    BoxHeight : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(209);
{$ENDC }
   if tblEditPnl(g.ActivePnl) then ExitSel
   else EndPnlSel;
   case diBox of
      diInsert    : if g.curRange.rKind = aRowGrid then MenuItem := LCRowInsert
                    else MenuItem := LCColInsert;
      diPrecision : MenuItem := DecPlacItem;
      otherwise     MenuItem := NumChrItem
   end;
   ButWidth  := CalcButWidth(0, 1, ButHeight);
   BoxHeight := (ButHeight * 7) div 2;
   FldMsgV   := (sysFInfo.ascent + BoxHeight) div 2;
   addDiBox(BoxHeight, @doCWidPrecBox, @endCWidPrecBox, false, false);
   with lblA do begin
      lbl       := lMenu;
      lmenuNum  := MenuBuzz;
      lmenuItem := menuItem;
      GetItem(myMenus[lmenuNum], lmenuItem, @tempLabel);
      TextFont(SysText);
      LblLen  := StringWidth(tempLabel) + StringWidth(' ');
      LblLeft := (ButLeftEdge - LblLen - StringWidth('1234')) div 2;
      SetRect(lblBox, 0, 0, LblLen + LblLeft, FldMsgV);
      lblH := LblLeft;
      lblV := FldMsgV;
      assocFldH := diHfld[1];
      assocFSH  := diHfs[1]
   end;
   putDiLbl(@lblA);
   with diHfld[1]^^ do begin
      curlen := maxlen;
      xStoB(initStr, curvalue^, curlen);
      with sysFInfo do
         SetRect(coords, LblLen + LblLeft, FldMsgV - ascent - descent + 1, ButLeftEdge, FldMsgV + descent)
   end;
   InitFstate(diHfld[1], diHfs[1]);
   putDiFld(diHfld[1], diHfs[1], status);
{$IFC fDebug }
   if TempCode then
      if status <> 0 then writeln('status = ', status:1, ' after putDiFld');
{$ENDC }
   pnlSelAll(dialogPnl, g.curTimeout);
   g.ActivePnl := dialogPnl;
   curDiBox    := diBox
end;


{$S FindDiBox }
procedure PutFindBox;
var status : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   clrUndo;
   addDiBox(FindDiSize, @doFindBox, @rmvDiBox, false, true);
   GetLisaDrawPic('{T3}FindBox');
   g.pnlToEnter := g.pnlwithChg;
   g.ActivePnl  := dialogPnl;
   curDiBox     := diFind;
   with chkBoxInfo.boxes[true] do begin
      b[1] := FindInVals;
      b[2] := FindInForms
   end;
   PutGraphics(@DrawDialog);
   putDiFld(diHfld[1], diHfs[1], status);
   pnlSelAll(dialogPnl, g.curTimeout)
end;


{$S funcHints}
procedure putFuncHints{InitBoxSize : integer};
var rh, rv : rect;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   addDiBox(InitBoxSize, @doFuncHints, nil, true, false);
   scrollArea := DialogFolder^.portrect;
   with scrollArea do begin
      bottom := DoItButTop;
      right  := right - dhsbox
   end;

   HintsOffset.h := 0;
   HintsOffset.v := 0;
   SetThumb(hsbHDiag, 0);
   SetThumb(hsbVDiag, 0);
   GetLisaDrawPic('{T3}FuncHints');
   SetSBIcons(hsbVDiag, [iconArwA, iconPagA, iconThumb, iconPagB, iconArwB]);
   if HintsPicture^^.picFrame.right < DialogFolder^.portrect.right - dhsbox then SetSBIcons(hsbHDiag, [])
   else SetSBIcons(hsbHDiag, [iconArwA, iconPagA, iconThumb, iconPagB, iconArwB]);
   g.pnlToEnter := g.pnlwithChg;
   g.ActivePnl  := dialogPnl;
   curDiBox     := diFuncHints;

   SetPnlPort(dialogPnl);
   FlushRects(rh, rV);
   SetSbRect(hsbHDiag, rH);
   SetSbRect(hsbVDiag, rv);
   PaintSBar(hsbHDiag);
   PaintSBar(hsbVDiag);
   PaintGrow;

   PutGraphics(@drawHints)
end;


{$S PRdialog}
procedure putNewRep{whichBox: idModeType; newBtns: boolean; var done: boolean};
        {Put up the varying parts of the replicate dialog box: the
         cell coordinates, the check boxes, and the formula itself.
         whichBox is mmFirst, mmNext, or mmPrior.  If whichBox = mmNext
         and there IS no next box, however, then return done = true and
         do no more.  Otherwise, return done = false and do the job.
         This routine assumes that diMgr already knows about lblA
         (the "Cell:" display,), lblC (the formula), chkRowA (the absolute
         check row), and chkRowR (the relative check row).  It erases the
         current fields, gets the current info, and redraws it all.
         If newBtns is true, then redraw (put up or remove) the next and
         prev buttons.}
const CellSpacing = 4;
var formBytes    : array [0..PRStrLength] of byte;
    cellBytes    : array [0..maxCoLen] of byte;
    status       : integer;
    numCellBytes : integer;
    rThereBtns   : PRFlags;
    i            : integer;
    lblLen       : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(210);
{$ENDC }
   numChkBytes  := PRStrLength + 1;
   numCellBytes := maxCoLen + 1;
   mmGetPRinfo(chkRowA.chkFldH^^.curvalue^, @formBytes, chkRowR.chkFldH^^.curvalue^, numChkBytes,
               @cellBytes, numCellBytes, rThereBtns, whichBox);
   {Make sure there IS new info to put up.  If there is no new info
    (ie, the person has hit NEXT and there is no next), then return
    DONE = true.}
   if (whichBox = mmNext) and not(rThereBts.prev or rThereBtns.curr) then done := true
   else begin
           done := false;
{$IFC fDebug }
           if traceDi then begin
              writeln('NewBtns: ',newBtns,'  Next: ',rThereBtns.next,'  Prev: ',rThereBtns.prev)
           end;
{$ENDC }
           if newBtns then begin
              shoButton(@nextBtn, rThereBtns.next);
              shoButton(@prevBtn, rThereBtns.prev);

              {Fill in the cell coordinates for lblA, then redraw the label}
              with lblA do begin
                 GetItem(myMenus[MenuStat], CellItem, @lStr^);
                 lblLen := length(lStr^);
                 for i := 1 to CellSpacing do
                    lStr^[lblLen + i] := chr(32);

                 lblLen := lblLen + CellSpacing;
                 for i := 1 to numCellBytes do
                    lStr^[lblLen + i] := chr(cellBytes[i-1]);
                 lStr^[0] := chr(lblLen + numCellBytes);

{$IFC fDebug }
                 if traceDi then begin
                    writeln('lblA for the Coords is:');
                    prntLblFld(@lblA);
                 end;
{$ENDC }

                 clrLbl(@lblA);
                 drawLbl(@lblA)
              end
           end;

           {Fill in the formula for lblC, then redraw the formula}
           with lblC do begin
              lStr^    := '';
              lblLen := 0;
              for i := 1 to numChkBytes do
                 lStr^[i] := chr(formBytes[i-1]);
              lStr^[0] := chr(numChkBytes);

{$IFC fDebug }
              if traceDi then begin
                 writeln('lblC for the formula is:');
                 prntLblFld(@lblC);
              end;
{$ENDC }

              clrLbl(@lblC);
              drawLbl(@lblC);
           end;

           {Fill in the final info for the check row fields, then redraw them}
           chkRowA.chkFldH^^.curlen := numChkBytes;
           chkRowR.chkFldH^^.curlen := numChkBytes;
           reDrawChks(@chkRowA);
           reDrawChks(@chkRowR);
        end
end;


{$S PrintDiBox }
procedure PutPrintBox;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   clrUndo;
   addDiBox(PrintDiSize, @doPrintBox, @rmvDiBox, false, true);
   GetLisaDrawPic('{T3}PrintBox');
   g.pnlToEnter := g.pnlwithChg;
   g.ActivePnl  := dialogPnl;
   with chkBoxInfo.boxes[true] do begin
      b[1] := printState.pPageHeader;
      b[2] := printState.pColHeadings;
      b[3] := printState.pGrids
   end;
   curDiBox  := diPrint;
   PutGraphics(@DrawDialog)
end;


{$S PRdialog}
procedure putRepBox;
        {The user has selected Paste Relative from the menu.  Put up the
         first dialog box for the replicate dialog, and set up for the whole
         thing.
        Note: This routine must be in a different segment from
         RepGrafix, CheckHit, PrevHit, and NextHit so that it can pass pointers
         to them.  For now, it's in DiSeg, but it really is LisaCalc-specific.}
var numCellBytes : integer;
    formBytes    : array [0..PRStrLength] of byte;
    dummyAArray  : array [0..PRStrLength] of byte;
    dummyBArray  : array [0..PRStrLength] of byte;
    cellBytes    : array [0..maxCoLen] of byte;
    done         : boolean;
    rThereBtns   : PRFlags;
    butHeight    : integer;             {current height of a button}
    butWidth     : integer;             {current width of a button}
    PrevH, NextH : integer;             {distances for next/prev button spacing}
    ChkLeft      : integer;             {Left edge of check box rows}
    RepLblV      : integer;             {Start the label 10 pixels below the top edge of the label box}
    RepBoxDv     : integer;             {Height of replicate dialog box}
    SameBot      : integer;             {Bottom edge of "Same"}
    AchkBot      : integer;             {Bottom edge of absolute check box row}
    FormBot      : integer;             {Bottom edge of formula label}
    RchkBot      : integer;             {Bottom edge of relative check box row}
    RelBot       : integer;             {Bottom edge of "Relative"}
    LrgRowHite   : integer;             {Height of any label or field rectangle}
    TabRowHite   : integer;             {Height of any label or field rectangle}


   {$S PRdialog}
    procedure CreatePBtn(theBtn : buttonX; btnProc : procPtr; btnNum : integer; offset : integer);
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       {Put up the Next button}
       with theBtn^ do begin
          buttonNum := btnNum;
          SetRect(environ, repBtnLeft, repBtnTop, DialogFolder^.portrect.right, repBtnBot);
          procX := btnProc;
          buttonLeft := coDH + PrevH + offset;
          buttonTop  := BDistFromTop
       end;
       PutButton(theBtn, false)
    end;


   {$S PRdialog}
    procedure CreateChkRow(var chk : chkRow; bottom : integer);
    var chkRect : rect;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       {Set up chkRowA, the descriptor for the absolute row of check boxes.}
       with chk do begin
          procX  := @CheckHit;
          SetRect(chkRect, ChkLeft, bottom - TabRowHite, ButLeftEdge, bottom);
          ChkFldH := CreateField(chkRect, maxDiStrng + 1, 0, left, 0, 1, 0, TblFntId.Fam, true);
          ChkFldH^^.curlen := 0; {Is this necessary?}
       end;
       putChkRow(@chk)
    end;


   {$S PRdialog}
    procedure CreateLbl(theLbl : lblFldX; menuItem : integer; Bottom : integer; theStr : PtrStrType);
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       with theLbl^ do begin
          if theStr <> nil then begin
             lbl     := lNull;
             lStr    := theStr;
             theStr^ := '';
          end
          else begin
                  lbl := lMenu;
                  lMenuNum  := MenuBuzz;
                  lMenuItem := menuItem
               end;
          SetRect(lblBox, ChkLeft, Bottom - LrgRowHite, ButLeftEdge, Bottom);
          lblH := RepLblH + ChkLeft;
          lblV := RepLblV + Bottom - LrgRowHite;
          assocFldH := nil;
          assocFSH  := nil;
       end;
       putDiLbl(theLbl)
    end;


{$S PRdialog}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(212);
{$ENDC }
   {First check to see if there really is a dialog necessary}
   numChkBytes  := PRStrLength + 1;
   numCellBytes := maxCoLen + 1;
   mmGetPRinfo(@dummyAArray, @formBytes, @dummyBArray, numChkBytes,
               @cellBytes, numCellBytes, rThereBtns, mmFirst);
   if not(rThereBtns.next or rThereBtns.curr) then begin
      forceCalc(true);
      chgStatPnl(false);
      SetUndo(uPasteRel, tblPnl)
   end
   else begin

           {calculate dialog box height from font information}
           LrgRowHite := LrgFInfo.Descent + LrgFInfo.Ascent + 2;
           TabRowHite := tblFInfo.Descent + tblFInfo.Ascent + 2;
           RepLblV    := LrgFInfo.Ascent + 2;
           SameBot    := pnlLineDv + LrgRowHite + 5;
           AchkBot    := SameBot + TabRowHite;
           FormBot    := AchkBot + LrgRowHite;
           RchkBot    := FormBot + TabRowHite - LrgFInfo.Descent + 1;
           RelBot     := RchkBot + LrgRowHite + tblFInfo.Descent;
           RepBoxDv   := RelBot + 4;
           curDiBox   := diReplicate;

           {Put all constant parts into the Dialog Box first: The labels, buttons, graphics, and
            the constant parts of the Check Rows and of the formula label
           }
           AddDiBox(RepBoxDv, @doRepBox, @endRepBox, false, false);

           {Tell diMgr about the special routine to draw graphics in the Replicate Dialog Box}
           PutGraphics(@RepGrafix);

           ButWidth := CalcButWidth(0, 1, ButHeight);
           PrevH    := ButWidth div 2;
           NextH    := ButWidth div 3;

           {Put up the Prev button}
           CreatePBtn(@prevBtn, @PrevHit, BtnPrevious, 0);
           CreatePBtn(@nextBtn, @NextHit, BtnNext, ButWidth + NextH);

           {Set up the empty "Cell: " display}
           with lblA do begin
              lbl  := lNull;
              lStr := @tempLabel;
              tempLabel := '';
              SetRect(lblBox, 0, 0, coDh, pnlLineDv);
              lblH := RepLblH;
              lblV := RepLblV;
              assocFldH := nil;
              assocFSH  := nil;
           end;
           putDiLbl(@lblA);


           {Set up the "Formula:" label}
           with lblB do begin
              lbl       := lMenu;
              lMenuNum  := MenuStat;
              lMenuItem := PRFormItem;
              GetItem(myMenus[lMenuNum], lMenuItem, @tempLabel);
              TextFont(sysText);
              ChkLeft  := StringWidth(tempLabel) + StringWidth(' ') + FormLeft;
              SetRect(lblBox, FormLeft, FormBot - LrgRowHite, ChkLeft, FormBot);
              lblH := RepLblH + FormLeft;
              lblV := RepLblV + FormBot - LrgRowHite;
              assocFldH := nil;
              assocFSH  := nil
           end;
           putDiLbl(@lblB);

           createLbl(@lblC, 0, FormBot, @formLabel);{Set up the label for the formula itself.   Note:
                                                         this should be the third label initialized to
                                                         correspond to the const FormLblNum in aplc/Comgr}
           createLbl(@lblD, SameItem, SameBot, nil);
           createLbl(@lblE, RelItem, RelBot, nil);

           {Set up the abs/rel check box row descriptors}
           CreateChkRow(chkRowA, AchkBot);
           CreateChkRow(chkRowR, RchkBot);

           {Put up the varying part of the replicate dialog box: The cell
            coordinates, the check boxes, and the formula itself}
           putNewRep(mmLast, true, done);
        end
end;


{$S StatusDiBox }
procedure PutStatusBox;
var statusRec : statusInfo;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   ClrUndo;
   addDiBox(StatDiSize, @rmvDiBox, nil, false, true);
   GetLisaDrawPic('{T3}StatusBox');
   g.pnlToEnter := g.pnlwithChg;
   g.ActivePnl  := dialogPnl;
   curDiBox     := diStatus;
   PutGraphics(@DrawDialog)
end;


(*$S DiSeg *)
procedure removeDiBox ;  { remove the dialogue box--formerly within disMissDi }
var endTime : longint;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug}
   if traceDi then lcTraceMess(224);
{$ENDC}
   SetPnlPort(DialogPnl);
   PushButn(BtnGoAway, true);
   endTime := time + 10;
   repeat until time > endTime;
   case curDiBox of
      diCircle,
      diPrint,
      diFind,
      diColWid,
      diPrecision,
      diReplicate,
      diXAxis,
      diYAxis : buttonWasPushed(BtnGoAway)
   end { case }
end;  { removeDiBox }


{$S PRdialog}
procedure RepGrafix;
        {Draw the graphical portions of the replicate dialog box: for now,
         just the lines around the Cell display.}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

{$IFC fDebug }
   if traceDi then LCtraceMess(213);
{$ENDC }
   SetPnlPort(dialogPnl);
   PenNormal;
   MoveTo(0, pnlLineDv);
   LineTo(coDh, pnlLineDv);
   LineTo(coDh, 0)
end;


{$S funcHints }
procedure DiBoxScroll{where : point; myhsbHit : Thsb; myIconHit : TIcon};
var offset     : integer;
    newThumb   : integer;
    rightMost  : integer;
    bottomMost : integer;
    temp       : integer;
    hOffset    : point;
    scrolling  : boolean;
    paging     : boolean;
    horiz      : boolean;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   scrolling := (myIconHit <> IconThumb);
   paging    := (myIconHit = IconPagA) or (myIconHit = IconPagB);
   horiz     := (myhsbHit = hsbHDiag);
   SetPnlPort(DialogPnl);
   if scrolling then PaintArw(myHSBHit, myIconHit, true);

   with HintsPicture^^.PicFrame do begin
      rightMost  := (right - left) * 3 div 4;
      bottomMost := (bottom - top) * 3 div 4
   end;

   case myIconHit of
      IconThumb : with HintsPicture^^.PicFrame do begin
                     DragThumb(myHsbHit, where, NewThumb);
                     SetThumb(myHsbHit, NewThumb);

                     if horiz then offset := ord4(newThumb) * rightMost div 1000 - HintsOffset.h
                     else offset := ord4(newThumb) * bottomMost div 1000 - HintsOffset.v
                  end;
      IconArwA : offset := -20;
      IconArwB : offset := 20;
      IconPagA,
      IconPagB : with scrollArea do begin
                    if myhsbHit = hsbHDiag then offset := right - left - 100
                    else offset := bottom - top - 20;
                    if myIconHit = IconPagA then offset := -offset
                 end
   end;

   hOffset.h := 0;
   hOffset.v := 0;
   if horiz then hOffset.h := offset
   else hOffset.v := offset;

   repeat

      if scrolling then begin
         temp := HintsOffset.v + hOffset.v;
         if temp > bottomMost then hOffset.v := bottomMost - HintsOffset.v
         else if temp < 0 then begin
                 if paging then hOffset.v := -HintsOffset.v
                 else hOffset.v := 0
              end;

         temp := HintsOffset.h + hOffset.h;
         if temp > rightMost then hOffset.h := rightMost - HintsOffset.h
         else if temp < 0 then begin
                 if paging then hOffset.h := -HintsOffset.h
                 else hOffset.h := 0
              end
      end;

      if (hOffset.h <> 0) or (hOffset.v <> 0) or not scrolling then begin
         SetPnlPort(DialogPnl);
         ClipRect(scrollArea);
         HintsOffset.h := HintsOffset.h + hOffset.h;
         HintsOffset.v := HintsOffset.v + hOffset.v;
         scrollRect(scrollArea, -hOffset.h, -hOffset.v, thePort^.clipRgn);

         OffSetRgn(thePort^.clipRgn, HintsOffset.h, HintsOffset.v);
         SetOrigin(HintsOffset.h, HintsOffset.v);
         drawPicture(HintsPicture, HintsPicture^^.picFrame);

         if scrolling then begin
            with HintsPicture^^.PicFrame do
               if horiz then newThumb := ord4(HintsOffset.h) * 1000 div rightMost
               else newThumb := ord4(HintsOffset.v) * 1000 div bottomMost;
            SetPnlPort(DialogPnl);
            SetUpMvThumb(myhsbHit);
            MoveThumb(newThumb)
         end

      end
   until not(scrolling and stilldown);

   if scrolling then begin
      SetPnlPort(DialogPnl);
      PaintArw(myHSBHit, myIconHit, false)
   end
end;


{$S specialDiSeg}
procedure StdRectProc{verb : grafVerb; r : rect};
var box : integer;
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   if verb = fill then begin
      box := ChkBoxNum;
      if box > 0 then
         with DialogFolder^ do
            if chkBoxInfo.boxes[true].b[box] then fillPat := black
            else fillPat := white
   end;
   StdRect(verb, r)
end;


{$S specialDiSeg}
procedure StdTextProc{count : integer; textAddr : QDPtr; numer, denom : point};
var dPtr         : ptrData;
    messageNum   : longint;
    message      : str255;
    titleTab     : str255;
    number       : str80;
    chrCnt       : integer;
    x            : integer;
    temp         : integer;
    textPos      : integer;
    textIndex    : integer;
    messageIndex : integer;
    numBytes     : integer;
    done         : boolean;
    theRange     : range;
    curFInfo     : FontInfo;

    {$S StatusDiBox}
    procedure StatInfo;
    var scient    : boolean;
        xNumber   : extended;
        myVof100  : extended;
        sNumber   : resultStr;
        statusRec : statusInfo;
        errNum    : integer;
        ds_refNum : integer;
        info_rec  : DSInfoRec;
    begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

       GetStatusInfo(messageIndex, statusRec);
       Info_Address(errNum, ord(theHeap), ds_refNum);
       if errNum = 0 then Info_DataSeg(errNum, ds_refNum, info_rec);
       case messageIndex of
          1 : messageNum := statusRec.scrapHeapSize;
          2 : messageNum := statusRec.modelSize;
          3 : messageNum := statusRec.formulaCount;
          4 : messageNum := statusRec.valueCount;
          5 : messageNum := FinalSnip(rowKind);
          6 : messageNum := FinalSnip(colKind);
          7 : messageNum := openTime;
          8 : messageNum := mmMemSize;
          9 : messageNum := mmDiskSize;
         10 : messageNum := calcTime;
         11 : messageNum := numHandles;
         12 : messageNum := numpasses;
         13 : messageNum := info_rec.mem_size;
         14 : messageNum := info_rec.disc_size;
       end;

       L2X(messageNum, xNumber);
       case messageIndex of
          7, 10 : begin
                     I2X(100, myVof100);
                     DivX(myVof100, xNumber)
                  end
       end;
       rstr(xNumber, sNumber, 0, 0, 7, scient);
       number := sNumber
    end;


{$S specialDiSeg}
begin
(*$IFC fTraceLC *) LogCall; (*$ENDC *)

   dPtr      := pointer(ord(textAddr));
   message   := '';
   textIndex := 0;
   while textIndex < count do begin
      number       := ' ';
      number[1]    := cChr(dPtr^[textIndex]);
      messageNum   := -1;
      messageIndex := 0;
      if number = 'Â' then begin
         done         := false;
         while (textIndex < count) and not done do begin
            textIndex := textIndex + 1;
            x := ord(dPtr^[textIndex]) - 48;
            if (x >= 0) and (x <= 9) then messageIndex := messageIndex * 10 + x
            else done := true
         end;
         case curDiBox of
            diStatus : StatInfo;
            diCircle : begin
                          if messageIndex = 1 then theRange := g.curRange
                          else begin
                                  if circleRg.rKind = aNullRg then exit(StdTextProc);
                                  theRange := circleRg
                               end;

                          getRgName(theRange, pointer(ord(@number)+1), numBytes);
                          number[0] := chr(numBytes)
                       end
         end
      end
      else if number = '¡' then exit(StdTextProc)
      else if number = 'Ä' then begin
              if textIndex + 1 < count then messageIndex := ord(dPtr^[textIndex + 1]) - 48;
              if (messageIndex >= 1) and (messageIndex <= 4) then begin
                 x         := textIndex;
                 textIndex := textIndex + 2;
                 chrCnt    := 2;
                 done      := false;
                 while (textIndex < count) and not done do begin
                    done := (cChr(dPtr^[textIndex]) <> 'Ä');
                    if not done then begin
                       chrCnt    := chrCnt + 1;
                       textIndex := textIndex + 1
                    end
                 end;
                 if inPutGrahics then begin
                    with diHfld[messageIndex]^^ do begin
                       curlen := maxlen;
                       case curDiBox of
                          diFind : xStoB(StrToFind, curvalue^, curlen);
                       end;
                       GetFontInfo(curFInfo);
                       temp := textWidth(@dPtr^[0], 0, x);
                       with curFInfo, thePort^.pnLoc do
                          SetRect(coords, h + temp, v - ascent - descent + 1,
                                         CMin(ButLeftEdge, h + temp + textWidth(@dPtr^[0], x, chrCnt)), v + descent)
                    end;
                    InitFstate(diHfld[messageIndex], diHfs[messageIndex])
                 end;
                 number[0] := chr(Cmin(chrCnt, sizeof(number) - 2));
                 for x := 1 to ord(number[0]) do number[x] := ' '
              end
              else textIndex := textIndex + 1
           end
      else textIndex := textIndex + 1;
      message := concat(message, number)
   end;
   StdText(length(message), pointer(ord(@message) + 1), numer, denom)
end;




ÿ