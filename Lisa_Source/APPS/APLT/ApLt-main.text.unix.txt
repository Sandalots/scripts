{ Copyright 1983, Apple Computer, Inc. }

program TE;
  {TE is the terminal emulator, called LisaTerminal.  For global information on}
  {LisaTerminal, see the document "LisaTerminal General Concepts".}


{$SETC RangeCheck := FALSE }
{$SETC DebugOn    := FALSE }
{$SETC WrapDebug  := FALSE }    {Debuging of word wrap}                                         {[JS]}
{$SETC ZoneDebug  := FALSE }    {Debuging of the folder zones}                                  {[JS]}
{$SETC Ouch       := FALSE }    {'Ouch' on GoAway}                                              {[JS]}
{$SETC DbgRuler   := FALSE }    {Debuging of the tab and column rulers}                         {[JS]}
{$SETC DbgRlrUpdates := FALSE}  {Debuging of the tab and column rulers updates}                 {[JS]}
{$SETC DbgSizeTerm := FALSE }   {Debuging number of calls to SizeTerm}                          {[JS]}
{$SETC DbgCursor  := FALSE }    {Debuging cursor tracking}                                      {[JS]}

{$SETC PrintTime  := False }    {Histogram of UpdateTerm timings.}

{$SETC DbgHeap    := False }    {Trace heap expansion.}
{$SETC Scramble   := False }    {Use the scrambling heap.  Scramble and check are}
                                {on initially.  command-1 to turn scramble off.}
                                {               command-2 to turn scramble on .}
                                {               command-3 to turn checking off.}
                                {               command-4 to turn checking on .}
{$SETC NrHandles  := False }    {Trace number of relocatable blocks (On initially.}
                                {               command-5 to turn off.}
                                {               command-6 to turn on .}

{$SETC FindDecr   := False }    {See if TheTerm's HBlinker's have changed.}

{$SETC UpdateFreq := FALSE }    {Ask person testing if they want to set update
                                 frequency variables, when they hit apple 7}
{$SETC SampCalls  := False }    {If true then all procedure calls are traced}

  uses
     {$IFC SampCalls}
     {$U aplt/tracecalls.obj} tracecalls,
     {$ENDC}
     HWInt,
     UnitStd,
     UnitHz,
     Storage,
     Quickdraw,
     FontMgr,
     GrafUtil,
    {$U libos/SysCall.obj } SysCall,
    {$U libos/PSysCall.obj} PSysCall,
     Events,
     Folders,
     Menus,
     FilerCom,
     WmlStd,
     WmlGrow,
     WmlSB,
     WmlCrs,
    {$U ApLt/DMgr     } DMgr,
     PMDecl,
     PMM,
     PrStdInfo,
     PrPublic,
     AlertMgr,
     UnitFmt,
     UnitCS,
     Scrap;

  const
    MinCol=1;           {Dimensions of active screen.}
    MaxCol=132;
    MinRow=1;
    MaxRow=24;

    HeapLdsn=4;         {LDSN of TheHeap.}
    HeapInit=32768;     {Initial size of TheHeap.}

    HeapExtra=1024;     {Extra bytes to allocate on the heap if we can.}

    MaxMem_Extra=18432; {Maximum space between heap and memory for normal   state (18K).}
    MinMem_Extra=16384; {Minimum space between heap and memory for normal   state (16K).}
    WrnMem_Extra=8192;  {        Space between heap and memory for warning  state ( 8`12K).}
    CrtMem_Extra=0;     {        Space between heap and memory for critical state ( 0K).}

    MaxDiskExtra=16384; {Maximum space between memory and disk for normal   state (16K).}
    MinDiskExtra=0;     {Minimum space between memory and disk for normal   state ( 0K).}
    WrnDiskExtra=0;     {        Space between memory and disk for warning  state ( 0K).}
    CrtDiskExtra=0;     {        Space between memory and disk for critical state ( 0K).}

    UpDelay=15;         {1/100 sec for same Where on multi-click.}
    DownDelay=15;

    HMargin=4;          {Pixel margins around text regions.}
    VMargin=3;

    BtnBWidth= 1;       {Width of border around a button}                                           {[JS]}
    BtnBHeight= 1;      {Height of border around a button}                                          {[JS]}
    BtnOvalHeight= 12;  {Oval Height of corners of ruler button}                                    {[JS]}
    BtnOvalWidth= 18;   {Oval Width of corners of ruler button}                                     {[JS]}

    VRulerSpace= 1;     {Vertical space between elements on the tab/column ruler}                   {[JS]}
    TicSpace=10;        {Space between numbers.}                                                    {[JS]}
    RulSpace=5;         {Space between big ruler marks.}                                            {[JS]}

    TopHysteresis=30;   {Line hysteresis on select in percent.}
    BotHysteresis=50;

    PaocSize=80;        {Size of data flow paths (see above).}
    ScrBufSize=511;     {Size of the default scrap buffer (see MySeqLpd).}
    HSBuffer=512;       {Size of the handshaking buffer (>=64) (see InitConsts).}
    MaxParm=10;         {Maximum number of parameters in VT100 sequences.}

    NrRowsInit=30;      {Initial number of rows in cache pages.}
    NrRowsBump=10;      {Increase in number of rows in cache pages.}
    PageInit=1024;      {Initial page size.}
    PageBump=2048;      {Increase in page size.}
    LTBigCache=1500;    {LinesInCache to alert for large cache.}
    VeryBigCache=32000; {Limit to # of Lines in Cache- turn remember off and
                         alert user}

    StatName='L1';      {The first status light mnemonic.}
    ParityChar=$FF;     {Character in PAOC's for a bad parity character.}
    ParityVis='a';      {Character in Lines  for a bad parity character.}

    p12TileLT=26;       {VT100 Fonts}
    p20TileLT=27;
    p12Graf=17;         {Graphic fonts}
    p20Graf=23;

    SerialA=True;
    SerialB=False;

    Driver=32;          {Serial Driver ID}
    ModemDriver=42;     {Serial Modem Driver ID}

    NullMenu = 0;       {The menus ...}

    FilPrt=2;           {File/Print}
      FPClosAll=1;        {Set Aside Everything      }
      FPClose=2;          {Set Aside "..."           }
      FPBlank1=3;         { - - - - - - - - - - - - -}
      FPPutBack=4;        {Save & Put Away           }
      FPSave=5;           {Save & Continue           }
      FPRevert=6;         {Revert to Previous Version}
      FPBlank2=7;         { - - - - - - - - - - - - -}
      FPPrintAsIs=8;      {Print As Is               }
      FPRoute=9;          {Format for Printer...     }
      FPPrint=10;         {Print...                  }
      FPIntend=11;        {Monitor the Printer...    }

    EditMenu=3;         {Edit}
      EditUndo=1;         {Undo Last Change      }
      Edit1Blank=2;       { - - - - - - - - - - -}
      EditCut=3;          {Cut                   }
      EditCopy=4;         {Copy                  }
      EditCopColumns=5;   {Copy Columns          }
      EditPaste=6;        {Paste                 }
      Edit2Blank=7;       { - - - - - - - - - - -}
      EditErase=8;        {Clear Lines Off Top   }
      Edit3Blank=9;       { - - - - - - - - - - -}
      EditAll=10;         {Select All of Document}

    SetupMenu=4;        {Setup}
      SetupCompat=1;      {Computer Compatibility...   }
      SetupCmfort=2;      {Comfort...                  }
      SetupCustom=3;      {Custom Functions...         }
      SetCharSets=4;      {Set and Select Character Sets}
      Setup1Blank=5;      { - - - - - - - - - - - - - -}
      SetupAnswrBk=6;     {Change Answerback Message...}

    RulerMenu=5;        {Ruler Menu}
      ShowTabRuler=1;
      ShowColumnRuler=2;
      HideRulers=3;
      Ruler1Blank=4;
      SetTabEvery8=5;
      ClearTabs=6;
      Ruler2Blank=7;
      ClearColumns=8;

    DialMenu=6;         {Phone}
      DialDial=1;         {Dial "..."           }
      DialChange=2;       {Enter Phone Number...}
      DialBlank=3;        { - - - - - - - - - - }
      DialHangUp=4;       {Hang Up              }

    MsgMenu=7;          {Messages in this menu are used for prompts and in alerts.}
      MsgPhone=1;         {Phone Number?}
      MsgAnswrBk=2;       {Answerback Message?}
      MsgPrefixDisk=3;    {the startup disk}
      MsgToolDisk=4;      {the disk containing the LisaTerminal tool}

    ScrapFile=8;        {File/Print}    {Menu for when scrap is the active folder.}
      ScrClosAll=1;       {Set Aside Everything}
      ScrClose=2;         {Set Aside "..."     }

    FirstMenu=FilPrt;           {The first menu to read and to show.}
    LastVisMenu=RulerMenu;      {The last  menu             to show.}
    LastMenu=ScrapFile;         {The last  menu to read            .}

    DBDoForget=0;       {Dialog box forms ...}
      DBSet=1;
      DBClr=2;

    DBTerminal=1;       {Computer Compatibility dialog box form.}
      DBvt100=1;
      DBvt52=2;
      DBtty=3;

    DBPortA=2;
    DBBaudRate=3;
      DB50=1;
      DB75=2;
      DB110=3;
      DB134_5=4;
      DB150=5;
      DB200=6;
      DB300=7;
      DB600=8;
      DB1200=9;
      DB1800=10;
      DB2000=11;
      DB2400=12;
      DB3600=13;
      DB4800=14;
      DB9600=15;
      DB19200=16;

    DBParity=4;
      DBNoParity=1;
      DBEvenParity=2;
      DBOddParity=3;

    DBXOnXOff=5;
    DBFullDuplex=6;
    DBOnLine=7;
    DBAutoLF=8;

    DBModem=9;
      DBHayes1200=1;
      DBHayes300=2;
      DBOther=3;

    DBDial=10;

    DBAutoRepeat=1;     {Comfort dialog box form.}
    DBMarginBell=2;
    DBCols80=3;
    DBWraparound=4;
    DBWordWrap=5;
    DBWhiteScreen=6;
    DBBlockCursor=7;
    DBSeeLights=8;
    DBRunoff=9;

    DBBit3=1;           {Custom Functions dialog box form.}
    DBBit2=2;
    DBBit1=3;
    DBBit0=4;

    DBChooseCharSet=1;  {Set and Select Char Set dialog box form}
      GroupG0=1;
      GroupG1=2;

    DBG0=2;
      GraphCharSet=1;
      ASCIICharSet=2;
      UKCharSet=3;
      E47SwedishFinnish=4;
      D47SwedishFinnish=5;
      Norwegian=6;
      Danish=7;
      German=8;
      French=9;
      FrenchCanadian=10;
      Spanish=11;
      Italian=12;
      Yugoslavian=13;

    DBG1=3;

    ALDefd1=1;          {Alerts.}
    ALDefd2=2;
    ALDefd3=3;
    ALDefd4=4;

    ALNilCopy=7;        {See phrase file for comments.}
    ALDocRead=8;
    ALDocWrite=9;
    ALUart=10;
    ALBigCache=11;
    ALDisconnect=12;
    ALBadDev=13;
    ALNilPaste=14;
    ALCantDial=15;
    ALDialing=16;
    AL300=17;
    AL1200=18;
    ALCantConnect=19;
    ALBaudModem=20;
    ALBaudPort=21;
    ALForceModem=22;
    ALHangUp=23;
    ALXOff=24;
    ALInUse=25;
    ALHeapFull=26;
    ALCopyStop=27;
    ALHeapDead=28;
    ALForceXOn=29;
    ALNoCache=30;
    ALNoBody=31;
    ALTalking=32;
      ABtnHangUp=1;
      ABtnContinue=2;
    ALSetDial=33;
    ALDialed=34;
    ALHungUp=35;
    ALWasTalking=36;
    ALIsTalking=37;
    ALStopCache=38;
    ALEmptyScrap=39;
    ALActivateMe=40;
    ALKilledCache=41;
    ALDefaultCharSet=42;
    AlRevrtNew=43;
    AlRevrtOld=44;
    AlCacheMuchTooBig=45;
    AlCantRemember=46;
    AlSave=47;
    AlBadPass=48;
    AlGoAway=200;                   {Button text for tab & column rulers: Go Away}              {[JS]}
    AlSetTab=201;                   {Button text for tab ruler: Set Tab}                        {[JS]}
    AlClrTab=202;                   {Button text for tab ruler: Clear Tab}                      {[JS]}
    AlSetColumn=203;                {Button text for column ruler: Set Column}                  {[JS]}
    AlClrColumn=204;                {Button text for column ruler: Clear Column}                {[JS]}

  type
    Str30=String [30];
    Str40=String [40];
    PPaoc=^Paoc;
    Paoc=packed array [1..PaocSize] of Char;    {Used to route data in Receive.}

    THeapState=(HeapNormal, HeapWarning, HeapCritical);

    TBase=(RulerBase, ScreenBase, LineBase);
    TVert=(AtTop, AtBaseLine, AtBottom);

    TFormNr=SetupCompat..SetCharSets;           {Dialog Box forms.}
    TForm=record
      HCkForm: TCkFormHnd;
      LastItem: Integer;
    end;

    THayesReply=(OKReply, Connect, Ring, NoCarrier, Error, Connect1200);

    TCharacter=packed record
      Ch: Char;

      Bold: Boolean;
      Underscore: Boolean;
      Blink: Boolean;
      Negative: Boolean;
      Graphic: Boolean;
    end;

    TPLine=^TLine;
    THLine=^TPLine;
    TLine=record
      TextLine: array [MinCol..MaxCol] of TCharacter;
      SeqNr: LongInt;           {Unique name for this line.}
      Cached: Boolean;          {Was this line retrieved from the cache?}
      Changed: Boolean;         {Has this line changed?}
      Repaint: Boolean;         {Has it changed alot?}

      TwoHigh: Boolean;         {Is this line double height?}
      TwoTop: Boolean;          {Is this the top of a TwoHigh line?}
      TwoWide: Boolean;         {Is this line double width?}
    end;

    TRowList=array [1..50] of THLine;

    TZone=(TextBox,             {Text area of screen (inset by xMargins).}
           RulerBox,            {Ruler area (inset).}                                   {[JS]}
           VScrollBox,          {Vertical scroll bar.}
           HScrollBox,          {Horizontal scroll bar.}
           GrowBox,             {Grow icon.}
           VGreyBox,            {Grey area to the right of BTextBox and BRulerBox.}
           HGreyBox,            {Grey area below BTextBox}
           StatBox,             {Base status lights' area.}
           BTextBox,            {Base text area.}
           BRulerBox,           {Base ruler area.}
           GoAway,              {Go Away buton .}                                       {[JS]}
           SetTabOrColumn,      {Set Tab or Set Column button.}                         {[JS]}
           ClrTabOrColumn,      {Clear Tab or Set Column button.}                       {[JS]}
           Divide,              {The dividing line above the Screen.}
           Elsewhere);

    TScreen=array [MinRow..MaxRow] of THLine;
    TLights=array [1..4] of Boolean;
    TTabStops=packed array [MinCol..MaxCol] of Boolean;
    TColumnStops = PACKED ARRAY[MinCol..MaxCol] OF BOOLEAN;                             {[JS]}

    TDBSetClr=DBSet..DBClr;     {Types used in Setup and dialog box forms.}
    TDBTerminal=DBvt100..DBtty;
    TDBBaud=DB50..DB19200;
    TDBParity=DBNoParity..DBOddParity;
    TDBModem=DBHayes1200..DBOther;
    TDBCharGroup=GroupG0..GroupG1;
    TDBCharSet=GraphCharSet..Yugoslavian;

    TSetup=record
      ADNumber: Str40;          {The auto-dial number.}
      AnswrBk: Str40;           {The answerback message.}
      Modem: TDBModem;          {The type of modem used.}
      AutoDial: Boolean;        {Should dial when installed?}

      AutoRepeat: Boolean;      {Do keys repeat?}
      MarginBell: Boolean;      {Ring bell near margin?}
      Cols80: Boolean;          {80 (else 132) columns per line?}
      Wraparound: Boolean;      {Does 80(132) col's mean peg or CR/LF?}
      AutoLF: Boolean;          {Does CR imply LF?}
      WhiteScreen: Boolean;     {Is background white (else Black)?}
      BlockCursor: Boolean;     {Is cursor a block (else a bar)?}
      SeeLights: Boolean;       {Are status lights visible?}
      SeeTabs: Boolean;         {Is the tab ruler visible?}
      SeeColumns: Boolean;      {Is the column ruler visible?}
      Runoff: Boolean;          {Should scrolled lines be cached?}

      Terminal: TDBTerminal;    {Is mode VT100 (ANSII), VT52, or TTY?}
      PortA: Boolean;           {Communicate with port A or B?}
      BaudRate: TDBBaud;        {Baud for communication.}
      Parity: TDBParity;        {Parity mode.}
      XOnXOff: Boolean;         {Handshake mode.}
      FullDuplex: Boolean;      {Full- or half-duplex?}
      OnLine: Boolean;          {OnLine or Local?}
      PhoneVis: Boolean;        {Phone menu visible?}
      WordWrap: BOOLEAN;        {Is the word wrapping enabled?}                     {[JS]}
      WrapPoint: INTEGER;       {The word wrapping point}                           {[JS]}
    end;

    TPorts = SerialB..SerialA;

    TTrix=packed record         {Trick to map characters to integers.}
      case Integer of           {15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0}
        0: (Ch: TCharacter);    {-------- Ch.Ch -------- ---- Ch.Attributes ----}
        1: (Ch1: Char;          {--------- Ch1 --------- --------- Ch2 ---------}
            Ch2: Char);
        2: (Int: Integer);      {--------------------- Int ---------------------}
    end;

    TNrTrix=packed record       {Trick to map LongInts to bytes (Char's).}
      case Integer of
        0: (Nr: LongInt);
        1: (Ch0: Char;
            Ch1: Char;
            Ch2: Char;
            Ch3: Char);
    end;

    TBoolTrix=packed record     {Trick to map booleans into a character.}
      case Integer of
        0: (Fill0: Char;
            Bool0: Boolean;
            Bool1: Boolean;
            Bool2: Boolean;
            Bool3: Boolean;
            Bool4: Boolean;
            Bool5: Boolean;
            Bool6: Boolean;
            Bool7: Boolean);

        1: (Fill1: Char;
            Char0: Char);
    end;

    TPBlinkItem=^TBlinkItem;    {Inversion area.  List head is BlinkList.}
    THBlinkItem=^TPBlinkItem;
    TBlinkItem=record
      Prev: THBlinkItem;        {Double-linked list.}
      Next: THBlinkItem;

      BlinkArea: RgnHandle;     {The region that is inverted.}
      Folder: WindowPtr;        {The folder that contains the inverted area.}

      Solid: Boolean;           {Is BlinkArea inverted when BlinkVis=False?}
      ShouldBeSolid: Boolean;   {Should Solid be set False when BlinkVis -> True?}
    end;

    TPosition=record            {A place in a document.}
      Ln: INTEGER;
      Ch: Integer;
    end;

    TRange=record               {A range in a document.}
      Left: TPosition;
      Right: TPosition;
    end;

    TPPage=^TPage;              {A page of a Cache.}
    THPage=^TPPage;
    TPage=record
      Prev: THPage;
      LinesInPage: Integer;     {Number of rows in Page.}
      PageSize: Integer;        {Number of bytes in Page.}
      Page: packed array [1..32000] of Char;    {The page of compacted rows.}
    end;

    TPCache=^TCache;            {A bunch of compacted rows.}
    THCache=^TPCache;
    TCache=record
      LastPage: THPage;         {The last page in this cache.}
      WritePtr: Integer;        {Where to write in Cache^^.LastPage.}
      NrRowsCached: Integer;    {Current desired number of rows in this page.}
      NrPages: Integer;         {Number of pages in this cache.}
      LinesInCache: Integer;    {Number of lines in this cache.}
      SeqLine: Integer;         {Save row  # for sequential rowio}
      SeqPage: THPage;          {Save page # for sequential rowio}
      SeqIdx: Integer;          {Save seq  # for sequential rowio}
    end;

    TSTP=packed record          {Trick to map a nybble to four booleans.}
      case integer of
        0: (FillA: Char;
            FillB: 0..15;
            Value: 0..15);

        1: (FillC: Char;
            FillD: 0..15;
            Bit3: Boolean;
            Bit2: Boolean;
            Bit1: Boolean;
            Bit0: Boolean);
    end;

    TButton=    (NoButton, GoAwayButton, SetButton, ClrButton);   {Wich button is hit?}   {[JS]}
    Moment=     (AtPaint, RightNow);    {Which state of the screen?}

    TDisplay=   RECORD
        Screen:     TScreen;                {Active part of the screen.}
        MoveArray:  RECORD                  {To copy this part of TDisplay.}        {BEGIN MoveArray [JS]}
            StartScreen:    INTEGER;        {Line number of Screen [MinRow].}

            Lights:         TLights;        {Status lights.}
            TabStops:       TTabStops;      {Tab stops.}
            ColumnStops:    TColumnStops;   {Column stops.}                         {[JS]}
            Position:       INTEGER;        {The position marker on the ruler}      {[JS]}

            VisLights:      BOOLEAN;        {Are the lights visible?}
            VisTabs:        BOOLEAN;        {Are the tabs visible?}
            VisColumns:     BOOLEAN;        {Are the columns visible?}              {[JS]}

            FirstRow:       INTEGER;        {Line number of the first visible row.}
            NrRows:         INTEGER;        {Number of visible rows.}
            FirstCol:       INTEGER;        {Number of the first visible column.}
            NrCols:         INTEGER;        {Number of visible columns.}

            FolderZones: ARRAY [TextBox..Divide] OF Rect;   {Folder divided into rects.}

            HThumbPos:      INTEGER;        {Horizontal scroll thumb position.}
            VThumbPos:      INTEGER;        {Vertical   scroll thumb position.}

            VisWrap:        BOOLEAN;        {Is the word wrapping marker visible?}  {[JS]}
            VisWrapPoint:   INTEGER;        {The word wrapping point}               {[JS]}

            HitButton:      TButton;        {State of hit ruler button}             {[JS]}
            ShowGrayLine:   BOOLEAN;        {Showing gray line during ruler drag}   {[JS]}

            blTStop:        INTEGER;        {BaseLine of tab stop marks.}           {[JS]}
            blRuler:        INTEGER;        {BaseLine of ruler numbers.}            {[JS]}
            blTicMk:        INTEGER;        {BaseLine of tick marks.}               {[JS]}
            blPos:          INTEGER;        {BaseLine of pos marker.}               {[JS]}
            blWrap:         INTEGER;        {BaseLine of wrap marker.}              {[JS]}
            END;                                                                    {END MoveArray [JS]}
        END;

    TPStyle=^TStyle;            {A character set.}
    THStyle=^TPStyle;
    TStyle=record
      Font: TLFntID;            {Font.}

      VertSp: Integer;          {Height of a character.}
      Above: Integer;           {Pixels above baseline.}
      Below: Integer;           {Pixels below baseline.}

      HorzSp: Integer;          {Width of a character.}
    end;

    TParm=record                {A parameter of VT100 esc sequence <ESC>[x;y;zW .}
      Value: Integer;           {What is the value?}
      Default: Boolean;         {Was no number given for this value?}
    end;

    TParmList=record            {The parameters of <ESC>[x;y;zW .}
      Parm: array [1..MaxParm] of TParm;
      Special: Boolean;         {Of the form: <ESC>[?x;y;zW ?}
    end;


    TPTerm=^TTerm;              {A terminal.  List head is TermList.}
    THTerm=^TPTerm;
    TTerm=record
      Prev, Next: THTerm;       {Double-linked list.}

      ReadMe: Boolean;          {Does the document still need to be read?}
      ImBlank: Boolean;         {Is it from blank stationery?}
      OldVersion: Boolean;

      HCache: THCache;          {The cached runoff.}
      CacheTooBig: Boolean;     {Is the cache growing too large?}

      Setup: TSetup;            {Setup info.}
      FileName: Str30;          {Name of Setup file.}
      TheTitle: Str255;         {Folder name (on the tab).}
      MinUpdWait: Integer;      {Minimum time (in 1/100 seconds) before update.}

      RefNum: Integer;          {RefNum of UART channel.}
      UartOpen: Boolean;        {Is RefNum assigned?}
      OffHook: Boolean;         {Has the modem been dialed?}

      RecUartSeq: Paoc;         {Char's received from the UART.}
      RecUartLen: Integer;      {RecUartSeq length.}
      KbdEvent: EventRecord;    {Event received from the keyboard.}
      KbdReady: Boolean;        {KbdEvent defined?}
      ReplySeq: Paoc;           {Response characters from the terminal.}
      ReplyLen: Integer;        {ReplySeq length.}

      TermProc: ProcPtr;        {Terminal processing procedure.}
      ParmList: TParmList;      {List of parameters for VT100 sequences.}
      ParmNr: Integer;          {Index to the next parameter.}
      CursorSave: TPosition;    {Saved Cursor.}
      BaseSave: TCharacter;     {Saved BaseChar.}
      StyleSave: THStyle;       {Saved Style.}
      BaseChar: TCharacter;     {The base character attributes.}
      TMargin: Integer;         {Offset from StartScreen to first line of scrolling region.}
      BMargin: Integer;         {Offset from StartScreen to  last line of scrolling region.}
      TOrigin: Integer;         {First line that cursor can be on.}
      BOrigin: Integer;         {Last  line that cursor can be on.}
      TBOrigin: Boolean;        {Should cursor be limited to scroll region?}
      TellSetup: Boolean;       {Should we ReportParms after OK to EndSetup?}
      CursorKey: Boolean;       {Encode the cursor keys?}
      KeyPad: Boolean;          {Encode the keypad characters?}
      NextNewLine: Boolean;     {Should a CR/LF be sent before the next char?}
      STP: TSTP;                {STP option bits.}
      CharGroup: TDBCharGroup;  {Character set group (G0 or G1).}
      CharSet: array [TDBCharGroup] of TDBCharSet;  {What is each group's set?}

      Folder: WindowPtr;        {Window for this terminal.}
      SBList: TSBList;          {List of scroll bars.}
      VSBar: THSB;              {The vertical scroll bar.}
      HSBar: THSB;              {The horizontal scroll bar.}

      Style: THStyle;           {Font and its dimensions.}
      Display: array [Moment] of TDisplay;      {Display states.}
      Changed: Boolean;         {Display [RightNow] <> Display [AtPaint]?}
      Repaint: Boolean;         {Have we changed fonts, etc?}
      LastUpdate: LongInt;      {When did the last update happen?}
      NrChanges: Integer;       {Number of critical changes since last update.}

      Cursor: TPosition;        {Current cursor position.}
      CursorRect: THBlinkItem;  {Rectangle around the cursor.}
      Select: TRange;           {Current caret or selection.}
      CaretRect: THBlinkItem;   {Region of caret or selection.}
      BlinkRgn: THBlinkItem;    {Region of blinking text displayed.}
      InvertRgn: THBlinkItem;   {Region of inverted text displayed.}

      DivLights: Boolean;       {Should the lights be Split-Screened?}
      DivTabs: Boolean;         {Should the tab ruler be Split-Screened?}
      DivColumns: Boolean;      {Should the column ruler be Split-Screened?}                    {[JS]}
      ComeFromBlank: Boolean;   {Did document come from blank Stationery?}
      CacheMuchTooBig: Boolean; {Cache size reached 32000}
      CantRemember: Boolean;    {Cant remember if cache much too big}
      Password: E_Name;
    end;

    TClick=(Single, Double, Triple, Beyond);

    TPScrap=^TScrap;
    TScrap=record               {Information kept for the scrap.}
      Cs: TCs;                  {The Character Stream information.}
      HCache: THCache;          {The data in the scrap.}

      Style: THStyle;           {What font?}
      Use132Cols: Boolean;      {Is there a line over 80 chars long?}

      SBList: TSBList;          {The scroll bars.}
      VSBar: THSB;
      HSBar: THSB;

      LastFull: Boolean;        {Does the last line have any information?}
    end;

    TDocument=record            {Information saved on disk for a terminal.}
      dVersion: Char;
      dSaved: Boolean;
      dSetup: TSetup;
      dCursor: TPosition;
      dSelect: TRange;
      dLights: TLights;
      dTabStops: TTabStops;
      dFirstRow: Integer;
      dFirstCol: Integer;
      dCacheExists: Boolean;
      dCharGroup: TDBCharGroup;
      dCharSet: array[TDBCharGroup] of TDBCharSet;
      dColumnStops: TColumnStops;                                                       {[JS]}
    end;

    THMatch=^TPMatch;           {A range of lines that match.  Used in UpdateScreen.}
    TPMatch=^TMatch;
    TMatch=record
      Prev: THMatch;            {Double-linked list.}
      Next: THMatch;

      NewStart: Integer;        {First line of the match in the new (RightNow) lines.}
      OldStart: Integer;        {First line of the match in the old (AtPaint ) lines.}
      Len: Integer;
    end;

    TTalkReason=(TalkOK, TalkNotOk, PortInUse);

    TAlertType=(AlrtNote, AlrtStop, AlrtWait);

    THAlertSave=^TPAlertSave;   {Alert queue used to post alerts while inactive.}
    TPAlertSave=^TAlertSave;
    TAlertSave=record
      Prev: THAlertSave;        {Double-linked list.  Queue head is AlertHead.}
      Next: THAlertSave;        {                     Queue tail is AlertTail.}

      AlertNumber: Integer;     {What is the alert's number?}
      AlertKind: TAlertType;    {Note Alert?  Stop Alert?  Wait Alert?}

      Param1: TParamAlert;      {The parameters for the alert.}
      Param2: TParamAlert;
      Param3: TParamAlert;

      FromTerm: THTerm;         {The terminal associated with the alert.}
    end;

  var
    {Structured constants:}
      Copyright: string [49];   {Copyright notice.}


      DeskStyle: TLFntID;       {Menu style.}
      M80Style:  THStyle;       {80  column text    style.}
      G80Style:  THStyle;       {80  column graphic style.}
      M132Style: THStyle;       {132 column text    style.}
      G132Style: THStyle;       {132 column graphic style.}

      TabMark:      BitMap;                     {The tab stop mark bitmap.}                     {[JS]}
      TabMap:       ARRAY [1..5] OF INTEGER;    {The bits of TabMark.}                          {[JS]}
      ColumnMark:   BitMap;                     {The column mark bitmap.}                       {[JS]}
      ColMap:       ARRAY [1..5] OF INTEGER;    {The bits of ColumnMark.}                       {[JS]}
      PosMark:      BitMap;                     {The poition marker bitmap.}                    {[JS]}
      PosMap:       ARRAY [1..5] OF INTEGER;    {The bits of PosMark.}                          {[JS]}
      WrapMark:     BitMap;                     {The word wrap marker bitmap.}                  {[JS]}
      WrapMap:      ARRAY [1..6] OF INTEGER;    {The bits of WrapMark.}                         {[JS]}

      AlphaNum: set of Char;    {The alpha-numeric characters.}
      NUL, SOH, STX, ETX, EOT, ENQ, ACK, BELL, BS, HT, LF, VT, FF, CR,
      SO, SI, DLE, DC1, DC2, DC3, DC4, NAK, SYN, ETB, CAN, EM, SUB, ESC,
      FS, GS, RS, US, SP, DEL: Char;
      XON, XOFF: Char;          {Synonyms.}

      BlankChar: TCharacter;    {Blank, non-attributed character.}
      BlankLine: TLine;         {A line of blank characters.}
      ZeroRect: Rect;           {The empty rectangle.}

      SizeOfTerminal: Integer;  {Space needed on heap for a new terminal.}
      SizeOfTPage: Integer;     {SizeOf (TPage) without Page.}
      ScrapTerm: THTerm;        {Bogus handle to recognize the scrap folder.}

      GroupA: array [TDBParity] of DCType;      {Groups for Device_Select.}
      GroupB: array [Boolean] of DCType;
      GroupC: array [TDBBaud] of DCType;
      GroupD: DCType;
      GroupE: array [Boolean] of DCType;
      GroupF: array [Boolean] of DCType;
      GroupG: DCType;
      GroupH: DCType;
      GroupHRetry: DCType;
      GroupI: DCType;
      GroupX: array [Boolean] of DCType;
      GroupY: DCType;
      GroupZ: DCType;

      Password: E_Name;         {Password to Uart ports.}
      UartName  : array [Boolean] of PathName;    {The UART path names:   -RS232x-XXX.}
      UartPath  : array [Boolean] of E_Name;      {The UART device names:  RS232x    .}
      SerialName: array [Boolean] of Str30;       {The UART string:             x    .}

      HayesDrop: array [TDBParity] of Str30;    {Hayes modem disconnect message.}

      Excep_Name: T_Ex_Name;    {Name of the exceptions for TE.}

      GProcs: QDProcs;

    {Global variables:}
      TheMenus: array [FirstMenu..LastMenu] of MenuInfo;
      IntCharGroup: TDBCharSet; {used for setting default international char set}
      BaseFPClose: Str40;       {   FilPrt:FPClose  menu title.}
      BaseDialDial: Str40;      { DialMenu:DialDial menu title.}
      BaseScrClose: Str40;      {ScrapFile:ScrClose menu title.}

      mGoAway:      Str40;      {Button text for tab & column rulers: Go Away}              {[JS]}
      mSetTab:      Str40;      {Button text for tab ruler: Set Tab}                        {[JS]}
      mClrTab:      Str40;      {Button text for tab ruler: Clear Tab}                      {[JS]}
      mSetColumn:   Str40;      {Button text for column ruler: Set Column}                  {[JS]}
      mClrColumn:   Str40;      {Button text for column ruler: Clear Column}                {[JS]}

      sysAscent:        INTEGER;    {Ascent of the sysText font}                                {[JS]}
      sysDescent:       INTEGER;    {Descent of the sysText font}                               {[JS]}
      tile20Ascent:     INTEGER;    {Ascent of the Tile 20 font}                            {[JS]}
      BigV:             INTEGER;    {Large tick mark on ruler}                              {[JS]}
      SmallV:           INTEGER;    {Small tick mark on ruler}                              {[JS]}


      SetupForm: array [TFormNr] of TForm;
      SetClrMap: array [Boolean] of TDBSetClr;
      AnswerMsg: Str40;         {String from message dialog.}
      Answering: Boolean;       {Message dialog in progress?}
      DoEndDial: Boolean;       {Should auto-dial when changed?}

      CopyByColumns: BOOLEAN;   {Is the current Copy a Column or Vanila copy?}              {[JS]}

      MyAlerts: TAlertFile;     {The alerts.}
      AlertNum: Integer;        {???}
      AlertHead: THAlertSave;   {Head alert queue waiting for reactivation.}
      AlertTail: THAlertSave;   {Tail alert queue waiting for reactivation.}

      TheTerm: THTerm;          {The active terminal.}
      TermList: THTerm;         {List of terminals.}
      BlinkList: THBlinkItem;   {List of blinking regions.}
      Running: Boolean;         {Is this the first call to Quit?}

      HScale: Integer;          {Font horizontal scale factor.}
      VScale: Integer;          {Font vertical   scale factor.}

      BlinkVis: Boolean;        {Are blinking inversion areas inverted now?}
      MouseVis: Boolean;        {Is the mouse cursor visible now?}
      MousePt: Point;           {Where is it?}
      TargSize: TClick;         {How many clicks have there been?}
      SelTime: LongInt;         {When was the last one done?}
      HourGlass: BOOLEAN;       {App is bussy, dont change the shape of the cursor}

      UpTime: LongInt;          {When  did mouse button last go up?}
      UpWhere: Point;           {Where did mouse button last go up?}

      DownTime: LongInt;        {When  did mouse button last go down?}
      DownWhere: Point;         {Where did mouse button last go down?}

      PasteTerm: THTerm;        {Terminal currently pasting (=NIL if none).}
      StartPaste: Boolean;      {Should receive start from the beginning.}
      CharsSinceCR: INTEGER;    {Used to keep track of word wrap during a Paste}                {[JS]}
      PWrapPoint: INTEGER;      {Wraping point of word, set up at begining of each Paste}       {[JS]}
      WrapStart: INTEGER;       {Computed start of line, set up at begining of each Paste}      {[JS]}
      ALpd: TALpd;              {Unit Scrap stuff (see Receive).}
      ScrapBuffer: packed array [0..ScrBufSize] of TB;  {See MySeqLpd.}
      TheScrap: TScrap;         {Image of the Copied stuff (see PaintScrap).}

      DidChange: Boolean;       {Needed here because SendToScreen can't nest.}
      ShouldUpd: Boolean;       {Has a change happened that should update the}
                                {screen (line-feed, clear screen, etc) ?}
                                {Also needed because SendToScreen can't nest.}

      Changed: Boolean;         {Has any folder changed?}
      BigTerm: Boolean;         {Is there a terminal to alert for large cache?}

      HeapState: THeapState;    {How badly is the heap overflowing?}
      HeapDisk: Str255;         {String from MsgMenu for the heap disk.}

      NrTerms: Integer;         {Number of documents.}
      NextSeqNr: LongInt;       {Sequential line numbering.}
      JunkRgn: RgnHandle;       {Destination region for ScrollRect.}

      {$IFC PrintTime }
        P_Hist: array [0..50] of Integer;
        P_Over: Integer;
      {$ENDC }

      {$IFC NrHandles }
        CountHandles: Boolean;
      {$ENDC }

      {$IFC FindDecr }
        Rgn1: LongInt;
        Rgn2: LongInt;
        Rgn3: LongInt;
        Rgn4: LongInt;
        OldProc: Str30;
      {$ENDC }

      {$IFC UpdateFreq}
        MaxUpdWait: Integer;
        MaxChanges: Integer;
      {$ENDC}

      {$IFC WrapDebug}                                                                  {[JS]}
        WrapDebug: BOOLEAN;                                                             {[JS]}
      {$ENDC}                                                                           {[JS]}

      {$IFC ZoneDebug}                                                                  {[JS]}
        ZoneDebug: BOOLEAN;                                                             {[JS]}
      {$ENDC}                                                                           {[JS]}

      {$IFC DbgRlrUpdates}                                                              {[JS]}
        DbgRlrUpdates: BOOLEAN;                                                         {[JS]}
      {$ENDC}                                                                           {[JS]}

      {$IFC DbgSizeTerm}                                                                {[JS]}
        DbgSizeTerm: BOOLEAN;                                                           {[JS]}
      {$ENDC}                                                                           {[JS]}

      {$IFC DbgCursor}                                                                  {[JS]}
        DbgCursor: BOOLEAN;                                                             {[JS]}
      {$ENDC}                                                                           {[JS]}

{$IFC fsymok}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}

{$S SegTE }

{$IFC RangeCheck }
  {$R+ }
{$ELSEC }
  {$R- }
{$ENDC }

  function ConvertLanguage(input:CHAR; language:integer):Char; External;
  function ConvertAscii(input:CHAR; language:integer):Char; External;


  procedure Quit;
    forward;


    {$IFC WrapDebug OR ZoneDebug OR DbgRlrUpdates OR DbgSizeTerm OR DbgCursor}          {BEGIN DbgYesNo [JS]}
    FUNCTION  DbgYesNo(s: STR255): BOOLEAN;
    VAR ch:     CHAR;
        yesNo:  BOOLEAN;

    {$S SegTECold }
    BEGIN
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        WRITELN;
        WRITE(CHR(7), s, '? [N] > ');
        READ(ch);
        yesNo := ch IN ['Y','y'];
        DbgYesNo := yesNo;
        IF yesNo THEN
            WRITELN(CHR(8),'Yes')
        ELSE
            WRITELN(CHR(8),'No');
    END;
    {$ENDC}                                                                             {END DbgYesNo [JS]}


    {$IFC ZoneDebug}
    {$S SegTECold }                                                                   {BEGIN PrintRect [JS]}
    PROCEDURE PrintRect(name: Str255; r: Rect);
    {$S SegTE }
    BEGIN
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        WRITELN(name:17, '([', r.left:0, ',', r.top:0, '], [', r.right:0, ',', r.bottom:0, '])');
    END;
    {$ENDC}                                                                             {END PrintRect [JS]}


  {$IFC NrHandles }
  {$S SegTECold}
    procedure PrintHandles (Str: Str40);
      var
        CBkRel: Integer;

      {$S SegTE }
      begin {PrintHandles}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        if CountHandles then begin
          if fCheckHzOK (TheHeap, CBkRel) then {do nothing};
          WriteLn ('Number of relocatable blocks = ', CBkRel:1, ' ', Str);
        end;
      end;  {PrintHandles}
  {$ENDC }

  {$IFC FindDecr }

    procedure WriteHex (Num: LongInt);
      var
        Hex: Str30;
        Str: Str30;
        I: Integer;
        Dig: Integer;

      {$S SegTECold }
      begin {WriteHex}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        Hex:='0123456789ABCDEF';

        Str:='1234 6789   ';
        for I:=9 downto 1 do
          if I<>5 then begin
            Dig:=Num mod 16;
            Num:=Num div 16;

            Str [I]:=Hex [Dig+1];
          end;

        Write (Str);
      end;  {WriteHex}


    procedure PrintRgns (HTerm: THTerm; ProcStr: Str30);
      {PrintRgns prints all of the blinkrgn handles in HTerm as hex values,}
      {followed by ProcStr.  This is used to find a problem involving one of}
      {the handles' high word being decremented.  Calls to this procedure are}
      {placed strategically throughout the code.}

      var
        I: Integer;

      {$S SegTECold }
      begin {PrintRgns}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        with HTerm^^ do begin
          if (Ord (CursorRect)<>Rgn1) or
             (Ord (CaretRect )<>Rgn2) or
             (Ord (BlinkRgn  )<>Rgn3) or
             (Ord (InvertRgn )<>Rgn4) then begin
            WriteHex (Rgn1);
            WriteHex (Rgn2);
            WriteHex (Rgn3);
            WriteHex (Rgn4);
            WriteLn ('--   ', OldProc);

            WriteHex (Ord (CursorRect));
            WriteHex (Ord (CaretRect));
            WriteHex (Ord (BlinkRgn));
            WriteHex (Ord (InvertRgn));
            WriteLn ('--   ', ProcStr);

            Write (Chr (7), '*** VALUES DIFFER ***       <CR> to continue ...');
            ReadLn;

            for I:=-maxint to maxint do {nothing};
            for I:=-maxint to maxint do {nothing};
            for I:=-maxint to maxint do {nothing};
            for I:=-maxint to maxint do {nothing};
            for I:=-maxint to maxint do {nothing};
            for I:=-maxint to maxint do {nothing};
            for I:=-maxint to maxint do {nothing};
            for I:=-maxint to maxint do {nothing};
            Write (Chr (7));
          end;

          Rgn1:=Ord (CursorRect);
          Rgn2:=Ord (CaretRect );
          Rgn3:=Ord (BlinkRgn  );
          Rgn4:=Ord (InvertRgn );
          OldProc:=ProcStr;
        end;
      end; {PrintRgns}
  {$ENDC }


  procedure Wait (HowLong: Integer);
    {Wait waits the specified length of time (in 1/100 sec).}

    var
      OKTime: LongInt;

    {$S SegTECold }
    begin {Wait}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      OKTime:=Time + HowLong;
      repeat
      until Time>=OKTime;
    end; {Wait}

  {$I ApLt/Heap.Text   }        {Procedures to grow and shrink the heap.}
  {$I ApLt/NewDsp.Text }        {Procedures to allocate and deallocate on the heap.}
  {$I ApLt/Alerts.Text }        {Procedures to queue and post alerts.}
  {$I ApLt/RowIO.Text  }        {Procedures to read/write caches.}
  {$I ApLt/Blink.Text  }        {Procedures to manipulate blinking areas.}
  {$I ApLt/Paint.Text  }        {Procedures to paint terminals.}
  {$I ApLt/Phone.Text  }        {Procedures to manipulate the modem.}
  {$I ApLt/Setup.Text  }        {Procedures to handle Setup information.}
  {$I ApLt/Folder.Text }        {Procedures to read/write, create/kill documents.}
  {$I ApLt/Term.Text   }        {Procedures to emulate the terminal.}
  {$I ApLt/Init.Text   }        {Initialization procedure.}
  {$I ApLt/Select.Text }        {Procedures to handle mouse clicks in the text area.}
  {$I ApLt/Scrap.Text  }        {Procedures to deal with the scrap.}
  {$I ApLt/AnswrBk.Text}        {Procedures to handle the answerback dialog.}
  {$I ApLt/Event.Text  }        {Procedure  to handle events.}
  {$I ApLt/Rec.Text    }        {Procedures to route input data.}



  procedure CheckMouse;
    {CheckMouse sets the mouse's cursor to the correct shape. }


    procedure TrackMouse;
      {TrackMouse sets the mouse's cursor to the correct shape for its position.}

      var
        SavePort: GrafPtr;
        MsePt: Point;
        Done: Boolean;


      function MseInFolder (Fldr: GrafPtr; var MsePt: Point): Boolean;
        {MseInFolder returns true if the mouse is in Fldr^.VisRgn.}
        {MsePt returns the coordinates of the mouse local to Fldr.}

        var
          SavePort: GrafPtr;

        {$S SegTEIdle }
        begin {MseInFolder}
          {$IFC SampCalls}   ALogCall;   {$ENDC}
          GetPort (SavePort);
          SetPort (Fldr);
          GetMouse (MsePt);
          SetPort (SavePort);

          MseInFolder:=PtInRgn (MsePt, Fldr^.VisRgn);
        end; {MseInFolder}


        PROCEDURE TrackTerm(MsePt: Point);                                              {BEGIN TrackTerm [JS]}
        {TrackTerm tracks the mouse cursor when in the active folder.}

        {$S SegTEIdle }
        BEGIN {TrackTerm}
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            WITH TheTerm^^.Display[AtPaint].MoveArray DO
                IF PtInRect(MsePt, FolderZones[BTextBox]) THEN
                    SetStdCursor (ICrsXIBeam)
                ELSE
                    IF PtInRect(MsePt, FolderZones[RulerBox]) AND (VisTabs OR VisColumn) THEN
                        IF PtInRect(MsePt, FolderZones[GoAway]) OR
                           PtInRect(MsePt, FolderZones[SetTabOrColumn]) OR
                           PtInRect(MsePt, FolderZones[ClrTabOrColumn]) THEN
                            SetStdCursor(ICrsCheck)
                        ELSE
                            SetStdCursor(ICrsGECross)
                    ELSE
                        SetStdCursor(iCrsInactive);
        END; {TrackTerm}                                                                {END TrackTerm [JS]}

    {$S SegTEIdle }
    BEGIN {TrackMouse}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        {$IFC DbgCursor}
        IF DbgCursor THEN
            WRITELN('TrackMouse: HourGlass = ',HourGlass);
        {$ENDC}

        IF NOT HourGlass THEN                       {We are bussy don't touch the cursor}           {[JS]}
            BEGIN
            Done := False;

            IF IsActive THEN                        {Is it in the active folder?}
                IF MseInFolder(TheTerm^^.Folder, MsePt) THEN
                    BEGIN
                    TrackTerm(MsePt);
                    Done := True;
                    END;

            IF NOT done THEN                        {Is it in the dialog box?}
                IF MseInFolder (DialogFolder, MsePt) THEN
                    BEGIN
                    CallTrkProc(MsePt, TheDBox.TrkMseProc);
                    Done := True;
                    END;

            IF NOT done THEN                        {Is it in nowheres-ville?}
                SetStdCursor (iCrsInactive);
            END;
    END; {TrackMouse}

    {$S SegTEIdle }
    begin {CheckMouse}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      if MouseVis then
        TrackMouse;
    end; {CheckMouse}


  procedure MainLoop;
    {MainLoop is the main body of TE.  Note that we don't go to sleep like}
    {the other applications.}

    const
      CaretDelay=50;                    {1/100 sec between blinks.}

    var
      TheEvent: EventRecord;
      GotEvent: Boolean;
      DoReceive: Boolean;
      BlinkTime: LongInt;
      HTerm: THTerm;
      LastState: THeapState;
      HeapWorse: Boolean;


    procedure AskAllCaches;
      {AskAllCaches is called when the heap can no longer be expanded.  First,}
      {it removes the unused space from all of the caches of each terminal.  It}
      {then asks the user to Clear Lines Off Top for each terminal on the list for}
      {terminals having LOT's larger than 100 lines.  If s/he killed no terminals}
      {having large caches then AskAllCaches asks for all other terminals on the}
      {list with anything at all in their caches.}

      var
        HTerm: THTerm;
        NoneBig: Boolean;

      {$S SegTEMain}
      begin {AskAllCaches}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        HTerm:=TermList;
        while HTerm<>NIL do begin
          ClipCache (HTerm^^.HCache);
          HTerm:=HTerm^^.Next;
        end;

        NoneBig:=True;
        HTerm:=TermList;
        while HTerm<>NIL do begin
          if HTerm^^.HCache<>NIL then
            if HTerm^^.HCache^^.LinesInCache>100 then begin
              ParamAlert (HTerm^^.TheTitle, HeapDisk, '');

              if CautionAlert (MyAlerts, ALHeapFull) then begin
                NoneBig:=False;
                KillLOT (HTerm);

              end else
                HTerm^^.Setup.Runoff:=False;
            end;

          HTerm:=HTerm^^.Next;
        end;

        if NoneBig then begin
          NoneBig:=True;

          HTerm:=TermList;
          while HTerm<>NIL do begin
            if HTerm^^.HCache<>NIL then
              if HTerm^^.HCache^^.LinesInCache<=100 then begin
                NoneBig:=False;

                ParamAlert (HTerm^^.TheTitle, HeapDisk, '');
                if CautionAlert (MyAlerts, ALHeapFull) then
                  KillLOT (HTerm)

                else
                  HTerm^^.Setup.Runoff:=False;
              end;

            HTerm:=HTerm^^.Next;
          end;
        end;
      end; {AskAllCaches}


    procedure ClipAllCaches;
      {ClipAllCaches is called when the heap can no longer be expanded and there}
      {is no active LisaTerminal document (so we can't use alerts).  Each terminal}
      {is clipped to use the minimum heap space and the Lines Off Top feature is}
      {set to Forget.}

      var
        HTerm: THTerm;

      {$S SegTEMain}
      begin {ClipAllCaches}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        HTerm:=TermList;
        while HTerm<>NIL do begin
          ClipCache (HTerm^^.HCache);

          with HTerm^^, Setup do
            if Runoff then begin
              Runoff:=False;
              GiveAlert (HTerm, AlrtNote, ALStopCache, TheTitle, HeapDisk, '');
            end;

          HTerm:=HTerm^^.Next;
        end;
      end; {ClipAllCaches}


    procedure KillAllCaches;
      {KillAllCaches is called when the heap can no longer be expanded and there}
      {is no active LisaTerminal document (so we can't use alerts).  Each terminal}
      {is clipped to use the minimum heap space and the Lines Off Top feature is}
      {set to Forget.}

      var
        HTerm: THTerm;

      {$S SegTEMain}
      begin {KillAllCaches}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        HTerm:=TermList;
        while HTerm<>NIL do begin
          KillLOT (HTerm);

          with HTerm^^ do begin
            Setup.Runoff:=False;
            GiveAlert (HTerm, AlrtNote, ALKilledCache, TheTitle, HeapDisk, '');
          end;

          HTerm:=HTerm^^.Next;
        end;
      end; {KillAllCaches}

    {$S SegTEMain}
    begin {MainLoop}

      {$IFC SampCalls}
      ALogCall;
      {$ENDC}
      Initialize;

      BlinkTime:=Time;

      LastState:=HeapState;
      GotEvent:=False;
      DoReceive:=False;
      repeat
        if IsActive then begin                  {Track the mouse's cursor.}
          CheckMouse;

          if AlertHead<>NIL then
            SayAlerts;
        end;

        if Time>=BlinkTime then begin           {Blink everything in all screens.}
          BlinkAll;
          BlinkTime:=Time+CaretDelay;
        end;

        HeapWorse:= (HeapState>LastState);      {Has the heap state gotten worse?}
        LastState:=HeapState;

        if HeapWorse then begin                 {Running out of heap.}
          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 3');
          {$ENDC }

          if TheScrap.HCache<>NIL then          {Try just killing the scrap cache.}
            KillCache (TheScrap.HCache)
          else
            if HeapState=HeapWarning then       {Ask user to kill other caches.}
              if IsActive then
                AskAllCaches
              else
                ClipAllCaches

            else {HeapState=HeapCritical}       {Tough luck Charlie ... didn't do}
              KillAllCaches;                    {anything soon enough.  Goodbye caches.}

          ShrinkSegMemory (TheHeap);

          if HeapState>HeapNormal then
            GiveAlert (NIL, AlrtStop, ALHeapDead, '', HeapDisk, '');

          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 4');
          {$ENDC }
        end;

        if BigTerm then begin                   {Check for large caches.}
          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 5');
          {$ENDC }

          HTerm:=TermList;
          while HTerm<>NIL do begin
            with HTerm^^ do begin
              if CacheTooBig and (HCache^^.LinesInCache>=LTBigCache) then
                GiveAlert (HTerm, AlrtNote, ALBigCache, TheTitle, '', '');
              if CacheMuchTooBig then begin
                GiveAlert (HTerm, AlrtNote, AlCacheMuchTooBig, TheTitle, '', '');
                CantRemember := True;
              end;
              CacheMuchTooBig := False;
              CacheTooBig:=False;
            end;

            HTerm:=HTerm^^.Next;
          end;

          BigTerm:=False;

          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 6');
          {$ENDC }
        end;

        if not GotEvent then begin              {Check for an event.}
          if Termlist <> NIL then begin         {Still have some active documents}
            GotEvent:=EventAvail;
            if GotEvent then
              GetEvent (TheEvent);
          end else begin                        {No active documents}
            GetEvent(TheEvent);
            GotEvent := True;
          end;
        end;

        if not DoReceive then                   {Check for receive (may use event).}
          DoReceive:=CheckReceive (TheEvent, GotEvent);

        if GotEvent and ((TheEvent.What<>KeyDown) or Answering) then begin
          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 11');
          {$ENDC }

          if Changed then
            UpdateAll;

          ProcessEvent (TheEvent);
          GotEvent:=False;

          {$IFC NrHandles }
            PrintHandles ('after ProcessEvent');
          {$ENDC }

          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 12');
          {$ENDC }

        end else if DoReceive then begin
          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 13');
          {$ENDC }

          Receive;
          DoReceive:=False;

          {$IFC NrHandles }
            PrintHandles ('after Receive');
          {$ENDC }

          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 14');
          {$ENDC }

        end else if Changed then begin
          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 15');
          {$ENDC }

          UpdateAll;

          {$IFC NrHandles }
            PrintHandles ('after UpdateAll');
          {$ENDC }

          {$IFC FindDecr }
            if TermList<>NIL then
              PrintRgns (TermList, 'MainLoop 16');
          {$ENDC }

        end else
          LetOthersRun;
      until False;
    end; {MainLoop}

{$S       }
  begin {TE}
    {$IFC SampCalls}
    AInitTrCalls;
    ALogCall;
    {$ENDC}

    {$IFC ZoneDebug}                                                                            {[JS]}
    ZoneDebug := DbgYesNo('Debug folder zones');                                                {[JS]}
    {$ENDC}                                                                                     {[JS]}

    {$IFC DbgRlrUpdates}                                                                        {[JS]}
    DbgRlrUpdates := DbgYesNo('Debug ruler updates');                                           {[JS]}
    {$ENDC}                                                                                     {[JS]}

    {$IFC DbgSizeTerm}                                                                          {[JS]}
    DbgSizeTerm := DbgYesNo('Extra call to SizeTerm in MakeVisible');                           {[JS]}
    {$ENDC}                                                                                     {[JS]}

    {$IFC DbgCursor}                                                                            {[JS]}
    DbgCursor := DbgYesNo('Debug cursor tracking');                                             {[JS]}
    {$ENDC}                                                                                     {[JS]}

    MainLoop;
  end. {TE}

