{ Copyright 1983, Apple Computer, Inc. }

{$S SegTE}
function IsInsertion (HTerm: THTerm): Boolean;
  {IsInsertion returns true if HTerm^^.Select is a NIL selection.}

  {$S SegTE}
  begin {IsInsertion}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^.Select do
      IsInsertion:= (Left.Ln=Right.Ln) and (Left.Ch=Right.Ch);
  end; {IsInsertion}



procedure PaintSBs (HTerm: THTerm);
  {PaintSBs paints the scroll bars and grow box into HTerm.}

  var
    SavePort: GrafPtr;


  {$S SegTECold}
  begin {PaintSBs}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    GetPort (SavePort);
    SetPort (HTerm^^.Folder);


    SetupMvThumb (HTerm^^.HSBar);
    MoveThumb (HTerm^^.Display [RightNow].MoveArray.HThumbPos);                                 {[JS]}

    SetupMvThumb (HTerm^^.VSBar);
    MoveThumb (HTerm^^.Display [RightNow].MoveArray.VThumbPos);                                 {[JS]}

    PaintSB (HTerm^^.VSBar);
    PaintSB (HTerm^^.HSBar);
    PaintGrow;

    SetPort (SavePort);
  end; {PaintSBs}



procedure UnpaintSBs (HTerm: THTerm);
  {UnpaintSBs takes the scroll bars and grow box off of HTerm.}

  var
    SavePort: GrafPtr;

  {$S SegTECold}
  begin {UnpaintSBs}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    GetPort (SavePort);
    SetPort (HTerm^^.Folder);
    HideSBorder (HTerm^^.Folder^.PortRect);
    SetPort (SavePort);
  end; {UnpaintSBs}



procedure KillSBs (HTerm: THTerm);
  {KillSBs takes the scroll bars and grow box off of HTerm.}

  var
    SavePort: GrafPtr;
    Zone: TZone;

  {$S SegTECold}
  begin {KillSBs}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    GetPort (SavePort);
    SetPort (HTerm^^.Folder);

    for Zone:=VScrollBox to GrowBox do
      EraseRect (HTerm^^.Display [AtPaint].MoveArray.FolderZones [Zone]);                           {[JS]}

    SetPort (SavePort);
  end; {KillSBs}



function RectWidth (R: Rect): Integer;
  {RectWidth returns the width of R.}

  {$S SegTE}
  begin {RectWidth}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    RectWidth:=R.Right-R.Left;
  end; {RectWidth}



function RectHeight (R: Rect): Integer;
  {RectHeight returns the height of R.}

  {$S SegTE}
  begin {RectHeight}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    RectHeight:=R.Bottom-R.Top;
  end; {RectHeight}



function RealCh (Ch: Integer; TwoWide: Boolean): Integer;
  {RealCh transforms Ch into its actual character position depending}
  {on TwoWide.}

  {$S SegTE}
  begin {RealCh}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    if TwoWide then
      RealCh:=2*Ch - 1
    else
      RealCh:=Ch;
  end; {RealCh}



function RealCol (Col: Integer; TwoWide: Boolean): Integer;
  {RealCol transforms Col into its actual column number depending}
  {on TwoWide.}

  {$S SegTE}
  begin {RealCol}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    if TwoWide then
      RealCol:=(Col + 1) div 2
    else
      RealCol:=Col;
  end; {RealCol}



function DeltaH (HTerm: THTerm; ColA: Integer; ColB: Integer): Integer;
  {DeltaH returns HorzSp*(ColA-ColB).}

  {$S SegTE}
  begin {DeltaH}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    DeltaH:=HTerm^^.Style^^.HorzSp*(ColA - ColB)
  end; {DeltaH}



function DeltaV (HTerm: THTerm; RowA: Integer; RowB: Integer): Integer;
  {DeltaV returns VertSp*(RowA-RowB).}

  {$S SegTE}
  begin {DeltaV}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    DeltaV:=HTerm^^.Style^^.VertSp*(RowA - RowB)
  end; {DeltaV}



function ColToH (HTerm:THTerm; ColNr: Integer; TwoWide: Boolean; Base: TBase): Integer;
  {ColToH returns the left side of ColNr in the given base.}

  var
    Result: Integer;
    BBox: Rect;

  {$S SegTECold}
  begin {ColToH}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Style^^, Display [RightNow], MoveArray do begin                               {[JS]}
      if Base=RulerBase then
        BBox:=FolderZones [RulerBox]                                                            {[JS]}
      else
        BBox:=FolderZones [TextBox];

      Result:=BBox.Left + HorzSp*(RealCh (ColNr, TwoWide) - FirstCol);
    end;

    if Result<BBox.Left then
      Result:=BBox.Left;

    if Result>BBox.Right then
      Result:=BBox.Right;

    ColToH:=Result;
  end; {ColToH}



function RowToV (HTerm:THTerm; RowNr: Integer; Vert: TVert; Base: TBase): Integer;
  {RowToV returns the given part of RowNr in the given base.}

  var
    Result: Integer;
    BBox: Rect;
    TheRow: Integer;
    dV: Integer;

  {$S SegTE}
  begin {RowToV}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Style^^, Display [RightNow], MoveArray do begin                               {[JS]}
      if Base=RulerBase then
        BBox:=FolderZones [RulerBox]                                                            {[JS]}
      else
        BBox:=FolderZones [TextBox];

      if Base=LineBase then
        TheRow:=RowNr-FirstRow
      else
        TheRow:=RowNr-1;

      case Vert of
        AtTop:      dV:=0;
        AtBaseline: dV:=Above;
        AtBottom:   dV:=VertSp;
      end;

      Result:=BBox.Top + VertSp*TheRow + dV;
    end;

    if Result<BBox.Top then
      Result:=BBox.Top;

    if Result>BBox.Bottom then
      Result:=BBox.Bottom;

    RowToV:=Result;
  end; {RowToV}



procedure ColsToRect (HTerm: THTerm; RowNr: Integer; CFirst: Integer;
                      CLast: Integer; TwoWide: Boolean; Base: TBase; var TheRect: Rect);
  {ColsToRect returns a rectangle around a range of columns in RowNr.}

  {$S SegTECold}
  begin {ColsToRect}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    TheRect.Top   :=RowToV (HTerm, RowNr  , AtTop   , Base);
    TheRect.Bottom:=RowToV (HTerm, RowNr  , AtBottom, Base);

    TheRect.Left  :=ColToH (HTerm, CFirst , TwoWide , Base);
    TheRect.Right :=ColToH (HTerm, CLast+1, TwoWide , Base);
  end; {ColsToRect}



procedure RowsToRect (HTerm: THTerm; RFirst: Integer; RLast: Integer;
                      Base: TBase; var TheRect: Rect);
  {RowsToRect returns a rectangle around a range of rows.}

  {$S SegTE}
  begin {RowsToRect}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^.Display [RightNow], MoveArray do                                               {[JS]}
      if Base=RulerBase then
        TheRect:=FolderZones [RulerBox]                                                         {[JS]}
      else
        TheRect:=FolderZones [TextBox];

    TheRect.Top   :=RowToV (HTerm, RFirst, AtTop   , Base);
    TheRect.Bottom:=RowToV (HTerm, RLast , AtBottom, Base);
  end; {RowsToRect}



function AllVisible (HTerm: THTerm; Zone: TZone): Boolean;
  {AllVisible returns true if HTerm^^.Display [RightNow].MoveArray.FolderZones [Zone]}
  {is all inside HTerm's VisRgn.}

  var
    TheRgn : RgnHandle;
    TheSect: RgnHandle;

  {$S SegTE}
  begin {AllVisible}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    TheRgn :=NewRgn;
    TheSect:=NewRgn;

    RectRgn (TheRgn, HTerm^^.Display [RightNow].MoveArray.FolderZones [Zone]);                  {[JS]}
    SectRgn (HTerm^^.Folder^.VisRgn, TheRgn, TheSect);
    AllVisible:=EqualRgn (TheRgn, TheSect);

    DisposeRgn (TheRgn );
    DisposeRgn (TheSect);
  end; {AllVisible}



procedure UpdateTerm (HTerm: THTerm);
  {UpdateTerm makes HTerm's Display [AtPaint] match its Display [RightNow].}
  {The folder is updated and Display [AtPaint]:=Display [RightNow] and}
  {Changed:=False.}

  var
    SavePort: GrafPtr;

    {$IFC PrintTime }
      P_Time: LongInt;
    {$ENDC }



  procedure UpdateLights;
    {UpdateLights updates the status lights for HTerm.}

    var
      I: Integer;
      dH: Integer;
      Pt: Point;
      Str: Str255;
      TempRect: Rect;
      MoveLights: Boolean;
      LightRect: Rect;

    {$S SegTE}
    begin {UpdateLights}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      if HTerm^^.Display [RightNow].MoveArray.VisLights then begin                              {[JS]}
        MoveLights:=not HTerm^^.Display [AtPaint].MoveArray.VisLights or                        {[JS]}
            (RectWidth (HTerm^^.Display [AtPaint ].MoveArray.FolderZones [StatBox]) <>          {[JS]}
             RectWidth (HTerm^^.Display [RightNow].MoveArray.FolderZones [StatBox]));           {[JS]}

        with HTerm^^, Style^^, Display [RightNow], MoveArray do begin                           {[JS]}
          dH:=RectWidth (FolderZones [StatBox]) div 4;      {Find delta on-center.}

          LightRect:=FolderZones [StatBox];                 {Find first light.}
          InsetRect (LightRect, 0, VMargin);
          OffsetRect (LightRect, (dH - HorzSp*Length (StatName)) div 2, 0);
          LightRect.Right:=LightRect.Left + HorzSp*Length (StatName);

          if MoveLights then begin
            TempRect:=FolderZones [StatBox];
            TempRect.Bottom:=TempRect.Bottom-1;
            EraseRect (TempRect);
          end;
        end;

        Str:=StatName;
        for I:=1 to 4 do begin
          if MoveLights then begin                          {Repaint the lights.}
            Pt:=LightRect.TopLeft;
            Pt.V:=Pt.V + HTerm^^.Style^^.Above;

            MoveTo (Pt.H, Pt.V);
            DrawString (Str);

            with HTerm^^.Display [RightNow], MoveArray do   {Inverted if "on".}                 {[JS]}
              if Lights [I] then
                InvertRect (LightRect);

            Str [Length (Str)]:=Succ (Str [Length (Str)]);

          end else                                          {Invert if changed.}
            if HTerm^^.Display [AtPaint ].MoveArray.Lights [I] <>                               {[JS]}
               HTerm^^.Display [RightNow].MoveArray.Lights [I] then                             {[JS]}
              InvertRect (LightRect);

          OffsetRect (LightRect, dH, 0);
        end;

      end else                                              {Lights aren't visible.}
        with HTerm^^.Display [AtPaint], MoveArray do                                            {[JS]}
          if VisLights then begin
            TempRect:=FolderZones [StatBox];
            TempRect.Bottom:=TempRect.Bottom-1;
            EraseRect (TempRect);
          end;

      with HTerm^^ do                                       {Draw the dividing line.}
        if DivLights then
          with Display [RightNow].MoveArray.FolderZones [StatBox] do begin                      {[JS]}
            MoveTo (Left   , Bottom-1);
            LineTo (Right-1, Bottom-1);
          end;
    end; {UpdateLights}



    PROCEDURE UpdateTabs;                                                           {BEGIN UpdateTabs [JS]}
    {UpdateTabs updates the tabs for HTerm.}

    VAR
        OldFirst:   INTEGER;    {Range of ruler in Display [AtPaint].}
        OldLast:    INTEGER;

        NewLast:    INTEGER;    {Range of ruler in Display [RightNow].}
        NewFirst:   INTEGER;

        GoodFirst:  INTEGER;    {Intersection of Old and New rulers.}
        GoodLast:   INTEGER;

        currentPort:    GrafPtr;
        oldFont:        INTEGER;
        oldFace:        Style;
        oldPen:         PenState;

        PROCEDURE DrawNr(Nr: INTEGER; H: INTEGER; V: INTEGER);
        {DrawNr draws Nr to the left of H with baseline V.}

        VAR
            Len:    INTEGER;
            I:      INTEGER;
            S:      Str255;

        {$S SegTECold}
        BEGIN {DrawNr}
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            IF Nr < 10 THEN
                Len := 1
            ELSE
            IF Nr < 100 THEN
                Len := 2
            ELSE
                Len := 3;

            {$R-}
            S[0] := CHR(Len);
            {$IFC RangeCheck}
                {$R+}
            {$ENDC}

            FOR I := Len DOWNTO 1 DO
                BEGIN
                S[I] := CHR(Nr MOD 10 + ORD('0'));
                Nr := Nr DIV 10;
                END;

            MoveTo(H - StringWidth(s), V);
            DrawString(S);
        END; {DrawNr}




        PROCEDURE DrawMap(map: BitMap; pt: Point);
        {DrawMap draws a bitmap.}

        VAR r:  Rect;

        {$S SegTECold}
        BEGIN {DrawMap}
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            r := map.Bounds;
            IF map.baseAddr = @TabMap THEN
                OffsetRect(r, pt.h, pt.v)
            ELSE
                OffsetRect(r, pt.h - RectWidth(r) DIV 2, pt.v);
            CopyBits (map, ThePort^.PortBits, map.Bounds, r, SrcCopy, NIL);
        END; {DrawMap}




        PROCEDURE UndrawMap(map: BitMap; pt: Point);
        {UndrawMap clears a area corresponding to the mbitmap.}

        VAR r: Rect;

        {$S SegTECold}
        BEGIN {UndrawMap}
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            r := map.Bounds;
            IF map.baseAddr = @TabMap THEN
                OffsetRect(r, pt.h, pt.v)
            ELSE
                OffsetRect(r, pt.h - RectWidth(r) DIV 2, pt.v);
            EraseRect (r);
        END; {UndrawMap}




        PROCEDURE XorButton(button: TButton; theMoment: Moment);
        {XorButton XORs the inside of buttons.}

        VAR buttonRect: Rect;

        {$S SegTECold}
        BEGIN {XorButton}
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            WITH HTerm^^.Display[theMoment].MoveArray DO
                CASE button OF
                    NoButton:       buttonRect := ZeroRect;
                    GoAwayButton:   buttonRect := FolderZone[GoAway];
                    SetButton:      buttonRect := FolderZone[SetTabOrColumn];
                    ClrButton:      buttonRect := FolderZone[ClrTabOrColumn];
                END;{CASE}

            IF NOT EmptyRect(buttonrect) THEN
                BEGIN
                PenSize(BtnBWidth, BtnBHeight);
                PenMode(patXor);
                FrameRoundRect(buttonRect, BtnOvalWidth, BtnOvalHeight);
                InvertRoundRect(buttonRect, BtnOvalWidth, BtnOvalHeight);
                PenNormal;
                END;
        END; {XorButton}


        PROCEDURE PaintRuler(First: Integer; Last: Integer);
        {PaintRuler paints the tab ruler from First to Last.}

        VAR
            TempRect:       Rect;       {Temporary Rect}
            pt:             Point;      {Temporary Point}
            LeftSide:       Integer;    {Left side of this character.}
            TabNr:          Integer;    {Current tab position}
            r:              Rect;       {Another temporary rect}



            PROCEDURE PaintButtons;
            VAR setBtnText:     Str40;
                clrBtnText:     Str40;

                PROCEDURE DoButton(VAR btnText: Str40; btnRect: Rect);

                {$S SegTECold}
                BEGIN{DoButton}
                    {$IFC SampCalls}   ALogCall;   {$ENDC}
                    IF NOT EmptyRect(btnRect) THEN
                        BEGIN
                        FrameRoundRect(btnRect, BtnOvalWidth, BtnOvalHeight);
                        MoveTo(btnRect.left + BtnBWidth + BtnOvalWidth DIV 2,
                               btnRect.bottom - BtnBHeight - VMargin - sysDescent);
                        DrawString(btnText);
                        END;
                END;{DoButton}

            {$S SegTE}
            BEGIN{PaintButtons}
                {$IFC SampCalls}   ALogCall;   {$ENDC}
                PenSize(BtnBWidth, BtnBHeight);
                TextFont(sysText);

                WITH HTerm^^, Setup, Display [RightNow].MoveArray DO
                    BEGIN
                    DoButton(mGoAway, FolderZones[GoAway]);
                    IF SeeTabs THEN
                        BEGIN
                        setBtnText := mSetTab;
                        clrBtnText := mClrTab;
                        END
                    ELSE
                        BEGIN
                        setBtnText := mSetColumn;
                        clrBtnText := mClrColumn;
                        END;

                    DoButton(setBtnText, FolderZones[SetTabOrColumn]);
                    DoButton(clrBtnText, FolderZones[ClrTabOrColumn]);
                    XorButton(HitButton, RightNow);
                    END;
                PenNormal;
                TextFont(p20TileLT);
            END;{PaintButtons}


        {$S SegTE}
        BEGIN {PaintRuler}
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            {$IFC DbgRuler}
            InvertRgn(HTerm^^.Folder^.ClipRgn);
            InvertRgn(HTerm^^.Folder^.ClipRgn);
            InvertRgn(HTerm^^.Folder^.ClipRgn);
            InvertRgn(HTerm^^.Folder^.ClipRgn);
            {$ENDC}

            IF First <= Last THEN
                BEGIN
                WITH HTerm^^, Style^^, Display [RightNow].MoveArray DO
                    BEGIN
                    TempRect := FolderZones[RulerBox];
                    TempRect.Left  := TempRect.Left + HorzSp * (First - FirstCol);
                    TempRect.Right := TempRect.Left + HorzSp * (Last - First + 1);
                    r := FolderZones[BRulerBox];
                    InsetRect(r, -1, 0);                        {Draw frame outside BRulerBox}
                    EraseRect(r);                               {Erase the area to be painted}
                    FrameRect(r);                               {Frame the area to be painted}
                    END;

                PaintButtons;                                   {Paint the buttons}

                WITH HTerm^^, Style^^, Display[RightNow].MoveArray, FolderZones[RulerBox] DO
                    BEGIN
                    SetPt(pt, left + HorzSp * (Position - first), blPos); {Draw the position marker}
                    DrawMap(PosMark, pt);
                    END;

                WITH HTerm^^, Style^^, Display[RightNow].MoveArray, FolderZones[RulerBox] DO
                    IF VisWrap THEN
                        BEGIN
                        SetPt(pt, left + HorzSp * (VisWrapPoint - first), blWrap); {Draw the Wrap marker}
                        DrawMap(WrapMark, pt);
                        END;

                LeftSide := TempRect.Left;                  {For each column ...}
                FOR TabNr := First TO Last DO
                    BEGIN
                    WITH HTerm^^, Display [RightNow].MoveArray DO {... draw the tab mark,}
                        BEGIN
                        IF TabNr > 1 THEN                   {Newer show tab mark 1, (according to VT100) }
                            BEGIN
                            SetPt(pt, LeftSide { + Style^^.HorzSp DIV 2}, blTStop);
                            IF Setup.SeeTabs THEN
                                BEGIN
                                IF TabStops[TabNr] THEN
                                    DrawMap(TabMark, pt);
                                END
                            ELSE
                                BEGIN
                                IF ColumnStops[TabNr] THEN
                                    DrawMap(ColumnMark, pt);
                                END;
                            END;

                        MoveTo(LeftSide, blTicMk);                  {... draw the tic mark,}

                        IF TabNr MOD RulSpace = 0 THEN
                            Line(0, BigV)
                        ELSE
                            Line(0, SmallV);

                        IF TabNr MOD TicSpace = 0 THEN              {... and number it.}
                            DrawNr(TabNr, LeftSide, blRuler);

                        LeftSide := LeftSide + HTerm^^.Style^^.HorzSp;
                        END;
                    END;
                END;
        END; {PaintRuler}




        PROCEDURE DoTabs;

        VAR
            dH:             INTEGER;
            TempRgn:        RgnHandle;
            AuxRgn:         RgnHandle;
            TempRect:       Rect;



            PROCEDURE ScrollRuler;
            VAR r:          Rect;

            {$S SegTECold}
            BEGIN{ScrollRuler}
                {$IFC SampCalls}   ALogCall;   {$ENDC}
                dH := HTerm^^.Style^^.HorzSp * (OldFirst-NewFirst);
                IF dH<>0 THEN
                    BEGIN       {Don't scroll the buttons}
                    r := HTerm^^.Display [RightNow].MoveArray.FolderZones [BRulerBox];
                    r.bottom := HTerm^^.Display [RightNow].MoveArray.blWrap + RectHeight(WrapMark.bounds);
                    ScrollRect(r, dH, 0, JunkRgn);
                    END
                ELSE
                    RectRgn(JunkRgn, ZeroRect);

                RectRgn(TempRgn, HTerm^^.Display [RightNow].MoveArray.FolderZones [RulerBox]);
                RectRgn( AuxRgn, HTerm^^.Display [AtPaint ].MoveArray.FolderZones [RulerBox]);
                DiffRgn(TempRgn, AuxRgn, TempRgn);
                UnionRgn(TempRgn, JunkRgn, JunkRgn);
            END;{ScrollRuler}



            PROCEDURE UpdatePosition;
            VAR pt: Point;

            {$S SegTECold}
            BEGIN{UpdatePosition}
                {$IFC SampCalls}   ALogCall;   {$ENDC}
                WITH HTerm^^, Display [RightNow].MoveArray DO
                    IF position <> Display[AtPaint].MoveArray.position THEN
                        BEGIN                                                   {Draw the position marker}
                        SetPt(pt, FolderZones [RulerBox].left + Style^^.HorzSp *
                                  (Display[AtPaint].MoveArray.Position
                                         - Display[AtPaint].MoveArray.FirstCol), blPos);
                        UndrawMap(PosMark, pt);     {Remove position marker}

                        MoveTo(pt.h, pt.v);
                        Line(0, SmallV);            {and replace tickmark}

                        pt.h := FolderZones [RulerBox].left +
                                Style^^.HorzSp * (Position - Display[AtPaint].MoveArray.FirstCol);
                        DrawMap(PosMark, pt);
                        END;
            END;{UpdatePosition}




            PROCEDURE UpdateWrapPoint;
            VAR pt:     Point;
                doUpdate:   BOOLEAN;

            {$S SegTECold}
            BEGIN{UpdateWrapPoint}
                {$IFC SampCalls}   ALogCall;   {$ENDC}
                doUpdate := FALSE;

                WITH HTerm^^, Display [RightNow].MoveArray DO
                    IF VisWrap <> Display[AtPaint].MoveArray.VisWrap THEN
                        doUpdate := TRUE
                    ELSE
                        IF VisWrap THEN
                            doUpdate := VisWrapPoint <> Display[AtPaint].MoveArray.VisWrapPoint;

                IF doUpdate THEN
                    WITH HTerm^^, Display[RightNow].MoveArray DO
                        BEGIN
                        IF Display[AtPaint].MoveArray.VisWrap THEN
                            BEGIN
                            SetPt(pt, FolderZones [RulerBox].left
                                      + Style^^.HorzSp * (Display [AtPaint].MoveArray.VisWrapPoint -
                                                          Display [AtPaint].MoveArray.FirstCol)
                                    , blWrap);
                            UndrawMap(WrapMark, pt);
                            END;

                        IF VisWrap THEN
                            BEGIN
                            SetPt(pt, FolderZones [RulerBox].left
                                      + Style^^.HorzSp * (VisWrapPoint - Display[AtPaint].MoveArray.FirstCol)
                                    , blWrap);
                            DrawMap(WrapMark, pt);
                            END;
                    END;
            END;{UpdateWrapPoint}




            PROCEDURE UpdateButtons;
            VAR oldHitButton:   TButton;

            {$S SegTECold}
            BEGIN{UpdateButtons}
                {$IFC SampCalls}   ALogCall;   {$ENDC}
                oldHitButton := HTerm^^.Display[AtPaint].MoveArray.HitButton;
                WITH HTerm^^, Display [RightNow].MoveArray DO
                    IF oldHitButton <> HitButton THEN
                        BEGIN
                        XorButton(oldHitButton, AtPaint);
                        XorButton(HitButton, RightNow);
                        END;
            END;{UpdateButtons}




            PROCEDURE UpdateColumnsAndTabs;
            VAR TabNr:          INTEGER;
                newMark:        BOOLEAN;
                oldMark:        BOOLEAN;
                SeeTabs:        BOOLEAN;
                SeeColumns:     BOOLEAN;
                HorzSp:         INTEGER;
                pt:             Point;

            {$S SegTECold}
            BEGIN{UpdateColumnsAndTabs}
                {$IFC SampCalls}   ALogCall;   {$ENDC}
                WITH HTerm^^ DO
                    BEGIN
                    SeeTabs := Setup.SeeTabs;
                    SeeColumns := Setup.SeeColumns;
                    HorzSp := Style^^.HorzSp
                    END;

                {$IFC DbgRlrUpdates}
                IF DbgRlrUpdates THEN
                    BEGIN
                    WRITELN('BEGIN UpdateColumnsAndTabs:   HTerm^^.Setup.SeeTabs    = ', SeeTabs);
                    WRITELN('                              HTerm^^.Setup.SeeColumns = ', SeeColumns);
                    END;
                {$ENDC}

                WITH HTerm^^, Display[RightNow].MoveArray DO
                    SetPt(pt, FolderZones[RulerBox].left
                             + HorzSp * (GoodFirst - Display[AtPaint].MoveArray.FirstCol), blTStop);

                FOR TabNr := GoodFirst TO GoodLast DO
                    BEGIN                                               {Update then changed markers.}
                    WITH HTerm^^ DO
                        IF SeeTabs THEN
                            BEGIN
                            oldMark := Display[AtPaint ].MoveArray.TabStops[TabNr];
                            newMark := Display[RightNow].MoveArray.TabStops[TabNr];
                            END
                        ELSE
                            BEGIN
                            oldMark := Display[AtPaint ].MoveArray.ColumnStops[TabNr];
                            newMark := Display[RightNow].MoveArray.ColumnStops[TabNr];
                            END;

                    IF (oldMark <> newMark) AND (TabNr > 1) THEN        {Newer show tab mark 1}
                        BEGIN
                        {$IFC DbgRlrUpdates}
                        IF DbgRlrUpdates THEN
                            WRITELN('    Position = ',TabNr:0,
                                    ', oldMark = ', oldMark,
                                    ', newMark = ', newMark);
                        {$ENDC}

                        IF SeeTabs THEN
                            IF newMark THEN
                                DrawMap(TabMark, pt)
                            ELSE
                                UndrawMap(TabMark, pt)
                        ELSE
                            IF newMark THEN
                                DrawMap(ColumnMark, pt)
                            ELSE
                                UndrawMap(ColumnMark, pt);
                        END;

                    pt.h := pt.h + HorzSp;
                    END;

                {$IFC DbgRlrUpdates}
                IF DbgRlrUpdates THEN
                    WRITELN('END UpdateColumnsAndTabs.');
                {$ENDC}
            END;{UpdateColumnsAndTabs}




            PROCEDURE ComputeUpdateRegion;

            VAR TempRect:   Rect;

            {$S SegTECold}
            BEGIN{ComputeUpdateRegion}
                {$IFC SampCalls}   ALogCall;   {$ENDC}
                WITH HTerm^^, Style^^, Display [RightNow], MoveArray, TempRect DO
                    BEGIN                                                           {Update tic numbers.}
                    TempRect := FolderZones[RulerBox];
                    Left  := Left + HorzSp * (GoodFirst - FirstCol);
                    Right := Left + HorzSp * 2;
                    bottom := blWrap + RectHeight(WrapMark.bounds) ;
                    END;
                RectRgn(TempRgn, TempRect);
                UnionRgn(JunkRgn, TempRgn, JunkRgn);

                WITH HTerm^^, Style^^, Display [RightNow], MoveArray, TempRect DO
                    BEGIN                                                           {Update tic numbers.}
                    Left := FolderZones[RulerBox].Left + HorzSp * (GoodLast - FirstCol - 1);
                    Right := Left + HorzSp * 2;
                    END;
                RectRgn(TempRgn, TempRect);
                UnionRgn(JunkRgn, TempRgn, JunkRgn);
            END;{ComputeUpdateRegion}

        {$S SegTECold}
        BEGIN {DoTabs}
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            TempRgn := NewRgn;
            AuxRgn := NewRgn;

            tempRect := HTerm^^.Display [RightNow].MoveArray.FolderZones [BRulerBox];
            InsetRect(tempRect, -1, 0);                 {Make shure we can draw frame outside BRulerBox}
            ClipRect(tempRect);

            IF (GoodFirst <= GoodLast) AND
               EqualRect(HTerm^^.Display [RightNow].MoveArray.FolderZones [RulerBox],
                         HTerm^^.Display [AtPaint].MoveArray.FolderZones [RulerBox])   THEN
                BEGIN
                ScrollRuler;

                UpdateButtons;
                UpdateWrapPoint;
                UpdateColumnsAndTabs;
                UpdatePosition;

                IF dH <> 0 THEN
                    ComputeUpdateRegion;

                SetClip(JunkRgn);
                END
            ELSE
                EraseRect (HTerm^^.Display[RightNow].MoveArray.FolderZones[RulerBox]);

            PaintRuler (NewFirst, NewLast);   {Paint new ruler.}

            ClipRect (HTerm^^.Folder^.PortRect);

            DisposeRgn(TempRgn);
            DisposeRgn(AuxRgn);
        END; {DoTabs}




        PROCEDURE UpdateLine;

        VAR h:      INTEGER;

        {$S SegTE}
        BEGIN{UpdateLine}
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            PenMode(patXor);
            PenPat(gray);

            WITH HTerm^^, Display[AtPaint].MoveArray DO
                IF ShowGrayLine THEN
                    BEGIN
                    h :=  FolderZones[RulerBox].left + Style^^.HorzSp * (Position - FirstCol);
                    MoveTo(h, FolderZones[TextBox].top);
                    LineTo(h, FolderZones[TextBox].bottom - 1);
                    END;

            WITH HTerm^^, Display[RightNow].MoveArray DO
                IF ShowGrayLine THEN
                    BEGIN
                    h :=  FolderZones[RulerBox].left + Style^^.HorzSp * (Position - FirstCol);
                    MoveTo(h, FolderZones[TextBox].top);
                    LineTo(h, FolderZones[TextBox].bottom - 1);
                    END;

            SetPenState(oldPen);
        END;{UpdateLine}


    {$S SegTE}
    BEGIN {UpdateTabs}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        GetPort(currentPort);
        oldFont := currentPort^.txFont;
        oldFace := currentPort^.txFace;
        GetPenState(oldPen);

        PenNormal;
        TextFont(p20TileLT);
        TextFace([]);

        IF HTerm^^.Display [RightNow].MoveArray.VisTabs OR
           HTerm^^.Display [RightNow].MoveArray.VisColumns THEN
            BEGIN
            WITH HTerm^^.Display[RightNow].MoveArray DO
                BEGIN
                NewFirst := FirstCol;
                NewLast  := NewFirst + NrCols - 1;
                END;

            WITH HTerm^^.Display[AtPaint].MoveArray DO
                IF VisTabs OR VisColumns THEN
                    BEGIN
                    OldFirst := FirstCol;
                    OldLast  := OldFirst + NrCols - 1;
                    END
                ELSE
                    BEGIN
                    OldFirst := 0;
                    OldLast  := 0;
                    END;

            GoodFirst := CMax(OldFirst, NewFirst);
            GoodLast  := CMin(OldLast , NewLast );

            DoTabs;
            END;

        IF      (HTerm^^.Display [AtPaint].MoveArray.ShowGrayLine <>
                HTerm^^.Display [RightNow].MoveArray.ShowGrayLine)
            OR
                    (HTerm^^.Display [RightNow].MoveArray.ShowGrayLine
                AND
                    (HTerm^^.Display [AtPaint].MoveArray.Position <>
                    HTerm^^.Display [RightNow].MoveArray.Position)  )       THEN
            UpdateLine;

(*  Split code disabled [JS]
        WITH HTerm^^ DO                                     {Draw the dividing line.}
            IF DivTabs OR DivCo then
          with HTerm^^.Display [RightNow].MoveArray.FolderZones [BRulerBox] do begin
            MoveTo (Left   , Bottom-1);
            LineTo (Right-1, Bottom-1);
          end;
*)
        TextFont(oldFont);
        TextFace(oldFace);
        SetPenState(oldPen);
    END; {UpdateTabs}                                                  {END UpdateTabs [JS]}



  procedure UpdateScreen;
    {UpdateScreen updates the text area of HTerm.}

    var
      RNewFirst : Integer;              {First RowNr of Display [RightNow].}
      RNewLast  : Integer;              {Last  RowNr of Display [RightNow].}
      ROldFirst : Integer;              {First RowNr of Display [AtPaint ].}
      ROldLast  : Integer;              {Last  RowNr of Display [AtPaint ].}
      RGoodFirst: Integer;              {First RowNr of intersection.}
      RGoodLast : Integer;              {Last  RowNr of intersection.}

      CNewFirst : Integer;              {First ColNr of Display [RightNow].}
      CNewLast  : Integer;              {Last  ColNr of Display [RightNow].}
      COldFirst : Integer;              {First ColNr of Display [AtPaint ].}
      COldLast  : Integer;              {Last  ColNr of Display [AtPaint ].}
      CGoodFirst: Integer;              {First ColNr of intersection.}
      CGoodLast : Integer;              {Last  ColNr of intersection.}

      NewStart: Integer;                {Start of screen in Display [RightNow].}
      NewSeqNr: LongInt;                {SeqNr of first row of Display [RightNow].}
      SeeNewDiv: Boolean;               {Can you see the divider RightNow?}
      NewLines: TRowList;               {List of rows in Display [RightNow].}
      NrNew: Integer;                   {Number of rows in Display [RightNow].}
      NewNr: Integer;

      OldStart: Integer;                {Start of screen in Display [AtPaint ].}
      OldSeqNr: LongInt;                {SeqNr of first row of Display [AtPaint ].}
      SeeOldDiv: Boolean;               {Can you see the divider AtPaint?}
      OldLines: TRowList;               {List of rows in Display [AtPaint ].}
      NrOld: Integer;                   {Number of rows in Display [AtPaint].}

      HFirst: THMatch;                  {Head of the match list.}
      HLast : THMatch;                  {Tail of the match list.}

      Redivide: Boolean;                {Has the divider moved?}
      ChangedRgn: RgnHandle;            {Region to be updated (hard) or NIL (easy).}
      TempRect: Rect;
      I : Integer;



    procedure GetLines (var RowList: TRowList; When: Moment; First: Integer; Last: Integer);
      {GetLines makes a new RowList and GetRow's lines into it.}

      var
        RowNr: Integer;
        HLine: THLine;

      {$S SegTE}
      begin {GetLines}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        for RowNr:=First to Last do begin
          GetRow (HTerm, When, RowNr, HLine);
          RowList[RowNr-First+1]:=HLine;
        end;
      end; {GetLines}



    procedure FreeLines (RowList: TRowList; NrLines: Integer);
      {FreeLines frees all the lines in RowList.}

      var
        I: Integer;

      {$S SegTE}
      begin {FreeLines}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        for I:=1 to NrLines do
          FreeRow (RowList [I]);
      end; {FreeLines}



    procedure DoDivide (Range: Rect);
      {DoDivide XOr draws a dividing line.}

      {$S SegTECold}
      begin {DoDivide}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        if Range.Left<Range.Right then begin
          PenMode (PatXOr);
          PenPat (LtGray);

          MoveTo (Range.Left   , Range.Top);
          LineTo (Range.Right-1, Range.Top);

          PenMode (PatCopy);
          PenPat (Black);
        end;
      end; {DoDivide}



    procedure PaintCols (HRow: THLine; RowNr: Integer;
                         CFirst: Integer; CLast: Integer);
      {PaintCols paints a series of characters in RowNr of HTerm.}

      var
        LastIdx: Integer;
        ThisIdx: Integer;
        LastChar: TTrix;
        ThisChar: TTrix;
        Str: Str255;
        StrIdx: Integer;
        ColNr: Integer;
        CPaintFirst: Integer;



      procedure DoPaint (Str: Str255; CFirst: Integer; CLast: Integer;
                         AttrCh: TCharacter);
        {DoPaint paints Str in the given bounds.  The attributes of the}
        {characters in Str must all be the same, i.e. AttrCh.}

        var
          TempRect: Rect;
          Pt: Point;
          NewClip: RgnHandle;
          OldClip: RgnHandle;
          DoClip: Boolean;
          TempRgn: RgnHandle;

        {$S SegTE}
        begin {DoPaint}
          {$IFC SampCalls}   ALogCall;   {$ENDC}
          with HTerm^^, HRow^^, Style^^, Display [RightNow], MoveArray do begin                     {[JS]}
            TempRect.TopLeft:=FolderZone [TextBox].TopLeft;
            TempRect.Left  :=TempRect.Left + HorzSp*(CFirst-FirstCol);
            TempRect.Right :=TempRect.Left + HorzSp*(CLast-CFirst+1);
            TempRect.Top   :=TempRect.Top  + VertSp*(RowNr-1);
            TempRect.Bottom:=TempRect.Top  + VertSp;

            Pt:=TempRect.TopLeft;
            Pt.V:=Pt.V+Above;

            DoClip:=False;
            if TwoWide then begin
              HScale:=2;

              if not Odd (CFirst) then
                Pt.H:=Pt.H-HorzSp;

              DoClip:=True;
            end;

            if TwoHigh then begin
              VScale:=2;

              Pt.V:=Pt.V-Below;
              if TwoTop then
                Pt.V:=Pt.V+VertSp;

              DoClip:=True;
            end;
          end;

          if DoClip then begin                          {Do the clipping.}
            OldClip:=NewRgn;
            GetClip (OldClip);

            NewClip:=NewRgn;
            RectRgn (NewClip, TempRect);
            SectRgn (NewClip, OldClip, NewClip);
            SetClip (NewClip);
            DisposeRgn (NewClip);
            HTerm^^.Folder^.Grafprocs:=@GProcs;
          end;

          SubBlink (HTerm^^.BlinkRgn, TempRect);        {Erase the area.}
          SubBlink (HTerm^^.InvertRgn, TempRect);
          EraseRect (TempRect);

          if AttrCh.Bold then                           {Do the text face.}
            TextFace (ThePort^.TxFace + [Bold]);

          if AttrCh.Underscore then
            TextFace (ThePort^.TxFace + [Underline]);

          if AttrCh.Graphic then                        {Do the style.}
            if HTerm^^.Setup.Cols80 then
              TextFont (p12Graf)
            else
              TextFont (p20Graf);

          MoveTo (Pt.H, Pt.V);                          {Draw it.}
          DrawString (Str);

          if not Redivide then
            if RowNr=NewStart then
              DoDivide (TempRect);

          if AttrCh.Graphic then                        {Undo the style.}
            if HTerm^^.Setup.Cols80 then
              TextFont (p12TileLT)
            else
              TextFont (p20TileLT);

          TextFace ([]);                                {Undo the text face.}

          if AttrCh.Blink then
            AddBlink (HTerm^^.BlinkRgn, TempRect);

          if AttrCh.Negative then
            AddBlink (HTerm^^.InvertRgn, TempRect);

          if DoClip then begin                          {Undo the clipping.}
            SetClip (OldClip);
            DisposeRgn (OldClip);
            HTerm^^.Folder^.Grafprocs:=NIL;

          end;

          HScale:=1;
          VScale:=1;

          with HTerm^^.CursorRect^^ do                  {Repaint obscured cursor.}
            if BlinkVis or Solid then
              if PtInRect (BlinkArea^^.RgnBBox.TopLeft, TempRect) then
                InvertRgn (BlinkArea);

          if BlinkVis or HTerm^^.CaretRect^^.Solid then begin
            TempRgn:=NewRgn;                            {Repaint obscured selection.}
            RectRgn (TempRgn, TempRect);
            SectRgn (HTerm^^.CaretRect^^.BlinkArea, TempRgn, TempRgn);
            if not EmptyRgn (TempRgn) then
              InvertRgn (TempRgn);
            DisposeRgn (TempRgn);
          end;
        end; {DoPaint}

      {$S SegTE}
      begin {PaintCols}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        LastIdx:=-1;
        with HRow^^ do
          LastChar.Ch:=TextLine [RealCol (CFirst, TwoWide)];

        StrIdx:=0;

        CPaintFirst:=CFirst;
        for ColNr:=CFirst to CLast do begin
          ThisIdx:=RealCol (ColNr, HRow^^.TwoWide);

          if ThisIdx<>LastIdx then begin
            ThisChar.Ch:=HRow^^.TextLine [ThisIdx];

            if ThisChar.Ch2<>LastChar.Ch2 then begin
              DoPaint (Str, CPaintFirst, ColNr-1, LastChar.Ch);
              CPaintFirst:=ColNr;

              StrIdx:=0;
            end;

            StrIdx:=StrIdx+1;
            Str [0]:=Chr (StrIdx);
            Str [StrIdx]:=ThisChar.Ch1;

            LastIdx    :=ThisIdx;
            LastChar.Ch:=ThisChar.Ch;
          end;
        end;

        if StrIdx>0 then
          DoPaint (Str, CPaintFirst, CLast, LastChar.Ch);
      end; {PaintCols}



    procedure FindMatches (var HFirst: THMatch; var HLast: THMatch);
      {FindMatches returns HFirst and HLast pointing to a list of corresponding}
      {old and new lines.  Two lines match if they have the same SeqNr.  Matching}
      {is done assuming that there are only shifts in order, and no shuffling}
      {done to get to the new lines.  This holds since Scroll (in Term) assigns}
      {unique SeqNr's to new lines scrolled in.  This procedure should be Order-N}
      {in most cases (simple upward scrolling of the whole display), but can}
      {quickly degenerate to Order-N**2, particularly when no lines match}
      {between the old and new lists.  (Considering that N should rarely be}
      {over 24, this is no big deal.)}

      var
        Matching: Boolean;
        NewNr: Integer;
        OldNr: Integer;
        TheSeqNr: LongInt;
        Searching: Boolean;
        OldSearch: Integer;
        HNewMatch: THMatch;

      {$S SegTE}
      begin {FindMatches}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        HLast :=NIL;
        HFirst:=NIL;

        NewNr:=1;
        OldNr:=1;
        Matching:=False;
        while (NewNr<=NrNew) and (OldNr<=NrOld) do begin
          TheSeqNr:=NewLines[NewNr]^^.SeqNr;

          if Matching then                              {Try to extend the match.}
            if OldLines[OldNr]^^.SeqNr=TheSeqNr then begin {Extend the match.}
              with HLast^^ do
                Len:=Len+1;

              OldNr:=OldNr+1;

            end else                                    {This doesn't extend it.}
              Matching:=False;

          if not Matching then begin                    {Try to start a new match.}
            Searching:=True;                            {Search for a match.}
            OldSearch:=OldNr;
            while Searching and (OldSearch<=NrOld) do
              if OldLines[OldSearch]^^.SeqNr=TheSeqNr then
                Searching:=False
              else
                OldSearch:=OldSearch+1;

            if not Searching then begin                 {Found a match.}
              NewHMatch (HNewMatch);                    {Make the match record.}
              with HNewMatch^^ do begin
                Prev:=HLast;
                Next:=NIL;

                NewStart:=NewNr;
                OldStart:=OldSearch;
                Len:=1;
              end;

              if HLast=NIL then                         {Put it on the list.}
                HFirst:=HNewMatch
              else
                HLast^^.Next:=HNewMatch;
              HLast:=HNewMatch;

              Matching:=True;                           {Continue matching ...}
              OldNr:=OldSearch+1;                       {... at the next one.}
            end;
          end;

          NewNr:=NewNr+1;
        end;
      end; {FindMatches}



    procedure MoveMatches (HHead: THMatch; GoForward: Boolean);
      {MoveMatches scrolls the list of matching areas.}
      {HHead = HFirst  GoForward = True   means do up   moves top-to-bottom.}
      {HHead = HLast   GoForward = False  means do down moves bottom-to-top.}
      {If the implicit parameter ChangedRgn is not NIL then the region}
      {invalidated by ScrollRect is unioned into ChangedRgn to be used}
      {as the clip region in the hard case of updating, to follow.}

      var
        HMatch: THMatch;
        HNextMatch: THMatch;
        Lower: Integer;
        Higher: Integer;
        BlockEnd: Integer;
        dH: Integer;
        dV: Integer;
        TempRect: Rect;
        RFirst: Integer;
        RLast: Integer;
        NewNr: Integer;



      procedure ScrollRgn (TheArea: RgnHandle; MoveRect: Rect;
                           dH: Integer; dV: Integer);
        {ScrollRgn scrolls the area described by MoveRect within TheArea by}
        {dH and dV pixels.}

        var
          ScrollArea: RgnHandle;
          MoveArea: RgnHandle;
          TempRect: Rect;

        {$S SegTECold}
        begin {ScrollRgn}
          {$IFC SampCalls}   ALogCall;   {$ENDC}
          if not EmptyRgn (TheArea) then
            if SectRect (TheArea^^.RgnBBox, MoveRect, TempRect) then begin
              MoveArea:=NewRgn;                             {Region to scroll in.}
              RectRgn (MoveArea, MoveRect);

              ScrollArea:=NewRgn;                           {Scroll stuff inside MoveArea.}
              CopyRgn (TheArea, ScrollArea);
              OffsetRgn (ScrollArea, dH, dV);
              SectRgn (ScrollArea, MoveArea, ScrollArea);

              DiffRgn (TheArea, MoveArea, TheArea);         {Replace w/scrolled stuff.}
              UnionRgn (TheArea, ScrollArea, TheArea);

              DisposeRgn (ScrollArea);
              DisposeRgn (MoveArea);
            end;
        end; {ScrollRgn}

      {$S SegTE}
      begin {MoveMatches}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        dH:=DeltaH (HTerm, COldFirst, CNewFirst);

        HMatch:=HHead;
        while HMatch<>NIL do begin
          with HMatch^^ do begin
            if GoForward then begin
              HNextMatch:=Next;

              Lower :=NewStart;
              Higher:=OldStart;

            end else begin
              HNextMatch:=Prev;

              Lower :=OldStart;
              Higher:=NewStart;
            end;

            BlockEnd:=Higher+Len-1;
            dV:=DeltaV (HTerm, NewStart, OldStart);
          end;

          if (Lower<Higher) or
            ((Lower=Higher) and GoForward) then begin
            if (dH<>0) or (dV<>0) then begin
              RowsToRect (HTerm, Lower, BlockEnd, ScreenBase, TempRect);
              ScrollRect (TempRect, dH, dV, JunkRgn);

              ScrollRgn (HTerm^^.CursorRect^^.BlinkArea, TempRect, dH, dV);
              ScrollRgn (HTerm^^.CaretRect ^^.BlinkArea, TempRect, dH, dV);
              ScrollRgn (HTerm^^.BlinkRgn  ^^.BlinkArea, TempRect, dH, dV);
              ScrollRgn (HTerm^^.InvertRgn ^^.BlinkArea, TempRect, dH, dV);
            end;

            if ChangedRgn<>NIL then begin               {Hard update case.}
              if (dH<>0) or (dV<>0) then                {Add in rgn invalidated by scrolling.}
                UnionRgn (ChangedRgn, JunkRgn, ChangedRgn);

            end else begin                              {Easy update case.}
              with HMatch^^ do begin                    {Repaint columns invalidated by scrolling.}
                RFirst:=NewStart;
                RLast :=NewStart+Len-1;
              end;

              if CNewFirst<=CGoodFirst-1 then
                for NewNr:=RFirst to RLast do
                  PaintCols (NewLines[NewNr], NewNr, CNewFirst  , CGoodFirst-1);

              if CGoodLast+1<=CNewLast then
                for NewNr:=RFirst to RLast do
                  PaintCols (NewLines[NewNr], NewNr, CGoodLast+1, CNewLast    );
            end;
          end;

          HMatch:=HNextMatch;
        end;
      end; {MoveMatches}



    procedure UpdateMatches (HFirst: THMatch;
                             procedure UpdateCols (HRow: THLine; RowNr: Integer;
                                                   CFirst: Integer; CLast: Integer);
                             procedure UpdateEnd);
      {UpdateMatches updates the rows in the new screen.  A row is painted if}
      {it's not incompassed by a match record.  If it is, then it is incrementally}
      {updated.  UpdateCols is a procedure parameter called when a specific area}
      {of a row needs to be updated.  UpdateEnd is supplied to clean up after the}
      {paint is done.  The two procedure parameters are used to distinguish the}
      {easy and hard update cases.}

      var
        HMatch: THMatch;
        NewNr: Integer;
        PaintIt: Boolean;
        Looking: Boolean;
        ColNr: Integer;
        NewRow: THLine;
        OldRow: THLine;
        Equal: Boolean;
        CNr: Integer;
        CPaintFirst: Integer;
        NewCh: TTrix;
        OldCh: TTrix;

      {$S SegTE}
      begin {UpdateMatches}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        HMatch:=HFirst;
        for NewNr:=1 to NrNew do begin                  {For each line ...}
          PaintIt:=True;                                {Is it in a match?}
          Looking:=True;
          while Looking and (HMatch<>NIL) do
            with HMatch^^ do
              if NewNr<NewStart+Len then begin
                PaintIt:= (NewNr<NewStart);
                Looking:=False;

              end else
                HMatch:=Next;

          NewRow:=NewLines [NewNr];
          if PaintIt then                               {Not in a match.}
            UpdateCols (NewRow, NewNr, CNewFirst, CNewLast)

          else begin                                    {In a match.}
            with HMatch^^ do
              OldRow:=OldLines[OldStart + (NewNr-NewStart)];

            if NewRow^^.Repaint then                    {Requires repaint.}
              UpdateCols (NewRow, NewNr, CNewFirst, CNewLast)

            else if NewRow^^.Changed then begin         {Requires update.}
              Equal:=True;
              for ColNr:=CGoodFirst to CGoodLast do begin {UpdateCols for each}
                CNr:=RealCol (ColNr, NewRow^^.TwoWide);   {contiguous group of}
                                                          {changed characters.}
                NewCh.Ch:=NewRow^^.TextLine [CNr];
                OldCh.Ch:=OldRow^^.TextLine [CNr];

                if NewCh.Int=OldCh.Int then begin
                  if not Equal then begin
                    UpdateCols (NewRow, NewNr, CPaintFirst, ColNr-1);
                    Equal:=True;
                  end;

                end else begin
                  if Equal then begin
                    CPaintFirst:=ColNr;
                    Equal:=False;
                  end;
                end;
              end;

              if not Equal then
                UpdateCols (NewRow, NewNr, CPaintFirst, CNewLast);
            end;
          end;
        end;

        UpdateEnd;
      end; {UpdateMatches}



    procedure EasyCols (HRow: THLine; RowNr: Integer;
                        CFirst: Integer; CLast: Integer);
      {EasyCols paints the given area of the given line for the easy update case.}

      {$S SegTE}
      begin {EasyCols}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        PaintCols (HRow, RowNr, CFirst, CLast);
      end; {EasyCols}



    procedure HardCols (HRow: THLine; RowNr: Integer;
                        CFirst: Integer; CLast: Integer);
      {HardCols adds the given area of the given line to the ChangedRgn}
      {for the hard update case.}

      var
        TheRect: Rect;
        TheRgn: RgnHandle;

      {$S SegTECold}
      begin {HardCols}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        ColsToRect (HTerm, RowNr, CFirst, CLast, False, ScreenBase, TheRect);
        TheRgn:=NewRgn;
        RectRgn (TheRgn, TheRect);
        UnionRgn (ChangedRgn, TheRgn, ChangedRgn);
        DisposeRgn (TheRgn);
      end; {HardCols}



    procedure EasyEnd;
      {EasyEnd cleans up after a paint for the easy case.  At this point, the}
      {easy-case screen has been entirely updated, so EasyEnd need not do anything.}

      {$S SegTE}
      begin {EasyEnd}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      end; {EasyEnd}



    procedure HardEnd;
      {HardEnd cleans up after a paint for the hard case.  First it takes the}
      {difference between the AtPaint and RightNow text areas, and adds it to}
      {the ChangedRgn.  Then, we clip to the ChangedRgn and repaint the entire}
      {contents of the text area.}

      var
        RgnA: RgnHandle;
        RgnB: RgnHandle;
        NewNr: Integer;

      {$S SegTECold}
      begin {HardEnd}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        RgnA:=NewRgn;                                   {Find the difference.}
        RgnB:=NewRgn;

        RectRgn (RgnA, HTerm^^.Display [RightNow].MoveArray.FolderZones [TextBox]);                 {[JS]}
        RectRgn (RgnB, HTerm^^.Display [AtPaint ].MoveArray.FolderZones [TextBox]);                 {[JS]}

        DiffRgn (RgnA, RgnB, RgnA);
        UnionRgn (ChangedRgn, RgnA, ChangedRgn);        {Add to ChangedRgn.}

        DisposeRgn (RgnA);
        DisposeRgn (RgnB);

        SetClip (ChangedRgn);                           {Clip and repaint.}

        for NewNr:=1 to NrNew do
          PaintCols (NewLines[NewNr], NewNr, CNewFirst, CNewLast);

        ClipRect (ThePort^.PortRect);
      end; {HardEnd}



    procedure MoveRows (HHead: THMatch; GoForward: Boolean);
      {MoveRows scrolls the list of matching areas of lines in the Terminal}
      {Screen Area of HTerm^^.Display [AtPaint].}
      {HHead = HFirst  GoForward = True   means do up   moves top-to-bottom.}
      {HHead = HLast   GoForward = False  means do down moves bottom-to-top.}

      var
        HMatch: THMatch;
        HNextMatch: THMatch;
        Lower: Integer;
        Higher: Integer;
        BlockEnd: Integer;
        dV: Integer;
        NewNr: Integer;
        Exg1: Integer;
        Exg2: Integer;
        HExgLine: THLine;

      {$S SegTE}
      begin {MoveRows}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        HMatch:=HHead;
        while HMatch<>NIL do begin
          with HMatch^^ do begin
            if GoForward then begin
              HNextMatch:=Next;

              Lower :=NewStart;
              Higher:=OldStart;

            end else begin
              HNextMatch:=Prev;

              Lower :=OldStart;
              Higher:=NewStart;
            end;

            BlockEnd:=Higher+Len-1;
            dV:=NewStart-OldStart;
          end;

          if Lower<Higher then
            with HTerm^^.Display [AtPaint], MoveArray do                                            {[JS]}
              if dV<0 then begin              {Scroll it up.}
                Exg1:=Lower;
                for Exg2:=Lower-dV to BlockEnd do begin
                  HExgLine:=Screen [Exg1];
                  Screen [Exg1]:=Screen [Exg2];
                  Screen [Exg2]:=HExgLine;

                  Exg1:=Exg1 + 1;
                end;

              end else begin                  {Scroll it down.}
                Exg1:=BlockEnd;
                for Exg2:=BlockEnd-dV downto Lower do begin
                  HExgLine:=Screen [Exg1];
                  Screen [Exg1]:=Screen [Exg2];
                  Screen [Exg2]:=HExgLine;

                  Exg1:=Exg1 - 1;
                end;
              end;

          HMatch:=HNextMatch;
        end;
      end; {MoveMatches}



    procedure FreeMatches (HHead: THMatch);
      {FreeMatches frees the list of matches starting at HHead.}

      var
        HMatch: THMatch;
        HNextMatch: THMatch;

      {$S SegTE}
      begin {FreeMatches}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        HMatch:=HHead;
        while HMatch<>NIL do begin
          HNextMatch:=HMatch^^.Next;
          DspHMatch (HMatch);

          HMatch:=HNextMatch;
        end;
      end;  {FreeMatches}

    {$S SegTE}
    begin {UpdateScreen}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      with HTerm^^ do begin
        with Display [RightNow], MoveArray do begin                                                 {[JS]}
          RNewFirst:=FirstRow;
          CNewFirst:=FirstCol;
          RNewLast:=RNewFirst+NrRows-1;
          CNewLast:=CNewFirst+NrCols-1;

          NewStart:=StartScreen;
          NewSeqNr:=Screen [MinRow]^^.SeqNr;
        end;
        NrNew:=RNewLast-RNewFirst+1;

        with Display [AtPaint], MoveArray do begin                                                  {[JS]}
          ROldFirst:=FirstRow;
          COldFirst:=FirstCol;
          ROldLast:=ROldFirst+NrRows-1;
          COldLast:=COldFirst+NrCols-1;

          OldStart:=StartScreen;
          OldSeqNr:=Screen [MinRow]^^.SeqNr;
        end;
        NrOld:=ROldLast-ROldFirst+1;
      end;

      RGoodFirst:=CMax (ROldFirst, RNewFirst);
      CGoodFirst:=CMax (COldFirst, CNewFirst);
      RGoodLast :=CMin (ROldLast , RNewLast );
      CGoodLast :=CMin (COldLast , CNewLast );

      Redivide:= ((NewSeqNr<>OldSeqNr) or (CNewFirst<>COldFirst));
      SeeNewDiv:= ((NewStart>=RNewFirst) and (NewStart<=RNewLast));
      SeeOldDiv:= ((OldStart>=ROldFirst) and (OldStart<=ROldLast));

      NewStart:=NewStart - RNewFirst + 1;
      OldStart:=OldStart - ROldFirst + 1;

      if Redivide and SeeOldDiv then
        DoDivide (HTerm^^.Display [AtPaint ].MoveArray.FolderZones [Divide]);                       {[JS]}

      if not HTerm^^.Setup.WhiteScreen then begin       {Set to black background.}
        BackPat (Black);
        TextMode (SrcBIC);
      end;

      GetLines (NewLines, RightNow, RNewFirst, RNewLast);

      if (RGoodFirst<=RGoodLast) and (CGoodFirst<=CGoodLast) then begin
        GetLines (OldLines, AtPaint , ROldFirst, ROldLast);

        if AllVisible (HTerm, TextBox) then
          ChangedRgn:=NIL
        else
          ChangedRgn:=NewRgn;

        FindMatches (HFirst, HLast);                    {Find the list of matches.}

        MoveMatches (HFirst, True );                    {Scroll  forward through matches.}
        MoveMatches (HLast , False);                    {Scroll backward through matches.}

        if ChangedRgn=NIL then                          {Paint the changes.}
          UpdateMatches (HFirst, EasyCols, EasyEnd)

        else begin
          UpdateMatches (HFirst, HardCols, HardEnd);
          DisposeRgn (ChangedRgn);
        end;

        FreeMatches (HFirst);                           {Free up the list of matches.}

        FreeLines (OldLines, NrOld);

      end else
        for NewNr:=1 to NrNew do
          PaintCols (NewLines[NewNr], NewNr, CNewFirst, CNewLast);

      FreeLines (NewLines, NrNew);

      TempRect:=HTerm^^.Display [RightNow].MoveArray.FolderZones [TextBox];                         {[JS]}
      ClipBlink (HTerm^^.BlinkRgn  , TempRect);
      ClipBlink (HTerm^^.InvertRgn , TempRect);

      BackPat (White);                                  {Restore white background.}
      TextMode (SrcOr);

      with HTerm^^, Display [RightNow], MoveArray do    {Set the new divider.}                      {[JS]}
        if (StartScreen>=FirstRow) and (StartScreen<=FirstRow+NrRows) then begin
          FolderZones [Divide]:=FolderZones [TextBox];
          with FolderZones [Divide], Style^^ do begin
            Top:=Top + VertSp*(StartScreen-FirstRow);
            Bottom:=Top;
          end;

        end else
          FolderZones [Divide]:=ZeroRect;

      if Redivide and SeeNewDiv then
        DoDivide (HTerm^^.Display [RightNow].MoveArray.FolderZones [Divide]);                       {[JS]}

      NrNew:=MaxRow-MinRow+1;           {Set up to scroll the AtPaint lines to}
      NrOld:=NrNew;                     {match them with the RightNow lines.}

      with HTerm^^ do begin             {Fake up NewLines and OldLines.}
        For I := 1 to 24 do begin
          NewLines[I]:=Display [RightNow].Screen[I];
          OldLines[I]:=Display [AtPaint ].Screen[I];
        end;
      end;


      FindMatches (HFirst, HLast);      {Find the matching areas.}

      MoveRows (HFirst, True );         {Scroll  forward through matches.}
      MoveRows (HLast , False);         {Scroll backward through matches.}

      FreeMatches (HFirst);             {Free up the list of matches.}
    end; {UpdateScreen}



  procedure UpdateActive;
    {UpdateActive either paints the selection or paints the cursor.  The}
    {selection is painted if it is non-empty.}



    procedure UpdateSelection;
      {UpdateSelection recreates the inversion region for HTerm's selection.}

      var
        lVertSp: Integer;
        lHorzSp: Integer;
        lTextBox: Rect;
        HRow: THLine;
        TL: Point;
        BR: Point;
        PtV: LongInt;
        TempRect: Rect;
        TempRgn: RgnHandle;
        SelRgn: RgnHandle;
        TheCh: Integer;

      {$S SegTECold}
      begin {UpdateSelection}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        with HTerm^^, Style^^, Display [RightNow], MoveArray do begin                               {[JS]}
          lVertSp:=VertSp;
          lHorzSp:=HorzSp;
          lTextBox:=FolderZones [TextBox];
        end;

        GetRow (HTerm, RightNow, HTerm^^.Select.Left .Ln, HRow);
        TheCh:=RealCh (HTerm^^.Select.Left.Ch, HRow^^.TwoWide);
        FreeRow (HRow);

        with HTerm^^, Select.Left , Display [RightNow],MoveArray do begin                           {[JS]}
          PtV :=lTextBox.Top  + lVertSp*(   Ln - FirstRow);
          if PtV<lTextBox.Top then
            PtV:=lTextBox.Top;

          TL.V:=PtV;
          TL.H:=lTextBox.Left + lHorzSp*(TheCh - FirstCol);
        end;

        if HTerm^^.Select.Right.Ch=MinCol then
          TheCh:=MinCol

        else begin
          GetRow (HTerm, RightNow, HTerm^^.Select.Right.Ln, HRow);
          TheCh:=RealCh (HTerm^^.Select.Right.Ch, HRow^^.TwoWide);
          FreeRow (HRow);
        end;

        with HTerm^^, Select.Right, Display [RightNow], MoveArray do begin                          {[JS]}
          PtV :=lTextBox.Top  + lVertSp*(   Ln - FirstRow);
          if PtV>lTextBox.Bottom then
            PtV:=lTextBox.Bottom;

          BR.V:=PtV;
          BR.H:=lTextBox.Left + lHorzSp*(TheCh - FirstCol);
        end;

        SelRgn:=NewRgn;                                 {Create bounding rectangle.}
        SetRectRgn (SelRgn, lTextBox.Left  ,
                      CMax (lTextBox.Top   , TL.V),
                            lTextBox.Right ,
                      CMin (lTextBox.Bottom, BR.V+lVertSp));

        TempRgn:=NewRgn;

        TempRect.Top   :=TL.V;                          {Remove top line portion.}
        TempRect.Bottom:=TL.V+lVertSp;
        TempRect.Left  :=lTextBox.Left;
        TempRect.Right :=TL.H;
        RectRgn (TempRgn, TempRect);
        DiffRgn (SelRgn, TempRgn, SelRgn);

        TempRect.Top   :=BR.V;                          {Remove bottom line portion.}
        TempRect.Bottom:=BR.V+lVertSp;
        TempRect.Left  :=BR.H;
        TempRect.Right :=lTextBox.Right;
        RectRgn (TempRgn, TempRect);
        DiffRgn (SelRgn, TempRgn, SelRgn);

        DisposeRgn (TempRgn);

        RgnChangeBlink (HTerm^^.CaretRect, SelRgn);     {Set selection.}
        DisposeRgn (SelRgn);
      end; {UpdateSelection}



    procedure UpdateCursor;
      {UpdateCursor refreshes the cursor.}

      var
        TempRect: Rect;
        HRow: THLine;

      {$S SegTE}
      begin {UpdateCursor}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        GetRow (HTerm, RightNow, HTerm^^.Cursor.Ln, HRow);
        if HRow^^.TwoTop then
          TempRect:=ZeroRect

        else
          with HTerm^^, Style^^, Cursor, Setup, Display [RightNow],MoveArray,  HRow^^ do begin      {[JS]}
            TempRect.TopLeft:=FolderZones [TextBox].TopLeft;

            TempRect.Left    :=TempRect.Left + HorzSp*(RealCh (Ch, TwoWide) - FirstCol);
            if TwoWide then
              TempRect.Right :=TempRect.Left + HorzSp*2
            else
              TempRect.Right :=TempRect.Left + HorzSp;

            TempRect.Top     :=TempRect.Top  + VertSp*(        Ln           - FirstRow);
            if BlockCursor then
              TempRect.Bottom:=TempRect.Top  + VertSp
            else begin
              TempRect.Top   :=TempRect.Top  + Above;
              TempRect.Bottom:=TempRect.Top  + 1;
            end;

            if SectRect (FolderZones [TextBox], TempRect, TempRect) then;
          end;
        FreeRow (HRow);

        ChangeBlink (HTerm^^.CursorRect, TempRect);
      end; {UpdateCursor}

    {$S SegTE}
    begin {UpdateActive}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      if IsInsertion (HTerm) then begin                 {Insertion.}
        UpdateCursor;
        ChangeBlink (HTerm^^.CaretRect, ZeroRect);

      end else begin                                    {Selection.}
        if HTerm=TheTerm then
          UpdateSelection;
        ChangeBlink (HTerm^^.CursorRect, ZeroRect);
      end;
    end; {UpdateActive}



  procedure EraseBorders;
    {EraseBorders erases the borders around the text and tab boxes.}



    procedure DoErase (BigBox: TZone; SmallBox: TZone; var FillPat: Pattern);
      {DoErase erases the region FolderZones [BigBox] - FolderZones [SmallBox].}

      var
        LMargin: Rect;                  {Margins=BxxxBox-xxxBox}
        TMargin: Rect;
        RMargin: Rect;
        BMargin: Rect;

      {$S SegTE}
      begin {DoErase}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        with HTerm^^.Display [RightNow], MoveArray do begin                                         {[JS]}
          LMargin:=FolderZones [BigBox];
          if BigBox=BRulerBox then                                                                  {[JS]}
            LMargin.Bottom:=LMargin.Bottom-1;

          TMargin:=LMargin;
          RMargin:=LMargin;
          BMargin:=LMargin;

          LMargin.Right :=FolderZones [SmallBox].Left  ;
          TMargin.Bottom:=FolderZones [SmallBox].Top   ;
          RMargin.Left  :=FolderZones [SmallBox].Right ;
          BMargin.Top   :=FolderZones [SmallBox].Bottom;
        end;

        FillRect (LMargin, FillPat);
        FillRect (TMargin, FillPat);
        FillRect (RMargin, FillPat);
        FillRect (BMargin, FillPat);
      end; {DoErase}

    {$S SegTE}
    begin {EraseBorders}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      (* dissabled [JS]
      IF HTerm^^.Display [RightNow].MoveArray.VisTabs OR                                            {[JS]}
         HTerm^^.Display [RightNow].MoveArray.VisColumns THEN                                       {[JS]}
          DoErase (BRulerBox, RulerBox, White);
      *)

      if HTerm^^.Setup.WhiteScreen then
        DoErase (BTextBox, TextBox, White)
      else
        DoErase (BTextBox, TextBox, Black);
    end; {EraseBorders}



  procedure UpdateThumb;
    {UpdateThumb moves the scroll bar thumbs to their correct positions if HTerm}
    {is the active terminal.}

    {$S SegTE}
    begin {UpdateThumb}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      if HTerm^^.Display [AtPaint ].MoveArray.HThumbPos <>                                          {[JS]}
         HTerm^^.Display [RightNow].MoveArray.HThumbPos then begin                                  {[JS]}
        SetupMvThumb (HTerm^^.HSBar);
        MoveThumb (HTerm^^.Display [RightNow].MoveArray.HThumbPos);                                 {[JS]}
      end;

      if HTerm^^.Display [AtPaint ].MoveArray.VThumbPos <>                                          {[JS]}
         HTerm^^.Display [RightNow].MoveArray.VThumbPos then begin                                  {[JS]}
        SetupMvThumb (HTerm^^.VSBar);
        MoveThumb (HTerm^^.Display [RightNow].MoveArray.VThumbPos);                                 {[JS]}
      end;
    end; {UpdateThumb}



  procedure UpdateGrey;
    {UpdateGrey repaints the grey areas to the right and below BTextBox.}

    var
      VGrey: Rect;
      HGrey: Rect;
      Pt1: Point;
      Pt2: Point;
      Pt3: Point;

    {$S SegTE}
    begin {UpdateGrey}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      with HTerm^^.Display [RightNow], MoveArray do begin                                           {[JS]}
        VGrey:=FolderZones [VGreyBox];
        HGrey:=FolderZones [HGreyBox];
      end;

      Pt1:=VGrey.TopLeft;
      Pt2:=HGrey.TopLeft;
      Pt3.H:=VGrey.Left;
      Pt3.V:=HGrey.Top;

      VGrey.Left:=VGrey.Left + 1;
      HGrey.Top :=HGrey.Top  + 1;

      if RectWidth (VGrey)>0 then begin
        FillRect (VGrey, LtGray);
        MoveTo (Pt1.H, Pt1.V);
        LineTo (Pt3.H, Pt3.V);

        HGrey.Right:=HGrey.Right + 1;
      end;

      if RectHeight (HGrey)>0 then begin
        FillRect (HGrey, LtGray);
        MoveTo (Pt2.H, Pt2.V);
        LineTo (Pt3.H, Pt3.V);
      end;
    end; {UpdateGrey}



  procedure UpdateState;
    {Update State makes the variables pertaining to HTerm's display reflect}
    {the current state of the display.  Note that UpdateScreen rearranged the}
    {AtPaint lines to match the RightNow lines.  Display [xxx].MoveArray is}
    {employed to speed up equating the AtPaint state to match the RightNow}
    {state variables.}

    var
      RowNr: Integer;
      HNew: THLine;
      HOld: THLine;

    {$S SegTE}
    begin {UpdateState}
      {$IFC SampCalls}   ALogCall;   {$ENDC}
      with HTerm^^ do begin
        for RowNr:=MinRow to MaxRow do begin
          HNew:=Display [RightNow].Screen [RowNr];
          HOld:=Display [AtPaint ].Screen [RowNr];

          with HNew^^ do
            if Changed or Repaint or (SeqNr<>HOld^^.SeqNr) then begin
              Changed:=False;
              Repaint:=False;

              HOld^^:=HNew^^;
            end;
        end;

        Display [AtPaint ].MoveArray:=Display [RightNow].MoveArray;

        Changed:=False;
        LastUpdate:=Time;
        NrChanges:=0;
      end;
    end; {UpdateState}

  {$S SegTE}
  begin {UpdateTerm}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    {$IFC PrintTime }
      P_Time:=Time;
    {$ENDC }

    GetPort (SavePort);
    SetPort (HTerm^^.Folder);

    {For Testing purposes do
    InvertRgn(HTerm^^.Folder^.ClipRgn);
    InvertRgn(HTerm^^.Folder^.ClipRgn);
    InvertRgn(HTerm^^.Folder^.ClipRgn);
    InvertRgn(HTerm^^.Folder^.ClipRgn);}

    If HTerm^^.Setup.Cols80 then TextFont(p12TileLT);

    UpdateLights;
    UpdateTabs;
    UpdateScreen;
    EraseBorders;
    UpdateActive;
    UpdateGrey;

    if HTerm=TheTerm then
      UpdateThumbs
    else
      UnpaintSBs (HTerm);

    UpdateState;
    SetPort (SavePort);

    {$IFC PrintTime }
      P_Time:=Time - P_Time;

      if P_Time <= 50 then
        P_Hist [P_Time]:=P_Hist [P_Time] + 1
      else
        P_Over:=P_Over + 1;
    {$ENDC }
  end; {UpdateTerm}



procedure SizeTerm (HTerm: THTerm);
  {SizeTerm sets values in HTerm's Display [RightNow] to fill}
  {its Folder.PortRect.}

  var
    SavePort: GrafPtr;
    Remains: Rect;
    TempRect: Rect;
    Zone: TZone;
    H: Integer;
    V: Integer;
    LoLimit: Integer;
    HiLimit: Integer;
    TextWidth: Integer;
    TextHeight: Integer;
    MaxNrCols: Integer;
    MaxNrRows: Integer;
    HRect: Rect;
    VRect: Rect;
    GRect: Rect;



    PROCEDURE ComputeButtons(r: Rect);                                          {BEGIN ComputeButtons [JS]}
    VAR currentPort:    GrafPtr;
        oldFont:        INTEGER;
        oldFace:        Style;
        width:          INTEGER;



        FUNCTION  BtnWidth(VAR btnText: Str40): INTEGER;
        {$S SegTECold}
        BEGIN
            {$IFC SampCalls}   ALogCall;   {$ENDC}
            BtnWidth := BtnBWidth * 2 + BtnOvalWidth + StringWidth(btnText);
        END;

    {$S SegTECold}
    BEGIN{ComputeButtons}
        {$IFC SampCalls}   ALogCall;   {$ENDC}
        GetPort(currentPort);
        oldFont := currentPort^.txFont;
        oldFace := currentPort^.txFace;

        TextFont(sysText);
        TextFace([]);

        InsetRect(r, HMargin, VMargin);                                     {Space for buttons}
        WITH r DO
            Top := Bottom - 2 * BtnBHeight - 2 * VMargin - sysAscent - sysDescent;

        WITH HTerm^^, Setup, Display [RightNow].MoveArray DO
            BEGIN
            {The button zones are asumed to be =ZereoRect uppon entry to ComputeButtons}

            width := BtnWidth(mGoAway);
            IF RectWidth(r) >= width THEN
                BEGIN
                FolderZones[GoAway] := r;
                FolderZones[GoAway].right := FolderZones[GoAway].left + width;
                r.left := FolderZones[GoAway].right + HMargin;

                IF SeeTabs THEN
                    width := BtnWidth(mClrTab)
                ELSE
                    width := BtnWidth(mClrColumn);
                IF RectWidth(r) >= width THEN
                    BEGIN
                    FolderZones[ClrTabOrColumn] := r;
                    FolderZones[ClrTabOrColumn].left := FolderZones[ClrTabOrColumn].right - width;
                    r.right := FolderZones[ClrTabOrColumn].left - HMargin;

                    IF SeeTabs THEN
                        width := BtnWidth(mSetTab)
                    ELSE
                        width := BtnWidth(mSetColumn);
                    IF RectWidth(r) >= width THEN
                        BEGIN
                        FolderZones[SetTabOrColumn] := r;
                        FolderZones[SetTabOrColumn].left := FolderZones[SetTabOrColumn].right - width;
                        END
                    END
                END
            END;

        TextFont(oldFont);
        TextFace(oldFace);
    END;{ComputeButtons}                                                        {END ComputeButtons [JS]}

  {$S SegTE}
  begin {SizeTerm}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    Remains:=HTerm^^.Folder^.PortRect;

    GetPort (SavePort);                         {Find the grow box and scroll bar sizes.}
    SetPort (HTerm^^.Folder);
    FlushRects (HRect, VRect);
    GetGrowRect (GRect);
    SetSBRect (HTerm^^.VSBar, VRect);
    SetSBRect (HTerm^^.HSBar, HRect);
    SetPort (SavePort);

    with HTerm^^, Setup, Style^^, Display [RightNow], MoveArray do begin                            {[JS]}
      FolderZones [VScrollBox]:=VRect;          {Enter the scroll box sizes.}
      FolderZones [HScrollBox]:=HRect;
      FolderZones [   GrowBox]:=GRect;

      Remains.Right :=FolderZones [VScrollBox].Left; {Remove from Remains.}
      Remains.Bottom:=FolderZones [HScrollBox].Top;

      if SeeLights then begin                   {Reserve the status light box.}
        H:=HMargin + HorzSp * (Length (StatName)+1) * 4 + HMargin;
        V:=VMargin + VertSp                             + VMargin;

        FolderZones [StatBox]:=Remains;         {Enter and remove status light box.}
        Remains.Top:=CMin (Remains.Top + V, Remains.Bottom);
        FolderZones [StatBox].Bottom:=Remains.Top;

        DivLights:=(RectHeight (FolderZones [StatBox]) >= V);
        VisLights:=(RectWidth  (FolderZones [StatBox]) >= H) and DivLights;

      end else begin                            {No status light box.}
        FolderZones [StatBox]:=ZeroRect;
        VisLights:=False;
        DivLights:=False;
      end;

      NrCols:=((-HMargin) + RectWidth (Remains) + (-HMargin)) div HorzSp;
      MaxNrCols:=MaxCol-FirstCol+1;             {How wide is the text area?}
      if NrCols>MaxNrCols then begin
        NrCols:=MaxNrCols;
        TextWidth:=HMargin + HorzSp*NrCols + HMargin;
      end else
        TextWidth:=RectWidth (Remains);

      FolderZones [VGreyBox]:=Remains;          {Enter and remove the vertical grey vox.}
      Remains.Right:=Remains.Left + TextWidth;
      FolderZones [VGreyBox].Left:=Remains.Right;

      VisTabs    := FALSE;                                                              {BEGIN Rulers [JS]}
      VisColumns := FALSE;
      VisWrap    := FALSE;
      IF SeeTabs OR SeeColumns THEN
          BEGIN
          blTicMk := 1;                                                     {Top of tick marks}
          blPos   := blTicMk;                                               {Top of pos mark}
          blRuler := blPos + BigV + 1;                                      {Base line of numbers}
          blTStop := blRuler + VRulerSpace;                                 {Top of col & tab marks}
          blWrap  := blTStop + CMax(RectHeight(TabMark.bounds),RectHeight(ColumnMark.bounds))
                             + VRulerSpace;
                                                             {Top of wrap marker}
          V := blWrap +
               RectHeight(WrapMark.bounds) + VRulerSpace +                  {Wrap marker}
               VMargin * 2 + BtnBHeight * 2 + sysAscent + sysDescent +      {Button height}
               VMargin;                                                     {White space}
          FolderZones[BRulerBox] := Remains;            {Enter and remove the ruler box.}
          Remains.Bottom := CMax(Remains.Bottom - V, Remains.Top);

          WITH FolderZones[BRulerBox] DO
              BEGIN
              Top := Remains.Bottom;
              blTicMk := Top + blTicMk;
              blPos   := Top + blPos;
              blTStop := Top + blTStop;
              blRuler := Top + blRuler;
              blWrap  := Top + blWrap;
              END;

          IF RectHeight(FolderZones[BRulerBox]) >= V THEN
              BEGIN
              VisTabs := SeeTabs;
              VisColumns := SeeColumns;

              IF WordWrap THEN
                  BEGIN
                  VisWrap := TRUE;
                  VisWrapPoint := WrapPoint;
                  END;
              END;
          END;

      FolderZones[GoAway] := ZeroRect;                                {Asume no button will fit}
      FolderZones[SetTabOrColumn] := ZeroRect;
      FolderZones[ClrTabOrColumn] := ZeroRect;

      DivTabs := VisTabs;
      DivColumn := VisColumns;

      IF NOT (VisTabs OR VisColumns) THEN
          FolderZones[BRulerBox] := ZeroRect
      ELSE
          BEGIN
          WITH FolderZones[RulerBox] DO
              BEGIN
              FolderZones[RulerBox] := FolderZones[BRulerBox];
              Left  := FolderZones[BRulerBox].Left + HMargin;
              Right := Left + HorzSp * NrCols;
              END;
          ComputeButtons(FolderZones[RulerBox]);
          END;
                                                                    {END Rulers [JS]}

      NrRows:=((-VMargin) + RectHeight (Remains) + (-VMargin)) div VertSp;
      MaxNrRows:=StartScreen+MaxRow-MinRow-FirstRow+1; {How high is the text area?}
      if NrRows>MaxNrRows then begin
        NrRows:=MaxNrRows;
        TextHeight:=VMargin + VertSp*NrRows + VMargin;
      end else
        TextHeight:=RectHeight (Remains);

      FolderZones [HGreyBox]:=Remains;          {Enter and remove the horizontal grey box.}
      Remains.Bottom:=Remains.Top + TextHeight;
      FolderZones [HGreyBox].Top:=Remains.Bottom;

      FolderZones [BTextBox]:=Remains;          {Give the rest to the text box.}
      FolderZones [TextBox].Left  :=Remains.Left + HMargin;
      FolderZones [TextBox].Top   :=Remains.Top  + VMargin;
      FolderZones [TextBox].Right :=FolderZones [TextBox].Left + HorzSp*NrCols;
      FolderZones [TextBox].Bottom:=FolderZones [TextBox].Top  + VertSp*NrRows;

      LoLimit:=MinCol;                          {Find the thumbs.}
      HiLimit:=MaxCol - NrCols + 1;
      if HiLimit=LoLimit then HThumbPos:= 0 else
        HThumbPos:=((Ord4(FirstCol-LoLimit))*1000) div (HiLimit-LoLimit);

      LoLimit:=MinRow;
      HiLimit:=(StartScreen+MaxRow-MinRow) - NrRows + 1;
      if HiLimit=LoLimit then VThumbPos:= 0 else
        VThumbPos:=((Ord4(FirstRow-LoLimit))*1000) div (HiLimit-LoLimit);

      {$IFC ZoneDebug}                                                          {BEGIN debug [JS]}
      IF ZoneDebug THEN
          BEGIN
          PrintRect('TextBox',        FolderZones[TextBox       ]);
          PrintRect('RulerBox',       FolderZones[RulerBox      ]);
          PrintRect('VScrollBox',     FolderZones[VScrollBox    ]);
          PrintRect('HScrollBox',     FolderZones[HScrollBox    ]);
          PrintRect('GrowBox',        FolderZones[GrowBox       ]);
          PrintRect('VGreyBox',       FolderZones[VGreyBox      ]);
          PrintRect('HGreyBox',       FolderZones[HGreyBox      ]);
          PrintRect('StatBox',        FolderZones[StatBox       ]);
          PrintRect('BTextBox',       FolderZones[BTextBox      ]);
          PrintRect('BRulerBox',      FolderZones[BRulerBox     ]);
          PrintRect('GoAway',         FolderZones[GoAway        ]);
          PrintRect('SetTabOrColumn', FolderZones[SetTabOrColumn]);
          PrintRect('ClrTabOrColumn', FolderZones[ClrTabOrColumn]);
          PrintRect('Divide',         FolderZones[Divide        ]);
          PrintRect('Elsewhere',      FolderZones[Elsewhere     ]);
          END;
      {$ENDC}                                                                   {END debug [JS]}
    end;

  end; {SizeTerm}



PROCEDURE MakeVisible (HTerm: THTerm);                                          {BEGIN MakeVisible [JS]}
  {MakeVisible makes HTerm's cursor visible.  The visible area is moved only}
  {if the cursor is currently invisible.}

VAR
    LastRow:    INTEGER;
    resize:     BOOLEAN;

{$S SegTE}
BEGIN {MakeVisible}
    {$IFC SampCalls}   ALogCall;   {$ENDC}

    {$IFC FindDecr }
        PrintRgns (HTerm, 'MakeVisible 1');
    {$ENDC }

    {$IFC DbgSizeTerm}                                                                          {[JS]}
    IF DbgSizeTerm THEN                                                                         {[JS]}
        SizeTerm (HTerm);
    {$ENDC}                                                                                     {[JS]}

    {$IFC FindDecr }
        PrintRgns (HTerm, 'MakeVisible 2');
    {$ENDC }

    resize := FALSE;                                                    {No need to run SizeTerm yet}
    WITH HTerm^^, Cursor, Setup, Display [RightNow], MoveArray DO
        BEGIN
        LastRow := StartScreen + MaxRow - MinRow;                       {Last RowNr of document.}
        IF (Ln < FirstRow) OR (Ln > FirstRow+NrRows-1) THEN             {Not in good row.}
            BEGIN
            IF Ln <= NrRows THEN                                        {Try top of document.}
                FirstRow := 1
            ELSE
                IF Ln >= LastRow - NrRows + 1 THEN                      {Try bottom of document.}
                    FirstRow := LastRow - NrRows + 1
                ELSE                                                    {Center in middle of doc.}
                    FirstRow := Ln - NrRows DIV 2;

            resize := TRUE;                                             {Run SizeTerm after this}
            END;

        IF (Ch < FirstCol) OR (Ch > FirstCol+NrCols-1) THEN             {Not in good col.}
            BEGIN
            IF Ch <= NrCols THEN                                        {Try left side.}
                FirstCol := 1
            ELSE
                IF Ch >= MaxCol - NrCols + 1 THEN                       {Try right side.}
                    FirstCol := MaxCol - NrCols  + 1
                ELSE                                                    {Center in middle.}
                    FirstCol := Ch - NrCols DIV 2;
            resize := TRUE;                                             {Run SizeTerm after this}
            END;
        END;

    {$IFC FindDecr }
      PrintRgns (HTerm, 'MakeVisible 3');
    {$ENDC }

    IF resize THEN
        SizeTerm (HTerm);

    {$IFC FindDecr }
      PrintRgns (HTerm, 'MakeVisible 4');
    {$ENDC }
END; {MakeVisible}                                                              {END MakeVisible [JS]}




procedure PaintTerm (HTerm: THTerm);
  {PaintTerm paints HTerm entirely.  This is done by making the currently}
  {painted state look empty.}

  var
    Zone: TZone;

  {$S SegTECold}
  begin {PaintTerm}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Display [AtPaint], MoveArray, Folder^ do begin                                    {[JS]}
      for Zone:=TextBox to Pred (Elsewhere) do
        FolderZone [Zone]:=ZeroRect;

      VisLights:=False;
      VisTabs:=False;
      NrRows:=0;
      NrCols:=0;
    end;
    ChangeBlink (HTerm^^.CursorRect, ZeroRect);
    ChangeBlink (HTerm^^.CaretRect , ZeroRect);
    ChangeBlink (HTerm^^.BlinkRgn  , ZeroRect);
    ChangeBlink (HTerm^^.InvertRgn , ZeroRect);

    UpdateTerm (HTerm);
    if HTerm=TheTerm then
      PaintSBs (HTerm);

    HTerm^^.Repaint:=False;
  end; {PaintTerm}



procedure UpdateAll;
  {UpdateAll updates all the screens of the terminals on TermList by}
  {scanning that list and calling UpdateTerm for each Changed terminal.}

  var
    HTerm: THTerm;

  {$S SegTECold}
  begin {UpdateAll}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    HTerm:=TermList;
    while HTerm<>NIL do begin
      if HTerm^^.Changed then begin
        MakeVisible (HTerm);

        if HTerm^^.Repaint then
          PaintTerm (HTerm)
        else
          UpdateTerm (HTerm);
      end;

      HTerm:=HTerm^^.Next;
    end;
    Changed:=False;
  end; {UpdateAll}



procedure PaintEmpty (HTerm: THTerm);
  {PaintEmpty paints the message inside HTerm indicating that HTerm will}
  {not be displayed until it is activated.}

  var
    SavePort: GrafPtr;
    TempRect: Rect;

  {$S SegTECold}
  begin {PaintEmpty}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    GetPort (SavePort);
    SetPort (HTerm^^.Folder);

    TempRect:=HTerm^^.Folder^.PortRect;
    ClipRect (TempRect);
    EraseRect (TempRect);

    UnpaintSBs (HTerm);

    with TempRect do begin
      Top   :=Top    + VMargin;
      Left  :=Left   + HMargin;

      Bottom:=Bottom - dvSBox;
      Right :=Right  - dhSBox;
    end;
    ClipRect (TempRect);

    DrawAlert (MyAlerts, ALActivateMe, TempRect);

    ClipRect (HTerm^^.Folder^.PortRect);

    SetPort (SavePort);
  end;  {PaintEmpty}

