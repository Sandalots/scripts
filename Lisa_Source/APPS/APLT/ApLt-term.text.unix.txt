{ Copyright 1983, Apple Computer, Inc. }
{$S SegTE}
procedure Scroll (HTerm: THTerm);
  {Scroll scrolls HTerm's screen up one line, caching the trashed line.  The}
  {line scrolled in is a blank line.}

  var
    HTrashed: THLine;
    RowNr: Integer;
    TheCache: THCache;
    CacheIt: Boolean;

  {$S SegTECold}
  begin {Scroll}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Display [RightNow], MoveArray do begin                                        {[JS]}
      HTrashed:=Screen [MinRow+TMargin];        {Scroll it.}
      for RowNr:=MinRow+TMargin+1 to MinRow+BMargin do
        Screen [RowNr-1]:=Screen [RowNr];

      if Setup.Runoff and (TMargin=0) then begin {Save trashed line in LOT.}
        StartScreen:=StartScreen+1;
        CacheIt:=True;

      end else begin                            {Throw away trashed line.}
        with Select.Left do                     {Scroll the selection.}
          if (Ln>=StartScreen+TMargin) and
             (Ln<=StartScreen+BMargin) then
            Ln:=Ln-1;

        with Select.Right do
          if (Ln>=StartScreen+TMargin) and
             (Ln<=StartScreen+BMargin) then
            Ln:=Ln-1;

        CacheIt:=False;
      end;
    end;

    if CacheIt then begin                       {Put the trashed line in the LOT.}
      TheCache:=HTerm^^.HCache;
      PutRow (TheCache, HTrashed);

      with HTerm^^ do begin
        HCache:=TheCache;

        if HCache^^.LinesInCache=LTBigCache then begin
          BigTerm:=True;
          CacheTooBig:=True;
        end;
        if HCache^^.LinesInCache=VeryBigCache then begin
          BigTerm:=True;
          CacheMuchTooBig:=True;
        end;

      end;
    end;

    HTrashed^^:=BlankLine;                      {Roll it around to the bottom.}
    HTrashed^^.SeqNr:=NextSeqNr;
    NextSeqNr:=NextSeqNr+1;
    with HTerm^^, Display [RightNow], MoveArray do                                              {[JS]}
      Screen [MinRow+BMargin]:=HTrashed;
  end; {Scroll}


procedure NextRow (HTerm: THTerm);
  {NextRow moves the cursor to the next row.}

  var
    ScrollIt: Boolean;

  {$S SegTECold}
  begin {NextRow}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    ScrollIt:=False;

    with HTerm^^, Cursor, Display [RightNow], MoveArray do begin                                {[JS]}
      Ln:=Ln+1;
      if Ln>StartScreen+BMargin then begin
        ScrollIt:=True;
        if (not Setup.Runoff) or (TMargin<>0) then
          Ln:=Ln-1;
      end;
    end;

    if ScrollIt then
      Scroll (HTerm);
  end; {NextRow}


procedure NextCol (HTerm: THTerm);
  {NextCol moves the cursor to the next column of HTerm.  If the cursor is}
  {beyond the right margin then the appropriate things are done for HTerm.}
  {If the cursor is now out of the scrolling region, the terminal is scrolled.}

  var
    LastCol: Integer;

  {$S SegTE}
  begin {NextCol}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Setup, Display [RightNow], MoveArray do begin                         {[JS]}
      if Cols80 then
        LastCol:=80
      else
        LastCol:=132;

      if Screen [Ln-StartScreen+MinCol]^^.TwoWide then
        LastCol:=LastCol div 2;

      if Ch>=LastCol then begin
        Ch:=LastCol;
        NextNewLine:=Wraparound;

      end else begin
        Ch:=Ch+1;
        if (Ch=LastCol-8) and MarginBell then
          if IsActive then
            BeepAlert (1);
      end;
    end;
  end; {NextCol}


procedure DECALN (HTerm: THTerm);
  var
    RowNr: Integer;
    ColNr: Integer;

  {$S SegTECold}
  begin {DECALN}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Display [RightNow], MoveArray do begin                                        {[JS]}
      for RowNr:=MinRow to MaxRow do
        with Screen [RowNr]^^ do begin
          for ColNr:=MinCol to MaxCol do begin
            TextLine [ColNr]:=BlankChar;
            TextLine [ColNr].Ch:='E';
          end;

          Changed:=True;
          Repaint:=True;
        end;

      DidChange:=True;
      ShouldUpd:=True;
    end;
  end;  {DECALN}


procedure SetDouble (HTerm: THTerm);
  {SetDouble sets the current line to double width, masking the trailing}
  {characters and making the cursor visible.}

  var
    ColNr: Integer;
    LastCol: Integer;

  {$S SegTECold}
  begin {SetDouble}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, Screen [Ln-StartScreen+MinCol]^^ do begin   {[JS]}
      TwoWide:=True;

      if Setup.Cols80 then
        LastCol:=40
      else
        LastCol:=66;

      for ColNr:=LastCol+1 to MaxCol do
        TextLine [ColNr]:=BlankChar;
    end;
  end; {SetDouble}


procedure DECDHLTop (HTerm: THTerm);

  {$S SegTECold}
  begin {DECDHLTop}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, Screen [Ln-StartScreen+MinCol]^^ do begin   {[JS]}
      TwoHigh:=True;
      TwoTop:=True;
      SetDouble (HTerm);

      Changed:=True;
      Repaint:=True;
      DidChange:=True;
    end;
  end;  {DECDHLTop}


procedure DECDHLBottom (HTerm: THTerm);

  {$S SegTECold}
  begin {DECDHLBottom}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, Screen [Ln-StartScreen+MinCol]^^ do begin  {[JS]}
      TwoHigh:=True;
      TwoTop:=False;
      SetDouble (HTerm);

      Changed:=True;
      Repaint:=True;
      DidChange:=True;
    end;
  end;  {DECDHLBottom}


procedure DECDWL (HTerm: THTerm);

   {$S SegTECold}
  begin {DECDWL}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, Screen [Ln-StartScreen+MinCol]^^ do begin {[JS]}
      TwoHigh:=False;
      TwoTop:=False;
      SetDouble (HTerm);

      Changed:=True;
      Repaint:=True;
      DidChange:=True;
    end;
  end;  {DECDWL}


procedure DECSWL (HTerm: THTerm);

  {$S SegTECold}
  begin {DECSWL}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, Screen [Ln-StartScreen+MinCol]^^ do begin {[JS]}
      TwoHigh:=False;
      TwoTop:=False;
      TwoWide:=False;

      Changed:=True;
      Repaint:=True;
      DidChange:=True;
    end;
  end;  {DECSWL}


procedure CUB (HTerm: THTerm);

  {$S SegTECold}
  begin {CUB}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, ParmList.Parm [ParmNr] do begin        {[JS]}
      NextNewLine:=False;

      if Value<1 then
        Value:=1;

      if Ch>MinCol then begin
        Ch:=CMax (Ch-Value, MinCol);
        DidChange:=True;
      end;
    end;
  end;  {CUB}


procedure CUD (HTerm: THTerm);
  var
    EndScreen: LongInt;

  {$S SegTECold}
  begin {CUD}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, ParmList.Parm [ParmNr] do begin        {[JS]}
      if Value<1 then
        Value:=1;

      EndScreen:=StartScreen+BOrigin;
      if Ln<EndScreen then begin
        Ln:=Ln+Value;
        if Ln>EndScreen then
          Ln:=EndScreen;
        DidChange:=True;
      end;
    end;
  end;  {CUD}


procedure CUF (HTerm: THTerm);
  var
    LastCol: Integer;

  {$S SegTECold}
  begin {CUF}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Setup, Display [RightNow], MoveArray, ParmList.Parm [ParmNr] do begin    {[JS]}
      NextNewLine:=False;

      if Value<1 then
        Value:=1;

      if Cols80 then
        LastCol:=80
      else
        LastCol:=132;

      if Screen [Ln-StartScreen+MinCol]^^.TwoWide then
        LastCol:=LastCol div 2;

      if Ch<LastCol then begin
        Ch:=CMin (Ch+Value, LastCol);
        DidChange:=True;
      end;
    end;
  end;  {CUF}


procedure CUP (HTerm: THTerm);
  var
    LastCol: Integer;

  {$S SegTECold}
  begin {CUP}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Setup, Display [RightNow], MoveArray, ParmList do begin               {[JS]}
      NextNewLine:=False;

      with Parm [1] do begin
        if Value<1 then
          Value:=1;

        Ln:=Value - 1 + StartScreen + TOrigin;
        if Ln>StartScreen+BOrigin then
          Ln:=StartScreen+BOrigin;
      end;

      if Cols80 then
        LastCol:=80
      else
        LastCol:=132;

      if Screen [Ln-StartScreen+MinCol]^^.TwoWide then
        LastCol:=LastCol div 2;

      Ch:=Parm [2].Value - 1 + MinCol;
      if Ch<MinCol then
        Ch:=MinCol

      else if Ch>LastCol then
        Ch:=LastCol;
    end;

    DidChange:=True;
  end;  {CUP}


procedure CUU (HTerm: THTerm);
  {$S SegTECold}
  begin {CUU}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, ParmList.Parm [ParmNr] do begin        {[JS]}
      if Value<1 then
        Value:=1;

      if Ln>StartScreen+TOrigin then begin
        Ln:=Ln-Value;
        if Ln<StartScreen+TOrigin then
          Ln:=StartScreen+TOrigin;
        DidChange:=True;
      end;
    end;
  end;  {CUU}


procedure DA (HTerm: THTerm);
  {$S SegTECold}
  begin {DA}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do begin
      ReplySeq [1]:=ESC;
      ReplySeq [2]:='[';
      ReplySeq [3]:='?';
      ReplySeq [4]:='1';
      ReplySeq [5]:=';';
      ReplySeq [6]:='7';
      ReplySeq [7]:='c';
      ReplyLen:=7;
    end;
  end;  {DA}


procedure DECLL (HTerm: THTerm);
  {$S SegTECold}
  begin {DECLL}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Display [RightNow], MoveArray, ParmList.Parm [ParmNr] do begin                {[JS]}
      if Value=0 then begin
        Lights [1]:=False;
        Lights [2]:=False;
        Lights [3]:=False;
        Lights [4]:=False;

      end else
        if Value<=4 then
          Lights [Value]:=True;

      DidChange:=VisLights;
      ShouldUpd:=VisLights;
    end;
  end;  {DECLL}


procedure DECREQTPARM (HTerm: THTerm);
  {$S SegTECold}
  begin {DECREQTPARM}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, ParmList.Parm [ParmNr] do begin
      if Value<=1 then begin
        ReportParms (HTerm, '3');
        TellSetup:= (Value<>1);
      end;
    end;
  end;  {DECREQTPARM}


procedure DECSTBM (HTerm: THTerm);
  {$S SegTECold}
  begin {DECSTBM}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Display [RightNow], MoveArray, ParmList do                                    {[JS]}
      if (Parm [1].Value<Parm [2].Value) and (Parm [2].Value<=MaxRow) then begin
        with Parm [1] do
          if Value<1 then
            TMargin:=0
          else
            TMargin:=Value-1;

        with Parm [2] do
          if Default then
            BMargin:=MaxRow-MinRow
          else
            BMargin:=Value-1;

        if TBOrigin then begin
          TOrigin:=TMargin;
          BOrigin:=BMargin;
        end;

        Cursor.Ln:=StartScreen+TOrigin;
        Cursor.Ch:=MinCol;
        DidChange:=True;
      end;
  end;  {DECSTBM}


procedure DECTST (HTerm: THTerm);
  {$S SegTECold}
  begin {DECTST}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    {Ignore self-test.}
  end;  {DECTST}


procedure DSR (HTerm: THTerm);
  var
    RowNr: Integer;
    ColNr: Integer;

  {$S SegTECold}
  begin {DSR}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, ParmList.Parm [ParmNr], Display [RightNow], MoveArray do begin        {[JS]}
      if Value=5 then begin                    {Respond with 'No Fail'.}
        ReplySeq [1]:=ESC;
        ReplySeq [2]:='[';
        ReplySeq [3]:='0';
        ReplySeq [4]:='n';
        ReplyLen:=4;

      end else if Value=6 then begin           {Respond with cursor position.}
        ReplySeq [1]:=ESC;
        ReplySeq [2]:='[';

        RowNr:=Ln - (StartScreen + TOrigin) + 1;
        ReplySeq [3]:=Chr (RowNr div 10 + Ord ('0'));
        ReplySeq [4]:=Chr (RowNr mod 10 + Ord ('0'));
        ReplySeq [5]:=';';

        ColNr:=Ch;
        ReplySeq [8]:=Chr (ColNr mod 10 + Ord ('0'));  ColNr:=ColNr div 10;
        ReplySeq [7]:=Chr (ColNr mod 10 + Ord ('0'));  ColNr:=ColNr div 10;
        ReplySeq [6]:=Chr (ColNr mod 10 + Ord ('0'));
        ReplySeq [9]:='R';
        ReplyLen:=9;
      end;
    end;
  end;  {DSR}


procedure ED (HTerm: THTerm);
  var
    EraseFrom: TPosition;
    EraseTo  : TPosition;
    RowNr: Integer;
    ColNr: Integer;
    TheSeqNr: LongInt;

  {$S SegTECold}
  begin {ED}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, ParmList.Parm [ParmNr] do begin        {[JS]}
      if Value<=2 then begin
        EraseFrom.Ln:=StartScreen;
        EraseFrom.Ch:=MinCol;

        EraseTo.Ln:=StartScreen+MaxRow-MinRow;
        EraseTo.Ch:=MaxCol;

        case Value of
          0: EraseFrom:=Cursor;
          1: EraseTo  :=Cursor;
          2: ;
        end;

        EraseFrom.Ln:=EraseFrom.Ln - StartScreen + MinRow;
        EraseTo  .Ln:=EraseTo  .Ln - StartScreen + MinRow;

        if EraseFrom.Ch>MinCol then begin
          with Screen [EraseFrom.Ln]^^ do begin
            for ColNr:=EraseFrom.Ch to MaxCol do
              TextLine [ColNr]:=BlankChar;

            Changed:=True;
            Repaint:=True;
          end;

          EraseFrom.Ln:=EraseFrom.Ln+1;
        end;

        if EraseTo.Ch<MaxCol then begin
          with Screen [EraseTo.Ln]^^ do begin
            for ColNr:=MinCol to EraseTo.Ch do
              TextLine [ColNr]:=BlankChar;

            Changed:=True;
            Repaint:=True;
          end;

          EraseTo.Ln:=EraseTo.Ln-1;
        end;

        for RowNr:=EraseFrom.Ln to EraseTo.Ln do begin
          TheSeqNr:=Screen [RowNr]^^.SeqNr;
          Screen [RowNr]^^:=BlankLine;

          with Screen [RowNr]^^ do begin
            SeqNr:=TheSeqNr;
            Changed:=True;
            Repaint:=True;
          end;
        end;
      end;

      DidChange:=True;
      ShouldUpd:=True;
    end;
  end;  {ED}


procedure EL (HTerm: THTerm);
  var
    ColFrom: Integer;
    ColTo  : Integer;
    ColNr  : Integer;

  {$S SegTECold}
  begin {EL}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, ParmList.Parm [ParmNr] do begin        {[JS]}
      if Value<=2 then begin
        ColFrom:=MinCol;
        ColTo  :=MaxCol;

        case Value of
          0: ColFrom:=Ch;
          1: ColTo  :=Ch;
          2: ;
        end;

        with Screen [Cursor.Ln-StartScreen+MinCol]^^ do begin
          for ColNr:=ColFrom to ColTo do
            TextLine [ColNr]:=BlankChar;

          Changed:=True;
          Repaint:=True;
        end;
      end;

      DidChange:=True;
    end;
  end;  {EL}


procedure RM (HTerm: THTerm);
  var
    SavePort: GrafPtr;

  {$S SegTECold}
  begin {RM}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Setup, ParmList, Parm [ParmNr], Display [RightNow], MoveArray do begin        {[JS]}
      if Special then
        case Value of
          1: CursorKey:=False;
          2: Terminal:=DBvt52;

          3: begin
            Cols80:=True;
            Style:=M80Style;

            GetPort (SavePort);
            SetPort (Folder);
            TextFont (Style^^.Font.Fam);
            SetPort (SavePort);

            ParmList.Parm [1].Default:=True;
            ParmList.Parm [1].Value:=0;
            ParmList.Parm [2].Default:=True;
            ParmList.Parm [2].Value:=0;
            CUP (HTerm);

            ParmList.Parm [1].Default:=False;
            ParmList.Parm [1].Value:=2;
            ParmNr:=1;
            ED (HTerm);

            SizeTerm(HTerm);

            Repaint:=True;
          end;

          4: {Scrolling ... ignored.};

          5: if WhiteScreen then begin
            WhiteScreen:=False;
            DidChange:=True;
            Repaint:=True;
          end;

          6: begin
            TOrigin:=0;
            BOrigin:=MaxRow-MinRow;

            TBOrigin:=False;

            ParmList.Parm [1].Default:=True;
            ParmList.Parm [1].Value:=0;
            ParmList.Parm [2].Default:=True;
            ParmList.Parm [2].Value:=0;
            CUP (HTerm);
          end;

          7: Wraparound:=False;
          8: AutoRepeat:=False;
          9: {Interlace ... ignored.};
        end

      else
        if Value=20 then
          AutoLF:=False;
    end;
  end;  {RM}


procedure SGR (HTerm: THTerm);
  {$S SegTECold}
  begin {SGR}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, ParmList.Parm [ParmNr] do begin
      case Value of
        0: BaseChar:=BlankChar;
        1: BaseChar.Bold      :=True;
        4: BaseChar.Underscore:=True;
        5: BaseChar.Blink     :=True;
        7: BaseChar.Negative  :=True;
      end;
    end;
  end;  {SGR}


procedure TBC (HTerm: THTerm);
  var
    ColNr: Integer;

  {$S SegTECold}
  begin {TBC}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray, ParmList.Parm [ParmNr] do begin        {[JS]}
      if Value=0 then
        TabStops [Ch]:=False

      else if Value=3 then
        for ColNr:=MinCol to MaxCol do
          TabStops [ColNr]:=False;

      DidChange:=True;
    end;
  end;  {TBC}


procedure SM (HTerm: THTerm);
  var
    SavePort: GrafPtr;

  {$S SegTECold}
  begin {SM}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Setup, ParmList, Parm [ParmNr] do begin
      if Special then
        case Value of
          1: CursorKey:=True;
          2: Terminal:=DBvt100;

          3: begin
            Cols80:=False;
            Style:=M132Style;

            GetPort (SavePort);
            SetPort (Folder);
            TextFont (Style^^.Font.Fam);
            SetPort (SavePort);

            ParmList.Parm [1].Default:=True;
            ParmList.Parm [1].Value:=0;
            ParmList.Parm [2].Default:=True;
            ParmList.Parm [2].Value:=0;
            CUP (HTerm);

            ParmList.Parm [1].Default:=False;
            ParmList.Parm [1].Value:=2;
            ParmNr:=1;
            ED (HTerm);

            SizeTerm(HTerm);

            Repaint:=True;
          end;

          4: {Scrolling ... ignored.};

          5: if not WhiteScreen then begin
            WhiteScreen:=True;
            DidChange:=True;
            Repaint:=True;
          end;

          6: begin
            TOrigin:=TMargin;
            BOrigin:=BMargin;

            TBOrigin:=True;

            ParmList.Parm [1].Default:=True;
            ParmList.Parm [1].Value:=0;
            ParmList.Parm [2].Default:=True;
            ParmList.Parm [2].Value:=0;
            CUP (HTerm);
          end;

          7: Wraparound:=True;
          8: AutoRepeat:=True;
          9: {Interlace ... ignored.};
        end

      else
        if Value=20 then
          AutoLF:=True;
    end;
  end;  {SM}


procedure DECID (HTerm: THTerm);
  {$S SegTECold}
  begin {DECID}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do begin
      ReplySeq [1]:=ESC;
      ReplySeq [2]:='[';
      ReplySeq [3]:='?';
      ReplySeq [4]:='1';
      ReplySeq [5]:=';';
      ReplySeq [6]:='7';
      ReplySeq [7]:='c';
      ReplyLen:=7;
    end;
  end;  {DECID}


procedure DECKPAM (HTerm: THTerm);
  {$S SegTECold}
  begin {DECKPAM}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Setup do begin
      KeyPad:=True;
    end;
  end;  {DECKPAM}


procedure DECKPNM (HTerm: THTerm);
  {$S SegTECold}
  begin {DECKPNM}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Setup do begin
      KeyPad:=False;
    end;
  end;  {DECKPNM}


procedure DECRC (HTerm: THTerm);
  {$S SegTECold}
  begin {DECRC}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do begin
      Cursor:=CursorSave;
      Cursor.Ln:=Cursor.Ln+Display [RightNow].MoveArray.StartScreen;                            {[JS]}

      BaseChar:=BaseSave;
      Style:=StyleSave;
      DidChange:=True;
      NextNewLine:=False;
    end;
  end;  {DECRC}


procedure DECSC (HTerm: THTerm);
  {$S SegTECold}
  begin {DECSC}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do begin
      CursorSave:=Cursor;
      CursorSave.Ln:=CursorSave.Ln-Display [RightNow].MoveArray.StartScreen;                    {[JS]}

      BaseSave:=BaseChar;
      StyleSave:=Style;
    end;
  end;  {DECSC}


procedure HTS (HTerm: THTerm);
  {$S SegTECold}
  begin {HTS}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray do begin                                {[JS]}
      TabStops [Ch]:=True;
      DidChange:=VisTabs;
    end;
  end;  {HTS}


procedure IND (HTerm: THTerm);
  {$S SegTECold}
  begin {IND}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    NextRow (HTerm);
    DidChange:=True;
    ShouldUpd:=True;
  end;  {IND}


procedure NEL (HTerm: THTerm);
  {$S SegTECold}
  begin {NEL}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    HTerm^^.NextNewLine:=False;

    NextRow (HTerm);
    HTerm^^.Cursor.Ch:=MinCol;
    DidChange:=True;
    ShouldUpd:=True;
  end;  {NEL}


procedure RI (HTerm: THTerm);
  var
    HTrashed: THLine;
    RowNr: Integer;

  {$S SegTECold}
  begin {RI}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Display [RightNow], MoveArray, Cursor do                                      {[JS]}
      if Ln=StartScreen+TMargin then begin
        HTrashed:=Screen [MinRow+BMargin];
        for RowNr:=MinRow+BMargin-1 downto MinRow+TMargin do
          Screen [RowNr+1]:=Screen [RowNr];

        with Select.Left do
          if (Ln>=StartScreen+TMargin) and
             (Ln<=StartScreen+BMargin) then
            Ln:=Ln+1;

        with Select.Right do
          if (Ln>=StartScreen+TMargin) and
             (Ln<=StartScreen+BMargin) then
            Ln:=Ln+1;

        HTrashed^^:=BlankLine;
        HTrashed^^.SeqNr:=NextSeqNr;
        NextSeqNr:=NextSeqNr+1;
        with HTerm^^, Display [RightNow] do
          Screen [MinRow+TMargin]:=HTrashed;

      end else
        Ln:=Ln-1;

    DidChange:=True;
    ShouldUpd:=True;
  end;  {RI}


procedure TPNum (TheCh: Char; HTerm: THTerm);
  {TPNum processes <ESC># ... sequences.}

  {$S SegTECold}
  begin {TPNum}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    case TheCh of
      '8': DECALN (HTerm);
      '3': DECDHLTop (HTerm);
      '4': DECDHLBottom (HTerm);
      '6': DECDWL (HTerm);
      '5': DECSWL (HTerm);
    end;
  end; {TPNum}


procedure TPExtG0 (TheCh: Char; HTerm: THTerm);
  {TPExtG0 processes ESC ( !  ... sequences.}

  {$S SegTECold}
  begin {TPExtG0}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do
      case TheCh of
        '4','6': CharSet[GroupG0]:= Italian;
        '0': CharSet[GroupG0]:= Yugoslavian;
        '?': CharSet [GroupG0]:=IntCharGroup; {revert to default}
          end;     {case}
      end; {TPExtG0}


procedure TPExtG1 (TheCh: Char; HTerm: THTerm);
  {TPExtG1 processes ESC ) !  ... sequences.}

  {$S SegTECold}
  begin {TPExtG1}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do
      case TheCh of
        '4','6':CharSet[GroupG1]:= Italian;
        '0': CharSet[GroupG1]:= Yugoslavian;
        '?': CharSet[GroupG1]:=IntCharGroup;
          end;  {case}
      end; {TPExtG1}


procedure TPSetG0 (TheCh: Char; HTerm: THTerm);
  {TPSetG0 processes <ESC>( ... sequences.}
  (*** Define character sets ***)

  {$S SegTE}
  begin {TPSetG0}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do
      case TheCh of
        'A': CharSet [GroupG0]:=UKCharSet;
        'B': CharSet [GroupG0]:=ASCIICharSet;
        '0': CharSet [GroupG0]:=GraphCharSet;
        '1': CharSet [GroupG0]:=ASCIICharSet;
        '2': CharSet [GroupG0]:=GraphCharSet;
        'H': CharSet [GroupG0]:=E47SwedishFinnish;
        '7': CharSet [GroupG0]:=E47SwedishFinnish;
        'C': CharSet [GroupG0]:=D47SwedishFinnish;
        '5': CharSet [GroupG0]:=D47SwedishFinnish;
        '6': CharSet [GroupG0]:=Norwegian;
        'E': CharSet [GroupG0]:=Danish;
        'K': CharSet [GroupG0]:=German;
        'R': CharSet [GroupG0]:=French;
        'Q': CharSet [GroupG0]:=FrenchCanadian;
        '9': CharSet [GroupG0]:=FrenchCanadian;
        'Z': CharSet [GroupG0]:=Spanish;
        '!': TermProc:=@TPExtG0;
      end;
  end; {TPSetG0}



procedure TPSetG1 (TheCh: Char; HTerm: THTerm);
  {TPSetG1 processes <ESC>) ... sequences.}
  (*** Define character sets ***)

  {$S SegTE}
  begin {TPSetG1}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do
      case TheCh of
        'A': CharSet [GroupG1]:=UKCharSet;
        'B': CharSet [GroupG1]:=ASCIICharSet;
        '0': CharSet [GroupG1]:=GraphCharSet;
        '1': CharSet [GroupG1]:=ASCIICharSet;
        '2': CharSet [GroupG1]:=GraphCharSet;
        'H': CharSet [GroupG1]:=E47SwedishFinnish;
        '7': CharSet [GroupG1]:=E47SwedishFinnish;
        'C': CharSet [GroupG1]:=D47SwedishFinnish;
        '5': CharSet [GroupG1]:=D47SwedishFinnish;
        '6': CharSet [GroupG1]:=Norwegian;
        'E': CharSet [GroupG1]:=Danish;
        'K': CharSet [GroupG1]:=German;
        'R': CharSet [GroupG1]:=French;
        'Q': CharSet [GroupG1]:=FrenchCanadian;
        '9': CharSet [GroupG1]:=FrenchCanadian;
        'Z': CharSet [GroupG1]:=Spanish;
        '!': TermProc:=@TPExtG1;
      end;
  end; {TPSetG1}



procedure TPParm (TheCh: Char; HTerm: THTerm);
  {TPParm processes parameter sequences for <ESC>[ ... sequences.}

  var
    NrParms: Integer;
    I: Integer;

  {$S SegTECold}
  begin {TPParm}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, ParmList do
      case TheCh of
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9': begin
          with Parm [ParmNr] do begin
            Value:=Value*10 + Ord (TheCh)-Ord ('0');
            Default:=False;
          end;

          TermProc:=@TPParm;
        end;

        ';': begin
          ParmNr:=ParmNr+1;
          TermProc:=@TPParm;
        end;

        '?': begin
          Special:=True;
          TermProc:=@TPParm;
        end;

        'H', 'f': CUP (HTerm);
        'r': DECSTBM (HTerm);

        otherwise begin
          NrParms:=ParmNr;
          for I:=1 to NrParms do begin
            HTerm^^.ParmNr:=I;

            case TheCh of
              'D': CUB (HTerm);
              'B': CUD (HTerm);
              'C': CUF (HTerm);
              'A': CUU (HTerm);
              'c': DA (HTerm);
              'q': DECLL (HTerm);
              'x': DECREQTPARM (HTerm);
              'y': DECTST (HTerm);
              'n': DSR (HTerm);
              'J': ED (HTerm);
              'K': EL (HTerm);
              'l': RM (HTerm);
              'm': SGR (HTerm);
              'g': TBC (HTerm);
              'h': SM (HTerm);
            end;
          end;
        end;
      end;
  end; {TPParm}


procedure TP100Seq (TheCh: Char; HTerm: THTerm);
  {TP100Seq processes <ESC> ... sequences for the VT100 mode.}

  var
    I: Integer;

  {$S SegTECold}
  begin {TP100Seq}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do
      case TheCh of
        '[': with ParmList do begin
          for I:=1 to MaxParm do
            with Parm [I] do begin
              Value:=0;
              Default:=True;
            end;

          Special:=False;
          ParmNr:=1;

          TermProc:=@TPParm;
        end;

        '(': TermProc:=@TPSetG0;
        ')': TermProc:=@TPSetG1;
        '#': TermProc:=@TPNum;

        'Z': DECID (HTerm);
        '=': DECKPAM (HTerm);
        '>': DECKPNM (HTerm);
        '8': DECRC (HTerm);
        '7': DECSC (HTerm);
        'H': HTS (HTerm);
        'D': IND (HTerm);
        'E': NEL (HTerm);
        'M': RI (HTerm);
        'c': StateFolder (HTerm);
      end;
  end; {TP100Seq}


procedure TPxParm (TheCh: Char; HTerm: THTerm);
  {TPxParm gets the X parameter for <ESC>Yy ... sequences.}

  {$S SegTECold}
  begin {TPxParm}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, ParmList.Parm [1], Display [RightNow], MoveArray do begin             {[JS]}
      NextNewLine:=False;

      Ch:=Ord (TheCh) - Ord (SP) + MinCol;
      if Ch>MaxCol then
        Ch:=MaxCol
      else if Ch<MinCol then
        Ch:=MinCol;

      DidChange:=True;
    end;
  end; {TPxParm}


procedure TPyParm (TheCh: Char; HTerm: THTerm);
  {TPyParm gets the Y parameter for <ESC>Y ... sequences.}

  {$S SegTECold}
  begin {TPyParm}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^, Cursor, Display [RightNow], MoveArray do begin                                {[JS]}
      Ln:=Ord (TheCh) - Ord (SP) + MinRow;
      if Ln>MaxRow then
        Ln:=MaxRow
      else if Ln<MinRow then
        Ln:=MinRow;
      Ln:=Ln + StartScreen - MinRow;

      DidChange:=True;
      TermProc:=@TPxParm;
    end;
  end; {TPyParm}


procedure TP52Seq (TheCh: Char; HTerm: THTerm);
  {TP52Seq processes <ESC> ... sequences for the VT52 mode.}

  {$S SegTECold}
  begin {TP52Seq}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do begin
      with ParmList do begin
        Special:=False;

        with Parm [1] do begin
          Default:=True;
          Value:=0;
        end;

        with Parm [2] do begin
          Default:=True;
          Value:=0;
        end;
      end;
      ParmNr:=1;

      case TheCh of
        'A': CUU (HTerm);
        'B': CUD (HTerm);
        'C': CUF (HTerm);
        'D': CUB (HTerm);

        'F': CharSet [CharGroup]:=GraphCharSet;
        'G': CharSet [CharGroup]:=ASCIICharSet;

        'H': CUP (HTerm);
        'I': RI (HTerm);
        'J': ED (HTerm);
        'K': EL (HTerm);

        'Y': TermProc:=@TPyParm;                        {Direct cursor address.}

        'Z': begin                                      {Identify.}
          ReplySeq [1]:=ESC;
          ReplySeq [2]:='/';
          ReplySeq [3]:='Z';
          ReplyLen:=3;
        end;

        '=': DECKPAM (HTerm);
        '>': DECKPNM (HTerm);

        '<': Setup.Terminal:=DBvt100;                   {Enter ANSI (VT100) mode.}
      end;
    end;
  end; {TP52Seq}


procedure TPBase (TheCh: Char; HTerm: THTerm);
  {TPBase processes TheCh and updates HTerm accordingly.}

  var
    RowNr: Integer;
    RightSide: Integer;
    language:   INTEGER;

  {$S SegTE}
  begin {TPBase}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    if ((TheCh>US) and (TheCh<DEL)) or (TheCh=Chr (ParityChar)) then
      with HTerm^^, Cursor do
        if NextNewLine then begin
          NextNewLine:=False;

          Ch:=MinCol;
          NextRow (HTerm);
        end;

    with HTerm^^, Cursor, Display [RightNow], MoveArray do begin                                {[JS]}
      if ((TheCh>US) and (TheCh<DEL)) or (TheCh=Chr (ParityChar)) then begin
        RowNr:=Ln-StartScreen+MinRow;           {Printable character.}

        with Screen [RowNr]^^ do begin
          TextLine [Ch]:=BaseChar;
          with TextLine [Ch] do
            if TheCh=Chr (ParityChar) then begin
              Ch:=ParityVis;
              Graphic:=True;

            end else begin
              language := ORD(CharSet[CharGroup]) - 2;
              IF language < 0 THEN      {Test for the GraphCharSet}
                language := 0;
              TheCh:= ConvertAscii(TheCh,language);
              Ch:=TheCh;
              Graphic:= (CharSet [CharGroup]=GraphCharSet) and
                        (TheCh in ['_'..'~']);
            end;

          Changed:=True;
        end;

        NextCol (HTerm);
        DidChange:=True;

      end else if TheCh=CR then begin           {Carriage return.}
        NextNewLine:=False;
        Ch:=MinCol;
        DidChange:=True;
        ShouldUpd:=True;

      end else if (TheCh=LF) or
                  (TheCh=VT) or
                  (TheCh=FF) then begin         {Line feed.}
        CheckDisconnect (HTerm, Screen [Ln-StartScreen+MinRow]);

        NextRow (HTerm);
        DidChange:=True;
        ShouldUpd:=True;

      end else if TheCh=HT then begin           {Tab.}
        if Setup.Cols80 then
          RightSide:=80
        else
          RightSide:=132;

        with Screen [Ln-StartScreen+MinCol]^^ do begin
          if TwoWide then
            RightSide:=RightSide div 2;

          if Ch<RightSide then begin
            repeat
              Ch:=Ch+1;
            until (Ch=RightSide) or TabStops [Ch];

            DidChange:=True;
          end;
        end;

      end else if TheCh=ESC then begin          {Escape ... starts sequence.}
        case Setup.Terminal of
          DBvt100: TermProc:=@TP100Seq;
          DBvt52:  TermProc:=@TP52Seq;
          DBtty:   {Don't see ESC};
        end;

      end else if TheCh=BS then begin           {Backspace.}
        NextNewLine:=False;

        with ParmList.Parm [1] do begin
          Default:=False;
          Value:=1;
        end;
        ParmNr:=1;

        CUB (HTerm);

      end else if TheCh=BELL then begin          {Say "BEEP".}
        if IsActive then
          BeepAlert (3);

      end else if TheCh=ENQ then begin          {Send answerback.}
        (*** Define answerback ***)

      end else if TheCh=SO then begin           {Character set to G1.}
        CharGroup:=GroupG1;

      end else if TheCh=SI then begin           {Character set to G0.}
        CharGroup:=GroupG0;
      end;
    end;
  end; {TPBase}


procedure CallTermProc (TheCh: Char; HTerm: THTerm; TheProc: ProcPtr);
  {CallTermProc calls TheProc with the parameters given.}

  external;


procedure SendToScreen (TheCh: Char; HTerm: THTerm);
  {SendToScreen calls the appropriate TermProc for interpreting the}
  {input sequences.}

  {$IFC NOT UpdateFreq}
  const
    MaxUpdWait=150;           {Maximum time (in 1/100 seconds)    before update.}
    MaxChanges=20;            {Maximum number of critical changes before update.}
  {$ENDC}

  var
    TheProc: ProcPtr;
    DoUpdate: Boolean;

  {$S SegTE}
  begin {SendToScreen}
    {$IFC SampCalls}   ALogCall;   {$ENDC}
    with HTerm^^ do begin
      if (   TheCh=CAN) or
         (   TheCh=SUB) or
         (   TheCh=ESC) or
         (TermProc=NIL) then
        TermProc:=@TPBase;

      TheProc:=TermProc;
      TermProc:=@TPBase;
    end;

    DidChange:=False;                           {Process the character.}
    ShouldUpd:=False;
    CallTermProc (TheCh, HTerm, TheProc);

    if DidChange then begin                     {TheCh altered the screen.}
      with HTerm^^ do begin
        Changed:=True;
        Select.Left:=Select.Right;              {Kill the selection.}
      end;
      Changed:=True;

      if HTerm=TheTerm then                     {Hide the mouse cursor.}
        ObscureCursor;

      if Time>=HTerm^^.LastUpdate+MaxUpdWait then
        ShouldUpd:=True;

      if ShouldUpd then begin                   {Can we postpone the update?}
        with HTerm^^ do begin
          NrChanges:=NrChanges+1;
          DoUpdate:= ((NrChanges >= MaxChanges           ) or
                      (Time      >= LastUpdate+MinUpdWait) or
                      (Repaint                           ));
        end;

        if DoUpdate then begin                  {Do the update now.}
          MakeVisible (HTerm);

          if HTerm^^.Repaint then
            PaintTerm (HTerm)
          else
            UpdateTerm (HTerm);

          LetOthersRun;                         {Don't hog the CPU.}
        end;
      end;
    end;
  end; {SendToScreen}


procedure EventToSeq (HTerm: THTerm; TheEvent: EventRecord;
                    var Seq: Paoc; var Len: Integer);
  {EventToSeq takes the KeyDown event in TheEvent and returns Seq with the}
  {decoded keystroke.}

  const                                         {Keycap codes ...}
    Kpd00=$49;                                  {'0' on keypad.}
    Kpd01=$4D;                                  {'1' on keypad.}
    Kpd02=$2D;                                  {'2' on keypad.}
    Kpd03=$2E;                                  {'3' on keypad.}
    Kpd04=$28;                                  {'4' on keypad.}
    Kpd05=$29;                                  {'5' on keypad.}
    Kpd06=$2A;                                  {'6' on keypad.}
    Kpd07=$24;                                  {'7' on keypad.}
    Kpd08=$25;                                  {'8' on keypad.}
    Kpd09=$26;                                  {'9' on keypad.}
    Kpd10=$27;                                  {'/' on keypad.}
    Kpd11=$2B;                                  {',' or '.' on keypad.}
    Kpd12=$2C;                                  {'.' on keypad.}
    Kpd13=$2F;                                  {ENTER on keypad}

    EscKey=$68;                                 {Top-Left key (for ESC).}
    BreakKey=$46;                               {Main ENTER key (for BREAK).}

    NegPadKey=Kpd10;                            {Map to '-'.}
    CmaPadKey=Kpd11;                            {Map to kpd11}

    LKey=$22;                                   {Left arrow.}
    RKey=$23;                                   {Right arrow.}
    UKey=$27;                                   {Up arrow.}
    DKey=$2B;                                   {Down arrow.}

    PF1Key=$20;                                 {PF keys (numeric top row).}
    PF2Key=$21;
    PF3Key=$22;
    PF4Key=$23;

  var
    OKToSend: LongInt;
    UartName: PathName;
    eCode: Integer;
    I: Integer;
    CantRepeat: Boolean;
    DoKeyPad: Boolean;
    KeybrdID: KeybdId;                         {*}
    language:   INTEGER;


  {$S SegTEIdle}
  begin {EventToSeq}
    {$IFC SampCalls}   ALogCall;   {$ENDC}

    language := ORD(HTerm^^.CharSet[HTerm^^.CharGroup]) - 2;
    IF language < 0 THEN      {Test for the GraphCharSet}
      language := 0;
    TheEvent.Ascii := ConvertLanguage(TheEvent.Ascii,language);


    Len:=0;                                             {Assume the empty sequence.}
    CantRepeat:=False;

    if (TheEvent.KeyCap=BreakKey) and (not TheEvent.RepeatKey) then begin {BREAK.}
      if HTerm^^.Setup.OnLine then begin
        OKToSend:=Time+30;                              {Wait until UART empty.}
        while Time<=OKToSend do;

        UartName:=Concat ('-', UartPath [HTerm^^.Setup.PortA], '-xxx'); {Send break.}
        Device_Control (eCode, UartName, GroupX [TheEvent.ShiftKey]);

        if TheEvent.AppleKey then                       {Reply with answerback message.}
          with HTerm^^.Setup do begin
            Len:=Length (AnswrBk);
            for I:=1 to Len do
              Seq [I]:=AnswrBk [I];
          end;
      end;

    end else begin
      if not TheEvent.AppleKey then begin               {CTRL off.}
        DoKeyPad:=HTerm^^.KeyPad;
        if DoKeyPad then                                {Possible keypad encoding.}
          case TheEvent.KeyCap of
            Kpd00: Seq [3]:='p';
            Kpd01: Seq [3]:='q';
            Kpd02: Seq [3]:='r';
            Kpd03: Seq [3]:='s';
            Kpd04: Seq [3]:='t';
            Kpd05: Seq [3]:='u';
            Kpd06: Seq [3]:='v';
            Kpd07: Seq [3]:='w';
            Kpd08: Seq [3]:='x';
            Kpd09: Seq [3]:='y';
            Kpd10: Seq [3]:='m';
            Kpd11: Seq [3]:='l';
            Kpd12: Seq [3]:='n';
            Kpd13: Seq [3]:='M';
            otherwise DoKeyPad:=False;
          end;

        if DoKeyPad then begin                          {Encode keypad stroke.}
          Len:=3;
          Seq [1]:=ESC;

          if HTerm^^.Setup.Terminal=DBvt100 then
            Seq [2]:='O'
          else
            Seq [2]:='?';

        end else begin                                  {Encode normally.}
          if TheEvent.KeyCap in [PF1Key, PF2Key, PF3Key, PF4Key] then begin
            Seq [1]:=ESC;                               {PF keys.}

            if HTerm^^.Setup.Terminal=DBvt100 then begin
              Seq [2]:='O';
              Len:=3;

            end else
              Len:=2;

            case TheEvent.KeyCap of
              PF1Key: Seq [Len]:='P';
              PF2Key: Seq [Len]:='Q';
              PF3Key: Seq [Len]:='R';
              PF4Key: Seq [Len]:='S';
            end;

          end else begin
            Len:=1;

            if      TheEvent.ASCII =ETX       then Seq [1]:=CR
            else if TheEvent.KeyCap=EscKey    then Seq [1]:=ESC
            else if TheEvent.KeyCap=NegPadKey then Seq [1]:='-'
            else if TheEvent.KeyCap=CmaPadKey then begin      {*}
                 KeybrdId:=Keyboard;
                 KeybrdId:=KeybrdID MOD 64;
                 If KeybrdID in [$26..$2E] then Seq[1]:='.'
                 else Seq[1]:=',';
            end else if TheEvent.ASCII <DEL       then Seq [1]:=TheEvent.ASCII;

            if (Seq [1]=CR) and HTerm^^.Setup.AutoLF then begin
              Seq [2]:=LF;
              Len:=2;
            end;

            CantRepeat:= (Seq [1] in [CR, HT, ESC]);
          end;
        end;

      end else begin                                    {CTRL on.}
        if TheEvent.KeyCap in [EscKey,Kpd13]       {*}
          then begin                    {What's hiding under ESC, Return?}
          Len:=1;
          Seq [1]:=TheEvent.ASCII;

        end else if TheEvent.KeyCap in [LKey, RKey, UKey, DKey] then begin
        if not TheEvent.ShiftKey then begin                       {*}
          Seq [1]:=ESC;                                 {Cursor control keys.}

          with HTerm^^, Setup do
            if Terminal=DBvt100 then begin
              if CursorKeys then
                Seq [2]:='O'
              else
                Seq [2]:='[';

              Len:=3;

            end else
              Len:=2;

          case TheEvent.KeyCap of
            UKey: Seq [Len]:='A';
            DKey: Seq [Len]:='B';
            RKey: Seq [Len]:='C';
            LKey: Seq [Len]:='D';
          end;

        end else begin            {shift on}
          Len:=1;
          if TheEvent.KeyCap =CmaPadKey then begin
                KeybrdId:=Keyboard;
                KeybrdId:= KeybrdId MOD 64;
                If KeybrdId in [$26..$2E] then Seq[1]:= '.'
                else Seq[1]:=',';
              end else Seq[1]:= TheEvent.Ascii;
          end

        end else if TheEvent.ASCII=BS then begin        {BackSpace => DEL.}
          Len:=1;
          Seq [1]:=DEL;
                                                              {*}
        end else if TheEvent.ASCII in [' ', 'A'..'Z','a'..'z',        {Ctrl-x.}
                                       ';','<','=','>','?',
                                       '[','\',']','^','_','{','|','}','~']
                                       then begin

          Len:=1;
          Seq [1]:=Chr (Ord (TheEvent.ASCII) mod 32);
          CantRepeat:=True;

        end

        {$IFC Scramble }
          else if TheEvent.ASCII='1' then
            TheHeap^.fScramble:=False

          else if TheEvent.ASCII='2' then
            TheHeap^.fScramble:=True

          else if TheEvent.ASCII='3' then
            TheHeap^.fCheck:=False

          else if TheEvent.ASCII='4' then
            TheHeap^.fCheck:=True
        {$ENDC }

        {$IFC NrHandles }
          else if TheEvent.ASCII='5' then
            CountHandles:=True

          else if TheEvent.ASCII='6' then
            CountHandles:=False
        {$ENDC }

        {$IFC UpdateFreq}
          else if TheEvent.ASCII='7' then begin
            Writeln('MaxUpdWait is currently set to ',MaxUpdWait);
            Writeln('What do you want to set MaxUpdWait to?');
            Readln(MaxUpdWait);
            Writeln('MinUpdWait is currently set to ',HTerm^^.MinUpdWait);
            Writeln('What do you want to set MinUpdWait to?');
            Readln(HTerm^^.MinUpdWait);
            Writeln('MaxChanges is currently set to ',MaxChanges);
            Writeln('What do you want to set MaxChanges to?');
            Readln(MaxChanges);
          end
        {$ENDC}

        {$IFC SampCalls }
          else if TheEvent.ASCII='8' then begin
            AResetTrace(TRUE);
            aStartCallLog;
          end else if TheEvent.ASCII ='9' then begin
            AStopCallLog;
            AListCalls;
          end;
        {$ENDC}
      end;
    end;

    if TheEvent.RepeatKey and CantRepeat then           {Null out non-repeating stuff.}
      Len:=0;
  end; {EventToSeq}

ÿ