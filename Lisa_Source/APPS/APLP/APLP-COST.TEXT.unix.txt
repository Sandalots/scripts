

{------------------------------------------------------------------------------}
{                  Copyright 1983,1984, Apple Computer Inc.                    }
{                                                                              }
{   Cost control routines, drawing and events.                                 }
{                                                                              }
{                                                                              }
{------------------------------------------------------------------------------}


UNIT PECost;

INTERFACE
USES
   {$U UnitStd    }  UnitStd,    { The basics }
   {$U UnitHz     }  UnitHz,
   {$U LibOs/SysCall    }  SysCall,

   {$U QuickDraw  }  QuickDraw,
   {$U FontMgr    }  FontMgr,    { Fonts & LisaGraf }
   {$U Storage    }  Storage,
   {$U GrafUtil   }  GrafUtil,

   {$U PmDecl     }  PmDecl,
   {$U Pmm        }  Pmm,

   {$U WM.Events  }  Events,     { The window manager }
   {$U WM.Folders }  Folders,
   {$U WM.Windows }  Windows,
   {$U WM.Menus   }  Menus,
   {$U wmlstd     }  WMlstd,
   {$U wmlsb      }  WMlsb,
   {$U wmlcrs     }  WMlcrs,
   {$U wmlgrow    }  WMlGrow,

   {$U PrStdInfo  }  PrStdInfo,
   {$U PrPublic   }  PrPublic,

   {$U AlertMgr   }  AlertMgr,
   {$U Dbenv      }  Dbenv,
   {$U scrap      }  Scrap,
   {$U fedec      }  fedec,
   {$U fld        }  fieldEdit,  { Misc managers }

{$SETC IsIntrinsic = True}
{$SETC WithUObject = False}
{$SETC UTProblems  = False}
{$SETC LibraryVersion = 30}
   {$U Uunivtext  }  UUniversaltext,

   {$U aplp/globals  }  PeGlobals,
   {$U aplp/dmgr     }  Pedmgr,
   {$U aplp/general  }  PeGeneral;     { My guys }


{$IFC PESymbols}
{$D+}
{$ElseC}
{$D-}
{$EndC}

{------------------------------------------------------------------------------}
CONST
   BucketBrigade = 529;    { bucket array goes from [-1..BucketBrigade]     }


TYPE
    { Writes out the task data }
    TPE2WriteUnivText = SUBCLASS OF TWriteUnivText
        FUNCTION  {TPE2WriteUnivText.}Create(object: TUTObject; itsHeap: THeap;
           itsDataArray: TUTString; itsDataSize: INTEGER): TPE2WriteUnivText;
    END;

    { Writes out the cash flow data }
    TPEWriteUnivText = SUBCLASS OF TWriteUnivText
        FUNCTION  {TPEWriteUnivText.}Create(object: TUTObject; itsHeap: THeap;
           itsDataArray: TUTString; itsDataSize: INTEGER): TPEWriteUnivText;
    END;




VAR
   EditRect  : Rect;       { Rect of the editable field                      }
   Bucket    : Array[-1..BucketBrigade] of LongInt; { holds cum cost figures }
   PERow     : Integer;

{ inits any cost variables etc. }
Procedure InitCost;
{ Resets the selection highlighting }
Procedure TblSelReset(myIndex: Integer);

{ drawing/printing routines for the resource table }
Procedure ShowRTbl;
Procedure RTblDeselect     (var error: boolean);
Procedure RTblUp;
Procedure RTblDown         (DownPt: point);
Procedure RTblKey          (theEvent: EventRec);


{ drawing/printing routines for the task table }
Procedure ShowTTbl;
Procedure TTblDeselect     (var error: boolean);
Procedure TTblUp;
Procedure TTblDown         (DownPt: point);
Procedure TTblKey          (theEvent: EventRec);

Procedure CalcFlow;  { Puts the cumulative costs into the buckets   }
Procedure CreatTbl;  { creates a new table according to ActiveChart }

{ Drawing/printing routines for the cash flow table }
Procedure ShowFlow;
Procedure FlowDeselect     (var error: boolean);
Procedure FlowUp;
Procedure FlowDown         (DownPt: point);
Procedure FlowKey          (theEvent: EventRec);

{ drawing/printing routines for the task table }
Procedure ShowAll;
Procedure AllDeselect      (var error: boolean);
Procedure AllUp;
Procedure AllDown          (DownPt: point);
Procedure AllKey           (theEvent: EventRec);

Procedure CellHit(msePt: Point; myChart: Integer; VAR icrs: TC; VAR found: Boolean);
Function  PEClipToField(myRect: Rect): Boolean;
Procedure LongtoASC(myLong: LongInt; VAR MaxChars: Integer; myHnd: hndData);

Procedure TblDocStart( paper, rPrintable: Rect; VAR PagesAcross, PagesDown: Integer);
Procedure TblCopyDocument; { Copies entire table to the scrap }


IMPLEMENTATION
{$IFC fsymok}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}
{$IFC fdbgok}
{$R+}
{$ELSEC}
{$R-}
{$ENDC}



CONST
   FixedLen      = 11;     { number of chars to represent a double integer  }
   MyDatalen     = 200;    { long enough to hold a complete task record for univ text }
   MyEditLen     = 52;     { long enough to hold one editable field         }
   TaskNamLen    = 23;     { number of chars for the task name in the table }

VAR
   lineSpace,              { vertical distance between the lines   }
   emSpace : Integer;      { char width                            }

   TotalNum,               { Total number of tasks                      }
   TopVisNum,              { number of the top visible task record      }
   BotVisNum: Integer;     { number of the bottom visible task record   }

   myData    : Array[0..myDataLen] of byte;
   myptrData : ptrData;
   myhndData : hndData;

   myEdit    : Array[0..myEditLen] of byte;
   myptrEdit : ptrData;
   myhndEdit : hndData;

   CostRgn   : rgnHandle;  { global region holding entire update region      }
   EditRgn   : rgnHandle;  { global region used to edit the fields           }

   PELen,                  { index to last filled spot in Pert's UT buffer   }
   PEIndex   : Integer;    { index to next unsent char in PERT's UT buffer   }

{***********************************************************************}

{$S       }
Procedure InitCost;
Begin
   CostRgn := NewRgn;
   EditRgn := NewRgn;
end;



Procedure LongtoASC{(myLong: LongInt; VAR MaxChars: Integer; myHnd: hndData)};
{ Converts myLong from a LongInt to byte data. Modeled on Dates/Str.
MaxChars is the max number of chars coming in, gets returned as the number
of chars in the converted string. }
VAR
   index    : Integer;  { index to last filled spot }
   myNumb,
   I,
   Next     : Longint;
   Digit    : Integer;
   FillChar : Byte;

Begin
   { Special case 0 }
   If (myLong = 0) Then Begin
      myHnd^^[0] := Ord('0');
      MaxChars := 1;
      Exit(LongtoAsc);
   end;

   { Pick off each digit in turn }
   Index    := MaxChars;
   myNumb   := ABS(myLong);
   While (myNumb > 0) AND (Index > 1) Do Begin
      Next  := myNumb div 10;
      Digit := loWord(myNumb - 10*Next);
      Index := Index - 1;
      myHnd^^[Index] := ord('0') + Digit;
      myNumb:= Next;
   end;

   If (myLong < 0) Then Begin
      Index := Index - 1;
      myHnd^^[Index] := ord('-');
   end;

   If (myNumb = 0) Then Begin
      { Pack the chars to the left }
      MoveLeft(myHnd^^[Index], myHnd^^[0], MaxChars-Index);
      MaxChars := MaxChars - Index;
   end
   Else Begin
      For Index := 0 to (MaxChars - 1) do myHnd^^[Index] := Ord('*');
      { just leave MaxChars alone }
   end;
end;


Procedure ASCtoLong(myHnd: hndData; NumChars: Integer; VAR myLong: LongInt);
{ Converts the ASCIIstring in myHnd to a longint. Modeled on aplp/Dates/asctoInt }
VAR
   Digit,
   Index : Integer;

begin
   myLong  := 0;
   For Index := 0 to (Numchars - 1) do Begin
      Digit := myHnd^^[Index] - Ord('0');
      If (0 <= Digit) AND (Digit <= 9) Then myLong := myLong*10 + digit;
   end;
   If (myHnd^^[0] = ord('-')) Then myLong := -myLong;
end;


Procedure NumtoName(RescNum: Integer; VAR ReturnName: hName);
{ Returns the name handle for the RescNumth resource name in the table }
VAR
   curName : hName;
   Index   : Integer;

Begin
   Index      := 1;
   curName    := Names;
   ReturnName := Nil;

   While (curName <> Nil) and (Index < RescNum) do Begin
      Index := Index + 1;
      CurName := CurName^^.Next;
   end;

   If (Index = RescNum) Then ReturnName := CurName;
end;


Procedure NumtoTask(TaskNum: Integer; VAR ReturnTask: hTask);
{ Returns the task handle for the TaskNumth task in the table }
VAR
   curTask : hTask;
   Index   : Integer;

Begin
   Index := 1;
   curTask := Head;
   ReturnTask := Nil;

   While (curTask <> Nil) and (Index < TaskNum) do Begin
      Index := Index + 1;
      CurTask := CurTask^^.fLink;
   end;

   If (Index = TaskNum) Then ReturnTask := CurTask;
end;


Procedure GtTblRange(mylineSpace: Integer; VAR StartRec, EndRec: Integer);
{ Returns the range of records to be printed or shown on the screen }
VAR
   deltaV : Integer;

Begin
   { Do them all if printing }
   If (Printing) Then Begin
      StartRec := 1;
      EndRec   := TotalNum;
   end

   { Calc the amount of room betweent the table top and the current origin }
   else begin
      deltaV   := myOrigin.v - TableTop;
      StartRec := CMax(1, (deltav div myLineSpace));;
      StartRec := CMin(TotalNum, StartRec);

      { Calc the amount of room in the current window }
      With myFolder^.portrect do deltav := bottom - top;
      EndRec   := StartRec + (deltav div myLineSpace) + 1;
      EndRec   := CMin(TotalNum, EndRec);
   end;
end;


Procedure GetRescCost(curTask: hTask; VAR myRescCost: LongInt);
{ Returns the total resource cost for task curTask }
VAR
   myResc: hResc;
   myName: hName;

Begin
   myRescCost := 0;
   If (CurTask <> Nil) Then Begin
      myResc := CurTask^^.resource;

      While (myResc <> Nil) do with myResc^^ do Begin
         myRescCost := myRescCost + Duration*RName^^.UnitCost;
         myResc := myResc^^.Next;
      end;
   end;
end;


{********************************************************************************************}
{$S PEUTEXT}
Procedure HelpDate(myDay: Integer);
{ Converts the real day myDay to ASCII and writes it into the Pert buffer }
VAR
   mySrcPtr,
   myDstPtr: ptrData;
   Date    : String30;
   curLen  : integer;

Begin
   { Get the ASCII date into Date }
   if (myDay > RDEquiv(calSize - 1)) then Date := '??'
   else DateString(myDay, Date);

   { Insert the ASCII string into Pert's buffer }
   PELen := PELen + 1; { make room for the eventual tabkey }
   curLen := Length(Date);

   mySrcPtr := pointer(ord4(@Date) + 1);
   MoveLeft(mySrcPtr^, myData[PELen], curLen);
   PELen := PELen + curLen;

   myData[PELen] := TabKey;
end;


Procedure HelpCost(myCost: LongInt);
{ Converts a LongInt cost to ASCII and writes it to the PEBuffer }
VAR
   myDstPtr: PtrData;
   CurLen  : Integer;
   myHData : hndData;
Begin
   PELen    := PELen + 1; { make room for the eventual tabkey }
   myDstPtr := pointer(ord4(myPtrData) + PELen);
   myhData  := @myDstPtr;

   CurLen   := FixedLen;
   LongToASC(myCost, curlen, myHData);
   PELen := PELen + curLen;

   myData[PELen] := TabKey;
end;


Procedure FillAllBuffer;
{ fills one buffer full of the project table information }
VAR
   mySrcPtr,
   myDstPtr : ptrData;

   myDay,
   I,
   CurLen  : Integer;

   curResc : hResc;
   curTask : hTask;
   curTitle: hText;
   myRescCost,
   myTotalCost: LongInt;


BEGIN
   PELen := -1;
   PEIndex := 0;
   myPtrData := @myData;
   myHndData := @myPtrData;

   If (PERow > TotalNum) Then Begin
      Exit(FillAllBuffer);
   end
   else begin
      { Get the task handle based on the current row }
      numtoTask(PERow, curTask);

      {***********************************************************************}
      { Stuff the taskname into Pert's buffer }
      curTitle := curTask^^.Title;
      I := 0;  { remember how many we've moved so far }
      PELen := PELen + 1; { make room for the tab char }
      While (curTitle <> Nil) AND (I < TaskNamLen) do Begin
         curLen   := CMin(TaskNamLen - I, curtitle^^.curlen);
         MoveLeft(curTitle^^.text^^, myData[PELen], curLen);
         myData[PELen + curLen] := ord(' ');

         curTitle := curTitle^^.Next;
         I := I + CurLen + 1{ for the blank };
         PELen := PELen + curLen + 1;
      end;
      myData[PELen] := tabKey;

      {***********************************************************************}
      { Stuff the duration. (Use the HelpCost routine to save space) }
      HelpCost(curTask^^.MaxDuration);

      {**********************************************************************}
      { Stuff the 4 dates }
      { First the early start }
      myDay    := RDEquiv(curTask^^.EarlyStart);
      HelpDate(myDay);

      { Early finish }
      With curTask^^ do myDay := RDEquiv(EarlyStart + MaxDuration);
      HelpDate(myDay);

      { Late start }
      With curTask^^ do myDay := RDEquiv(LateStart);
      HelpDate(myDay);

      { Late finish }
      With curTask^^ do myDay := RDEquiv(EarlyStart + MaxDuration);
      HelpDate(myDay);

      {************************************************************************}
      { the 3 cost figures }
      { the fixed cost }
      HelpCost(curTask^^.FixedCost);

      { the resource cost }
      GetRescCost(curTask, myRescCost);
      HelpCost(myRescCost);

      { the total cost }
      myTotalCost := myRescCost + curTask^^.FixedCost;
      HelpCost(myTotalCost);

      {********************************************************************}
      { Draw up to 5 resource names }
      curResc := curTask^^.resource;
      For I := 1 to 5 do Begin
         PELen := PELen + 1; { Make room for the eventual tab char }
         If (curResc <> Nil) Then Begin
            mySrcPtr := Pointer(ord(curResc^^.RText^));
            CurLen   := CMin(FixedLen, curResc^^.RCurLen);
            MoveLeft(mySrcPtr^, myData[PELen], curLen);
            PELen := PELen + CurLen;
            curResc := curResc^^.next;
         end;

         { Write out a tab either way }
         myData[PELen] := TabKey;
      end;

      {********************************************************************}
      { Move the pertinent info into the Univ text fields to finish it off }
      { overwrite the last Tab with a CR }
      myData[PELen] := Return;
      PeRow := PERow + 1;
  end;
END;


Methods Of TPE2WriteUnivText; { writes out the task records }

   FUNCTION  {TPE2WriteUnivText.}Create{object: TUTObject; itsHeap: THeap;
       itsdataArray: TUTString; itsDataSize: Integer): TPE2WriteUnivText};
   VAR
      mycBkStd: TC;
      myHZ    : tHZ;
   Begin
      PERow   := 1;   { index to next row to send           }
      PELen   := -1;  { index to last filled character spot }
      PEIndex := 0;   { index to next char to send          }

      myPtrData := @myData;
      myHndData := @myPtrData;

      If (Object = Nil) then object := NewUTObject(itsHeap, thisClass);
      Self := TPe2WriteUnivText(TWriteUnivText.create(Object, itsheap, itsdataArray, itsdataSize));
   end;


   PROCEDURE {TPE2WriteUnivText.}FillParagraph;
   { Fills a run for the the project table }
   VAR
      curLen         : Integer;
      mySrcPtr       : ptrData;

   BEGIN
      Self.Data.DelAll;
      Self.ParagraphDescriptor.ParagraphStart := True;
      If (PERow > TotalNum) then exit(FillParagraph);

      { Refill the buffer }
      FillAllBuffer;

      { Send the characters }
      curLen   := PELen + 1;
      mySrcPtr := pointer(ord(@myData));
      Self.Data.InsPAOCAt(self.data.size+1, pointer(ord(mySrcPtr)), curLen);
   END;
END;


PROCEDURE FillFlowBuffer;
{ fills one buffer full of the cash flow information }
VAR
   Day,
   BucketNum  : Integer;
   Incremental: LongInt;     { Incremental cost figure }

BEGIN
   PELen   := -1; { index to last filled spot      }
   PEIndex := 0;  { index to last unsent character }
   myPtrData := @myData;
   myHndData := @myPtrData;

   If (PERow <= TotalNum) Then begin
      { See aplp/Gantt/DrawTimeLabels for a model for this code }
      BucketNum := PERow - 1;

      {*************************************************************************}
      { Stuff the start date string }
      If (Head = Nil) Then Day := 0
      Else Day := StartTime;
      Day := Day + (BucketNum)*GridIncrement[curGridSize];
      HelpDate(Day);

      {*************************************************************************}
      { Stuff the Incremental cost string }
      Incremental := Bucket[BucketNum] - Bucket[BucketNum - 1];
      HelpCost(Incremental);

      {*************************************************************************}
      { Do the finish day }
      Day := Day + GridIncrement[CurGridSize];
      HelpDate(Day);

      {*************************************************************************}
      { Draw the Cumulative cost string straight out of the bucket }
      HelpCost(Bucket[BucketNum]);

      {*************************************************************************}
      { Bump the row number for the next time we're called }
      PERow := PERow + 1;
   end;

   { overwrite the last tab with a CR }
   myData[PELen] := Return;
end;


{$S PEUTEXT}
Methods Of TPEWriteUnivText; { Writes out the cash flow table }

   FUNCTION  {TPEWriteUnivText.}Create{object: TUTObject; itsHeap: THeap;
              itsdataArray: TUTString; itsDataSize: Integer): TPEWriteUnivText};
   Begin
      PERow   := 1;   { index to next row to send           }
      PELen   := -1;  { index to last filled character spot }
      PEIndex := 0;   { index to next char to send          }

      myPtrData := @myData;
      myHndData := @myPtrData;

      If (Object = Nil) Then Object := NewUTObject(itsHeap, ThisClass);
      Self := TPEWriteUnivText(TWriteUnivText.Create(object, itsHeap, itsDataArray, itsDataSize));
   end;


    PROCEDURE {TPEWriteUnivText.}FillParagraph;
    { Fills a run for the the cash flow table }
    VAR
       curLen         : Integer;
       mySrcPtr       : ptrData;
    BEGIN
       Self.Data.DelAll;
       Self.ParagraphDescriptor.ParagraphStart := True;
       If (PERow > TotalNum) then exit(FillParagraph);

       { Refill the buffer }
       FillFlowBuffer;

       { Send the chars }
       curLen         := PELen + 1;
       mySrcPtr       := pointer(ord(@myData));
       Self.Data.InsPAOCAt(Self.Data.Size + 1, pointer(ord(mySrcPtr)), curLen);
    END;
END; { Methods }

{$S PEUTEXT}
Procedure TblCopyDocument;
{ Copies the entire active table to the scrap }
VAR
   myUTObj:  TPEWriteUnivText;
   myAllObj: TPE2WriteUnivText;
   errNum    : Integer;

Procedure ErrorExit(message: integer);
begin
   case message of
      29: begin
         {$IFC PEDebug}
         writeln('scrap error is ',errnum);
         {$EndC}
         StopAlert(PeAlert, 29 {scrap Error});
      end;

      50: begin
         ParamAlert('Copy', '','');
         StopAlert( PeAlert, 50 {Out Of Memory});
      end;
   end; { case }

   {myscrapConts := nothing; }
   exit(TblCopyDocument);
end;


Begin
   { claim the scrap, erase old data }
   InHeritScrap(true);
   EraseScrapData(errnum);
   if errnum>0 then ErrorExit(29);

   If (ActiveChart = CashFlow) Then Begin
      { Get a Universal text object, write the data to the scrap }
      myUTObj := TPEWriteUnivText.Create(NIL, pointer(ord(theHeap)), Nil {TUTString}, myDataLen);

      myUTObj.Free;
   end

   else if (ActiveChart = TaskTable) Then Begin
      myAllObj := TPE2WriteUnivText.Create(NIL, pointer(ord(theHeap)), Nil {TUTString}, myDataLen);

      myAllObj.Free;
   end;

   { and display the new scrap contents }
   {ShowScrap;}
end;

{*****************************************************************************************}

Function PEClipToField{(myRect: Rect): Boolean};
{ Clips to the intersection of myRect and the contents of the window }
VAR
   ContentRect: Rect;

Begin
   With myFolder^.portRect do
      SetRect(ContentRect, Left, Top, Right-dhsBox+1, Bottom-dvsBox+1);
   PECliptoField := SectRect(myRect, ContentRect, ContentRect);
   RectRgn(myFolder^.ClipRgn, ContentRect);
end;


Procedure TblSelReset{(myIndex: Integer)};
{ Rehighlights the selection rect etc. after a redraw for one of the tables }
VAR
   myTag: TCurSelMode;
   myRect: Rect;

Begin
   myTag := CurSelRec[ActiveChart].Tag;
   If (myTag = Document) Then Begin
      { update it visually }
      With myFolder^.PortRect do
         SetRect(myRect, left, top, right-dhsBox+1, Bottom-DvsBox+1);
      InvertRect(myRect);
   end

   else if (myTag = FixCost) Then With EditRect do Begin
      Top     := TableTop + LineSpace*(myIndex - 1) + 1;
      Bottom  := TableTop + LineSpace*myIndex;
      If PECliptoField(EditRect) Then Begin
         DrawField(hTaskField, hfState, True, True);
      end;
   end

   else if (myTag = UnitCSel) Then With EditRect do Begin
      Top     := TableTop + LineSpace*(TotalNum - myIndex) + 1;
      Bottom  := Top + LineSpace - 1;
      If PECliptoField(EditRect) Then Begin
         DrawField(hTaskField, hfState, True, True);
      end;
   end;
end;


Procedure TblDeselect(var error: boolean);
{ General deselect for all the table selections. }

VAR
   myRect: Rect;
   myBool: Boolean;

Begin
   error := False;
   With CurSelRec[ActiveChart] do Begin
      If (Tag = FixCost) Then Begin
         myBool := PECliptoField(EditRect);
         ExitField(hTaskField, hfState);
         Tag := Air;

         { Convert the character string to a LongInt, then back to ASCII }
         With hTaskField^^ do Begin
            ASCtoLong(CurValue, CurLen, HitTask^^.FixedCost);
            CurLen := FixedLen;
            LongtoASC(HitTask^^.FixedCost, CurLen, CurValue);
         end;

         { Display the new value }
         EraseRect(EditRect);
         DrawField(hTaskField, Nil, False, False);
      end

      Else If (Tag = UnitCSel) Then Begin
         myBool := PECliptoField(EditRect);
         ExitField(hTaskField, hfState);
         Tag := Air;

         { Convert the character string to a LongInt, then back to ASCII }
         With hTaskField^^ do Begin
            ASCtoLong(CurValue, CurLen, CSelName^^.UnitCost);
            Curlen := FixedLen;
            LongToASC(CSelName^^.UnitCost, CurLen, CurValue);
         end;

         { Display the new value }
         EraseRect(EditRect);
         DrawField(hTaskField, Nil, False, False);
      end

      Else if (Tag = ChartTitle) Then Begin
         tag := air;
         ExitField( Titles[activechart][index].hTitleField, hfstate );
         ShowCursor;
      end

      Else if (Tag = Document) Then Begin
         tag := Air;
         { update it visually }
         With myFolder^.PortRect do
            SetRect(myRect, left, top, right-dhsBox+1, Bottom-DvsBox+1);
         ClipRect(myRect);
         InvertRect(myRect);
      end;
   end;
end;


Procedure TblTitleSel(DownPt: Point; myIndex: Integer);
{ handles  a down over a title }
VAR
   movePt  : Point;
   errFlag : Boolean;

Begin

   With CurSelRec[activeChart] do Begin

      { See if its a double or triple click }
      if (tag=chartTitle) and (clickCount=2) then begin
         SelectWord(downpt, Titles[activechart][index].htitlefield, hfstate,
         curnbrhood, curtimeout);
      end
      else if (tag=charttitle) and (clickcount=3) then begin
         ExitField(Titles[activechart][index].htitlefield, hfstate );
         SelectAll(Titles[activechart][index].htitlefield, hfstate, curtimeout);
      end

      { else it's a single click so reset the field under edit }
      else begin
         TblDeselect(errFlag);
         tag := ChartTitle;
         index := myIndex;
         {ScrollinRect(Titles[activechart][i].htitleField^^.coords);}
         SetPort(myfolder);
         with myfolder^, portrect do
            SetRectRgn( clipRgn, left, top, right - dhSbox + 1, bottom - dvSbox + 1);
         InitFstate(Titles[activechart][index].hTitleField, hfstate);

         Select( downpt, Titles[activechart][index].hTitleField, hfstate,
         curNbrhood, curTimeout);

         { generate the simulated move events }
         While StillDown Do begin
            GetMouse(MovePt);
            if Not PtinRect(Movept, curnbrhood) then begin
               GrowSel( Movept, Titles[activechart][index].htitlefield, hfstate, curNbrhood);
               setrect(curNbrhood, movept.h - dhNbhd, movept.v - dvNbhd,
                                   movept.h + dhNbhd, movept.v + dvNbhd);
            end; { if }
         end; { while }
      end;
   end;
end;



Procedure RTblSelAll(myIndex: Integer; myName: hName);
{ Selects the unit cost field for myName, the myIndexth name in the table.
  myIndex is used to calc the rectangle placement. }
VAR
   myLen : Integer;
   myBool: Boolean;

Begin
   If (myName <> Nil) Then Begin

      { Set the ASCII unit cost }
      With hTaskField^^ do Begin
         CurValue := myHndEdit;
         CurLen   := myDataLen;
         MaxLen   := myDataLen;
         LongToASC(myName^^.UnitCost, CurLen, myHndEdit);
      end;

      { Set up CurSelRec }
      With CurSelRec[ActiveChart] do Begin
         Tag      := UnitCSel;
         CSelName := myName;
         numName  := myIndex;
         { curSelLoc is unused for this selection type }
      end;

      { Set the field variables }
      InitFState(hTaskField, hfState);
      With EditRect do Begin
         Top    := TableTop + LineSpace*(TotalNum - myIndex) + 1;
         Bottom := Top + LineSpace - 1;
      end;

      SetFCoords(hTaskField, hfState, EditRect); { set Coords and SelectRect }
      SetFAlign (hTaskField, hfState, Right);

      { Draw the highlighting }
      myBool := PECliptoField(EditRect);
      SelectAll(hTaskField, hfState, curTimeOut);
   end;
end;



Procedure TtblSelAll(TaskNum: Integer; myTask: hTask);
{ Selects the fixed cost field for myTask, the TaskNumth field in the table. No redraw. }
VAR
   myBool: Boolean;

Begin
   If (myTask <> Nil) Then Begin

      { Set the ASCII fixed cost }
      With hTaskField^^ do Begin
         CurValue := myHndEdit;
         CurLen   := myDataLen;
         MaxLen   := myDataLen;
         LongToASC(myTask^^.FixedCost, CurLen, myHndEdit);
      end;

      { Set the selection record }
      With CurSelRec[ActiveChart] do Begin
         Tag     := FixCost;
         hitTask := myTask;
         numTask := TaskNum;
         { curSelLoc is unused for this selection type }
      end;

      { Set the field variables }
      InitFState(hTaskField, hfState);
      With EditRect do Begin
         Top    := TableTop + LineSpace*(TaskNum - 1) + 1;
         Bottom := TableTop + LineSpace*TaskNum;
      end;

      SetFCoords(hTaskField, hfState, EditRect); { set Coords and SelectRect }
      SetFAlign (hTaskField, hfState, Right);

      { Draw the highlighting }
      myBool := PEClipToField(EditRect);
      SelectAll(hTaskField, hfState, curTimeOut);
   end;
end;


Procedure HelpDrawField( myAlign: byte; myLen, myLineSpace: Integer; FrameBool: Boolean;
                         VAR myRect: Rect);
{ helper routine to draw a field and lower myRect by the line spacing }

Label
   10;

VAR
   NewRect: Rect;

Begin
   With myRect do Begin
      If (Printing) Then Begin
         { See if the cell rect sects the printrect }
         If SectRect(myRect, PrintRect, NewRect) Then Begin

            { If the entire cell is within the printrect then draw the cell }
            If EqualRect(myRect, NewRect) Then Goto 10

            { if the cell partially sects the printrect then you hit a page boundary  }
            Else Begin
               { Store the new offsets for setting up the next page }
               If (Right  > NewRect.Right)
                  Then NextHOffset := PrHOffset + PrintRect.Left - Left;
               If (Bottom > NewRect.Bottom) Then Begin
                  NextVOffset := PrVOffset + PrintRect.Top - Top;
               end;

               { Offset the rect and exit without drawing this cell }
               Top    := Top    + myLineSpace;
               Bottom := Bottom + myLineSpace;
               Exit(HelpDrawField);
            end;
         end

         { if none of the cell sects printrect then just offset it }
         else Begin
            Top    := Top    + myLineSpace;
            Bottom := Bottom + myLineSpace;
            Exit(HelpDrawField);
         end;
      end;

10:   { Draw the cell contents }
      SetFCoords(hDrawField, Nil, myRect);
      SetFAlign (hDrawField, Nil, myAlign);
      hDrawField^^.CurLen := myLen;
      DrawField(hDrawField, Nil, False, False);

      { Frame it as needed }
      If FrameBool then Begin
         Right := Right+1;
         FrameRect(myRect);
         Right := Right - 1;
      end;

      { Offset it down for the next time through }
      Top   := Top + myLineSpace;
      Bottom:= Bottom + myLineSpace;
   end; { With }
end;


{ drawing/printing routines for the resource table }
Procedure ShowRTbl;
{ shows the resource table used to enter the resource unit costs.
Modeled after routine GANTT/DrawTasks }

VAR
   errNum   : Integer;
   curName  : hName;

   NumRect,
   TaskRect : Rect;

   TitleNum : Integer;         { number of the resource name being displayed}
   mytitle  : Str255;
   myFontNum: Integer;

   mypData  : ptrData;
   myhOffset,
   myvOffset: integer;

Begin
   { Get the font info and set the text characteristics. Set
     TaskRect for clipping the task name }
   CopyRgn(myFolder^.clipRgn, CostRgn);
   With PertFontInfo[ActiveChart] do Begin
      emSpace   := mSpace;
      LineSpace := 4*lSpace div 3; { increase the vert spacing }
      TableTop  := 6*LineSpace;
   end;

   { Init things for displaying the task records. All refer to the next open field }
   myhOffset := 0;
   myvOffset := 0;
   If Printing Then Begin
      myhOffset := PrhOffset;
      myVOffset := PrVOffset;
   end;

   { Set the rects for displaying the task records. }
   With PertFontInfo[ActiveChart], Numrect do Begin
      Left   := myhOffset + paperRect[activechart].left + 2*emspace;
      Top    := myvOffset + TableTop - LineSpace;
      Right  := Left + 5*emSpace + 1;
      Bottom := Top + LineSpace + 1;

      SetRect(TaskRect, NumRect.Right,                Top,
                        NumRect.Right + 25*emSpace,   Bottom);

      SetRect(EditRect, TaskRect.Right,               Top,
                        TaskRect.Right + 13* emSpace, Bottom);
   end;

   { Set the paperrect. }
   With paperRect[activeChart] do Begin
      right  := pageH*(1 + EditRect.Right div PageH);
      Bottom := CMax(TableTop + (TotalNum + 2)*LineSpace, Top + PageV div 2);
   end;

   { Draw the paper and erase the previous contents. Modeled on GANTT/ShowGantt }
   if (not Printing) and (not drawingscrap) then begin
      SetPort(myFolder);
      DrawPaper;  {in aplp/general }
      EraseRect(myFolder^.portrect);
      if Preview then PreviewPrint(activeChart);
   end;

   {*********************************************************************************}
   { Draw the chart titles. In Aplp/General. }
   DrawTitles(ActiveChart);

   { Draw the labels across the top }
   PenNormal;
   mypData := Pointer(ord4(@myTitle) + 1);
   hDrawField^^.curValue :=@mypData;
   SetRunFormat(hDrawField, nil, PertFontInfo[activeChart].myFont, SetFont, errNum);

   { No title for the numbers }
   OffsetRect(NumRect, 0, LineSpace);

   { Resource name title }
   GetItem(Menu[lastBuzz], 8, @myTitle);
   HelpDrawField(Left, Length(myTitle), LineSpace, False, TaskRect);

   { Unit Cost title }
   GetItem(Menu[lastBuzz], 9, @myTitle);
   HelpDrawField(Right, Length(myTitle), LineSpace, False, EditRect);

   { Init things for displaying the resource name records.
     All refer to the next open field }
   PenNormal;
   myptrData := @myData;
   myhndData := @myPtrData;
   myptrEdit := @myEdit;
   myhndEdit := @myPtrEdit;

   {*************************************************************************}
   { Find the record numbers currently visible.  }
   GtTblRange(LineSpace, TopVisNum, BotVisNum);

   { Remember record 1 is displayed at the bottom! }
   numToName(TotalNum - BotVisNum + 1, curName);

   { Draw the information about the visible tasks.
   TitleNum is the label number displayed on the left of the table. We'll display
   the records from the top to the bottom.  }
   TitleNum:= BotVisNum;
   OffsetRect(NumRect,  0, (BotVisNum-1) * LineSpace);
   OffsetRect(TaskRect, 0, (BotVisNum-1) * LineSpace);
   OffsetRect(EditRect, 0, (BotVisNum-1) * LineSpace);

   { Draw the information about each resource }
   While (curName <> nil) do Begin

      {**********************************************************************}
      { Draw the resource number. }
      With hDrawField^^ do Begin
         MaxLen := myDataLen;
         curLen := myDataLen;
         CurValue := myHndData;
         LongtoASC(TitleNum, CurLen, myhndData);
         HelpDrawField(Right, CurLen, -LineSpace, False, NumRect);
      end;

      {*********************************************************************}
      { Draw the Resource name, stuffing handles and curlen into hDrawField }
      With hDrawField^^ do Begin
         curValue := curName^^.text;
         curLen   := CMin(24, curName^^.curLen);
         HelpDrawField(Left, curLen, -LineSpace, True, TaskRect);
      end;

      {*****************************************************************}
      { Draw the unit cost for the resource }
      With hDrawField^^ do Begin
         MaxLen := myDataLen;
         curLen := myDataLen;
         CurValue := myHndData;
         LongtoASC(curName^^.UnitCost, CurLen, myhndData);
         HelpDrawField(Right, CurLen, -LineSpace, True, EditRect);
      end;

      {*****************************************************************}
      { bump the counters and lower the cliprects for the next field}
      If (TitleNum > TopVisNum) Then Begin
         TitleNum := TitleNum - 1;
         CurName  := curName^^.Next;
      end
      else curName := Nil;
   end;

   { Inset it for the editing operations }
   With EditRect Do Begin
      SetRect(EditRect, Left + 2, Top + 2, Right, Bottom - 1);
   end;

   TblSelReset(CurSelRec[ActiveChart].numName);
end;


{ event handlers }
Procedure RTblDeselect{(var error: boolean)};
{ Deselects the current selection in the resource unit cost field. Put here
so Main/myDeselect has something to call, but TblDeselect does all the work. }

Begin
   TblDeselect(error);
end;


Procedure RTblUp;
Begin
end;



Procedure RTblDown{(DownPt: point)};
VAR
   deltaV,
   oldRecordNum,
   xRecordNum,
   I         : Integer;

   errFlag,
   found     : Boolean;

   movePt    : Point;
   myName    : hName;

Begin
   DeltaV     := DownPt.v - TableTop;
   { xRecordNum is the true record number }
   xRecordNum := TotalNum - (DeltaV DIV LineSpace);

   { See if you hit a title }
   Found := False;
   If (xRecordNum > Totalnum) Then TitleHit(downPt, ActiveChart, I, Found);
   If Found then Begin
      { Select the new title }
      TblTitleSel(DownPt, I);
   end

   { Else see which table record you hit }
   Else Begin

      XRecordNum := CMax(1, XRecordNum);
      xRecordNum := CMin(TotalNum, xRecordNum); {Resets to 0 if TotalNum = 0}

      {remember the old selection number if necessary }
      If (CurSelRec[ActiveChart].Tag = UnitCSel)
      Then oldRecordNum := CurSelRec[ActiveChart].numName
      else oldRecordNum := 0;  { indicates nothing previously selected }

      { Deselect ANY TYPE of old selection }
      RTblDeselect(errFlag);

      { Get the task handle for this numbered record }
      NumtoName(xRecordNum, myName);

      { Select the whole thing if it's a new field. }
      If (xRecordNum <> oldRecordNum) Then Begin
         { Highlight the sel and set the tag }
         RtblSelAll(xRecordNum, myName);
         ClickCount := ClickCount - 1;
      end

      { else the user decided to select part of an existing field }
      Else If (XRecordNum > 0) Then Begin
         CurSelRec[ActiveChart].Tag := UnitCSel;

         { the first click in the same field sets the insertion point }
         If (ClickCount = 1) Then Begin
            Select(DownPt, hTaskField, hfState, curNbrHood, curTimeOut);
         end

         { 2nd click selects by word }
         Else if (clickcount = 2) Then Begin
            SelectWord(DownPt, hTaskField, hfState, curNbrHood, curTimeOut);
         end

         { 3 clicks selects the entire thing. }
         Else if (clickCount >= 3) Then Begin
            ExitField(hTaskField, hfState);
            SelectAll(hTaskField, hfState, curTimeOut);
         end;

         While StillDown Do Begin
            GetMouse(movePt);
            If (Not PtInRect(MovePt, curNbrHood)) then Begin
               GrowSel(movePt, hTaskField, hfState, curNbrHood);
            end;
         end;
      end;
   end;
end;



Procedure RTblBS(theEvent: EventRec);
{ handles the backspace character }
VAR
   errNum: Integer;
   myBool: Boolean;

Begin
   if theEvent.shiftkey and not theEvent.AppleKey then
      ForwardSpace(htaskfield, hfstate, errnum)
   else if not theEvent.shiftKey and theEvent.AppleKey then
      BackWord(htaskfield, hfstate, errnum)
   else if theEvent.shiftKey and theEvent.AppleKey then
      ForwardWord(htaskfield, hfstate, errnum)
   else begin
      BackSpace( htaskfield, hfstate, errnum);
   end;

   myBool := PECliptoField(EditRect);
   EraseRect(EditRect);
   DrawField(hTaskField, hfState, True{ShowSel}, False);
end;


Procedure RTblClear(theEvent: EventRec);
VAR
   errNum: Integer;
   myBool: Boolean;

Begin
   ClearField(htaskfield, hfstate, errnum);
   myBool := PECliptoField(EditRect);
   EraseRect(EditRect);
   DrawField(hTaskField, hfState, True{ShowSel}, False);
end;


Procedure RtblCellMove(DeltaCell: Integer);
VAR
   oldRec,
   newRec: Integer;
   errFlag: Boolean;
   newName: hName;

Begin
   oldRec := curSelRec[ActiveChart].numName;
   NewRec := OldRec + DeltaCell;
   NewRec := CMin(TotalNum, NewRec);
   NewRec := CMax(1, NewRec);
   RtblDeselect(errFlag);

   { Get the task handle for this numbered record }
   NumtoName(NewRec, NewName);

   { select the new field }
   RtblSelAll(NewRec, NewName);
end;



Procedure RTblKey{(theEvent: EventRec)};
VAR
   errNum : Integer;
   myOrdch: byte;
   PredictLen : Integer;

Begin
   With CurSelRec[ActiveChart] do Begin
      If (tag = ChartTitle) Then with theEvent do Begin
         TitleKey(activechart, curselrec[activechart].index, ascii, shiftKey,  AppleKey)
      end

      else If (tag = UnitCSel) Then Begin
         myordCh := Ord(theEvent.ASCII);
         Case myOrdCh of
            TabKey,
            Return: RTblCellMove(-1 + 2*Ord(theEvent.ShiftKey));
            Enter : RTblCellMove(0);
            ArwLeft,
            ArwUp : RTblCellMove(+1);
            ArwRight,
            ArwDown:RTblCellMove(-1);

            BSpace: RTblBS(theEvent);
            Clear : RTblClear(theEvent);

            otherwise Begin
               With hfState^^.select.int do Begin
                  PredictLen := hTaskField^^.curLen - (lpLim - lpFst) + 1;
               end;
               If (PredictLen <= 10 {Max # digits}) AND
               ((myOrdch = Ord('-')) OR
                ((ord('0') <= myOrdCh) AND (myOrdCh <= ord('9')))) Then Begin
                  InsCh(theEvent.ASCII, hTaskField, hfState, errNum);
                  If PECliptoField(EditRect) Then Begin
                     EraseRect(EditRect);
                     DrawField(hTaskField, hfState, True{ShowSel}, False);
                  end;
               end;
            end;
         end;
      end;
   end;
end;



{******************************************************************}
{ drawing/printing routines for the task table }
Procedure ShowTTbl;
{ shows the task table used to enter the task fixed costs.
Modeled after routine GANTT/DrawTasks }

VAR
   Delta,
   I,
   errNum   : Integer;
   curTask  : hTask;
   curTitle : hText;
   textLen  : Integer;

   NumRect,
   TaskRect : Rect;

   TitleNum : Integer;         { number of the title being displayed}
   mytitle  : Str255;
   myFontNum: Integer;

   mypData  : ptrData;

   myhOffset,                  { offset numbers for printing        }
   myVOffset: Integer;

Begin
   { Save the ClipRgn which is the maximum area ever needed to redraw }
   CopyRgn(myFolder^.ClipRgn, CostRgn);

   { Get the font info and set the text characteristics. Set
     TaskRect for clipping the task name }
   With PertFontInfo[ActiveChart] do Begin

      emSpace   := mSpace;
      LineSpace := 4*lSpace div 3; { increase the vert spacing }
      { Title placement consts from aplp/general. See also Aplp/General: DrawTitles }
      TableTop  := 6*LineSpace;
   end;

   { Init things for displaying the task records. All refer to the next open field }
   myhOffset := 0;
   myvOffset := 0;
   If Printing Then Begin
      myhOffset := PrhOffset;
      myVOffset := PrVOffset;
   end;

   With PertFontInfo[ActiveChart], NumRect do Begin
      Left   := myhOffset + paperRect[activechart].left + 2*emspace;
      Top    := myvOffset + TableTop - LineSpace;
      Right  := Left + 5*emSpace;
      Bottom := Top + LineSpace + 1;

      SetRect(TaskRect, NumRect.Right,               Top,
                        NumRect.Right + 25*emSpace,  Bottom);

      SetRect(EditRect, TaskRect.Right,              Top,
                        TaskRect.Right + 13*emSpace, Bottom);
   end;

   { Set the paperrect for scrolling and printing }
   With paperRect[activeChart] do Begin
      right  := pageH*(1 + EditRect.Right div PageH);
      Bottom := CMax(TableTop + (TotalNum + 2)*LineSpace, Top + PageV Div 2)
   end;

   { Draw the paper and erase the previous contents. Modeled on GANTT/ShowGantt }
   if (not Printing) and (not drawingscrap) then begin
      SetPort(myFolder);
      DrawPaper;  {in aplp/general }
      EraseRect(myFolder^.portrect);
      if Preview then PreviewPrint(activeChart);
   end;

   {*********************************************************************************}
   { Draw the chart titles. In Aplp/General. }
   DrawTitles(ActiveChart);

   {*********************************************************************************}
   { Draw the labels across the top. In Aplp/General. }

   SetRunFormat(hDrawField, nil, PertFontInfo[activeChart].myFont, SetFont, errNum);
   mypData := Pointer(ord4(@myTitle) + 1);
   hDrawField^^.CurValue := @mypData;

   { Draw the labels across the top }
   PenNormal;
   OffSetRect(NumRect, 0, LineSpace);

   {myTitle := 'Task Name';}
   GetItem(Menu[lastBuzz], 10, @myTitle);
   HelpDrawField(Left, Length(myTitle), LineSpace, False, TaskRect);

   {myTitle := 'Fixed Cost';}
   GetItem(Menu[lastBuzz], 11, @myTitle);
   HelpDrawField(Right, Length(myTitle), LineSpace, False, EditRect);

   myptrData := @myData;
   myhndData := @myPtrData;
   myptrEdit := @myEdit;
   myhndEdit := @myPtrEdit;

   {*************************************************************************}
   { Find the record numbers currently visible }
   GtTblRange(LineSpace, TopVisNum, BotVisNum);
   numToTask(TopVisNum, curTask);

   { Draw the information about the visible tasks }
   TitleNum:= topVisNum;
   OffsetRect(NumRect,  0, (TitleNum-1) * LineSpace);
   OffsetRect(TaskRect, 0, (TitleNum-1) * LineSpace);
   OffsetRect(EditRect, 0, (TitleNum-1) * LineSpace);

   While (curTask <> nil) do Begin

      {**********************************************************************}
      { Draw the task number. }
      With hDrawField^^ do Begin
         CurValue := myHndData;
         CurLen   := myDataLen;
         MaxLen   := myDataLen;

         LongtoASC(TitleNum, CurLen, myhndData);
         HelpDrawField(Right, CurLen, LineSpace, False, NumRect);
      end;

      {*****************************************************************}
      { Draw the task name, stuffing handles and curlen into hDrawField }
      With hDrawField^^ do Begin
         curValue := myHndData;
         I        := 0; { I = index of next open spot }

         { Move the separate lines into one line of text }
         curTitle := curTask^^.title;
         While (CurTitle <> Nil) AND (I < TaskNamLen) Do Begin
            Delta := CMin(TaskNamLen - I, curTitle^^.curLen);
            MoveLeft(curTitle^^.text^^, myHndData^^[I], Delta);
            myHndData^^[I+Delta] := ord(' ');

            I := I + Delta + 1;
            curTitle := curTitle^^.Next;
         end;

         HelpDrawField(Left, I, LineSpace, True, TaskRect);
      end;


      {*****************************************************************}
      { Draw the fixed cost for the task }
      With hDrawField^^ do Begin
         MaxLen := myDataLen;
         CurLen := myDataLen;
         curValue := myHndData;

         LongtoASC(curTask^^.FixedCost, CurLen, myhndData);
         HelpDrawField(Right, CurLen, LineSpace, True, EditRect);
      end;

      {*****************************************************************}
      { bump the counters for the next field}
      TitleNum := TitleNum + 1;
      curTask := curTask^^.fLink;
   end;

   { Inset the EditRect for the editing operations }
   With EditRect Do Begin
      SetRect(EditRect, Left + 2, Top + 2, Right, Bottom - 1);
   end;

   { Reset the selection rect and highlighting }
   TblSelReset(curSelRec[ActiveChart].numTask);
end;

Procedure TTblDeselect{(var error: boolean)};
{ Specific deselect for the task cost entry table. Put here so
Aplp/Main: myDeselect can call it, but uses TblDeselect to do all its work }
Begin
   TblDeselect(error);
end;


Procedure TTblUp;
Begin
end;



Procedure TTblDown{(DownPt: point)};
VAR
   deltaV,
   oldRecordNum,
   RecordNum,
   I         : Integer;
   errFlag,
   found     : Boolean;
   movePt    : Point;
   myTask    : hTask;

Begin
   DeltaV    := DownPt.v - TableTop;
   RecordNum := (DeltaV DIV LineSpace) + 1;

   { Check if the downpt hit a title }
   Found := False;
   If (RecordNum < 1) Then TitleHit(downPt, ActiveChart, I, Found);
   If Found then Begin
      { Select the new one }
      TblTitleSel(DownPt, I);
   end

   else begin

      { otherwise select the closest record }
      RecordNum := CMax(1, RecordNum);
      RecordNum := CMin(TotalNum, RecordNum); {resets to 0 if TotalNum = 0}

      {remember the old selected record if there was one }

      If (CurSelRec[ActiveChart].Tag = FixCost)
      then oldRecordNum := CurSelRec[ActiveChart].numTask
      else oldrecordnum := -1; { indicates no previous selection }

      { Deselect ANY TYPE of old selection }
      TtblDeselect(errFlag);

      { Get the task handle for this numbered record }
      NumtoTask(RecordNum, myTask);

      { Select the whole thing if it's a new field. }
      If (RecordNum <> oldRecordNum) Then Begin
         { Highlight the sel and set the tag }
         TtblSelAll(RecordNum, myTask);
         ClickCount := ClickCount - 1;
      end

      { else the user decided to select part of an existing field }
      Else if (RecordNum > 0) then Begin
         CurSelRec[ActiveChart].Tag := FixCost;

         { the first click in the same field sets the insertion point }
         If (ClickCount = 1) Then Begin
            Select(DownPt, hTaskField, hfState, curNbrHood, curTimeOut);
         end

         { 2nd click selects by word }
         Else if (Clickcount = 2) Then Begin
            SelectWord(DownPt, hTaskField, hfState, curNbrHood, curTimeOut);
         end

         { 3 clicks or selects the entire thing.  }
         Else if (clickCount >= 3) Then Begin
            ExitField(hTaskField, hfState);
            SelectAll(hTaskField, hfState, curTimeOut);
         end;

         While StillDown Do Begin
            GetMouse(movePt);
            If (Not PtInRect(MovePt, curNbrHood)) then Begin
               GrowSel(movePt, hTaskField, hfState, curNbrHood);
            end;
         end;
      end;
   end;
end;



Procedure TtblCellMove(DeltaCell: Integer);
VAR
   oldRec,
   newRec: Integer;
   errFlag: Boolean;
   newTask: hTask;

Begin
   oldRec := curSelRec[ActiveChart].numTask;
   NewRec := OldRec + DeltaCell;
   NewRec := CMin(TotalNum, NewRec);
   NewRec := CMax(1, NewRec);
   TtblDeselect(errFlag);

   { Get the task handle for this numbered record }
   NumtoTask(NewRec, NewTask);

   { select the new field }
   TtblSelAll(NewRec, NewTask);
end;



Procedure TTblBS(theEvent: EventRec);
Begin
   { Save code by using the same handler }
   RTblBS(theEvent);
end;


Procedure TTblClear(theEvent: EventRec);
Begin
   { Save code by using the same handler }
   RTblClear(theEvent);
end;


Procedure TTblKey{(theEvent: EventRec)};
VAR
   errNum : Integer;
   myOrdch: byte;
   PredictLen : Integer;

Begin
   With CurSelRec[ActiveChart] do Begin
      If (tag = ChartTitle) Then with theEvent do Begin
         TitleKey(activechart, curselrec[activechart].index, ascii, shiftKey,  AppleKey)
      end

      Else If (tag = FixCost) Then Begin
         myordCh := Ord(theEvent.ASCII);
         Case myOrdCh of
            TabKey,
            Return: TTblCellMove(+1 - 2*Ord(theEvent.ShiftKey));
            Enter : TTblCellMove(0);
            BSpace: TTblBS(theEvent);
            Clear : TTblClear(theEvent);

            ArwLeft,
            ArwUp : TTblCellMove(-1);

            ArwRight,
            ArwDown:TTblCellMove(+1);

            otherwise Begin
               With hfState^^.select.int do Begin
                  PredictLen := hTaskField^^.curLen - (lpLim - lpFst) + 1;
               end;
               If (PredictLen <= 10 {max # digits}) AND
               ((myOrdCh = ord('-')) OR
                ((ord('0') <= myOrdCh) AND (myOrdCh <= ord('9')))) Then Begin
                  InsCh(theEvent.ASCII, hTaskField, hfState, errNum);
                  If PECliptoField(EditRect) Then Begin
                     EraseRect(EditRect);
                     DrawField(hTaskField, hfState, True{ShowSel}, False);
                  end;
               end;
            end;
         end;
      end;
   end;
end;



{************************************************************}
Procedure AddRescCosts(curTask: hTask);
{ Adds the resource costs for this task into the buckets }
VAR
   I,
   BucketNum: Integer;
   myhResc  : hResc;
   myStartDay: Integer;

Begin
   myStartDay := curTask^^.earlyStart;
   myhResc    := curTask^^.resource;

   While (myhResc <> Nil) Do Begin
      For I := 0 to (myhResc^^.duration-1) do Begin
         BucketNum := (RDEquiv(myStartDay+I) - StartTime) DIV GridIncrement[curGridSize];
         If (BucketNum > BucketBrigade) Then BucketNum := BucketBrigade;
         Bucket[BucketNum] := Bucket[BucketNum] + myhResc^^.RName^^.UnitCost;
      end;

      myhResc := myhResc^^.Next;
   end;
end;


{************************************************************}
Procedure CalcFlow;
VAR
   curTask: hTask;
   BucketNum: Integer;

Begin
   { Zero out all the buckets. The -1th bucket always remains zero, used in ShowFlow
     only for something to subtract against for the 0th incremental cost. }
   For BucketNum := -1 to BucketBrigade do Bucket[BucketNum] := 0;

   {Go down the task list, adding the costs into each bucket }
   curTask := Head;
   While (curTask <> Nil) Do Begin

      { Calc which bucket to stuff the fixed cost figure into. In words, the bucket number =
        (amount of time to reach the early start) DIV (# days between time line increments) }
      BucketNum := (RDEquiv(curTask^^.earlyStart) - StartTime) DIV GridIncrement[curGridSize];
      If (BucketNum > BucketBrigade) then BucketNum := BucketBrigade;

      { Add the fixed cost into this bucket }
      Bucket[BucketNum] := Bucket[BucketNum] + curTask^^.FixedCost;

      { add in the resource costs for this task }
      AddRescCost(curTask);

      { go to the next task }
      CurTask := CurTask^^.fLink;
   end;

   { Sum the incremental costs to get the cumulative costs. Pretty neat huh?! }
   For BucketNum := 1 to BucketBrigade do
   Bucket[BucketNum] := Bucket[BucketNum-1] + Bucket[BucketNum];
end;


Procedure GtRescTot;
VAR
   myName: hName;

Begin
   TotalNum := 0;
   myName   := Names;

   While (myName <> Nil) do Begin
      Totalnum := TotalNum + 1;
      myName   := myName^^.Next;
   end;
end;


Procedure GtTaskTot;
VAR
   myTask: hTask;

Begin
   TotalNum := 0;
   myTask   := Head;

   While (myTask <> Nil) do Begin
      Totalnum := TotalNum + 1;
      myTask   := myTask^^.fLink;
   end;
end;


Procedure GtFlowTot;
{ Calcs the total number of records and fills the buckets }
VAR
   myStartDay,
   myEndDay : Integer;

Begin
   { Find the start and end times in real days }
   If (head = Nil) Then myStartDay := 0
                   Else myStartDay := StartTime;
   myEndDay := CMin(EndTime, RDEquiv(calSize - 1));

   { See how many gridincrements it takes to fill the alloted time }
   TotalNum  := ((myEndDay - myStartDay) DIV GridIncrement[CurGridSize]) + 1;

   { Calc the cumulative costs }
   CalcFlow;
end;



Procedure CreatTbl;
Begin
   { These all just calc the variable TotalNum, the total number of records displayed
     for the table }
   Case ActiveChart of
      RescCost : GtRescTot;
      TaskCost : GtTaskTot;
      CashFlow : GtFlowTot;
      TaskTable: GtTaskTot;
   end;
end;



{************************************************************}
{ drawing/printing routines for the cash flow table }
Procedure ShowFlow;
VAR
   EndDay,                  { Last day for which to display the cash flow }
   Day,                     { indexes through the time line days          }
   I,
   BucketNum,
   emSpace,
   LineSpace : Integer;
   myTask    : hTask;
   Date      : String30;
   Incremental: LongInt;     { Incremental cost figure                    }

   Date1Rect,                { Rect for displaying the start date         }
   IncrRect,                 { Rect for displaying the incremental cost   }
   Date2Rect,                { Rect for displaying the periods end date   }
   CumRect   : Rect;         { Rect for displaying the cumulative cost    }

   mypData   : ptrData;
   myhOffset,
   myvOffset: integer;

Begin
   { Save the ClipRgn which is the maximum area ever needed to redraw }
   CopyRgn(myFolder^.ClipRgn, CostRgn);

   { Init things for displaying the task records. All refer to the next open field }
   myhOffset := 0;
   myvOffset := 0;
   If Printing Then Begin
      myhOffset := PrhOffset;
      myVOffset := PrVOffset;
   end;

   { Set the rects for displaying the task records. }
   With PertFontInfo[ActiveChart], Date1rect do Begin
      emSpace   := mSpace;
      LineSpace := 4*lSpace div 3; { increase the vert spacing }
      TableTop  := 6*LineSpace;

      Left   := myhOffset + paperRect[activechart].left + 7*emspace;
      Top    := myvOffset + TableTop - LineSpace;
      Right  := Left + 10*emSpace + 1;
      Bottom := Top + LineSpace + 1;

      SetRect(IncrRect , Date1Rect.Right,            Top,
                         Date1Rect.Right+12*emSpace, Bottom);

      SetRect(Date2Rect, IncrRect.Right,             Top,
                         IncrRect.Right+10*emSpace,  Bottom);

      SetRect(CumRect  , Date2Rect.Right,            Top,
                         Date2Rect.Right+12*emSpace, Bottom);
   End;

   { Set the paperrect for scrolling and printing }
   With paperRect[activeChart] do Begin
      right  := pageH*(1 + CumRect.Right DIV PageH);
      Bottom := CMax(TableTop + (TotalNum + 2)*LineSpace, Top + PageV div 2);
   end;

   { Draw the paper and erase the previous contents. Modeled on GANTT/ShowGantt }
   if (not Printing) and (not drawingscrap) then begin
      SetPort(myFolder);
      DrawPaper;  {in aplp/general }
      EraseRect(myFolder^.portrect);
      if Preview then PreviewPrint(activeChart);
   end;

   {**************************************************************************}
   { Draw the titles across the top }
   PenNormal;
   DrawTitles(ActiveChart);

   { Draw the table labels }
   mypData := Pointer(ord4(@Date) + 1);
   hDrawField^^.curValue := @myPData;

   {Date := 'Start';}
   GetItem(Menu[lastBuzz], 12, @Date);
   HelpDrawField(Center, Length(Date), LineSpace, False, Date1Rect);

   {Date := 'Incremental';}
   GetItem(Menu[lastBuzz], 13, @Date);
   HelpDrawField(Center, Length(Date), LineSpace, False, IncrRect);

   {Date := 'End';}
   GetItem(Menu[lastBuzz], 14, @Date);
   HelpDrawField(Center, Length(Date), LineSpace, False, Date2Rect);

   {Date := 'Cumulative';}
   GetItem(Menu[lastBuzz], 15, @Date);
   HelpDrawField(Center, Length(Date), LineSpace, False, CumRect);

   {*************************************************************************}
   { Find the record numbers currently visible }
   GtTblRange(LineSpace, TopVisNum, BotVisNum);

   { Draw the information about the visible tasks }
   OffsetRect(Date1Rect, 0, (TopVisNum-1) * LineSpace);
   OffsetRect(IncrRect,  0, (TopVisNum-1) * LineSpace);
   OffsetRect(Date2Rect, 0, (TopVisNum-1) * LineSpace);
   OffsetRect(CumRect,   0, (TopVisNum-1) * LineSpace);

   { See aplp/Gantt/DrawTimeLabels for a model for this code }
   { Set Day to be the start day of the first visible record }
   If (Head = Nil) Then Day := 0
   Else Day := StartTime;
   Day := Day + (TopVisNum - 1)*GridIncrement[curGridSize];

   { Set the EndDay to be the first day for the last interval }
   EndDay:= CMin(EndTime, RDEquiv(CalSize - 1));
   EndDay:= CMin(EndDay, Day+(BotVisNum-TopVisNum)*GridIncrement[curGridSize]);

   BucketNum := TopVisNum - 1;

   { Draw out all the records }
   Repeat Begin
      {*************************************************************************}
      { Draw the start date string }
      mypData := Pointer(ord4(@Date) + 1);

      hDrawField^^.curValue := @myPData;
      If (Day > RDEquiv(calSize - 1)) Then Date := '??'
                                      Else DateString(Day, Date);
      HelpDrawField(Center, Length(Date), LineSpace, True, Date1Rect);

      {*************************************************************************}
      { Draw the Incremental cost string }
      myptrData := @myData;    { global handles }
      myHndData := @myPtrData;
      Incremental := Bucket[BucketNum] - Bucket[BucketNum -1];
      With hDrawField^^ do Begin
         curValue := myHndData;
         curLen   := myDataLen;
         MaxLen   := myDataLen;

         LongtoASC(Incremental, CurLen, myHndData);
         HelpDrawField(Right, CurLen, LineSpace, True, IncrRect);
      end;

      {*************************************************************************}
      { Do the finish day }
      hDrawField^^.CurValue := @mypData;
      Day := Day + GridIncrement[CurGridSize];
      If (Day > RDEquiv(calSize - 1)) Then Date := '??'
                                      Else DateString(Day, Date);

      HelpDrawField(Center, Length(Date), LineSpace, True, Date2Rect);

      {*************************************************************************}
      { Draw the Cumulative cost string straight out of the bucket }
      With hDrawField^^ do Begin
         curValue := myHndData;
         curLen   := myDataLen;
         MaxLen   := myDataLen;

         LongtoASC(Bucket[BucketNum], CurLen, myHndData);
         HelpDrawField(Right, CurLen, LineSpace, True, CumRect);
      end;

      {*************************************************************************}
      { Bump everything for the next run through }
      BucketNum := BucketNum + 1;

   end Until (Day > EndDay);

   { Reset the selection rect and highlighting }
   TblSelReset(0 {dummy});
end;


Procedure FlowDeselect{(var error: boolean)};
Begin
   TblDeselect(error);
end;


Procedure FlowUp;
Begin
end;


Procedure FlowDown{(DownPt: point)};
VAR
   I    : Integer;
   Found,
   errFlag: Boolean;

Begin
   { See if you hit a title }
   Found := False;
   TitleHit(downPt, ActiveChart, I, Found);
   If Found then Begin
      { Select the new title }
      TblTitleSel(DownPt, I);
   end
   else FlowDeselect(errFlag);
end;


Procedure FlowKey{(theEvent: EventRec)};
Begin
   With CurSelRec[ActiveChart] do Begin
      If (tag = ChartTitle) Then with theEvent do Begin
         TitleKey(activechart, curselrec[activechart].index, ascii, shiftKey,  AppleKey)
      end;
   end;
end;


{**************************************************************************}
{                                                                          }
{ Routines to handle the task table operations                             }
{                                                                          }
{**************************************************************************}

Procedure ShowAll;
{ shows the task table used to display all the task information.
Modeled after routine GANTT/DrawTasks }

CONST
   MaxAllRect = 15;

VAR
   errNum,
   Delta,
   I        : Integer;
   curTask  : hTask;
   curTitle : hText;
   curResc  : hResc;

   Rectal: Array[1..MaxAllRect] of Rect;

   Date  : String30;
   myDay : Integer;

   myRescCost,
   myTotalCost : Longint;

   TitleNum : Integer;         { number of the title being displayed}
   mytitle  : Str255;
   myFontNum: Integer;

   mypData  : ptrData;
   myhOffset,
   myvOffset: Integer;

Begin
   { Save the ClipRgn which is the maximum area ever needed to redraw }
   CopyRgn(myFolder^.ClipRgn, CostRgn);

   { Get the font info and set the text characteristics. Set
     TaskRect for clipping the task name }
   With PertFontInfo[ActiveChart] do Begin
      emSpace   := mSpace;
      LineSpace := 4*lSpace div 3; { increase the vert spacing }
      TableTop  := 6*LineSpace;
   end;

   { Init things for displaying the task records. All refer to the next open field }
   myhOffset := 0;
   myvOffset := 0;
   If Printing Then Begin
      myhOffset := PrhOffset;
      myVOffset := PrVOffset;
   end;

   { Init things for displaying the task records. All refer to the next open field }
   With PertFontInfo[ActiveChart], Rectal[1] do Begin
      Left   := myhOffset + paperRect[activechart].left;
      Top    := myvOffset + TableTop - LineSpace;
      Right  := Left + 5*emSpace;
      Bottom := Top + LineSpace + 1;

      SetRect(Rectal[2], Rectal[1].Right,                      Top,
                 Rectal[1].Right + (TaskNamLen+1)*emSpace,     Bottom);        { Task Name }

      SetRect(Rectal[3], Rectal[2].Right,                      Top,
                         Rectal[2].Right + 6*emSpace,          Bottom);        { Duration  }

      { the 4 dates, the 3 costs, and the 5 resource names all have the same width }
      For I := 4 to MaxAllRects do Begin
         SetRect(Rectal[I],  Rectal[I-1].Right,                         Top,
                             Rectal[I-1].Right + (FixedLen+1)*emSpace,  Bottom);
      end;
   end;

   { Set the paperrect for scrolling and printing }
   With paperRect[activeChart] do Begin
      right  := pageH*(1 + Rectal[MaxAllRect].Right div PageH);
      Bottom := CMax( TableTop + (TotalNum + 2)*LineSpace, Top + PageV div 2);
   end;

   { Draw the paper and erase the previous contents. Modeled on GANTT/ShowGantt }
   if (not Printing) and (not drawingscrap) then begin
      SetPort(myFolder);
      DrawPaper;  {in aplp/general }
      EraseRect(myFolder^.portrect);
      if Preview then PreviewPrint(activeChart);
   end;

   DrawTitles(ActiveChart);

   SetRunFormat(hDrawField, nil, PertFontInfo[activeChart].myFont, SetFont, errNum);
   mypData := Pointer(ord4(@myTitle) + 1);
   hDrawField^^.CurValue := @mypData;

   { Draw the labels across the top }
   PenNormal;
   OffSetRect(Rectal[1], 0, LineSpace);

   {myTitle := 'Task Name';}
   GetItem(Menu[lastBuzz], 16, @myTitle);
   HelpDrawField(Left, Length(myTitle), LineSpace, False, Rectal[2]);

   For I := 3 to 15 do Begin
      GetItem(Menu[LastBuzz], I+14, @myTitle);
      HelpDrawField(Center, Length(myTitle), LineSpace, False, Rectal[I]);
   end;

   myptrData := @myData;
   myhndData := @myPtrData;

   {*************************************************************************}
   { Find the record numbers currently visible }
   GtTblRange(LineSpace, TopVisNum, BotVisNum);
   numToTask(TopVisNum, curTask);

   { Set the rects at the right vertical placement }
   TitleNum:= topVisNum;
   For I := 1 to MaxAllRect do OffsetRect(Rectal[I],  0, (TitleNum-1) * LineSpace);

   { Draw the information about the visible tasks }
   While (curTask <> nil) do Begin

      {**********************************************************************}
      { Draw the task number. }
      With hDrawField^^ do Begin
         CurValue := myhndData;
         CurLen   := myDataLen;
         MaxLen   := myDataLen;

         LongtoASC(TitleNum, CurLen, myhndData);
         HelpDrawField(Right, CurLen, LineSpace, False, Rectal[1]);
      end;

      {*****************************************************************}
      { Draw the task name, stuffing handles and curlen into hDrawField }
      With hDrawField^^ do Begin
         curValue := myHndData;
         I        := 0; { I = index of next open spot }

         { Move the separate lines into one line of text }
         curTitle := curTask^^.title;
         While (CurTitle <> Nil) AND (I < TaskNamLen) Do Begin
            Delta := CMin(TaskNamLen - I, curTitle^^.curLen);
            MoveLeft(curTitle^^.text^^, myHndData^^[I], Delta);
            myHndData^^[I+Delta] := ord(' ');

            I := I + Delta + 1;
            curTitle := curTitle^^.Next;
         end;

         HelpDrawField(Left, I, LineSpace, True, Rectal[2]);
      end;

      {*****************************************************************}
      { Draw the duration }
      With hDrawField^^ do Begin
         CurValue := myhndData;
         CurLen   := myDataLen;
         MaxLen   := myDataLen;

         LongtoASC(curTask^^.MaxDuration, CurLen, myhndData);
         HelpDrawField(Right, CurLen, LineSpace, True, Rectal[3]);
      end;

      {*****************************************************************}
      { Draw the early start time for the task... }
      mypData:= pointer(ord4(@Date) + 1);
      hDrawField^^.CurValue := @mypData;

      myDay := RDEquiv(curTask^^.EarlyStart);
      If (myDay > RDEquiv(calSize - 1))
         Then Date := '??'
         Else DateString(myDay, Date);

      HelpDrawField(Center, Length(Date), LineSpace, True, Rectal[4]);

      { ... and the EarlyFinish, LStart, and LFinish times }

      With curTask^^ do myDay := RDEquiv(EarlyStart + MaxDuration);
      If (myDay > RDEquiv(calSize - 1))
         Then Date := '??'
         Else DateString(myDay, Date);
      HelpDrawField(Center, Length(Date), LineSpace, True, Rectal[5]);

      With curTask^^ do myDay := RDEquiv(LateStart);
      If (myDay > RDEquiv(calSize - 1))
         Then Date := '??'
         Else DateString(myDay, Date);
      HelpDrawField(Center, Length(Date), LineSpace, True, Rectal[6]);

      With curTask^^ do myDay := RDEquiv(LateStart + MaxDuration);
      If (myDay > RDEquiv(calSize - 1))
         Then Date := '??'
         Else DateString(myDay, Date);
      HelpDrawField(Center, Length(Date), LineSpace, True, Rectal[7]);

      {*****************************************************************}
      { Draw the costs for the task }

      { Draw the fixed cost }
      With hDrawField^^ do Begin
         curValue := myHndData;
         CurLen := myDataLen;
         LongtoASC(curTask^^.FixedCost, CurLen, myhndData);
         HelpDrawField(Right, CurLen, LineSpace, True, Rectal[8]);
      End;

      { Draw the resource cost for the task }
      GetRescCost(curTask, myRescCost);
      With hDrawField^^ do Begin
         CurLen := myDataLen;
         LongtoASC(myRescCost, CurLen, myhndData);
         HelpDrawField(Right, CurLen, LineSpace, True, Rectal[9]);
      end;

      { Draw the total cost for the task }
      myTotalCost := curTask^^.FixedCost + myRescCost;
      With hDrawField^^ do Begin
         CurLen   := myDataLen;
         LongtoASC(myTotalCost, CurLen, myhndData);
         HelpDrawField(Right, CurLen, LineSpace, True, Rectal[10]);
      End;

      {*****************************************************************}
      { Draw 5 resource names for the task }

      curResc := curTask^^.resource;
      For I := 11 to 15 Do Begin
         { just frame the rect if there's no resource }
         If (CurResc = Nil) Then HelpDrawField(Left, 0, LineSpace, True, Rectal[I])

         { otherwise draw the resource name and frame the rect }
         Else with hDrawField^^, curResc^^ do Begin
            curValue := RText;
            CurLen   := CMin(RCurLen, FixedLen);
            HelpDrawField(Left, CurLen, LineSpace, True, Rectal[I]);
            curResc := curResc^^.next;
         end
      end;

      {*****************************************************************}
      { bump the counters etc. }
      If (Titlenum < BotVisNum) Then Begin
         TitleNum := TitleNum + 1;
         curTask := curTask^^.fLink;
      end
      Else curTask := Nil;
   end;

   { Reset the selection rect and highlighting }
   TblSelReset(0 {dummy});
end;



Procedure AllDeselect{(var error: boolean)};
Begin
   TblDeselect(error);
end;

Procedure AllUp;
Begin
end;


Procedure AllDown{(DownPt: point)};
VAR
   found,
   errflag: Boolean;
   I    : Integer;

Begin
   { See if you hit a title }
   Found := False;
   TitleHit(downPt, ActiveChart, I, Found);
   If Found then Begin
      { Select the new title }
      TblTitleSel(DownPt, I);
   end
   Else TblDeselect(errFlag);
end;


Procedure AllKey{(theEvent: EventRec)};
Begin
   With CurSelRec[ActiveChart] do Begin
      If (tag = ChartTitle) Then with theEvent do Begin
         TitleKey(activechart, curselrec[activechart].index, ascii, shiftKey,  AppleKey)
      end;
   end;
end;

Procedure CellHit{(msePt: Point; myChart: Integer; VAR icrs: TC; VAR Found: Boolean)};
{ Returns found and a new cursor if msept is within the cell under edit }
Begin
   Found := False;
   With CurSelRec[ActiveChart] do Begin
      If ((Tag = FixCost) OR (Tag = UnitCSel)) Then Begin
         If PtInRect(msePt, EditRect) Then Begin
            icrs := icrsIBeam;
            Found := True;
         end;
      end;
   end;
end;


Procedure TblDocStart{ paper, rPrintable: Rect; VAR PagesAcross, PagesDown: Integer };
{ recode to match the code in HelpDrawField }
VAR
   myPageH,
   myPageV,
   FirstFit,            { Number of records that fit on first page       }
   NumOnPage: Integer;  { Number of records that fit on succeeding pages }

Begin
   With rPrintable do Begin
      myPageH := Right  - Left;
      myPageV := Bottom - Top;
   end;

   { Set up the local globals }
   With PertFontInfo[ActiveChart] do Begin
      emSpace   := mSpace;
      LineSpace := 4*lSpace div 3; { increase the vert spacing }
      TableTop  := 6*LineSpace;
   end;

   { Calc the pages across. This is 0 based. }
   pagesAcross  := (paper.right - paper.left) div myPageH;

   { Calc the pages down, also 0 based }
   PagesDown := 0;
   FirstFit  := (myPageV - TableTop) DIV LineSpace;

   { Calc some more if they dont all fit on the first page }
   If (TotalNum > FirstFit) Then  Begin
      numOnPage := myPageV DIV LineSpace;
      { PagesDown = Page1 + Full pages required + last partial page }
      PagesDown := 1 + ((TotalNum - FirstFit - 1) Div NumOnPage);
   end;
end;
{$S SgPeInit}

END.
