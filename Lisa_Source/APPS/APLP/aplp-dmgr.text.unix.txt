

{-----------------------------------------------------------------------}
{                  Copyright 1983,1984, Apple Computer Inc.             }
{                                                                       }
{ Dialog Box Manager, adapted and extended from general dialog box      }
{ manager by Mark Cutter.                                               }
{                                                                       }
{ This unit provides some general routines that manipulate dialog boxes }
{ for PERT.  The format of the dialogs are read in from a file at init- }
{ alization of the program.  Routines are provided which read the data  }
{ from the file, display the dialog boxes, handle events when dialogs   }
{ are active and remove dialogs from the screen.                        }
{                                                                       }
{ Two kinds of dialogs are available, check boxes and editable fields.  }
{ Many of the routines are provided for both of these types of dialogs. }
{                                                                       }
{-----------------------------------------------------------------------}

{$S  }

UNIT PEDMgr;

INTERFACE
USES
   {$U UnitStd    }  UnitStd,    { The basics }
   {$U UnitHz     }  UnitHz,
   {$U libos/SysCall    }  SysCall,

   {$U QuickDraw  }  QuickDraw,
   {$U FontMgr    }  FontMgr,    { Fonts & LisaGraf }
   {$U Storage    }  Storage,

   {$U PmDecl     }  PmDecl,
   {$U Pmm        }  Pmm,

   {$U WM.Events  }  Events,     { The window manager }
   {$U WM.Folders }  Folders,
   {$U WM.Windows }  Windows,
   {$U WM.Menus   }  Menus,
   {$U wmlstd     }  WMlstd,
   {$U wmlsb      }  WMlsb,
   {$U wmlcrs     }  WMlcrs,
   {$U wmlgrow    }  WMlGrow,

   {$U AlertMgr   }  AlertMgr,
   {$U Dbenv      }  Dbenv,
   {$U scrap      }  Scrap,
   {$U fedec      }  fedec,
   {$U fld        }  fieldEdit, { Misc managers }

   {$U aplp/globals   }  PeGlobals;


{$IFC PESymbols}
{$D+}
{$ElseC}
{$D-}
{$EndC}


{-----------------------------------------------------------------------}
{                                                                       }
{ The extensions for editable field dialogs are built upon routines from}
{ Cutter's general Dmgr.  The file format allows input of initial       }
{ values into the fields.  This replaces the input of check item titles }
{ It is assumed that the first item read in is meant to be a yes-no     }
{ check box item.  The remaining items all all fields.                  }
{                                                                       }
{ One field editor field data structure is used for all the edit fields.}
{ It is created with a max length of 20 characters and on format and no }
{ grow capabilities with either.  Field to field movement is supported  }
{ with tab, return, shift-tab.  Arrow keys are not currently supported  }
{ but will be treated as tab and shift-tab when added. Double and triple}
{ clicks are also supported.                                            }
{                                                                       }
{-----------------------------------------------------------------------}

const
    maxCkItm   = 10;           { max number of items in a ckBox         }
    maxEdItm   = 40;           { max number of items in a edit field    }

type
    TStrHnd  = ^TStrPtr;
    TStrPtr  = ^Str255;

    TDBoxInfo  =
        record
            isOpen:      Boolean;       { is Dialog Box open?           }
            inData:      QDPtr;         { pointer to proper input data  }
            ProcessProc: ProcPtr;       { procedure to process events   }
            TrkMseProc:  ProcPtr;       { procedure to track cursor     }
            RestoreProc: ProcPtr;       { procedure to restore dialog   }
            EndProc:     ProcPtr;       { procedure to end dialog       }
        end;

    TCkItmHnd   = ^TCkItmPtr;
    TCkItmPtr   = ^TCkItmInfo;
    TCkItmLst   = Array[0..maxCkItm] of TCkItmHnd;
    TCkItmInfo  =
        record
            font:       Integer;        { font of ckBox item           }
            iTitle:     TStrHnd;        { name of ckBox item           }
            iLoc:       Point;          { location of start of iTitle  }
            hitBox:     Rect;           { actual hit box is bigger     }
            itmBox:     Rect;           { box that gets colored in     }
        end;

    TCkBoxHnd  = ^TCkBoxPtr;
    TCkBoxPtr  = ^TCkBoxInfo;
    TCkBoxLst  = Array[0..0] of TCkBoxHnd;
    TCkBoxInfo =
        record
            ckBoxId:    TB;             { logical index of ckBox       }
            numCkItm:   TB;             { number of items              }
            curOnOff:   TB;             { which on/off box is checked  }
            curCkItm:   TB;             { which item is checked        }
            hasOnOff:   Boolean;        { are items 1 and 2 special?   }
            ckItmLst:   TCkItmLst;      { ckItem list may be empty     }
            DrawProc:   ProcPtr;        { procedure to draw ckBox      }
            HitTstFunc: ProcPtr;        { function to hit test ckBox   }
        end;

    TCkFormHnd  = ^TCkFormPtr;
    TCkFormPtr  = ^TCkFormInfo;
    TCkFormInfo =
        record
            numCkBox: TB;               { number of ckBoxes in list    }
            vCkForm:  Integer;          { height of dialog box         }
            ckBoxLst: TCkBoxLst;        { list of ckBoxPtrs            }
        end;


    TEdItmHnd   = ^TEdItmPtr;
    TEdItmPtr   = ^TEdItmInfo;
    TEdItmLst   = Array[0..maxEdItm] of TEdItmHnd;
    TEdItmInfo  =
        record
            font:       Integer;        { font of EdField item         }
            iTitle:     TStrHnd;        { name of EdField item         }
            iLoc:       Point;          { location of start of ititle  }
            hitBox:     Rect;           { actual hit box is bigger     }
            idata:      hndData;        { actual field data record     }
            idataLen:   integer;        { length of field in chars     }
            iMaxLen:    integer;        { max length of field in chars }
            WasEdited:  boolean;        { has this field been edited   }
        end;

    TEdFldHnd  = ^TEdFldPtr;
    TEdFldPtr  = ^TEdFldInfo;
    TEdFldLst  = Array[0..0] of TEdFldHnd;
    TEdFldInfo =
        record
            EdFldId:    TB;             { logical index of EdFld       }
            numEdItm:   TB;             { number of items              }
            EdItmLst:   TEdItmLst;      { EdItem list may be empty     }
            DrawProc:   ProcPtr;        { procedure to draw EdFld      }
            HitTstFunc: ProcPtr;        { function to hit test EdFld   }
        end;

    TEdFormHnd  = ^TEdFormPtr;
    TEdFormPtr  = ^TEdFormInfo;
    TEdFormInfo =
        record
            numEdFld: TB;               { number of EdFields in list   }
            vEdForm:  Integer;          { height of dialog box         }
            EditInProgress: boolean;    { is there an edit in progress }
            edFld:    integer;          { the edFld index being edited }
            edItm:    integer;          { the edItm index being edited }
            loc:      point;            { the location of the edit     }
            CkBox:    TCkBoxHnd;        { always a do it, forget it box}
            EdFldLst: TEdFldLst;        { list of EdFldPtrs            }
        end;

var
    dmHz:       THz;                    { this units heap zone         }
    theDBox:    TDBoxInfo;              { the dialog box state data    }



    { ckBox dialog }
    procedure ReadCkBox    (var ckFile: Text; var info: TCkBoxHnd);
    procedure CkFormHeight (info: TCkFormHnd);
    procedure ShowCkBtn    (info: TCkBoxHnd);
    procedure ShowCkBox    (info: TCkBoxHnd);
    procedure ShowCkForm   (info: TCkFormHnd);
    function  CkBtnHit     (info: TCkBoxHnd; pt: Point;
                            var ckItm: Integer): Boolean;
    function  CkBoxHit     (info: TCkBoxHnd; pt: Point;
                            var ckItm: Integer): Boolean;
    procedure CkFormSelect (info: TCkFormHnd; var ckBox,ckItm: Integer);
    procedure GetCkHit     (thisEvent: EventRec);
    procedure TrkCkBoxMse  (msePt: Point);
    procedure RestoreCkForm;

    { miscellaneous }
    procedure InitDMgr     (hz: THz; font: Integer);
    procedure SetDFont     (font: Integer);
    procedure SetDBox      (inD: QDPtr; prcP,trkP,rstP,endP: ProcPtr);
    procedure ClearDBox;
    procedure RestoreDBox;
    procedure dmBlink;
    procedure dmDeActivate;

    { calling procs }
    procedure CallPrcsProc (thisEvent: EventRec; ProcessProc: ProcPtr);
    procedure CallTrkProc  (msePt: Point; TrkProc: ProcPtr);
    procedure CallRstProc  (RestoreProc: ProcPtr);
    procedure CallEndProc  (doItFlag: Boolean; EndProc: ProcPtr);
    procedure CallShowCkBox(info: TCkBoxHnd; ShowProc: ProcPtr);
    function  CallHitTst   (info: TCkBoxHnd; pt: Point;
                            var ckItm: Integer; HitFunc: ProcPtr): Boolean;

    { edFld dialog routines }
    procedure ReadEdFld    (var EdFile: Text; var info: TEdFldHnd);
    procedure EdFormHeight (info: TEdFormHnd);
    procedure ShowEdFld    (info: TEdFldHnd);
    procedure ShowEdForm   (info: TEdFormHnd);
    function  EdFldHit     (info: TEdFldHnd; pt: Point;
                            var hitEdItm: Integer): Boolean;
    procedure GetEdHit     (thisEvent: EventRec);
    procedure EdFormSelect (info: TEdFormHnd; var hitEdFld,hitEdItm: Integer;
                            var hitCheck: boolean; var ckItm: integer);
    procedure ExitEdit     (info: TEdFormHnd);
    procedure EdFldKeyProc (thisEvent: EventRec);
    procedure TrkEdFldMse  (msePt: point);
    procedure RestoreEdForm;





IMPLEMENTATION
{$IFC fsymok}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}
{$IFC fdbgok}
{$R+}
{$ELSEC}
{$R-}
{$ENDC}



var { DMgr Font info used in laying out ckBoxes, edit fields            }
    ascent:     Integer;        { ascent of the characters from base    }
    descent:    Integer;        { descent from baseline                 }
    lSpace:     Integer;        { height of "l", ascent + descent       }
    mSpace:     Integer;        { width of the character "m"            }
    lSpTop:     Integer;        { dist fm line top to ascender top      }
    offset:     Integer;        { baseLine := offset+row*lineSp         }

    { ckBox info }
    itmBoxSize: Rect;           { 2/3 ascent }

    { field editor vars for editing }
    dmHfstate:  hndfstate;      { handle to field state record          }
    dmHfield:   hndField;       { handle to field record                }

    {dmClickTime:  LongInt;}      { used to time double and triple clicks }
    {dmClickCount: integer;}      { used to count double and triple clicks}
    dmNbrHood:    rect;         { neighborhood around the down point    }
    dmCurTimeOut: integer;      { current time out for field editing    }


{-----------------------------------------------------------------------}
{                                                                       }
{ Dialog Box GuideLines                                                 }
{                                                                       }
{ The only kinds of events that can be gotten in the dialog folder are  }
{ keyDown, buttonDown, buttonUp, folderUpdate and nilEvent. Ignore      }
{ folderUpdate, since the only way to get it is thru a call to          }
{ DialogHeight, and it has a flag allowing you to specify if you want   }
{ it.  We never do.                                                     }
{                                                                       }
{-----------------------------------------------------------------------}


{-----------------------------------------------------------------------}
{                                                                       }
{ private utilities                                                     }
{                                                                       }
{-----------------------------------------------------------------------}

procedure OpenDBox(height: Integer);
{ Open the dialog box, set port, set cliprect, get height }

var thisPort: GrafPtr;

begin { OpenDBox }

    { get the port, set dialog height }
    GetPort(thisPort);
    if thisPort=dialogFolder then begin
        DialogHeight(height,false);
        theDBox.isOpen := true;
    end;

    { clear out space for dialog }
    FillRect(thisPort^.portRect,white);
    cliprect(thisport^.portrect);
end; { OpenDBox }

{-----------------------------------------------------------------------}

procedure SetCkItm(var itm: TCkItmHnd; c,r,f: Integer; title: String30);
{ create and init the check item with the vars passed in }

var dh,dv: Integer;
    thisTitle: TStrHnd;

begin { SetCkItm }

   { create the item and title }
   itm       := Pointer(Ord(HAllocate(dmHz,SizeOf(TCkItmInfo))));
   thisTitle := Pointer(Ord(HAllocate(dmHz,Length(title)+1)));

   with itm^^ do begin

      { set font of ckItm }
      font := f;

      { set name of ckItm }
      iTitle := thisTitle;
      MoveLeft(title,iTitle^^,Length(title)+1);

      { set starting point for text }
      dh := c*mSpace;
      dv := r*lSpace+offset;
      SetPt(iLoc,dh+2*mSpace,dv);

      { set itm ckBox }
      itmBox := itmBoxSize;
      OffSetRect(itmBox,dh,dv-itmBoxSize.bottom);

      { set hitBox }
      SetRect(hitBox,0,0,StringWidth(title)+3*mSpace,lSpace);
      OffsetRect(hitBox,dh-(mSpace div 2),dv-ascent-lSpTop);
   end; { with }
end; { SetCkItm }

{-----------------------------------------------------------------------}

procedure ScanCkBox(lineBuf: Str255; var c,r,f: Integer; var s: String30);
{ scan the linebuf from the file for the form data }

var bufIndx: Integer;
    digits: Set of Char;

{-----------------------------------------------------------------------}


function  GetInt: Integer;
{ get an integer from the line buffer }

var value: Integer; { value of the integer }

begin { GetInt }

   value := 0;
   while (bufIndx<=Length(lineBuf)) and
   not (lineBuf[bufIndx] in digits) do
       bufIndx := bufIndx+1;
   while (bufIndx<=Length(lineBuf)) and
   (lineBuf[bufIndx] in digits) do begin
      value := Ord(lineBuf[bufIndx])-Ord('0')+10*value;
      bufIndx := bufIndx+1;
   end;
   GetInt := value;
end; { GetInt }


{-----------------------------------------------------------------------}


procedure GetString(var thisStr: String30);
{ get a string from the line buffer }

var byteCnt: Integer;
    src: TStrPtr;

begin { GetString }

    thisStr := '';
    while (bufIndx<=Length(lineBuf)) and (lineBuf[bufIndx]<=' ') do
        bufIndx := bufIndx+1;
    byteCnt := Length(lineBuf)-bufIndx+2;
    if byteCnt>30 then
        byteCnt := 30;
    src := Pointer(Ord(@lineBuf)+bufIndx-1);
    MoveLeft(src^,thisStr,byteCnt);
    {$R-}
    thisStr[0] := Chr(byteCnt-1);
    {$R+}
end; { GetString }


{-----------------------------------------------------------------------}


begin { ScanCkBox }

   if lineBuf<>'' then begin
      digits := ['0'..'9'];
      bufIndx := 1;
      c := GetInt;
      r := GetInt;
      f := GetInt;
      GetString(s);
  end; { if }
end; { ScanCkBox }


{-----------------------------------------------------------------------}

procedure ReadCkItm(var f: Text; info: TCkBoxHnd; var noMore: Boolean);
{ read the check item data from the file }

var title: String30;
    c,r,font: Integer;
    lineBuf: Str255;
    thisItm: TCkItmHnd;  { temp handle to pass to SetCkItm }

begin { ReadCkItem }

   { see if standard CkBox or user defined }
   Readln(f,lineBuf);
   if lineBuf='' then
      noMore := TRUE
   else if info^^.numCkItm=maxCkItm then
      noMore := TRUE
   else begin
      noMore := FALSE;
      info^^.numCkItm := info^^.numCkItm+1;

      ScanCkBox(lineBuf,c,r,font,title);
      SetCkItm(thisItm,c,r,font,title);
      info^^.ckItmLst[info^^.numCkItm] := thisItm;
   end; { else }
end; { ReadCkItm }


{-----------------------------------------------------------------------}


procedure ShowCkItm(info: TCkItmHnd; showBox,boxChecked: Boolean);
{ show the check item in the dbox }

begin { ShowCkItem }

    if info<>nil then with info^^ do begin
        TextFont(font);
        with iLoc do
        MoveTo(h,v);
        DrawString(iTitle^^);
        if showBox then begin
            if boxChecked then
                FillRect(itmBox,black)
            else
                FrameRect(itmBox);
        end; { if }
    end; { if }
end; { ShowCkItm }


{-----------------------------------------------------------------------}


procedure SetEdItm(var itm: TEdItmHnd; c,r,f: Integer; strng: String30;
                   setTitle: boolean);
{ read and init the edit item data }

var theData: hndData;
    thetitle: TStrHnd;
    i: integer;

begin { SetEdItm }

   { get the item }
   itm := Pointer(Ord(HAllocate(dmHz,SizeOf(TEdItmInfo))));

   { set the font }
   itm^^.font := f;

   { is this the item title? }
   if SetTitle then begin
      { set title of edItm }
      theTitle := Pointer(Ord(HAllocate(dmHz,Length(strng)+1)));
      MoveLeft(strng,theTitle^^,Length(strng)+1);
      itm^^.ititle := theTitle;
   end
   else begin
      { set up initial field data }
      thedata := Pointer(Ord(Hallocate(dmHz,length(Strng)+1)));
      {$R-}
      for i := 0 to length(strng) - 1 do
          theData^^[i] := ord(strng[i+1]);
      {$R+}
      itm^^.idata := theData;
      itm^^.idataLen := Length(Strng);
      itm^^.iMaxLen  := length(Strng);
   end;

   { set starting location }
   SetPt(itm^^.iLoc,(c+2)*mSpace,r*lSpace);

   { set hitBox for item }
   SetRect(itm^^.hitBox,0,0,mSpace,lSpace);
   OffsetRect(itm^^.hitBox,0,r*lSpace-ascent-lSpTop);
end; { SetEdItm }


{-----------------------------------------------------------------------}

procedure ReadEdItm(var theFile: Text; info: TEdFldHnd; var noMore: Boolean);
{ read the edit item from the file }

var Strng: String30;
    c,r,f: Integer;
    lineBuf: Str255;
    myEditmHnd: TEditmHnd;

begin { ReadEdItm }

    { see if standard EdFld or user defined }
    Readln(theFile,lineBuf);
    if lineBuf='' then
        noMore := true
    else begin
        noMore := false;
        with info^^ do numEdItm := numEdItm+1;
        ScanCkBox(lineBuf,c,r,f,strng);

        { Assign into local handle, then assign that handle to final spot }
        SetEdItm(myEditmHnd, c, r, f, strng, info^^.numEdItm=0);
        with info^^ do edItmLst[numEditM] := myEditmHnd;
    end;
end; { ReadEdItm }

{-----------------------------------------------------------------------}

procedure ShowEdItm(info: TEdItmHnd; showfield: Boolean);
{ display the edit item in the dbox }

var errnum: integer;

begin { ShowEdItm }

   if info<>nil then
       if not showfield then begin
           { show the title }
           TextFont(info^^.font);
           MoveTo(info^^.iLoc.h,info^^.iLoc.v);
           DrawString(info^^.iTitle^^);
       end { if }
       else begin
           dmHfield^^.curlen := info^^.idataLen;
           dmHfield^^.maxlen := info^^.iMaxlen;
           dmHfield^^.curvalue := info^^.idata;
           SetRunFormat( dmHfield, nil, info^^.font, SetFont, errnum);
           MoveField(dmHfield, nil, info^^.iLoc);
           DrawFldAt(dmHfield, nil, info^^.iLoc, false, false);
           { save coords rect as hit box }
           info^^.HitBox := dmHfield^^.coords;
       end; { else }
end; { ShowEdItm }

{-----------------------------------------------------------------------}
{                                                                       }
{ ckBox dialog public routines                                          }
{                                                                       }
{-----------------------------------------------------------------------}

{-----------------------------------------------------------------------}
{                                                                       }
{ File Format for Forms                                                 }
{                                                                       }
{ From the file is input the format of the form, the number of fields,  }
{ the text strings associated with each field, the font of the text,    }
{ and the position of the field in the dialog box.  The first check box }
{ is assumed to be the cancel-ok buttons.  You cannot mix check boxes   }
{ with editiable fields in one form.   The format for a check box item  }
{ is the following:                                                     }
{                                                                       }
{    check box number                                                   }
{    h location,  v location,  font,  title      (for item number 1)    }
{         "           "          "      "        (for item number 2)    }
{                                                                       }
{ For example, the file                                                 }
{                                                                       }
{    0                                                                  }
{    0   1                                                              }
{    0   1 0 Cancel                                                     }
{    0   1 0 OK                                                         }
{                                                                       }
{    1                                                                  }
{    0   1 8 Early Start                                                }
{    9   1 7 On                                                         }
{    13  1 7 Off                                                        }
{                                                                       }
{    2                                                                  }
{    17  1 8 Early Finish                                               }
{    27  1 7 On                                                         }
{    31  1 7 Off                                                        }
{                                                                       }
{    3                                                                  }
{    0   3 8 Late Start                                                 }
{    9   3 7 On                                                         }
{    13  3 7 Off                                                        }
{                                                                       }
{    4                                                                  }
{    17  3 8 Late Finish                                                }
{    27  3 7 On                                                         }
{    31  3 7 Off                                                        }
{                                                                       }
{ creates a dialog check form with four check boxes with an on and off  }
{ item for each.  The buttons are in the system font and dont need a    }
{ h and v offset.  The box titles are in a p10tile with the item titles }
{ in a p15tile font.                                                    }
{                                                                       }
{ The difference between the check form file format and the edit field  }
{ form format is slight.  The check item titles become initial values   }
{ for the fields.  For example:                                         }
{                                                                       }
{    0                                                                  }
{    0   1                                                              }
{    0   1 0 Cancel                                                     }
{    0   1 0 OK                                                         }
{                                                                       }
{    0                                                                  }
{    5   2 8 Start task no earlier than:                                }
{    25  2 8 mm/dd/yy                                                   }
{                                                                       }
{    1                                                                  }
{    5   4 8 Finish task no later than:                                 }
{    25  4 8 mm/dd/yy                                                   }
{                                                                       }
{  creates a form with two fields each with initial field strings of    }
{  'mm/dd/yy' in the p10tile font.                                      }
{                                                                       }
{-----------------------------------------------------------------------}

{$S SgPeInit}


    procedure ReadCkBox{ var ckFile: Text; var info: TCkBoxHnd };
    var noMore: Boolean;
        i: Integer;
    begin
        SetPort(dialogFolder);
        info := Pointer(Ord(HAllocate(dmHz,SizeOf(TCkBoxInfo))));
        with info^^ do begin
            { init ckBox }
            numCkItm   := -1;
            curOnOff   := -1;
            curCkItm   := -1;
            hasOnOff   := FALSE;
            DrawProc   := nil;
            HitTstFunc := nil;
            for i := 0 to maxCkItm do
                ckItmLst[i] := nil;
        end;

        { read in ckBox info }
        ReadLn(ckFile,info^^.ckBoxId);
        repeat
            ReadCkItm(ckFile,info,noMore);
        until noMore;

        with info^^ do begin
            { see if standard ckBox }
            if numCkItm>0 then with ckItmLst[0]^^ do begin
                { get ckBox hitBox size }
                for i := 1 to numCkItm do
                    UnionRect(hitBox,ckItmLst[i]^^.hitBox,hitBox);
                { set standard Draw and Choose procs }
                DrawProc   := @ShowCkBox;
                HitTstFunc := @CkBoxHit;
            end;
        end;
    end; { ReadCkBox }

{-----------------------------------------------------------------------}

    procedure CkFormHeight{ info: TCkFormHnd };
    var thisHeight,height: Integer;
        i,j,bh,bv: Integer;
    begin
        height := 0;
        with info^^ do begin
            for i := 0 to numCkBox do begin
                {$R-}
                thisHeight := ckBoxLst[i]^^.ckItmLst[0]^^.hitBox.bottom;
                {$R+}
                if thisHeight>height then
                    height := thisHeight;
            end;
            bh := CalcButWidth(0,1,bv);
            { use MaxInt }
            bh := height+Round(lSpace/2);
            bv := 2*bv+30;
            if bh>bv then
                vCkForm := bh
            else
                vCkForm := bv;

        end;
    end; { CkFormHeight }

{-----------------------------------------------------------------------}

{$S  }

    procedure ShowCkBtn{ info: TCkBoxHnd };
    var i,bh,bv: Integer;
        boxChecked: Boolean;
        vLoc: Array[0..1] of Integer;
    begin
        if info=nil then
            {$IFC PEDebug}
            writeln('DMgrError--ShowCkBtn info is nil.')
            {$EndC}
        else with info^^ do begin
            { show the button title }
            ShowCkItm(ckItmLst[0],FALSE,FALSE);

            { show two buttons }
            bh := CalcButWidth(0,1,bv);
            with dialogFolder^.portRect do begin
                vLoc[0] := top+10;
                vLoc[1] := bottom-bv-10;
                for i := 0 to 1 do begin
                    HideButn(i);
                    PushButn(i,FALSE);
                    ShowButn(i,right-20-bh,vLoc[i],{false}(i=0));
                end;
            end;
        end;
    end; { ShowCkBtn }

{-----------------------------------------------------------------------}

    procedure ShowCkBox{ info: TCkBoxHnd };
    var i: Integer;
        boxChecked: Boolean;
    begin
        if info=nil then
            {$IFC PEDebug}
            writeln('DMgrError--ShowCkBox info is nil.')
            {$ENDC}
        else with info^^ do
            for i := 0 to numCkItm do begin
                boxChecked := (i=curOnOff) or (i=curCkItm);
                ShowCkItm(ckItmLst[i],i<>0,boxChecked);
            end;
    end; { ShowCkBox }

{-----------------------------------------------------------------------}

    procedure ShowCkForm{ info: TCkFormHnd };
    var i: Integer;
        thisPort: GrafPtr;
    begin
        OpenDBox(info^^.vCkForm);
        with info^^ do begin
            for i := 0 to numCkBox do
                {$R-}
                CallShowCkBox(ckBoxLst[i],ckBoxLst[i]^^.DrawProc);
                {$R+}
        end;
    end; { ShowCkForm }

{-----------------------------------------------------------------------}

    function  CkBtnHit{ info: TCkBoxHnd; pt: Point;
                        var ckItm: Integer): Boolean };
    var pushed: TButn;
    begin
        CkBtnHit := ButnPushed(0,1,pushed,pt);
        ckItm := pushed+1;
    end; { CkBtnHit }

{-----------------------------------------------------------------------}

    function  CkBoxHit{ info: TCkBoxHnd; pt: Point;
                        var ckItm: Integer): Boolean };
    var hit: Boolean;
        i: Integer;
    begin
        ckItm := 0;
        hit := PtInRect(pt,info^^.ckItmLst[0]^^.hitBox);
        if hit then with info^^ do begin
            for i := 1 to numCkItm do
                if PtInRect(pt,ckItmLst[i]^^.hitBox) then begin
                    ckItm := i;
                    i := numCkItm;
                end;
        end;
        CkBoxHit :=  hit;
    end; { CkBoxHit }

{-----------------------------------------------------------------------}

    procedure CkFormSelect{ info: TCkFormHnd; var ckBox,ckItm: Integer };
    var msePt: Point;
        oldCkItm,i: Integer;
        thisRect: Rect;
        thisEvent: EventRecord;
    begin
        { assumes port is already set }
        {repeat}
            { do nothing }
        {until not StillDown;}
        GetMouse(msePt);
        { get rid of buttonUp event }
        {if PeekEvent(thisEvent) then begin
            if thisEvent.what=buttonUp then begin
                GetEvent(thisEvent);
                msePt := thisEvent.where;
            end;
        end;}
        ckBox := 0;
        with info^^ do
        for i := 0 to numCkBox do begin
            {$R-}
            if CallHitTst(ckBoxLst[i],msePt,
                          ckItm,ckBoxLst[i]^^.HitTstFunc) then
            with ckBoxLst[i]^^ do begin
                ckBox := ckBoxId;
                i := numCkBox;
                if ckBox>0 then
                    if ckItm>0 then begin
                        { figure out which item was checked }
                        if hasOnOff and (ckItm<=2) then begin
                            oldCkItm := curOnOff;
                            curOnOff := ckItm;
                        end else begin
                            oldCkItm := curCkItm;
                            curCkItm := ckItm;
                        end;
                        { clear old item }
                        if oldCkItm>0 then begin
                            thisRect := ckItmLst[oldCkItm]^^.itmBox;
                            InSetRect(thisRect,1,1);
                            FillRect(thisRect,white);
                        end;
                        { fill new item }
                        FillRect(ckItmLst[ckItm]^^.itmBox,black);
                    end;
            end;
            {$R+}
        end;
    end; { CkFormSelect }

{-----------------------------------------------------------------------}

    procedure GetCkHit{ thisEvent: EventRec };
    var info: TCkFormHnd;
        ckBox,ckItm: Integer;
    begin
        if thisEvent.what=buttonDown then with theDBox do begin
            info := Pointer(Ord(inData));
            CkFormSelect(info,ckBox,ckItm);
            if (ckBox=0) and (ckItm<>0)  then
                CallEndProc(ckItm=2,endProc)
        end;
    end; { GetCkHit }

{-----------------------------------------------------------------------}

    procedure TrkCkBoxMse{ msePt: Point };
    var info:     TCkFormHnd;
        i,j,
        ckItm:    Integer;
        inCkItm:  Boolean;
        nHood:    Rect;
        icrs:     TC;

    begin
        { assumes port is already set }
        icrs := icrsInactive;
        info := Pointer(Ord(theDBox.inData));
        with info^^ do begin
           GetMouse(msePt);
           if not PtInRect( msePt, dialogfolder^.portrect) then {}
           else begin
               { check for a hit on a ckbox }
               inCkItm := FALSE;
               for i := 1{0} to numCkBox do
                   {$R-}
                   if CkBoxHit(ckBoxLst[i],msePt,ckItm) then begin
                       nHood := ckBoxLst[i]^^.ckItmLst[ckItm]^^.hitBox;
                       i := numCkBox;
                       inCkItm := ckItm<>0;
                   end;
                   {$R+}
               if inCkItm then icrs := icrsCheck;
           end;
       end;
       SetStdCursor(icrs);
    end; { TrkCkBoxMse }


{-----------------------------------------------------------------------}

    procedure RestoreCkForm;
    var info: TCkFormHnd;
    begin
        info := Pointer(Ord(theDBox.inData));
        ShowCkForm(info);
    end; { RestoreCkForm }


{-----------------------------------------------------------------------}

{ edit field public routines }

{-----------------------------------------------------------------------}

{$S SgPeInit}

    procedure ReadEdFld{ var EdFile: Text; var info: TEdFldHnd };
    var noMore: Boolean;
        i: Integer;
    begin
        info := Pointer(Ord(HAllocate(dmHz,SizeOf(TEdFldInfo))));
        with info^^ do begin
            { init EdFld }
            numEdItm   := -1;
            DrawProc   := nil;
            HitTstFunc := nil;
            for i := 0 to maxEdItm do EdItmLst[i] := nil;
            { read in EdFld info }
            ReadLn(EdFile,EdFldId);
         end;

         repeat
             ReadEdItm(EdFile,info,noMore);
         until noMore;

         with info^^ do begin
            { see if standard edFld }
            if numEdItm>0 then with EdItmLst[0]^^ do begin
                { get edFld hitBox size }
                for i := 1 to numEdItm do
                    UnionRect(hitBox,edItmLst[i]^^.hitBox,hitBox);
                { set standard Draw and Choose procs }
                DrawProc   := @ShowEdFld;
                HitTstFunc := @EdFldHit;
            end;
        end;
    end; { ReadEdFld }

{-----------------------------------------------------------------------}


    procedure EdFormHeight{ info: TEdFormHnd };
    var thisHeight,height: Integer;
        i,j: Integer;
    begin
        height := 0;
        with info^^ do begin
            for i := 0 to numEdFld do begin
                {$R-}
                thisHeight := EdFldLst[i]^^.EdItmLst[0]^^.hitBox.bottom;
                {$R+}
                if thisHeight > height then
                    height := thisHeight;
            end;
            vEdForm := height+Round(lSpace/2);
        end;
    end; { EdFormHeight }

{-----------------------------------------------------------------------}

{$S  }

    procedure ShowEdFld{ info: TEdFldHnd };
    var i: Integer;
        boxChecked: Boolean;
    begin
        if info=nil then
            {$IFC PEDebug}
            writeln('DMgrError--ShowEdFld info is nil.')
            {$ENDC}
        else with info^^ do begin
            for i := 0 to numEdItm do
                ShowEdItm(EdItmLst[i],i<>0);
            if numEdItm>0 then with EdItmLst[0]^^ do
                { get edFld hitBox size }
                for i := 1 to numEdItm do
                    UnionRect(hitBox,edItmLst[i]^^.hitBox,hitBox);
        end;
    end; { ShowEdFld }

{-----------------------------------------------------------------------}

    procedure ShowEdForm{ info: TEdFormHnd };
    var i,
        errnum: Integer;
        thisPort: GrafPtr;
    begin
        OpenDBox(info^^.vEdForm);
        CallShowCkBox(info^^.CkBox,info^^.CkBox^^.DrawProc);
        {$R-}
        for i := 0 to info^^.numEdFld do
            CallShowCkBox(Pointer(Ord(info^^.EdFldLst[i])),info^^.EdFldLst[i]^^.DrawProc);

        { set up first item as all selected }
        info^^.EditInProgress := true;
        info^^.edFld := 0;
        info^^.edItm := 1;
        with info^^.EdFldLst[info^^.edFld]^^.EdItmLst[info^^.edItm]^^ do begin
           dmHfield^^.curlen := idataLen;
           dmHfield^^.maxlen := iMaxlen;
           dmHfield^^.curvalue := idata;
           SetRunFormat( dmHfield, nil, font, SetFont, errnum);
           WasEdited := true;
           info^^.loc := iLoc;
           MoveField( dmHfield, nil, info^^.loc );
           InitFstate( dmHfield, dmHfstate);
           SelectAll( dmHfield, dmHfstate, dmCurtimeOut);
        end;
        {$R+}
    end; { ShowEdForm }

{-----------------------------------------------------------------------}

    function  EdFldHit{ info: TEdFldHnd; pt: Point;
                        var hitEdItm: Integer): Boolean };
    var hit: Boolean;
        i: Integer;
    begin
        hitEdItm := 0;
        hit := PtInRect(pt,info^^.edItmLst[0]^^.hitBox);
        if hit then with info^^ do begin
            for i := 1 to numEdItm do
                if PtInRect(pt,edItmLst[i]^^.hitBox) then begin
                    hitEdItm := i;
                    i := numEdItm;
                end;
        end;
        EdFldHit :=  hit;
    end; { EdFldHit }

{-----------------------------------------------------------------------}

    procedure EdFormSelect { info: TEdFormHnd; var hitEdFld,hitEdItm: Integer;
                            var hitCheck: boolean; var ckItm: integer };
    var oldCkItm,i: Integer;
        thisRect:   Rect;
        thisEvent:  EventRecord;
        downpt,
        MovePt:     point;
        errnum:     integer;
    begin
        { assumes port is already set }
        GetMouse(downpt);
        hitEdFld := 0;
        hitEdItm := 0;
        hitCheck := false;
        ckItm := 0;
        {$R-}
        { check for hit on fields }
        for i := 0 to info^^.numEdFld do with info^^ do begin
            if CallHitTst(Pointer(Ord(EdFldLst[i])),downpt,
                          hitEdItm,EdFldLst[i]^^.HitTstFunc) then begin
                hitEdFld := i;
                i := numEdFld;
                { set up for edit }
                if hitEdItm<>0 then begin
                    EditInProgress := true;
                    edFld := hitEdFld;
                    edItm := hitEdItm;
                    with EdFldLst[edFld]^^.EdItmLst[edItm]^^ do begin
                       dmHfield^^.curlen := idataLen;
                       dmHfield^^.maxlen := iMaxlen;
                       dmHfield^^.curvalue := idata;
                       SetRunFormat( dmHfield, nil, font, SetFont, errnum);
                       WasEdited := true;
                       loc := iLoc;
                       MoveField( dmHfield, nil, loc );
                       InitFstate( dmHfield, dmHfstate);
                       Select( downpt, dmHfield, dmHfstate,
                            DmNbrhood, DmCurTimeOut);
                    end; { with }
                end; { if }
            end; { if }
        end; { for }

        if info^^.editInProgress then with info^^ do begin
            If StillDown then begin
                setRect( dmNbrHood, downPt.h - 3, downpt.v - 2,
                    downpt.h + 3, downpt.v + 2);
                While StillDown do begin
                    GetMouse(MovePt);
                    if not PtinRect(MovePt, DmNbrhood) then begin
                        GrowSel(Movept, dmHfield, dmHfstate, DmNbrhood);
                        setRect( dmNbrHood, MovePt.h - 3, Movept.v - 2,
                            Movept.h + 3, Movept.v + 2);
                    end; { if }
                end; { while }
            end; { if }
        end { if }

        { otherwise check for hit on the dolt- GoAway boxes }
        else if CallHitTst(info^^.ckBox,downpt,
                  ckItm,info^^.ckBox^^.HitTstFunc) then with info^^ do begin
            with ckBox^^ do begin
                hitCheck := true;
                if ckItm>0 then begin
                    { figure out which item was checked }
                    if hasOnOff and (ckItm<=2) then begin
                        oldCkItm := curOnOff;
                        curOnOff := ckItm;
                    end else begin
                        oldCkItm := curCkItm;
                        curCkItm := ckItm;
                    end;
                    { clear old item }
                    {if oldCkItm>0 then begin
                        thisRect := ckItmLst[oldCkItm]^^.itmBox;
                        InSetRect(thisRect,1,1);
                        FillRect(thisRect,white);
                    end;}
                    { fill new item }
                    {FillRect(ckItmLst[ckItm]^^.itmBox,black);}
                end; { if }
            end; { with }
        end; { else }
        {$R+}
    end; { EdFormSelect }

{-----------------------------------------------------------------------}

    Procedure ExitEdit{ info: TEdFormHnd };
    begin
        { deselect any item current under edit }
         if info^^.EditInProgress then begin
             ExitField(dmHfield, dmHfstate);
             {$R-}
             with info^^ do with EdFldLst[edFld]^^.EdItmLst[edItm]^^ do begin
                 idataLen := dmHfield^^.curlen;
                dmHfield^^.curvalue := nil;
                dmHfield^^.curlen := 0;
                dmHfield^^.maxlen := 0;
                edFld := 0;  edItm := 0;
             end;
             {$R+}
         end;
         info^^.editInProgress := false;
    end; { ExitEdit }

{-----------------------------------------------------------------------}

    procedure GetEdHit{ thisEvent: EventRec };
    var info: TEdFormHnd;
        theEdFld,theEdItm: Integer;
        hitCheck: boolean;
        ckItm: integer;
    begin
        if thisEvent.what=buttonUp then begin
            {dmClickTime:=thisEvent.when + clickDelay;} {50}  { 1/2 second }
            info := Pointer(Ord(theDBox.indata));
            if info^^.editinprogress then ObscureCursor;
        end;

        if thisEvent.what=buttonDown then
        with theDBox do begin

            { count clicks }
            {if thisEvent.when < dmClickTime  then dmClickCount:=dmClickCount+1
            else dmClickCount:=1;}
            info := Pointer(Ord(inData));
            with info^^ do begin
               if (ClickCount = 2) and (editInProgress) then begin
                   SelectWord(thisEvent.where,dmHfield,dmHfstate, DmNbrhood,
                   DmCurTimeOut);
                   DrawField(dmHfield, dmHfstate,  true, true);
               end
               else begin
                   if (ClickCOunt > 2) and (editInProgress) then begin
                      ExitField(dmHfield,dmHfstate);
                      SelectAll(dmHfield,dmHfstate,DmCurTimeOut);
                   end
                   else begin
                       ExitEdit(info);
                       EdFormSelect(info,theEdFld,theEdItm, hitCheck, ckItm);
                       { if selected the do it - forget it check box call end }
                       if (hitCheck) and (ckItm<>0) then
                       CallEndProc(ckItm=2,endProc);
                   end;
               end;
            end;
        end;
    end; { GetEdHit }

{-----------------------------------------------------------------------}

    procedure TrkEdFldMse{ msePt: point };
    var info:    TEdFormHnd;
        i,
        Itm:     integer;
        inEdItm,
        inCkItm: boolean;
        nHood:   rect;
        icrs:    TC;

    begin
       info := Pointer(Ord(theDBox.inData));
       icrs := icrsInactive;
       with info^^ do begin
           GetMouse(msePt);
           if not PtInRect( msePt, dialogFolder^.portrect) then {}
           else begin
              { check for hit on check boxes }
              inCkItm := false;
              inEdItm := false;
              if CkBoxHit(ckBox,msePt,Itm) then begin
                  nHood := ckBox^^.ckItmLst[Itm]^^.hitBox;
                  inCkItm := Itm<>0;
              end;
              { no hit, check for hit on field items }
              if not inCkItm then
                  for i := 0 to numEdFld do
                      {$R-}
                      if EdFldHit(edFldLst[i],msePt,Itm) then begin
                          nHood := edFldLst[i]^^.EdItmLst[Itm]^^.hitBox;
                          i := numEdFld;
                          inEdItm := Itm<>0;
                      end;
                      {$R+}
              if inEdItm or inCkItm then begin
                  if inEditm then icrs := icrsIbeam;
              end;
          end;
       end; { with }
       SetStdCursor(icrs);

    end; { TrkEdFldMse }

{-----------------------------------------------------------------------}


    procedure EdFldKeyProc { thisEvent: EventRec };
    { currently ignoring arrow keys, eventually will treat just as
       tab and shift-tabs. }

    var errnum,
        i,
        hitEdItm,
        hitEdFld:   integer;
        info:       TEdFormHnd;
        key:        char;
        Hit:        boolean;
    begin
        with theDBox do begin
            info := Pointer(Ord(inData));
            if info^^.EditInProgress then begin

                key := thisEvent.ascii;
                case ord(key) of

                   ArwUp,
                   ArwDown,
                   ArwRight,
                   ArwLeft: begin
                      { ignore these keys for now }
                   end;

                   Clear: begin
                      ClearField( dmHfield, dmHfstate, errnum);
                      {$R-}
                      with info^^ do with EdFldLst[edFld]^^.EdItmLst[edItm]^^ do
                      DrawFldAt(dmHfield, dmHfstate, iLoc, true, true);
                      {$R+}
                   end;

                   return,
                   tabKey: begin
                      hitEdFld := info^^.EdFld;
                      hitEdItm := info^^.EdItm;
                      ExitEdit(info);

                      Hit := true;
                      {$R-}
                      if (ord(Key)=tabKey) and (thisEvent.shiftkey) then begin
                         hitEdItm := hitEdItm - 1;
                         if hitEdItm <= 0 then begin
                            hitEdFld := hitEdFld - 1;
                            if hitEdFld < 0 then begin
                               { off the end, nothing for now }
                               hit := false;
                            end
                            else hitEdItm := info^^.EdFldLst[HitEdFld]^^.NumEdItm;
                         end;
                      end
                      else begin
                         hitEdItm := hitEditm + 1;
                         if hitEdItm > info^^.EdfldLst[hitEdFld]^^.numEdItm then begin
                            hitEdFld := hitEdFld + 1;  hitEdItm := 1;
                            if hitEdFld > info^^.numEdFld then begin
                               { off the end, nothing for now }
                               Hit := false;
                            end;
                         end;
                      end;
                      {$R+}

                      if hit then with info^^ do begin
                          EditInProgress := true;
                          edFld := hitEdFld;
                          edItm := hitEdItm;
                          {$R-}
                          with EdFldLst[edFld]^^.EdItmLst[edItm]^^ do begin
                             dmHfield^^.curlen := idataLen;
                             dmHfield^^.maxlen := iMaxlen;
                             dmHfield^^.curvalue := idata;
                             WasEdited := true;
                             loc := iLoc;
                             MoveField( dmHfield, nil, loc );
                             SelectAll( dmHfield, dmHfstate, DmCurTimeOut);
                          end;
                          {$R+}
                       end;
                   end;

                   enter: begin
                      { enter and stay }
                      ExitField(dmHfield, dmHfstate);
                      SelectAll(dmHfield, dmHfstate, dmCurTimeOut);
                   end;

                   Bspace: begin
                      BackSpace(dmHfield, dmHfstate, errnum);
                      {$R-}
                      with info^^ do with EdFldLst[edFld]^^.EdItmLst[edItm]^^ do
                      DrawFldAt(dmHfield, dmHfstate, iLoc, true, true);
                      {$R+}
                   end;

                   otherwise begin
                      InsCh (thisEvent.ascii, dmHfield, dmHfstate, errnum);
                      {$R-}
                      with info^^ do with EdFldLst[edFld]^^.EdItmLst[edItm]^^ do
                      DrawFldAt(dmHfield, dmHfstate, iLoc, true, true);
                      {$R+}
                   end;
                end; { case }
            end; { if }
        end;
    end; { EdFldKeyProc }

{-----------------------------------------------------------------------}

    procedure RestoreEdForm;
    var info: TEdFormHnd;
    begin
        info := Pointer(Ord(theDBox.inData));
        ShowEdForm(info);
    end; { RestoreEdForm }


{-----------------------------------------------------------------------}


Procedure dmBlink;
{ Blinking the caret was added as a bug fix close to shipment of
  the product.  As a result, it was added on in the simplest way
  possible, and not necessarily the best way. }
var info: TEdFormHnd;
begin
   with theDBox do begin
      if EdFldBox then begin
         info := Pointer(Ord(inData));
         if info^^.EditInProgress then begin
            BlinkCaret(dmHfield, dmHfstate, dmCurTimeOut);
         end; { if }
      end; { if }
   end;
end;

{-----------------------------------------------------------------------}


Procedure dmDeActivate;
{ called on a deactivate event if msgon is true. }
var info: TEdFormHnd;
begin
   with theDBox do begin
      if EdFldBox then begin
         info := Pointer(Ord(inData));
         if info^^.EditInProgress then begin
            ExitEdit(info);
         end; { if }
      end; { if }
   end;
end;

{-----------------------------------------------------------------------}

{-----------------------------------------------------------------------}

{ miscellaneous }

{-----------------------------------------------------------------------}

{$S SgPeInit}

    procedure InitDMgr{ hz: THz; font: Integer };
    const
        curLen      = 10;
        growLen     = 0;
        padding     = 8;
        ifmts       = 1;
        gfmts       = 0;
        protect     = false;
    var
        nilRect:    rect;
    begin
        dmHz := hz;
        theDBox.isOpen := FALSE;
        SetDFont(font);
        { create field vars for field edits }
        dmHfstate := Pointer(Ord(HAllocate(dmHz, SizeOf(fieldState))));
        SetRect( nilRect, 0,0,0,0 );
        dmHfield := CreateField( nilRect, curLen, growLen, Left, padding,
           ifmts, gfmts, font, protect );
        {dmClickCount := 0;}
        {dmClickTime := 0;}
    end; { InitDMgr }

{-----------------------------------------------------------------------}


    procedure SetDFont{ font: Integer };
    var errNum:Integer;
        fInfo: FontInfo;
        fid:   TLFntId;
    begin
        SetPort(dialogFolder);
        TextFont(font);
        TextFace([]);
        fid.fam := font;
        fid.seteface := [];
        fid.dev := devScreen;
        { get font info used in reading ckForms }
        if not FmFontMetrics(fid,fInfo,errNum) then begin
            {$IFC PEDEbug}
            writeln('DMgr Error -- SetDFont can''t find font');
            {$ENDC}
            Halt;
        end else begin
            ascent  := fInfo.ascent;
            descent := fInfo.descent;
            lSpace  := fInfo.ascent+fInfo.descent+fInfo.leading;
            mSpace  := CharWidth('m');
            lSpTop  := Round((lSpace-ascent-descent)/2);
            offset  := lSpTop+ascent-Round(lSpace/2);
            { ckBox vars }
            SetRect(itmBoxSize,0,0,(3*ascent) div 2,ascent);
        end;
    end; { SetDFont }

{-----------------------------------------------------------------------}

{$S  }

    procedure SetDBox{ inD: QDPtr; prcP,trkP,rstP,endP: ProcPtr };
    begin
        with theDBox do begin
            inData      := inD;
            processProc := prcP;
            trkMseProc  := trkP;
            restoreProc := rstP;
            endProc     := endP;
        end;
    end; { SetDBox }

{-----------------------------------------------------------------------}

    procedure ClearDBox;
    begin
        with theDBox do begin
            if isOpen then
                DialogHeight(0,False)
            else begin
                {$IFC PEDebug}
                writeln('DMgrError: ClearDBox--theDBox not open.')
                {$ENDC}
                end;
            isOpen := FALSE;
        end;
    end; { ClearDBox }

{-----------------------------------------------------------------------}

    procedure RestoreDBox;
    begin
        with theDBox do
        if isOpen then begin
            SetPort(dialogFolder);
            CallRstProc(restoreProc);
        end;
    end; { RestoreDBox }

{-----------------------------------------------------------------------}



{-----------------------------------------------------------------------}


{-----------------------------------------------------------------------}

    procedure CallPrcsProc { thisEvent: EventRec; ProcessProc: ProcPtr };
        external;

    procedure CallTrkProc  { msePt: Point; TrkProc: ProcPtr };
        external;

    procedure CallRstProc  { RestoreProc: ProcPtr };
        external;

    procedure CallEndProc  { doItFlag: Boolean; EndProc: ProcPtr };
        external;

    procedure CallShowCkBox{ info: TCkBoxHnd; ShowProc: ProcPtr };
        external;

    function  CallHitTst   { info: TCkBoxHnd; pt: Point;
                              var ckItm: Integer; HitFunc: ProcPtr): Boolean };
        external;

END. { unit }


