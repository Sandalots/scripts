

{------------------------------------------------------------------------------}
{                  Copyright 1983,1984, Apple Computer Inc.                    }
{                                                                              }
{   Pert control routines, drawing and events.                                 }
{                                                                              }
{ The entire pert chart is redrawn by calling DrawPert.  DrawTask is used to   }
{ redraw just one task record and no links, for drawing one task in the scrap. }
{                                                                              }
{ The event handles, up, down, key, deselect handle these events for the pert  }
{ chart only and should only be called when pert is the active chart.          }
{                                                                              }
{------------------------------------------------------------------------------}


UNIT PEPert;



INTERFACE
USES
   {$U UnitStd    }  UnitStd,    { The basics }
   {$U UnitHz     }  UnitHz,
   {$U LibOs/SysCall    }  SysCall,

   {$U QuickDraw  }  QuickDraw,
   {$U FontMgr    }  FontMgr,    { Fonts & LisaGraf }
   {$U Storage    }  Storage,
   {$U GrafUtil   }  GrafUtil,

   {$U PmDecl     }  PmDecl,
   {$U Pmm        }  Pmm,

   {$U WM.Events  }  Events,     { The window manager }
   {$U WM.Folders }  Folders,
   {$U WM.Windows }  Windows,
   {$U WM.Menus   }  Menus,
   {$U wmlstd     }  WMlstd,
   {$U wmlsb      }  WMlsb,
   {$U wmlcrs     }  WMlcrs,
   {$U wmlgrow    }  WMlGrow,

   {$U PrStdInfo  }  PrStdInfo,
   {$U PrPublic   }  PrPublic,

   {$U AlertMgr   }  AlertMgr,
   {$U Dbenv      }  Dbenv,
   {$U scrap      }  Scrap,
   {$U fedec      }  fedec,
   {$U fld        }  fieldEdit,  { Misc managers }

   {$U aplp/Globals  }  PEGlobals,
   {$U aplp/general  }  PEGeneral,

   {$U fplib      }  fplib;      { And floating point }


{$IFC PESymbols}
{$D+}
{$ElseC}
{$D-}
{$EndC}


{ schedule calculations }
Procedure CalcSchedule;
Procedure UnSchedule;

{ Pert data handlers }
procedure DeleteArrow   (fromtask, totask: hTask);
Procedure RemoveTask    (task: hTask);
Function  addarrow      (taskfrom, taskto: hTask): boolean;
procedure addtask       (task: hTask);
Procedure MoveTask      (task: hTask; var newloc: rect);

{ hit test routines }
Function  HitTestPert   (var MsePt: point; Tracking: boolean; var HitTask: boolean;
                         var perimeter: boolean; var TaskFrom: htask; var TaskTo: htask): boolean;
Function  KnobHit       (task: hTask; oldmouse: point): tknob;

{ event routines }
Procedure NormVMS       (var theOval: Rect);
Procedure NormHMS       (var theOval: Rect);
Procedure EditCheckDur  (resc: hResc; var value: integer; var Ok: boolean);
Procedure RestoreOldVa  (resc: hResc);
Procedure RestoreTitle  (line: hText; htaskfield: hndfield);
Procedure RestDuration  (curresc: hResc; htaskfield: hndfield);
Procedure XRestoreResc   (curresc: hResc; htaskfield: hndfield);
Procedure CreateTask    (pt: point; var task: hTask);
Procedure NewTextLine   (var newline: hText);
Procedure NewRescLine   (var newresc: hResc);
Procedure SetUpTitle    (line: hText; htaskfield: hndfield);
Procedure SetUpDuration (curresc: hResc; htaskfield: hndfield);
Procedure SetUpResc     (curresc: hResc; htaskfield: hndfield);

Function  Critical      (task: htask): boolean;


{ routines still in aplp/pert }

{ drawing/printing routines }
Procedure DrawTask         (Task: hTask; scaled: rect );
Procedure ShowPert;

{ event handlers }
Procedure PertDeselect     (var error: boolean);
Procedure PertUp;
Procedure PertDown         (DownPt: point);
Procedure PertKey          (theEvent: EventRec);

{ box size control }
Procedure CkHGrowth;
Procedure CkVGrowth;



IMPLEMENTATION
{$IFC fsymok}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}
{$IFC fdbgok}
{$R+}
{$ELSEC}
{$R-}
{$ENDC}



const
   { fixed limits on task box sizes }
   MinHBox      = 50;     { Minimum width of a task box }
   MinVBox      = 32;     { Minimum height of a task box}



{$I aplp/pdata}


{------------------------------------------------------------------------------}
{                                                                              }
{           Drawing/printing routines, private.                                }
{                                                                              }
{------------------------------------------------------------------------------}


{$S MenuStuff}

Procedure ClipPert;
{ Sets up the clip region for the pert folder to be the portrect minus the
  scroll bar area intersected with the paper rect. }

var
   paper:     rect;           { the scaled paper rect            }
   ARgn:      rgnHandle;      { temporary rgn for paper boundary }

begin { ClipPert }

   with theport^ do with portrect do begin

      { create a paper region }
      ARgn := NewRgn;
      ScalePaper( Paper, Pert);
      RectRgn( ARgn, paper);

      { set clip region so as to protect scroll bars }
      SetRectRgn( clipRgn,left,top,right - dhSbox + 1,bottom - dvSbox + 1);

      { intersect paper region with the old clipRgn, store result in cliprgn}
      SectRgn( clipRgn, ARgn, clipRgn);
      DisposeRgn( ARgn );
   end; { with }
end; { ClipPert }



{-------------------------------------------------------------------------------}


Procedure Draw1Arrow( startpt, endpt: point);
{ draw one arrow from startbox to endbox }

begin { Draw1Arrow }

   { now draw it }
   MoveTo ( startpt.h, startpt.v);
   LineTo ( endpt.h, endpt.v);
end; { Draw1Arrow }


{-------------------------------------------------------------------------------}


Procedure DrawArrows(Task: hTask; scaled: rect);
{ Draws all the arrows from this task to its immediate successors }

var i:          integer;    { link counter            }
    TaskCenter,             { center point of task    }
    LInkCenter: point;      { center of linked task   }
    VisRect:    Rect;       { visible rect for update }
    myBool :    Boolean;

Begin { DrawArrows }

   { Draw all the arrows starting at this task }
   PenNormal;

   SetPt(TaskCenter, (scaled.right + scaled.left) div 2,(scaled.bottom + scaled.top) div 2);

   with task^^ do begin
      for i := 0 to NForward - 1 do begin
         {$R-}
         RectOffCntr( LinkCenter, Link[i]^^.box);
         Pt2Rect( TaskCenter, LinkCenter, VisRect);
         insetRect(visRect, -3,-2);
         If Printing then myBool := SectRect(VisRect, printRect, VisRect)
         else myBool := SectRect( VisRect, theport^.portrect, VisRect) or DrawingScrap;
         if myBool then Draw1Arrow( taskCenter, LinkCenter );
         {$R+}
      end; { for }
   End; { with  }
End; { DrawArrows }

{-------------------------------------------------------------------------------}


Procedure DrTextLine( task: hTask; sbox: rect; sdot: integer );
{ draws out the lines of text for the task requested    }

var I:         integer;      { line counter                    }
    curline:   hText;        { current line of text            }
    loc:       point;        { loc to draw string              }
    underEdit: boolean;      { is the line under edit now?     }

begin { DrTextLine }

   { for now, only draw if scaled to normal or larger }
   if (Scale[Pert].state = ScaleReal) or printing or drawingScrap then begin

      { set up initial location }
      SetPt( loc, ((sbox.right + sbox.left) div 2),
                    sbox.top + sdot div 2 + PertFontInfo[Pert].lspace -
                   (PertFontInfo[Pert].lspace * linecount(task) div 2));

      { loop through all lines }
      curline := task^^.title;
      SetFAlign( hdrawfield, nil, center );
      while curline <> nil do begin

         { must check if under edit }
         underEdit := false;
         if curselrec[pert].tag = textsel then begin
            if curselrec[pert].editingTitle and (curselrec[pert].curline = curline) then begin
               { this field is under edit }
               SetFAlign(htaskfield, hfstate, center);
               MoveField(htaskfield, hfstate, loc);
               peDrawFldAt(htaskfield, hfstate, loc, true, true);
               underEdit := true;
               curselrec[pert].dx := loc;
            end;
         end;

         { not under edit, set up hdrawfield }
         if not underEdit then begin
            { get field set up }
            hdrawfield^^.curvalue  := curline^^.text;
            hdrawfield^^.curlen    := curline^^.curlen;
            hdrawfield^^.maxlen    := curline^^.maxlen;
            PeDrawFldAt( hdrawfield, nil, loc, false, false );
         end;

         loc.v := loc.v + PertFontInfo[Pert].lspace;
         curline := curline^^.next;
      end; { while }
   end; { if }
end; { DrTextLine }


{-------------------------------------------------------------------------------}


Procedure DrawDotLine( task: htask;  sbox: rect;  sdot: integer );
{ draw the dotted line separating titles and resources }

begin { DrawDotLine }

   { dont draw this if this is a milestone, or will fall on the bottom line }
   if ((task^^.milestone) or (sdot >= (sbox.bottom - sbox.top)) or (sdot <= 0)) then {}
   else begin
      { draw the dotted line above the resources }
      if printing then begin
         { need pen size larger if printing cause single gray
         whether light or dark can fall through the cracks
         and disappear }
         pensize(1,2);
         penpat(ltgray);
      end { if }
      else begin
         { dark gray looks nice on the screen }
         pennormal;
         penpat(dkgray);
      end; { else }
      { move from left and right - 2 because dont want it
      to write over any part of the framerect, that looks
      messy }
      MoveTo( sbox.left + 2, sdot + sbox.top );
      LineTo( sbox.right - 2, sdot + sbox.top );
      pennormal;
   end; { else }
end; { DrawDotLine }


{-------------------------------------------------------------------------------}


procedure DrawResc( task: hTask;  Sbox: rect;  sdot: integer);
{ draws out the resource lines }

var I:         integer;    { local counter                 }
    curresc:   hResc;      { curent resource line          }
    locName,               { name location                 }
    locDur:    point;      { duration location             }
    underEdit: boolean;    { is field under edit now?      }

begin { DrawResc }

   if not task^^.milestone then begin

      { for now, only draw chars if normal or zoomed in mode }
      if (Scale[Pert].state = scaleReal) or printing or drawingScrap then begin

         { define the locations of the names and durations }
         SetPt( locName,
            (sbox.left + sbox.right) div 2 - 8,
            (sbox.bottom + sbox.top + sdot) div 2 + PertFontInfo[Pert].lspace -
            (PertFontInfo[Pert].lspace * RescCount(task)) div 2);
         SetPt( locDur,
            (sbox.left + sbox.right) div 2 + 8,
            locName.v);

         { loop through and output lines }
         curresc := task^^.resource;
         while curresc <> nil do begin

            underEdit := false;
            if curselrec[pert].tag = textsel then begin
               if (not curselrec[pert].editingTitle) and (not curselrec[pert].editingDuration) and
                  (curselrec[pert].curresc = curresc) then begin
                  underEdit := true;
                  setFAlign(htaskfield, hfstate, right);
                  MoveField(htaskfield, hfstate, locName);
                  PeDrawFldAt(htaskfield, hfstate, locName, true, true);
                  curselrec[pert].dx := locname;
               end;
            end;

            if (not underEdit) then begin
               { set up hdrawfield for resource name }
               hdrawfield^^.curvalue  := curresc^^.Rtext;
               hdrawfield^^.curlen    := curresc^^.Rcurlen;
               hdrawfield^^.maxlen    := curresc^^.Rmaxlen;

               { do it }
               SetFAlign( hdrawfield, nil, right );
               PeDrawFldAt(hdrawfield, nil, locName, false, false);
            end;


            underEdit := false;
            if curselrec[pert].tag = textsel then begin
               if (not curselrec[pert].editingTitle) and (curselrec[pert].editingDuration) and
                  (curselrec[pert].curresc = curresc) then begin
                  underEdit := true;
                  setfAlign(htaskfield, hfstate, left);
                  MoveField(htaskfield, hfstate, locDur);
                  PeDrawFldAt(htaskfield, hfstate, locDur, true, true);
                  curselrec[pert].dx := locdur;
               end;
            end;

            if not underEdit then begin
               { set up hdrawfield for duration value }
               hdrawfield^^.curvalue := curresc^^.dtext;
               hdrawfield^^.curlen   := curresc^^.dcurlen;
               hdrawfield^^.maxlen   := curresc^^.dmaxlen;

               { and do it }
               SetFAlign( hdrawfield, nil, left );
               PeDrawFldAt(hdrawfield, nil, locDur, false, false);
            end;

            { go on to next one }
            curresc := curresc^^.next;
            locName.v  := locName.v + PertFontInfo[Pert].lspace;
            locDur.v   := locDur.v  + PertFontInfo[Pert].lspace;
         end; { for }
      end; { if }
   end; { if }
end; { DrawResc }


{-------------------------------------------------------------------------------}


Procedure DrawSched( task: htask;  ScaledRect: rect );
{ outputs the dates, early start, late start, early finish, late finish }

var CenterH,              { h value of center of task rect         }
    offset:   integer;    { if date underlined then adjust offset  }
    theface:  Style;      { the face we will draw the text with    }
{-------------------------------------------------------------------------------}


Procedure DrawDate( WDoffset, locH, BoundH, locV, justify: integer);
{ draw one date at loch and locv }

var RDoffset: integer;   { real calendar day offset    }
    Date:     String30;  { the date string             }

begin { DrawDate }

   { convert to real day offset, and compute date string }
   RDoffset := RDEquiv(WDoffset);
   DateString(RDoffset, Date);

   if justify = left then begin
      if locH + StringWidth(date) > BoundH then locH := BoundH - StringWidth(date);
   end { if }
   else begin
      if justify = right then begin
         if loch - StringWidth(date) < BoundH then locH := BoundH
         else locH := locH - StringWidth(date);
      end { if }
      else begin
         { justify = center }
         locH := locH - StringWidth(date) div 2;
      end; { else }
   end; { else }

   { and draw it }
   MoveTo(locH,locV);
   DrawString( date );
end; { DrawDate }

{-------------------------------------------------------------------------------}


begin { DrawSched }

   { if we are currently displaying dates... }
   if ((Scale[Pert].state = ScaleReal) or printing or drawingScrap) and showDates then begin

      { set up font for drawing the dates          }
      SetUpFont;  { special case for scrap follows }
      if drawingScrap then begin  { to scrap draw normal dates }
         theFace := PertFontInfo[pert].myface;
      end { if }
      else begin { on the screen draw dates with a white shadow }
         theface := PertFontInfo[pert].myface + [shadow];
         TextMode( SrcBic );
      end; { else }

      { output each date, check if scheduled and if milestone }
      centerH := (scaledRect.left + ScaledRect.right) div 2;
      with task^^ do begin

         { check if start date has been user input, if so underline the text
           and change the offset to compensate for this  }
         if SetStart <> maxval then begin
            { If can't meet user set date then draw date in SrcOr }
            If (setStart <> earlyStart) Then TextMode(SrcOr);
            TextFace(theface + [underline]);
            ScaleVInt(offset, PertFontInfo[pert].descent * 2);
         end { if }
         else begin
            TextFace(theface);
            ScaleVInt(offset, PertFontInfo[pert].descent);
         end; { else }

         { if this is a milestone then draw date in the middle }
         if milestone then  begin
            if showES or showEF then DrawDate(earlystart,
            centerH, CenterH, scaledRect.top - offset,center);
         end { if }
         else begin
            if showES then DrawDate(earlystart,
            ScaledRect.left, centerH - 5,  scaledRect.top - offset, left);
            if showEF then DrawDate(earlystart + maxduration,
            ScaledRect.right, CenterH + 5, ScaledRect.top - offset, right);
         end; { else }

         TextMode(SrcBic);

         { see if user set the finish date }
         if (SetFinish <> minval) Then Begin
            { If cant meet user set late finish then draw the date in SrcOr }
            If (SetFinish <> latestart + maxduration) Then TextMode(SrcOr);
            TextFace(theface + [underline]);
         end
         else TextFace(theface);

         { if its a milestone then draw date in the center }
         if milestone then begin
            if showLS or showLF then
            DrawDate(latestart,
            CenterH, centerH, scaledRect.bottom + PertFontInfo[Pert].lspace,center);
         end { if }
         else begin
            if showLS then DrawDate(latestart,
            ScaledRect.left, centerH - 5, scaledRect.bottom + PertFontInfo[Pert].lspace, left);
            if showLF then DrawDate(latestart + maxduration,
            scaledRect.right, centerH + 5, scaledRect.bottom + PertFontInfo[Pert].lspace, right);
         end; { else }
      end; { with }

      { set up font for remainder of redraw }
      SetUpFont;
   end; { if }
end; { DrawSched }


{-------------------------------------------------------------------------------}


Procedure DrawSelected;

var theknob: rect;         { the knob to be drawn                       }
    HIncrement,            { amount to jump in h from knob to next knob }
    VIncrement,            { amount to jump in v                        }
    HOffset,               { adjustment for circles in H                }
    VOffset:    real;      { adjustment for circles in V                }
    I, J:       integer;   { loop counters                              }
    box:        rect;
    center1,
    center2:    point;

Procedure GetArwClipRgn( taskstart, taskend:   hTask; var ARgn: RgnHandle);
{ This procedure takes a start and end task with an arrow between and
  determines the clipped arrow coordinates and draws the arrow as selected.
  It leaves the clip rgn set to the rgn minus the start task and end task.}

Var
   Pt:       point;       { scaled center point of start and end tasks  }
   sbox:     rect;        { scaled task box rect                        }

begin { GetArwClipRgn }

   { lets define this rgn by drawing into it in mode -1 }
   PenNormal; PenMode( -1 );
   OpenRgn;

   { frame the start task }
   ScaleRect( sbox, taskstart^^.box);
   if taskstart^^.milestone then frameoval( sbox )
   else framerect( sbox );

   { and frame the end task }
   ScaleRect( sbox, taskend^^.box);
   if taskend^^.milestone then frameoval( sbox )
   else framerect( sbox );

   { the rgn is the current cliprng minus the start and end tasks }
   CloseRgn( ARgn );
   DiffRgn( myfolder^.cliprgn, Argn, ARgn );
   CopyRgn( ARgn, myfolder^.cliprgn);
end; { GetArwClipRgn }


{-------------------------------------------------------------------------------}
begin { DrawSelected }

   if not printing then begin
      with curselrec[pert] do begin
         case tag of
            task: begin
               { set up pen state }
               pennormal; penmode(10);  penpat(gray);  pensize(dHcritical, dVcritical);

               { frame the rect  or oval }
               ScaleRect(box, curtask^^.box);
               if not curtask^^.milestone then framerect(box)
               else frameoval(box);

               { draw knobbies }
               pennormal;   penmode(10);

               { set up some values for loop }
               HIncrement := (box.right  - box.left)/2.0;
               VIncrement := (box.bottom - box.top )/2.0;
               if curtask^^.milestone then begin
                  HOffset := HIncrement / Pi;
                  VOffset := HOffset * 0.66;
               end;

               { draw the knobbies }
               For I := 0 to 2 do begin
                  for J := 0 to 2 do begin

                     { don't draw the 1,1 one, this would be the center }
                     if Not((I = 1) and (J = 1)) then begin

                        { milestones are draw differently on four corners }
                        if (curtask^^.milestone and ((abs(I - J)= 2) or (abs(I - J)= 0)))  then begin
                           if I = 0
                           then theknob.left :=  box.left + trunc(HIncrement - HOffset)
                           else theknob.left :=  box.left + trunc(HIncrement + HOffset);
                           if J = 0
                           then theknob.top := box.top + trunc(VIncrement - VOffset)
                           else theknob.top := box.top + trunc(VIncrement + VOffset);
                        end { if }

                        { not milestone or milestone and not a corner }
                        else begin
                           theknob.left := box.left + trunc(I* HIncrement);
                           theknob.top := box.top + trunc(J* VIncrement);
                        end; { else }

                        { draw the knob }
                        theknob.botright := theknob.topleft;
                        Insetrect( theknob, -3, -2 );
                        paintrect( theknob );
                     end; { if }
                  end; { for }
               end; { for }
            end; { task }

            arrow1: begin
               { draw a selected arrow }
               GetArwClipRgn(TaskFrom, Taskto, ArwClipRgn);
               pensize(3,3); penmode(10); penpat(gray);
               RectCntr(Center1, taskfrom^^.box);
               RectCntr(Center2, taskto^^.box);
               center1.h := center1.h -1;
               center1.v := center1.v -1;
               center2.h := center2.h -1;
               center2.v := center2.v -1;
               Draw1Arrow(center1, center2);
               pennormal;
               clipPert;
            end;

         end; { case }
      end; { with }
   end; { if }
end; { DrawSelected }

{-------------------------------------------------------------------------------}


Procedure GetMaxArrow( task: htask; var maxH: integer);

var i: integer;

begin { GetMaxArrow }

   MaxH := task^^.box.right;

   with task^^ do
   for i := 0 to NForward - 1 do begin
      {$R-}
      MaxH := CMax(Maxh, link[i]^^.box.left);
      {$R+}
   end; { for }
   ScaleHInt(MaxH, MaxH);
end; { GetMaxArrow }



{-------------------------------------------------------------------------------}
{                                                                               }
{           Drawing/printing routines, public.                                  }
{                                                                               }
{-------------------------------------------------------------------------------}


Procedure DrawTask{( Task:   hTask; scaled: rect )};
{ DrawTask draws the one box associated with hTask and then draws the
  text inside the box.  It also draws the deadline and target schedule
  dates below the box if these display parameters are set. }

var
   Sdot:     integer;     { scaled location of the dotline   }
   outrect:  rect;
   myBool : Boolean;

Begin { DrawTask }

   OutRect := scaled;
   if showdates then InsetRect(outrect, 0, -PertFontInfo[pert].lspace * 2);

   If Printing then myBool := sectRect(outrect, printrect, outrect)
   else myBool := sectRect(outrect, theport^.portrect, outrect) or drawingscrap;
   if myBool then begin

      ScaleVInt(Sdot, task^^.dotline);

      { set the pen, scale the rect }
      pennormal;
      If Critical(task) then PenSize(dHcritical, dVCritical);

      { fill the rect or oval }
      if task^^.milestone then begin
         FillOval(Scaled, white);
         FrameOval(Scaled);
      end { if }
      else begin
         FillRect(Scaled, white);
         FrameRect(Scaled);
      end; { else }

      { draw the text lines and date strings }
      DrTextLine( task, scaled, sdot);
      DrawResc( task, scaled, sdot);
      DrawDotLine( task, scaled, sdot );
      DrawSched( task, scaled );
   end; { if }

   if (curselrec[pert].tag = document) and ((not printing) and (not drawingscrap)) then
      if task^^.milestone then InvertOval(scaled)
      else InvertRect(scaled);
End; { Drawtask }



{-------------------------------------------------------------------------------}


Procedure ShowPert;
{ ShowPert draws the entire Pert chart.}

var curTask: hTask;   { the current task being drawn }
    errnum:  integer; { for FE error returns         }
    scaled:  rect;    { scaled rect for task         }
    MaxH:    integer;
    done:    boolean;

Begin { ShowPert }

   { watch out for printing, draw the paper and preview }
   if (not Printing) and (not drawingScrap) then begin
      DrawPaper;
      EraseRect(theport^.portrect);
      if Preview then PreviewPrint(Pert);
   end;

   { draw chart titles, these go over any tasks or milestones }
   DrawTitles(Pert);

   if printing or drawingScrap then begin
      curtask := Head;
      while curtask <> nil do begin
         ScalOffRect(scaled,curtask^^.box);
         DrawArrows(curtask, scaled);
         drawtask(curtask, scaled);
         curtask := curtask^^.flink;
      end; { while }
   end { if }

   else begin
      { follow flinks through the network data }
      vishead := nil;
      visTail := nil;
      curTask := Head;
      done := false;
      While (curTask <> Nil) and (Not done) Do Begin
         ScaleRect(scaled, curtask^^.box);

         if visHead = nil then begin
            GetMaxArrow( curtask, MaxH );
            if MAxH > myfolder^.portrect.left then begin
               visHead := curtask;
               visTail := curtask;
               DrawArrows(curTask, scaled);
               DrawTask( curTask, scaled);
            end;
         end
         else begin
            if scaled.left < myfolder^.portrect.right then begin
               visTail := curtask;
               drawArrows( curtask, scaled);
               DrawTask( curtask, scaled);
            end
            else done := true;
         end;
         CurTask := curtask^^.fLink;
      End; { While }

      DrawSelected;
   end; { else }

End; { ShowPert }



{------------------------------------------------------------------------------}
{                                                                              }
{         Pert event handlers, public.                                         }
{                                                                              }
{------------------------------------------------------------------------------}

{$S Events}





Procedure BoxPerim( Task1: hTask; oldmouse:  point );
{ handle the case where down is on perimeter of task or milestone }

Begin { BoxPerim }

   { set up current selection }
   With CurSelRec[pert] Do Begin
      tag := task;
      Curtask := Task1;
      ScaleRect(CurrentBox, task1^^.box);
      knob := none;

      { draw the selection }
      SetPort( myfolder );
      drawselected;
   End; { With }
End; { BoxPerim }


{------------------------------------------------------------------------------}



Procedure GetDx(task: htask; theline: htext; var loc: point);
{ gets the point at which the text line is drawn }

var curline: htext;   { current line to be drawn }
    sbox:    rect;    { scaled task box          }
    sdot:    integer; { scaled dotline value     }

begin { GetDx }

   { scale needed values }
   ScaleRect(sbox, task^^.box);
   ScaleVInt(sdot, task^^.dotline);

   { set starting point for text }
   SetPt( loc, ((sbox.right + sbox.left) div 2),
                 sbox.top + sdot div 2 + PertFontInfo[Pert].lspace -
                (PertFontInfo[Pert].lspace * linecount(task) div 2));

   curline := task^^.title;
   while (curline <> theline) and (curline <> nil) do begin
      loc.v := loc.v + PertFontInfo[Pert].lspace;
      curline := curline^^.next;
   end; { While }
end; { GetDx }


{-------------------------------------------------------------------------------}


Procedure GetNDx(task: htask; theresc: hresc; var loc: point);
{ gets the point at whick theresc name is drawn }

var curresc: hresc;     { current resc to be drawn }
    sbox:    rect;      { scaled task box          }
    sdot:    integer;   { scaled dotline value     }

begin { GetNDx }

   { Scale the values needed }
   ScaleRect(sbox, task^^.box);
   ScaleVInt(sdot, task^^.dotline);

   { set starting point for drawing }
   SetPt( loc,
      (sbox.left + sbox.right) div 2 - 8,
      (sbox.bottom + sbox.top + sdot) div 2 + PertFontInfo[Pert].lspace -
      (PertFontInfo[Pert].lspace * RescCount(task)) div 2);

   { find the resc requested }
   curresc := task^^.resource;
   while (curresc <> theresc) and (curresc <> nil) do begin
      loc.v := loc.v + PertFontInfo[Pert].lspace;
      curresc := curresc^^.next;
   end;
end; { GetNDx }


{-------------------------------------------------------------------------------}


Procedure GetDDx(task: htask; theresc: hresc; var loc: point);
{ gets the point at which theresc duration is drawn }

var curresc: hresc;    { the current resc being drawn }
    sbox:    rect;     { the scaled task box value    }
    sdot:    integer;  { the scaled dotline value     }

begin { GetDDx }

   { get the necessary scaled values }
   ScaleRect(sbox, task^^.box);
   ScaleVInt(sdot, task^^.dotline);

   { get the staring point for drawing }
   SetPt( loc,
      (sbox.left + sbox.right) div 2 + 8,
      (sbox.bottom + sbox.top + sdot) div 2 + PertFontInfo[Pert].lspace -
      (PertFontInfo[Pert].lspace * RescCount(task)) div 2);

   { find theresc }
   curresc := task^^.resource;
   while (curresc <> theresc) and (curresc <> nil) do begin
      loc.v := loc.v + PertFontInfo[Pert].lspace;
      curresc := curresc^^.next;
   end; { While }
end; { GetDDx }

{-------------------------------------------------------------------------------}



Procedure BoxInt( Task : hTask;  downpt: point);
{ Handles the case where the user buttoned down inside the box interior
of Task. This procedure determines which line of text has been selected
for editing. }

var
   tempdot:    integer;    { scaled dotline value           }
   tempbox:    rect;       { scaled task box value          }
   found:      boolean;    { stopping flag for line search  }
   curloc:     point;
   theLine:    htext;
   theResc:    hresc;

Begin { BoxInt }

   { scale everybody to current scale factor }
   Scalerect( tempbox, task^^.box);
   ScaleVInt( tempdot, task^^.dotline);
   found := false;

   with curselrec[pert] do begin

      if scale[pert].state = scalereal then begin

         { downpt above or below dotline ? }
         if downpt.v <= tempdot + tempbox.top then begin

            { its above, editing task title }
            if task^^.title = nil then begin
               if enoughSpace(theheap, sizeTextRec) then begin
                  NewTextLine( theline);
                  task^^.title := theline;
                  DrTextLine(task, tempbox, tempdot);
                  found := true;
               end { if }

               { not enough space, dont create the line }
               else Stopalert(pealert, 50 {out of memory});
            end

            { look through the existing lines }
            else begin
               theline := task^^.title;
               GetDx(task, theline, curloc);

               while ((theline^^.next <> nil) and (not found)) do begin
                  if downpt.v < curloc.v then found := true
                  else theline := theline^^.next;
                  curloc.v := curloc.v + PertFontInfo[Pert].lspace;
               end;
               found := true;
            end; { else }

            { got an edit }
            if found then begin
               tag := textsel;
               newfrom := task;
               curline := theLine;
               SetUpTitle( curline, htaskfield );
               SetFAlign( htaskfield, nil, center );
               GetDx(task, curline, dx);
               MoveField( htaskfield, nil, dx );
               editingTitle := true;
               EditingDuration := false;
               curresc := nil;
               recalc := false;
            end { if }
            else tag := air;
         end { if }

         { its below, look at resource names and duration fields }
         else begin

            { if no lines yet, then create a new line }
            if task^^.resource = nil then begin
               if enoughSpace(theheap, sizeRescRec + sizeNameRec) then begin
                  NewRescLine( theresc);
                  task^^.resource := theresc;
                  DrawResc(task,tempbox,tempdot);
                  found := true;
               end { if }
               else Stopalert(pealert, 50 {out of memory});
            end

            { look at existing lines for edit }
            else begin
               theresc := task^^.resource;
               GetNdx(task,theresc, curloc);
               while ((theresc^^.next <> nil) and (not found)) do begin
                  if downpt.v < curloc.v then found := true
                  else  theresc := theresc^^.next;
                  curloc.v := curloc.v + PertFontInfo[Pert].lspace;
               end;
               found := true;
            end; { else }

            { which was it, name or duration field ? }
            if found then begin
               tag := textsel;
               newfrom := task;
               curresc := theResc;
               if downpt.h <= ((tempbox.left + tempbox.right) div 2)
               then begin

                  { got the resource name field }
                  SetUpResc( curresc, htaskfield );
                  SetFAlign( htaskfield, nil, right );
                  GetNdx(newfrom, curresc, dx);
                  MoveField( htaskfield, nil, dx );
                  EditingTitle := false;
                  EditingDuration := false;
                  curline := nil;

               end { if }
               else  begin

                  { got the duration field }
                  SetUpDuration( curresc, htaskfield);
                  SetFAlign( htaskfield, nil, left );
                  GetDdx(task, curresc, dx);
                  MoveField( htaskfield, nil, dx );
                  EditingDuration := true;
                  EditingTitle := false;
                  curline := nil;
               end; { else }
               recalc := true;
            end; { if }
         end; { else }

         { we got something to edit, set it up }
         if tag = textsel then begin
            InitFstate( htaskfield, hfstate);
            Select( downpt, htaskfield, hfstate, curNbrhood, curTimeout);
            docDirtyFlag := true;
         end; { if }
      end { if }
      else begin
         { in a reduced mode, go into new arrow mode }
         { set up new arrow in curselrec }
         tag := newarrow;
         NewTo := Nil;
         NewFrom := Task;
         RectCntr( NewCntr, NewFrom^^.box);

         { set pen move and draw the arrow }
         Penmode(10); pensize(1,1);
         MoveTo( NewCntr.h, NewCntr.v);
         LineTo (downPt.h, downpt.v );
         oldmouse := downpt;

         { change cursor to inactive }
         SetStdCursor(icrsGECross);
      end; { else }
   end; { with }
End; { BoxInt }


{------------------------------------------------------------------------------}


Function MaxTextH( task: htask): integer;
{ determines the scaled min size of the box given the text inside, includes padding }

const padding = 8;

var curline: htext;
    max: integer;
    NoEdit: boolean;

begin { MaxTextH }

   SetUpFont;
   curline := task^^.title;
   max := 0;
   while curline<> nil do begin
      NoEdit := true;
      if curselrec[pert].tag = textsel then begin
         if (curselrec[pert].EditingTitle) and (curline = curselrec[pert].curline) then begin
            Max := CMax( Max,
            (TextWidth( Pointer(Ord(htaskfield^^.curvalue^)),0,htaskfield^^.curlen))
            div 2 + padding);
            NoEdit := false;
         end;
      end;
      if noEdit then
         max := CMax( Max,
         (TextWidth( Pointer(Ord(curline^^.text^)), 0, curline^^.curlen)) div 2 + Padding);
      curline := curline^^.next;
   end; { while }
   Max := trunc(max * Scale[pert].factor/PertFontInfo[activechart].actual);
   maxTextH := Max;
end; { MaxTextH }


{-------------------------------------------------------------------------------}


Function MaxRescH( task: htask): integer;
{ determines the min box size according to resource text inside }

const
   padding = 8;
   offRescH= 5;
var
   curresc: hresc;
   max: integer;
   NoDurEdit,
   NoNamEdit: boolean;

begin { MaxRescH }

   SetUpFont;
   max := 0;
   if not task^^.milestone then begin
      curresc := task^^.resource;
      while curresc <> nil do begin
         NoDurEdit := true;
         NoNamEdit := true;

         if curselrec[pert].tag = textsel then begin
            if (CurselRec[pert].EditingDuration) and (curresc=curselrec[pert].curresc)
            then begin
               Max := CMax( max, offRescH +
               TextWidth(pointer(ord(htaskfield^^.curvalue^)), 0,
               htaskfield^^.curlen) + padding);
               NoDurEdit := false;
            end
            else if (not curselrec[pert].editingTitle) and
            (Not curselrec[pert].editingDuration) and (curresc=curselrec[pert].curresc)
            then begin
               Max := CMax( max, offRescH +
               TextWidth(pointer(ord(htaskfield^^.curvalue^)), 0,
               htaskfield^^.curlen) + padding);
               NoNamEdit := false;
            end;
         end; { if }

         if noDurEdit then
            Max := CMax( Max, offRescH +
            TextWidth(Pointer(Ord(curresc^^.dtext^)),0,curresc^^.dcurlen) +
            padding);
         if noNamEdit then
            Max := CMax( Max, offRescH +
            TextWidth(Pointer(Ord(curresc^^.Rtext^)),0,
            curresc^^.Rcurlen) + padding);
         curresc := curresc^^.next;
      end; { while }
   end; { if }
   Max := trunc(max * Scale[pert].factor/PertFontInfo[activechart].actual);
   maxRescH := Max;
end; { MaxRescH }

{-------------------------------------------------------------------------------}

Procedure DrawGhost( box: rect;  milestone: boolean );
{ Draws the ghost box or oval for the task or milestone move in XOR mode. }

begin { drawghost }

   { set up pen and frame it }
   pennormal;   penmode( 10 );
   if not milestone then framerect(box)
   else frameoval(box);
end; { drawghost }


{-------------------------------------------------------------------------------}


Procedure PertMove( Pt: point );
{ handles a mousemove }


var
   dh,                  { amount mouse moved horizontally    }
   dv:     integer;     { amount mouse moved vertically      }
   I:      integer;     { control var for Newtask for loop   }
   box:    rect;        { scaled newfrom^.box for text, arrow}
   TempRect:  Rect;     { rect slightly within a task box    }
   paper:     rect;

Begin { PertMove }

   { Case according to the current type of selection }
   With curSelRec[pert] do
      Case Tag of

         Task: begin

            { if this is a move then get new current box }
            if knob = none then begin
               scalepaper(paper, pert);
               with currentbox do begin
                  if (left + pt.h - oldmouse.h < paper.left)
                  then dh := paper.left - left
                  else if (right  + pt.h - oldmouse.h > paper.right)
                     then dh := paper.right - right
                     else dh := pt.h - oldmouse.h;
                  if (top + pt.v - oldmouse.v < paper.top )
                  then dv := paper.top - top
                  else if (bottom + pt.v - oldmouse.v > paper.bottom)
                     then dv := paper.bottom - bottom
                     else dv := pt.v - oldmouse.v;
               end; { with }

               if (dh <> 0) or (dv <> 0) then begin
                  { erase the old rect }
                  if not firstmove then drawghost(currentbox, curtask^^.milestone)
                  else firstmove := false;
                  { get the new rect }
                  offsetrect(currentbox, dh, dv);
                  { draw the new rect }
                  drawghost(currentbox, curtask^^.milestone);
                  { save the old mouse point }
                  setpt(oldmouse, oldmouse.h + dh, oldmouse.v + dv);
               end; { if }
            end { if }

            { otherwise this is a grow }
            else begin
               scalepaper(paper, pert);
               dh := pt.h - curselloc.h;  { dh, dv = distance from original down pt }
               dv := pt.v - curselloc.v;

               { Erase the old ghost box  }
               if (dh <> 0) or (dv <> 0) then begin
                  if not firstmove then drawghost(currentbox, curtask^^.milestone)
                  else firstmove := false;

                  ScaleRect( box, curtask^^.box);

                  if curtask^^.milestone then begin
                     case knob of
                        centerleft,
                        topleft,
                        botleft: begin
                           currentbox.left := box.left + dh;
                           if (currentbox.right - currentbox.left) < HBoxMin
                           then currentbox.left := currentbox.right - HBoxMin;

                           {if (currentbox.right - (box.left + dh)) < HBoxMin
                           then dh := currentbox.right - box.left - HBoxMin;
                           currentbox.left:= box.left + dh;}

                           if currentbox.left < paper.left then currentbox.left := paper.left;
                           NormVMS( currentbox );
                           if currentbox.top  < paper.top  then begin
                              currentbox.top  := paper.top;
                              NormHMS( currentbox);
                           end;
                           if currentbox.bottom > paper.bottom then begin
                              currentbox.bottom := paper.bottom;
                              NormHMS(currentbox);
                           end;
                        end;
                        centerright,
                        topright,
                        botright: begin
                           currentbox.right := box.right + dh;
                           if (currentbox.right - currentbox.left) < HBoxMin
                           then currentbox.right := currentbox.left + HBoxMin;

                           {if ((box.right + dh) - currentbox.left) < HboxMin
                           then dh := HBoxMin + currentbox.left - box.right;
                           currentbox.right:= box.right + dh;}

                           if currentbox.right > paper.right then currentbox.right := paper.right;
                           NormVMS( currentbox );
                           if currentbox.bottom > paper.bottom then begin
                              currentbox.bottom := paper.bottom;
                              NormHMS(currentbox);
                           end;
                           if currentbox.top < paper.top then begin
                              currentbox.top := paper.top;
                              NormHMS(currentbox);
                           end;
                        end;
                        topcenter:begin
                           currentbox.top := box.top + dv;
                           if (currentbox.bottom - currentbox.top) < VBoxMin
                           then currentbox.top := currentbox.bottom - VBoxMin;

                           {if (currentbox.bottom - (box.top + dv)) < VBoxMin
                           then dv := currentbox.bottom - box.top - VBoxMin;
                           currentbox.top := box.top + dv;}

                           if currentbox.top < paper.top then currentbox.top := paper.top;
                           NormHMS( currentbox );
                           if currentbox.left < paper.left then begin
                              currentbox.left := paper.left;
                              NormVMS(currentbox);
                           end;
                           if currentbox.right > paper.right then begin
                              currentbox.right := paper.right;
                              NormVMS(currentbox);
                           end;
                        end;
                        botcenter:begin
                           currentbox.bottom := box.bottom + dv;
                           if (currentbox.bottom - currentbox.top) < VBoxMin
                           then currentbox.bottom := currentbox.top + VBoxMin;

                           {if ((box.bottom + dv) - currentbox.top) < VBoxMin
                           then dv := VBoxMin - box.bottom + currentbox.top;
                           currentbox.bottom:= box.bottom + dv;}

                           if currentbox.bottom > paper.bottom then currentbox.bottom := paper.bottom;
                           NormHMS( currentbox );
                           if currentbox.right >  paper.right  then begin
                              currentbox.right := paper.right;
                              NormVMS(currentbox);
                           end;
                           if currentbox.left < paper.left then begin
                              currentbox.left := paper.left;
                              NormVMS(currentbox);
                           end;
                        end;
                     end; { case }
                  end { if }
                  else begin

                     { move the task's box position and redraw in the new position }
                     case knob of
                     topleft,
                     centerleft,
                     botleft:  begin
                                  currentbox.left := box.left + dh;
                                  if (currentbox.right - currentbox.left) < HBoxMin
                                  then currentbox.left := currentbox.right - HBoxMin;
                                  if currentbox.left < paper.left then currentbox.left := paper.left;
                               end;
                     botright,
                     centerright,
                     topright: begin
                                  currentbox.right := box.right + dh;
                                  if (currentbox.right - currentbox.left) < HBoxMin
                                  then currentbox.right := currentbox.left + HBoxMin;
                                  if currentbox.right > paper.right then currentbox.right := paper.right;
                               end;
                     end;

                     case knob of
                     topleft,
                     topright,
                     topcenter:begin
                                  currentbox.top := box.top + dv;
                                  if (currentbox.bottom - currentbox.top) < VBoxMin
                                  then currentbox.top := currentbox.bottom - VBoxMin;
                                  if currentbox.top < paper.top then currentbox.top := paper.top;
                               end;
                     botleft,
                     botcenter,
                     botright: begin
                                  currentbox.bottom := box.bottom + dv;
                                  if (currentbox.bottom - currentbox.top) < VBoxMin
                                  then currentbox.bottom := currentbox.top + VBoxMin;
                                  if currentbox.bottom > paper.bottom then currentbox.bottom := paper.bottom;
                               end;
                     end; { case }
                  end; { else }
                  oldmouse := pt;
                  drawghost(currentbox, curtask^^.milestone);
               end; { if }
            end; { else }

         End; { Task }

         NewArrow: Begin

            { XOR the old arrow to erase it }
            Penmode(10);
            MoveTo( oldmouse.h, oldmouse.v);
            LineTo( newCntr.h, newCntr.v);

            { see if we are outside the newtask and if not then switch back
            to text }
            ScaleRect(temprect, newfrom^^.box);
            if PtinRect( pt, temprect ) and (Scale[pert].state = scaleReal)  then begin

               tag := textsel;
               SetStdCursor(icrsIBeam);
               HilightSel( htaskfield, hfstate, true );
               GrowSel( pt, htaskfield, hfstate, curNbrhood );

            end
            else begin

               { Draw in the new arrow in XOR and save the mouse point }
               LineTo( pt.h, pt.v);
               oldmouse := pt;
            end;
         End; { NewArrow Case }

         TextSel: Begin

            { Determine if we want to switch to a new arrow }
            ScaleRect( temprect, newfrom^^.box);
            if PtinRect( pt, temprect) then begin

               { extend the selection according to the new mouse point }
               if not PtinRect(pt, curNbrhood) then
               GrowSel( pt, htaskfield, hfstate, curNbrhood);
            end
            else begin

               { get out of text edit state, turn off highlighting on text }
               HilightSel( htaskfield, hfstate, false );

               { set up new arrow in curselrec }
               tag := newarrow;
               NewTo := Nil;
               RectCntr( NewCntr, NewFrom^^.box);

               { set pen move and draw the arrow }
               Penmode(10); pensize(1,1);
               MoveTo( NewCntr.h, NewCntr.v);
               LineTo (Pt.h, pt.v );
               oldmouse := pt;

               { change cursor to inactive }
               SetStdCursor(icrsGECross);
            end; { if }

         End; { TextSel }

         NewTask: Begin

            { erase the old box and draw the new one }
            For I := 1 to 2 do begin
               MoveTo(curselloc.h, curselloc.v );
               LineTo(lastmovept.h, curselloc.v );
               LineTo(lastmovept.h, lastmovept.v );
               LineTo(curselloc.h, lastmovept.v );
               LineTo(curselloc.h, curselloc.v );
               lastmovept := pt;
            end;
         End; { NewTask }

         ChartTitle: begin
            if not PtinRect(pt, curnbrhood) then
            GrowSel( pt, Titles[fldrId][index].hTitleField, hfstate, curNbrhood);
         end;

      End; { Case }
End; { PertMove }


{------------------------------------------------------------------------------}


Function CkRemovAllText( curtask: htask):boolean;
{ see if we can remove any blank lines of text from the task
  title or resource records }

var curline,
    lastline,
    nextline:  htext;
    curresc,
    lastresc,
    nextresc:  hresc;
    textRemoved: boolean;
    sdot:      integer;

begin
   { first ckeck the task titles }
   curline := curtask^^.title;
   lastLine := nil;
   TextRemoved := false;

   { look for blank lines of text }
   while curline <> nil do begin
      { got one }
      if (curline^^.curlen = 0) then begin
         { unlink it from the text list }
         TextRemoved := true;
         if lastline = nil then begin
            curtask^^.title := curline^^.next;
         end
         else begin
            lastline^^.next := curline^^.next;
         end;
         NextLine := curline^^.next;
         FreeText( curline );
         curline := NextLine;
      end
      else begin
         lastline := curline;
         curline := curline^^.next;
      end; { else }
   end; { while }

   { next the resources }
   curresc := curTask^^.resource;
   lastResc := nil;

   { look for blank lines }
   while curresc <> nil do begin

      { if name and duration are not filled in then get rid of this record }
      if ((curresc^^.Rcurlen = 0) and (curresc^^.Dcurlen = 0)) then begin
         textRemoved := true;

         { return the resource reference }
         ReturnResc(names, curresc );

         { Remove the resource record from the list.  Unlink it first }
         if lastresc = nil
         then curtask^^.resource := curresc^^.next
         else lastresc^^.next := curresc^^.next;

         { get rid of the resc record }
         nextResc := curresc^^.next;
         FreeRsc( curresc );
         curresc := nextResc;
      end
      else begin
         lastresc := curresc;
         curresc := curresc^^.next;
      end; { else }
   end; { while }
   CKRemovAllText := TextRemoved;
end;

{------------------------------------------------------------------------------}


Procedure PertDeselect{( var error: boolean)};
{ This deselects the current selection. It sets the penpat and the penmode
   back to normal. It sets the current selection tag to air. }

var
   Ok:          boolean;    { ok so far                     }
   newduration: integer;    { new duration value after edit }
   lastline:    hText;      { the predecessor to curline    }
   theTask:     htask;
   CenterFrom,
   CenterTo:    point;
   updateRect:  rect;
   sbox:        rect;
   removed:     boolean;


Begin { PertDeselect }

   { update the current selection record }
   UndoValid := false;
   error := false;
   With CurSelRec[pert] do Begin
      Case Tag of
         Task: Begin
            { Redraw the entire box }
            SetPort( myfolder);
            drawselected;
         End; { Task Case }

         Arrow1: Begin
            { Redraw the arrow in white to erase it and draw normally }
            DrawSelected;
            DisposeRgn(ArwClipRgn);
            ClipPert;
         End; { Arrow1 case }

         TextSel: Begin

            { exit the field edit routines }
            Exitfield(Htaskfield, hfstate);
            thetask := Newfrom;

            if EditingTitle then RestoreTitle( curline, htaskfield )
            else begin
               If EditingDuration then begin
                  EditCheckDuration( curresc, newduration, ok);
                  If Ok then begin
                     RestDuration( curresc, htaskfield );
                     curresc^^.duration  := newduration;
                     curresc^^.remaining := newduration;
                     CalcMaxDuration ( newfrom );
                  end { if }
                  else begin
                     { the edit was not a good duration value, restore old value.
                     No redraw here because of restore. }
                     StopAlert(PEalert, 12 {Bad Duration Value});

                     { erase the new value coords rect }
                     EraseRect(htaskfield^^.coords);

                     { now restore the old value in the field }
                     RestoreOldValue(curresc);

                     { reset coords rect for old value and redraw }
                     MoveField( htaskfield, nil, dx );
                     DrawFldAt( htaskfield, nil, dx, true, true);
                     RestDuration( curresc, htaskfield );
                     error := true;
                  end; { else }
               end { if }
               else begin
                  { got a new resource name here }
                  XRestoreResc( curresc, htaskfield );
               end; { else }
            end; { else }
            tag := air;
            Removed := CkRemovAllText(newfrom);
            if recalc and showdates then begin
               CalcSchedule;
               Showcontents(myfolder);
            end
            else if removed then begin
               scaleRect(sbox, newfrom^^.box);
               DrawTask(newfrom, sbox );
            end;
         End; { textsel case }

         ChartTitle: begin
            ExitField( Titles[FldrId][index].hTitlefield, hfstate );
            { redraw entire chart in title area this is because the
              title goes underneath everything else }
            UnionRect(oldCoords, titles[fldrId][index].htitlefield^^.coords, UpdateRect);
            tag := air;
            setport(myfolder);
            cliprect(updateRect);
            showscroll(myfolder);
            showcontents(myfolder);
         end;

         Document: begin
            tag := air;  { must reset this before the show }
            Showcontents(myfolder);
         end;

      End; { Case }
      tag := air;
      docDirtyFlag := false;
   End; { With }
End; { Pertdeselect }


{------------------------------------------------------------------------------}


Procedure PertUp;
{ handles a buttonup at Pt }

var
   Pt:        Point;
   DestTask:  hTask;    { Dest task for laying down a new arrow     }
   found:     Boolean;  { True if the up point is within a Task box }
   task1:     hTask;    { handle for newtask case                   }
   temprect:  rect;     { to detmine neighborhood for box move      }
   error:     boolean;  { error flag returned from MoveTask, AddTask}
   perimeter: boolean;
   moveInH:   integer;
   centerpt:  point;
   CenterFrom,          { new arrow, scaled center pt of from task  }
   CenterTo:  point;    { scaled centerpt of to task                }
   VisRect:   rect;     { rect made with above two points           }
   newbox:    rect;
   minh,
   minv:      integer;
   scaledBox: rect;
   HitBool:   boolean;
   FromTask,
   ToTask:    htask;
   removed:   boolean;


Begin { PertUp }

   { set port, clip, save up point }
   SetPort(myfolder);
   ClipPert;
   Pt := theEvent.where;

   { look at the current selection to decide what to do }
   With curSelRec[pert] do Begin
      Case Tag of
         Task: Begin

            { erase the ghost image }
            pennormal;  penmode(10);
            if not firstmove then drawghost(currentbox, curtask^^.milestone);

            { set up temprect to be the neighborhood around the down point}
            Pt2Rect(curselloc, curselloc, temprect);
            InSetRect( temprect, -dhNbhd, -dvNbhd);

            { if the box has moved then check for growth or just move }
            IF not PtinRect ( Pt, temprect ) then begin

               { if box has moved then document has been changed }
               docChangedFlag := true;

               { this was a growth, do some checking }
               if (knob <> none) then
               with curtask^^ do begin
                  UnScaleRect(newbox, currentbox);

                  { adjust the location of the dotline }
                  if milestone then
                     dotline := newbox.bottom - newbox.top
                  else
                     if (knob = topcenter) then
                        Dotline := Cmax(LineCount(curtask)*p15lspace, dotline + box.top - newbox.top)
                     else
                        if (knob = centerleft) or (knob = centerright) then
                           { dont change dotline value }
                        else
                           if (knob = botcenter) then begin
                              if (newbox.bottom - newbox.top - dotline) < RescCount(curtask)*p15lspace then
                              dotline := newbox.bottom - newbox.top - rescCount(curtask)*p15lspace;
                           end { if }
                           else begin
                              { all other cases keep same proportional position }
                              dotline := trunc(dotline/(box.bottom - box.top) *
                              (newBox.bottom - newbox.top));
                              if dotline < linecount(curtask)*p15lspace
                                 then dotline := linecount(curtask)*p15lspace;
                              if (newbox.bottom - newbox.top - dotline) < RescCount(curtask)*p15lspace
                                 then dotline :=  newbox.bottom - newbox.top - rescCount(curtask)*p15lspace;
                           end; { else }
               end; { if }

               { everything checked out, set up new task }
               MoveTask( curtask, currentbox);
               Showcontents(myfolder);
               ValidRgn(myfolder^.cliprgn);
            end; { else }
         End; { Task  }

         Arrow1: Begin
         End;

         Air: Begin
         End;

         NewArrow: Begin

            { Erase the old XOR arrow }
            pennormal;  penmode(10);
            MoveTo( oldmouse.h, oldmouse.v);
            LineTo( newCntr.h, newCntr.v);

            { we should deselect some text }
            { exit the field edit routines }
            if scale[pert].state = scalereal then begin
               ExitField(hTaskField, hfState);

               { was this an edit of task title ?? }
               if EditingTitle then RestoreTitle( curline, htaskfield )
               else if EditingDuration then RestDuration( curresc, htaskfield )
               else XRestoreResc( curresc, htaskfield );
               Removed := CkRemovAllText(NewFrom);
            end; { if }

            { See if the mouse up point is in another, different task }
            If HitTestPert(Pt, false{tracking},HitBool, perimeter, FromTask, ToTask)
            then begin
               if HitBool and (NewFrom <> FromTask) then Begin

                  DocChangedFlag := true;

                  { Add a new arrow into the data base }
                  if not AddArrow( NewFrom, FromTask) then {}

                  { Draw the new arrow in clipped to the boxes it connects }
                  else begin
                     if showdates then begin
                        CalcSchedule;  Showcontents(myfolder);
                     end
                     else begin
                        { Draw the new arrow }
                        RectCntr(centerFrom, newfrom^^.box);
                        RectCntr(centerTo,   FromTask^^.box);
                        Pt2Rect(centerFrom, centerTo, visRect);
                        InsetRect(visRect, -3,-2);
                        setport(myfolder);
                        ClipRect(visRect);
                        ShowContents(myfolder);
                     end;
                  end; { else }
               End; { If }
            end; { if }

            { Done so set the CurSelRec to Air }
            NewFrom := Nil;
            Tag := Air;
         End; { NewArrow }

         TextSel,
         ChartTitle: Begin
            StartBlink( curTimeout );
            ObscureCursor;
         End; { TextSel case }

         NewTask: Begin

            { first erase the old ghost box }
            pennormal;  penmode(10);
            MoveTo(curselloc.h,curselloc.v);
            LineTo(lastmovept.h,curselloc.v);
            LineTo(lastmovept.h,lastmovept.v);
            LineTo(curselloc.h, lastmovept.v);
            LineTo(curselloc.h, curselloc.v );
            pennormal;

            { save the new mouse point and check if same as original point}
            ScaleHInt(minh, minhbox);
            scaleVInt(minv, minvbox);
            if (abs(curselloc.h - pt.h) < MinH) or
               (abs(curselloc.v - pt.v) < MinV) then
               { not large enough move to indicate user wants new task}
               Tag := air

            { otherwise we have a new task, go check it out }
            else begin

               { check for enough space for task and text records }
               if Not EnoughSpace(theHeap, SizeTaskRec + SizeTextRec) then begin
                  { not enough space to create the new task, give alert }
                  StopAlert(pealert, 50);
                  tag := air;
               end { if }
               else begin

                  { enough space, go ahead and create it }
                  CreateTask(pt, task1);
                  docChangedFlag := true;
                  ShowPert;

                  { assume user wants to type in text right away }
                  if scale[pert].state = scalereal then begin
                     RectCntr(centerPt, task1^^.box);
                     BoxInt(Task1, centerPt);
                  end
                  else tag := air;
               end; { else }
            end;  { else }
         End; { NewTask }
      End; { Case }
   End; { With }
   firstmove := false;
End; { PertUp }


{------------------------------------------------------------------------------}


Procedure PertDown{( DownPt: point )};
{ Handles a mousedown in the Pert folder. }

label 10;

const padding = 8;
var
   found:     boolean;
   Task1,              { task downed on                      }
   Task2:     hTask;   { dest task when user downs on arrow  }
   center1,
   center2:   point;
   MovePt:    point;
   perimeter: boolean; { bool for hit test, internal or perim}
   error:     boolean; { error bool return from deselect proc}
   I:         integer; { chart title hit                     }
   theRect:   rect;
   HitBool:   boolean;

Begin { PertDown }

   ClipPert;
   with curselrec[pert] do begin

      { Store the mouse position into oldmouse to prepare for a Task move }
      oldmouse  := DownPt;
      firstmove := true;
      curselloc := oldmouse;

      found := false;
      if ((tag=textsel)or(tag=chartTitles)) and ((clickCount=2)or(clickCount=3))
      then begin
         found := true;
         if tag = textsel then begin
            if clickcount = 2 then
               SelectWord(downpt, htaskfield, hfstate, curnbrhood, curtimeout)
            else begin
               ExitFIeld(htaskfield, hfstate);
               SelectAll(htaskfield, hfstate, curtimeout);
            end;
         end
         else begin
            if clickcount = 2 then
               SelectWord(downpt, Titles[fldrId][index].htitlefield,hfstate,
               curnbrhood, curtimeout)
            else begin
               Exitfield(Titles[fldrId][index].htitlefield, hfstate);
               SelectAll(titles[fldrid][index].htitlefield, hfstate, curtimeout);
            end;
         end;
      end
      else if (tag = task) then begin
         knob := knobhit( curtask, downpt );
         if knob <> none then begin
            found := true;
            ScaleRect(CurrentBox, curtask^^.box);
            { set min box size for box grow and shrink }
            ScaleHInt(HBoxMin, MinHBox);
            HBoxMin := CMax(CMax(MaxRescH(curtask), MaxTextH(curtask)) * 2, HBoxMin);
            ScaleVInt( VBoxMin, MinVBox);
            VBoxMin := CMax(trunc((LineCount(curtask) + RescCount(curtask))*p15lspace * Scale[pert].factor),
                       VBoxMin);
            if curtask^^.milestone then begin
               if trunc(VBoxMin * 1.5) > HBoxMin
               then HBoxMin := trunc(VBoxMin * 1.5)
               else VBoxMin := trunc(HBoxMin * 0.66);
            end; { if }
            HboxMin := trunc(PertFontInfo[pert].actual * hboxMin);
            VBoxMin := trunc(PertFontInfo[pert].actual * vboxMin);
         end; { if }
      end;

      if not found then begin
         PertDeselect( error );
         if error then begin
            Goto 10;  { error, skip the up event also }
         end { if }
         else begin

            { See if we hit a task or arrow. }
            clipPert;
            if HitTestPert( downpt, false{tracking},HitBool, perimeter, Task1, Task2) then begin
               If HitBool Then begin
                  ScaleRect( theRect, task1^^.box);
                  ScrollinRect( theRect);
                  If perimeter Then BoxPerim( task1, oldmouse )
                  else BoxInt( Task1, oldmouse );
               end
               { Missed the boxes. Hit an arrow.}
               else begin

                  RectCntr(Center1, task1^^.box);
                  RectCntr(Center2, task2^^.box);
                  Pt2Rect( center1, center2, theRect );
                  ScrollInRect( theRect);
                  tag := arrow1;
                  taskfrom := task1;
                  taskto := task2;
                  ArwClipRgn := NewRgn;
                  DrawSelected;
               End; { else }
            end { if }

            { see if we hit a chart title, check only if in scale real mode }
            else begin
               if scale[pert].state = scalereal then TitleHit(downpt,Pert, I, found);
               if found then begin
                  {ScrollInRect(Titles[Pert][I].htitlefield^^.coords);}
                  tag := ChartTitle;
                  index := I;
                  fldrId := Pert;
                  InitFstate( Titles[FldrId][index].hTitlefield, hfstate);
                  Select( downpt, Titles[FldrId][index].hTitlefield,
                  hfstate, curNbrhood, curTimeout);
                  oldCoords := Titles[FldrId][index].hTitlefield^^.coords;
               end
               else begin
                  { missed everything, got new task }
                  tag := newtask;
                  lastmovept := oldmouse;
                  pennormal;
                  penmode(10);
               end; { else }
            end; { else }
         end; { else }
      end; { if }

      { generate the simulated pert move events }
      If StillDown then begin
         { set the nbhd to be the rect immediately around the down point }
         SetRect(curNbrhood, oldmouse.h - dhNbhd, oldmouse.v - dvNbhd,
            oldmouse.h + dhNbhd, oldmouse.v + dvNbhd);

         While StillDown Do begin
            GetMouse(MovePt);
            if Not PtinRect(Movept, curnbrhood) then begin
               PertMove(MovePt);
               setrect(curnbrhood, movept.h - dhNbhd, movept.v - dvNbhd,
               movept.h + dhNbhd, movept.v + dvNbhd);
            end; { if }
        end; { while }
      end; { if }
10:end; { with }
End; { PertDown }



{------------------------------------------------------------------------------}


Procedure TabtoNextField( shift: boolean; var error: boolean );
{ This guy is tough, shift tab and tab are handled here }

var nextline:    htext;
    nextResc:    hresc;
    Ok:          boolean;
    newduration: integer;
    newresc:     hresc;

begin { TabToNextField }

   if curselrec[pert].tag = textsel then
   with curselrec[pert] do begin

      { get out of exit on current field }
      Exitfield(htaskfield,hfstate);
      error := false;

      { was this an edit of task title ?? }
      if EditingTitle then begin
         RestoreTitle( curline, htaskfield );
         { set up next field for edit }
         if not shift then begin
            { move to next lower field }
            curline := curline^^.next;
            if curline = nil then begin
               if newfrom^^.milestone then error := true
               else begin
                  { move to the next lower field, in this case first resource }
                  EditingTitle := false;
                  EditingDuration := false;
                  if newfrom^^.resource = nil  then begin
                     { create a new resource line }
                     NewRescLine( newresc);
                     newfrom^^.resource := newresc;
                     curresc := nil;
                     CkVGrowth;
                  end; { if }
                  curresc := newfrom^^.resource;
                  SetUpResc( curresc, htaskfield );
                  SetFAlign( htaskfield, nil, right );
                  GetNDx(newfrom, curresc, dx);
               end; { else }
               recalc := true;
            end { if }
            else begin
               { set up next line of text }
               SetUpTitle( curline, htaskfield );
               GetDx(newfrom,curline, dx);
            end; { else }
         end { if }
         else begin
            { got a shift-tab, if this is the first line then error }
            if curline = newfrom^^.title then error := true
            else begin
               { set up previous line }
               nextline := newfrom^^.title;
               while nextline^^.next <> curline do nextline := nextline^^.next;
               curline := nextline;
               SetUpTitle(curline,htaskfield);
               GetDx(newfrom, curline, dx);
            end; { else }
         end; { else }
      end { if }

      { or resource name or duration?? }
      else begin
         if EditingDuration then begin
            { check out the new value }
            EditCheckDuration( curresc, newduration, Ok );
            If OK then begin
               RestDuration( curresc, htaskfield );
               curresc^^.duration := newduration;
               curresc^^.remaining := newduration;
               { set up for next edit }
               if not shift then
                  { go to next line if one exists, otherwise error }
                  if curresc^^.next = nil then error := true
                  else curresc := curresc^^.next;
               if not error then begin
                  SetUpResc( curresc, htaskfield );
                  GetNDx(newfrom, curresc, dx);
                  SetFAlign( htaskfield, nil, right );
                  EditingDuration := false;
               end; { if }
            end { if }
            { doesn't look like a good duration value }
            else begin
               error := true;
               StopAlert(PEAlert, 12 {Bad Duration Value});
               EraseRect(htaskfield^^.coords);
               RestoreOldValue(curresc);
               DrawField( htaskfield, nil, false,true );
            end; { else }
         end { if }

         else begin
            { we were editing the resource name field }
            XRestoreResc( curresc, htaskfield );
            { move to next field }
            if shift then begin
               { got a shift, move to higher line, duration field or text line}
               if curresc = newfrom^^.resource then begin
                  { we were on first resc line, move to last text line }
                  curline := newfrom^^.title;
                  if curline = nil then begin
                     { create a new text line }
                     NewTextLine( curline );
                     curline^^.next := nil;
                     newfrom^^.title := curline;
                     SetUpTitle(curline,htaskfield);
                     SetFAlign( htaskfield, nil, center );
                     CkVGrowth;
                  end
                  else begin
                     { find the last text line }
                     while curline^^.next <> nil do curline := curline^^.next;
                     SetUpTitle(curline,htaskfield);
                     SetFAlign(htaskfield, nil, center);
                  end;
                  GetDx(newfrom, curline, dx);
                  EditingTitle := true;
                  curresc := nil;
               end { if }
               else begin
                  { next higher duration field }
                  nextresc := newfrom^^.resource;
                  while nextresc^^.next <> curresc do nextresc := nextresc^^.next;
                  curresc := nextresc;
                  { set up for edit of duration field }
                  SetUpDuration( curresc, htaskfield );
                  SetFAlign( htaskfield, nil, left );
                  GetDDx(newfrom, curresc, dx);
                  EditingDuration := true;
               end;
            end { if }
            else begin
               { no shift here }
               { set up for edit of duration field }
               SetUpDuration( curresc, htaskfield );
               SetFAlign( htaskfield, nil, left );
               GetDDx(newfrom, curresc, dx);
               EditingDuration := true;
            end; { else }
         end; { else }
      end; { else }
   end; { with  }
end; { TabtoNextField }


{------------------------------------------------------------------------------}


Procedure PertKey{(theEvent: EventRec)};
{ This procedure handles a keystroke in the pert folder. Note that we are
  currently ignoring the arrow keys and shift-tab. }


var
   errnum:    integer;       { error byte for field edit }
   error:     boolean;       { error flag for new edits  }
   newline:   hText;         { new  line of text edited  }
   I:         integer;       { counter                   }
   key:       char;          { the key that was entered  }
   newduration: integer;
   ok:        boolean;
   theline:   htext;
   thetask:   htask;
   newresc:   hresc;

Begin { PertKey }

   undoValid := true;
   AnyToUndo := true;
   with curselrec[pert] do
   if (tag = textsel) then begin
         ObscureCursor;
         key := theEvent.ascii;
         docChangedFlag := true;
         case ord(key) of

            ArwLeft,
            ArwUP,
            ArwRight,
            ArwDown: begin
               { ignore these keys for now }
            end;

            Clear: begin
               ClearField(htaskfield, hfstate, errnum);
               PEDrawFldAt( htaskfield, hfstate, dx, true, true);
            end;

            Enter: begin
               { enter and stay, check duration value }
               ExitField(htaskfield, hfstate);
               if EditingTitle then SelectAll(htaskfield, hfstate, curtimeout)
               else begin
                  if EditingDuration then begin
                     EditCheckDuration( curresc, newduration, Ok );
                     if Ok then begin
                        RestDuration(curresc, htaskfield);
                        curresc^^.duration  := newduration;
                        curresc^^.remaining := newduration;
                        CalcMaxDuration ( newfrom );
                        if showdates then begin
                           CalcSchedule;
                           Showcontents(myfolder);
                        end; { if }
                        SetUpDuration(curresc,htaskfield);
                        SelectAll(htaskfield, hfstate, curtimeout);
                     end { if }
                     else begin
                        StopAlert(PEAlert, 12 {Bad Duration Value});
                        EraseRect(htaskfield^^.coords);
                        RestoreOldValue(curresc);
                        DrawField( htaskfield, nil, false,true );
                        tag := air;
                     end; { else }
                  end { if }
                  else begin
                     { must be the resource name }
                     XRestoreResc( curresc, htaskfield );
                     if showdates then begin
                        CalcSchedule;
                        showContents(myfolder);
                     end;
                     SetUpResc( curresc, htaskfield);
                     SelectAll(htaskfield, hfstate, curtimeout);
                  end; { else }
               end; { else }
            end; { Enter }

            TabKey:  begin
               UndoValid := false;
               TabtoNextField( theEvent.shiftKey, error);
               { have we got something else to set up?? }
               if not error then begin
                  MoveField(htaskfield, nil, dx );
                  SelectAll(htaskfield, hfstate,curtimeout);
               end
               else begin
                  CalcMaxDuration(newfrom);
                  tag := air;
                  if showdates then begin
                     calcSchedule;
                     showContents(myfolder);
                  end;
               end;
            end; { tab }

            Return: begin
               UndoValid := false;
               Exitfield(htaskfield,hfstate);
               { was this an edit of task title ?? }
               if EditingTitle then begin
                  RestoreTitle( curline, htaskfield );

                  { set up next field for edit, create a new one }
                  { but only if not on last line and its empty   }
                  if curline^^.curlen <> 0 then begin
                     NewTextLine( newline );
                     newline^^.next := curline^^.next;
                     curline^^.next := newline;
                     curline := newline;
                  end;
                  { set up next line of text }
                  SetUpTitle( curline, htaskfield );
                  InitFState(htaskfield, hfstate);
                  CkVGrowth;
                  GetDx(newfrom, curline, dx);
                  Select( dx ,htaskfield, hfstate, curNbrhood, curTimeout);
               end { if }

               else begin
                  if EditingDuration then begin
                     RestDuration( curresc, htaskfield );
                     EditCheckDuration( curresc, newduration, Ok );
                     If OK then begin
                        curresc^^.duration := newduration;
                        curresc^^.remaining := newduration;

                        { set up for next edit }
                        if (curresc^^.Dcurlen <> 0) or
                           (curresc^^.Rcurlen <> 0) then
                        begin
                           NewRescLine( newresc);
                           newresc^^.next := curresc^^.next;
                           curresc^^.next := newresc;
                           curresc := newresc;
                        end;
                        SetUpResc( curresc, htaskfield );
                        SetFAlign( htaskfield, nil, right );
                        EditingDuration := false;
                        InitFState(htaskfield, hfstate);
                        CkVGrowth;
                        GetNDx(newfrom, curresc, dx);
                        Select( dx ,htaskfield, hfstate, curNbrhood, curTimeout);
                     end { if }

                     { doesn't look good }
                     else begin
                        StopAlert(PEAlert, 12 {Bad Duration Value});
                        EraseRect(htaskfield^^.coords);
                        RestoreOldValue(curresc);
                        DrawField( htaskfield, nil, false,true );
                        tag := air;
                     end; { else }
                  end { if }
                  else begin
                     { must be the resource name field }
                     XRestoreResc( curresc, htaskfield );
                     { set up for next edit }
                     if (curresc^^.dcurlen <> 0) or
                        (curresc^^.Rcurlen <> 0) then
                     begin
                        NewRescLine( newresc);
                        newresc^^.next := curresc^^.next;
                        curresc^^.next := newresc;
                        curresc := newresc;
                     end;
                     SetUpResc( curresc, htaskfield );
                     EditingDuration := false;
                     InitFState(htaskfield, hfstate);
                     CkVGrowth;
                     GetNDx(newfrom, curresc, dx);
                     Select( dx ,htaskfield, hfstate, curNbrhood, curTimeout);
                  end; { else }
               end;
            end;

            BSpace: begin
               if theEvent.shiftkey and not theEvent.AppleKey then
                  ForwardSpace(htaskfield, hfstate, errnum)
               else if not theEvent.shiftKey and theEvent.AppleKey then
                  BackWord(htaskfield, hfstate, errnum)
               else if theEvent.shiftKey and theEvent.AppleKey then
                  ForwardWord(htaskfield, hfstate, errnum)
               else begin
                  BackSpace( htaskfield, hfstate, errnum);
               end;
               PEDrawFldAt( htaskfield, hfstate, dx, true, true);
            end; { BSpace }

            otherwise begin
               { make sure no more than 50 characters are entered into the field}
               if (htaskfield^^.curlen >= 50) and
                  ((hfstate^^.select.int.lpLim - hfstate^^.select.int.lpFst) = 0)
               then StopAlert(pealert, 51 {Hit Text Limit})
               else begin
                  InsCh ( key, htaskfield, hfstate, errnum);
                  CkHGrowth;
               end; { else }
            end; { otherwise }
         end; { case }
   end { if }
   else begin
      if tag = ChartTitle then begin
         obscureCursor;
         docChangedFlag := true;
         TitleKey(pert, index, theEvent.ascii, theEvent.shiftKey, theEvent.AppleKey);
      end { if }
      else begin
         ParamAlert('type','','');
         StopAlert(pealert, 45 {Selection Required});
      end; { else }
   end; { else }
End; { PertKey }

{------------------------------------------------------------------------------}


Procedure CkHGrowth;
{ called on new character or on a paste }

var newwidth: integer;
    centerH:  integer;
    sizeH:    integer;
    sizeV:    integer;
    newbox,
    Sbox:     rect;
    Sdot:     integer;

begin { CkHGrowth }

   with curselrec[pert] do begin
      if tag = textsel then begin
         ScaleRect( Sbox, newfrom^^.box);
         EraseRect( htaskfield^^.coords);

         { see if current line of edit is causing a grow }
         newwidth := cMax(maxTextH(newfrom), maxRescH(newfrom)) * 2;

         if newWidth  > (newfrom^^.box.right - newfrom^^.box.left) then begin

            { got an update of width only, redraw current line and boundary }
            CenterH :=  (newfrom^^.box.right + newfrom^^.box.left) div 2;
            Newfrom^^.box.left := centerH - newwidth div 2;
            newfrom^^.box.right :=centerH + newwidth div 2;

            if newfrom^^.milestone then NormVMS(newfrom^^.box);
            ScaleRect(newbox,newfrom^^.box);
            pennormal; penpat( white );
            pensize(newbox.right  - Sbox.right + dHcritical + 2,
                    newbox.bottom - Sbox.bottom + dVcritical + 2);

            { frame the box or oval to erase the old delta }
            if newfrom^^.milestone
               then frameoval( newbox )
               else framerect( newbox );

            { now draw the new frame }
            pennormal;
            if Critical(newfrom) then pensize(dHcritical, dVcritical);
            if newfrom^^.milestone then newfrom^^.dotline := newfrom^^.box.bottom - newfrom^^.box.top;
            if showdates then begin
               InsetRect(newbox, -30, -30);
               with myfolder^ do ClipRect( newbox );
               Showcontents(myfolder);
            end
            else begin
               if newfrom^^.milestone then begin
                  frameoval( Newbox );
                  PeDrawFldAt(htaskfield, hfstate, dx, true, true );
               end { if }
               else begin
                  framerect( Newbox );
                  ScaleVInt(sdot,newfrom^^.dotline);
                  DrawDotLine( newfrom, Newbox, Sdot );
                  peDrawFldAt( htaskfield, hfstate, dx, true, true);
               end; { else }
            end; { else }
         end
         else PeDrawFldAt( htaskfield, hfstate, dx, true, true);
      end;
   end;
end; { CkHGrowth }


{-------------------------------------------------------------------------------}


Procedure CkVGrowth;

const padding = 6;

var   locHeight: integer;
      deltaV:    integer;
      newbox:    rect;
      growth:    boolean;

begin { CkVGrowth }

   { check if the newline causes a growth of the box }
   { always a redraw of all text lines whether growth or not to relay out text }
   with curselrec[pert] do begin
      if tag = textsel then begin
         growth := false;

         if editingTitle then begin
            { new title field }
            locHeight := trunc((padding + LineCount(newfrom) *
               PertFontInfo[Pert].lspace) * 1/(Scale[activechart].factor * PertFontInfo[activechart].actual));
            if newfrom^^.milestone then locHeight := trunc(locHeight * Pi);

            if locHeight > newfrom^^.dotline then begin
               { got a growth }
               deltaV  := trunc((locHeight - newfrom^^.dotline) / 2.0 + 0.99);
               SetRect( newbox, newfrom^^.box.left,
                                newfrom^^.box.top - deltaV,
                                newfrom^^.box.right,
                                newfrom^^.box.bottom + deltaV);
               if newfrom^^.milestone then NormHMs( newbox );
               newfrom^^.dotline := locHeight;
               newfrom^^.box := newbox;
               growth := true;
            end;
         end
         else begin
            { new resource name or duration }
            locHeight := trunc((RescCount(newfrom) * PertFontInfo[Pert].lspace
               + padding) * 1/(Scale[activechart].factor * PertFontInfo[activechart].actual));
            if locHeight > (newfrom^^.box.bottom -
               newfrom^^.box.top - newfrom^^.dotline)
            then begin
               { got a growth }
               DeltaV  := trunc((locHeight - (newfrom^^.box.bottom - newfrom^^.box.top -
                          newfrom^^.dotline)) / 2.0 + 0.99);
               SetRect( Newbox, newfrom^^.box.left,
                                newfrom^^.box.top - deltaV,
                                newfrom^^.box.right,
                                newfrom^^.box.bottom + deltaV);
               newfrom^^.box := newbox;
               growth := true;
            end;
         end;
         { redraw all text in box }
         if ShowDates and growth then begin
            scalerect(newbox,newbox);
            InsetRect(newbox, -20, -20);
            with myfolder^ do ClipRect( newbox );
            Showcontents(myfolder);
         end
         else begin
            ScaleRect(newbox, newfrom^^.box);
            DrawTask( newfrom, newbox );
         end; { else }
      end; { if }
   end; { with }
end; { CkVGrowth }


END. { Unit }
