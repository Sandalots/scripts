{----------------------------------------------------------------------------}
{                                                                            }
{                  Copyright 1983,1984, Apple Computer Inc.                  }
{                                                                            }
{----------------------------------------------------------------------------}

{ 12/13/83 now this is an include file for aplp/pert }

{--------------------------------------------------------------------------------

            schedule calculations, private.

 -------------------------------------------------------------------------------}

{$S MainLoop}

Procedure CreateGantt; external;
Procedure CreatTbl; external;  { in aplp/Cost }

function xcntrcoord ( box: rect ): integer;
{ This procedure exists simply to return the xcoordinate value from the
   center point of the rectangle.  }

var pt: point;

begin { xcntrcoord }

   Rectcntr( pt, box );
   xcntrcoord := pt.h;

end; { xcntrcoord }



{-------------------------------------------------------------------------------}



Procedure AllocResources;
{  This procedure does the actual scheduling of the network data.
   First the vars of the task record for each task are initialized.
   The heuristic value is calculated for each task.  Then the procedure
   steps through time allocating resources to tasks.  Finally the
   latestart times are calcualted.  The algorithm is taken from Moder
   and Phillips, 'Management with Pert and CPM.

   The algorithm is based on three sets, MFN, the initial multiple end
   nodes,  EAS, the eligible activity set, and OSS, the ordered scheduling
   set.  The EAS is the set of tasks whose predecessors are currently scheduled,
   or those that are eligible to be scheduled.  The OSS is the set of
   tasks whose earlystart is <=  the current time. The tasks in this set
   are scheduled based on increasing latestart times and durations. }

const
   maxtasks = 100;        { max number tasks for scheduling algorithm  }


var
   MFN,                                       { Multiple Finish Nodes  }
   EAS:      array[1..maxtasks] of hTask;     { Eligible Activity Set  }
   lenMFN,                                    { length of MFN array    }
   lenEAS,                                    { length of EAS array    }
   Time,
   lastFinish,                                { largest finish time    }
   I,J:      integer;                         { counters               }
   Done:     boolean;                         { schedule until done    }
   LSHead:   htask;
   SchedIndex: integer;
   SchedDay:   integer;
   SchedFlag:  boolean;

{-------------------------------------------------------------------------------}


Procedure LateStart;
{ calculates all the latestart times for tasks that got scheduled }

VAR
   curtask:     htask;
   curresc:     hresc;
   Myduration:  integer;
   MyLatestart: integer;
   i:           integer;

Begin  { Latestart }

   { look through LS list generated by ScheduleTasks procedure }
   curtask := LSHead;
   while curtask <> nil do begin

      MyDuration := curtask^^.maxduration;
      MyLatestart := maxval;

      { get constraints from successor tasks }
      if (curtask^^.NForward = 0) then with curtask^^ do begin

         { if the task is a finish node, set mylatestart to the latest of all
         finish dates. If user set a finish date to add slack, then use this }
         if (setFinish = minval) then MyLatestart := lastfinish
         else MyLateStart := CMax(earlystart, SetFinish - myduration);
      end { if }

      else with curtask^^ do begin
         for i := 0 to NForward - 1 do begin
            {$R-}
            Mylatestart := CMin(MyLatestart, Link[i]^^.latestart - MyDuration);
            {$R+}
         end; { for }
      end;

      { now see if this guy has resource constraints also }
      If (limitresources) Then Begin
         curresc := curtask^^.resource;
         while curresc <> nil do begin
            if curresc^^.PrevResc <> nil then with curresc^^ do begin
               { look at latestart for previous task with same resource }
               if rname^^.curlen > 0 then begin
                  MyLatestart := CMin( MyLatestart, Prevresc^^.task^^.latestart - duration);
               end;
            end;
            curresc := curresc^^.next;
         end; { while }
      end;

      { last we must check if curtask has a setfinish time }
      With curTask^^ do if (SetFinish = minval) then latestart := myLatestart
      else latestart := CMin(myLatestart, SetFinish - Myduration);

      curtask := curtask^^.LSSched;
   end; { while }

End; { Latestart }


{-------------------------------------------------------------------------------}


Function NullFields( var StartTime: integer): boolean;
{  NullFields sets some vars in the task records to their initial values.
   The only error condition is if the user has more than maxtasks start
   nodes or end nodes. }

var
   Current:   hTask;    { the current task rec that we are init'ing }
   curname:   hName;    { the current resc name record to init      }
   thisStart: integer;  { the work day offset for starting time     }
   Error:     boolean;  { true if too many starts or ends           }

Begin { NullFields }

   { start at the head }
   current := Head;
   error := false;

   While (Current <> Nil) Do Begin

      With Current^^ Do Begin
         { Set the vars to their unscheduled values }
         earlystart := 0;
         LateStart  := MaxVal;
         scheduled  := false;

         { if no back links then add to EAS list }
         if NBackward = 0 then begin
            if lenEAS >= maxtasks then error := true
            else begin

               { add task to eas }
               LenEAS := lenEAS + 1;
               EAS[lenEAS] := current;

               { if setstart undefined, then use day 0 }
               if SetStart = maxval then thisStart := 0
               else thisStart := setStart;
               startTime := CMin(startTime, thisStart);
            end; { else }
         end; { if }

         { if no forward links then add to MFN list }
         if NForward = 0 then begin
            if lenMFN >= maxtasks then error := true
            else begin
               lenMFN := lenMFN + 1;
               MFN[lenMFN] := current;

               { get the largest set finish time }
               if SetFinish = minval then {}
               else lastFinish := CMax( lastFinish, setfinish);
            end; { else }
         end; { if }
      end; { with }

      Current := Current^^.fLink;
   End; { While }

   { reset scheduled list to nil }
   curname := names;
   while curname <> nil do begin
      curname^^.schedule := nil;
      curname^^.currentavail := 0;
      curname := curname^^.next;
   end; { while }

   { do we have a problem with this network? }
   NullFields := Not error;
End; { NullFields }


{-------------------------------------------------------------------------------}



Function ScheduleTasks(var None: boolean; var lastFinish: integer ): boolean;
{  This procedure schedules all tasks that it can in the current time
   period.  It also sets None true on return if there are no more tasks
   left to be scheduled in the EAS set. }

var
   index:        integer;     { current index into OSS set }
   task,                      { the task to be scheduled   }
   successor:    hTask;       { tasks successors           }
   i,
   N,M:          integer;     { counters                   }
   MS,                        { is this a milestone?       }
   found:        boolean;     { search till found          }
   allscheduled: boolean;     { all predecessors schedule? }
   schedable:    boolean;     { is task schedule-able?     }
   curavail:     integer;     { time resource is available }
   curresc:      hResc;       { current resource record    }

{-------------------------------------------------------------------------------}

Function SneakIn( schedIndex, SchedDay, SneakIndex: integer): boolean;
{ returns true if sneaktask can be scheduled without affecting the start time
  of the schedtask.  In particular:
     returns true if all the resources required by sneak task
     also requried by schedtask can be finished beore schedtask's
     scheduled day.  }

var CanSneakIn: boolean;
    schedtask: htask;
    sneaktask: htask;
    schedResc: hresc;
    sneakResc: hresc;
    sneakName: hname;

begin

   { assume we can sneak it in until proven otherwise }
   CanSneakIn := true;
   schedtask := EAS[SchedIndex];
   sneaktask := EAS[sneakIndex];

   { for each of sneaktask's resources, see if schedTask has same resource }
   sneakresc := sneakTask^^.resource;
   while (CanSneakIn and (sneakresc <> nil)) do begin
      sneakName := sneakResc^^.rname;
      if sneakname = nil then {}
      else begin
         if sneakname^^.curlen = 0 then {}
         else begin

            { got a sneaktask resource, check schedtask resource list }
            schedresc := schedtask^^.resource;
            while schedResc <> nil do begin
               if schedResc^^.rname <> nil then begin

                  { same resource name ? }
                  if sneakname = schedresc^^.rname then begin

                     { return false if sneak task uses a resource making it impossible to schedule
                       schedtask at the desired time }
                     CanSneakIn := ((sneakname^^.currentavail + sneakResc^^.duration) <= SchedDay);
                  end; { if }
                  schedResc := schedResc^^.next;
               end;
            end; { while }
         end; { else }
      end; { else }
      sneakresc := sneakResc^^.next;
   end; { while }

   SneakIn := CanSneakIn;
end;

{-------------------------------------------------------------------------------}

Procedure AssignSched( NewIndex: integer; NewDay: integer; NewFlag: boolean);

begin
   SchedIndex := NewIndex;
   SchedDay   := NewDay;
   SchedFlag  := NewFlag;
end;


{-------------------------------------------------------------------------------}

Procedure PickEarly( index, newDay: integer; NewFlag: boolean);
{ resets schedIndex, schedDay, and SchedFlag if index task should
  be scheduled before the schedIndex one. }
{ Picks index to be best task:
        if it has an earlier scheduled date,
        if the scheduled dates are equal then
           if it has an earlier technological earlystart,
           if these are equal then,
              if it has a shorter duration,
              if these are equal then,
                 if it has a smaller v coordinate on
                 the task box.   }

VAR
   reset: Boolean;

begin
   Reset := False;
   { Reset absolutely if the new day is sooner than the previous best }
   If (newDay < schedDay) then Reset := True
   Else If (newday = schedDay) then with EAS[SchedIndex]^^ do begin

      { the scheduled days are =, so smaller earlystart goes first }
      if (EAS[Index]^^.earlystart < earlystart) then Reset := True

      else if EAS[Index]^^.earlystart = earlystart then begin

         { the early starts are also =, so the shorter duration goes first }
         if (EAS[index]^^.maxduration < maxduration) then Reset := True

         else if (EAS[index]^^.maxduration = maxduration) then begin
            { the durations are also =, so the smaller v coordinate goes first }
            Reset := (EAS[index]^^.box.top < box.top);
         end; { else }

      end; { if }
   end; { If }
   If Reset then AssignSched(Index, NewDay, NewFlag);
end; { PickEarly }

{-------------------------------------------------------------------------------}


Procedure GetDate( Index: integer; var Day: integer; var Flag: boolean);
{ returns the earliest date Task can be scheduled,  i.e. Max(scheduled date,
  max(curavail), earlystart).  Sets SchedFlag to true if that date is a scheduled one. }

var task: htask;
    MaxCuravail: integer;
    curresc:  hresc;

begin { GetDate }

   { get the maximum curavail for all resources used }
   task := EAS[Index];
   MaxCuravail := task^^.earlystart;

   If (limitResources) Then Begin
      curresc := task^^.resource;
      while curresc <> nil do begin
         { the resource name with 0 characters is an exception }
         if (curresc^^.rname <> nil) Then with curresc^^.rname^^ do Begin
            if (curlen > 0) then Begin
               MaxCuravail := CMax( MaxCuravail, currentavail);
            end;
         end;
         curresc := curresc^^.next;
      end; { while }
   end;

   { see if task has a scheduled start date, this will push out day }
   Flag := (task^^.SetStart <> maxval);
   if Flag then Day := CMax(MaxCuravail, task^^.SetStart)
   else Day := MaxCuravail;

end; { GetDate }


{-------------------------------------------------------------------------------}


Procedure GetTask;
{ Find the "best" task to schedule.  That will be the one we schedule next.}

var i: integer;
    newDay: integer;
    NewFlag: boolean;

begin { GetTask }

   { assume it is number one in the EAS, get its numbers }
   SchedIndex := 1;
   GetDate(SchedIndex, SchedDay, SchedFlag);

   { compare current best to the rest }
   For I := 2 to lenEAS  do begin

      { Get next guys numbers also and compare the two }
      GetDate( I, NewDay, NewFlag );

      If (limitresources) then Begin
         { branch on the 4 possible combinations of the the user set scheduled flags
           of the two tasks }
         if SchedFlag then begin
            If NewFlag then begin

               { both are scheduled, pick the earlier one }
               PickEarly( I, NewDay, NewFlag);
            end { if }
            else begin

               { schedule new one if can finish before current one scheduled to begin }
               if SneakIn( SchedIndex, SchedDay, I) then begin
                  AssignSched( I, NewDay, NewFlag);
               end; { if }
             end; { else }
          end { if }
          else begin

             { new one scheduled, current one not scheduled }
             if NewFlag then begin
                { do nothing if current one completes before new one is scheduled }
                if SneakIn( I, newDay, SchedIndex ) then begin
                   { do nothing since current task completes before newtask starts }
                end
                else begin
                   { assign the new one since it's scheduled to start and the
                     current one would push it out }
                   AssignSched( I, NewDay, NewFlag );
                end; { else }
             end { if }

             { none scheduled, pick the one with the earliest date }
             else begin
                PickEarly( I, NewDay, NewFlag);
             end; { else }
          end; { else }
       end { if on limitresources }

       { if not using resources, just pick the earliest }
       else PickEarly(I, NewDay, NewFlag);
    end; { for }
end; { GetTask }


{-------------------------------------------------------------------------------}


begin { ScheduleTasks }

   { defines globals SchedIndex, SchedDay, and SchedFlag for selected task }
   Gettask;
   task := EAS[SchedIndex];

   { remove this task from the EAS list }
   { be sure to not rearrange EAS ordering when you remove the
     task, ordering encourages breadth-first scheduling of tasks }
   {for i := schedIndex to lenEas - 1  do
      EAS[i] := EAS[i+1];
   lenEAS := lenEAS - 1;}

   { I task the last comment back, remove the
     task from the EAS and dont worry about remaining
     order of EAS }
   EAS[SchedIndex] := EAS[lenEAS];
   lenEAS := lenEAS - 1;

   { update current available array for this resource if task is not
     a milestone event. }
   if not task^^.milestone then begin
      curresc := task^^.resource;
      while curresc <> nil do begin
         { the rescource name with 0 characters is an exception }
         if curresc^^.rname = nil then {}
         else if curresc^^.rname^^.curlen = 0 then {}
         else begin
            curresc^^.rname^^.currentavail := SchedDay + curresc^^.duration;
         end; { else }
         curresc := curresc^^.next;
      end; { while }
      curavail := SchedDay + task^^.maxduration;
   end { if }
   else curavail := SchedDay;

   { keep last finish up to date }
   lastFinish := CMax( lastFinish, curavail);

   { keep a record of its scheduled time with each resource consumed }
   task^^.earlystart := SchedDay;
   task^^.scheduled := true;
   task^^.latestart := maxval;
   if not task^^.milestone then begin
      curresc := task^^.resource;
      while curresc <> nil do begin

         { put this resc record on head of sched list }
         curresc^^.task := task;  { dont really need this here }
         if curresc^^.rname^^.schedule <> nil
         then curresc^^.rname^^.schedule^^.prevResc := curresc;
         curresc^^.nextResc := curresc^^.Rname^^.schedule;
         curresc^^.prevResc := nil;
         curresc^^.Rname^^.schedule := curresc;

         { fill in the other pointer also for task chart }
         if curresc^^.next = nil then begin
            curresc^^.nextTask := ESOrder;
            ESOrder := curresc;
         end
         else curresc^^.nextTask := nil;
         curresc := curresc^^.next;
      end;
   end; { if }

   { link tasks on a latestart list }
   task^^.LSSched := LSHead;
   LSHead := task;


   { now adjust and add successors of task to EAS }
   for N := 0 to task^^.NForward - 1 do begin

      {$R-}
      successor := task^^.Link[N];
      {$R+}

      { update the earlystart for this guy so he doesnt get scheduled
        before the time the resource is available  }
      if successor^^.earlystart < curavail then successor^^.earlystart := curavail;

      { see if all his predecessors have been scheduled }
      allschedule := true;
      For M := successor^^.NForward to (successor^^.NForward + successor^^.NBackWard - 1) do begin
         {$R-}
         allscheduled := allscheduled and successor^^.Link[M]^^.scheduled;
         {$R+}
      end; { for }

      { they all have, so put him in }
      if allscheduled then begin
         if lenEAS >= maxtasks then begin
            { cant schedule this chart, get out of here gracefully }
            ScheduleTasks := false;
            Exit(ScheduleTasks);
         end { if }
         else begin
            lenEAS := lenEAS + 1;
            {$R-}
            EAS[lenEAS] := successor;
            {$R+}
         end; { else }
      end { if }
      else {};
   end; { for }

   { check to see if we are completely done }
   None := (lenEAS = 0);
   Scheduletasks := True;
end; { ScheduleTasks }

{-------------------------------------------------------------------------------}


begin { AllocResources }

   { initialization of schedule vars & fill EAS }
   lenEAS := 0;
   lenMFN := 0;
   lastFinish := minval;
   ESOrder := nil;
   LSHead := nil;
   Time := maxval;
   if NullFields( Time ) then begin   { also sets the initial start time }

      { save the real equiv of initial start time }
      StartTime := RDEquiv( Time );

      { start scheduling all the tasks }
      Done := (head = nil);
      while not done do begin
         if ScheduleTasks(Done, lastfinish) then {}
         else begin
            { cant calc a schedule for this chart, violated maxtasks limit }
            if ImActive then StopAlert(pealert, 52 {Max Eligible});
            Exit(AllocResources);
         end; { else }
      end;

      LateStart;

      { save the ending time for gantt and task charts }
      EndTime := RDEquiv(lastFinish)
   end { if }

   { if nullfields fails, cant calc a schedule for this chart }
   else if ImActive then StopAlert(pealert, 52 {Max Eligible});
end; { AllocResources }


{--------------------------------------------------------------------------------

            Schedule Calculations, public.

 -------------------------------------------------------------------------------}

Procedure CalcSchedule;
{ calculates or recalculates the schedule, returns false if the schedule cannot
  be calculate.  The only case when this would happen is if the user has more than }

begin { CalcSchedule }

   { calculate the schedule }
   AllocResources;

   { create the gantt data from the new schedule }
   if (activeChart = RescGantt) or (activechart = TaskGantt) then CreateGantt

   { else create the appropriate table }
   Else if (ActiveChart > 3) Then Begin
      { Add code here to check there's no overflow displaying the timeline,
        similarly to the code in CreateGantt }

      { Now create the tabular data }
      CreatTbl; { in aplp/cost }
   end;
end; { CalcSchedule }


{-------------------------------------------------------------------------------}


Procedure UnSchedule;

var Current:   hTask;    { the current task rec that we are init'ing }

Begin { Unschedule }

   { reset earlystart and latestart }
   current := Head;
   While (Current <> Nil) Do Begin
      With Current^^ Do Begin
         EarlyStart := MinVal;
         LateStart  := MaxVal;
      end; { with }
      Current := Current^^.fLink;
   End; { While }
end; { UnSchedule }


{-------------------------------------------------------------------------------}
{                                                                               }
{           Pert data handlers, private.                                        }
{                                                                               }
{-------------------------------------------------------------------------------}

{$S Events}

Procedure CheckBackArrows( task: hTask;  var error: boolean );
{ This procedure checks to see if there are any backward arrows associated
   with this task.  All forward link records are checked to ensure that the
   destination task is beyond this task;  all backward links are checked to
   ensure the destination task is behind this task. }

var h,                 { the h coord of the center point of the task }
    i:   integer;      { link counter                                }

begin { CheckBackArrows }

   { set up current H offset for this task }
   h := xcntrcoord( task^^.box );

   { look through both forward and backward links }
   error := false;
   with task^^ do begin

      { first the forward ones }
      for i := 0 to (NForward - 1) do begin
         {$R-}
         if h >= xcntrcoord(Link[i]^^.box) then error := true;
         {$R+}
      end; { for }

      { then the backward links }
      for i := NForward to (Nforward + NBackWard - 1) do begin
         {$R-}
         if h <= xcntrcoord(Link[i]^^.box) then error := true;
         {$R+}
      end; { for }
   end; { with }

end; { CheckBackArrows }



{-------------------------------------------------------------------------------}
{                                                                               }
{           Pert data handlers, public.                                         }
{                                                                               }
{-------------------------------------------------------------------------------}


procedure DeleteArrow{(fromtask, totask:   hTask )};
{ this procedure deletes an arrow, that is both the forward link off the
  fromtask and the backward link off the totask are deleted for the arrow
  connection. }

var i,j,                { loop counters for links         }
    stop,               { stopping value for loops        }
    newsize: integer;   { the new size of the task record }

begin { DeleteArrow }

   { first delete the forward link off fromtask }
   with fromtask^^ do begin
      { find the index of the link to be deleted }
      stop := NForward - 1;
      i := 0;
      while i <= stop do begin
         {$R-}
         if link[i] = toTask then begin
            { found it so copy what follows over the one above it }
            for j := (i + 1) to (NForward + NBackWard - 1) do begin
               Link[j - 1] := Link[j];
            end;
            NForward := NForward - 1;
            i := stop + 1;
         end; { if }
         {$R+}
         i := i + 1;
      end; { while }
      newsize := sizeof(taskrec) + (Nforward + Nbackward) * 4;
   end; { with }
   ChangeSizeH(theheap, pointer(ord(fromtask)), newsize);

   { now the backward link off totask }
   with totask^^ do begin
      { find the index of the link to be deleted }
      stop := (NForward + Nbackward - 1);
      i := NForward;
      while i <= stop do begin
         {$R-}
         if Link[i] = fromtask then begin
            { found it, get rid of it }
            for j := (i+1) to (NForward + NBackWard - 1) do begin
               LInk[j-1] := link[j];
            end; { for }
            NBackward := NBackward - 1;
            i := stop + 1;
         end; { if }
         {$R+}
         i := i + 1;
      end; { while }
      newsize := sizeof(taskrec) + (Nforward + Nbackward) * 4;
   end; { with }
   ChangeSizeH(theheap,  pointer(ord(totask)), newsize);

end; { DeleteArrow }


{-------------------------------------------------------------------------------}



Procedure RemoveTask {( task:   hTask)};
{ this procedure deletes a task and deletes all forward and backward
  links from this task and their complement backward and forward links.
  Note that the task record is not disposed of here. }

var i,               { counter for link indicies }
    start,           { starting link index       }
    stop: integer;   { stopping link index       }

begin { RemoveTask }

   { first delete all forward arrows }
   { forward arrows range from 0 to NForward - 1 }
   stop := task^^.NForward - 1;
   for i := 0 to stop do begin
      DeleteArrow (task, task^^.Link[0]);
   end; { for }

   { now lets get all the back arrows }
   { back arrows range from NForward to NForward + NBackward - 1 }
   start := task^^.NForward;
   stop := task^^.NForward + task^^.NBackward - 1;
   for i := start to stop do begin
      DeleteArrow (task^^.Link[0], task);
   end; { for }

   { now go for the task record itself, link it into the ozone }
   { dont forget to keep head and tail up to date }
   if task = head then head := head^^.flink;
   if task = tail then tail := tail^^.blink;
   if task^^.blink <> nil then task^^.blink^^.flink := task^^.flink;
   if task^^.flink <> nil then task^^.flink^^.blink := task^^.blink;
   task^^.blink := nil;
   task^^.flink := nil;

end; { Removetask }


{-------------------------------------------------------------------------------}


Function addarrow{( taskfrom, taskto: hTask):boolean};

{ This procedure adds a new arrow, that is a pair of link records.  A forward
   link record is added to the taskfrom list, a backward link is added to the
   taskto list. An error occurs if an attempt is made to add a backward arrow.}

var cntrfrom,
    cntrto:    point;
    i,
    newsize:   integer;

begin { addarrow }

   { find the end points of the arrow }
   Rectcntr( cntrfrom, taskfrom^^.box);
   Rectcntr( cntrto, taskto^^.box);

   { if this is a backward arrow, then error }
   If cntrfrom.h >= cntrto.h then begin
      StopAlert(pealert, 10 {No Backward Arrows});
      Addarrow := false;
   end { if }

   else begin

      { make sure there isnt an arrow between these two already }
      with taskfrom^^ do begin
         for i := 0 to NForward -1  do begin
            {$R-}
            if Link[i] = taskto then begin
               Stopalert(pealert, 49 {No Two Arrows});
               Addarrow := false;
               exit(addarrow);
            end; { if }
            {$R+}
         end; { for }
      end; { with }

      { first add the forward link record to taskto }
      with taskfrom^^ do newsize := sizeof(taskRec) + 4*(NForward + NBackward + 1);
      ChangeSizeH(theHeap,  pointer(ord(taskfrom)), newsize);
      {!!!!!!!!what about out of memory??!!!!!!!}

      with taskfrom^^ do begin
         i := NBackward + NForward;
         while i > NForward do begin
            {$R-}
            link[i] := link[i - 1];
            {$R+}
            i := i - 1;
         end; { while }
         {$R-}
         Link[NForward] := taskto;
         {$R+}
         NForward := NForward + 1;
      end; { with }

      { next add the backward link record to taskfrom }
      with taskto^^ do newsize := sizeof(taskRec) + 4*(NForward + NBackward + 1);
      ChangeSizeH(theheap,  pointer(ord(taskto)), newsize);
      {!!!!!!!!what about out of memory??!!!!!!!}

      with taskto^^ do begin
         {$R-}
         link[NForward + NBackward] := taskfrom;
         {$R+}
         NBackward := NBackward + 1;
      end; { with }
      addarrow := true;
   end; { else }
end; { addarrow }

{-------------------------------------------------------------------------------}



procedure addtask {(task: hTask;)};
{ This procedure adds a task to the list of task records.  The global
   variables head and tail potentially will be modified by this routine.
   Tasks are inserted into the task list in an ordered fashion, on increasing
   horizontal value of their center point.  Function rectcntr is used to
   determine the center point of a particular task box. }

var
   curtask:   hTask;
   found:     boolean;
   TaskCntr:  integer;

begin { addtask }

   TaskCntr := xcntrCoord(task^^.box);

   { look down the list for new position }
   curtask := head;
   found := false;

   { if list empty then new head and tail }
   if curtask = nil then begin
      head := task;
      tail := task;
      task^^.flink := nil;
      task^^.blink := nil;
   end { if }

   else begin
      while (curtask<>nil) and (not found) do begin
         if (xcntrcoord(curtask^^.box) >= TaskCntr) then begin
            found := true;
            task^^.flink := curtask;
            task^^.blink := curtask^^.blink;
            curtask^^.blink := task;

            if (curtask = head) then head := task
            else task^^.blink^^.flink := task;
         end
         else curtask := curtask^^.flink;
      end; { while }

      { make a new tail }
      if not found then begin
         tail^^.flink := task;
         task^^.blink := tail;
         task^^.flink := nil;
         tail := task;
      end; { if }
   end; { else }
end; { addtask }

{-------------------------------------------------------------------------------}


Procedure MoveSubChart( task: htask;            { the task to be moved }
                        oldloc:  rect;          { the unscaled old box }
                        var error: boolean);    { error return         }
{ adjusts everything to the right of task by the move amount if possible }

var deltaH: integer;

begin { MoveSubChart }

   { calc the delta h for the move }
   deltaH := task^^.box.right - oldloc.right;
   error := false;

   { if moving right then check right paper boundary }
   if deltaH > 0 then begin
      if tail^^.box.right + DeltaH > PaperRect[pert].right then
         error := true
      else begin
         task := task^^.flink;
         while task <> nil do begin
            offsetRect( task^^.box, DeltaH, 0);
            task := task^^.flink;
         end;
         error := false;
      end; { else }
   end { if }

   { otherwise check left paper boundary }
   else begin
      if head^^.box.left + deltaH < 0 then
         error := true
      else begin
         task := task^^.blink;
         while task <> nil do begin
            offsetRect( task^^.box, deltaH, 0);
            task := task^^.blink
         end;
         error := false;
      end; { else }
   end; { else }
end; { MoveSubChart }


{------------------------------------------------------------------------------}


Procedure GetUPdRgn( task: htask; UpdateRgn: rgnHandle);

var updRect,
    destrect:   rect;
    i:          integer;
    centertask,
    destcenter: point;

begin

   updRect := task^^.box;
   if showdates then insetrect(updrect, -15, -p15lspace);
   ScaleRect(updrect,updrect);
   insetrect(updrect, -3, -2);
   RectCntr(centertask, task^^.box);

   with task^^ do
   for i := 0 to NForward + NBackward - 1 do begin
      {$R-}
      RectCntr(destCenter, link[i]^^.box);
      {$R+}
      Pt2Rect(centerTask,destCenter, destrect);
      UnionRect(updrect, destrect, updrect);
   end; { for }
   RectRgn(UpdateRgn, updRect);
end;



{-------------------------------------------------------------------------------}


Procedure MoveTask {(task:  hTask;  var newloc: rect)};
{ This procedure moves a task in the task list when its location has
   changed.  This procedure is called by PertUP on a move of an existing
   task.  None of the link records are changed, just the location of the
   task in the task list.  You can't move a task into a position where a
   backward arrow is created.  Also you cant move the task off the paper.}

var nexterror: boolean;
    oldloc,
    paper:     rect;
    th:        integer;
    forward:   boolean;
    error:     boolean;
    UpdateRgn: RgnHandle;

begin { MoveTask }

   oldloc := task^^.box;
   UpdateRgn := NewRgn;
   GetUpdRgn( task, UpdateRgn );

   Unscalerect( newloc, newloc);
   task^^.box := newloc;
   error := false;

   { first check for any potential backward arrows }
   CheckBackArrows( task, error );
   if error then begin
      { got some, see if we can avoid them }
      MoveSubChart(task, oldloc, error);
      if error then begin
         StopAlert(PEAlert,47 {No Way to Avoid Back Arrows});
         task^^.box := oldloc;
         {SetEmptyRgn(updateRgn);}
      end;
   end { if }

   { no back arrows }
   else begin
      { unlink it from present position.  }
      if task = head then head := head^^.flink
      else task^^.blink^^.flink := task^^.flink;

      if task = tail then tail := tail^^.blink
      else task^^.flink^^.blink := task^^.blink;

      { now add it in to task list at proper place.
        all links are unchanged. }
      addtask( task );

      { get the update region }
      GetUpdRgn(task, myfolder^.cliprgn);
      UnionRgn(updatergn, myfolder^.cliprgn, myfolder^.cliprgn);
   end; { else }

   { return updated newloc }
   ScaleRect( newloc, task^^.box);
   DisposeRgn(UpdateRgn);
end; { MoveTask }

{-------------------------------------------------------------------------------}
{                                                                               }
{           Hit test routines, private.                                         }
{                                                                               }
{-------------------------------------------------------------------------------}

{$S MainLoop}

Procedure RealCkArrow( mousept,
                       Pt1,
                       Pt2:       point;
                       Var found: Boolean );
{ the expensive test for hit on an arrow }

VAR
   dh1,          { horiz distance from pt2 to pt1 }
   dv1,          { vert distance from pt2 to pt1 }
   dh2,          { horiz distance from mousept to pt1 }
   dv2,          { vert distance from the arrow to pt1. This is how far
                    above pt1 the point would be for a perfect hit in the arrow }
   dh3,
   dv3: integer;

   mouseHdist,          { vertical distance from mousept to pt1                 }
   mouseVdist: integer; { horizontal distance from mousept to pt1               }

Begin

   { calculate the distances using triangulation. (dv1/dh1 = dv2/dh2 so
   dv2 = dh2 * dv1/dh1   }

   found := false;

   dh1   := pt2.h - pt1.h;
   dv1   := pt2.v - pt1.v;

   if dh1 <> 0 then begin
      dh2   := mousept.h - pt1.h;
      dv2   := trunc(dv1 * (dh2  / dh1));
      mouseVDist := mousept.v - pt1.v;
      found := (dv2 - 5 < mouseVdist) AND (mousevdist < dv2 + 5);
   end;

   if (dv1 <> 0) and (not found) then begin
      dv3   := mousept.v - pt1.v;
      dh3   := trunc(dh1 * (dv3 / dv1));
      mouseHdist := mousept.h - pt1.h;
      found := (dh3 - 5 < mouseHdist) AND (mouseHdist < dh3 + 5);
   end;
End; { RealCkArrow }

{-------------------------------------------------------------------------------}


Function Ck1Arrow( pt: point;
                   myFrom,
                   myTo:      hTask): boolean;
{ Ck1Arrow returns found = True if pt hit the single arrow running
from myFrom to myTo. This performs the actual hit test for the arrow }

VAR
   EnclosRect:  Rect;      { Rects for each box                        }
   Pt1,
   Pt2:         Point;     { the center point for each box             }
   found:       boolean;

Begin

   { Check if the point is within minimum rect enclosing the two center pts }
   RectCntr( Pt1, myfrom^^.box);
   RectCntr( Pt2, myTo^^.box);

   Pt2Rect( Pt1, Pt2, EnclosRect );
   InsetRect( EnclosRect, -3, -2 );

   if PtinRect( Pt, EnclosRect )
   then RealCkArrow( Pt, Pt1, Pt2, found )
   else found := false;
   Ck1Arrow := found;

End; { Ck1Arrow }

{-------------------------------------------------------------------------------}


Function Ck1Task( pt: point;  FromTask: htask; VAR DestTask: hTask): Boolean;

Var i: integer;

Begin { Ck1Task }

   { Look at all the forward links coming from this node }
   with FromTask^^ do begin
      for i := 0 to (NForward - 1) do begin
         { Get the to pointer out of the link record }
         {$R-}
         DestTask   := Link[i];
         {$R+}
         if Ck1Arrow(pt, FromTask, DestTask) then begin
            Ck1task := true;
            exit(Ck1Task);
         end;
      end; { for }
   End; { with }
   ck1Task := false;

End; { Ck1Task }

{-------------------------------------------------------------------------------}

Function CkTaskHit( MsePt: point; curtask: htask; var perimeter: boolean): boolean;

var temprect: rect;
    outrect:  rect;
    found:    boolean;
    centerpt: point;
    radius,
    rsqr,
    hsqr,
    vsqr:     real;

begin

   found := false;
   perimeter := false;

   { hit test for task box }
   Scalerect( temprect,curtask^^.box);
   { OutRect is the rect with gravity around the outside }
   OutRect := temprect;
   InsetRect( Outrect, -leftInset, -botInset );

   if PtinRect( Msept, Outrect ) then begin
      if not curtask^^.milestone then begin

         { got a hit on a task, see if perimeter or inside }
         found   := True;
         Scalerect( temprect,curtask^^.box);
         if Critical(curtask)
         then InsetRect(temprect, dhcritical, dvcritical)
         else InsetRect(temprect, 1, 1);
         if ptinrect( Msept, temprect) then {perimeter := false}
         else perimeter := true;
      End { If }

      { hit test for milestone circles }
      else begin
         Rectcntr( centerpt, curtask^^.box);
         radius := abs(temprect.botright.h - centerpt.h);
         rsqr := Sqr(radius);
         vsqr := Sqr((msept.v - centerpt.v) * 1.5); { convert to h equiv }
         hsqr := Sqr((msept.h - centerpt.h) * 1.0); { to convert to real }

         if ((rsqr + 2 * dhNbhd * radius) > (vsqr + hsqr))  then begin

            { got a hit on a milestone }
            found := true;
            if ((rsqr - (2 * dhNbhd * radius)) < (vsqr + hsqr)) then
               perimeter:= true
            else {perimeter := false};
         end; { if }
      end; { else }
   end; { if }
   CkTaskHit := found;
end;

{-------------------------------------------------------------------------------}


Function HitTestPert{( var MsePt: point; Tracking: boolean; var HitTask: boolean;
                       var perimeter: boolean; var TaskFrom: htask; var TaskTo: htask): boolean};

label 10;
var curtask,
    destTask: htask;
    HitArrow,
    done:     boolean;

begin

   curtask  := vistail;
   Hittask  := false;
   HitArrow := false;
   done := (vistail = nil);

   { Loop through each task till you find a hit }
   While (not done) and (not (HitTask or HitArrow)) Do Begin

      if curtask = nil then begin
         done := true;
      end { if }
      else begin
         if tracking then begin
            GetMouse(MsePt);
            if not PtinRect(MsePt, Myfolder^.portrect) then goto 10;
         end; { if }
         if CkTaskHit(MsePt, curtask, perimeter) then begin
            HitTask := true;
            TaskFrom := curtask;
         end { if }
         else begin
            { test this guy's forward arrows }
            if Ck1Task(MsePt, curtask, destTask) then begin
               HitArrow := true;
               TaskFrom := curTask;
               TaskTo   := desttask;
            end;
         end;

         done := (curtask = visHead);
         curtask := curtask^^.blink;
      end; { else }
   End; { While }

10:hitTestPert := HitTask or HitArrow;
end; { HitTestPert }


{-------------------------------------------------------------------------------}

Function KnobHit{( task:  hTask;  oldmouse: point): tknob};
{ Does a hit test on each of the eight knobbies around the perimeter of a
   box or circle.  Returns knob equal to none or to the knob selected. }

label 10;


var box,
    curknob:    rect;
    knob:       tknob;
    HIncrement,
    VIncrement,
    HOffSet,
    VOffSet:    real;
    I, J:       integer;

begin { KnobHit }

   Scalerect( box, task^^.box);
   knob := none;

   insetRect( box, -3, -2 );
   if PtinRect( oldmouse, box ) then begin

      ScaleRect( box, task^^.box);
      HIncrement := (box.botright.h - box.topleft.h)/ 2.0;
      VIncrement := (box.botright.v - box.topleft.v)/ 2.0;
      if task^^.milestone then begin
         HOffset := HIncrement / pi;
         VOffset := HOffset * 0.666;
      end;

      For I := 0 to 2 do
         For J := 0 to 2 do
            if Not((I = 1) and (J = 1)) then begin
               if (task^^.milestone and ((abs(I - J)= 2) or (abs(I - J)= 0)))
               then begin
                  if I = 0
                  then curknob.topleft.h :=
                     box.topleft.h + trunc(HIncrement - HOffset)
                  else curknob.topleft.h :=
                     box.topleft.h + trunc(HIncrement + HOffset);
                  if J = 0
                  then curknob.topleft.v :=
                     box.topleft.v + trunc(VIncrement - VOffset)
                  else curknob.topleft.v :=
                     box.topleft.v + trunc(VIncrement + VOffset);
               end
               else begin
                  curknob.topleft.h := box.topleft.h + trunc(I * HIncrement);
                  curknob.topleft.v := box.topleft.v + trunc(J * VIncrement);
               end;
               curknob.botright := curknob.topleft;
               Insetrect( curknob, -3, -2 );
               knob := succ(knob);
               if PtinRect( oldmouse, curknob ) then goto 10;
            end; { if }
      knob := none;
   end; { if }

10:knobhit := knob;
end; { KnobHit }

{-------------------------------------------------------------------------------

          Pert event routines, public.

 ------------------------------------------------------------------------------}

{$S Events}

Procedure NormVMS{( var theOval: Rect )};
var
   oldCntrV,
   offCntrV:  integer;
begin

   with theOval do begin
      oldCntrV := (bottom + top) div 2;
      offCntrV := trunc((right - left) * 0.333);
      top    := oldCntrV - offCntrV;
      bottom := oldCntrV + offCntrV;
   end;
end;

{-------------------------------------------------------------------------------}

Procedure NormHMS{( var theOval: Rect )};
var
   oldCntrH,
   offCntrH: integer;
begin

   with theOval do begin
      oldCntrH := (right + left) div 2;
      offCntrH := trunc((bottom - top)* 0.75);
      left  := oldCntrH - offCntrH;
      right := oldCntrH + offCntrH;
   end;
end;


{-------------------------------------------------------------------------------}


Procedure EditCheckDuration{( resc: hResc;  var value: integer;
                             var Ok: boolean )};
{ This procedure checks to see that the text string in the duration text
   is indeed an integer value and if so, return this value in duration. }

var
   length:    integer;     { length in chars of string }
   ch:        byte;        { current character         }
   count:     integer;     { current place in array    }
   maxlen:    integer;

begin { EditCheckDuration }

   { check out this new duration value, make sure its a number }
   length := htaskfield^^.curlen;
   maxlen := htaskfield^^.maxlen;
   value := 0;  { final integer value }
   Ok := true;  { ok so far           }
   count := 0;  { current position    }
   if length <> 0 then begin

      { skip leading and trailing blanks }
      {$R-}
      While ((htaskfield^^.curvalue^^[count] = ord(' '))and(count<maxlen))
         do count := count + 1;
      while ((htaskfield^^.curvalue^^[length-1] = ord(' '))and(length>0))
         do length := length -1;

      { if over three digits then bad value }
      if length - count > 3 then ok := false
      else begin

         while ok and (count <= length - 1 ) do begin
            ch := htaskfield^^.curvalue^^[count];
            if ((ch >= ord('0')) and (ch <= ord('9'))) then begin
               value := ch - ord('0') + value * 10;
               count := count + 1;
            end
            else ok := false;
         end; { while }
      end; { else }
      {$R+}
   end; { if }

end; { EditCheckDuration }


{-------------------------------------------------------------------------------}


procedure RestoreOldValue{( resc: hResc )};
{ restore old duration value in htaskfield array }

var strng:  String3;       { the resultant string }
    I:      integer;

begin { RestoreOldValue }

   { restore the old value in the field }
   Str( resc^^.duration, Strng);
   {$R-}
   For I := 0 to length(Strng) - 1 do htaskfield^^.curvalue^^[i] := ord(Strng[i+1]);
   {$R+}
   htaskfield^^.curlen := Length(Strng);
   resc^^.dcurlen := length(strng);

end; { RestoreOldValue }


{-------------------------------------------------------------------------------}


Procedure RestoreTitle{( line: hText;  htaskfield: hndfield )};
{ undoes what is done to set up for edit of title field. this exists because
  we are only using one field edit structure for all out text fields  }

begin { RestoreTitle }

   { just reset the new length }
   line^^.curlen := htaskfield^^.curlen;
   line^^.maxlen := htaskfield^^.maxlen;
   line^^.text :=   htaskfield^^.curvalue;
end; { RestoreTitle }


{-------------------------------------------------------------------------------}


Procedure RestDuration{( curresc: hResc;  htaskfield: hndfield )};
{ undoes what is done to set up for edit of duration field }

begin { RestDuration }

   { again, just reset  length }
   curresc^^.Dcurlen := htaskfield^^.curlen;
   curresc^^.Dmaxlen := htaskfield^^.maxlen;
   curresc^^.Dtext   := htaskfield^^.curvalue;
end; { RestDuration }


{-------------------------------------------------------------------------------}


Procedure XRestoreResc{( curresc: hResc;  htaskfield: hndfield )};
{ undoes what is done to set up for edit of resource name field }

begin { XRestoreResc }

   { again, just reset  length }
   with curresc^^ do begin
      Rcurlen := htaskfield^^.curlen;
      Rmaxlen := htaskfield^^.maxlen;
      Rtext   := htaskfield^^.curvalue;
   end; { with }

   { find the new resource name record }
   findResc(names, curresc);
end; { XRestoreResc }


{------------------------------------------------------------------------------}


Procedure CreateTask{( pt: point; var task: hTask)};
{ called on a pert up in newtask case, creates the new task record,
   links it in to task list }

begin { CreateTask }

   { get the new task data structure }
   if NewTaskRec(0, task) then begin

      { figure out a rect from these two points }
      Pt2Rect( curselrec[pert].curselloc, pt, task^^.box );

      { now fill in the rest of the task fields }
      with task^^ do begin

         { if we are currently scaled, then unscale box rect }
         Unscalerect( box, box);

         with box do
         dotline := ((bottom - top) * 3) div 5;
         milestone  := false;

         earlystart := minval;
         latestart  := maxval;

         flink := nil;
         blink := nil;

         { just allocate a duration value of 0 }
         maxduration := 0;

         { set up the text stuff }
         title := nil;
         resource := nil;

         { and the schedule date }
         SetStart := maxval;
         SetFinish := minval;

         NForward  := 0;
         NBackward := 0;
         FixedCost := 0;

         { add this task to linked list of tasks }
         addtask( task);

      end; { with }
   end { if }
   else StopAlert(pealert, 50 {Out Of Memory});
end; { CreateTask }


{------------------------------------------------------------------------------}


Procedure NewTextLine{( var newline: hText )};
{ create a new line of text }

begin { NewTextLine }

   { create the new text line of length 5 chars }
   if NewTextRec(10, newline) then begin
      with newline^^ do begin
         next := nil;
         curlen := 0;
         maxlen := 10;
      end; { with }
   end { if }
   else StopAlert(Pealert, 50 {Out Of Memory});
end; { NewTextLine }


{------------------------------------------------------------------------------}


Procedure NewRescLine{( var newresc: hResc)};
{ create a new resource line }

begin { NewRescLine }

   if NewRescRec(2,5, newresc) then begin
      with newresc^^ do begin
         duration  := 0;
         remaining := 0;
         dcurlen   := 0;
         dMaxlen   := 2;
         rcurlen   := 0;
         RMaxlen   := 5;
         rname := nil;
         next   := nil;
         nextresc := nil;
         nexttask := nil;
      end; { with }
      FindResc(names,  newresc);
   end { if }
   else StopAlert(Pealert, 50 {Out Of Memory});
end; { NewRescLine }


{------------------------------------------------------------------------------}


Procedure SetUpTitle{( line: hText;  htaskfield: hndfield )};
{ sets up for the edit of the title field }

begin { SetUPTitle }

   { point byte array to text record, and copy length }
   htaskfield^^.curvalue := line^^.text;
   htaskfield^^.curlen   := line^^.curlen;
   htaskfield^^.maxlen   := line^^.maxlen;
end; { SetUpTitle }


{------------------------------------------------------------------------------}


Procedure SetUpDuration{( curresc: hResc;  htaskfield: hndfield )};
{ sets up for edit of the duration field }

begin { SetUpDuration }

   htaskfield^^.curvalue := curresc^^.dtext;
   htaskfield^^.curlen   := curresc^^.dcurlen;
   htaskfield^^.maxlen   := curresc^^.dmaxlen;
end; { SetUpDuration }


{------------------------------------------------------------------------------}


Procedure SetUpResc{( curresc: hResc;  htaskfield: hndfield )};
{ sets up for edit of resource name field }

begin { SetUpResc }

   { return this resource }
   ReturnResc(names, curresc );

   htaskfield^^.curvalue :=  curresc^^.rtext;
   htaskfield^^.curlen   :=  curresc^^.rcurlen;
   htaskfield^^.maxlen   :=  curresc^^.rmaxlen;
end; { SetUPResc }


{------------------------------------------------------------------------------}

{$S MenuStuff}

Function  Critical {(task: htask): boolean};
{ check to see if task is a critical one, that is if earlystart >= latestart }

begin { Critical }
   with task^^ do Critical := (earlystart >= latestart);
end; { Critical }

