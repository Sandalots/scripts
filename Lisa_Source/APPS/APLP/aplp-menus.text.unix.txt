
{-----------------------------------------------------------------------------}
{                  Copyright 1983,1984, Apple Computer Inc.                   }
{                                                                             }
{  Menu handler routines.                                                     }
{                                                                             }
{  This unit reflects LisaProject's menu structure. Some basic menu fuctions  }
{  are handled here, install the menus, clean out existing menus, check the   }
{  current menu options in our menus, do the processing for each menu item    }
{  and one oddball routine that shrinks a pert drawing on a file save.        }
{                                                                             }
{-----------------------------------------------------------------------------}

UNIT PEMenus;

INTERFACE

USES
   {$U UnitStd    }  UnitStd,    { The basics }
   {$U UnitHz     }  UnitHz,
   {$U LibOs/SysCall    }  SysCall,

   {$U QuickDraw  }  QuickDraw,
   {$U FontMgr    }  FontMgr,    { Fonts & LisaGraf }
   {$U Storage    }  Storage,
   {$U GrafUtil   }  GrafUtil,

   {$U PmDecl     }  PmDecl,
   {$U Pmm        }  Pmm,

   {$U WM.Events  }  Events,     { The window manager }
   {$U WM.Folders }  Folders,
   {$U WM.Windows }  Windows,
   {$U WM.Menus   }  Menus,
   {$U wmlstd     }  WMlstd,
   {$U wmlsb      }  WMlsb,
   {$U wmlcrs     }  WMlcrs,
   {$U wmlgrow    }  WMlGrow,

   {$U PrStdInfo  }  PrStdInfo,
   {$U PrPublic   }  PrPublic,

   {$U AlertMgr   }  AlertMgr,
   {$U Dbenv      }  Dbenv,
   {$U scrap      }  Scrap,
   {$U fedec      }  fedec,
   {$U fld        }  fieldEdit,

{$SETC IsIntrinsic = True}
{$SETC WithUObject = False}
{$SETC UTProblems  = False}
{$SETC LibraryVersion = 30}
   {$U Uunivtext  }  UUniversaltext,

   {$U FilerComm  }  FilerComm,  { and the filer }

   {$U aplp/globals  }  PEGlobals,
   {$U aplp/DMgr     }  PEDMgr,
   {$U aplp/general  }  PEGeneral,
   {$U aplp/pert     }  PEPert,
   {$U aplp/cost     }  PECost,
   {$U aplp/gantt    }  PEGantt,
   {$U aplp/fileIO   }  PEFileIO;

{$IFC PESymbols}
{$D+}
{$ElseC}
{$D-}
{$EndC}


const
   firstScrapMenu = 1;    { menu number range for scrap folder           }
   lastScrapMenu  = 1;    { number of items in the scrap menu            }

   lastSched    = 1;      { last item in scheduled dates dialog          }
   lastDatesCk  = 4;      { last item in display dates check form        }
   lastDataCk   = 1;      { last item in data formats check form         }


type
   { from old file aplp/scrap }
   { types to remember whats in the scrap }
   tScrapContents = (aTask, aTextSel, aDocument, Nothing);

   tScrapPtr = ^tScrapRec;
   tScrapHnd = ^tScrapPtr;
   tScrapRec = record
      tag:  tscrapContents;
      case tscrapContents of

         atask: (task: htask;
                 Resc: hname;);

         adocument:();

         atextsel: ();

         nothing:  ();
   end;



var
   ScrapMenu:
      array[firstScrapMent..lastScrapMenu] of MenuInfo;

   SchedForm:  TEdFormHnd; { the sheduled start date edit form handle   }
   DatesForm:  TCkFormHnd; { dialog box check for date display }
   DataForm:   TCkFormHnd; { dialog box check for date formats  }
   PCalendar:  TEdFormHnd; { the calendar edit form }

   { from aplp/scrap }
   { vars for scrap management }
   myScrapConts: tScrapContents;



{ dialog box message IO }
Procedure EndMsg;

{ routines }
Procedure ShrinkDrawing;
Procedure DateDefaults;
Procedure CkMenuOptions;
Procedure MenuCommand         (theMenu, theItem: integer );
Procedure InstallMenus        (folder: windowPtr);
Procedure CleanMenus;

{ from aplp/scrap }
Procedure ShowScrap;
Procedure PECopyTask           (curtask: htask);
Procedure PECutTask            (curtask: htask);
Procedure PEPasteTask          (curtask: htask);
Procedure PECopyDocument;
Procedure PEPasteAir;



IMPLEMENTATION
{$IFC fsymok}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}
{$IFC fdbgok}
{$R+}
{$ELSEC}
{$R-}
{$ENDC}



const
   { Menu and menu item numbers }
   M_FilePrint = 1;       { file and print menu number                   }
   I_CloseEvery  = 1;     { close every thing on the desk                }
   I_CloseTitle  = 2;     { close 'Title'                                }
   I_PutBack     = 4;     { Put back 'Title'                             }
   I_SaveVersion = 5;     { Save version and continue                    }
   I_ReverttoPrev= 6;     { Revert to previous draft                     }
   { Null        = 7;                                                    }
   I_PrintOne    = 8;     { Print one copy as is                         }
   I_IntendedFor = 9;     { Intended for printer ...                     }
   I_Print       = 10;    { Print                                        }
   I_PrintProg   = 11;    { printing in progress ...                     }
   { Null        = 12;                                                   }
   I_DataFormats = 13;    { convert data formats...                      }

   M_Edit      = 2;
   I_Undolast    = 1;
   I_Cut         = 3;
   I_Copy        = 4;
   I_Paste       = 5;
   I_SelectAll   = 7;

   M_TypeStyle = 3;
   I_PlainText   = 1;
   I_UnderLine   = 2;
   I_Bold        = 3;
   I_Italic      = 4;
   { Null item   = 5; }
   I_Modern      = 6;
   I_Classic     = 7;
   { Null item   = 8; }
   I_8Pt20       = 9;
   I_8Pt15       = 10;
   I_10Pt12      = 11;
   I_12Pt10      = 12;
   I_12Pt        = 13;
   I_14Pt        = 14;
   I_18Pt        = 15;
   I_24Pt        = 16;

   M_PageLayout= 4;
   I_DontPreview = 1;
   I_DoPreview   = 2;
   I_ShowActual  = 4;
   I_70Reduce    = 5;
   I_FitReduce   = 6;
   I_RightPage   = 8;
   I_BottomPage  = 9;

   M_Customize = 5;
   I_Calendar    = 1;
   I_SchedDates  = 2;
   I_UndoScheds  = 3;
   I_DispDates   = 4;
   I_GanttScale  = 6;
   I_Update      = 7;
   I_MScircle    = 9;
   { Null item   = 10 }
   I_Parallel    = 11;
   I_Resource    = 12;

   M_Chart     = 6;
   I_Pert        = 1;
   I_RescGantt   = 2;
   I_TaskGantt   = 3;
   {Null item    = 4; }
   I_RescCost    = 5;
   I_TaskCost    = 6;
   I_CashFlow    = 7;
   I_TaskTable   = 8;

   I_SClosEvery  = 1;     { close every thing on the desk                }
   I_SClosTitle  = 2;     { close 'Title'                                }
   I_SMonitorPr  = 4;     { Monitor the printer                          }



Procedure myDeselect(var error: boolean); external;

{------------------------------------------------------------------------------}
{$I aplp/scrap}
{------------------------------------------------------------------------------}
Procedure MyKey (theEvent: eventRec); external;

{$S   }
Procedure EndMsg;
{ endproc for simple message dialog }

begin { EndMsg }
   { clear out the dialog box }
   if theDBox.isOpen then ClearDBox;
   msgon := false;
   edFldBox := false;

   { reset key handler routines to activefolder }
   keyport := myfolder;
   keyproc := @MyKey;
   SetStdCursor(icrsInactive);

end; { EndMsg }

{$S SgPeFile}

Procedure ShrinkDrawing;
{ calculates the minimum drawing size for the Pert chart and resizes paper }

var maxH,                { maximum h value used in drawing    }
    maxV:    integer;    { maximum v value used in drawing    }

begin { ShrinkDrawing }

   getMaxHV( maxh, maxv );

   { adjust pert drawing size }
   with paperRect[pert] do begin
      right  := CMin(Trunc(CMAx(MaxH, PageH)/pageH + 0.99)* pageH, MaxHDrwSize);
      bottom := CMin(trunc(CMax(MaxV, PageV)/pageV + 0.99)* pageV, MaxVDrwSize);
   end;

end; { ShrinkDrawing }



{------------------------------------------------------------------------------}

{$S MenuStuff}
Procedure ScrapDeskTop(theItem: integer);
{ controls the file/print menu for the scrap folder }

var cErr: TC;

begin { ScrapDeskTop }

   case theItem of

      I_SClosEvery: begin
         DoFilingCmd(cmdClosAll);
      end;

      I_SClosTitl: begin
         DoFilingCmd(cmdClose);
      end;

      I_SMonitorPr: begin
         PrBgdDlg;
         (* ??? if cErr <> 0 then NoteAlert(pealert, 65 {PrMonitor}); *)
      end;
   end; { case }
end; { ScrapDeskTop }

{------------------------------------------------------------------------------}
{$S  }
procedure SetUpDBox(FormHnd: QDPtr; prcP,trkP,rstP,endP: ProcPtr; Edfield: boolean);
{ sets up a dialog box for display }

begin { SetUpDBox }

   { finish any pending dialog before starting a new one }
   with theDBox do if isOpen then CallEndProc(false,endProc);

   { set up and draw dialog box }
   SetDBox(FormHnd,PrcP, trkP, rstP, endP);
   SetPort(dialogFolder);
   msgOn := true;
   edFldBox := edField;
end; { SetUpDBox }


{------------------------------------------------------------------------------}

Procedure DateDefaults;
{ stuffs the strings into the calendar edit form, this gets called by the fileio
  unit when reading in a new file and by the menu code upon termination of the
  calendar dialog }

var date:       string30;   { the date string for holidays }
    i,j,                    { local counters               }
    Digits:     integer;    { last two digits of the year  }
    YearString:  string3;   { above converted to a string  }

begin { DateDefaults }

{$R-}
   with PCalendarForm^^ do begin

      { calendar starting year }
      with EdFldLst[0]^^.EdItmLst[1]^^ do begin
         Digits := calstartDate.year Mod 100;
         Str( Digits,  YearString );
         for i := 0 to length(YearString) - 1 do
            idata^^[i] := ord(YearString[i + 1]);
         idataLen := length(YearString);
         WasEdited := false;
      end;

      { calendar ending year }
      with EdFldLst[1]^^.EdItmLst[1]^^ do begin
         Digits := endingyear Mod 100;
         Str( Digits,  YearString );
         for i := 0 to length(YearString) - 1 do
            idata^^[i] := ord(YearString[i + 1]);
         idataLen := length(YearString);
         WasEdited := false;
      end;

      { days per week }
      with EdFldLst[2]^^.EdItmLst[1]^^ do begin
         idata^^[0] := ord('0') + DaysPerWeek;
         idataLen := 1;
         WasEdited := false;
      end;

      { today }
      with EdFldLst[3]^^.EdItmLst[1]^^ do begin
         if today = 0 then date := mm_dd_yy
         else datestring(today, date);
         for i := 0 to Length(Date) - 1 do
            idata^^[i] := ord(date[i+1]);
         idataLen := length(Date);
         wasEdited := false;
      end;

      { holidays }
      with EdFldLst[4]^^ do begin
         for i := 1 to maxholiday do begin
            if holidate[i].RD = maxval then date := mm_dd_yy
            else DateString(Holidate[i].RD,date);
            holidate[i].WD := WDEquiv(holidate[i].RD);
            if (i <= numEdItm) and (edItmLst[i] <> nil) then begin
               with EdItmLst[i]^^ do begin
                  for j := 0 to length(date) - 1 do
                  idata^^[j] := ord(date[j+1]);
                  idataLen := length(date);
                  wasEdited := false;
               end;
            end
            else begin
               { weird condition - dbox record doesnt have
                 enough holidays }
               StopAlert(Pealert, 2 {Internal error});
            end; { else }
         end; { for }
      end; { with }
   end; { with }
{$R+}
end; { DateDefaults }

{------------------------------------------------------------------------------}

procedure EndData( doItFlag: boolean);

begin { EndData }

    { did the user say do it?? }
    if doItFlag then begin
       with dataform^^ do begin

    {$R-} if (CkBoxLst[1]^^.CurOnOff = 1) and
             ((dateformat <> toolDateformat) or (mm_dd_YY <> toolMM_DD_YY)) then begin   {$R+}
             SetDateCode(toolDateFormat, toolMM_DD_YY);
             DateDefaults;
             ShowContents(myfolder);
             docChangedFlag := true;
          end { if }
    {$R-} else if (CkBoxLst[1]^^.CurOnOff = 2) and
              ((dateformat <> docDateFormat) or (mm_dd_YY <> docMM_DD_YY)) then begin {$R+}
              SetDateCode(docDateFormat, docMM_DD_YY);
              DateDefaults;
              ShowContents(myfolder);
              docChangedFlag := true;
          end; { if}
       end; { with }
    end; { if }

    { clear dialog io }
    ClearDBox;
    msgOn := false;
end; { EndData }


{----------------------------------------------------------------------------}

{$S MenuStuff}
Procedure DeskTop( theItem: integer );
{ Controls the file/print menu items for Pert and Gantt charts. }


var error_code: integer;
    oldname:    pathname;
    attributes: fs_info;
    whenstring: TParamAlert;
    doRevert:   boolean;
    Event:      EventRecord;
    error:      boolean;
    filerError:  integer;
    failReason:  FReason;
    cErr:        TC;

Begin { DeskTop }

   Case theItem of

      I_CloseEvery: Begin { Close everything on desk }
         DoFilingCmd(cmdClosAll);
      End;

      I_CloseTitle: Begin { Close "Title" }
         DoFilingCmd(cmdClose);
      End;

      I_SaveVersion: Begin { Save version and continue }
         MyDeselect(error);
         if not error then begin
            WaitAlert( PeAlert, 19 {Saving File});
            if SaveTheDoc( failreason, error_code, fileRefNum) then begin
               HideFolder(alertFolder);
               flush(error_code, fileRefNum);
            end { if }
            else begin
               case failReason of
                  InternalError: StopAlert(Pealert, 18 {Internal Error});

                  noDiskSpace: StopAlert(pealert, 54 {Disk Full});

                  CantWrite: StopAlert( Pealert, 20 {No Save});
               end; { case }
            end; { else }
         end; { if }
      End;

      I_PutBack : begin { Put back this version }
         MyDeselect(error);
         if error then { only case is bad duration in pert, no message required here }
         else begin
            ShrinkDrawing;
            WaitAlert( PeAlert, 19 {Saving File});
            IF CloseTheDoc(fcClose,failReason) then begin
               HideFolder(alertFolder);
               { do a deactivate event here }
               HiLiteTab(theEvent.who, false);
               { prepare to swap, make my data segments small, etc }
               {fVisible := False;}
               feTerminate;
               { make my data segment small }
               ShrinkHeap(theHeap, True {shrink the disc also }, error_code);

               { tell the filer that were closed and not active }
               TellFiler(filerError,docClosd,docPutBack, myfolder);
               myfolder := nil;
            end { if }
            else begin
               case FailReason of
                  InternalError: StopAlert(Pealert, 18 {Internal Error});

                  noDiskSpace: StopAlert(pealert, 54 {Disk Full});

                  CantWrite: StopAlert( Pealert, 20 {No Save});
               end; { case }
            end; { else }
         end; { else }
      end;

      I_ReverttoPrev: begin { Revert to previous version }

         MyDeselect(error);

         { look up info on the file, we currently should have it opened }
         LookUp(error_code, Filename, attributes);

         { error means problem with the disk, give the usual message for this }
         if error_code > 0 then begin
            TellFiler(error_code, docClosd, cantRead, myfolder);
            docsOpen := 0;
            myfolder := nil;
         end { if }
         else begin

            { if it has a close to 0 size then this will revert to
              blank stationary, otherwise will revert to last save }
            if attributes.size < 10 then
               DoRevert := CautionAlert(Pealert, 48 {Restore Blank Doc?})
            else begin
               DTAlert(PeAlert, attributes.DTM, whenstring);
               ParamAlert(whenstring, '','');
               DoRevert := CautionAlert( PeAlert, 21 {Reading Doc});
            end; { else }

            { did they want to go ahead and do it?? }
            if DoRevert then begin
               if RestTheDoc( failreason, error_code, fileRefnum) then {OK}
               else begin
                  TellFiler(error_code, docClosd, failreason, myfolder);
                  docsOpen := 0;
                  myfolder := nil;
               end { else }
            end; { if }
         end; { else }
      end; { revert to previous version }

      I_PrintOne: begin { Print one copy as is }
         DoPrint(ePrDialogSuppress);
      end;

      I_Intendedfor: begin { Intended for printer...}
         IntendedFor;
      end;

      I_Print: begin { Print... }
         DoPrint(ePrNormal);
      end;

      I_PrintProg: begin { Monitor the Printer }
        PrBgdDlg;
        (* ??? if cErr <> 0 then NoteAlert(pealert, 65 {PrMonitor}); *)
      end;

      I_DataFormats: begin { Convert the data formats }
         SetUpDBox(Pointer(Ord(DataForm)),@GetCkHit,@TrkCkBoxMse,@RestoreCkForm,@EndData,false);
         with DataForm^^.ckBoxLst[0]^^ do curCkItm := -1;
{$R-}    with dataForm^^ do CkBoxLst[1]^^.CurOnOff :=
            1 + ord((dateformat <> tooldateFormat) or (MM_DD_YY <> toolMM_DD_YY));   {$R+}
         ShowCkForm( DataForm);
      end;

   End; { Case }
End; { DeskTop }

{------------------------------------------------------------------------------}


Procedure PageLayout( theItem: integer );
{ Page layout menu,  preview, zooming, adding pages to the schedule chart. }

var neworigin: point;
    error:     boolean;

begin { PageLayout}

   Case theItem of

      I_DontPreview,
      I_DoPreview: begin { do/dont preview pages }
            if (preview <> (theItem = I_doPreview)) then begin
               Preview := (theItem = I_doPreview);
               SetPort(myFolder);
               ClipRect(myFolder^.portrect);
               ShowContents(myFolder);
            end;
         end;

      I_ShowActual: begin { Show Actual size }
           ShowActual;
         end;

      I_70Reduce: begin { Reduce 70% }
           Show70Reduce;
         end;

      I_FitReduce: begin { Show reduced to fit }
            ShowFitReduce;
         end;

      I_RightPage,
      I_BottomPage: begin { Add Page Right,  Add Page Bottom }
            error := false;
            if theItem = I_rightPage then begin
               if paperRect[Pert].right >= maxHDrwSize
                  then error := true
                  else begin
                     PaperRect[Pert].right := CMin(PaperRect[Pert].right + PageH, MaxHDrwSize);
                     ReqPaper.h := PaperRect[pert].right;
                  end; { else }
            end { if }
            else begin
               if paperRect[pert].bottom >= maxVDrwSize
                  then error := true
                  else begin
                     PaperRect[Pert].bottom:= CMin(PaperRect[Pert].bottom + PageV, MaxVDrwSize);
                     ReqPaper.v := PaperRect[pert].bottom;
                  end; { else }
            end; { else }

            { if error then alert, otherwise redisplay chart }
            if error then StopAlert(PEalert, 27 {No more Paper})
            else begin
               if scale[activechart].state = scaleFit then ShowFitReduce
               else begin
                  SetPt(neworigin, myFolder^.portrect.left,
                                   myFolder^.portrect.top);
                  CkSBars( myfolder^.portrect, neworigin );

                  { set origin, draw scrolls and chart }
                  SetPort(myfolder);
                  SetOrigin( neworigin.h, neworigin.v );
                  myOrigin := newOrigin;
                  ClipRect(myfolder^.portrect );
                  ShowScroll(myfolder);
                  showContents(myfolder);
               end; { else }
            end; { else }
         end;
   end; { case }
end; { PageLayout }


{------------------------------------------------------------------------------}
{$S  }


Procedure TellUser(var WarnedUser: boolean);
begin

   if not WarnedUser then
      NoteAlert(Pealert, 68);
   WarnedUser := true;
end;


{------------------------------------------------------------------------------}


Procedure GetRDOffsets;
{ this guy converts the SetStart and SetFinish fields to real offsets
  in preparation for a change in the calendar }

var current: htask;

begin { GetRDOffsets }

   current := head;
   while current <> nil do begin

      with current^^ do begin
         SetStart := RDEquiv(SetStart);
         SetFinish := RDEquiv(SetFinish);
      end; { with }
      current := current^^.flink;
   end; { while }
end; { GetRDOffsets }


{------------------------------------------------------------------------------}


Procedure NewOffsets(oldCalStart: tdate);
{ calculates new scheduled dates WD offsets for new calendar }

var delta:   integer;
    current: htask;
    maxRD:   integer;
    BenWarned: boolean;

begin { NewOffsets }

   { get real difference between new cal start and old cal start }
   DateSubtract( oldCalstart, calstartdate, delta );
   {$R-}
   maxRD := calendar^^[calsize];
   {$R+}
   BenWarned := false;

   current := head;
   while current <> nil do begin

      with current^^ do begin

         if SetStart <> maxval then begin
            SetStart := SetStart + delta;
            if (SetStart < 0) or (SetStart > MaxRD) then begin
               TellUser(BenWarned);
               SetStart := maxval;
            end
            else SetStart := WDEquiv(SetStart);
         end;

         if (SetFinish  <> maxval) then begin
            SetFinish  := SetFinish  + delta;
            if (SetFinish  < 0) or (SetFinish  > MaxRD) then begin
               TellUser(BenWarned);
               SetFinish  := minval;
            end
            else SetFinish  := WDEquiv(SetFinish );
         end
         else SetFinish  := minval;

      end; { with }
      current := current^^.flink;
   end; { while }
end; { NewOffsets }


{------------------------------------------------------------------------------}


Procedure ParseCalstart( var newstart: boolean);

var strng:     string30;
    i:         integer;
    newvalue:  integer;

begin { parseCalstart }

   {$R-}
   { starting year of calendar }
   if PCalendarForm^^.EdFldLst[0]^^.EdItmLst[1]^^.wasEdited then begin
      strng := '        ';
      for i := 0 to PCalendarForm^^.EdFldLst[0]^^.EdItmLst[1]^^.idataLen - 1 do
         Strng[i+1] := chr(ord(PCalendarForm^^.EdFldLst[0]^^.EdItmLst[1]^^.idata^^[i]));
      newvalue := AsciiToInt(strng);

      if (length(strng) <> 0) or ((newvalue < 0) or (newvalue > 99)) then begin
         NoteAlert(pealert, 38 {Bad Starting Year});
      end
      else begin
         with CalStartDate do begin
            year := newvalue + 1900;
            day := 1;
            month := 1;
         end;
         DayOfWeek(calStartDate);
         newstart := true;
      end;
   end; { if }
   {$R+}
end; { parseCalstart }


{------------------------------------------------------------------------------}


Procedure ParseEndYear( var Newstart, updateCalendar: boolean);

var strng:     string30;
    i:         integer;
    newvalue:  integer;

begin

   { ending year of calendar }
   {$R-}
   if PCalendarForm^^.EdFldLst[1]^^.EdItmLst[1]^^.wasEdited or NewStart then begin
      strng := '        ';
      for i := 0 to PCalendarForm^^.EdFldLst[1]^^.EdItmLst[1]^^.idataLen - 1 do
         Strng[i+1] := chr(ord(PCalendarForm^^.EdFldLst[1]^^.EdItmLst[1]^^.idata^^[i]));
      newvalue := AsciiToInt(strng);

      if (length(strng)<>0) or ((newvalue < 0) or (newvalue > 99)) then begin
         NoteAlert(pealert, 26 {Bad Ending Year});
         endingYear := CalStartDate.year;
      end { if }
      else begin
         if (newvalue < (calstartdate.year - 1900))  then begin
            { not a positive cal range }
            NoteAlert(pealert, 24 {Bad Calendar Range});
            endingyear := CalstartDate.year;
         end
         else begin
            if (newvalue > (calstartdate.year - 1900 + 10)) then begin
               { error, not a positive calendar range or range too big }
               NoteAlert(pealert, 34 {Calendar Range Too Big});
               endingYear := calstartdate.year + 10;
            end
            else begin
               { got a good value, amazing }
               EndingYear := 1900 + newvalue;
            end; { else }
         end; { else }
      end; { else }
      updateCalendar := true;
   end; { if }
   {$R+}
end; { parseEndYear }


{------------------------------------------------------------------------------}


Procedure ParseDaysPerWeek( var UpdateCalendar: boolean);

var strng:     string30;
    i:         integer;
    newvalue:  integer;

begin { parseDaysperWeek }

   { working days per week }
   {$R-}
   if PCalendarForm^^.EdFldLst[2]^^.EdItmLst[1]^^.wasEdited then begin
      strng := '        ';
      for i := 0 to PCalendarForm^^.EdFldLst[2]^^.EdItmLst[1]^^.idataLen - 1 do
         Strng[i+1] := chr(ord(PCalendarForm^^.EdFldLst[2]^^.EdItmLst[1]^^.idata^^[i]));
      newvalue := AsciiToInt(strng);
      if (newvalue <= 0) or (newvalue > 7) then begin
         NoteAlert(pealert, 39 {Bad Days Per Week});
      end
      else begin
         DaysPerWeek := newValue;
         updateCalendar := true;
      end;
   end; { if }
end; { parseDaysPerWeek }


{------------------------------------------------------------------------------}


procedure parseToday( newstart: boolean; var UpdateCalendar: boolean );

var strng:     string30;
    i:         integer;
    newvalue:  integer;
    newdate:   tdate;

begin

   if PCalendarForm^^.EdFldLst[3]^^.EdItmLst[1]^^.wasedited or NewStart then begin
      if ParseDate( PCalendarForm^^.EdFldLst[3]^^.EdItmLst[1]^^.idataLen,
                    PCalendarForm^^.EdFldLst[3]^^.EdItmLst[1]^^.idata,
                    NewDate ) then begin
         DayOfWeek(newDate);
         DateSubtract( newdate, CalStartDate, NewValue);
         { is it in the calendar range ? }
         if (NewValue < 0) or (newdate.year > endingyear)
         then begin
            NoteAlert(pealert, 40 {Today Out Of Range});
            today := 0;
         end { if }
         else begin
            today := newValue;
            updateCalendar := true;
         end; { else }
      end { if }
      else begin
         { default to mm/dd/yy with no alert }
         today := 0;
         updateCalendar := true;
      end; { else }
      PCalendarForm^^.EdFldLst[3]^^.EdItmLst[1]^^.WasEdited := false;
   end; { if }
end; { parseToday }


{------------------------------------------------------------------------------}


Procedure ParseHolidays( newstart: boolean; var UpdateCalendar: boolean);

var strng:     string30;
    i:         integer;
    newvalue:  integer;
    NewDate:   tdate;

begin { parseHolidays }

   { and the holidays }
   for i := 1 to maxholiday do
   if PCalendarForm^^.EdFldLst[4]^^.EdItmLst[i]^^.wasEdited or NewStart then begin
      if parseDate( PCalendarForm^^.EdFldLst[4]^^.EdItmLst[i]^^.idataLen,
                    PCalendarForm^^.EdFldLst[4]^^.EdItmLst[i]^^.idata,
                    newdate) then begin
         { is new date in the calendar range ? }
         dateSubtract( newdate, CalStartDate, NewValue );
         if (NewValue < 0) or (newdate.year > endingyear) then begin
            noteAlert(pealert, 41 {Holiday Out Of Range});
            Holidate[i].RD := maxval;
         end
         else begin
            Holidate[i].date := newDate;
            Holidate[i].RD   := NewValue;
            updateCalendar := true;
         end; { else }
      end
      else begin
         { put in the default }
         holidate[i].RD := maxval;
         updateCalendar := true;
      end; { else }
   end; { if }
   {$R+}
end; { parseHolidays }


{------------------------------------------------------------------------------}



Procedure EndCalCmd(doitflag: boolean);
{ called when user says do it or cancel to calendar dialog }

var updateCalendar,
    newStart:   boolean;
    oldCalStart: tDate;
    oldEndYear:  integer;
    oldDaysPWk:  integer;
    newcalsize:  integer;

begin { EndCalCmd }

   { exit the dialog box IO }
   setport(dialogfolder);
   ExitEdit(pCalendarForm);

   { copy the old calendar values }
   oldCalstart := calstartDate;
   oldEndYear  := endingYear;
   oldDaysPWk  := daysPerweek;

   UpdateCalendar := false;
   NewStart := false;

   { now see what new values have been entered }
   if doItflag then begin
      docChangedFlag := true;

      { parse the start date }
      ParseCalStart( NewStart );

      { parse the end date }
      ParseEndYear( NewStart, UpdateCalendar );

      { days per week }
      ParseDaysPerWeek( UpdateCalendar );

      { make sure we are going to have enough memory for this calendar }
      { make an approximation of the calendar size }
      newCalsize := (endingYear - calstartDate.year + 1) * 53 * daysperweek * 2;
      if newcalsize > calsize then begin
         if not EnoughSpace( theheap, newcalsize - calsize) then begin

            { not enough space, restore old calendar info, don't go on }
            stopalert(pealert, 50 {out of memory});
            calstartdate := oldcalstart;
            endingyear   := oldendYear;
            daysperWeek  := oldDaysPWk;

            { stuff strings back into edit form }
            DateDefaults;
            endmsg;
            exit(endCalcmd);
         end; { if }
      end; { if }

      { today }
      ParseToday( newstart, updateCalendar );

      ParseHolidays( newstart, updateCalendar );

      { if we change the calendar start then must change scheduled dates }
      if newstart then GetRDOffsets;

      { if anything changed then create a new calendar }
      if updateCalendar or newstart then begin
         if FillCalendar then {OK}
         else begin
            { got trouble, estimate said we would have enough memory, but
              now we dont }
            stopalert(pealert, 18 {difficulitites working on this document});
         end; { else }
      end;

      { Recalc the scheduled date offsets }
      if newstart then NewOffsets(oldCalStart);

      { get the new schedule  }
      if (updateCalendar or newstart) then begin
         if (showdates) or (activechart <> Pert) then CalcSchedule;
         SetPort(myfolder);
         with myfolder^ do ClipRect(portrect);
         if scale[activechart].state = ScaleFit
         then ShowFitReduce
         else Zoom( 1.0, Scale[activechart].state);
      end; { if }
   end; { else }

   { stuff strings back into edit form }
   DateDefaults;

   EndMsg;
end; { EndCalCmd }


{------------------------------------------------------------------------------}


procedure EndGScale(doItFlag: Boolean);
{ terminates the gantt scale command dialog io }

var newGridSize: integer;
    paper: rect;
    screenh,
    screenv: integer;
    neworigin: point;

begin { EndGScale }

    { did the user say do it?? }
    if doItFlag then begin
       {$R-}
       newGridSize := GGridForm^^.ckBoxLst[1]^^.curCkItm;
       {$R+}
       { is this a new value?? }
       if newGridSize <> curGridSize then begin

          { set up the new size }
          curGridSize := newGridSize;
          docChangedFlag := true;
          CreateGantt;
          setport(myfolder);
          cliprect(myfolder^.portrect);

          { this may change the current scale factor or origin }
          case scale[activechart].state of
             scalefit:  ShowFitReduce;
             ScaleReal: Zoom( 1.0, ScaleReal );
             Reduce70: begin
                { if now the paper is smaller than the screen in h...}
                with myfolder^.portrect do begin
                   ScalePaper(paper, activeChart);
                   screenh := right - left - dhSbox;
                   screenv := bottom - top - dvSbox;
                end;
                { then show in scale to fit mode }
                if screenh >= (paper.right - paper.left)
                then ShowFitReduce
                { otherwise just show in same scale with origin
                  possible adjusted }
                else begin
                  SetPt(neworigin, myFolder^.portrect.left,
                                   myFolder^.portrect.top);
                  CkSBars( myfolder^.portrect, neworigin );

                  { set origin, draw scrolls and chart }
                  SetPort(myfolder);
                  SetOrigin( neworigin.h, neworigin.v );
                  myOrigin := newOrigin;
                  ClipRect(myfolder^.portrect );
                  ShowScroll(myfolder);
                  showContents(myfolder);
                end; { else }
             end;
          end; { case }
       end; { if }
    end; { if }

    { clear dialog io }
    ClearDBox;
    msgOn := false;
end; { EndGScale }


{------------------------------------------------------------------------------}


procedure EndDates( doItFlag: boolean);
{ finishes off the dbox that selected date display in pert }

var temprgn: RgnHandle;
    error:   boolean;

begin { EndDates }

    { did the user say do it?? }
    if doItFlag then begin
       docChangedFlag := true;
       with datesform^^ do begin
          {$R-}
          showES := (CkBoxLst[1]^^.CurOnOff = 1);
          ShowEF := (CkBoxLst[2]^^.CurOnOff = 1);
          ShowLs := (CkBoxLst[3]^^.CurOnOff = 1);
          ShowLF := (CkBoxLst[4]^^.CurOnOff = 1);
          {$R+}
       end; { with }

       { reset out main bool }
       showDates := (showES or showLS or showEF or showLF);
       if showdates then begin
          error := false;
          if curselrec[pert].tag = textsel then
             if not curselrec[pert].editingtitle then
                PertDeselect(error);
          if not error then begin
             calcSchedule;
             setport(myfolder);
             cliprect(myfolder^.portrect);
             showContents(myfolder);
          end; { if }
       end { if }
       else begin
          UnSchedule;

          { redisplay chart }
          SetPort(myfolder);
          Cliprect(myfolder^.portrect);
          ShowContents(myfolder);
       end; { else }

    end; { if }

    { clear dialog io }
    ClearDBox;
    msgOn := false;

end; { EndDates }



{------------------------------------------------------------------------------}


procedure EndSchedDate(doItFlag: Boolean);
{ Finishes off the scheduled dates dbox dialog. Parses dates that were
  edited.  Gives alerts if dates parse but not in the calendar range.
  Defaults if dates don't parse to legtimate dates. }

var NewDate:    tdate;
    RDOff:      integer;

begin { EndSchedDate }

   { clear the dialog box IO }
   setport(dialogfolder);
   ExitEdit(SchedForm);

   { now see what new value has been entered }
   if doItflag then begin
      docChangedFlag := true;
      {$R-}
      { scheduled start date }
      if SchedForm^^.EdFldLst[0]^^.EdItmLst[1]^^.wasEdited then
      with curselrec[pert] do begin
         if ParseDate( SchedForm^^.EdFldLst[0]^^.EdItmLst[1]^^.idataLen,
                       SchedForm^^.EdFldLst[0]^^.EdItmLst[1]^^.idata,
                       NewDate ) then begin

            DateSubtract( newdate, CalStartDate, RDOff);
            { if outside the calendar then tell the user }
            if (RDOff < 0) or (newdate.year > endingyear)
            then begin
               ParamAlert('Scheduled Start','','');
               StopAlert(Pealert, 31 {Out Of Calendar});
            end { if }
            { got a good date, parsed and in range }
            else curtask^^.SetStart := WDEquiv(RDOff);
         end { if }

         { date didnt parse, default case }
         else curtask^^.SetStart := maxval;
         SchedForm^^.EdFldLst[0]^^.EdItmLst[1]^^.WasEdited := false;
      end; { with }

      { scheduled finish date }
      if SchedForm^^.EdFldLst[1]^^.EdItmLst[1]^^.wasEdited then
      with curselrec[pert] do begin
         if ParseDate( SchedForm^^.EdFldLst[1]^^.EdItmLst[1]^^.idataLen,
                       SchedForm^^.EdFldLst[1]^^.EdItmLst[1]^^.idata,
                       NewDate ) then begin
            DayOfWeek(newDate);
            DateSubtract( newdate, CalStartDate, RDOff);
            if (RDOff < 0) or (newdate.year > endingyear)
            then begin
               ParamAlert('Scheduled Finish','','');
               StopAlert(pealert, 31 {Out Of Calendar});
            end { if }
            { got a good date, set new finish time }
            else curtask^^.SetFinish := WDEquiv(RDOff);
         end { if }

         { didnt parse, default case }
         else curtask^^.SetFinish := minval;
         SchedForm^^.EdFldLst[1]^^.EdItmLst[1]^^.WasEdited := false;
      end; { with }
      {$R+}

      { recalc schedule and redisplay pert }
      if showdates then begin
         CalcSchedule;
         SetPort(myfolder);
         with myfolder^ do ClipRect(portrect);
         showscroll(myfolder);
         ShowContents(myfolder);
      end; { if }
   end; { if }
   EndMsg;
end; { EndSchedDate }


{------------------------------------------------------------------------------}


procedure SetUpSchedDate(task: htask);
{ sets up dbox for entering scheduled dates on tasks and milestones }

var DateStr:    String30;
    i:          integer;    { helps me count                      }

begin { SetUpSchedDate }

   {$R-}
   { put in the string for the scheduled start date }
   if task^^.SetStart = maxval then

      { has no set date, if no preds then set to calendar start }
      if task^^.NBackward = 0 then DateString( 0, DateStr )

      { otherwise set to default, that is none }
      else DateStr := mm_dd_yy

   else DateString( RDEquiv(task^^.SetStart), DateStr);

   { stuff the string in the edit field }
   with SchedForm^^.EdFldLst[0]^^.EdItmLst[1]^^ do begin
      for i := 0 to Length(DateStr) - 1 do
         idata^^[i] := ord(DateStr[i+1]);
      idataLen := length(DateStr);
      wasEdited := false;
   end;

   { put in the string for the scheduled finish date }
   if task^^.SetFinish = minval then

      { got no finish date, if no succs then give asap }
      if task^^.NForward = 0 then DateStr := ASAP

      { else default, that is none }
      else DateStr := mm_dd_yy

   else DateString( RDEquiv(task^^.SetFinish), DateStr);

   { stuff the string into the edit field }
   with SchedForm^^.EdFldLst[1]^^.EdItmLst[1]^^ do begin
      for i := 0 to Length(DateStr) - 1 do
         idata^^[i] := ord(DateStr[i+1]);
      idataLen := length(DateStr);
      wasEdited := false;
   end;
   {$R+}

   SetUpDBox(Pointer(Ord(SchedForm)),@GetEdHit,
      @TrkEdFldMse,@RestoreEdForm,@EndSchedDate, true);
   { make sure DoIt/ForgetIt boxes are unchecked }
   with SchedForm^^.ckBox^^ do curCkItm := -1;
   ShowEdForm(SchedForm);
   keyport := dialogfolder;
   keyproc := @EdFldKeyProc;

end; { SetUpSchedDate }


{------------------------------------------------------------------------------}


procedure EndUpdForm(doItFlag: Boolean);
{ sets new days remaining value in gantt chart }

var NewDate:   tdate;
    Strng:     string30;
    i:         integer;
    newvalue:  integer;
    barrect:   rect;

begin { EndUpdForm }

   { clear the dialog box IO }
   setport(dialogfolder);
   ExitEdit(UpdateForm);

   { now see what new value has been entered }
   if doItflag then begin
      {$R-}
      docChangedFlag := true;
      { days remaining in task }
      if UpdateForm^^.EdFldLst[0]^^.EdItmLst[1]^^.wasEdited then begin
         strng := '        ';
         for i := 0 to UpdateForm^^.EdFldLst[0]^^.EdItmLst[1]^^.idataLen - 1 do
            Strng[i+1] := chr(ord(UpdateForm^^.EdFldLst[0]^^.EdItmLst[1]^^.idata^^[i]));
         newvalue := AsciiToInt(strng);
         { did it parse out to an integer ? }
         if (length(strng) <> 0) then begin
            { string didnt parse to an integer }
            stopalert(pealert, 36 {out Of Range});
         end { if }
         else begin
            { it did parse, look at the value input }
            with curselrec[activechart] do
            if (newvalue >= 0) and (newvalue <= hitresc^^.duration) then begin
               hitresc^^.remaining := newvalue;
               { redraw the bar with this new value }
               setport(myfolder);
               scaleRect(barrect,hitresc^^.bar);
               RectRgn(myfolder^.cliprgn, barrect);
               showContents(myfolder);
            end { if }
            else StopAlert(Pealert, 36 {Out of Range});
         end; { else }
         UpdateForm^^.EdFldLst[0]^^.EdItmLst[1]^^.WasEdited := false;
      end; { if }
      {$R+}
   end; { if }
   EndMsg;
end; { EndUpdForm }


{------------------------------------------------------------------------------}

{$S Events}
Procedure CreateMS;
{ changes the currently selected task to a milestone and redraws pert }

var curresc: hResc;
    theRect,
    oldbox:  rect;

begin { CreateMS }

   { change task to milestone }
   if (curselrec[activechart].tag = task) then begin

      docChangedFlag := true;
      with curselrec[activeChart] do begin
         { set up milestone info in task record, first the new box }
         ScaleRect(oldbox, curtask^^.box);
         NormVMS(curtask^^.box);

         { now fill in the other fields for milestone }
         with curtask^^ do begin
            dotline := box.bottom - box.top;
            maxduration := 0;
            curresc := resource;
            while curresc <> nil do begin
               ReturnResc(names, curresc);
               curresc := curresc^^.next;
            end; { while }
            resource := nil;
            milestone := true;
         end;

         { could change the schedule so recalc and redraw }
         ScaleRect(theRect, curtask^^.box);
         ScrollinRect(theRect);
         if showdates then begin
            with myfolder^ do clipRect(portrect);
            CalcSchedule;
            ShowContents(myfolder);
         end
         else begin
            InsetRect(therect, -6,-4);
            insetrect(oldbox, -6,-4);
            UnionRect(therect, oldbox, therect);
            with myfolder^ do cliprect(theRect);
            showcontents(myfolder);
         end; { else }
         AnyToUndo := true;
      end; { with }
   end { if }
   else
      if (curselrec[activechart].tag = document) then StopAlert(pealert, 16 {No Chart To Milestone})
      else StopAlert( PeAlert, 8 {Can't Create Milestone});
end; { CreateMS }


{------------------------------------------------------------------------------}

{$S MenuStuff}

Procedure Customize( theItem: integer );
{ Handles the curtomize menu items,  create milestone, calendar and
  drawing attributes. }

var current: htask;
    i:       integer;  { counter for chars        }
    daystr:  string3;  { string of days remaining }
    myBool:  boolean;

begin { Customize }
   case theItem of

      I_Calendar: begin { Calendar Attributes }
         { set up and display calendar dbox }
         SetUpDBox(Pointer(Ord(PCalendarForm)), @GetEdHit,
            @TrkEdFldMse, @RestoreEdForm, @EndCalCmd, true);
         { make sure DoIt/ForgetIt boxes are unchecked }
         with PCalendarForm^^.ckBox^^ do curCkItm := -1;
         ShowEdForm(PCalendarForm);
         keyport := dialogfolder;
         keyproc := @EdFldKeyProc;
      end; { Calendar Attributes }

      I_DispDates: begin { Display dates on }
         { set up and draw dialog box }
         SetUpDBox(Pointer(Ord(DatesForm)),@GetCkHit,
            @TrkCkBoxMse,@RestoreCkForm,@EndDates, false);
         { make sure DoIt/ForgetIt boxes are unchecked }
         with DatesForm^^.ckBoxLst[0]^^ do curCkItm := -1;
         { reset values to current state }
         with datesForm^^ do begin
            {$R-}
            CkBoxLst[1]^^.CurOnOff := 1 + Ord(not showES);
            CkBoxLst[2]^^.CurOnOff := 1 + Ord(not ShowEF);
            CkBoxLst[3]^^.CurOnOff := 1 + Ord(not ShowLS);
            CkBoxLst[4]^^.CurOnOff := 1 + Ord(not ShowLF);
            {$R+}
         end; { with }
         ShowCkForm( DatesForm);
      end; { display dates on }


      I_MScircle: begin { Milestone }
         CreateMS;
      end; { Milestone }

      I_ganttScale: begin { Gantt scale }
         { set up and draw dialog box }
         SetUpDBox(Pointer(Ord(GGridForm)),@GetCkHit,
            @TrkCkBoxMse,@RestoreCkForm,@EndGScale, false);
         { make sure DoIt/ForgetIt boxes are unchecked }
         with GGridForm^^.ckBoxLst[0]^^ do curCkItm := -1;
         { set current option as checked }
         {$R-}
         GGridForm^^.ckBoxLst[1]^^.curCkItm := curGridSize;
         {$R+}
         ShowCkForm(GGridForm);
      end; { gantt scale }

      I_SchedDates: begin { Scheduled start date }
         with curselrec[activechart] do
            if (activechart = pert) then begin
               if (tag = task) then begin
                  SetUpSchedDate(curtask);
               end { if }
               else StopAlert(PeAlert, 30 {No Task Selected});
            end { if }
            else StopAlert(pealert, 69 {Wrong Chart});
      end; { set schedule dates }

      I_UndoSched: begin { undo all scheduled dates }
         if CautionAlert( PEAlert, 32 {Remove Dates?}) then begin
            docChangedFlag := true;
            current := head;
            while current <> nil do begin
               with current^^ do begin
                  SetStart := maxval;
                  SetFinish := minval;
               end; { with }
               current := current^^.flink;
            end; { while }

            { recalc schedule and redisplay pert }
            if showdates then begin
               CalcSchedule;
               SetPort(myfolder);
               with myfolder^ do ClipRect(portrect);
               ShowContents(myfolder);
               ValidRgn(myfolder^.cliprgn);
            end; { if }
         end; { if }
      end; { Undo all scheduled dates }

      I_Update: begin
         with curselrec[activechart] do
            if (activechart = RescGantt) and (tag = bar)
            then begin
               { set up dbox for days remaining for this resc }
               Str(curselrec[activechart].hitresc^^.remaining, daystr);
               with Updateform^^.edfldlst[0]^^.editmlst[1]^^ do begin
                  {$R-}
                  for i := 0 to length(daystr) - 1 do
                  idata^^[i] := ord(daystr[i+1]);
                  {$r+}
                  idatalen := length(daystr);
                  wasEdited := false;
               end; { with }

               { set up dbox and lets go }
               SetUpDBox(Pointer(Ord(UpdateForm)),@GetEdHit,
                  @TrkEdFldMse,@RestoreEdForm,@EndUpdForm, true);
               { make sure DoIt/ForgetIt boxes are unchecked }
               with UPdateForm^^.ckBox^^ do curCkItm := -1;
               ShowEdForm(UpdateForm);
               keyport := dialogfolder;
               keyproc := @EdFldKeyProc;
            end { if }
            else StopAlert(PeAlert, 35 {No Bar Selected});
      end; { Update gantt }

      I_Parallel,
      I_Resource: begin
         myBool := (theItem = I_Resource);
         If (LimitResources <> myBool) Then Begin
            LimitResources := myBool;
            if (showdates) or (activechart <> Pert) then CalcSchedule
                                                    else Unschedule;
            SetPort(myFolder);
            ClipRect(myFolder^.portRect);
            ShowContents(myFolder);
            ValidRgn(myFolder^.ClipRgn);
         end;
      end;

   end; { case }
end; { Customize }


{------------------------------------------------------------------------------}


Procedure Edit( theItem: integer );
{ Handles the Edit menu items,  Cut, Paste, Copy, Undo, and select all.  }

var errnum: integer;
    error:  boolean;
    taskbox: rect;
    CenterFrom: point;
    CenterTo:   point;
    theRect:    rect;
    paper:      rect;
    loc:        point;
    dresc:      integer;

Begin { Edit }
   if not msgOn then With curselrec[activeChart] do Begin
      Case theItem of
         I_UndoLast: begin { Undo last change }
            if AnyToUndo then begin

               case tag of
                  textsel: begin
                     if undoValid then begin
                        ScaleRect(taskbox, curtask^^.box);
                        ScrollinRect(taskbox);
                        UndoEdit(htaskfield, hfstate, errnum);
                        if errnum > 0 then stopalert(pealert, 7 {No Undo})
                        else begin
                           CkHGrowth;
                           StartBlink(curtimeout);
                        end;
                     end
                     else StopAlert(PEAlert, 7 {No Undo});
                  end;

                  charttitles: begin
                     if UndoValid then begin
                        ScrollInRect(
                           titles[activeChart][index].htitlefield^^.coords);
                        UndoEdit(Titles[activeChart][index].hTitleField, hfstate, errnum);
                        if errnum > 0 then stopalert(pealert, 7 {No Undo})
                        else begin
                           If (ActiveChart < 4) Then Begin
                              ScaleHInt(loc.h, dtitleH);
                              ScaleVInt(loc.v, dtitleV + (index-1) * d2Title);
                           end
                           else GtTtlPoint(index, loc); { in Aplp/General }

                           scalePaper(paper, activechart);
                           loc.v := loc.v + paper.top;
                           PeDrawFldAt(Titles[activechart][index].hTitlefield, hfstate, loc, true, true);
                           StartBlink(curtimeout);
                        end;
                     end
                     else StopAlert(PEAlert, 7 {No Undo});
                  end;


                  fixcost, unitcsel: begin
                     if UndoValid then begin
                        ScrollInRect(hTaskField^^.coords);
                        UndoEdit(hTaskField, hfstate, errnum);

                        if errnum > 0 then stopalert(pealert, 7 {No Undo})
                        else begin
                           If PEClipToField(EditRect) Then DrawField(hTaskField, hfstate, true, true);
                           StartBlink(curtimeout);
                        end;
                     end
                     else StopAlert(PEAlert, 7 {No Undo});
                  end;

                  OtherWise begin
                     StopAlert(PEAlert, 7 {No Undo});
                  end;
               end; { case }
            end { if }

            { Used to be alert 56 - nothing since last activation, but
              this was confusing for the user }
            else Stopalert(pealert, 7 {No Undo});
         end; { Undo }

         I_Copy: Begin { Copy }
            case tag of

               Task: begin
                  PECopyTask(curtask);
               end;

               TextSel: begin
                  CutCopyField(htaskfield, hfstate, false, True, errnum);
                  if errnum > 0 then begin
                     if errnum = 3 then begin
                        ParamAlert('Copy','','');
                        StopAlert(pealert, 58 {Non Null Selection});
                     end { if }
                     else stopalert(pealert, 18 {Internal Error});
                  end { if }
                  else begin
                     MyScrapConts := atextsel;
                  end;
               end;

               ChartTitles: begin
                  CutCopyField(Titles[activeChart][index].hTitleField,
                     hfstate,false, true, errnum);
                  if (errnum = 3) Then Begin
                     ParamAlert('Copy','','');
                     StopAlert(pealert, 58 {Non Null Selection});
                  end
                  else if (errnum > 0) Then stopalert(pealert, 18 {Internal Error})
                  else MyScrapConts := atextsel;
               end;

               FixCost, UnitCSel: begin
                  CutCopyField(hTaskField, hfstate,false, true, errnum);
                  if (errnum = 3) Then Begin
                     ParamAlert('Copy','','');
                     StopAlert(pealert, 58 {Non Null Selection});
                  end
                  else if (errnum > 0) Then stopalert(pealert, 18 {Internal Error})
                  else MyScrapConts := atextsel;
               end;

               Document: begin
                  If (ActiveChart < 4) Then PECopyDocument {in aplp/scrap }
                  { Can only copy cashflow and task records }
                  Else if (ActiveChart >= CashFlow) Then TblCopyDocument; {in aplp/cost  }
               end;

               Arrow1: begin
                  StopAlert(Pealert, 14 {No Copy Arrow});
               end;

               Air: begin
                  ParamAlert('Copy','','');
                  StopAlert(Pealert, 45 {Selection Required});
               end;

               Bar: begin
                  StopAlert(Pealert, 46 {No Copy Bar});
               end;
            End; { case }
         end; { copy }

         I_Cut: Begin { Cut }
            Case Tag of

               Task: Begin
                  PECutTask(curtask);
                  AnyToUndo := true;
                End; { task }

                Arrow1:Begin
                   docChangedFlag := true;
                   RectCntr( CenterFrom, taskfrom^^.box);
                   RectCntr( CenterTo,   taskto^^.box);
                   Pt2Rect( CenterFrom, CenterTo, theRect );
                   ScrollInRect( theRect);
                   DeleteArrow(taskfrom, taskto);
                   Tag := Air;
                   if showdates then begin
                      CalcSchedule;
                      ShowContents(myfolder);
                   end { if }
                   else begin
                      InsetRect(therect,-3,-2);
                      cliprect(therect);
                      showcontents(myfolder);
                   end; { else }
                   AnyToUndo := true;
                end;

                TextSel: begin
                   docChangedFlag := true;
                   ScaleRect( taskbox, curtask^^.box);
                   ScrollInRect(taskbox);
                   setPort(myfolder);
                   CutcopyField (htaskfield , hfstate, True, True, errnum );
                   if errnum > 0 then begin
                      if errnum = 3 then begin
                         ParamAlert('Cut','','');
                         StopAlert(pealert, 58 {Non Null Selection});
                      end { if }
                      else stopalert(pealert, 18 {Internal Error});
                   end { if }
                   else begin
                      { update the  new length }
                      UndoValid := (htaskfield^^.curlen <> 0);
                      AnyToUndo := true;
                      PEDrawFldAt( htaskfield, hfstate, dx, true, true);
                      myscrapConts := atextsel;
                   end;
                end;

                ChartTitles: begin
                   docChangedFlag := true;
                   ScrollInRect(Titles[activeChart][index].htitlefield^^.coords);
                   SetPort(myFolder);
                   CutCopyField(Titles[activeChart][index].hTitleField, hfstate,
                      true, true, errnum);

                   if errnum > 0 then begin
                      if errnum = 3 then begin
                         ParamAlert('Cut','','');
                         StopAlert(pealert, 58 {Non Null Selection});
                      end { if }
                      else stopalert(pealert, 18 {Internal Error});
                   end { if }
                   else begin
                      If (ActiveChart < 4) Then Begin
                         ScaleHInt(loc.h, dtitleH);
                         ScaleVInt(loc.v, dtitleV + (index-1) * d2Title);
                      end
                      else GtTtlPoint(index, loc); { in aplp/general }

                      Scalepaper(paper, activechart);
                      loc.v := loc.v + paper.top;
                      PeDrawFldAt(Titles[activeChart][index].hTitleField, hfstate,
                      loc, true, true);
                      UndoValid := true;
                      AnyToUndo := true;
                      myScrapConts := atextsel;
                   end;
                end;

                FixCost, UnitCSel: begin
                   docChangedFlag := true;
                   ScrollInRect(hTaskField^^.coords);
                   SetPort(myFolder);
                   CutCopyField(hTaskField, hfstate, true, true, errnum);

                   if (errnum = 3) then begin
                      ParamAlert('Cut','','');
                      StopAlert(pealert, 58 {Non Null Selection});
                   end { if }
                   else if (errnum > 0) then stopalert(pealert, 18 {Internal Error})
                   else begin
                      If PEClipToField(EditRect) Then DrawField(hTaskField, hfstate, true, true);
                      UndoValid := true;
                      AnyToUndo := true;
                      myScrapConts := atextsel;
                   end;
                end;

                Air: begin
                   ParamAlert('Cut','','');
                   StopAlert(pealert, 45 {Selection required});
                end;

                Document: begin
                   ParamAlert('Document','','');
                   StopAlert(pealert, 13 {Can't Cut Object});
                end;

                Bar: begin
                   ParamAlert('Bar','','');
                   StopAlert(PeAlert, 13 {Can't Cut Object});
                end;
             End; { case }
          End; { Cut }

          I_Paste: Begin { & Paste }
             case tag of

                Task: begin
                   PePasteTask(curtask);
                   AnyToUndo := true;
                end;

                TextSel: begin
                   if myScrapConts = atextsel then begin
                      ScaleRect(taskbox, curtask^^.box);
                      ScrollinRect(taskbox);
                      PasteField(htaskfield, hfstate, errnum, false, 50{pasteLimit});
                      AnyToUndo := true;
                      UndoValid := true;

                      case errnum of
                         0: begin { ok }
                            docChangedFlag := true;
                            CkHGrowth;
                            StartBlink(curtimeout);
                         end;

                         1: begin { paste limit }
                            stopalert(pealert, 51 {Hit text Limit});
                         end;

                         4: begin  { clip incompatible }
                            ParamAlert('Text','','');
                            stopalert( pealert, 25 {clip Incompatible});
                         end;

                         otherwise StopAlert(PEAlert, 29 {Scrap Error});
                      end; { case }
                    end { if }

                    else begin
                       ParamAlert('Text','','');
                       StopAlert(pealert, 25 {Clip Incompatible});
                    end; { else }
                end;

                ChartTitles: begin
                   if myscrapConts = atextsel then begin
                      with titles[activechart][index] do begin
                         ScrollInRect(htitlefield^^.coords);
                         PasteField(hTitleField, hfstate, errnum, true, 50{pasteLimit});
                         AnyToUndo := true;
                         UndoValid := true;
                         case errnum of
                            0: begin { ok }
                               docChangedFlag := true;
                               If (ActiveChart < 4) Then Begin
                                  ScaleHInt(loc.h, dtitleH);
                                  ScaleVInt(loc.v, dtitleV + (index-1) * d2Title);
                               end
                               else GtTtlPoint(Index, loc);

                               Scalepaper(paper, activechart);
                               loc.v := loc.v + paper.top;
                               scaleHInt(dresc, drescLine[activechart]);
                               with myfolder^ do
                               SetRectRgn( clipRgn, portrect.left + dresc, portrect.top,
                               portrect.right - dhSbox + 1, portrect.bottom - dvSbox + 1);
                               PeDrawFldAt(hTitleField, hfstate, loc, true, true);
                               StartBlink(curtimeout);
                            end;

                            1: begin { field full }
                               StopAlert(pealert, 51 {Hit Text Limit});
                            end;

                            4: begin { clipIncompatible }
                               ParamAlert('Text','','');
                               stopalert(pealert, 25 {clip Incompatible});
                            end;

                            otherwise StopAlert(pealert, 29 {scrap Error})
                         end; { case }
                       end; { with }
                    end { if }
                    else begin
                       ParamAlert('Text','','');
                       Stopalert(pealert, 25 {Clip Incompatible});
                    end; { else }
                end; { chartTitles }

                FixCost, UnitCSel: begin
                   if (myscrapConts = atextsel) then begin

                      ScrollInRect(hTaskField^^.coords);
                      PasteField(hTaskField, hfstate, errnum, false, 10{pasteLimit});
                      AnyToUndo := true;
                      UndoValid := true;

                      case errnum of
                         0: begin { ok }
                            docChangedFlag := true;
                            ClipRect(EditRect);
                            If PEClipToField(EditRect) Then DrawField(hTaskField, hfstate, true, true);
                            StartBlink(curtimeout);
                         end;

                         1: begin { field full }
                            StopAlert(pealert, 77 {Hit Text Limit});
                         end;

                         4: begin { clipIncompatible }
                            ParamAlert('Text','','');
                            stopalert(pealert, 25 {clip Incompatible});
                         end;

                         otherwise Begin
                            StopAlert(pealert, 29 {scrap Error});
                         end;
                      end; { errNum case }
                   end { if }

                   else begin
                      ParamAlert('Text','','');
                      Stopalert(pealert, 25 {Clip Incompatible});
                   end; { else }
                end; { fixCost, UnitCSel }

                Air: begin
                   PEPasteAir;
                   AnyToUndo := true;
                end;

                Arrow1: begin
                   ParamAlert('Arrow','','');
                   Stopalert(pealert, 17 {Can't Paste Object});
                end;

                Document: begin
                   ParamAlert('Document','','');
                   StopAlert(pealert, 17 {Can't Paste Object});
                end;

                Bar: begin
                   ParamAlert('Bar','','');
                   StopAlert(PEAlert,17 {Can't Paste Object});
                end;
             End; { case }
          end; { paste }

          I_SelectAll: begin { Select entire document }
             MyDeselect(error);
             if not error then begin
                curselrec[activechart].tag := Document;
                setport(myfolder);
                cliprect(myfolder^.portrect);
                If (ActiveChart < 4) Then ShowContents(myFolder)
                Else TblSelReset(0{dummy}); { in APLP/Cost. InvertRects the window }
             end;
         end; { selectall }
      End; { Case }
   End; { With }
End; { Edit }


{------------------------------------------------------------------------------}

Procedure PEXModern(VAR Font: Integer);
Begin
   If      Font = p12Cent then Font := p12tile
   else If Font = p10Cent then Font := p10tile
   else If Font = Cent12  then Font := tile12
   else If Font = Cent18  then Font := tile18
   else If Font = Cent24  then Font := Tile24
   else If Font = 16      then Font := 15;
end;

Procedure PEClassic(VAR Font: Integer);
Begin
   If      Font = p12tile then Font := p12Cent
   else If Font = p10tile then Font := p10Cent
   else If Font = tile12  then Font := Cent12
   else If Font = tile18  then Font := Cent18
   else If Font = Tile24  then Font := Cent24
   else If Font = 15      then Font := 16;
end;



procedure UpDFont(index, font, format: integer);
{ updates the font and face information for a particular chart or for a title }

var Reqfid:    TLFntId;   { the font identifier  rec }
    errnum:    integer;   { error for field editor   }
    loc:       point;     { loc for erasing titles   }
    oldActual,            { the old actual value     }
    newActual: real;      { the new actual value     }
    paper:     rect;      { scaled paper rect        }
    letterQuality,
    PSOnly:    boolean;
    dResc:     integer;
    myNewFont: integer;

begin { UpdFont }

   if curselrec[activechart].tag = chartTitles then begin
      with Titles[activechart][index] do begin

         { calculate the loc for this title }
         Scalepaper(paper, activechart);

         { graphical charts put titles stacked in the middle, tables on left and right.
            See also Aplp/General: DrawTitles }
         If (ActiveChart < 4) Then Begin
            ScaleHInt(loc.h, dtitleH);
            ScaleVInt(loc.v, dtitleV + (index-1) * d2Title);
         end
         Else GtTtlPoint(Index, loc); { in Aplp/general }

         loc.v := loc.v + paper.top;

         { calc the clip region for update }
         scaleHInt(dresc, drescLine[activechart]);
         with myfolder^ do SetRectRgn( clipRgn, portrect.left + dresc, portrect.top,
            portrect.right - dhSbox + 1, portrect.bottom - dvSbox + 1);

         { move the field to this loc to update the coords rect }
         Movefield(htitlefield, hfstate, loc);

         { erase old coords rect }
         eraseRect(htitlefield^^.coords);

         { update run for text }
         UpdateRun(hTitleField,hfstate, font, format, errnum);

         { move the field to this loc to update the new coords rect }
         Movefield(htitlefield, hfstate, loc);
         PeDrawFldAt(htitlefield, hfstate, loc, true, true);
         docChangedFlag := true;
      end; { with }
   end
   else begin

      { update the font for the entire chart }
      with ReqFInfo[activeChart] do begin
         Reqfid.fam := myfont;
         Reqfid.seteface := myface;
         Reqfid.dev := devScreen;
      end; { with }

      if format = SetFont then Reqfid.fam := font
      else if format = SetNormal    then Reqfid.seteface := []
      else if format = SetUnderline then Reqfid.seteface := Reqfid.seteface + [UnderLine]
      else if format = SetBold      then Reqfid.seteface := Reqfid.seteface + [Bold]
      else if format = SetItalic    then Reqfid.seteface := Reqfid.seteface + [Italic]
      else if format = SetShadow    then Reqfid.seteface := Reqfid.seteface + [Shadow]
      { convert the current font to the requested Modern or Classic font }
      else if format = SetToModern  then Begin
         PEModern := True;
         myNewFont := reqFid.Fam;
         PEXModern(myNewFont);
         reqfid.fam := myNewFont;
      end
      else if format = SetToClassic then Begin
         PEModern := False;
         myNewFont := reqFid.Fam;
         PEClassic(myNewFont);
         reqfid.fam := myNewFont;
      end;

      if ((Reqfid.fam = ReqfInfo[activechart].myfont) and
          (Reqfid.seteface = ReqfInfo[activechart].myface)) then {do nothing, no change}
      else begin
         oldactual := PertFontInfo[activechart].actual;
         { GetFontNumbers is in Aplp/General }
         if GetFontNumbers(ReqFid, activechart) then begin
            docChangedFlag := true;

            If (activeChart = RescGantt) OR (activeChart = TaskGantt) Then CreateGantt
            else begin
               SetRunFormat( hdrawField, nil, font, format, errnum);
               SetRunFormat( htaskfield, nil, font, format, errnum);
            end;

            if scale[activechart].state = ScaleFit
            then ShowFitReduce
            else Zoom( 1.0, Scale[activechart].state);

            { was there a swap of another fixed pitch font?? }
            if ReqFinfo[activechart].myfont <> PertFontInfo[activechart].myfont then
            if CautionAlert(pealert,76) then {};
         end { if }
         else {Not undoing anything here};
      end; { else }
   end; { else }
end; { UpDFont }


{------------------------------------------------------------------------------}


Procedure TypeStyle(theItem: integer);
{ changes the font type or face for the chart titles or entire chart }

var TitleRef,
    FontZ    : integer;

begin { TypeStyle }

   With curselrec[activechart] do Begin

      { only change font if title or entire document selected }
      if (tag = chartTitles) or (tag = document) then begin
         if tag = chartTitles
         then TitleRef := index
         else titleRef := 0;

         Case theItem of

            I_PlainText: begin { Plain text }
               UpDFont( titleRef, 0, SetNormal );
            end;

            I_Underline: begin { UnderLine }
               if tag = document then StopAlert(Pealert, 44 {No Underline in Chart})
               else UpDFont( titleRef, 0, SetUnderLine );
            end;

            I_Bold: begin { Bold }
               UpDFont( titleRef, 0, SetBold);
            end;

            I_Italic: begin { Italic }
               UpDFont(  titleRef, 0, SetItalic);
            end;

            {*************************************************************************}
            I_Modern: begin
               UpDFont(  titleRef, 0, SetToModern);
            end;

            I_Classic: begin
               UpDFont(  titleRef, 0, SettoClassic);
            end;

            {*************************************************************************}
            I_8Pt20: Begin
               UpDFont( TitleRef, P20Tile, SetFont);
            end;

            I_8Pt15: Begin
               UpDFont(  TitleRef, P15Tile, SetFont);
            end;

            I_10Pt12: Begin
               If PEModern then FontZ := p12Tile
                           else FontZ := p12Cent;
               UpDFont(  TitleRef, FontZ, SetFont);
            end;

            I_12Pt10: Begin
               If PEModern then FontZ := p10Tile
                           else FontZ := p10Cent;
               UpDFont( TitleRef, FontZ, SetFont);
            end;

            { Point fonts }

            I_12Pt: Begin
               if tag = document then StopAlert(Pealert, 33 {No Ps Fonts})
               else begin
                  If PEModern then FontZ := Tile12
                              else FontZ := Cent12;
                  UpDFont(  TitleRef, FontZ, SetFont);
               end;
            end;

            I_14Pt: Begin
               if tag = document then StopAlert(Pealert, 33 {No Ps Fonts})
               else begin
                  If PEModern then FontZ := 15
                              else FontZ := 16;
                  UpDFont(  TitleRef, FontZ, SetFont);
               end;
            end;

            I_18Pt: Begin
               if tag = document then StopAlert(Pealert, 33 {No Ps Fonts})
               else begin
                  If PEModern then FontZ := Tile18
                              else FontZ := Cent18;
                  UpDFont(  TitleRef, FontZ, SetFont);
               end;
            end;

            I_24Pt: Begin
               if tag = document then StopAlert(Pealert, 33 {No Ps Fonts})
               else begin
                  If PEModern then FontZ := Tile24
                              else FontZ := Cent24;
                  UpDFont(  TitleRef, FontZ, SetFont);
               end;
            end;
         end; { case }
      end { if }
      else if theItem <> 0 then StopAlert(pealert, 22 {No Font Selected});
   end; { with }
end; { typestyle }


{------------------------------------------------------------------------------}

Procedure ActvtItem(MenuIndex, MenuItem: Integer; Flag: Boolean);
Begin
   If (Flag) Then EnableItem( Menu[MenuIndex], MenuItem)
             Else DisableItem(Menu[MenuIndex], MenuItem);
end;

{------------------------------------------------------------------------------}

Procedure CkMenuOptions;
{ enables/disables menus items according to current status,  checks items that
  are currently in effect. }

var i,
    FontZ     : integer;
    ActvtFlag : Boolean;
    PEClassicFlag: Boolean;

begin { CkMenuOptions }

   { 1.  Gray the page layout menu items appropriately. }

   { The Preview menu items are always enabled }

   { Activate the reduction menu items only for the pert and gantt charts }
   ActvtFlag := (ActiveChart < 4);
   ActvtItem(M_PageLayout, I_DontPreview,ActvtFlag);
   ActvtItem(M_PageLayout, I_DoPreview,  ActvtFlag);
   ActvtItem(M_PageLayout, I_ShowActual, ActvtFlag);
   ActvtItem(M_PageLayout, I_70Reduce,   ActvtFlag);
   ActvtItem(M_PageLayout, I_FitReduce,  ActvtFlag);

   { Activate the add pages menu items only for the pert chart }
   ActvtItem(M_PageLayout, I_RightPage,  (ActiveChart = Pert));
   ActvtItem(M_PageLayout, I_BottomPage, (ActiveChart = Pert));

   { 1.1 Gray the customize menu items }
   { Calendar item is always active }

   ActvtFlag := (ActiveChart = Pert);

   ActvtItem(M_Customize, I_SchedDates, ActvtFlag);
   ActvtItem(M_Customize, I_UndoSched,  (ActiveChart < 4));
   ActvtItem(M_Customize, I_DispDates,  ActvtFlag);
   ActvtItem(M_Customize, I_GanttScale, (ActiveChart = RescGantt) OR
           (ActiveChart = TaskGantt) OR (ActiveChart = CashFlow));
   ActvtItem(M_Customize, I_Update,     (ActiveChart = RescGantt));
   ActvtItem(M_Customize, I_MSCircle,   ActvtFlag);


   { 2. properly gray the data formats menu item }

   ActvtItem(M_FilePrint, I_DataFormats,
      (toolDateFormat <> docDateFormat) or (toolMM_DD_YY <> docMM_DD_YY));


   { 3. look at state vars.       Defined above.    Defined in aplp/globals }
   CheckItem( Menu[M_Chart],       I_Pert,          ActvtFlag);
   CheckItem( Menu[M_Chart],       I_RescGantt,     (activeChart = RescGantt));
   CheckItem( Menu[M_Chart],       I_taskGantt,     (activeChart = TaskGantt));
   CheckItem( Menu[M_Chart],       I_RescCosts,     (activeChart = RescCost));
   CheckItem( Menu[M_Chart],       I_TaskCost,      (activeChart = TaskCost));
   CheckItem( Menu[M_Chart],       I_CashFlow,      (activeChart = CashFlow));
   CheckItem( Menu[M_Chart],       I_TaskTable,     (activeChart = TaskTable));

   CheckItem( Menu[M_PageLayout],  I_DontPreview,   Not Preview);
   CheckItem( Menu[M_PageLayout],  I_DoPreview,     Preview);
   CheckItem( Menu[M_PageLayout],  I_ShowActual,    (Scale[ActiveChart].state = scaleReal));
   CheckItem( Menu[M_PageLayout],  I_FitReduce,     (Scale[ActiveChart].state = scaleFit));
   CheckItem( Menu[M_PageLayout],  I_70Reduce,      (Scale[ActiveChart].state = reduce70));

   CheckItem( Menu[M_Customize],   I_Parallel,      (Not LimitResources));
   CheckItem( Menu[M_Customize],   I_Resource,      (LimitResources));

   { 4. look at current selection }
   if curselrec[activechart].tag = document then begin
      CheckItem( Menu[M_TypeStyle],   I_PlainText, (ReqFInfo[activeChart].myface = []));
      CheckItem( Menu[M_TypeStyle],   I_UnderLine, (UnderLine in ReqFInfo[activeChart].myface));
      CheckItem( Menu[M_TypeStyle],   I_Bold,      (Bold in ReqFInfo[activeChart].myface));
      CheckItem( Menu[M_TypeStyle],   I_Italic,    (Italic in ReqFInfo[activeChart].myface));

      CheckItem( Menu[M_TypeStyle],   I_Modern,    PEModernFlag );
      CheckItem( Menu[M_TypeStyle],   I_Classic,   (Not PEModernFlag) );

      FontZ := ReqFInfo[activeChart].myfont;
      CheckItem( Menu[M_TypeStyle],   I_8Pt20,   (FontZ = p20tile));
      CheckItem( Menu[M_TypeStyle],   I_8Pt15,   (FontZ = p15tile));
      CheckItem( Menu[M_TypeStyle],   I_10Pt12,  (FontZ = p12Tile) OR (FontZ = p12cent) );
      CheckItem( Menu[M_TypeStyle],   I_12Pt10,  (FontZ = p10Tile) OR (FontZ = p10cent) );

      CheckItem( Menu[M_TypeStyle],   I_12Pt,    (FontZ = Tile12) OR (FontZ = Cent12) );
      CheckItem( Menu[M_TypeStyle],   I_14Pt,    (FontZ = 15) OR (FontZ = 16) );
      CheckItem( Menu[M_TypeStyle],   I_18Pt,    (FontZ = Tile18) OR (FontZ = Cent18) );
      CheckItem( Menu[M_TypeStyle],   I_24Pt,    (FontZ = Tile24) OR (FontZ = Cent24) );
   end
   else for i := i_PlainText to i_24Pt do CheckItem( Menu[M_TypeStyle],   i, false);

end; { CkMenuOptions }


{------------------------------------------------------------------------------}


Procedure HelpSetFace(thisFont, thisFormat: Integer);
VAR myErr: Integer;
Begin
   SetRunFormat(hDrawField, nil, thisFont, thisFormat, myErr);
   SetRunFormat(hTaskField, nil, thisFont, thisFormat, myErr);
end;

Procedure Chart(theItem:integer);
{ flips back and forth between pert, gantt and other charts }

var paper: rect;     { the scaled paper rect for active chart   }
    error: boolean;  { if cant deselect current item then error }
    errNum,
    newChart : Integer;

begin { Chart }
   If (theItem > 0) Then Begin
      newChart := theItem;
      If (newChart > 3) Then newChart := newChart-1;

      if (activechart <> newChart) then begin
         { if something selected then unselect it before you go to another chart }
         MyDeselect(error);  { in aplp/main, which calls PertDeselect, RTblDeselect etc. }
         if error then { only case is bad duration in pert, no message required here }
         else begin
            activechart := newChart;

            { Set the font and face info for this chart type }
            with ReqFInfo[ActiveChart] do begin
               HelpSetFace(myFont, SetFont);
               HelpSetFace(myFont, SetNormal);

               if (UnderLine in myface) then HelpSetFace(myfont, SetUnderLine);
               if (Bold in myface)      then HelpSetFace(myfont, SetBold);
               if (Italic in myface)    then HelpSetFace(myfont, SetItalic);
               if (Shadow in myface)    then HelpSetFace(myfont, SetShadow);
            end; { with }


            FixActual := Round(65536 * PertFontInfo[activechart].actual);
            FixFactor := Round(65536 * Scale[activechart].factor);

            { do we need to reschedule or create the gantt? }
            if (not showdates) and (activechart = pert)
            then UnSchedule
            else CalcSchedule;

            if scale[activechart].state = scaleFit then ShowFitReduce
            else begin
               setPort(myfolder);
               scalePaper(paper, activeChart);
               { set new origin according to old thumb positions }
               with myfolder^.portrect do
                  SetOrigin(trunc(CThumbPos(hsbH[activeChart])/1000.0 *(paper.right -
                            paper.left - (right - left - dhsbox)) + paper.left),
                            trunc(CThumbPos(hsbV[activeChart])/1000.0 * (paper.bottom -
                            paper.top  - (bottom - top - dvsbox)) + paper.top));
               myOrigin := myfolder^.portrect.topleft;
               ClipRect(myfolder^.portrect);

               { redraw scroll and folder contents }
               ShowScroll(myfolder);
               ShowContents(myfolder);  { in aplp/general }
               ValidRgn(myfolder^.cliprgn);
            end;
         end;
      end; { if }
   end; {if on theitem > 0 }
end; { Chart }


{-------------------------------------------------------------------------------}


Procedure MenuCommand{( theMenu,  theItem: integer )};
{ handles all menu commands from the menus, pert, gantt and other folders. }

Begin { MenuCommand }

   case theMenu of

      M_FilePrint: begin { File/Print }
            if activefolder = scrapfolder then ScrapDeskTop(theItem)
            else DeskTop(theItem);
         end;

      M_Edit: begin { Edit }
            Edit(theItem);
         end;

      M_TypeStyle: begin { Type style }
            TypeStyle(theItem);
         end;

      M_PageLayout: begin { Page Layout }
            PageLayout(theItem);
         end;

      M_Customize: begin { Customize }
            Customize(theitem);
         end;

      M_Chart: begin { Chart }
            Chart(theItem);
         end;
   end; { case  }
End; { MenuCommand }


{-------------------------------------------------------------------------------}


Procedure SetFldrName(folder: windowptr);
{ sets up the folder title in the menu item text in either scrap or my menus }

var itemStr:   str255;
    newtitle:  str255;

begin { SetFldrName }

   { get the old menu item title for Close "title" }
   if folder = scrapfolder
      then GetItem(ScrapMenu[M_FilePrint], I_CloseTitle, @ItemStr)
      else GetItem(Menu[M_FilePrint], I_CloseTitle, @ItemStr);

   { copy over the close ", add in new folder title and " }
   Delete(itemStr, pos('"', itemstr), length(itemStr));
   newtitle := '';
   GetFldrTitle(folder, newtitle);
   ItemStr := Concat(itemStr, '"', newTitle, '"');

   { set new item title }
   if folder = scrapfolder
      then SetItem(ScrapMenu[M_FilePrint], I_CloseTitle, @ItemStr)
      else SetItem(Menu[M_FilePrint], I_CloseTitle, @ItemStr);
end; { SetFldrName }


{-------------------------------------------------------------------------------}


Procedure InstallMenus{(folder: windowPtr)};
{ set up new menu items for the folder and selected chart }

var i:  integer;   { local counter for reading in new menu }

begin { InstallMenus }

   { check if installing menus for scrap or myfolder }
   if folder = scrapfolder then begin
      for i := firstScrapMenu to lastScrapMenu do InsertMenu(scrapMenus[i],i);
      SetFldrName(folder);
      drawMenuBar;
   end

   else if folder = myfolder then begin
      { stuff the current folder name into menu item text }
      SetFldrName(folder);
      for i:= firstMenu to lastMenu do InsertMenu(Menu[i],i);
      DrawMenuBar;
   end;
end; { InstallMenus }


{-------------------------------------------------------------------------------}


Procedure CleanMenus;
{ Clean out the menu items in the menu bar }

begin { CleanMenus }

   { clear items and redraw }
   ClearMenuBar;
   DrawMenuBar;

end; { CleanMenus }
end.
