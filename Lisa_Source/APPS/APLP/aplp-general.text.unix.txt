
{-------------------------------------------------------------------------------}
{                  Copyright 1983,1984, Apple Computer Inc.                     }
{                                                                               }
{   General drawing and utility routines.                                       }
{                                                                               }
{   This unit is a collection of general routines that are used by all three    }
{   charts, pert, gantt, and task.                                              }
{                                                                               }
{-------------------------------------------------------------------------------}




UNIT PEGeneral;

INTERFACE
USES
   {$U UnitStd    }  UnitStd,    { The basics }
   {$U UnitHz     }  UnitHz,
   {$U LibOs/SysCall    }  SysCall,

   {$U QuickDraw  }  QuickDraw,
   {$U FontMgr    }  FontMgr,    { Fonts & LisaGraf }
   {$U Storage    }  Storage,
   {$U GrafUtil   }  GrafUtil,

   {$U PmDecl     }  PmDecl,
   {$U Pmm        }  Pmm,

   {$U WM.Events  }  Events,     { The window manager }
   {$U WM.Folders }  Folders,
   {$U WM.Windows }  Windows,
   {$U WM.Menus   }  Menus,
   {$U wmlstd     }  WMlstd,
   {$U wmlsb      }  WMlsb,
   {$U wmlcrs     }  WMlcrs,
   {$U wmlgrow    }  WMlGrow,

   {$U PrStdInfo  }  PrStdInfo,
   {$U PrPublic   }  PrPublic,

   {$U AlertMgr   }  AlertMgr,
   {$U Dbenv      }  Dbenv,
   {$U scrap      }  Scrap,
   {$U fedec      }  fedec,
   {$U fld        }  fieldEdit,  { Misc managers }

   {$U aplp/Globals  }  PEGlobals;


{$IFC PESymbols}
{$D+}
{$ElseC}
{$D-}
{$EndC}


const

   { titles }
   maxtitles = 2;         { two title lines per chart                    }
   d2Title  = 25;         { offset of second title line from first       }
   dTitleV  = 65;         { offset of top title line from top of chart   }
   dTitleV2 = 24;         { offset of top title line for the table charts}
   dTitleH  = 360;        { h offset for titles, fixed also              }

   { pert and gantt drawing maxes }
   MaxHDrwSize = 8640;    { max number pixels in screen resolution       }
   MaxVDrwSize = 2880;    { makes about 96" by 48" max drawing           }

   dTimeLine    = 40;     { height of the time line in gantt chart       }
   dInitResc    = 80;     { width of the resource line                  }

   { zoom commands }
   Reduce70  = 1;
   ScaleFit  = 2;
   ScaleReal = 3;

type
   { chart title types }
   titleRec = record
      hTitleField:  hndField;
      dx:           point;
   end;
   titleSet = array[1..maxtitles] of titleRec;



var
   { printing globals }
   prHOffset,               { H and V offset for printed pages             }
   PrVOffset:   integer;
   prprf:       TPrRec;     { The Print record                             }
   hRes,                    { horizontal resolution, pixs per inch         }
   vRes:        TC;         { vertical resolution                          }
   PageH,                   { current printer page size  in H              }
   PageV:       integer;    { current printer page size  in V              }
   PrintRect:   rect;
   Printing:    boolean;    { we are currently doing imaging for printing  }

   MyOrigin:    point;      { current origin for myfolder                  }

   { chart titles }
   Titles: array[Pert..numCharts] of titleSet;

   FixActual,         { PertFontInfo[activechart].actual fixed equivalent }
   FixFactor:  fixed; { Scale[activechart].factor    fixed equivalent     }

   ReqPaper:   point; { requested paper size of schedule chart            }

   NextHOffset,       { offsets for printing the next page for the table charts }
   NextVOffset: Integer;

{ miscellaneous }
Procedure ScaleRect   (var result: rect; source: rect);
Procedure ScalOffRect (var result: rect; source: rect);
Procedure ScalePaper  (var result: rect; chart: integer);
Procedure UnScaleRect (var result: rect; source: rect);
Procedure ScaleVInt   (var result: integer; input: integer);
Procedure ScalOffVInt (var result: integer; input: integer);
Procedure ScaleHInt   (var result: integer; input: integer);
Procedure ScalOffHInt (var result: integer; input: integer);
Procedure RectCntr    (Var Cntr: Point; box: rect);
Procedure RectOffCntr (Var Cntr: Point;  box: rect);
Function  LineCount   (task: htask): integer;
Function  RescCount   (task: htask): integer;
Procedure CalcMaxDuration  (task: hTask);
Procedure GetMaxHV    (var maxh, maxv: integer);


{ general drawing routines }
Procedure PEDrawFldAt   (hfield: hndfield;  hfstate: hndfstate; loc: point; showselect, erase: boolean);
Procedure HideScroll    (folder: windowptr);
Procedure ShowScroll    (Folder: WindowPtr);
Procedure ShowDialog;
Procedure PreViewPrint  (chart: integer);
Procedure ScrollInRect  (theRect: Rect);
Procedure DoScroll      (dh, dv: integer);
procedure ShowContents  (folder: windowptr);
Procedure CkSBars       (portRect: rect; var neworigin: point);
Procedure Zoom          (ScaleMult: real; ScaleOpt: integer);
Procedure ShowActual;
Procedure ShowFitReduce;
Procedure Show70Reduce;
Procedure SetUpFont;
Procedure DrawPaper;

{ chart title routines, gantt and pert }
Procedure DrawTitles    (chartId: integer);
Procedure TitleHit      (downpt: point; FolderId: integer;
                         var index: integer; var found: boolean);
Procedure TitleKey      (folderID: integer; var index: integer; key: char;  shift, command: boolean);
Procedure GtTtlPoint    (Index: Integer; VAR sdx: Point);

{ printing control }
Procedure PrMyDoc       (prprf: TPrRec; fSpool: TF);
Function  GetFontNumbers(ReqFid: TLFntid; chart: integer): boolean;
Procedure IntendedFor;
Procedure DoPrint(myPrMode: PrMenuSuppress);
Procedure AdjustToPrint;





IMPLEMENTATION
{$IFC fsymok}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}
{$IFC fdbgok}
{$R+}
{$ELSEC}
{$R-}
{$ENDC}





var prHScale,
    prVScale: real;



Procedure ShowScrap; external;




{$S MainLoop}

Procedure ScaleRect{( var result, source: rect)};
{ scales a rect record by multiplying every point by the scalefactor, if printing
  then offsets the rect also. }

var ScaleH,          { the scale factor for h }
    ScaleV: fixed;   { scale factor for v     }

begin { ScaleRect }
   { draw scrap in actual size }
   if DrawingScrap then begin
      ScaleH := FixActual;
      ScaleV := ScaleH;
   end { if }

   else begin

      { if printing then h and v scales are different }
      if printing then begin
         with PertFontInfo[activechart] do begin
            ScaleH := Round(65536 * prHScale);
            ScaleV := Round(65536 * prVScale);
         end; { with }
      end

      { normal case }
      else begin
         ScaleH := FixMul( FixActual, FixFactor);
         ScaleV := scaleH;
      end;
   end; { else }

   { do nothing if scale is 1 }
   if (ScaleH = 1.0) and (ScaleV = 1.0) then begin
      result := source;
   end

   { otherwise, scale the rect }
   else with source do
   setrect(result, HiWord(FixMul(ScaleH, FixRatio(left,1))),
                   HiWord(FixMul(ScaleV, FixRatio(top,1))),
                   HiWord(FixMul(ScaleH, Fixratio(right,1))),
                   HiWord(FixMul(ScaleV, FixRatio(bottom,1))));

end; { ScaleRect }


{-------------------------------------------------------------------------------}

Procedure ScalOffRect{( var result, source: rect)};
{ scales a rect record by multiplying every point by the scalefactor, if printing
  then offsets the rect also. }


begin { ScalOffRect }
   { first scale it }
   ScaleRect( result, source);

   { if printing then offset the rect also }
   if printing then offsetRect(result, prhoffset, prvoffset);

end; { ScalOffRect }


{-------------------------------------------------------------------------------}


Procedure ScalePaper{( var result: rect; chart: integer)};
{ scales the paper rect by multiplying every point by the scalefactor }

var ScaleH,
    ScaleV: fixed;

begin { Scalepaper }
   { if printing then h and v scales are different }
   if DrawingScrap then begin
      result := paperrect[chart];
      exit(scalepaper);
   end { if }
   else begin
      if printing then begin
         with PertFontInfo[chart] do begin
            ScaleH := {prHScale}   FixRatio(hres, 90);
            ScaleV := {prVScale}   FixRatio(vres, 60);
         end; { with }
      end
      else begin
         ScaleH := Round(65536 * scale[chart].factor);
         ScaleV := scaleH;
      end;
   end;

   { do nothing if scale is 1 }
   if (ScaleH = 1.0) and (ScaleV = 1.0) then begin
      result := paperRect[chart];
   end

   { otherwise, scale the rect }
   else with paperrect[chart] do
   setrect(result, HiWord(FixMul(ScaleH, FixRatio(left,1))),
                   HiWord(FixMul(ScaleV, FixRatio(top,1))),
                   HiWord(FixMul(ScaleH, Fixratio(right,1))),
                   HiWord(FixMul(ScaleV, FixRatio(bottom,1))));

end; { ScalePaper }


{-------------------------------------------------------------------------------}


Procedure UnScaleRect{( var result, input: rect)};
{ unscales a rect. undoes what the above procedure does }

var ScaleH,
    ScaleV: fixed;

begin { UnScaleRect }
   if DrawingScrap then begin
      ScaleH := Round(65536/(PertFontInfo[activechart].actual));
      ScaleV := ScaleH;
   end { if }
   else begin

      { if printing then h and v scales are different }
      if printing then begin
         with PertFontInfo[activechart] do begin
            ScaleH := Round(65536/prHScale);
            ScaleV := Round(65536/prVScale);
         end; { with }
      end
      else begin
         ScaleH := Round(65536/(Scale[activechart].factor * PertFontInfo[activechart].actual));
         ScaleV := scaleH;
      end;
   end; { else }

   { do nothing if scale is 1 }
   if (ScaleH = 1.0) and (ScaleV = 1.0) then result := source

   { otherwise, scale the rect }
   else with source do
   setrect(result, HiWord(FixMul(ScaleH, FixRatio(left,1))),
                   HiWord(FixMul(ScaleV, FixRatio(top,1))),
                   HiWord(FixMul(ScaleH, Fixratio(right,1))),
                   HiWord(FixMul(ScaleV, FixRatio(bottom,1))));

end; { UnScaleRect }


{-------------------------------------------------------------------------------}


Procedure ScaleVInt{( var result, input: integer)};
{ scales an integer according to the scalefactor passed in }

var ScaleV: fixed;

begin { ScaleVInt }
   if DrawingScrap then ScaleV := FixActual
   else begin
      if printing then begin
         with PertFontInfo[activechart] do begin
            ScaleV := Round(65536 * prVScale);
         end; { with }
      end { if }
      else scaleV := FixMul(FixFactor, FixActual);
   end;
   result := HiWord(FixMul(ScaleV, FixRatio(input,1)));
end; { ScaleVInt }

{-------------------------------------------------------------------------------}


Procedure ScalOffVInt{( var result, input: integer)};
{ scales an integer according to the scalefactor passed in, offsets it for
  printing also }

begin { ScaleVInt }

   scaleVInt(result, input);
   if printing then result := result + prVOffset;

end; { scalOffVInt }


{-------------------------------------------------------------------------------}


Procedure ScaleHInt{( var result, input: integer)};
{ scales an integer according to the scalefactor passed in }

var ScaleH: fixed;

begin { ScaleHInt }

   if drawingScrap then ScaleH := FixActual
   else begin
      if printing then begin
         with PertFontInfo[activechart] do begin
            ScaleH := Round(65536 * prHScale);
         end; { with }
      end { if }
      else scaleH := FixMul(FixFactor, FixActual);
   end; { else }
   result := HiWord(FixMul(ScaleH, FixRatio(input,1)));
end; { ScaleHInt }

{-------------------------------------------------------------------------------}


Procedure ScalOffHInt{( var result, input: integer)};
{ scales an integer according to the scalefactor passed in, offsets it for
  printing also }

begin { ScaleHInt }

   scaleHInt(result, input);
   if printing then result := result + prHOffset;

end; { scalOffHInt }



{-------------------------------------------------------------------------------}


Procedure RectCntr{( Var Cntr: Point;  box: rect )};
{ RectCntr returns the center point of a rect. Note that it scales the rect. }

var temprect: rect;  { holds scaled rect of box }

Begin { RectCntr }

   { scale it and return the center point }
   ScaleRect( temprect, box );
   With temprect Do begin
      cntr.h := (left + right) Div 2;
      cntr.v := (top + bottom) Div 2;
   End; { With }

End; { RectCntr }


{-------------------------------------------------------------------------------}


Procedure RectOffCntr{( Var Cntr: Point;  box: rect )};
{ RectCntr returns the center point of a rect. Note that it scales the rect. }

var temprect: rect;  { holds scaled rect of box }

Begin { RectOffCntr }

   { scale it and return the center point }
   ScalOffRect( temprect, box );
   With temprect Do begin
      cntr.h := (left + right) Div 2;
      cntr.v := (top + bottom) Div 2;
   End; { With }

End; { RectOffCntr }


{-------------------------------------------------------------------------------}

Function LineCount{(task: htask): integer};

var n: integer;
    curline: htext;

begin

   n := 0;
   curline := task^^.title;
   while curline <> nil do begin
      n := n + 1;
      curline := curline^^.next;
   end;
   LineCount := n;
end;

{-------------------------------------------------------------------------------}

Function RescCount{(task: htask): integer};

var n: integer;
    curresc: hresc;

begin

   n := 0;
   curresc := task^^.resource;
   while curresc <> nil do begin
      n := n + 1;
      curresc := curresc^^.next;
   end;
   RescCount := n;
end;

{-------------------------------------------------------------------------------}

{$S Events}

Procedure CalcMaxDuration{( task: hTask )};
{ calculate the new max duration for the task }

var curresc: hResc;     { the current resource record examined }
    max:     integer;   { the max value                        }

begin { CalcMaxDuration }

   { look at all resource durations }
   curresc := task^^.resource;
   max := 0;

   { if we see a new max then update the max value }
   while curresc <> nil do begin
      if curresc^^.duration > max then
         max := curresc^^.duration;
      curresc := curresc^^.next;
   end; { while }
   task^^.maxduration := max;

end; { CalcMaxDuration }


{-------------------------------------------------------------------------------}


Procedure GetMaxHV{(var maxh, maxv: integer)};
{ calculate max h and max v coordinate values in pert network }

var curTask: hTask;     { the current task record examined }

begin { GetMaxHV }
   { get largest h coordinate value used in H }
   if tail <> nil
      then maxH := tail^^.box.right
      else maxH := 0;

   { and in v }
   maxV := 0;
   curtask := head;
   while curtask <> nil do begin
      MaxV := CMax(curtask^^.box.bottom, maxV);
      curtask := curtask^^.flink;
   end; { while }

   { scale these up to account for the font used }
   if printing then begin
      ScaleHInt(maxh, maxh);
      ScaleVInt(maxv, maxv);
   end { if }
   else begin
      maxh := trunc(PertFontInfo[pert].actual * maxh);
      maxv := trunc(PertFontInfo[pert].actual * maxv);
   end; { else }

end; { GetMaxHV }




{-------------------------------------------------------------------------------}
{                                                                               }
{       General drawing routines, public.                                       }
{                                                                               }
{-------------------------------------------------------------------------------}


procedure ShowPert; external;
procedure ShowGantt; external;

{ in Aplp/Cost }
procedure ShowRTbl; external;
procedure ShowTTbl; external;
procedure ShowFlow; external;
procedure ShowAll;  external;
Procedure TblDocStart( paper, rPrintable: Rect;
                       VAR PagesAcross, PagesDown: Integer); external;

Procedure CreateGantt;  external;
Procedure DrawTask(task: htask); external;


{$S MenuStuff}

Procedure PEDrawFldAt   {(hfield: hndfield;  hfstate: hndfstate; loc: point; showselect, erase: boolean)};
{ funnel for all field editor drawing of fields }

begin { PEDrawFldAt }

  { draw the field }
  if erase then CaretErased(hfield, hfstate);
  DrawFldAt(hfield, hfstate, loc, showselect, erase);

end; { PEDrawFldAt }


{-------------------------------------------------------------------------------}

{$S MainLoop}
Procedure HideScroll{( folder: windowptr )};
{ whites out the scroll bars for the deactivated folder }

begin { HideScroll }

   { hide the border on scrap or my folder }
   if (folder = myfolder) or (folder = scrapfolder) then
      HideSBorder( folder^.portrect);

end; { HideScroll }


{-------------------------------------------------------------------------------}


Procedure ShowScroll{( Folder: WindowPtr )};
{ Positions and draws the scroll bars for either the pert or Gantt folder,
  must eventually deal with scroll bars in the scrap. }

var
   rH, rV:     Rect;       { rects for vert and horiz scroll bars         }
   temprgn:   rgnhandle;   { rgn for clipping down to protect scroll bars }
   emptyRect: rect;        { adjust scroll bars for skewered area         }
   dResc:     integer;     { the h width of the skewered area             }
   curOrigin: point;

Begin { ShowScroll }
   { this guy only works for myfolder or the scrap }
   if (folder = scrapFolder) or (folder = myfolder) then begin

      temprgn := newrgn;

      { save the current origin of the folder }
      SetPort(folder);
      pennormal;

      { always reset origin back to origin when scroll bars were created, 0,0 }
      curOrigin := folder^.portrect.topleft;
      setOrigin(0, 0);
      CopyRgn(folder^.cliprgn, TempRgn);
      FlushRects( rH, rV);

      { Call the library routine to get the scroll bar rects }
      if folder = myfolder then begin

         { need to adjust clip rgn by difference in origin }
         OffsetRgn(myfolder^.cliprgn, -curOrigin.h, -curOrigin.v);

         emptyRect := rH;
         scaleHInt( dresc, drescLine[activechart]);
         rH.left := myfolder^.portrect.left + dResc;
         emptyRect.right := rH.left;
         SetSbRect(hsbH[activeChart], rH);
         SetSbRect(hsbV[activeChart], rV);
      end { if }
      else begin

         SetSbRect(hsbHScrap, rH);
         SetSbRect(hsbVScrap, rV);
      end; { else }

      { Redraw them and the grow box }
      { show scrolls if active, else hide them }
      if folder = activefolder then begin
         if folder = myfolder then begin
            PaintSB( hsbH[activeChart]);
            PaintSB( hsbV[activeChart]);
            fillrect(emptyRect, ltGray);
            framerect(emptyrect );
         end { if }
         else begin
            PaintSB( hsbHScrap);
            PaintSB( hsbVScrap);
         end; { else }
         PaintGrow;
      end { if }
      else HideScroll(folder);

      { reset origin back to my orign and reset to original clip rgn }
      if folder = myfolder then begin
         SetOrigin(myOrigin.h, MyOrigin.v);
         CopyRgn(temprgn, myfolder^.cliprgn);
      end;

      { now use temprgn to clip out scroll bars from current clip }
      with folder^.portrect do
         SetRectRgn(TempRgn,left,top,right - dhSbox + 1,
         bottom - dvSbox + 1);
      SectRgn(folder^.cliprgn, temprgn, folder^.cliprgn);

      disposeRgn( temprgn );
   end; { if }
End; { ShowScroll }


{-------------------------------------------------------------------------------}

Procedure RestoreDBox; external; { in file aplp/dmgr}

procedure ShowDialog;
{ draw contents of dialog box, again nothing in here }

begin { ShowDialog }

   { refresh the dialog contents }
   if msgOn then RestoreDBox;

end; { ShowDialog }



{-------------------------------------------------------------------------------}


Procedure PreViewPrint{(chart: integer)};
{ Show the page breaks that will occur when the network or chart is printed.  In order to
  avoid round off errors out on the 40th page, we need to determine the page break coords
  in the printer resolution and then scale to the screen resolution before drawing. }

const H = true;
      V = false;
var PrintPaper:     rect;        { scaled paper in printer coords }
    ScreenPaper:    rect;        { scaled paper in screen coords }
    PageCount:      integer;     { page count }
    PageLoc:        integer;     { current location on the screen }


Function ScreenLoc(PageCount: integer; Horizontal: boolean): integer;
begin
   if Horizontal
   then ScreenLoc := trunc(scale[chart].factor * 90/hres *
                           (PrintPaper.left + PageCount * (PrintRect.right - PrintRect.left)))
   else ScreenLoc := trunc(scale[chart].factor * 60/VRes *
                           (PrintPaper.top  + PageCount * (PrintRect.bottom - PrintRect.top)));
end;

begin { PreviewPrinting }
   { set up the pen }
   PenNormal; pensize(3,2); PenPat(Gray);
   printing := true; ScalePaper( PrintPaper, chart); printing := false;
   ScalePaper(ScreenPaper, chart);

   { start at left and move right across the paper }
   PageCount := 1;
   PageLoc  := ScreenLoc(PageCount, H);
   while (PageLoc > ScreenPaper.left) and (PageLoc < ScreenPaper.right) do begin
      MoveTo(PageLoc, ScreenPaper.top);
      LineTo(PageLoc, ScreenPaper.bottom);
      PageCount := PageCount + 1;
      PageLoc := ScreenLoc(PageCount, H);
   end; { while }

   { start at top and move down the paper }
   PageCount := 1;
   PageLoc := ScreenLoc(PageCount, V);
   while (PageLoc > ScreenPaper.top) and (PageLoc < ScreenPaper.bottom) do begin
      MoveTo(ScreenPaper.left,PageLoc);
      LineTo(ScreenPaper.right,PageLoc);
      PageCount := PageCount + 1;
      PageLoc := ScreenLoc(PageCount, V);
   end; { while }

   PenNormal;
end; { PreviewPrinting }


{-------------------------------------------------------------------------------}


Procedure ScrollInRect{(theRect: Rect)};
{ scroll so theRect is completely in view in the active folder.
  12/20/83: Remember to add code to scroll in the rect for the table. }

var
   paper     : rect;
   dh, dv    : integer;
   cNewThumb : integer;
   dResc,
   dTime     : integer;
   myBool    : Boolean;

begin { ScrollInRect }

   If (ActiveChart < 4) Then Begin
      { clip off rect that exceeds the paper boundary }
      ScalePaper(paper, activechart);
      myBool := SectRect(theRect, paper, theRect);

      SetPort(myfolder);
      SetOrigin(myorigin.h, myorigin.v);

      { gantt scrolls a little different than pert }
      Case ActiveChart of
         Pert: begin
            dResc := 0;
            dTime := 0;
         end;

         RescGantt, TaskGantt: Begin
            ScaleHInt( dResc, dRescLIne[activechart]);
            ScaleVInt( dTime, dTimeLine);
            if theRect.left < paper.left + dResc then theRect.left := paper.left + dResc;
            if theRect.top  < paper.top  + dTime then theRect.top  := paper.top  + dTime;
         end;
         otherwise Begin { Do Nothing } End;
      end;

      { determine if we need a scroll }
      dh := 0;  dv := 0;

      { if rect is bigger than port or left edge is not in view }
      with myfolder^ do
      if (theRect.right - theRect.left > portrect.right - portrect.left - dhsbox
          + 1 - dResc) or (portrect.left + dResc > theRect.left)
      { then put the rect at left edge of port }
      then dh := portrect.left + dResc - theRect.left
      { if the right edge is out of view }
      else if (portrect.right - dhsbox + 1) < theRect.right
         { then move right edge into view }
         then dh := portrect.right - dhsbox + 1 - theRect.right;

      { if the rect is taller than port or top edge is not in view }
      with myfolder^ do
      if (theRect.bottom - theRect.top > portrect.bottom - portrect.top - dvsbox
          + 1 - dTime) or (portrect.top + dtime > theRect.top)
      { then put the rect at top edge of port }
      then dv := portrect.top + dTime - theRect.top
      { if the bottom edge is out of view }
      else if (portrect.bottom - dvsbox + 1) < theRect.bottom
         { then move bottom edge into view }
         then dv := portrect.bottom - dvsbox + 1 - therect.bottom;


      { well, have we got one? }
      if (dh <> 0) or (dv <> 0) then begin

         { got dh, dv, now set up new thumb locations }
         { before drawing any scrolls, set origin to 0,0 }
         setport(myfolder);
         setorigin(0,0);
         ClipRect(myfolder^.portrect);
         if dh <> 0 then begin
            CNewThumb := trunc((myOrigin.h - dh - paper.left) * 1000.0/
            (paper.right - paper.left - (myfolder^.portrect.right - myfolder^.portrect.left - dHsbox)));
            SetupMvThumb( hsbH[activeChart] );
            MoveThumb(CNewThumb);
            curselrec[activeChart].curselloc.h :=
               curselrec[activeChart].curselloc.h - dh;
         end;
         if dv <> 0 then begin
            CNewThumb := trunc(1000.0 * (myOrigin.v - dv - paper.top)/
            (paper.bottom - paper.top -
            (myfolder^.portrect.bottom - myfolder^.portrect.top - dHsbox)));
            SetupMvThumb( hsbV[activeChart] );
            MoveThumb(CNewThumb);
            curselrec[activeChart].curselloc.v :=
               curselrec[activeChart].curselloc.v - dv;
         end; { if }
         { set origin back and clip back }
         setorigin(myorigin.h, myorigin.v);
         cliprect(myfolder^.portrect);

         { update the display }
         doScroll(dh, dv);
         with myfolder^ do
         SetRectRgn(cliprgn, portrect.left, portrect.top,
         portrect.right - dhsbox + 1, portrect.bottom - dvSbox + 1);
      end; { if }
   end; { if on activeChart }
end; { ScrollInRect }


{-------------------------------------------------------------------------------}



Procedure doScroll{(dh, dv: integer)};
{ does the scrolling once the caller figures out how much to scroll }


var destRect: rect;
    updateRgn: rgnHandle;
    paper:     rect;
    timeRect,
    nameRect:  rect;
    time,
    resc:      rect;

begin { DoScroll }

   with myfolder^ do begin
      setport(myfolder);
      setorigin(myorigin.h, myorigin.v);
      SetRectRgn( clipRgn, portrect.left, portrect.top,
      portrect.right - dhSbox + 1, portrect.bottom - dvSbox + 1);


      { special case the gantt folder }
      if (activeChart = RescGantt) or (activeChart = TaskGantt) then begin

         { set up the time rect and name rect according to paper size }
         SetRect(timeRect, 0, PaperRect[activechart].top, PaperRect[activechart].right,
         PaperRect[activechart].top + dTimeLine);
         SetRect(nameRect,0, TimeRect.bottom, dRescLine[activechart],
         PaperRect[activechart].bottom);
         ScaleRect( Time,  TimeRect);
         ScaleRect( Resc,  NameRect);
         scalePaper( paper, activechart);
         with myfolder^.portrect do begin
            OffsetRect(Time, CMax(left, paper.left) - time.left,
                          CMax(top,  paper.top ) - time.top);
            OffsetRect(Resc, CMax(left, paper.left) - resc.left,
                          time.bottom - resc.top - 2);
         end;


         SetRect( destRect, portrect.left, portrect.top,
         portrect.right  - dhsbox + 1,
         portrect.bottom - dvsbox + 1);
         if dh <> 0 then destRect.left := Resc.right;
         if dv <> 0 then destRect.top  := Time.bottom;

         { scroll destRect and get the update rgn }
         UpdateRgn := NewRgn;
         ScrollRect( destRect, dh, dv, updateRgn );
         Setorigin( portrect.left - dh, portrect.top - dv);
         myOrigin := portrect.topleft;
         OffSetRgn( updateRgn, -dh, -dv );

         { add to update rgn the time line if scrolling in h }
         if dh <> 0 then begin
            SetRectRgn( cliprgn, portrect.left, portrect.top,
                        portrect.right - dvsbox + 1, Time.bottom);
            UnionRgn( cliprgn, updateRgn, updateRgn );
         end; { if }

         { update the update rgn }
         CopyRgn( updateRgn, clipRgn );
         ShowContents( myfolder);
         DisposeRgn( updateRgn );
      end { if }

      else begin
         { ok, scroll the sucker and redraw }
         ScrollRect( portrect, dh, dv, cliprgn );
         Setorigin( portrect.left - dh, portrect.top - dv);
         myOrigin := portrect.topleft;
         OffSetRgn( clipRgn, -dh, -dv );
         ShowContents( myfolder);
      end; { else }
   end; { with }
end; { DoScroll }


{-------------------------------------------------------------------------------}


procedure ShowContents{(folder: WindowPtr)};
{ draws the innerds of the folder, that is everything inside the scroll bars }

var temprgn:  rgnHandle;   { used to clip out scroll bars on redraw }

begin { ShowContents }

   if not printing then begin
      { protect scroll bars, keep within current cliprgn }
      temprgn := newrgn;
      with folder^.portrect do SetRectRgn(TempRgn,left,top,right - dhSbox + 1,
      bottom - dvSbox + 1);
      SectRgn( folder^.cliprgn, temprgn, Folder^.cliprgn );
      disposeRgn( temprgn );
      SetPort(folder);
   end; { if }

   { show the contents of the various folders }
   if folder = myFolder then begin
      Case activeChart of
         Pert     : ShowPert;
         RescGantt,
         TaskGantt: ShowGantt;

         { in Aplp/Cost }
         RescCost : ShowRTbl;
         TaskCost : ShowTTbl;
         CashFlow : ShowFlow;
         TaskTable: ShowAll;
      end;
   end
   else if folder = scrapFolder  then ShowScrap
   else if folder = dialogFolder then ShowDialog;
end; { ShowContents }


{-------------------------------------------------------------------------------}


Procedure CkSBars{( portRect: rect; var neworigin: point)};
{ checks for showing, hiding and changing scroll bars }

var screenH,
    screenV: integer;
    paper:   rect;
    NewThumb:  TC;

begin { CkSBars }

   with portrect do begin
      ScalePaper(paper, activeChart);
      screenh := right - left - dhSbox;
      screenv := bottom - top - dvSbox;

      if screenH >= (paper.right - paper.left) then begin
         neworigin.h := (paper.right + paper.left - screenH) div 2;
         SetThumb(hsbH[activeChart],500);
      end
      else begin
         if paper.left > neworigin.h then neworigin.h := paper.left;
         if paper.right < neworigin.h + screenh then neworigin.h := paper.right - screenh;
         NewThumb := trunc((neworigin.h - paper.left)* 1000.0 /
         (paper.right - screenh - paper.left));
         SetThumb( hsbH[activeChart], NewThumb );
      end;

      if screenV >= (paper.bottom - paper.top) then begin
         neworigin.v := (paper.bottom + paper.top - screenv) div 2;
         SetThumb(hsbV[activeChart],500);
      end { if }
      else begin
         if paper.top > neworigin.v then neworigin.v := paper.top;
         if paper.bottom < neworigin.v + screenv then neworigin.v := paper.bottom - screenv;
         NewThumb := trunc((neworigin.v - paper.top)* 1000.0 /
         (paper.bottom - screenv - paper.top));
         SetThumb( hsbV[activeChart], NewThumb );
      end; { else }
   end; { with }
end; { CkSBars }


{-------------------------------------------------------------------------------}

Procedure Zoom{( ScaleMult: real; ScaleOpt: integer )};
{ Zooms a chart, pert or gantt. }

var neworigin,
    centerpt:  point;
    Screenh,
    screenV:   integer;
    paper:     rect;

begin { Zoom }

   { first determine what the new origin will be }
   WITH myfolder^ DO WITH portRect DO begin

      { calc the new scale factor }
      scale[activechart].factor := scale[activeChart].Factor * scaleMult;
      Scale[ActiveChart].State  := scaleOpt;
      if (ScaleOpt = ScaleReal) then Scale[activeChart].Factor := 1.0;
      FixFactor := Round(65536 * Scale[ActiveChart].factor);

      { determine new window origin, three cases according to ScaleOpt }
      screenh := right - left - dhSbox;
      screenv := bottom - top - dvSbox;

      { if we are going to actual size, then go to page 1 }
      if scaleOpt = ScaleReal then begin
         scalePaper(paper, activechart);
         neworigin := paper.topleft;
      end { if }
      else SetPt( neworigin,
            trunc(((left + right - dhsbox) div 2)* ScaleMult - screenh div 2),
            trunc(((bottom + top - dvsbox) div 2)* ScaleMult - screenv div 2));

      { check out changing, hiding, or showing the scroll bars }
      CkSBars( myfolder^.portrect, neworigin );

      { set up for a redraw }
      SetPort(myfolder);
      SetOrigin( neworigin.h, neworigin.v );
      myOrigin := neworigin;
      ClipRect( portrect );
      ShowScroll(myfolder);
      showContents(myfolder);
   end; { with }
end; { Zoom }


{------------------------------------------------------------------------------}



Procedure ShowFitReduce;
{ shows a chart in scale to fit mode }

var screenh,             { length of screen in h    }
    screenV,             { length of screen in v    }
    paperH,              { length of paper in h     }
    paperV:    integer;  { length of paper in v     }
    MultH,               { the h multiplier for fit }
    MultV,               { the v multiplier for fit }
    Mult:      real;     { the multiplier used      }
    paper:     rect;     { scaled paper rect        }

begin { ShowFitReduce }

   { figure out what scale multiplier should be, then zoom }
   with myfolder^ do with portrect do begin
      {trouble with scaling if screen goes to 0 length or width}
      screenh := CMax(right - left - dhsbox, 200);
      screenv := CMax(bottom - top - dvsbox, 100);
   end;
   ScalePaper(paper, activechart);
   with paper do begin
      paperh := right - left + 6;
      paperv := bottom - top + 4;
   end;
   Multh := screenh/paperh;
   Multv := screenv/paperv;
   if Multh < multV then Mult := MultH
   else Mult := multV;

   Zoom(Mult, ScaleFit);
end; { ShowFitReduce }


{------------------------------------------------------------------------------}


Procedure ShowActual;

begin

   if Scale[activeChart].state <> ScaleReal then begin
      Zoom( 1/Scale[activeChart].factor, ScaleReal );
   end;
end; { ShowActual }


{------------------------------------------------------------------------------}

Procedure Show70Reduce;

var screenh,
    screenV,
    paperH,
    paperV:    integer;
    paper:     rect;

begin

   with myfolder^ do with portrect do begin
      screenh := right - left - dhsbox;
      screenv := bottom - top - dvsbox;
   end;
   scalePaper( paper, activechart);
   with paper do begin
      paperh := right - left;
      paperv := bottom - top;
   end;
   if (screenH > paperH) and (screenV > paperV)
   then StopAlert(PeAlert,28 {No More Zooming})
   else begin
      if (screenh >= trunc(0.70 * paperh)) and (screenv >= trunc(0.70 * paperv))
      then showfitReduce
      else Zoom(0.70, Reduce70 );
   end;
end; { Show70Reduce }


{------------------------------------------------------------------------------}

Procedure SetUpFont;
begin
   with PertFontInfo[activechart] do begin
      TextFont(myfont);
      TextFace(myface);
      TextMode(srcOr);
   end;
end;


{-------------------------------------------------------------------------------}


Procedure DrawPaper;
{ Sets up the clip region for the folder to be the portrect minus the
  scroll bar area intersected with the paper rect. While doing this, the paper
  boundary is painted gray. }

var
   paper:   Rect;        { the scaled paper rect              }
   ARgn:    RgnHandle;   { a temporary rgn for paper boundary }

begin { DrawPaper }

   { create a new rgn }
   ARgn := newRgn;

   { define paper region, subtract paper from current clip }
   Scalepaper( Paper,  activeChart);
   RectRgn( ARgn, Paper );
   DiffRgn( theport^.clipRgn, ARgn, ARgn );

   { paint the paper boundary gray }
   if not Printing then fillRgn( ARgn, gray );

   { draw the paper outline }
   insetrect( Paper, -3, -2);
   pennormal;   pensize(3,2);
   if not Printing then framerect(Paper);

   { clip to protect the paper boundary }
   scalePaper(paper, activechart);
   RectRgn( ARgn, paper );
   SectRgn( theport^.clipRgn, ARgn, theport^.cliprgn);
   DisposeRgn( Argn );

end; { DrawPaper }


{-------------------------------------------------------------------------------}

Procedure DrawTitles{( chartId: integer)};
{ draw/print titles for pert or gantt }

var i: integer;
    loc: point;
    state: hndfstate;
    paper: rect;

begin

   { if this is at actual size for a particular font then show titles }
   if (Scale[chartID].state = ScaleReal) or printing or drawingScrap then begin
      ScalePaper(paper, activechart);

      for i := 1 to maxtitles do begin

         { scale to current scale multiple. See also TitleKey below. }
         { graphical charts put titles stacked in the middle }
         If (ChartId < 4) Then Begin
            ScalOffHInt(loc.h, dtitleH);
            ScalOffVInt(loc.v, dtitleV + (i-1) * d2Title);
         end

         { tabular charts put titles on left and right sides }
         Else Begin
            GtTtlPoint(i, loc);
         end;
         loc.v := loc.v + paper.top;

         state := nil;
         if ((not printing) and (curselrec[chartID].tag = charttitles)) then
            with curselrec[chartID] do
               if I = index then state := hfstate;

         MoveField(titles[chartID][i].htitlefield, state, loc);
         PeDrawFldAt(Titles[chartID][i].hTitlefield, state, loc, true, true);
      end;
   end;
end; { DrawTitles }


{-------------------------------------------------------------------------------}

{$S MainLoop}

Procedure TitleHit{(downpt: point; FolderId: integer;
                    var index: integer; var found: boolean)};
var hitrect: rect;

begin { titleHit }

   index := 1;  found := false;
   while (not found) and (index <= maxtitles) do begin
      hitrect := Titles[FolderId][index].hTitleField^^.coords;
      insetRect( hitrect, -6, 0);
      if PtinRect(downpt, hitrect )
      then found := true
      else index := index + 1;
   end; { while }
end; { titleHit }


{-------------------------------------------------------------------------------}

{$S MainLoop}

Procedure TitleKey{(folderID: integer; var index: integer; key: ascii;  shift,
                    command: boolean)};
{ This procedure handles a keystroke for chart title edit. Note that we are
  currently ignoring the arrow keys. }

const
   buffH      =  20;         { pixel buffering for title }

var
   errnum:    integer;       { error for field edit      }
   paper:     rect;          { scaled paper rect         }
   sdx:       point;         { scaled drawing point      }
   dResc,
   dTime:     integer;

Begin { TitleKey }
   docChangedFlag := true;

   { set up for key entry into chart title }
   setport(myfolder);
   Case activeChart of

      Pert, RescCost, TaskCost, CashFlow,
      TaskTable: With myFolder^, portRect do Begin
         SetRectRgn(clipRgn, left, top, right - dhSbox + 1, bottom - dvSbox + 1);
      end;

      RescGantt, TaskGantt: begin
         scaleHInt(dResc, dRescLine[activechart]);
         scaleVInt(dTime, dTimeLine);
         with myfolder^, portrect do
            SetRectRgn( clipRgn, left + dResc,       top + dTime,
                                 right - dhSbox + 1, bottom - dvSbox + 1);
      end;
   end;

   { graphical charts put titles stacked in the middle. See also DrawTitles above }
   If (ActiveChart < 4) Then Begin
      ScaleHInt(sdx.h, dtitleH);
      ScaleVInt(sdx.v, dtitleV + (index-1) * d2Title);
   end

   { tabular charts put titles on left and right sides }
   Else Begin
      GtTtlPoint(Index, sdx);
   end;

   ScalePaper(paper, activechart);
   sdx.v := sdx.v + paper.top;

   { look at key, some require special handling }
   case ord(key) of

      ArwUP,
      ArwDown,
      ArwRight,
      ArwLeft: begin
         { ignore these keys for now }
      end;

      Clear: begin
         ClearField(Titles[folderID][index].hTitleField, hfstate, errnum);
         PeDrawFldAt(Titles[FolderID][index].hTitleField, hfstate, sdx, true, true);
      end;

      tabKey,
      return: begin
         { move to another field, up or down depending on the shift }
         UndoValid := false;
         ExitField(Titles[folderID][index].hTitleField, hfstate);
         if shift then index := index - 1
                  else index := index + 1;
         if (index > maxtitles) or (index < 1) then begin
            curselrec[folderID].tag := air;
         end
         else begin
            SelectAll(Titles[FolderID][index].hTitleField, hfstate, curtimeout);
         end;
      end;

      enter: begin
         { enter and stay }
         ExitField(Titles[FolderID][index].hTitleField, hfstate);
         SelectAll(Titles[FolderID][index].hTitleField, hfstate, curtimeout);
      end;

      Bspace: begin
         { look at shift and command keys for direction }
         if shift and not command then
            ForwardSpace(Titles[FolderID][index].hTitleField, hfstate, errnum)
         else if not shift and command then
            BackWord(Titles[FolderID][index].hTitleField, hfstate, errnum)
         else if shift and command then
            ForwardWord(Titles[FolderID][index].hTitleField, hfstate, errnum)
         else
            BackSpace(Titles[FolderID][index].hTitleField, hfstate, errnum);

         PeDrawFldAt(Titles[FolderID][index].hTitleField, hfstate, sdx,true,true);
      end;

      otherwise begin
         { just add a new key }
         InsCh( key,Titles[FolderID][index].hTitleField, hfstate, errnum );
         if errnum = 1 then stopalert(pealert, 51 {Hit Text Limit});
         PeDrawFldAt(Titles[FolderID][index].hTitleField, hfstate, sdx, true, true);
      end; { otherwise }
   end; { case }
End; { TitleKey }


Procedure GtTtlPoint{(Index: Integer; VAR sdx: Point)};
{ Returns the title point for the indexth title in a table chart }
Begin
   sdx.H := (40 * Index - 20) * PertFontInfo[ActiveChart].mSpace;
   sdx.V := TableTop Div 2;

   If Printing Then With sdx do Begin
      H := H + prHOffset;
      V := V + prVOffset;
   end;
end;


{------------------------------------------------------------------------------}

{$S PrintGeneral}

PROCEDURE PrMyDoc {prprf: TPrRec; fSpool: TF}; {PS}
{ Prints the doc. }

VAR cErr:        TC;
    rBand:       Rect;
    finfo:       Fontinfo;
    pagesAcross,
    pagesDown,
    column,
    row:         integer;
    paper:       rect;
    myBool,
    done :       boolean;
    prPort:      tPrPort;

{------------------------------------------------------------------------------}


PROCEDURE MyDocStart;
{Stuff I do at the start of printing}

VAR fOk:   TF;
    lfntid:TLfntid;
    maxH,                { maximum h value used in drawing    }
    maxV:    integer;    { maximum v value used in drawing    }

BEGIN { MyDocStart }
   printing := true;
   {Get any formatting information I may need:}
   with PertFontInfo[activechart] do begin
      PrLFntId(prprf, myFont, myFace, lfntId);
      fOk := FMFontMetrics (lfntid, finfo, cErr);
      if (fOk AND (cErr=0)) then with finfo do begin
         { calc the printer lspace }
         lSpace := Ascent+ Descent+ Leading;
         mSpace := widmax;

         prhScale := actual * hres/90;
         prvScale := actual * vres/60;
      end;
   end;

   hRes := prprf.Prinfo.hres;
   VRes := prprf.PrInfo.vres;

   ScalePaper(paper, activechart);
   with prprf.PrInfo do begin
      Case activechart of
         pert: begin
            GetMaxHV(maxh, maxv);
            pagesAcross  := MaxH div (rprintable.right - rprintable.left);
            pagesDown    := MaxV div (rprintable.bottom - rprintable.top);
         end;

         RescGantt, TaskGantt: Begin
            pagesAcross  := (paper.right - paper.left) div (rprintable.right - rprintable.left);
            pagesDown    := (paper.bottom- paper.top)  div (rprintable.bottom - rprintable.top);
         end;

         otherwise TblDocStart(paper, rPrintable, pagesAcross, PagesDown); { in Aplp/Cost }
      end;

      PrHOffset   := rprintable.left - paper.left;
      PrVOffset   := rprintable.top  - paper.top;
      NextHOffset := PrHOffset;
      NextVOffset := PrVOffset;
      PrintRect   := rprintable;
   end; { with }
END; { MyDocStart }


{------------------------------------------------------------------------------}


PROCEDURE MyPageStart(row, column: integer);
{Stuff I do at the start of a page  }

BEGIN
{Set up for the next page.}
END;


{------------------------------------------------------------------------------}


PROCEDURE PrintMyPage;
{Code to print the current page     }

BEGIN { PrintMyPage }
   Case activechart of
      pert     : Showpert;
      RescGantt,
      TaskGantt: ShowGantt;
      RescCost : ShowRTbl;
      TaskCost : ShowTTbl;
      CashFlow : ShowFlow;
      TaskTable: ShowAll;
   end;
END; { PrintMyPage }


{------------------------------------------------------------------------------}


PROCEDURE MyDocEnd;
{Stuff I do at the end of printing  }
var lfntid:TLfntid;
    errnum: integer;

BEGIN { MyDocEnd }
   printing := false;
   with PertFontInfo[activechart] do begin
      lfntid.fam := myfont;
      lfntid.seteface := myface;
      lfntid.dev := devScreen;
      if FmFontMetrics(lfntid, fInfo, Errnum) then with finfo do begin
         lSpace  := Ascent+ Descent+ Leading;
         mSpace  := widmax;
      end;
   end;
END; { MyDocEnd }


{------------------------------------------------------------------------------}


Procedure MyOffsetPage(column, row: integer);
{ reset proffsets to current page }

begin
   If (ActiveChart < 4) Then Begin
      PrHOffset := PrintRect.left - paper.left - column * (Printrect.right - PrintRect.left);
      PrVOffset := PrintRect.top  - paper.top  - row    * (PrintRect.bottom - PrintRect.top);
   end

   { Table charts use offsets lying exactly on cell boundaries }
   Else Begin
      { Reset the V offsets to move down to the next page }
      PrVOffset := NextVOffset;

      { Reset both offsets when starting a new column }
      If (Row = 0) Then Begin
         PrHOffset := NextHOffset;
         PrVOffset := PrintRect.Top - paper.Top;
      end;
   end;
end;


{------------------------------------------------------------------------------}


BEGIN { PrMyDoc }
   { Set up for printing }
   If PrDocStart (prprf, prport, 7, true) Then Begin
      { Get the font info and the printing offsets }
      MyDocStart;

      { print in direction that favors landscape for charts, profile for tables }
      Row := 0; Column := 0;
      done := False;

      Repeat Begin
         If prPageStart(prPrf, PrPort) Then Begin
            myPageStart(row, column);
            myOffsetPage(column, row);
            PrintMyPage;

            { Normally returns false. Certain special printer conditions return True here }
            myBool := PrPageEnd(prPrf, prPort);

            { Reset the row and column indices for the next page }
            { Print left to right for the charts }
            If (ActiveChart < 4) Then Begin
               Column := Column + 1;
               If (Column > pagesAcross) Then Begin
                  Column := 0;
                  Row    := Row + 1;
                  Done   := (Row > PagesDown);
               end;
            end

            { Print top to bottom for the tables }
            else begin
               Row := Row + 1;
               If (Row > PagesDown) Then Begin
                  Row    := 0;
                  Column := Column + 1;
                  Done   := (Column > pagesAcross);
               end;
            end;
         end;
      end Until (myBool {Special printer end} or Done {all pages printed});
   end; { if on PrDocStart }

   PrDocEnd (prPrf, prPort);
   MyDocEnd; {Don't close up shop until after the above dispatch!}

   BeginUpdate(myfolder);
   if not EmptyRgn(myfolder^.visrgn) then begin
      setport(myfolder);
      cliprect(myfolder^.portrect);
      showscroll(myfolder);
      showContents(myfolder);
   end;
   EndUpdate(myfolder);
end; { PrMyDoc }


{------------------------------------------------------------------------------}

{$S MainLoop}

Procedure AdjustToPrint;
{ adjust the drawing size for a new paper rect, this will possibly grow the drawing size
  to include all of the old drawing.  This gets called by the fileIO code when a new file
  is read in.  Also gets called when a new print preference is set up. }

var maxH,                  { maximum h value used in drawing    }
    maxV:      integer;    { maximum v value used in drawing    }

begin { AdjustToPrint }

   { make paper big enough for drawing with new page multiple }
   { look at the requested paper size, and the size the guy is}
   { using for his picture,   don't look at the current size  }
   GetMaxHV( maxh, maxv );
   with paperRect[pert] do begin

      right  := CMin(trunc(CMax(ReqPaper.h, maxH)/pageh + 0.99)* pageh, MaxHDrwSize);

      bottom := CMin(trunc(CMax(ReqPaper.v, maxV)/pagev + 0.99)* pagev, MaxVDrwSize);
   end; { with }
end; { AdjustToPrint }


{------------------------------------------------------------------------------}

{$S PrintGeneral}

Function AdjustDrawing(oldactual, newactual: real; chart: integer): boolean;
{ recalcs the drawing size to a page multiple for pert when user goes to a new font for the chart
  returns false if new font caused drawing to be larger than the max }

var maxH,                  { maximum h value used in drawing    }
    maxV:      integer;    { maximum v value used in drawing    }

begin { AdjustDrawing }

   AdjustDrawing := true;
   if chart = pert then begin

      { get max paper size in h and v }
      PertFontInfo[pert].actual := newactual;
      GetMaxHV( maxh, maxv );

      { set if paper is big enough for new font }
      with paperRect[pert] do begin
         if right < maxh then begin
            if maxh > MaxHDrwSize then begin
               PertFontInfo[chart].actual := oldactual;
               AdjustDrawing := false;
               exit(adjustDrawing);
            end { if }
            else begin
               right := CMin(trunc(maxh/pageh + 0.99)* pageh, MaxHDrwSize);
               ReqPaper.h := right;
            end; { else }
         end; { if }

         if bottom < maxv then begin
            if maxv > MaxVDrwSize then begin
               PertFontInfo[chart].actual := oldactual;
               AdjustDrawing := false;
               Exit(AdjustDrawing);
            end
            else begin
               bottom := CMin(trunc(maxv/pagev + 0.99)* pagev, MaxVDrwSize);
               ReqPaper.v := bottom;
            end; { else }
         end; { if }
      end; { with }
   end; { if }
end; { AdjustDrawing }


{------------------------------------------------------------------------------}

Function GetFontNumbers{( ReqFid: TLFntid; chart: integer): boolean};

var realFid:  TLFntId;
    errnum:   integer;
    finfo:    Fontinfo;
    oldactual,
    newactual: real;

begin

   { now map to printer font that matches up as close as we can }
   { I have fid to be what the guy asked for }
   RealFid := Reqfid;
   {RealFid.dev := PrDev(prprf); ???}
   FmMapFont(RealFid, errnum);
   RealFid.dev := devScreen;

   { get font size info }
   if not FmFontMetrics(RealFid, fInfo, Errnum) then StopAlert(Pealert, 18 {Internal Error})
   else begin

      SetPort(myfolder);
      TextFont(RealFid.fam);
      TextFace(RealFid.seteface);
      oldActual := PertFontInfo[chart].actual;
      With finfo do NewActual  := (Ascent+ Descent+ Leading)/p15lspace;
      if (charWidth('m')/p15mspace > NewActual) then NewActual := charWidth('m')/p15mspace;

      { will the new font keep the schedule chart within the max limits?? }
      if AdjustDrawing(oldActual, NewActual, chart) then begin

         { new font is ok, go for it }
         with PertFontInfo[chart] do begin
            myfont := Realfid.fam;
            myface := Realfid.seteface;

            ReqFInfo[chart].myfont := Reqfid.fam;
            ReqFInfo[chart].myface := Reqfid.seteface;

            { get the new numbers }
            ascent  := finfo.Ascent;
            descent := finfo.Descent;
            with finfo do lSpace  := Ascent+ Descent+ Leading;
            mSpace  := CharWidth('m');
            lSpTop  := Round((lSpace-ascent-descent)/2);
            offset  := lSpTop+ascent-Round(lSpace/2);
            actual  := NewActual;
            if chart = activechart then FixActual := Round(65536 * actual);

         end; { with }
         GetFontNumbers := true;
      end { if }
      else begin
         StopAlert(pealert, 53 {No Paper});
         GetFontNumbers := false;
      end; { else }
   end; { else }
end; { GetFontNumbers }


{------------------------------------------------------------------------------}


Function NewPrPrf(    PSOnlyAlert, WrongFPAlert: integer;
                  var PSOnlyResponse, WrongFPResponse: boolean) : boolean;

var
    ReqFid:     tLFntId;   { the requested font and face }
    oldactual:  real;
    LetterQuality,
    PSOnly:     boolean;

begin

   { set up new prprf, see if this is OK }
   with prprf.PrInfo do begin

      { figure out my page size in screen resolution }
      PageH := trunc(((rprintable.right - rprintable.left)/ hres) * 90);
      PageV := trunc(((rprintable.bottom - rprintable.top)/ vres) * 60);
      PrintRect := rprintable;
   end; { with }

   { hres, vres }
   hres := prprf.PrInfo.hres;
   vres := prprf.PrInfo.vres;

   { save the old scale factor for the active chart }
   oldactual := PertFontInfo[activechart].actual;

   { set up real font number for pert }
   with ReqFid do begin
      fam := Reqfinfo[pert].myfont;
      seteface := Reqfinfo[pert].myface;
      dev := devScreen;
   end; { with }
   if GetFontNumbers(ReqFid, Pert) then begin

      { if change OK for Pert then OK for other charts }
      docChangedFlag := true;
      with ReqFid do begin
         fam := Reqfinfo[RescGantt].myfont;
         seteface := Reqfinfo[RescGantt].myface;
         dev := devScreen;
      end; { with }
      if GetFontNumbers(ReqFid, RescGantt) then {};
      with ReqFid do begin
         fam := Reqfinfo[TaskGantt].myfont;
         seteface := Reqfinfo[TaskGantt].myface;
         dev := devScreen;
      end; { with }
      if GetFontNumbers(ReqFid, TaskGantt) then {};

      { do some more fanagleing }
      AdjustToPrint;
      if (activechart <> Pert) then CreateGantt;

      { was there a swap of another fixed pitch font?? }
      if ReqFinfo[activechart].myfont <> PertFontInfo[activechart].myfont then begin
         if WrongFPAlert <> 0 then WrongFPResponse := CautionAlert(pealert,WrongFPAlert)
         else WrongFPResponse:= true;
      end;

      { show the drawing }
      if scale[activechart].state = ScaleFit then ShowFitReduce
      else Zoom( PertFontInfo[activechart].actual/oldactual, Scale[activechart].state);

      NewPrPrf := true;
   end { if }
   else NewPrPrf := false;
end; { NewPrPrf }


{------------------------------------------------------------------------------}


Procedure IntendedFor;
{ sets up the Intended For printer... dialog }

var
    fNewStl,
    fPgSzSuppress:    TF;
    Copyprprf:  tPrRec;
    PSonlyResponse,
    WrongFpResponse: boolean;

begin { IntendedFor }

   { save it off just in case of a problem }
   CopyPrprf := prprf;

   { call the print manager dialog, pull out the up event }
   fPgSzSuppress := True; {???}
   PrPrfDlg (prprf, fNewStl, fPgSzSuppress );

   { if this is a new printer preference then set up for it }
   IF fNewStl then begin

      if NewPrPrf(71, 72, PSOnlyResponse, WrongFPResponse )
      then ValidRgn(myfolder^.cliprgn)
      else begin
         { not OK, undo it }
         PrPrf := CopyPrPrf;
         if NewPrPrf(0, 0, PSOnlyResponse, WrongFpREsponse ) then {OK}
         else {BadNews!};
      end;
   end; { if }
end; { IntendedFor }


{------------------------------------------------------------------------------}



Procedure DoPrint{(myPrMode: PrMenuSuppress)};
{ begin the print process. myPrMode = ePrNormal to put up dialogs, or
                           myPrMode = ePrDialogSuppress to print one copy as is. }

var fDoIt,
    fNewStl:    TF;
    cErr:       TC;
    CopyPrPrf:  tPrRec;
    PSonlyResponse,
    WrongFpResponse,
    Bool:       boolean;

begin { DoPrint }
   { save off old preference in case of a problem }
   CopyPrPrf := PrPrf;
   PSOnlyResponse := true;
   WrongFpResponse := true;

   { set up dialog using myPrMode parameter passed in. }
   fDoIt := FPrInsDlg (prprf, fNewStl, myprMode);

   { *** COMMENTED OUT 3/5/84 if we have an error then alert user
   if cErr <> 0 then NoteAlert(pealert, 64) else begin     ******  }

   { if new printer set up then handle it }
   IF fNewStl then begin

      if NewPrPrf(73, 74, PSOnlyResponse, WrongFpResponse) then {OK}
      else begin
         PrPrf := CopyPrPrf;
         FDoIt := false; {dont print}
         if NewPrPrf(0, 0, Bool, Bool) then {OK}
         else {BadNews!}
      end;
   end { if }

   else begin
      { no new printer preference, just redisplay }
      setport(myfolder);
      cliprect(myfolder^.portrect);
      showscroll(myfolder);
      showContents(myfolder);
   end; { else }

   { if we are going to print, then do it }
   if fDoit and PSOnlyResponse and WrongFPResponse then begin
      prMyDoc(prprf, true {print in background});
   end; { if }
end; { DoPrint }

end.
