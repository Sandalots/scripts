(*   Prototype menu procedure:
PROCEDURE XXXxMenu(item:integer);
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   CASE item of
      :
         BEGIN
         END;
      :
         BEGIN
         END;
      :
         BEGIN
         END;
      :
         BEGIN
         END;
      END;
   END;

*)



{$S lmcolvismenu}
PROCEDURE ColVisMenu(item:integer);

   VAR VisString: STRING[20];
       VisPtr: PtrData;
       Vis: BOOLEAN;
       Len: INTEGER;
       STATUS : INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Stuff a string into the current field}
   if PrintProcs then writeln('ColVisMenu');
   VisPtr := @VisString;

   CASE item of
      MvOn: Vis := TRUE;
      MvOFF: Vis := FALSE;
      END;

   GenVisible(Vis,@VisPtr^[1],Len);
   VisPtr^[0] := Len;
   SetCellStr(VisString);
   if CellError then
      BEGIN
      {restore error message};
      Promptstring := ListTitle;
      shoTitle;
      CellError := FALSE;
      END;

   EnterStuff(Status);
   IF Status <> 0 THEN
      BEGIN
      ErrSelect(Status);
      END;
   DoSelCr(CurRange,curTimeout,selectCell);
   END;



{$S lmdtypemenu}
PROCEDURE DTypeMenu(item:integer);

   VAR TypeString: STRING[20];
       TypePtr: PtrData;
       Len: INTEGER;
       DType: INTEGER;
       Status : INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('DTypeMenu');
   TypePtr := @TypeString;
   CASE item of
      MdCharacter: DType := Lets;
      MdNumber: DType := Num;
      MdSSN: DType := SS;
      MdZipCode: DType := Zip;
      MdDate: DType := Dt;
      MdTime: DType := Tim;
      MdTelephone: DType := Ph;
      MdMoney: DType := Dol;
      END;

   GenDataType(DType,@TypePtr^[1],Len);
   TypePtr^[0] := Len;
   SetCellStr(TypeString);
   if CellError then
      BEGIN
      {restore error message};
      Promptstring := ListTitle;
      shoTitle;
      CellError := FALSE;
      END;

   EnterStuff(Status);
   IF Status <> 0 THEN
      BEGIN
      ErrSelect(Status);
      END;
   DoSelCr(CurRange,curTimeout,selectCell);

   END;


{$S lmeditmenu}
PROCEDURE EditMenu(item:integer);
   Label 10,11,12,20,100;

   const
       em = 'editmenu';

   VAR status : integer;
       row,col,thisrow,nextrow : idtype;
       startrg:range;
       temprg:range;
       rowband,colband : tmband;
       atmstate : tmstate;
       skind : selkind;
       errfile:TAlertFile;
       sstate : scstate;
       saveop:integer;
       sstat : integer;
       HZPtr : THeap;
       i : integer;
       tabrecord : TableRecord;
       ch : char;
       crgkind : rgkind;
       utextdup : boolean;
       rowdup : boolean;
       coldup : boolean;
       ucols : integer;
       fecheck : boolean;
       alerttype : integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('EditMenu');
   {make scrap pnl consistent with scrap window, so a cut or a copy to it
    will do the right thing}
   chgpnlsize(scrappnl,scrapfolder^.portrect.right-dhsbox+1,
                             scrapfolder^.portrect.bottom-dvsbox+1);

   {if we are doing some kind of modification, make sure the stuff being
    modified is visible on the screen}

   {assign rkind to a local}
   CRgKind := currange.rkind;

   if (NOT ((CRgKind = aNullRg) or (CRgKind = aWTBoxRg) or
           (CRgKind = aColGrid) or (CRgKind = aRowGrid)))
       and (NOT ((item = copym)  or (item = seltbl))) then
            makergVisible(CurRange,CurRange);

   CASE item of  { Edits menu }
      Clear:
         BEGIN
         if ClearOK then
            begin
            case ActivePnl of

               cWidePnl,
               cTblPnl:
                    BEGIN
                    If( CRgKind = a1CellRg ) OR (CRgKind = aColHedRg) OR
                      (CRgKind = aRowHedRg) THEN
                      begin
                      {if  a whole cell is selected, convert it to a text selection}
                      getselkind(skind);
                      if skind = a1CellSl then
                         begin
                         DoSelCr(CurRange,Curtimeout,SelectContents);
                         wholeselected := false;
                         end;

                      if CellError then
                         BEGIN
                         {restore error message};
                         CellError := FALSE;
                         Promptstring := ListTitle;
                         shoTitle;
                         END;
                      ClearSel(status);
                      if status <> 0 then errselect(status+feerr);
                      end

                    ELSE if (CRgKind = aRowRg)
                         or (CRgKind = aColRg)
                         or (CRgKind = aRectRg)
                         or ((CRgKind = aWTBoxRg) and (CurTable = tList))  then
                       BEGIN
                       mmscraprg := currange;
                       if (CRgKind = aWTBoxRg) or (CRgKind = aColRg) then
                         begin
                         SwitchTable(TRUE,tabrecord);
                         ClearRg(CurRange);
                         SwitchTable(FALSE,tabrecord);
                         tmshonewtbl;
                         end
                       else
                         begin
                         if (CRgKind = aRectRg) then ClearSel(status);
                         ClearRg(CurRange);
                         newrgimg(currange);
                         end;
                       doselcr(currange,curtimeout,selectcell);
                       END
                    ELSE if ((CRgKind = aWTboxRg) and (CurTable = tSearch)) then
                       BEGIN
                       GetSnipId(rowkind,mmfirst,0,row,row);
                       ClearRg(CurRange);
                       setRg(temprg,aRowRg,row,minfsnip,row,pinfsnip);
                       NewRgImg(temprg);
                       END;

                    END;


               END;{CASE}
            END;
         GetCr(CurRange);

         END;

      Cut:
         BEGIN
         if CUTOK then
            BEGIN

            case ActivePnl of

               cWidePnl,
               cTblPnl:
                    BEGIN
                    If(CRgKind = a1CellRg ) OR (CRgKind = aColHedRg) OR
                      (CRgKind = aRowHedRg) THEN
                      begin
                      {convert to a text selection}
                      getselkind(skind);
                      if skind = a1CellSl then
                         begin
                         DoSelCr(CurRange,Curtimeout,SelectContents);
                         wholeselected := false;
                         end;
                      RelScrap;
                      Clearscrap(status);

                      if CellError then
                         BEGIN
                         {restore error message};
                         Promptstring := ListTitle;
                         shoTitle;
                         CellError := FALSE;
                         END;
                      CutSel(status);
                      if status > feNotUndoable then errselect(scrapcutfld)
                      else if status <> 0 then errselect(status+feerr);
                      end
                    ELSE IF (CRgKind=aRectRg) AND (CurTable = TList) THEN
                       BEGIN
                       endrgborders;

                       RelScrap;
                       Clearscrap(status);

                       setscrap(scList,status);
                       if status <> 0 then
                          begin
                          if status > 0 then
                            begin
                            if status = noroom then alerttype := scrapnoroom else alerttype := scrapopfailed;
                            if cautionalert(lmalerts,alerttype) then ;
                            end;
                          RelScrap;
                          Clearscrap(status);
                          end
                       else
                          begin
                          LLDrawScrap(CRgKind);          {draw scrap picture}
                          ClearRg(CurRange);
                          newrgimg(currange);
                          doselcr(currange,curtimeout,selectcell);
                          end; {copy succeeded, scrap succeeded}
                      end
                    ELSE IF (CRgKind = aWTBoxRg) AND (CurTable = TList) THEN
                       BEGIN
                       temprg.rkind := aRowGrid;
                       getsnipid(rowkind,mmprior,0,curRange.lorow,temprg.lorow);
                       getsnipid(rowkind,mmnext,0,curRange.hirow,temprg.hirow);
                       temprg.locol := minfsnip;
                       temprg.hicol := pinfsnip;
                       endrgborders;

                       RelScrap;
                       Clearscrap(status);

                       setscrap(scList,status);
                       if status <> 0 then
                          begin
                          if status > 0 then
                            begin
                            if status = noroom then alerttype := scrapnoroom else alerttype := scrapopfailed;
                            if cautionalert(lmalerts,alerttype) then ;
                            end;
                          RelScrap;
                          Clearscrap(status);
                          end
                       else
                          begin
                          SwitchTable(TRUE,tabrecord);
                          LLDrawScrap(CRgKind);
                          SwitchTable(FALSE,tabrecord);

                          SaveTable(rowband,colband,atmstate);
                          CutTable;
                          GetSnipId(RowKind,MMFirst,0,Row,Row);
                          RowBand.TMBLoId := Row;
                          LoadTable(rowband,colband,atmstate);
                          TMShoNewTbl;
                          end;

                       {do a getsnipid next from the saved temp range
                        to get bottom extent of the row grid range.
                        This is necessary because we may have logically cut
                        blank row, but it magically getsreconstituted behind
                        our back }

                       getsnipid(rowkind,mmnext,0,temprg.lorow,temprg.hirow);
                       curRange := temprg;
                       doselcr(temprg,curtimeout,selectcell);

                       FixThumb(Folder);
                       END

                    ELSE IF (CRgKind=aRowRg) AND (CurTable = TList) THEN
                       BEGIN
                       temprg.rkind := aRowGrid;
                       getsnipid(rowkind,mmprior,0,curRange.lorow,temprg.lorow);
                       getsnipid(rowkind,mmnext,0,curRange.hirow,temprg.hirow);
                       temprg.locol := minfsnip;
                       temprg.hicol := pinfsnip;
                       endrgborders;
                       RelScrap;
                       Clearscrap(status);

                       setscrap(scList,status);
                       if status = 0 then
                          begin
                          LLDrawScrap(CRgKind);  {draw scrap picture}

                          CutRows(CurRange.LoRow,CurRange.HiRow);

                          {do a getsnipid next from the saved temp range
                           to get bottom extent of the row grid range.
                           This is necessary because we may have logically cut
                           blank row, but it magically getsreconstituted behind
                           our back }

                          getsnipid(rowkind,mmnext,0,temprg.lorow,temprg.hirow);
                          curRange := temprg;
                          doselcr(temprg,curtimeout,selectcell);

                          end
                       else
                          begin
                          if status > 0 then
                            begin
                            if status = noroom then alerttype := scrapnoroom else alerttype := scrapopfailed;
                            if cautionalert(lmalerts,alerttype) then ;
                            end;
                          RelScrap;
                          Clearscrap(status);
                          end;
                       FixThumb(Folder);
                       END

                    ELSE IF (CRgKind=aColRg) AND (CurTable = tColSpecs) THEN
                       BEGIN
                       IF ColumnsCut and NOT (creatingtable or Redefining) then
                          BEGIN
                          MMErrFile(ColinScrap,errfile,status);
                          IF CautionAlert(Errfile,status)THEN ;
                          Goto 100;
                          END
                       ELSE
                          BEGIN
                          {save rowgrid rg to set after cut}
                          temprg.rkind := aColGrid;
                          getsnipid(colkind,mmprior,0,curRange.locol,temprg.locol);
                          getsnipid(colkind,mmnext,0,curRange.hicol,temprg.hicol);
                          temprg.lorow := minfsnip;
                          temprg.hirow := pinfsnip;
                          RelScrap;
                          Clearscrap(status);

                          setscrap(scList,status);
                          if status = 0 then
                            begin
                            LLDrawScrap(CRgKind);

                            CutCols(CurRange.locol,CurRange.hicol);

                            NullSel;
                            NullCR;
                            {set col grid range}
                            curRange := temprg;
                            doselcr(temprg,curtimeout,selectcell);

                            end
                          else
                            begin
                            if status > 0 then
                              begin
                              if status = noroom then alerttype := scrapnoroom
                              else alerttype := scrapopfailed;
                              if cautionalert(lmalerts,alerttype) then ;
                              end;
                            RelScrap;
                            Clearscrap(status);
                            end;
                          FixThumb(Folder);
                          END;
                       END;
                    END;


               END;
            END;

         GetCr(CurRange);

         END;
      Copym:
         BEGIN
         if copyok then
            begin

            case ActivePnl of

            cWidePnl,
            cTblPnl:
                 BEGIN
                 If(CRgKind = a1CellRg ) OR (CRgKind = aColHedRg) OR
                   (CRgKind = aRowHedRg) THEN
                    begin
                   getselkind(skind);
                   if skind = a1CellSl then
                      begin
                      {make it a text selection}
                      DoSelCr(CurRange,Curtimeout,SelectContents);
                      wholeselected := false;
                      end;
                   RelScrap;
                   Clearscrap(status);

                   if CellError then
                      BEGIN
                      {restore error message};
                      CellError := FALSE;
                      Promptstring := ListTitle;
                      shoTitle;
                      END;
                    CopySel(status);
                    if status > feNotUndoable {highest field editor error}
                                   then errselect(scrapcopyfld)
                    else if status <> 0 then errselect(status+feerr);
                    end

                 ELSE IF ((CRgKind = aWTBoxRg) OR (CRgKind = aColRg) OR (CRgKind = aRowRg)
                       OR (CRgKind = aRectRg)) AND (CurTable = TList) THEN
                    BEGIN
                    if CRgKind = aWTBoxRg then NullCR else endrgborders;
                    RelScrap;
                    Clearscrap(status);

                    setscrap(scList,status);
                    if status <> 0 then
                      begin
                      if status > 0 then
                        begin
                        if status = noroom then alerttype := scrapnoroom else alerttype := scrapopfailed;
                        if cautionalert(lmalerts,alerttype) then ;
                        end;
                      RelScrap;
                      Clearscrap(status);
                      end
                    else
                       begin
                       if (CRgKind = aWTBoxRg) or (CRgKind = aColRg) then
                         begin
                         SwitchTable(TRUE,tabrecord);
                         LLDrawScrap(CRgKind);
                         SwitchTable(FALSE,tabrecord);
                         tmshonewtbl;
                         end
                       else
                         begin
                         LLDrawScrap(CRgKind);
                         newrgimg(currange);
                         end;
                       doselcr(CurRange,curtimeout,selectcell);
                       end; {copy succeeded, scrap succeeded}

                    if (CRgKind = aWTBoxRg) or (CRgKind = aColRg) then FixThumb(Folder);
                    END;
                end;  {case}
               END;
            end;
         GetCr(CurRange);
         END;

      PasteM:
         BEGIN
         if pasteok then
            begin
            case ActivePnl of

               cWidePnl,
               cTblPnl:
                    BEGIN

                    if ((CRgKind = aRectRg) or (CRgKind = aColRg)
                       or (CRgKind = aRowRg) or (CRgKind = aRowgrid)
                       or (CRgKind = a1CellRg)
                       or (CRgKind = aWTBoxRg))
                       and (curTable = TList) then
                      begin

                      IgnoreEdChkErrs := FALSE;
                      IgnoreRowFull := FALSE;
                      mmscraprg := currange;
{                     FECheck := FALSE;}

                      {check the scrap type; if it has FE data and a1cellrg, let FE do paste}
                      lookatscrap(sstate,status);
                      if status <> 0 then goto 11
                      else
                        begin
                        if sstate = scfield then
                          begin
                          if CRgKind = a1cellrg then goto 20
                          else begin
                               FeTerminate;
{                              FECheck := TRUE;}
                               end;
                          end;
                        end;
{13:}
                      {create a universal text object}
                      HZPtr := pointer(ord(SnipZone));
                      readutext := TReadUnivText.CREATE(NIL,HZPtr,NIL,512,[UTparagraphs]);
                      if readutext = NIL then
                        begin
                        if mmtrap1 then writeln('==> no universal text');
(*                      if CRgKind = a1cellrg then goto 20;

                        {see if FE has some to generate}
                        if NOT FECheck then
                          begin
                          lookatscrap(sstate,status);
                          if status = 0 then
                            if sstate = scfield then
                              begin
                              FeTerminate;
                              FECheck := TRUE;
                              goto 13;
                              end;
                          end; *)
                        goto 11;
                        end;
                      utextrestart := FALSE;

                      sstat := 0;
                      selrg := currange;
                      InitPasteRgs(sstat);      {will call cachemgr(TRUE) if necessary}
                      if sstat <> 0 then
                        begin
                        if mmtrap1 then writeln(em,'; initpastergs sstat : ',sstat);
                        goto 10;
                        end;

                      {compare scrap range with selection range}
                      RgCompare(sstat,ucols,utextdup);
                      if sstat <> 0 then
                        begin
                        if mmtrap1 then writeln(em,'; RgCompare NOMATCH');
                        if CautionAlert(lmalerts,RgNoMatch) then ;
                        goto 10;
                        end;

                      if selrg.rkind = arowgrid then goto 12;

                      {paste text into snips in the cache}
                      PasteCache(sstat,UCols,utextdup);
                      if sstat <> 0 then
                        begin
                        status := 0;
                        goto 10;
                        end;

                      {paste text records in the rest of file}
                      sstat := 0;
                      PasteFile(sstat,UCols,utextdup);
                      case sstat of
                        0: begin
                           end;
                        1,3,4,5:            {done / lmfetch, getsnipblock, setuprec err}
                           begin
                           if mmtrap1 then writeln(em,'; PasteFile status : ',sstat);
                           status := 0;
                           goto 10;
                           end;
                        2: begin
                           {paste text records in the rest of file}
                           sstat := 0;
                           if NOT utextrestart then             {if started duping rows in pastefile}
12:                          PasteNew(sstat,ucols,utextdup);    { don't continue to do rowdup by    }
                           {alerts taken care of}               { adding new rows                   }
                           end;
                        end;  {case}

10:                     nullcr;
                        mmscraprg.rkind := acolrg;    {kludge to always rebuild table}
                        SwitchTable(FALSE,tabrecord);
                        TMShoNewTbl;
                        FixThumb(folder);

                        readutext.FREE;
11:
                      end

                      ELSE IF (CRgKind = a1CellRg ) OR (CRgKind = aColHedRg) OR
                              (CRgKind = aRowHedRg) THEN
20:                   begin
                      getselkind(skind);
                      if skind = a1CellSl then
                         begin
                         {coerce to text selection}
                         DoSelCr(CurRange,Curtimeout,SelectContents);
                         wholeselected := false;
                         end;

                      if CellError then
                         BEGIN
                         {restore error message};
                         CellError := FALSE;
                         Promptstring := ListTitle;
                         shoTitle;
                         END;
                      if CRgKind = a1CellRg then
                         begin
                         unboldflds(status);
                         {always paste unbolded text}
                         if mmtrap1 then if status<> 0 then writeln('unboldflds status',
                           status:4);
                         end;
                      PasteSel(false,maxDbRecSize,status);
                      redrawsel(true);
                      if status <> 0 then
                         begin
                         if mmtrap1 then writeln('pastesel status ',status);
                         errselect(status+feerr);
                         end;
                      end

                    ELSE IF (CRgKind = aColGrid) THEN
                       BEGIN
                       IF (ColumnsCut) and (curtable = tColSpecs) then
                          BEGIN
                          col := CurRange.locol;
                          NullCr;
                          ClearScrap(status);
                          If (CurRange.locol = minfSnip) or
                             (CurRange.locol = pinfsnip)  then PasteCols(nullSnip)
                          ELSE PasteCols(col);
                          FixThumb(Folder);
                          END
                       ELSE
                          BEGIN
                          MMErrFile(NoColPaste,errfile,status);
                          IF CautionAlert(Errfile,status)THEN ;
                          GoTo 100;
                          END;
                       END;
                    END;


               END;
            ENd;

         GetCr(CurRange);
         END;
      RstOrig:
         BEGIN
         if RestoreOK then
            begin
            case ActivePnl of

               cWidePnl,
               cTblPnl:
                    BEGIN
                    If(CRgKind = a1CellRg ) OR (CRgKind = aColHedRg) OR
                      (CRgKind = aRowHedRg) THEN
                      begin
                      getselkind(skind);
                      if skind = a1CellSl then
                         begin
                         {coerce to a text selection}
                         DoSelCr(CurRange,Curtimeout,SelectContents);
                         wholeselected := false;
                         end;

                      if CellError then
                         BEGIN
                         {restore error message};
                         Promptstring := ListTitle;
                         shoTitle;
                         CellError := FALSE;
                         END;
                      restoreflds(curtimeout);
                      GetCr(CurRange);
                      end;
                    END;


               END;{case}
            end;
         END;
      Seltbl:
         BEGIN
         EnterStuff(Status);
         IF Status <> 0 THEN
            BEGIN
            ErrSelect(Status);
            GOTO 100;
            END;

         IF CurTable = TList THEN
            BEGIN
            UpdateRow;
            IF curRgList then RelcRgList;
            FixThumb(folder);
            END;
         NullCR;
         SetRg(CurRange,aWTBoxRg,minfsnip,minfsnip,pinfsnip,pinfsnip);
         WhTblSel(CurRange,CurNbrhood,CurTimeout);



         END;
      Undo:
         BEGIN
          if undook then
            BEGIN
            makergVisible(CurRange,CurRange);
            If(CRgKind = a1CellRg )  OR (CRgKind = aColHedRg) OR
              (CRgKind = aRowHedRg) THEN
              begin
              getselkind(skind);
              if skind = a1CellSl then
                 begin
                 {coerce to a text selection}
                 DoSelCr(CurRange,Curtimeout,SelectContents);
                 wholeselected := false;
                 end;

              if CellError then
                 BEGIN
                 {restore error message};
                 Promptstring := ListTitle;
                 shoTitle;
                 CellError := FALSE;
                 END;
              saveop := uinfo.lastop;
              UndoSel(status);
              if status <> 0 then
                 begin
                 errselect(status+feerr);
                 end
              else
                 begin
                 if (saveop = cutop) or (saveop = copyop) then
                   UndoInheritScrap(status);
                 if mmtrap1 then if status <> 0 then
                   writeln('undoinherit status',status);
                 end;

              GetCr(CurRange);
              end;
            END
         else
            BEGIN
            {undo not ok, put up alert}
            if cautionalert(lmalerts,undoNotOk) then ;
            END;
         END;

      END;

100:
   END;



{$S lmfilemenu}
PROCEDURE FileMenu(item:integer);
   Label 100;
   VAR
       status: integer;
       startRg: Range;                     {Initial range for building the table}
       Row,Col: Idtype;

       curtblfont : tlfntid;

       oldstyleitem:integer;
       oldfontitem:integer;
       finfo:fontinfo;

       newstyle : boolean;
       PrintPreference: TPrRec;
       lasttable : tabletype;
       sstate : scstate;

       dtarray : datearray;
       timestamp:longint;
       whenstring:TParamalert;
       r:rect;
       oldfont,
       newfont : tlfntid;
       updatergn:RgnHandle;
       fdialog: boolean;
       DlgType : PrMenuSuppress;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('FileMenu');
   CASE item OF { Folder(desktop) Menu }


      fmcloseall:
         BEGIN
         DoFilingCmd(cmdClosAll);
         END;

      fmclose:
         BEGIN
         DoFilingCmd(cmdClose);
         END;

      fmPutBack:
         BEGIN

         if not fileclosed then
            begin

            {this stuff came from deactivate}
            refuseDeactivate := FALSE;

            {clean up scrap}

            if (scrapProcess = My_Id) then
               begin
               lookatscrap(sstate,status);
               if status = 0 then
               case sstate of

                  scfield:
                      BEGIN
                      {scrap already ok}
                      FeTerminate;
                      END;
                  scempty:
                      BEGIN
                      {scrap already ok}
                      END;
                  sclist:
                      BEGIN
                      if columnscut then
                        begin
                        {paste the cols back}
                        unpastecols;
                        clearscrap(status);
                        end;
                      END;
                  scnotmine: {if it ain't mine don't touch it};

                  end;
               if (sstate <> scnotmine)  then
                  begin
                  {draw picture  }
                  updatergn := newrgn;
                  setport(scrapfolder);
                  setorigin(0,0);
                  rectrgn(updatergn,scrapfolder^.portrect);
                  WMOpenPicture(scrapfolder);
                  redrawscrap(updatergn,false);
                  WMClosePicture;
                  disposergn(updatergn);
                  end;
               end;

            if not (CreatingTable  or Redefining) then              {#178}
               begin
               FlushUpdates(status);
               if status <> 0 then goto 100;
               end
            else
               begin
               EnterStuff(Status);
               IF Status <> 0 THEN
                  BEGIN
                  ErrSelect(Status);
                  GOTO 100;
                  END;

               NullCR;
               GetCr(CurRange);
               end;

            {this stuff just came from fcclose }
            waitalert(lmalerts,waitsave);
            curtblfont := mmfontinfo.DMPfont;
            CloseDocument;
            fileclosed := true;
            fldrUpdateOK := false;
            EndWaitAlert;

            if  fmfontmetrics(curtblfont,finfo,status) then ;
            if mmtrap1 then if status <> 0 then
                  writeln('bad call to fmfontmetrics status',status);

            FntIDToItem(curtblfont,oldstyleitem,oldfontitem);
            checkitem(mymenus[menufont],menustyle,false);
            checkitem(mymenus[menufont],oldfontitem,false);
            checkitem(mymenus[menushow],lastshowitem,false);
            docsOpen := docsOpen - 1;   { can now accept another document }
            susdoccalled := false;

            {release scrap if it has  rows}

            end;

         TellFiler(status,docClosd,docPutBack,folder);
         END;

      mpformatfor:
         BEGIN

         PrintPreference := mmPrintPreference;

         PrPrfDlg(PrintPreference,newstyle,TRUE);       {PgSzSuppress flag TRUE}

         PutPrintPref(PrintPreference);
         CheckPrintPref(PrintPreference,oldfont,newfont,status);

         FontChange(oldfont,newfont);

         END;

  mpprintasis,
      mpprint:
         BEGIN
         EnterStuff(Status);
         IF Status <> 0 THEN
            BEGIN
            ErrSelect(Status);
            GOTO 100;
            END;

         IF CurTable = TList THEN
            BEGIN
            UpdateRow;
            IF curRgList then RelcRgList;
            FixThumb(folder);
            END;
         NullCR;
         GetCr(CurRange);

         PrintPreference := mmPrintPreference;
         if item = mpPrintAsIs then DlgType := ePrDialogSuppress else DlgType := ePrNormal;
         fdialog := FPrInsDlg(PrintPreference,newstyle,DlgType);

         if fdialog then
            BEGIN
            PutPrintPref(PrintPreference);
            CheckPrintPref(PrintPreference,oldfont,newfont,status);

            FontChange(oldfont,newfont);
            mmprint;

            END;

         IF CurTable = TList THEN
            BEGIN
            GetCurPosSnip(Row,Col);
            SetRg(StartRg,A1CellRg,Row,Col,Row,Col);
            ReBldTbl(StartRg);
            TMShoNewTbl;
            {since we just drew the table, validate that part of the table}
            getpnlrect(tblpnl,r);
            adjrect(tblpnl,r);
            setport(folder);
            setorigin(0,0);
            validrect(r);

            Nullsel;
            Nullcr;
            curtimeout := dflttimeout;

            END
         ELSE
            NULLCR;

         GetCr(CurRange);

         FixThumb(Folder);
         DoUpdate(folder,true);
         END;


      mpPrInProg:
         BEGIN
         PrBgdDlg;
         END;

      AcceptAll:
         BEGIN
         LastTable := CurTable;
         {this creating or redefining is never executed since item is disabled}
         if creatingtable or redefining then                          {#178}
            begin
            EnterStuff(Status);
            IF Status <> 0 THEN
               BEGIN
               ErrSelect(Status);
               GOTO 100;
               END;

            NullCR;
            GetCr(CurRange);
            end
         else
            begin
            waitalert(lmalerts,waitsave);
            Flushupdates(status);
            EndWaitAlert;
            if status <> 0 then goto 100;
            FillTable(LastTable,true,false,false);
            end;
         END;


      UndoAll:
         BEGIN
         if undoallok then
            begin
            With GMTPostTime do
               begin
               dtarray.year := year;
               dtarray.day := day;
               dtarray.hour := hour;
               dtarray.minute := minute;
               dtarray.second := second;
               end;
            DateToTime(dtarray,timestamp);
            DTalert(lmalerts,timestamp,whenstring);
            ParamAlert(whenstring,lfname,'');
            if cautionAlert(lmalerts,confundo) then
               begin
               doUpdate(folder,true);
               NullCR;
               if CellError then
                  BEGIN
                  {restore error message};
                  Promptstring := ListTitle;
                  {      Shotitle comes later   }
                  CellError := FALSE;
                  END;
               UndoTableEdits(Status);
               {no meaningful status returned from undo table edits}

               GetCurPosSnip(Row,Col);
               SetRg(startRg,a1CellRg,Row,Col,Row,Col);
               {$IFC tedebug}
               IF tracing then prntrg('startrg',startrg);
               {$ENDC}
               ReBldTbl(startRg);
               tmShoNewTbl;
               ClearScrap(status);
               Nullsel;
               Nullcr;
               curtimeout := dflttimeout;
               promptstring := ListTitle;
               shotitle;
               FixThumb(folder);
               GetCr(CurRange);
               FixMenus;
               END
            ELSE
               BEGIN
               doUpdate(folder,true);
               GetCr(CurRange);
               END;
            end;


         END;




      Recover:
         BEGIN
         IF MMTRAP1 then if CreatingTable or Redefining THEN
            BEGIN
            {This case shouldn't happen - menu should be disabled.}
            writeln('recover when creating table');
            GOTO 100;
            END;

         lasttable := curTable;
         {Post any changes}
         FlushUpdates(Status);
         IF Status <> 0 THEN GOTO 100;

         {Put up the alert to ask if user has backed up file.
         If not, don't do the recovery.}
         if (AskAlert(LMAlerts,RecBackup) = 2 ) then
            BEGIN

            checkitem(mymenus[menushow],lastshowitem,false);
            {Close the file}
            CloseDocument;
            docsopen := docsopen - 1;


            docsopen := docsopen + 1;
            OpentheList(MMRecover,Status);
            IF status <> 0 then goto 100;


            {take down hourglass};
            FixThumb(folder);


            END
         ELSE
            BEGIN   {user doesn't want to recover}
            {Load up the list}
            filltable(lasttable,true,false,false);
            END;
         END;{recover}

      END;
100:
   END;


{$S lmfontmenu}
PROCEDURE FontMenu(item:integer);
   VAR
      newDspfntid:Tlfntid;
      oldDspfntid : tlfntid;

      newDMPfntid,
      oldDMPFntid,
      mappedfont: tlfntid;

      oldstyleitem, oldfontitem : integer;
      newstyleitem, newfontitem: integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('FontMenu');

   {uncheck old. first get fontid then figure out which item then uncheck}
   oldDspfntid := mmfontinfo.font;
   oldDMPfntid := mmfontinfo.DMPFont;

   {now setup new font}
   with newDspfntid do
      BEGIN
      seteface := [];
      dev := devscreen;
      END;

   with newDMPfntid do
      BEGIN
      seteface := [];
      dev := devscreen;
      END;

   {find out what is currently checked on menu (DMP font)}
   fntidtoitem(olddmpfntid,oldstyleitem,oldfontitem);
   oldstyleitem := menustyle;
   newdmpfntid := olddmpfntid;

   CASE item of

   mmodern,
   mclassic,
   m08x20,
   m08x15,
   m10x12,
   m12x10:
     begin
     case item of

     mmodern:
       begin
       case oldfontitem of

         m08x20 : newDMPfntid.fam := p20tile;
         m08x15 : newDMPfntid.fam := p15tile;
         m10x12 : newDMPfntid.fam := p12tile;
         m12x10 : newDMPfntid.fam := p10tile;

       end;  {case oldfontitem}
       menustyle := mmodern;
       end;

     mclassic:
       begin
       case oldfontitem of

         m08x20 : newDMPfntid.fam := p20tile;   {no classic for these two}
         m08x15 : newDMPfntid.fam := p15tile;
         m10x12 : newDMPfntid.fam := p12cent;
         m12x10 : newDMPfntid.fam := p10cent;

       end;  {case oldfontitem}
       menustyle := mclassic;
       end;

     m08x20:
       begin
       newDMPfntid.fam := p20tile;
       end;

     m08x15:
       begin
       newDMPfntid.fam := p15tile;
       end;

     m10x12:
       begin
       if oldstyleitem = mmodern then newDMPfntid.fam := p12tile
       else {mclassic} newDMPfntid.fam := p12cent;
       end;

     m12x10:
       begin
       if oldstyleitem = mmodern then newDMPfntid.fam := p10tile
       else {mclassic} newDMPfntid.fam := p10cent;
       end;

     end;

     if printfont in mmfontinfo.fontoptions then
        BEGIN
        {show as printer would print, so change display font to
        either DMPfont or coerced typewriter font}
        {clear small med large}
        checkitem(mymenus[menufont],msmall,false);
        checkitem(mymenus[menufont],mmedium,false);
        checkitem(mymenus[menufont],mlarge,false);
        setfontoptions([printfont]);

        newDspFntid := newDMPfntid;
        if tracing then
          writeln('old fam, new fam',olddspfntid.fam,newdspfntid.fam);
        FontChange(oldDspfntid,newDspFntid);

        END
     else
        BEGIN {small med large in effect}

        case newdmpfntid.fam of
           p20tile,
           p15tile,
           p12tile,
           p10tile,
           p12cent,
           p10cent:
              BEGIN
              if smallfont in mmfontinfo.fontoptions then
                 newdspfntid.fam := p20tile
              else if mediumfont in mmfontinfo.fontoptions then
                begin
                if menustyle = mclassic then newdspfntid.fam := p12cent
                else newdspfntid.fam := p12tile;
                end
              else if largefont in mmfontinfo.fontoptions then
                begin
                if menustyle = mclassic then newdspfntid.fam := p10cent
                else newdspfntid.fam := p10tile;
                end;
              END;

        END; {case}
        FontChange(oldDspFntid,newDspfntid);

        END;

     {if face change then change face, if width change and sml then
      do nothing, if width change and sap then dmpfont = screen font;}

     {uncheck old ones, check new ones}
     checkitem(mymenus[menufont],oldstyleitem,false);
     checkitem(mymenus[menufont],oldfontitem,false);
     fntidtoitem(newdmpfntid,newstyleitem,newfontitem);

     checkitem(mymenus[menufont],menustyle,true);
     checkitem(mymenus[menufont],newfontitem,true);

     SetUserFont(newDMPfntid);

  END;

   mactual:
      BEGIN

      checkitem(mymenus[menufont],msmall,false);
      checkitem(mymenus[menufont],mmedium,false);
      checkitem(mymenus[menufont],mlarge,false);
      checkitem(mymenus[menufont],mactual,true);
      setfontoptions([printfont]);

      newDspFntid := oldDMPfntid;
      FontChange(oldDspfntid,newDspFntid);

      END;

   msmall,
   mmedium,
   mlarge:
      BEGIN
      checkitem(mymenus[menufont],mactual,false);
      checkitem(mymenus[menufont],msmall,false);
      checkitem(mymenus[menufont],mmedium,false);
      checkitem(mymenus[menufont],mlarge,false);
      enableitem(mymenus[menufont],mactual);

      case item of
         msmall:
            BEGIN
            newDspFntid.fam := p20tile;
            checkitem(mymenus[menufont],msmall,true);
            setfontoptions([smallfont]);
            END;

         mmedium:
            BEGIN

            if menustyle = mmodern then newDspFntid.fam := p12tile
            else newDspFntid.fam := p12cent;

            checkitem(mymenus[menufont],mmedium,true);
            setfontoptions([mediumfont]);
            END;

         mlarge:
            BEGIN
            if menustyle = mmodern then newDspFntid.fam := p10tile
            else newDspFntid.fam := p10cent;

            checkitem(mymenus[menufont],mlarge,true);
            setfontoptions([largefont]);
            END;

         END;
         FontChange(oldDspFntid,NewDspFntid);
      END;
   END;{case}

   END;


{$S lmopmenu}
PROCEDURE OpMenu(item:integer);
   VAR str : str40;
       len : integer;
       i : integer;
       ch : char;
       status : integer;
       skind : selkind;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('OpMenu');
   IF (CurTable = tsearch) and (CurRange.Rkind = a1CellRg) then
   CASE item of
      moeq:
         BEGIN
         str := '=';
         len := 1;
         END;
      molt:
         BEGIN
         str := '<';
         len := 1;
         END;
      mogt:
         BEGIN
         str := '>';
         len := 1;
         END;
      mole:
         BEGIN
         str := '<=';
         len := 2;
         END;
      moge:
         BEGIN
         str := '>=';
         len := 2;
         END;
      mone:
         BEGIN
         str := '<>';
         len := 2;
         END;
      mothru:
         BEGIN
         str := copy(ThruString,2,ThruLength-2);
         len := ThruLength-2;
         END;
      END;

   getselkind(skind);
   if skind = a1CellSl then
      begin

      {coerce to a cell text selection}
      selalltxt(Curtimeout);
      end;
   if item = mothru then
      begin
      {put in a blank}
      ch := ' ';
      inkey(ch,true,false,true,curtimeout,status);
      if mmtrap1 then if status <> 0 then writeln('inkey status ',status:4);
      end;
   boldflds(status);
   if mmtrap1 then if status <> 0 then writeln('boldflds status ',status:4);
   For i := 1 to len do
      begin
      ch := str[i];
      inkey(ch,true,false,false,curtimeout,status);
      if mmtrap1 then if status <> 0 then writeln('inkey    status ',status:4);
      end;
   unboldflds(status);
   if mmtrap1 then if status <> 0 then writeln('unboldflds status ',status:4);

   if item = mothru then
      begin
      {put in a blank}
      ch := ' ';
      inkey(ch,true,false,false,curtimeout,status);
      if mmtrap1 then if status <> 0 then writeln('inkey status ',status:4);
      end;

   if CellError then
      BEGIN
      {restore error message};
      Promptstring := ListTitle;
      shoTitle;
      CellError := FALSE;
      END;


   END;

{$S lmscrapmenu}
PROCEDURE ScrapMenu(item:integer);
   VAR status:integer;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('ScrapMenu');
   CASE item of
      scrapclall:
         BEGIN
         DoFilingCmd(cmdClosAll);
         END;

      scrapclose:
         BEGIN
         DoFilingCmd(cmdClose);
         END;

      scrapmonptr:
         BEGIN
         PrBgdDlg;
         END;

      END;
   END;

{$S lmshowmenu}
PROCEDURE ShowMenu(item:integer);
   LABEL 100;
   VAR
       status : integer;
       srchlist : boolean;
       sortit : boolean;
       itemstring : str255;
       lastrg : range;
       lasttable:tabletype;




   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('ShowMenu');
   lastrg := curRange;
   lasttable := curtable;
   {enter any value being edited, then update the row.}
   FlushUpdates(status);

   IF Status <> 0 THEN
      Begin
      if status = mustpastecol then
         begin
         if lastrg.rkind = acolgrid then
            begin
            doselcr(lastrg,curtimeout,selectcell);
            getCr(CurRange);
            end;
         end;
      GOTO 100;
      end;


   if redefining then
      Begin
      {user modified the table to have more or less cols, file is closed so open
       it up}
      docsopen := docsopen - 1;
      checkitem(mymenus[menushow],lastshowitem,false);
      {openthelist checks the items}
      docsopen := docsopen + 1;
      OpentheList(MMResume,Status);
      IF status <> 0 then
         begin
         goto 100;
         end;
      GetItem(mymenus[menusubst],msentire,@itemstring);
      SetItem(mymenus[menushow],mslist,@itemstring);
      FixThumb(folder);
      goto 100;
      END;

   CASE item of

      msselrows,
      mslist,
      msorder,
      mssrchord:
         begin
         IF (Item = msselrows) or (item = mssrchord) THEN SrchList := TRUE
         ELSE SrchList := FALSE;
         If (item = msorder) or (item = mssrchord) then Sortit := TRUE
         ELSE Sortit := FALSE;
         FillTable(tlist,false,Srchlist,Sortit);
         GetItem(mymenus[menusubst],msentire,@itemstring);
         SetItem(mymenus[menushow],mslist,@itemstring);
         checkitem(mymenus[menushow],lastshowitem,false);
         lastshowitem := item;
         checkitem(mymenus[menushow],lastshowitem,true);
         end;

      msSearch:
         BEGIN
         FillTable(tsearch,false,false,false);
         GetItem(mymenus[menusubst],msentire,@itemstring);
         SetItem(mymenus[menushow],mslist,@itemstring);
         checkitem(mymenus[menushow],lastshowitem,false);
         lastshowitem := item;
         checkitem(mymenus[menushow],lastshowitem,true);
         END;

      msColSpecs:
         BEGIN
         FillTable(tcolspecs,false,false,false);
         GetItem(mymenus[menusubst],msentire,@itemstring);
         SetItem(mymenus[menushow],mslist,@itemstring);
         checkitem(mymenus[menushow],lastshowitem,false);
         lastshowitem := item;
         checkitem(mymenus[menushow],lastshowitem,true);
         END;

      ChangeFile:
         BEGIN
         {see if a backup has been made}

         if  (askalert(lmalerts,restbackup) = 2) then
            begin

            ReDefining := TRUE;
            FillTable(tcolspecs,false,false,false);
            GetItem(mymenus[menusubst],msmodified,@itemstring);
            SetItem(mymenus[menushow],mslist,@itemstring);
            checkitem(mymenus[menushow],lastshowitem,false);
            lastshowitem := item;
            checkitem(mymenus[menushow],lastshowitem,true);
            end
         else
            begin
            filltable(lasttable,true,false,false);
            {same menus}
            end;
         END;

      END;
100:
   END;

{$s lmsortmenu}
PROCEDURE SortMenu(item:integer);

   VAR SortString: STRING[20];
       SortPtr: PtrData;
       Order: INTEGER;
       Direction: INTEGER;
       Len: INTEGER;
       STatus : integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('SortMenu');
   SortPtr := @SortString;
   Order := -1; {Signifies order should be filled in.}
   CASE item of
      msAscend: Direction := 0;
      msDescend: Direction := 1;
      END;

   GenSort(Order,Direction,CurRange.locol,@SortPtr^[1],Len);
   SortPtr^[0] := Len;
   SetCellStr(SortString);
   if CellError then
      BEGIN
      {restore error message};
      Promptstring := ListTitle;
      shoTitle;
      CellError := FALSE;
      END;

   EnterStuff(Status);
   IF Status <> 0 THEN
      BEGIN
      ErrSelect(Status);
      END;

   DoSelCr(CurRange,curTimeout,selectCell);

   END;


{$IFC fexecdebug}
{$S lminit}
PROCEDURE TraceMenu(item:integer);

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('TraceMenu');
   CASE item of  { Trace menu }
      TMmgr:
         BEGIN
         {$IFC MMDEBUG }
         TraceMmgr := NOT TraceMmgr;
         ClrMrkItem (MenuTrace,item,traceMMgr);
         {$ENDC }
         END;
      TMmgr2:
         BEGIN
         {$IFC MMDEBUG }
         Trace2Mmgr := NOT Trace2Mmgr;
         ClrMrkItem (MenuTrace,item,trace2MMgr);
         {$ENDC }
         END;
      Tlmprint:
         BEGIN
         {$IFC MMDEBUG }
         Tracelmprint := NOT Tracelmprint;
         ClrMrkItem (MenuTrace,item,tracelmprint);
         {$ENDC }
         END;
      Tdbconvert:
         BEGIN
         {$IFC MMDEBUG }
         setdbctest( NOT dbctest );
         ClrMrkItem (MenuTrace,item,dbctest);
         {$ENDC }
         END;
      TSmgr:
         BEGIN
         {$IFC tmdebug }
         TraceSmgr := NOT TraceSmgr;
         ClrMrkItem (MenuTrace,item,tracesmgr);
         {$ENDC }
         END;
      TTmgr:
         BEGIN
         {$IFC tmdebug }
         TraceTmgr := NOT TraceTmgr;
         ClrMrkItem (MenuTrace,item,tracetmgr);
         {$ENDC }
         END;
      TXTmgr:
         BEGIN
         {$IFC tmdebug }
         TraceXTmgr := NOT TraceXTMgr;
         ClrMrkItem (MenuTrace,item,tracextmgr);
         {$ENDC }
         END;
      TFmgr:
         BEGIN
         {$IFC teDEBUG }
         TraceFmgr := NOT TraceFmgr;
         ClrMrkItem (MenuTrace,item,traceFmgr);

         {$ENDC }
         END;
      TFedits:
         BEGIN
         {$IFC flddebug }
         setfldtest (NOT fldTest);
         ClrMrkItem (MenuTrace,item,fldtest);
         {$ENDC }
         END;
      TFexec:
         BEGIN
         {$IFC fexecdebug }
         tracing := NOT tracing;
         ClrMrkItem (MenuTrace,item,tracing);
         {$ENDC }
         END;
      Tlmdebug:
         BEGIN
         {$IFC prerelease}
         lmdebug := Not lmdebug;
         ClrMrkItem (MenuTrace,item,lmdebug);
         {$ENDC}
         END;
      Tmmtrap1:
         BEGIN
         {$IFC MMDEBUG }
         mmtrap1 := NOT mmtrap1;
         ClrMrkItem (MenuTrace,item,mmtrap1);
         {$ENDC }
         END;
      TMmtrap2:
         BEGIN
         {$IFC MMDEBUG }
         mmtrap2 := NOT mmtrap2;
         {$IFC prerelease}
         PDebug := TRUE;
         {$ENDC }
         ClrMrkItem (MenuTrace,item,mmtrap2);
         {$ENDC }
         END;
      TPrintPRocs:
         BEGIN
         {$IFC fexecdebug }
         PrintProcs := NOT PrintPRocs;
         ClrMrkItem (MenuTrace,item,PrintProcs);
         {$ENDC }
         END;
      TStorage:
         BEGIN
         {$IFC fexecdebug }
         {$ENDC }
         END;
      END;
   END;
{$ENDC }

