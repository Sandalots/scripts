{$S lmres2 }
PROCEDURE MakeColSpecSnips;

   {This procedure creates the spec table column snips. For each column in
   the list, a corresponding spec table column snip is created. Each field
   is type variable length character.}

   CONST MCSS = ' MakeColSpecSnips';

   VAR Column: IdType;
       ColId: IdType;
       NextColumn: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,MCSS);

   {Initialize column pointers and counts, just to make sure}
   WITH TableData DO
      BEGIN
      FirstCol := NullSnip;
      LastCol := NullSnip;
      ColCount := 0;
      END;

   {Loop through every column in the list, but ignore the ticket field}
   Column := ListTable.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      {Get the next column in the list for the next loop}
      SetSnipPtr(ColKind,Column);
      NextColumn := ColSnip^.NextSnip;

      {Do not create a colspec snip for the ticket field}
      WITH ColSnip^ DO IF NOT((FieldInfo.FldType = Tick) AND (FieldNum = 1)) THEN
         BEGIN {Not the ticket field}
         {Create the colspec column}
         NewCSCol(Column,ColId);

         {Link this snip into the end of the list of column snips}
         WITH TableData DO
            BEGIN
            InsertColSnips(FirstCol,LastCol,LastCol,ColId,ColId);
            ColCount := ColCount + 1;
            END;
         END; {Not ticket}

      Column := NextColumn;
      END; {WHILE  Loop}
   END;





{$S lmopendoc }
PROCEDURE MakeListFormChanges{FormId: IdType};

   {MakeListFormChanges examines a list form and changes various list
   specific parameters, such as the column width, visibility, and ordering.
   It is designed to work on damaged forms. This is part of the recovery
   strategy. Do not make modifications to this code unless you understand
   the recovery strategy and all procedures which are involved.}

   LABEL 200,300,400,500;

   CONST MLFC = ' MakeListFormChanges';

   TYPE IArray = ARRAY[0..1] OF INTEGER;

   VAR FormArray: ^IArray;
       FormSize: INTEGER;
       NextLoc: INTEGER;
       Len: INTEGER;
       Code: INTEGER;
       IntArray: ^IArray;
       Column: IdType;
       LastCol: IdType;
       TripSize: INTEGER;
       I: INTEGER;
       J: INTEGER;
       Width: INTEGER;
       FieldCount: INTEGER;
       Status: INTEGER;
       Status2: BOOLEAN;
       FInfo: fontinfo;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,MLFC);

   InitSnipPtr(ColKind,FormId);
   FieldCount := TableData.ColCount;
   FormArray := @ColSnip^;
   FormSize := FormArray^[0] DIV 2; {Convert to words}
   NextLoc := 1;

   WHILE NextLoc < FormSize DO
      BEGIN
      Len := FormArray^[NextLoc];
      IF Trace2MMgr THEN WriteLn('Process next block of len: ',len);

      {Check length for too small value}
      IF Len < 2 THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***Bad block length: ',len);
         GOTO 500;
         END;

      {Make sure form contains entire block - it may be truncated,
      or length may be a large positive value}
      IF (NextLoc + Len - 1) > FormSize THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***Truncated block');
         GOTO 500;
         END;

      {Look at the code and do the right thing}
      Code := FormArray^[NextLoc + 1];
      IF Trace2MMgr THEN WriteLn('Next block code is: ',code);

      CASE Code OF

 OrderCode: BEGIN
            IF Trace2MMgr then WriteLn(MxMgr,MLFC,'Order block found');
            {Make sure block length corresponds to field count}
            IF Len <> (FieldCount + 2) THEN
               BEGIN
               IF MMTrap1 THEN WriteLn(Bell,'***Bad length in order block: ',Len);
               GOTO 500;
               END;

            {Verify field numbers are unique and less than fieldcount}
            IntArray := @FormArray^[NextLoc + 2];
            FOR I := 0 TO (FieldCount - 1) DO
               BEGIN
               {Make sure order is in range}
               IF (IntArray^[I] > FieldCount) OR (IntArray^[I] < 1) THEN
                  BEGIN
                  IF MMTrap1 THEN WriteLn(Bell,'***Bad order: ',IntArray^[I]);
                  GOTO 400;
                  END;
               {Make sure there are no duplicates}
               FOR J := 0 TO (FieldCount - 1) DO
               IF (J <> I) AND (IntArray^[J] = IntArray^[I]) THEN
                   BEGIN
                   IF MMTrap1 THEN WriteLn(Bell,'***Duplicate order: ',IntArray^[I]);
                   GOTO 400;
                   END;
                END;

            {Loop through the column snips and insert their proper order}
            Column := TableData.FirstCol;
            While Column <> NullSnip DO
               BEGIN
               SetSnipPtr(ColKind,Column);
               ColSnip^.Order := IntArray^[ColSnip^.FieldNum];
               Column := ColSnip^.NextSnip;
               END;

            {Now replace the contents of the array with the ids in proper sequence.}
            Column := TableData.FirstCol;
            While Column <> NullSnip DO
               BEGIN
               SetSnipPtr(ColKind,Column);
               IntArray^[ColSnip^.Order-1] := ColSnip^.SnipId;
               Column := ColSnip^.NextSnip;
               END;

            {Now loop through the array and relink the list in the proper order.
            The array was changed in the last step. Before, it contained the
            order numbers of fields, and was indexed by field number. Now it
            contains the snipids of the column snips, and is indexed by order.
            This means that the first entry in the array contains the snipid of
            the column which should be first, etc.}
            I := 0;
            LastCol := NullSnip;
            WHILE I < FieldCount DO
               BEGIN
               Column := IntArray^[I];
               SetSnipPtr(ColKind,Column);

               IF I = 0 THEN TableData.FirstCol := Column
               ELSE IF I = FieldCount - 1 THEN
                  BEGIN
                  ColSnip^.NextSnip := NullSnip;
                  TableData.LastCol := Column;
                  END;

               {Link in the backward pointer of this snip.}
               ColSnip^.PriorSnip := LastCol;

               {Link in the next pointer of the last column.}
               IF LastCol <> NullSnip THEN
                  BEGIN
                  SetSnipPtr(ColKind,LastCol);
                  ColSnip^.NextSnip := Column;
                  END;

               I := I + 1;
               LastCol := Column;
               END;
            END;


WidthCode: BEGIN
           IF Trace2MMgr then WriteLn(MxMgr,MLFC,'Width block found');
           {Make sure block length corresponds to field count}
           IF Len <> (FieldCount + 2) THEN
              BEGIN
              IF MMTrap1 THEN WriteLn(Bell,'***Bad length in width block: ',Len);
              GOTO 500;
              END;
           IntArray := @FormArray^[NextLoc + 2];
           Column := TableData.FirstCol;
           While Column <> NullSnip DO
              BEGIN
              SetSnipPtr(ColKind,Column);
              Width := IntArray^[ColSnip^.FieldNum];
              IF (Width < 0) OR (Width > MaxColWidth) THEN
                 BEGIN
                 IF MMTrap1 THEN WriteLn(Bell,'***Bad width: ',Width);
                 ListFormChanged := TRUE;
                 END
              ELSE ColSnip^.Width := Width;
              Column := ColSnip^.NextSnip;
              END;
           END;


FontCode: BEGIN
          IF Trace2MMgr then WriteLn(MxMgr,MLFC,'Width block found');
          {Make sure block length corresponds to field count}
          IF Len <> (SizeOf(FontRec) + 2) THEN
             BEGIN
             IF MMTrap1 THEN WriteLn(Bell,'***Incompatible font block length: ',Len);
             GOTO 400;
             END;
          MoveLeft(FormArray^[NextLoc + 2],MMFontinfo,SizeOf(FontRec));
          WITH MMFontinfo DO
             BEGIN
             Status2 := FmFontMetrics(Font,finfo,Status);
             IF MMTrap1 THEN IF Status <> 0 THEN WriteLn('***',MLFC,'FmFontMetrics status: ',Status);
             WITH finfo DO
                BEGIN
                CellWidth := WidMax+1;
                CellHeight := Ascent + Descent + Leading;
                END;
             AdjustTableToFont(CellWidth,CellHeight);
             END;
          END;


PrintCode: BEGIN
           IF Trace2MMgr then WriteLn(MxMgr,MLFC,'Print block found');
           {Make sure block length corresponds to field count}
           IF Len <> (SizeOf(MMPrintPreference) + 2) THEN
              BEGIN
              IF MMTrap1 THEN WriteLn(Bell,'***Incompatible print block length: ',Len);
              GOTO 400;
              END;
           MoveLeft(FormArray^[NextLoc + 2],MMPrintPreference,SizeOf(MMPrintPreference));
           END;


VisCode: BEGIN
         IF Trace2MMgr then WriteLn(MxMgr,MLFC,'Visible block found');
         {Make sure block length corresponds to field count}
         IF Len <> (FieldCount + 2) THEN
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,'***Bad length in visible block: ',Len);
            GOTO 500;
            END;

         IntArray := @FormArray^[NextLoc + 2];
         Column := TableData.FirstCol;
         While Column <> NullSnip DO
            BEGIN
            SetSnipPtr(ColKind,Column);
            WITH ColSnip^ DO
               BEGIN
               IF (IntArray^[FieldNum] = 0) {Invisible}
               OR ((FieldNum = 1) AND (FieldInfo.FldType = Tick)) {Ticket}
               THEN Visible := FALSE
               ELSE Visible := TRUE;
               END;
            Column := ColSnip^.NextSnip;
            END;
         END;

SortCode:
         BEGIN
         IF Trace2MMgr then WriteLn(MxMgr,MLFC,'Sort block found');
         IntArray := @FormArray^[NextLoc + 2];
         Column := TableData.FirstCol;
         While Column <> NullSnip DO
            BEGIN
            SetSnipPtr(ColKind,Column);
            ColSnip^.SortOrder := IntArray^[ColSnip^.FieldNum * 2];
            ColSnip^.SortDirection := IntArray^[ColSnip^.FieldNum * 2 + 1];
            Column := ColSnip^.NextSnip;
            END;
         END;

SearchCode:
         BEGIN
         IF Trace2MMgr then WriteLn(MxMgr,MLFC,'Search block found');
         IntArray := @FormArray^[NextLoc];
         NumTriples := IntArray^[2];
         TripSize := IntArray^[3];
         ConstSize := IntArray^[4];

         {Now create a snip block to contain the expressions and load it up.}
         GetSnipBlock(ExprSnip,TripSize,Status);
         ExprHnd := POINTER(ORD(SnipToPtr(ExprSnip)));
         MoveLeft(IntArray^[5],ExprHnd^^,TripSize);

         {Create a snip block for the constants and load it up}
         GetSnipBlock(ConstSnip,ConstSize,Status);
         ConstHnd := POINTER(ORD(SnipToPtr(ConstSnip)));
         MoveLeft(IntArray^[5+TripSize],ConstHnd^^,ConstSize);

         SearchValid := FALSE; {Causes new scan to be opened if necessary.}
         END;

      END; {case}

200:  NextLoc := NextLoc + Len;
      END;

300:{Release the space for the form}
   FreSnipBlock(FormId);
   Exit(MakeListFormChanges);

400: {Error occurred which prevents processing of current block, but
    does not prevent following blocks from being processed.}
    ListFormChanged := TRUE;
    GOTO 200;

500: {Error occurred which prevents processing of any more blocks}
   ListFormChanged := TRUE; {Forces write of new list and deletion of old}
   GOTO 300;
   END;



{$S lmres2 }
Function MakeSpace{hz:THz; cbNeed:Integer) : INTEGER};

   LABEL 800,999;

   CONST MS = ' MakeSpace ';

   VAR TopVisibleRow: IdType;
       BotVisibleRow: IdType;
       LeftVisibleCol: IdType;
       NewBottomRow : IdType;
       NewTopRow: IdType;
       OldTopRow: IdType;
       cRg : Range;
       Row: IdType;
       PrevRow: IdType;
       NextRow : Idtype;
       countrows : integer;
       CurPt: Point;
       VisRg: Range;
       RowsFreed: BOOLEAN;
       Status: INTEGER;
       NewSegMemSize: LONGINT;
       NewSegDiscSize: LONGINT;
       DeltaSpace: LONGINT;
       DeltaMem: LONGINT;

{$IFC MMDEBUG }
    PROCEDURE CountSnips;

       VAR Tracing: BOOLEAN;
           SnipId: IdType;
           Rows: INTEGER;
           Cols: INTEGER;
           CRRows: INTEGER;
           CTRows: INTEGER;
           FSnips: INTEGER;
           Tot: INTEGER;
           Misc: INTEGER;

       BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
       IF TraceMMgr THEN
          BEGIN
          TraceMMgr := FALSE;
          Tracing := TRUE;
          END
       ELSE Tracing := FALSE;

       {Count up row snips on main list}
       SnipId := TableData.TopRow;
       Rows := 0;
       WHILE SnipId <> NullSnip DO
          BEGIN
          Rows := Rows + 1;
          SetSnipPtr(Rowkind,SnipId);
          SnipId := RowSnip^.NextSnip;
          END;

       {If there are rows on current range list, count them up}
       CRRows := 0;
       IF CurRgList THEN
          BEGIN
          SnipId := CurRgSnip;
          WHILE SnipId <> NullSnip DO
             BEGIN
             CRRows := CRRows + 1;
             SetSnipPtr(RowKind,SnipId);
             SnipId := RowSnip^.NextSnip;
             END;
          END;

       {If Rows have been cut, count them up}
       CTRows := 0;

       IF RowsCut THEN
          BEGIN
          SnipId := CutRow.FirstRow;
          WHILE SnipId <> NullSnip DO
             BEGIN
             CTRows := CTRows + 1;
             SetSnipPtr(RowKind,SnipId);
             SnipId := Rowsnip^.NextSnip;
             END;
          END;

       {Count the number of free snips}
       FSnips := 0;
       SnipId := FreeSnipList;
       WHILE SnipID <> NullSnip DO
       BEGIN
       FSnips := FSnips + 1;
       SnipId := SnipMap[SnipId];
       END;

       {Count the columns now}
       Cols := 0;
       SnipId := TableData.FirstCol;
       WHILE SnipId <> NullSnip DO
          BEGIN
          Cols := Cols + 1;
          SetSnipPtr(ColKind,SnipId);
          SnipId := ColSnip^.NextSnip;
          END;

       {Count miscellaneous snips}
       Misc := 0;
       IF ConstSnip <> NullSnip THEN Misc := Misc + 1;
       IF ExprSnip <> NullSnip THEN Misc := Misc + 1;

       {Write out the results}
       Tot := FSnips + CTRows + CRRows + Rows + Cols + Misc;
       IF (Tot <> 250) OR Tracing THEN
          BEGIN
          WriteLn('SnipCounts..Free:',FSnips:3,'Rows:',Rows:3,'Cols:',Cols:3);
          WriteLn('CRRows:',CRRows:3,'CutRows:',CTRows,'Misc: ',Misc:3);
          WriteLn('Total Snip Count:',Tot:3);
          END;

       IF Tracing THEN TraceMMgr := TRUE;
       END;
{$ENDC }


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF MMTrap1 THEN WriteLn(MxMgr,MS,CBNeed);
   IF Trace2MMgr THEN WriteLn(MS,'Zone,SegMem,SegDisc,MMCalling:  ',ZoneSize,SegMemSize,SegDiscSize,' ',MMCallingMakeSpace);
   DeltaSpace := 0; {Count of bytes accumulated}


   {If there is extra space in the data segment which has not been given
   to the zone, do so. However, don't do it if it is the matrix manager
   which is calling, because if it is, what it really wants is to get
   rid of any snips which aren't absolutely necessary, for example,
   when suspending.}
   IF NOT MMCallingMakeSpace AND (ZoneSize < SegDiscSize) THEN
      BEGIN
      {Check to see if there is a difference between the zone size and the
      segment memory size. If so, release it}
      IF ZoneSize < SegMemSize THEN
         BEGIN
         IF Trace2MMgr THEN WriteLn(MS,'Expanding zone to segment memory size.');
         DeltaSpace := SegMemSize - ZoneSize;
         IF DeltaSpace >= CBNeed THEN GOTO 999;
         END;

      {Now check to see if there is a difference between the segment memory
      size and the segment disc size. If so, expand the memory size of the
      data segment.}
      IF SegMemSize < SegDiscSize THEN
         BEGIN
         DeltaMem := SegDiscSize - SegMemSize;
         IF DeltaMem > 10000 THEN DeltaMem := 10000; {Don't expand more than 10K bytes at a time}
         IF Trace2MMgr THEN WriteLn(MS,'Expanding segment memory size by: ',DeltaMem);
         Size_DataSeg(Status,SegRefNum,DeltaMem,NewSegMemSize,0,SegDiscSize);
         IF Status > 0 THEN
            BEGIN
            {We didn't get the memory we wanted. However, this is no cause for
            a fatal error, because we may still be able to throw away stuff.}
            IF MMTrap1 THEN WRiteLn(Bell,'***',MS,'Size_DataSeg status: ',Status);
            END;
         DeltaMem := NewSegMemSize - SegMemSize; {Must recompute how much was actually obtained.}
         IF Trace2MMgr THEN WriteLn('***',MS,'Expanded memory size of segment by: ',DeltaMem);
         DeltaSpace := DeltaSpace + DeltaMem;
         SegMemSize := NewSegMemSize;
         IF DeltaSpace >= CBNeed THEN GOTO 999;
         END;
      END;

   {If printing, simply save the last or first row depending on the direction and throw out the rest.}
   IF Printing AND (CurTable = TList) THEN
      BEGIN
      IF Trace2MMgr THEN WriteLn(MxMgr,MS,'Print logic');
      {Remember which row to save}
      WITH TableData DO IF InsertAtTop THEN NewTopRow := TopRow ELSE NewTopRow := BottomRow;
      IF NewTopRow <> NullSnip THEN
         BEGIN
         {Cut it out of the list}
         WITH TableData DO CutRowSnips(TopRow,BottomRow,NewTopRow,NewTopRow);

         {Release all of the rows which are left}
         ReleaseRowSnips;

         {Now link the snip back in}
         WITH TableData DO
            BEGIN
            TopRow := NewTopRow;
            BottomRow := NewTopRow;
            END;
         END;

      {If there is a current range, get rid of it too}
      IF CurRgList THEN RelCrgList;

      GOTO 999;
      END;

   {If the list is current, then most likely we can free up some row snips which are not being
   displayed to make space. Make sure that we are not in the process of loading up snips when
   resuming, however, since the snip structures are inconsistent at this point.}
   IF (CurTable = TList) AND (NOT LoadingSnips) THEN
      BEGIN
      IF Trace2MMgr THEN
         BEGIN
         WriteLn('Attempting to release row snips');
         {$IFC MMDEBUG }
         CountSnips;
         IF CurRgList THEN DumpCrgList;
         DumpTB;
         {$ENDC }
         END;

      {Following boolean keeps track if we actually manage to release snips}
      RowsFreed := FALSE;

      {Make sure there is something to release}
      IF TableData.TopRow = NullSnip THEN GOTO 800;

      {Find out the top and bottom limits of the visible screen}
      {Get point in current view}
      TMCurVwPt(CurPt);
      IF Trace2MMgr THEN WriteLn('H: ',CurPt.H,' V: ',CurPt.V);
      {Get currently visible range}
      VisRgOfView(CurPt,VisRg);
      WITH VisRg DO
         BEGIN
         TopVisibleRow := LoRow;
         BotVisibleRow := HiRow;
         IF Trace2MMgr THEN WriteLn('TMCurVwPt LoRow: ',LoRow,' HiRow: ',HiRow);
         IF (TopVisibleRow = MInfSnip) OR (TopVisibleRow = PInfSnip) THEN
            BEGIN
            {There is nothing showing on the screen}
            GOTO 800;
            END;
         IF BotVisibleRow = PInfSnip THEN BotVisibleRow := TableData.BottomRow;
         END;

      {Now alter the top or bottom row depending on the scroll direction, if any}
      IF Scrolling THEN
         BEGIN
         IF Trace2MMgr THEN WriteLn('Scrolling.....');
         IF InsertAtTop THEN TopVisibleRow := TableData.TopRow
         ELSE BotVisibleRow := TableData.BottomRow;
         END;

      IF Trace2MMgr THEN WriteLn('TopVisibleRow:',TopVisibleRow:4,'BottomVisibleRow:',BotVisibleRow:4);

      {Determine whether or not to remove rows from the bottom}
      IF SnipLT(RowKind,BotVisibleRow,TableData.BottomRow)       {First there must be rows to release.}
      AND ((NOT Scrolling) OR InsertAtTop) THEN                  {If scrolling, must be scrolling up.}

         BEGIN {Remove rows from the bottom}
         IF Trace2MMGR then  writeln('removing rows from the bottom');
         NewBottomRow := BotVisibleRow;

         {If the current range is off the screen, and it has not already
         been saved, then save the snips.}
         IF NOT CurRgList THEN
            BEGIN
            GetCR(cRg);
            WITH CRg DO IF (Rkind = aRowRg) OR
               (Rkind = a1CellRg) OR
               (Rkind = aRowGrid) THEN
               BEGIN {Valid Range so check for current range off the screen}
               {Adjust range to contain only real snips}
               IF Rkind = ARowGrid THEN
                  BEGIN
                  if mmtrap1 then WriteLn('Row Grid: LoRow: ',LoRow,' HiRow: ',HiRow);
                  IF (LoRow = MInfSnip) OR (LoRow = NullSnip) THEN LoRow := HiRow
                  ELSE IF (HiRow = PInfSnip) OR (HiRow = NullSnip) THEN HiRow := LoRow;
                  END;

               IF SnipLT(rowkind,NewBottomRow,hiRow)  THEN
                  BEGIN {Hi row of current range is in area to be deleted.}
                  {Construct a linked list starting with curRgsnip which has all}
                  {the  currg snips that are off the screen, and delete them from}
                  {the Tabledata.top .. bottom linked list (screen list )        }

                  IF Trace2MMGR then writeln('current range is off screen');

                  {If range straddles newbottom, set newbottom to include range.}
                  IF NOT SnipLT(RowKind,NewBottomRow,LoRow) THEN
                     BEGIN
                     NewBottomRow := HiRow;
                     END

                  ELSE BEGIN {Range is entirely below newbottom.}
                       {Cut the range out of the list}
                       WITH TableData DO CutRowSnips(TopRow,BottomRow,LoRow,HiRow);
                       CurRgSnip := LoRow;
                       CurRgList := TRUE;
                       END; {Range entirely below newbottom.}

                  END; {Part of range in area to be deleted.}
               END; {Valid range.}
            END; {Not CurRgList}

         {now delete from one after new bottom to end, if there is any left after
         possibly cutting out the current range.}
         IF TableData.BottomRow <> NewBottomRow THEN
            BEGIN
            SetSnipPtr(rowkind,newbottomrow);
            Row := Rowsnip^.nextsnip;
            RowSnip^.NextSnip := NullSnip;
            ReleaseSnips(RowKind,Row);
            TableData.BottomRow := NewBottomrow;
            RowsFreed := TRUE;
            END;

         TableData.LastRow := NullSnip;
         END ; {Delete from bottom}


      {Now check to see if we should delete from the top}
      IF SnipLT(RowKind,TableData.TopRow,TopVisibleRow)    {First make sure there are rows to release.}
      AND ((NOT Scrolling) OR (NOT InsertAtTop))  THEN     {If scrolling, must be downward.}

         BEGIN
         IF Trace2MMGR then  writeln('removing rows from the top');
         {Remove Rows from the top}
         newtoprow := TopVisibleRow;

         {See if current range is off top of screen}
         IF NOT CurRgList THEN
            BEGIN
            GetCR(cRg);
            WITH Crg DO IF (Rkind = aRowRg) OR
            (Rkind = a1CellRg) OR
            (Rkind = aRowGrid) THEN
               BEGIN {Valid Range so check for current range off the screen}
               {Adjust range to contain only real snips}
               IF Rkind = ARowGrid THEN
                  BEGIN
                  if mmtrap1 then WriteLn('Row Grid: LoRow: ',LoRow,' HiRow: ',HiRow);
                  IF (LoRow = MInfSnip) OR (LoRow = NullSnip) THEN LoRow := HiRow
                  ELSE IF (HiRow = PInfSnip) OR (HiRow = NullSnip) THEN HiRow := LoRow;
                  END;


               IF SnipLT(rowkind,loRow, newtoprow)  THEN
                  BEGIN {At least part, if not all of current range is in the
                  area at the top to be deleted.}
                  {Construct a linked list starting with curRgsnip which has all}
                  {the  currg snips that are off the screen, and delete them from}
                  {the Tabledata.top .. bottom linked list (screen list )        }

                  IF Trace2MMGR then
                     BEGIN
                     writeln('current range is off top screen');
                     WriteLn('LowRow: ',lorow,'HiRow: ',hirow);
                     END;

                  {If the range straddles the new top row, then reset the new top
                  row to include it.}
                  IF NOT SnipLT(RowKind,HiRow,NewTopRow) THEN
                     BEGIN
                     NewTopRow := LoRow;
                     END

                  ELSE BEGIN {Range is entirely above new top row.}
                       {Cut the range out of the list}
                       WITH TableData DO CutRowSnips(TopRow,BottomRow,LoRow,HiRow);
                       CurRgSnip := LoRow;
                       CurRgList := TRUE;
                       END; {Range entirely above new top row.}

                  END; {Part of range in area to be deleted.}
               END; {Valid Range}
            END; {Not CurRgList}

         {now delete from oldtop to newtop, if we havent done so already by
         cutting out the current range!}
         IF NewTopRow <> TableData.TopRow THEN
            BEGIN
            OldTopRow := TableData.TopRow;
            TableData.TopRow := newtoprow;
            SetSnipPtr(RowKind,NewTopRow);
            PrevRow := RowSnip^.PriorSnip;
            RowSnip^.PriorSnip := NullSnip;
            SetSnipPtr(RowKind,PrevRow);
            RowSnip^.NextSnip := NullSnip;
            ReleaseSnips(RowKind,OldTopRow);
            RowsFreed := TRUE;
            END;

         {misc cleanup}
         TableData.FirstRow := NullSnip;
         END; {Delete from top}

      IF RowsFreed THEN
         BEGIN
         IF Trace2MMgr THEN
            BEGIN
            WriteLn('Row snips released');
            {$IFC MMDEBUG }
            CountSnips;
            {$ENDC }
            END;

         IF Trace2MMgr THEN
            BEGIN
            {$IFC MMDEBUG }
            IF CurRgList THEN DumpCrgList;
            DumpTB;
            {$ENDC }
            END;

         GOTO 999;
         END;

800:  IF Trace2MMgr THEN WriteLn('Unable to release row snips');
      END; {CurTable = TList}

   {If we get this far, then it means that there was no extra disc segment
   space, and furthermore, we were unable to free any snips. This does not normally
   happen, because the procedure EnoughMemory tries to guaranteed that
   there is enough disc heap space for any sequence of operations. However, for
   lists with small numbers of columns relative to the record size, the estimate
   does not always work. Therefore, we will try to expand the data segment rather than
   abort the process. Only do this if it is the storage manager calling.}
   IF NOT MMCallingMakeSpace THEN
      BEGIN
      DeltaMem := 10000;
      IF MMTrap1 THEN WriteLn('***',MS,'Snip heap full, Attempting to expand disc size by: ',DeltaMem,' bytes');
      Size_DataSeg(Status,SegRefNum,DeltaMem,NewSegMemSize,DeltaMem,NewSegDiscSize);
      IF Status = 0 THEN
         BEGIN
         IF MMTrap1 THEN WriteLn('*** Segment expanded to: ',NewSegMemSize,' bytes');
         DeltaSpace := DeltaSpace + NewSegMemSize - SegMemSize;
         SegMemSize := NewSegMemSize;
         SegDiscSize := NewSegDiscSize;
         GOTO 999;
         END
      ELSE BEGIN
           IF MMTrap1 THEN WriteLn(Bell,'***',MS,'Size_DataSeg status: ',Status);
           StatusMakeSpace := Status; {Remember Size_DataSeg status for GetSnipblock and ExpSnipBlock}
           END;
      END;



999: {Set the number of bytes given up, if any, and remember new zone size.}
   MakeSpace := DeltaSpace;
   ZoneSize := ZoneSize + DeltaSpace; {If more space given, remember new size}
   IF Trace2MMgr THEN WriteLn(MS,'Zone,SegMem,SegDisc,DeltaSpace: ',ZoneSize,SegMemSize,SegDiscSize,DeltaSpace);
   END;




{$S lmrecov }
PROCEDURE MarksRevenge{var result : integer;
                       var warnings : elemset;
                       lsid : integer};
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' MarksRevenge ');

   Result := NoErr;
   END;



{$S lmres }
function mmBreakSnip{aKind : snipKind;
                     aSnip : idType) : Boolean};
     BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
     IF TraceMMgr THEN WriteLn(MxMgr,' MMBreakSnip ');

     MMBreakSnip := FALSE;
     END;


{$S lmres }
PROCEDURE MMErrFile{Status: INTEGER;
                   VAR ErrFile: TAlertFile;
                   VAR ErrNum: INTEGER};


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' MMErrFile ');

   {Errors from the matrix manager range from 0 to 999}
   IF (Status >= 0) AND (Status < 1000) THEN
      BEGIN
      Errnum := STatus;
      ErrFile := LMALERTS;
      END


   ELSE IF (Status > FEErr) AND (Status < (FEErr+1000)) THEN
      BEGIN
      CASE (Status - FEErr) OF
         FldFull:      ErrNum := FieldFull;
         FldProtected: ErrNum := FldNoMod;
         NullSelect:   ErrNum := SelZero;
         InvScrapType: ErrNum := ScrapErr;
         InvOpType:    ErrNum := NoUndo;
         InvalidEdit:  ErrNum := InvEdit;
         FEAllocationFailed: Errnum := fealocerr;
         FENotUndoable: Errnum := fenoundo;
         END;
      ErrFile := LMALERTS;
      END


   ELSE IF (Status >= dsptoosmall) AND (Status <= (rectoosmall)) THEN
      BEGIN
      CASE (Status ) OF
         DspTooSmall: ErrNum := StrRoom;
         RecTooSmall: ErrNum := RecRoom;
         END;
      ErrFile := LMALERTS;
      END


   ELSE IF (Status >= CvtErr) AND (Status < (DBERR)) THEN
      BEGIN
      Errnum := Status - CVTErr;
      ErrFile := DBCALERTS;
      END


   ELSE IF (Status > DBErr)  THEN
      BEGIN
      Errnum := STatus;
      ErrFile := LMALERTS;
      END;
   END;



{$S lmclosedoc }
PROCEDURE MMFatalErr{Status: INTEGER;
                     CurProc: String40;
                     CallProc: String40};

   {The only real purpose of this procedure is to halt. This will cause
   the terminate exception handler to be called to clean things up.
   The other purpose is to write out some debugging information if the
   debug flags are enabled.}

   VAR ErrNum: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' MMFatalErr ');
   IF MMTrap1 THEN
      BEGIN
      WriteLn(Bell,'Fatal error in matrix manager procedure: ',CurProc);

      IF CallProc <> '' THEN
         BEGIN
         IF Status < 1000 THEN ErrNum := Status
         ELSE IF (Status>FEErr) AND (Status<(FEErr+1000)) THEN ErrNum := Status - FEErr
         ELSE IF (Status>CVTErr) AND (Status<(CVTErr+1000)) THEN ErrNum := Status - CVTErr
         ELSE IF (Status>=dsptoosmall) AND (Status<=(rectoosmall)) THEN ErrNum := Status
         ELSE IF (Status>DBErr) THEN ErrNum := Status - DBErr;

         WriteLn('Error status: ',ErrNum:2,' returned from procedure: ',CallProc);
         END

      ELSE WriteLn('Error status: ',Status:2);

      {Loop}
      WHILE True DO ErrNum := ErrNum + 1;
      END;



    Halt;
    END;



{$S lminit}
PROCEDURE MMInit{dbcAlert:TAlertFile; VAR Status: INTEGER};

  CONST MMI = ' MMInit ';

  VAR    I : INTEGER;
         lresult : integer;
         path:pathname;
         ErrStatus: INTEGER;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,MMI);

   {Initialize Miscellaneous globals}
   Bell := chr(7);
   LoadingSnips := FALSE;

   {initialize trace, debug and trap flags}
   {$IFC MMDEBUG }
   TraceMMgr := FALSE;
   Trace2MMgr := FALSE;
   MMTrap1 := TRUE;
   MMTrap2 := FALSE;
   {$ENDC }

   {$IFC PRERELEASE } {These are database intrinsic debug flags }
   pdebug := false ;
   labdebug := false ;
   scandebug := false ;
   bdebug := false ;
   dbdebug := false;
   debug_compact := false;
   lmdebug := false ;
   {$ENDC }

   {initialize international stuff}
   Convert := FALSE;
   CvtEditChk := FALSE;

   {Pull in strings used for table fill-in from the alert file}
   GetStrings;

   {Initialize default print information.}
   PrPrfDefault(MMPrintDefault);

   {Initialize the database structures}
   IF Trace2MMgr then WriteLn(MxMgr,MMI,'InitPool');
   path := 'initpool';
   Sched_Class(ErrStatus,FALSE);
   InitPool(Status,true,IP1LDSN,DBBuffers,DBHeapSize,@path,ds_private,2048);
   Sched_Class(ErrStatus,TRUE);
   IF Status <> NoErr THEN
      BEGIN
      Status := Status + DBErr;
      Exit(MMInit);
      END;

   {Initialize lmscan search strategy}
   Init_Strategy;

   {Set_Sort is a global db variable which determines which kind
   of sort (key or full) will be used. Until we determine the
   criteria for selecting one or the other, it will always be set
   one way.}
   Set_Sort := 0; {TSorted=1, TRetrieve=0 }

   {Set minimum number of differential file pages}
   LastPermanant := (PSize * DiffFilePages) + 512;

   {Initialize edit check stuff}
   InitConvert(dbcAlert);

   END;


{$S lmopendoc }
PROCEDURE MMInitFiles;

   CONST MMIF = ' MMInitFiles';

   VAR I : INTEGER;
       Status: INTEGER;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,MMIF);
   IF MMTrap1 then writeln('TableData,FreeSnipList,SnipMap : ',ord(@tabledata):10,
                            ord(@freesniplist):10, ord(@snipmap):10);

   {Initialize Snip Zone data segment}
   ZoneSize := SegMemSize;
   SnipZone := HzInit(@SegPtr^,Pointer(Ord(@SegPtr^)+ZoneSize),nil,MaxSnips,0,@MakeSpace, nil,nil,nil);

   {Put all snips in the snipmap on the free snip list}
   i := 1;
   while i < maxsnips do
     begin
     SnipMap[i] := i + 1;
     i := i+1;
     end;
   SnipMap[MaxSnips] := nullSnip;
   FreeSnipList := 1;

   {Initialize table information records}
   InitTabRecords;

   {Initialize printer preference information from the default.}
   MMPrintPreference := MMPrintDefault;

   {Initialize time record used to identify scrap with this document}
   Get_Time(Status,DocScrapId);
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***Get_Time status: ',Status);

   {Initialize miscellaneous globals}
   MMCallingMakeSpace := FALSE;
   RedefiningTable := FALSE;
   ScanOpen := FALSE;
   SearchValid := FALSE;
   SortValid := FALSE;
   Searched := FALSE;
   Sorted := FALSE;
   SearchRequested := FALSE;
   SortRequested := FALSE;
   SchemaChanged := FALSE;
   ErrorList := FALSE;
   TableCut := FALSE;
   Printing := FALSE;
   DocSuspended := FALSE;
   ListScrollValid := FALSE;
   HScrollId := NullSnip;
   ListRowCount := 0;
   BytesAdded := 0;
   MagCaution := FALSE;

   {Any globals which are snipids, or indicate existance of a snipid
   should be initialized, since the snip zone is empty at this point}
   ColumnsCut := FALSE;
   RowsCut := FALSE;
   ColumnsDeleted := FALSE;
   CurRgList := FALSE;
   ExprSnip := NullSnip;
   ConstSnip := NullSnip;
   TypeRow := NullSnip;
   EditCRow := NullSnip;
   SortRow := NullSnip;
   VisibleRow := NullSnip;
   CopyListColumns.FirstCol := NullSnip;

   with cutrow do
     begin
     firstrow := nullsnip;
     lastrow := nullsnip;
     end;

   {Initialize search stuff to not search}
   ExprHnd := Nil;
   NumTriples := 0;
   ConstHnd := Nil;
   ConstSize := 0;
   SearchValid := FALSE;

   END;

{$S lmres }
PROCEDURE mmMapSnip{snip :snipkind;
                    oldSnipId: idtype;
                    VAR newSnipId: idType;
                    VAR status : INTEGER};

   CONST MMMS = ' MMMapSnip';

   VAR Column: IdType;
       Row: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,MMMS);
   Status := RMOk;

   CASE snip  OF
   ColKind: BEGIN
            IF ColumnsCut THEN
               BEGIN
               Column := CutCol.FirstCol;
               WHILE Column <> NullSnip DO
                  BEGIN
                  IF Column = OldSnipId THEN
                     BEGIN
                     Status := RMDel;
                     Column := NullSnip;
                     END

                  ELSE BEGIN {Column <> OldSnipId}
                       IF Column = CutCol.LastCol THEN Column := NullSnip
                       ELSE BEGIN
                            SetSnipPtr(ColKind,Column);
                            Column := ColSnip^.NextSnip;
                            END;
                       END;
                  END;
               END
            END;

   RowKind: IF RowsCut THEN
               BEGIN

               Row := CutRow.FirstRow;
               WHILE Row <> NullSnip DO
                  BEGIN
                  IF Row = OldSnipId THEN
                     BEGIN
                     Status := RMDel;
                     Row := NullSnip;
                     END
                  ELSE BEGIN
                       SetSnipPtr(RowKind,Row);
                       Row := RowSnip^.NextSnip;
                       END;
                  END;
               END;
   END; {Case}

   IF Status = RMOk THEN NewSnipId := OldSnipId;
   END;


{$S lmprint }
PROCEDURE MMPrint;

   CONST MMP = ' MMPrint';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,MMP);

   Printing := TRUE;

   {If the current table is the list, do some special things}
   IF Curtable = TList THEN
      BEGIN
      {Remember the row at the top of the display, so that we can
      come back to it after it has long been swapped out.}
      SaveScroll;

      {If the first snip is not in memory, get rid of the rest to make room.}
      IF TableData.FirstRow = NullSnip THEN
         BEGIN
         IF CurRgList THEN RelCrgList;
         ReleaseRowSnips;
         END;

      END;

   {Print the list}
   PrintList;


   IF CurTable = TList THEN
      BEGIN
      {Release all of the snips used to print.}
      ReleaseRowSnips;
      END;

   {Set printing flag off}
   Printing := FALSE;
   END;



{$S lmres2 }
PROCEDURE NewCSCol{ListColId: IdType;
                   VAR CSColId: IdType};

   {This procedure creates a single col spec table column snip, given the
   identifier of a list column snip to create it from.}

   CONST NCSC = ' NewCSCol ';

   VAR ColId: IdType;
       ColRecSize: INTEGER;
       ColName: ARRAY[0..255] OF BYTE;
       ColNameLen: INTEGER;
       SOrder: INTEGER;
       SDirection: INTEGER;
       SWidth: INTEGER;
       SNewCol: BOOLEAN;
       BytePtr: PtrData;
       ErrNum: INTEGER;
       InitFreeBytes: INTEGER;
       NullString: STRING[1];
       Status: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,NCSC);
   NullString := '';

   {Remember some column info for later}
   IF ListColId = NullSnip THEN
      BEGIN
      ColNameLen := 0;
      SOrder := 0;
      SDirection := 0;
      SWidth := ColWidth;
      SNewCol := TRUE;
      END

   ELSE BEGIN
        {Load from an old column}
        SetSnipPtr(ColKind,ListColId);
        IF ColSnip^.FieldInfo.Name = FNilVal THEN ColNameLen := 0
        ELSE BEGIN
             BytePtr := POINTER(ORD(@ColSnip^.FieldInfo) + ColSnip^.FieldInfo.Name);
             ColNameLen := BytePtr^[0] + 1;
             MoveLeft(BytePtr^,ColName,ColNameLen);
             END;

        WITH ColSnip^ DO
           BEGIN
           SOrder := SortOrder;
           SDirection := SortDirection;
           SWidth := Width;
           SNewCol := NewColumn;
           END;
        END;

   {Now,  get a snip block for the new spec column}
   InitFreeBytes := ColNameLen + 1{Null String} + 5{Room to grow};
   ColRecSize := SIZEOF(ColSnipRecord) + InitFreeBytes;
   GetSnipBlock(ColId,ColRecSize,Status);

   {Set up the pointers to it}
   InitSnipPtr(ColKind,ColId);

   {Initialize the column snip record}
   WITH ColSnip^ DO
      BEGIN
      RecSize := ColRecSize;
      SnipId := ColId;
      SnipType := ColKind;
      NextSnip := NullSnip;
      PriorSnip := NullSnip;
      ListSnip := ListColId;
      Order := TableData.ColCount + 1; {Always assume adding to end}
      Width := SWidth;
      NewColumn := SNewCol;
      FieldNum := Order - 1;
      SortOrder := SOrder;
      SortDirection := SDirection;
      Visible := TRUE;
      FreeBytes := InitFreeBytes;
      {Field information initialized in next step}
      END;

   {Initialize the field information portion of the column snip}
   WITH ColSnip^.FieldInfo DO
      BEGIN
      FldSize := SIZEOF(DBField);
      Name := Fnilval;
      Display := FNilVal;
      Highval := Fnilval;
      Lowval := Fnilval;
      Defval := Fnilval;
      {Now set the editcheck array}
      LegalEditCheck('',Lets,EditCheck,ErrNum);
      IF MMTrap1 THEN IF ErrNum <> 0 THEN
         BEGIN
         WriteLn(Bell,'***LegalEditCheck status: ',Errnum);
         END;
      FldType := Lets; {Characters}
      Options := [DBCentered,DBNullOk];
      RepType := FTypVstr; {Variable length characters}
      OffSet := (ColSnip^.Order - 1) * 4;
      Size := 4;

      {Move in the column name now if there is one}
      IF ColNameLen > 0 THEN SetFieldAttr(ColId,0,@ColName,ColNameLen);

      {Move in a null string for the edit check}
      BytePtr := @NullString;
      SetFieldAttr(ColId,1,BytePtr,1);
      END;

   {Insert the id of the column spec snip in the list snip, if there is one}
   IF ListColId <> NullSnip THEN
      BEGIN
      SetSnipPtr(ColKind,ListColId);
      ColSnip^.ListSnip := ColId;
      END;

   {Return id of the column spec snip}
   CSColId := ColId;
   END;


{$S lmcolspec }
PROCEDURE NewListCol{VAR NewColId: IdType;
                     ColOrder: INTEGER};

   {This procedure creates a default list column snip.}

   CONST NLC = ' NewListCol';

   VAR RecordSize: INTEGER;
       ColId: IdType;
       ErrNum: INTEGER;
       EPtr: PtrData;
       Status: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR THEN WriteLn(MxMgr,NLC);

   {First get a snip block}
   RecordSize := SIZEOF(ColSnipRecord)
                 + 1  {For the null edit check string}
                 + ColExpansion;
   GetSnipBlock(ColId,RecordSize,Status);

   {Set up the pointers to it}
   InitSnipPtr(ColKind,ColId);

   {Initialize the column snip record}
   WITH ColSnip^ DO
      BEGIN
      RecSize := RecordSize;
      SnipId := ColId;
      SnipType := ColKind;
      NextSnip := NullSnip;
      PriorSnip := NullSnip;
      ListSnip := NullSnip;
      Order := ColOrder;
      Width := ColWidth;
      NewColumn := TRUE;
      FieldNum := ColOrder - 1;
      SortOrder := 0;
      SortDirection := 0;
      Visible := TRUE;
      FreeBytes := ColExpansion;
      {Field information initialized in next step}
      END;

   {Initialize the field information portion of the column snip}
   WITH ColSnip^.FieldInfo DO
      BEGIN
      FldSize := SIZEOF(DBField)
                 + 1; {For the null edit check string}
      Name := Fnilval;
      Display := SIZEOF(DBField);
      Highval := Fnilval;
      Lowval := Fnilval;
      Defval := Fnilval;

      {Editcheck array initialized in next step}
      LegalEditCheck('',Lets,EditCheck,ErrNum);
      if mmtrap1 then IF ErrNum <> 0 THEN WriteLn(Bell,'***LegalEditCheck status: ',ErrNum);

      FldType := Lets; {Characters}
      Options := [DBLeft,DBNullOk];
      {RepType,Offset, and Size are not computed until the file is created.}
      RepType := 0;
      OffSet := 0;
      Size := 0;
      END;

   {Set the edit check string to null}
   EPtr := POINTER(Ord(@ColSnip^.FieldInfo) + ColSnip^.FieldInfo.Display);
   EPtr^[0] := 0; {Zero length character string}

   {Return the id of the new col spec column}
   NewColId := ColId;
   END;



ÿ