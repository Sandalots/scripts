{$S lmres }
PROCEDURE NextCell{Mode: MCType;
                   CurCell: Range;
                   VAR NxtCell: Range};

    {This procedure returns a 1-cell range depending on the value of
    Mode and on the current cell.  The next appropriate 1-cell range
    (which is application dependent) is returned in NxtCell.  Mode
    takes on the following types:

   MMRight - Move right from current range with wrap around.
   MMLeft  - Move left with wrap around.
   MMUp    - Move up.
   MMDown  - Move down.
   MMBegOfCol - Return range for beginning of next col.
   MMBegOfRow - Return range for beginning of next row.
   mmrightpeg - moe right and peg
   mmleftpeg - move left and peg }

   LABEL 800,999;

   CONST NCell = ' NextCell ';

   VAR rowband,colband : tmband;
       Status: INTEGER;

Procedure AddNewCol;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

   AddCol(Status);
   IF Status <> 0 THEN
      BEGIN
      {Range stays the same}
      NxtCell := CurCell;
      END

   ELSE
      BEGIN
      {Notify the table manager of the additional column}
      TMNewSnips(ColKind,CurCell.LoCol,TRUE);

      {Set the next cell range.}
      WITH NxtCell DO
         BEGIN
         LoRow := MInfSnip;
         LoCol := TableData.LastCol;
         RKind := AcolHedRg;
         END;
      END;
   END;



   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,NCell,'Mode:',Ord(Mode));
   {$IFC tedebug}
   IF Trace2MMgr then
      BEGIN
      PrntRg('CurCell',CurCell);
      END;
   {$ENDC}


   {Make some checks}
   IF MMTrap1 THEN
      BEGIN
      IF NOT(Mode IN [MMRight,MMLeft,MMUp,MMDown,MMBegOfRow,MMRightPeg,MMLeftPeg]) THEN
         BEGIN
         WriteLn('***Invalid mode');
         MMFatalErr(LogicErr,NCell,'');
         END;
      IF NOT (CurCell.rkind  in [a1CellRg,aColHedRg,aRowHedRg]) THEN
         BEGIN
         WriteLn('***Not a 1 cell range');
         MMFatalErr(LogicErr,NCell,'');
         END;
      END;

   {Now set the range}
   nxtcell := curcell;
   CASE Mode OF

      MMBegOfRow:
          BEGIN
          Case CurCell.rkind of
             a1CellRg:
                  BEGIN
                  GetSnipId(colkind,MMFirst,0,nxtcell.locol,nxtcell.locol);
                  GetSnipId(rowkind,MMNext,0,curcell.lorow,nxtcell.lorow);
                  IF nxtcell.lorow = pInfSnip THEN NxtCell.lorow  := curcell.lorow;
                  END;

             aColHedRg:
                  BEGIN
                  IF (curtable = tColspecs) then
                     BEGIN
                     GetSnipId(colkind,MMFirst,0,nxtcell.locol,nxtcell.locol);
                     GetSnipId(rowkind,MMFirst,0,nxtcell.lorow,nxtcell.lorow);
                     NxtCell.rkind := a1CellRg;
                     END;
                  END;

             aRowHedRg:
                  BEGIN
                  if mmtrap1 then writeln('***tab from arowhed');
                  END;
             END;
         END;

      MMleft:
          BEGIN
          CASE CurCell.rkind of

             a1CellRg:
                 BEGIN
                 GetSnipId(colkind,MMPrior,0,curcell.locol,nxtcell.locol);
                 if nxtcell.locol = MinfSnip then
                    BEGIN

                    GetSnipId(colkind,MMLast,0,nxtcell.locol,nxtcell.locol);
                    GetSnipId(rowkind,MMPrior,0,curcell.lorow,nxtcell.lorow);
                    if NxtCell.lorow = MinfSnip then
                       BEGIN
                       IF (CurTable = tColSpecs) then
                          BEGIN
                          {Column headers are editable so allow moves there}
                          nxtcell.rkind := aColHedRg;
                          END
                       ELSE
                          BEGIN
                          {curcell is 1st cell of list so stay there}
                          nxtcell := curcell;
                          END;
                       END;
                    END;
                 END;

             aColHedRg:
                 BEGIN
                 GetSnipId(colkind,MMPrior,0,curcell.locol,nxtcell.locol);
                 if NxtCell.locol = MinfSnip then
                    BEGIN
                    Nxtcell := curCell;
                    END;
                 END;

             aRowHedRg:
                 BEGIN
                 if mmtrap1 then writeln('***left from arowhed');
                 END;

             END;
          END;


      MMleftPeg:
          BEGIN
          CASE CurCell.rkind of

             a1CellRg:
                 BEGIN
                 GetSnipId(colkind,MMPrior,0,curcell.locol,nxtcell.locol);
                 if nxtcell.locol = MinfSnip then
                    BEGIN

                    {curcell is 1st cell of list so stay there}
                    nxtcell := curcell;
                    END;
                 END;

             aColHedRg:
                 BEGIN
                 GetSnipId(colkind,MMPrior,0,curcell.locol,nxtcell.locol);
                 if NxtCell.locol = MinfSnip then
                    BEGIN
                    Nxtcell := curCell;
                    END;
                 END;

             aRowHedRg:
                 BEGIN
                 if mmtrap1 then writeln('***leftPeg from arowhed');
                 END;

             END;
          END;

      MMright:
          BEGIN
          CASE CurCell.rkind of

             a1CellRg:
                 BEGIN
                 GetSnipId(colkind,MMNext,0,curcell.locol,nxtcell.locol);
                 if nxtcell.locol = PinfSnip then
                    begin
                    GetSnipId(colkind,MMFirst,0,nxtcell.locol,nxtcell.locol);
                    GetSnipId(rowkind,MMNext,0,curcell.lorow,nxtcell.lorow);

                    if NxtCell.lorow = PinfSnip then
                       begin
                       Nxtcell := curcell;
                       end;
                   end ;
                 END;

             aColHedRg:
                 BEGIN
                 GetSnipId(colkind,MMNext,0,curcell.locol,nxtcell.locol);
                 if NxtCell.locol = PinfSnip then
                    BEGIN
                    IF NOT (CreatingTable OR RedefiningTable) THEN
                       BEGIN
                       {go to first cell in the matrix}

                       GetSnipId(colkind,MMFirst,0,nxtcell.locol,nxtcell.locol);
                       if curtable = tlist then
                          begin
                          savetable(rowband,colband);
                          getsnipid(rowkind,mmfraction,0,rowband.tmbloid,
                                    rowband.tmbloid);
                          {note: this call releases row snips and brings in the
                           row associated with the pct  }


                          rowband.tmbhidep := 0;

                          loadtable(rowband,colband);
                          tmshonewtbl;
                          nxtcell.lorow := rowband.tmbloid;
                          end
                       ELSE GetSnipId(rowkind,MMFirst,0,nxtcell.lorow,nxtcell.lorow);
                       NxtCell.rkind := a1CellRg;
                       END

                    ELSE
                       BEGIN
                       {Tabbing out of the last column header when the
                       table is being created causes a new column to be created
                       at the end. Otherwise, the selection just remains in the
                       same place.}

                       AddNewCol;
                       END; {Creating table}
                    END; {Locol = PInfSnip}
                 END; {AColHedRg}


             aRowHedRg:
                 BEGIN
                 {tab into data area}
                 if mmtrap1 then writeln('***right from arowhed');
                 END;


             END;
          END;

      MMrightPeg:
          BEGIN
          CASE CurCell.rkind of

             a1CellRg:
                 BEGIN
                 GetSnipId(colkind,MMNext,0,curcell.locol,nxtcell.locol);
                 if nxtcell.locol = PinfSnip then
                    begin
                    Nxtcell := curcell;
                   end ;
                 END;

             aColHedRg:
                 BEGIN
                 GetSnipId(colkind,MMNext,0,curcell.locol,nxtcell.locol);
                 if NxtCell.locol = PinfSnip then
                    BEGIN
                    IF NOT (CreatingTable OR RedefiningTable) THEN
                       BEGIN
                       {Peg}

                       Nxtcell := curcell;
                       END

                    ELSE
                       BEGIN
                       {Tabbing out of the last column header when the
                       table is being created causes a new column to be created
                       at the end. Otherwise, the selection just remains in the
                       same place.}

                       AddNewCol;
                       END; {Creating table}
                    END; {Locol = PInfSnip}
                 END; {AColHedRg}


             aRowHedRg:
                 BEGIN
                 {tab into data area}
                 if mmtrap1 then writeln('***rightPeg from arowhed');
                 END;


             END;
          END;

      MMdown:
          BEGIN
          CASE CurCell.rkind of

             a1CellRg:
                 BEGIN
                 GetSnipId(rowkind,MMNext,0,curcell.lorow,nxtcell.lorow);
                 IF nxtcell.lorow = pInfSnip THEN
                    BEGIN
                    {peg}
                    nxtcell := curCell;
                    (*

                    {go to top of next col}

                    {get new row...}
                    if curtable = tcolspecs then
                       begin
                       nxtcell.rkind := aColHedRg;
                       nxtcell.lorow := minfsnip;
                       end
                    else
                       begin
                       if curtable = tlist then
                          begin
                          savetable(rowband,colband);
                          getsnipid(rowkind,mmfraction,0,rowband.tmbloid,
                                    rowband.tmbloid);
                          {note: this call releases row snips and brings in the
                           row associated with the pct  }


                          rowband.tmbhidep := 0;

                          loadtable(rowband,colband);
                          tmshonewtbl;
                          nxtcell.lorow := rowband.tmbloid;
                          end
                       ELSE GetSnipId(rowkind,MMFirst,0,Nxtcell.lorow,nxtcell.lorow);
                       end;

                    {get next col }
                    GetSnipId(colkind,MMNext,0,curcell.locol,nxtcell.locol);
                    if nxtcell.locol = pinfsnip then
                       begin
                       IF CreatingTable OR RedefiningTable THEN
                          BEGIN
                          {Try to add another column}
                          {GOTO 500;}
                          AddNewCol;
                          END;
                       {Otherwise, current range stays the same}
                       end;
                    *)
                    END;
                 END;

             aColHedRg:
                 BEGIN
                 if curtable = tlist then
                    begin
                    savetable(rowband,colband);
                    getsnipid(rowkind,mmfraction,0,rowband.tmbloid,
                              rowband.tmbloid);
                    {note: this call releases row snips and brings in the
                     row associated with the pct  }

                    rowband.tmbhidep := 0;
                    loadtable(rowband,colband);
                    tmshonewtbl;
                    nxtcell.lorow := rowband.tmbloid;
                    end
                 ELSE GetSnipId(rowkind,MMFirst,0,Nxtcell.lorow,nxtcell.lorow);
                 IF nxtcell.lorow = pInfSnip THEN
                    begin
                    (*
                    nxtcell.lorow := minfsnip;
                    GetSnipId(colkind,MMNext,0,curcell.locol,nxtcell.locol);
                    if nxtcell.locol = pinfsnip then
                       begin
                       IF CreatingTable OR RedefiningTable THEN
                          BEGIN
                          {Try to add another column}
                          {GOTO 500;}
                          AddNewCol;
                          END;
                       {Otherwise, current range stays the same}
                       end;
                    *)
                    nxtcell:=curCell;
                    end

                 else
                    begin
                    NxtCell.rkind := a1CellRg;
                    end;
                 END;
             END;
          END;


      MMup:
          BEGIN
          CASE CurCell.rkind of

             a1CellRg:
             (*aRowHedRg:*)
                 BEGIN
                 GetSnipId(rowkind,MMPrior,0,curcell.lorow,nxtcell.lorow);
                 if NxtCell.lorow = MinfSnip then
                    BEGIN
                    IF (Curtable = tcolspecs) then
                       BEGIN
                       {allow going into col headers}
                       Nxtcell.rkind := aColHedRg;
                       END
                    ELSE
                       BEGIN
                       nxtcell.lorow := curcell.lorow;
                       END;
                    END;

                 END;
             aColHedRg:
                 BEGIN
                 {do nothing}
                 nxtcell := Curcell;
                 END;
             END;
          END;


      (*
      MMBegOfCol:
          BEGIN
          Case CurCell.rkind of
             a1CellRg:
                  BEGIN
                  GetSnipId(colkind,MMNext,0,curcell.locol,nxtcell.locol);
                  if NxtCell.locol = PinfSnip then
                     BEGIN
                     IF CreatingTable OR RedefiningTable THEN
                        BEGIN
                        {Try to add another column}
                        {GOTO 500;}
                        AddNewCol;
                        goto 800;
                        END;

                     { no next col, so go to top of current col}
                     nxtcell.locol := curcell.locol;
                     if curtable = tcolspecs then
                        begin
                        nxtcell.lorow := minfsnip;
                        nxtcell.rkind := acolhedrg;
                        end
                     else if curtable <> tlist then
                        begin
                        GetSnipId(rowkind,MMFirst,0,nxtcell.lorow,nxtcell.lorow);
                        end

                     else
                        begin
                        if curtable = tlist then
                           begin
                           savetable(rowband,colband);
                           getsnipid(rowkind,mmfraction,0,rowband.tmbloid,
                                     rowband.tmbloid);
                           {note: this call releases row snips and brings in the
                            row associated with the pct  }

                           rowband.tmbhidep := 0;
                           loadtable(rowband,colband);
                           tmshonewtbl;
                           nxtcell.lorow := rowband.tmbloid;
                           end;
                        end;
                     END; {Locol = PInfSnip}

                  IF (curtable = tColspecs) then
                     BEGIN
                     NxtCell.lorow := mInfSnip;
                     NxtCell.rkind := aColHedRg;
                     END
                  ELSE
                     BEGIN
                     if curtable = tlist then
                        begin
                        savetable(rowband,colband);
                        getsnipid(rowkind,mmfraction,0,rowband.tmbloid,
                                  rowband.tmbloid);
                        {note: this call releases row snips and brings in the
                         row associated with the pct  }

                        rowband.tmbhidep := 0;
                        loadtable(rowband,colband);
                        tmshonewtbl;
                        nxtcell.lorow := rowband.tmbloid;
                        end
                     ELSE GetSnipId(rowkind,MMFirst,0,nxtcell.lorow,nxtcell.lorow);
                     END;
                  END;

             aColHedRg:
                  BEGIN
                  GetSnipId(colkind,MMNext,0,curcell.locol,nxtcell.locol);
                  if NxtCell.locol = PinfSnip then
                     BEGIN
                     IF CreatingTable OR RedefiningTable THEN
                        BEGIN
                        {Try to add another column}
                        {GOTO 500;}
                        AddNewCol;
                        GOTO 800;
                        END;

                     nxtcell.locol := curcell.locol;
                     if curtable = tlist then
                        begin
                        savetable(rowband,colband);
                        getsnipid(rowkind,mmfraction,0,rowband.tmbloid,
                                  rowband.tmbloid);
                        {note: this call releases row snips and brings in the
                         row associated with the pct  }

                        rowband.tmbhidep := 0;
                        loadtable(rowband,colband);
                        tmshonewtbl;
                        nxtcell.lorow := rowband.tmbloid;
                        end
                     ELSE GetSnipId(rowkind,MMFirst,0,nxtcell.lorow,nxtcell.lorow);
                     nxtcell.rkind := a1cellRg;
                     END; {Locol = PInfSnip}
                  END;

             aRowHedRg:
                  BEGIN
                  {go to first data cell}
                  if mmtrap1 then writeln('***begofcol from arowhed');
                  END;

             END;
         END;
         *)
      END; {Case}
800:
   NxtCell.hirow := NxtCell.lorow;
   NxtCell.hicol := NxtCell.locol;

   {$IFC tedebug}
   IF Trace2MMGR then prntRg('nxtCell',nxtCell);
   {$ENDC }

   999: END;


{$S lmopendoc }
PROCEDURE OpenDocument{FileNamePtr: ptrpathname;
                       Action: DocActionType;
                       VAR Status: INTEGER};

   LABEL 400,450,460,475,500,550,600,700,750,800,900,950,975;

   CONST OD = ' OpenDocument ';
         Timing = TRUE;

   VAR FormId: IdType;
       FormPtr: PtrData;
       FormSize: INTEGER;
       FieldIndex: INTEGER;
       FieldPtr: ptrDBField;
       ColSize: INTEGER;
       ColId: IdType;
       HandlePtr: TH;
       LStatus: INTEGER;
       LStatus2: INTEGER;
       SetSize: INTEGER;
       ClosedNormal: BOOLEAN;
       SegName: PathName;
       MMSegPtr: LONGINT;
       Manip: MSet;
       SusPName: PathName;
       NewFileName: PathName;
       FileEName: E_Name;
       SuspendInfo: FS_Info;
       NewFile: BOOLEAN;
       Recovering: BOOLEAN;
       DBScanID: INTEGER;
       VersionPtr: PtrData;
       ErrStatus: INTEGER;
       edchk: ecstr;
       ecptr: ^ecstr;
       fsize: integer;
       i : integer;
       j : integer;
       dataptr : ptrdata;
       oldptr : ptrdata;
       datasize : integer;
       ecsize : integer;
       newsnipsize : integer;
       waitalrtup : boolean;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

   IF TraceMMGR then WriteLn(MxMgr,OD);
   Status := 0;
   Convert := FALSE;
   CvtEditChk := FALSE;
   Recovering := FALSE;
   FilePName := FileNamePtr^;
   waitalrtup := FALSE;

   {If document is to be recovered, this is the first step, since all of the
   files must be closed, and some will be destroyed and recreated.}
   IF Action = MMRecover THEN
400:  BEGIN
      {Put up wait alert}
      If Convert then WaitAlert(LMAlerts,ConvWait)
      else WaitAlert(LMAlerts,RecWait);
      waitalrtup := TRUE;

      {Call the recovery procedure}
      RecoverList(FilePName,LStatus);
      IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn('***',OD,'RecoverList status: ',LStatus);

      {Now check status from recovery}
      IF LStatus <> 0 THEN
         BEGIN
         {Put up message that recovery failed}
         if convert then
           begin
           if CautionAlert(LMAlerts,ConvUnsuccessful) then;
           Status := MMCvtErr;
           end
         else
           begin
           if CautionAlert(LMAlerts,RecUnsuccessful) then;
           Status := MMBadData;
           end;
         Exit(OpenDocument);
         END;

      IF Convert THEN
        BEGIN
        Convert := FALSE;
        SchemaChanged := TRUE;
        END
      ELSE
       BEGIN
       EndWaitAlert;   {Take down wait alert}
       WaitAlrtUp := FALSE;
       END;
      END;

   {Create snip zone data segment. Snip segment is created under the same prefix as the
   document. Its space can be traded off to the suspend file when suspending. This is
   a private segment which will disappear when it is closed or when the process quits.}
   SegName := ConCat(FilePName,HeapSuffix);
   SegDiscSize := 512 * InitSegPages;
   SegMemSize := 512 * InitMemPages;
   IF MMTrap1 THEN IF Timing THEN Write('2');
   Sched_Class(ErrStatus,FALSE);
   make_dataseg(LStatus,segname,SegMemSize,SegDiscSize,SegRefNum,mmsegptr,SnipLDSN,DS_Private);
   Sched_Class(ErrStatus,TRUE);
   IF LStatus <> 0 THEN
      BEGIN
      {At this time there is no documentation for errors returned from this
      procedure. So assume it is because there was not enough disc space to
      create the data segment, since this is the most likely failure.}
      IF MMTrap1 THEN WriteLn(Bell,'***',OD,'Make_DataSeg status: ',LStatus);
      Status := MMNoDisc;
      GOTO 975;
      END;
   SegPtr := POINTER(mmsegptr);


   {Initialize all variables which must be initialized before a new file.
   This call must be made after the data segment has been created, because it
   initializes the heap zone.}
   IF MMTrap1 THEN IF Timing THEN Write('3');
   MMInitFiles;

   {Open the suspend file. This file is kept open until the document is
   either closed or suspended. It is used to keep spare disc space. It is
   also used to write suspend information to in such an event}
   Manip := [DRead,DWrite];
   SusPName := ConCat(FilePName,SuspendSuffix);
   NewFile := FALSE;
   IF MMTrap1 THEN IF Timing THEN Write('5');

450:
   Sched_Class(ErrStatus,FALSE);
   Open_Secure(LStatus,SusPName,SuspRefNum,Manip,DocPassWord);
  {Open(LStatus,SusPName,SuspRefNum,Manip);}
   Sched_Class(ErrStatus,TRUE);
   IF MMTrap1 THEN IF (LStatus <> 0) THEN WriteLn('***',OD,'Suspend Open status: ',LStatus);
   IF (LStatus <> 0) and (LStatus <> -1293) THEN
      BEGIN
      {If the file is open, close it, because we don't need no stinkin' corrupted files}
      IF (LStatus < 0) THEN
         BEGIN
         {Don't use the same status, since we want to still use it.}
         Close_Object(LStatus2,SuspRefNum);
         IF MMTrap1 THEN IF LStatus2 <> 0 THEN WriteLn(Bell,'***',OD,'Suspend Close_Object status: ',LStatus2);
         END;

      IF LStatus = 1294 then    {wrong password}
        begin
        IF MMTrap1 THEN WriteLn(Bell,'***',OD,'Open bad password');
        status := MMBadPassWd;
        goto 950;
        end;

      IF LStatus = 948 THEN {Non existant file}
460:     BEGIN
         Make_Secure(LStatus,SusPName,DocPassWord);
        {Make_File(LStatus,SusPName,0);}
         IF MMTrap1 THEN
           BEGIN
           IF (LStatus <> 0) THEN WriteLn(Bell,'***',OD,'Suspend Make_File status: ',LStatus);
           END;
         IF (LStatus <> 0) THEN
            BEGIN
            {The following errors are related to a lack of disc space on volume}
            IF (LStatus = 855) OR (LStatus = 854) THEN Status := MMNoDisc
            ELSE Status := MMIntErr;   {All other errors are regarded as internal errors}

            GOTO 950; {Close dataseg and exit}
            END;

         {Loop back up and open}
         NewFile := TRUE;
         GOTO 450;
         END;

      IF MMTrap1 THEN WriteLn(Bell);
      {The following errors are due to running out of memory for file structures}
      IF (LStatus = 872) OR (LStatus = 947) THEN
         BEGIN
         Status := MMNoMem;
         GOTO 950;
         END;

      {If this is a new file, any other errors either indicate that an internal
      error occured, or that there is some inconsistency in the file system.}
      IF NewFile THEN
         BEGIN
         IF LStatus = 871 THEN Status := MMBadData   {Problem with file system consistency}

         {All other error regarded as internal errors}
         ELSE Status := MMIntErr;

         GOTO 950;
         END;


475:  {Since it is an old file, all other errors are either internal problems,
      or errors which indicate the system crashed and the file was not closed
      properly, or that the file was scavenged. In all of these cases, just
      kill the file and recreate it. Any suspend info will be lost, if there
      is any.}
      Kill_Secure(LStatus,SusPName,DocPassWord);
     {Kill_Object(LStatus,SusPName);}
      IF MMTrap1 THEN IF LStatus > 0 THEN WriteLn(Bell,'***',OD,'Suspendfile Kill_Object status: ',LStatus);
      IF (LStatus > 0) THEN
         BEGIN {Give up}
         IF LStatus = 1294 then    {wrong password}
           begin
           IF MMTrap1 THEN WriteLn(Bell,'***',OD,'Kill bad password');
           status := MMBadPassWd;
           end
         else Status := MMIntErr;
         GOTO 950;
         END;

      {Loop back and create file}
      GOTO 460;
      END;


   {Determine how much disc has been allocated to the suspend file}
   IF MMTrap1 THEN IF Timing THEN Write('6');
   Info(LStatus,SuspRefNum,SuspendInfo);
   IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn(Bell,'***',OD,'Suspend Info status: ',LStatus);
   IF LStatus <> 0 THEN
      BEGIN
      IF NewFile THEN
         BEGIN {All errors regarded as internal or bad file system}
         IF LStatus = 1190 THEN Status := MMBadData

         {Internal error}
         ELSE Status := MMIntError;

         GOTO 900; {Close file and dataseg}
         END; {NewFile}

      {Since this is an old file, destroy it and start over}
      GOTO 475;
      END;


   SuspFreeBytes := SuspendInfo.PSize;

   {Make sure the suspend file contains a minimum amount of space to
   guarantee posting. A quick check is made to see if it is necessary to call
   the procedure EnoughDisc, because it is located in the 'lmlist' segment which
   has to be swapped in. This, I believe, is the only place where this procedure
   is called from a segment outside of lmlist.}
   IF ((SuspFreeBytes + 511) DIV 512) < MinFreePages THEN
      BEGIN
      IF MMTrap1 THEN IF Timing THEN Write('7');
      Sched_Class(ErrStatus,FALSE);
      IF NOT EnoughDisc(0) THEN
         BEGIN
         Sched_Class(ErrStatus,TRUE);
         {All failures to get enough disc, regardless of whether it may be
         an internal problem or some other problem which has nothing to do
         with disc space, are reported as not able to get disc space.}
         Status := MMNoDisc;
         GOTO 900;
         END;
      Sched_Class(ErrStatus,TRUE);
      END;

   {If we are creating, then load up the necessary structures and exit}
   IF Action = MMCreate THEN
500:  BEGIN
      {Make sure data segment is large enough.}
      IF NOT EnoughMemory(BlankCols,MMFontinfo.CellHeight) THEN
         BEGIN
         {All failures to get enough memory, regardless of whether it may be
         an internal problem or some other problem which has nothing to do
         with memory, are reported as not able to get disc space. This is
         because the most likely cause of the failure is not being able to
         get enough disc space to expand the data segment. Presumably, the
         smallest machine will have enough memory for the worst case list.}
         Status := MMNoDisc;
         GOTO 900;
         END;

      {Modify the global table information to correspond to the create table.}
      CurTable := TList;
      CreatingTable := TRUE;
      with ListHeader do        {to fix open/put away/open blank doc bug 7/25/83}
        begin
        RecSize := BlankCols * 4;
        Version := ListVersion;
        MarketCode := ToolMarketCode;
        end;
      TableChars := ListChars;
      TableData := ListTable;

      {Initialize the column snip structures}
      FOR I := 1 TO BlankCols DO
         BEGIN
         {Create a default list column}
         NewListCol(ColId,I);

         {Link this snip into the end of the list of column snips}
         WITH TableData DO
            BEGIN
            InsertColSnips(FirstCol,LastCol,LastCol,ColId,ColId);
            ColCount := ColCount + 1;
            END;
         END; {For Loop}

      {Switch list into background}
      SwitchFromList;
      GOTO 700; {exit}
      END;



   {Resume the document if it was suspended. The current thinking is that
   you resume if the file was suspended, even if you get an Open action.}
   IF (Action = MMResume) OR (Action = MMOpen) THEN
      BEGIN
      {See if the file was suspended}
      IF MMTrap1 THEN IF Timing THEN Write('8');
      Sched_Class(ErrStatus,FALSE);
      IF FileSuspended(FilePName,LStatus) THEN
         BEGIN
         Sched_Class(ErrStatus,TRUE);
         DocSuspended := TRUE;
         GOTO 700; {exit}
         END;
      Sched_Class(ErrStatus,TRUE);

      {Check status from filesuspended. Currently the only cause of an error
      from filesuspended is if you got a failure from trying to expand the
      datasegment. Since this is probably a failure to get disc, return this
      as the cause. All other failures from this procedure are covered up
      and we pretend that the file was not suspended.}
      IF LStatus <> 0 THEN
        BEGIN
        IF LStatus = MMNeedToCvt THEN Status := MMNeedToCvt
        ELSE Status := MMNoDisc;
        GOTO 900; {Close suspend file and dataseg and exit}
        END;

      END;


550: {Open a scan on the file}
   IF MMTrap1 THEN IF Timing THEN Write('9');
   Sched_Class(ErrStatus,FALSE);
   OpenScan(LStatus,@FilePName,@FilePName,DBScanId,LabelUpdate);

   Sched_Class(ErrStatus,TRUE);
   IF MMTrap1 THEN IF (LStatus <> 0) AND (LStatus <> 948) THEN WriteLn(Bell,'***',OD,'File ',FilePName,
                       ' OpenScan status: ',LStatus);
   IF LStatus <> NoErr THEN
      BEGIN
      CASE LStatus OF
         {File missing codes.}
         NotFound,
         {Open} 948:
            BEGIN {See if there is a $New file. If so, it means the system
            crashed during a restructure or recovery. Rename the file}

            {Figure out the entry name for the old file, to use in call to Rename_Entry}
            FileEName := FilePName;
            FOR I := Length(FileEName) DOWNTO 1 DO
               BEGIN
               IF FileEName[I] = '-' THEN
                  BEGIN
                  Delete(FileEName,1,I);
                  I := 0;
                  END;
               END;

            {Rename the new file to the old name}
            NewFileName := Concat(FilePName,NewSuffix);
            IF TraceMMgr THEN Writeln('Renaming new file: ',NewFileName,' to ',FileEName);
            Rename_Secure(LStatus,NewFileName,FileEName,DocPassWord);
           {Rename_Entry(LStatus,NewFileName,FileEName);}
            IF LStatus <= 0 THEN GOTO 550 {Successful rename, try to reopen}
            ELSE GOTO 500; {Load up create table}
            END;

         {The following errors are considered to be internal errors}
         {Info} 974,
         {Open} 873,951,946,949,950,
         {Lookup} 971,972,
         {OpenScan} NoBuffs:
            BEGIN
            Status := MMIntErr;
            GOTO 900;
            END;

         {Errors relating to available memory}
         {Open} 872,947,
         {OpenScan} NoMem:
            BEGIN
            Status := MMNoMem;
            GOTO 900;
            END;

         {Error relating to a newer document opened by older, incompatible software}
         DBVersionMisMatch:
            BEGIN
            GOTO 750;
            END;

          DBTooOld:
            BEGIN
            Status := MMTooOldDoc;
            goto 900;
            END;

          DBTooNew:
            BEGIN
            Status := MMTooNewDoc;
            goto 900;
            END;
         END; {Case}

      {All other errors which are documented at this point are related to
      corrupted data. Therefore, for these we will attempt recovery. For those
      errors which are undocumented, these will also cause recovery. Better to
      attempt a recovery on some unknown errors than not to do a recovery when
      it is necessary.}

      {Set flag to cause recovery}
      Recovering := TRUE;
      GOTO 900;
      END; {LStatus <> 0}



   {At this point, a scan has been successfully opened on the data file}

   {Read in the header record}
   IF MMTrap1 THEN IF Timing THEN Write('0');
   Sched_Class(ErrStatus,FALSE);
   Get_Header(LStatus,DBScanId,ListHeader);
   Sched_Class(ErrStatus,TRUE);
   IF LStatus <> NoErr THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***',OD,'Get_Header status: ',LStatus);
      CASE LStatus OF
         {The following errors are related to corrupt data. In the case of
         IOErr and Inconsistent, these are recoverable errors, so try to recover.
         In the case of NotFound, since there is no schema, something
         is really broken. However, if there is a redundant file around, there
         is a chance for recovery. So try it.}
         IOErr,Inconsistent,NotFound: Recovering := TRUE;

         {All other errors (NoMem,BadScanId,NoBuffs) indicate some kind of
         internal error, since there should be enough memory at this point.}
         OTHERWISE Status := MMIntErr;
         END; {Case}

      GOTO 800;
      END; {LStatus <> 0}

   {Now that the header is in, check the user-specified version number to make sure this version
   of the software is compatible with the DB Form and List Form structures. If not, refuse to open.}

   VersionPtr := @ListHeader.Version;
   IF VersionPtr^[1] > ListVersion THEN {Only use rightmost byte}
     BEGIN
     IF MMTrap1 THEN WriteLn(Bell,OD,'Version incompatibility: ',ListHeader.Version,ListVersion);
     Status := MMTooNewDoc;
     goto 800;
     END;

   {Make sure that the market code of the document matches that of the tool }
   IF (ListHeader.MarketCode <> ToolMarketCode) and NOT(CvtEditChk) THEN
     BEGIN
     IF MMTrap1 THEN WriteLn(Bell,OD,'Marketcode incompatibility: ',ListHeader.MarketCode,ToolMarketCode);
     IF ListHeader. MarketCode = MCodeNil then  {Chris converted DB coalating sequence}
       BEGIN
       VersionPtr^[1] := ListVersion;
       CvtEditChk := TRUE;
       END
     ELSE
       BEGIN
       Status := MMNeedToCvt;
       IF (askalert(LMALERTS, CvtMktCode) = 1 ) THEN GOTO 800     {if doesn't want conversion, leave}
       ELSE IF (askalert(LMAlerts,ConvBackup) = 1) THEN GOTO 800
           ELSE BEGIN
                Status := 0;  {if wants conversion, clear status and go on}
                CvtEditChk := TRUE;
                END;
       END;
     END;


   {Make sure there is enough memory available to work on this list}
   IF MMTrap1 THEN IF Timing THEN Write('1');
   Sched_Class(ErrStatus,FALSE);
   IF NOT EnoughMemory(ListHeader.NFields,MMFontinfo.CellHeight) THEN
      BEGIN
      Sched_Class(ErrStatus,TRUE);
      {All errors mascarade as failure to get disc space to expand data segment}
      Status := MMNoDisc;
      GOTO 800;
      END;
   Sched_Class(ErrStatus,TRUE);

   {Get the total size of the form in bytes}
   FormSize := ListHeader.Space;

   {Allocate space for the form and set pointer to it}
   GetSnipBlock(FormId,FormSize,LStatus);
   InitSnipPtr(ColKind,FormId);
   FormPtr := @ColSnip^;

   {Now read the form into the space for it}
   IF MMTrap1 THEN IF Timing THEN Write('2');
   Sched_Class(ErrStatus,FALSE);
   GetForm(LStatus,DBScanId,FormPtr);
   Sched_Class(ErrStatus,TRUE);
   IF LStatus <> NoErr THEN
      BEGIN
      {The following errors are related to corrupt data. In the case of
      IOErr and Inconsistent, these are recoverable errors, so try to recover.}
      IF (LStatus = IOErr) OR (LStatus = Inconsistent) THEN Recovering := TRUE

      {All other errors (NoMem,BadScanId,NoBuffs,Notfound) indicate some kind of
      internal error, since there should be enough memory at this point.
      There is no reason why the form should not be found, since it was
      found in the previous call to Get_Header}
      ELSE Status := MMIntError;

      GOTO 800;
      END;


   {Initialize the table information}
   IF MMTrap1 THEN IF Timing THEN Write('3');
   InitTabRecords;
   CurTable := TList;
   CreatingTable := FALSE;

   if CvtEditChk and not WaitAlrtUp then
     begin
     WaitAlert(LMAlerts,CvtWait);
     WaitAlrtUp := TRUE;
     end;

   {For each field, determine the size of the snip block required, allocate
   a block, and then load the data into the block.}
   FieldIndex := 0;
   i := 1;
   while i <= listheader.nfields do
      BEGIN
      {First determine the ultimate size of the column snip record}
      FieldPtr := @FormPtr^[FieldIndex];
      ColSize := SIZEOF(ColSnipRecord)
                 + (FieldPtr^.FldSize - SIZEOF(DBField))
                 + ColExpansion;

      {Allocate a snip block}
      GetSnipBlock(ColId,ColSize,LStatus);

      {Reset pointers to form in case the form moved after GetSnipBlock}
      InitSnipPtr(ColKind,FormId);
      FormPtr := @ColSnip^;
      FieldPtr := @FormPtr^[FieldIndex];

      {Set up pointers to the new block}
      InitSnipPtr(ColKind,ColId);

      {Initialize first portion of column snip record}
      WITH ColSnip^ DO
         BEGIN
         RecSize := ColSize;
         SnipId := ColId;
         SnipType := ColKind;
         NextSnip := NullSnip;
         PriorSnip := TableData.LastCol;
         ListSnip := NullSnip;
         Order := I;
         Width := ColWidth;
         NewColumn := FALSE;
         FieldNum := I - 1;
         SortOrder := 0;
         SortDirection := 0;
         FreeBytes := ColExpansion;
         {Load in contents of field record}
         MoveLeft(FieldPtr^,FieldInfo,FieldPtr^.FldSize);
         END;

      {Call Larry's and Chris' routines here to convert edit checks and check reptype}
      if CvtEditChk then
        begin

        CvtEdChk(formid,fieldindex,colid,errstatus);
        if errstatus <> 0 then
          begin
          status := MMCvtErr;
          goto 800;
          end;
        end;

      {Reset pointers to form in case the form moved after CvtEdChk}
      InitSnipPtr(ColKind,FormId);
      FormPtr := @ColSnip^;
      FieldPtr := @FormPtr^[FieldIndex];

      {Set up pointers to the new block}
      InitSnipPtr(ColKind,ColId);

      with ColSnip^ do
         BEGIN

         IF MMTrap1 THEN WITH FieldInfo DO
            BEGIN
            IF ((Name<>FNilVal) AND Odd(Name))
            OR ((Display<>FNilVal) AND Odd(Display))
            OR ((Name > Display) AND (Display <> FNilVal))
            THEN  WriteLn(Bell,'***',OD,'Invalid offsets in DBField record: ',FieldNum,Name,Display);
            END;

         {If this is the ticket field, make it invisible.}
         IF (I=2) AND (FieldInfo.FldType = Tick)
         THEN Visible := FALSE ELSE Visible := TRUE;
         IF Trace2MMgr THEN
            BEGIN
            {$IFC MMDEBUG }
            DumpField(@FieldInfo);
            {$ENDC }
            END;
         END;

      {Link this snip into the end of the column snips}
      WITH TableData DO
         BEGIN
         InsertColSnips(FirstCol,LastCol,LastCol,ColId,ColId);
         ColCount := ColCount + 1;
         END;

      {Count to next field in form}
      FieldIndex := FieldIndex + FieldPtr^.FldSize;
      i := i+1;

      END;

   if CvtEditChk then
     begin
     {Take down wait alert}
     EndWaitAlert;
     WaitAlrtup := FALSE;
     {After edit check conversion, change the doc marketcode to that of tool; set change flag}
     ListHeader.Version := ListVersion;
     ListHeader.MarketCode := ToolMarketCode;
     SchemaChanged := TRUE;
     CvtEditChk := FALSE;
     end;

   {Now release the form space}
   FreSnipBlock(FormId);

   {Now read the list manager specific information which is stored in the
   data file labels into memory, and make the necessary changes to the snip
   data structures.}
   IF MMTrap1 THEN IF Timing THEN Write('5');
   ListFormChanged := FALSE;
   Sched_Class(ErrStatus,FALSE);
   ReadListForm(DBScanId,FormId,LStatus);
   Sched_Class(ErrStatus,TRUE);
   IF FormId <> NullSnip THEN
      BEGIN
      MakeListFormChanges(FormId);

      {Check the memory requirements again, since the font may have changed}
      IF MMTrap1 THEN IF Timing THEN Write('6');
      Sched_Class(ErrStatus,FALSE);
      IF NOT EnoughMemory(ListHeader.NFields,MMFontinfo.CellHeight) THEN
         BEGIN
         Sched_Class(ErrStatus,TRUE);
         {All errors mascarade as failure to get disc space to expand dataseg}
         Status := MMNoDisc;
         GOTO 800;
         END;
      Sched_Class(ErrStatus,TRUE);
      END;

   {Create the differential file}
   IF MMTrap1 THEN IF Timing THEN Write('7');
   {Name the differential file and other necessary files}
   DiffPName := ConCat(FilePName,DiffSuffix);

   {The following files are needed by DiffOpen}
   Temp1PName := ConCat(FilePName,Temp1Suffix);
   Temp2PName := ConCat(FilePName,Temp2Suffix);

   {Create the differential file}
   setsize := ((TableData.colcount + 15) div 16) * 2;
   WITH TableData DO SetSet(@NullNA,ColCount,ColCount);
   IF Trace2MMgr then WriteLn(MxMgr,OD,'Calling DiffCreate...');
   Sched_Class(ErrStatus,FALSE);
   DiffCreate(LStatus,ScanId,ClosedNormal,DocPassWord,@FilePName,@DiffPName,@NullNA,setsize);
   Sched_Class(ErrStatus,TRUE);
   IF Trace2MMgr then WriteLn(MxMgr,OD,'Return from DiffCreate...');
   IF (LStatus <> NoErr) THEN
      BEGIN
      {All errors at this level are consisdered to be the result of corrupted
      data. The strategy will be to destroy the file and start over. In the
      event that the file is being created for the first time, it will not
      hurt to try again. Errors will be handled more specifically the next
      attempt.}
      IF MMTrap1 THEN WriteLn('***DiffCreate status: ',LStatus);

600:  {Destroy the differential file}
      Kill_Secure(LStatus,DiffPName,DocPassWord);
     {Kill_object(LStatus,DiffPName);}
      {Dont check status, because the file may not be there}

      {Now try to create again}
      DiffCreate(LStatus,ScanId,ClosedNormal,DocPassWord,@FilePName,@DiffPName,@NullNA,setsize);
      IF LStatus <> NoErr THEN
         BEGIN
         CASE LStatus OF
            {The following are errors caused by a lack of disc space}
            NoRoom,
            {Make_File} 854,855: Status := MMNoDisc;

            {The next set of errors are due to corrupted data}
            IOErr,Inconsistent,
            {Open} 871,
            {Lookup,Make_File,Close_Object} 835,848,849,
            {Info} 1190,
            {Make_File,Close_Object} 802,
            {Close_Object} 610: Status := MMBadData;

            OTHERWISE
               BEGIN
               {600 range is inconsistent file system}
               IF (LStatus >= 600) AND (LStatus <= 699) THEN Status := MMBadData
               {All other errors are considered to be internal}
               ELSE Status := MMIntError;
               END;
            END; {Case}

         GOTO 800;
         END;
      END;


   {If the file has unposted updates, then it means that this is a file
   which was suspended and is now being opened normally. It could also mean
   that there was a crash of some kind. In this case, we want to post any changes}
   IF NOT ClosedNormal THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***Posting unposted updates in diff file...');
      DiffClose(LStatus,ScanId,TRUE); {Post close}
      IF LStatus <> 0 THEN
         BEGIN
         IF MMTrap1 THEN WriteLn('***DiffClose status: ',LStatus);
         {For now, due to schedule constraints, any errors during the
         posting will cause those records or updates which failed to
         be discarded. Eventually, you would want to notify the user and
         allow him to make corrections.}
         DiffClose(LStatus,ScanId,FALSE); {NoPost close}
         IF LStatus <> 0 THEN
            BEGIN
            {In the case that there is a problem doing a nopost close, kill
            the diff file and start over. This code cannot loop because the
            next time down, ClosedNormal will be true.}
            IF MMTrap1 THEN WriteLn('***DiffClose status: ',LStatus);
            DiffDestroy(LStatus,ScanId);
            {Do not check status - go and try to recreate a good new diff file}
            IF MMTrap1 THEN IF LStatus <> 0 THEN WRiteLn('***DiffDestroy status: ',LStatus);
            GOTO 600; {Kill diff file and open a new one}
            END;
         END;
      END;

   {Close the scan on the data file}
   IF MMTrap1 THEN IF Timing THEN WRite('8');
   CloseScan(LStatus,DBScanId);
   IF MMTrap1 THEN IF LStatus <> NoErr THEN WriteLn(Bell,'***',OD,'CloseScan status: ',LStatus);
   {Failure to close scan will not prevent document to be accessed.}

   {Switch list into background}
   SwitchFromList;

700: IF MMTrap1 THEN IF Timing THEN Write('9');
   IF WaitAlrtUp THEN
     BEGIN
     EndWaitAlert;
     WaitAlrtUp := FALSE;
     END;
   Exit(OpenDocument);

750: {Version incompatibility}
   IF not Convert THEN
     BEGIN
     Status := MMNeedToCvt;
     IF(askalert(LMALERTS, ConvertFile) <> 1) THEN
       IF (askalert(LMALERTS,ConvBackup) <> 1) THEN
         BEGIN
         Status := 0;
         Convert := TRUE;
         END;
     END;

800: {Error cleanup - don't report errors}
   {Close the scan on the data file}
   CloseScan(LStatus,DBScanId);
   IF MMTrap1 THEN IF LStatus <> NoErr THEN WriteLn('***CloseScan status: ',LStatus);

900: {Close the suspend file}
   Close_Object(LStatus,SuspRefNum);
   IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn('***Close_Object status: ',LStatus);

950: {Close the data seg - this will delete it.}
   Close_DataSeg(LStatus,SegRefNum);
   IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn('***Close_DataSeg status: ',LStatus);

975: {If a recovery is to be attempted, go to the recovery code}
   IF Recovering THEN
      BEGIN
      {Tell user about problem and ask for recovery}
      IF (askalert(LMAlerts,RecBadFile)  = 1) THEN
         BEGIN
         Status := MMBadData;
         Exit(OpenDocument);
         END;

      {Make sure user has backup copy}
      IF (askalert(LMAlerts,RecBackup) = 1) THEN
         BEGIN
         Status := MMBadData;
         Exit(OpenDocument);
         END;

      Recovering := FALSE; {Set false so that we don't recover ad infinitum}
      Status := 0;
      GOTO 400; {Loop back to the top and start recovery}
      END;

 {Conversion needed}
  IF Convert THEN
    BEGIN
    Status := 0;
    GOTO 400;
    END;

   IF WaitAlrtUp THEN
     BEGIN
     EndWaitAlert;
     WaitAlrtUp := FALSE;
     END;

  {Here is where alerts are displayed depending on the error encountered}
  IF (Status <> 0) THEN
      BEGIN
      CASE Status OF
         MMBadData: LStatus := FileErr;
         MMNoDisc: LStatus := DiscOpenErr;
         MMNoMem: LStatus := MemOpenErr;
         MMIntErr: LStatus := IntErr;
         MMTooNewDoc: LStatus := TooNewErr;
         MMTooOldDoc: LStatus := TooOldErr;
         MMNeedToCvt: LStatus := NeedCvtErr;
         MMCvtErr: LStatus := ConvUnsuccessful;
         OTHERWISE LStatus := IntErr;
         END;
      if status = mmcvterr then status := mmbaddata;
      IF (LStatus <> DiscOpenErr) and (Status <> MMBadPassWd) THEN
        IF CautionAlert(LMAlerts,LStatus) THEN;
      END;

   END;



{$S lmcolspec }
PROCEDURE PackCSCol{Column: IdType};

   CONST PCSC = ' PackCSCol';

   VAR Data: ARRAY[0..EcStrBnd] OF Byte;
       Len: INTEGER;
       ListCol: IdType;
       Status: INTEGER;
       BytePtr1: PtrData;
       BytePtr2: PtrData;

       {The following variables are used to hold information about the list
       column and are used to generate the cell values for data type, edit check,
       and visibility.}
       DType: INTEGER;
       Edit: ECStr;
       Vis: BOOLEAN;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,PCSC);

   SetSnipPtr(ColKind,Column);
   ListCol := ColSnip^.ListSnip;

   {If the list column is null, then use defaults}
   IF ListCol = NullSnip THEN
      BEGIN
      DType := Lets;
      Edit := '';
      Vis := TRUE;
      END

   ELSE BEGIN {ListCol <> NullSnip}
        {Get the necessary information out of the list column snip}
        SetSnipPtr(ColKind,ListCol);
        WITH ColSnip^ DO
           BEGIN
           {get out data type}
           DType := FieldInfo.FldType;

           {Get out edit check string}
           IF FieldInfo.Display = FNilVal THEN Edit := ''
           ELSE BEGIN
                BytePtr1 := POINTER(ORD(@ColSnip^.FieldInfo) + FieldInfo.Display);
                Len := BytePtr1^[0] + 1;
                BytePtr2 := @Edit;
                MoveLeft(BytePtr1^,BytePtr2^,Len);
                END;

           {Get out visibility}
           Vis := Visible;
           END;
        END; {ListCol <> NullSnip}


   {************* First generate the data type *********************}
   {Generate the appropriate text for the data type}
   GenDataType(DType,@Data,Len);

   {Now put the text string into the row snip record}
   PackField(TypeRow,Column,@Data,NIL,Len,Status);
   IF MMTrap1 THEN IF Status <> 0 THEN MMFatalErr(Status,PCSC,'PackField');


   {************ Now generate the edit check ***********************}
   GenEdit(@Edit,@Data,Len);

   PackField(EditCRow,Column,@Data,NIL,Len,Status);
   IF MMTrap1 THEN IF Status <> 0 THEN MMFatalErr(Status,PCSC,'PackField');

   {Only put in the other information if the list
   is not either being created or redefined.}
   IF NOT (CreatingTable OR RedefiningTable) THEN
      BEGIN
      {************* Now generate the sort order ***********************}
      {Set up pointers to the spec table column snip to get the sort info.}
      SetSnipPtr(ColKind,Column);

      {generate the sort string}
      WITH ColSnip^ DO
         BEGIN
         GenSort(SortOrder,SortDirection,NullSnip,@Data,Len);
         END;

      {Put the text string into the row snip record}
      PackField(SortRow,Column,@Data,NIL,Len,Status);
      IF MMTrap1 THEN IF Status <> 0 THEN MMFatalErr(Status,PCSC,'PackField');


      {*********** Now generate the visibility indication *************}
      GenVisible(Vis,@Data,Len);

      {Put the text string into the row snip record}
      IF Len > 0 THEN
         BEGIN
         PackField(VisibleRow,Column,@Data,NIL,Len,Status);
         IF MMTrap1 THEN IF Status <> 0 THEN MMFatalErr(Status,PCSC,'PackField');
         END;
      END;
   END;






{$S lmres }
PROCEDURE PackField {RowId:  IdType;
                     ColId:  IdType;
                     val:  PtrData;
                     hval: HndData;
                     VAR Length:  INTEGER
                     VAR STatus : integer};

   LABEL 999;

   VAR vfield : ptrvfld;
        dbf : ptrdbField;
        len : integer;
        delta : integer;
        rsize : integer;
        errnum : INTEGER;
        DeltaSize: INTEGER;
        DataPtr: PtrData;
        RSizeAvail: INTEGER;
        I: INTEGER;
        LStatus: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,' PackField ');
   IF Trace2MMgr THEN IF Hval = NIL THEN FOR I :=  0 TO Length DO
      BEGIN
      Write(Val^[I]:4);
      WriteLn('Inside PackField');
      END;

   {Set up pointers to stuff}
   setSnipPtr(rowkind,RowId);
   setSnipPtr(colKind,ColId);
   dbf:= @colsnip^.fieldinfo;

   {Check to insure data is legal with respect to edit check}
   if Hval = NIL then Legal(dbf,val,length,errnum) else Legal(dbf,Hval^,length,errnum);
   IF errnum <> 0 THEN
      BEGIN
      Status := ErrNum + CVTErr;
      GOTO 999;
      END;

   IF Trace2MMgr THEN IF Hval = NIL THEN FOR I := 0 TO Length DO
      BEGIN
      Write(Val^[I]:4);
      WriteLn('After Legal');
      END;

   If not VarField(colsnip) then
      BEGIN
      rsize := rowsnip^.dbrecsize - sizeOF(preamble);
      {$IFC MMDEBUG }
      IF Trace2MMgr THEN DumpRow(@RowSnip^);
      {$ENDC}
      if Hval = NIL then pack(0,dbf,val,length,POINTER(ORD(rowsnip)+
                              rowsnip^.data),rsize+rowsnip^.freebytes,rsize,delta,errnum)
                    else pack(2,dbf,Hval^,length,POINTER(ORD(rowsnip)+
                              rowsnip^.data),rsize+rowsnip^.freebytes,rsize,delta,errnum);
      {$IFC MMDEBUG }
      IF Trace2MMgr THEN DumpRow(@RowSnip^);
      {$ENDC }
      IF ErrNum <> 0 THEN
         BEGIN
         Status := ErrNum;
         Exit(PackField);
         END;
      rowsnip^.dbrecsize := rsize + sizeOf(preamble);
      END

   ELSE
      BEGIN
      Vfield := POINTER(ORD(rowsnip) + rowsnip^.data +
               colsnip^.fieldinfo.offset);

      Len := vfield^.size;
      delta := length - len;
      IF Trace2MMGR then
         BEGIN
         Writeln('variable len field - delta:',delta:3);
         writeln('old len: ',len:3,'new len: ',length);
         END;

      {Expand snip size if necessary to add new value}
      IF length > len THEN
         BEGIN
         {save 1 byte to round up to even recsize}
         IF delta  > rowsnip^.freebytes-1 THEN
            BEGIN
            DeltaSize := Delta + RecExpand;
            ExpSnipBlock(rowsnip^.snipId,rowsnip^.recsize + DeltaSize,LStatus);
            IF LStatus <> 0 THEN
               BEGIN {Convert NoRoom or NoMem error into our own codes for displaying messages.}
               IF LStatus = NoRoom THEN Status := ModNoDisc ELSE Status := ModNoMem;
               Exit(PackField);
               END;

            SetSnipPtr(rowkind,rowid);
            WITH RowSnip^ DO
               BEGIN
               Recsize := Recsize + DeltaSize;
               Freebytes :=  FreeBytes + DeltaSize;
               END;

            {Reset pointers which may have changed due to snip expansion}
            setSnipPtr(colKind,ColId);
            dbf:= @colsnip^.fieldinfo;
            Vfield := POINTER(ORD(rowsnip) + rowsnip^.data + colsnip^.fieldinfo.offset);
            END;
         END;


      {Pack value into record}
      RSize := rowsnip^.dbrecsize - sizeOF(preamble);
      DataPtr := POINTER(Ord(RowSnip) + RowSnip^.Data);
      RSizeAvail := RSize + RowSnip^.FreeBytes;
      {If this is a real database record, the max size must be limited to what the intrinsics
      allow. Otherwise, the size is limited to a fairly large value. }
      IF CurTable = TList THEN RSizeAvail := CMin(RSizeAvail,MaxDBRecSize-SizeOf(PreAmble))
      ELSE RSizeAvail := CMin(RSizeAvail,MaxRecSize);

      {$IFC MMDEBUG }
      IF Trace2MMgr THEN
         BEGIN
         DumpField(@dbf^);
         DumpRow(@RowSnip^);
         WriteLn('RSize: ',RSize,' RSizeAvail: ',RSizeAvail,' Length: ',Length);
         Write('Value: ');
         IF Length > 0 THEN IF Hval = NIL THEN FOR I := 0 TO Length DO Write(Val^[I]:4);
         WriteLn;
         END;
      {$ENDC}

      if Hval = NIL then pack(0,dbf,val,length,DataPtr,RSizeAvail,RSize,Delta,ErrNum)
      else pack(2,dbf,Hval^,length,DataPtr,RSizeAvail,RSize,Delta,ErrNum);
      IF errnum <> 0 then
         BEGIN
         Status := ErrNum;
         Exit(PackField);
         END;

      {Update sizes and offsets}
      with rowsnip^ do
        begin
        freebytes := freebytes - delta;
        dbrecsize := rsize + sizeOF(preamble);
        end;
      reCalcOffsets(rowsnip,colId,vfield^.offset,delta);
      status := errnum;

      {$IFC MMDEBUG }
      IF Trace2MMgr THEN DumpRow(@RowSnip^);
      {$ENDC}
      END;
999: END;


(*
{$S lmsearch  }
PROCEDURE PackFldH { RowId:  IdType;
                       ColId:  IdType;
                       val:  HndData;
                       VAR Length:  INTEGER
                       VAR STatus : integer};

   LABEL 999;

   VAR  vfield : ptrvfld;
        dbf : ptrdbField;
        len : integer;
        delta : integer;
        rsize : integer;
        errnum : INTEGER;
        DeltaSize: INTEGER;
        DataPtr: PtrData;
        RSizeAvail: INTEGER;
        LStatus: INTEGER;



   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,'PackFldh');

   {Set up pointers to stuff}
   setSnipPtr(rowkind,RowId);
   setSnipPtr(colKind,ColId);
   dbf:= @colsnip^.fieldinfo;

   {Check to insure data is legal with respect to edit check}
   Legal(dbf,val^,length,errnum);
   IF errnum <> 0 THEN
      BEGIN
      Status := ErrNum + CVTErr;
      GOTO 999;
      END;

   If not VarField(colsnip) then
      BEGIN
      rsize := rowsnip^.dbrecsize - sizeOF(preamble);
      {$IFC MMDEBUG }
      IF MMTrap2 THEN DumpRow(@RowSnip^);
      {$ENDC }
      pack(2,dbf,val^,length,POINTER(ORD(rowsnip)+
        rowsnip^.data),rsize+rowsnip^.freebytes,rsize,delta,errnum);
      {$IFC MMDEBUG }
      IF MMTrap2 THEN DumpRow(@RowSnip^);
      {$ENDC }
      IF ErrNum <> 0 THEN
         BEGIN
         Status := ErrNum;
         Exit(PackFldh);
         END;
      rowsnip^.dbrecsize := rsize + sizeOf(preamble);
      END

   ELSE
      BEGIN
      Vfield := POINTER(ORD(rowsnip) + rowsnip^.data +
               colsnip^.fieldinfo.offset);

      Len := vfield^.size;
      delta := length - len;
      IF Trace2MMGR then
         BEGIN
         Writeln('variable len field - delta:',delta:3);
         writeln('old len: ',len:3,'new len: ',length);
         END;

      {Expand snip size if necessary to add new value}
      IF length > len THEN
         BEGIN
         {save 1 byte to round up to even recsize}
         IF delta  > rowsnip^.freebytes-1 THEN
            BEGIN
            DeltaSize := Delta + RecExpand;
            if trace2mmgr then writeln('deltasize, freebytes, recsize',
                       deltasize:5, rowsnip^.freebytes:5,rowsnip^.recsize:5);
            ExpSnipBlock(rowsnip^.snipId,rowsnip^.recsize + DeltaSize,LStatus);
            SetSnipPtr(rowkind,rowid);
            WITH RowSnip^ DO
               BEGIN
               Recsize := Recsize + DeltaSize;
               Freebytes :=  FreeBytes + DeltaSize;
               END;

            {Reset pointers which may have changed due to snip expansion}
            setSnipPtr(colKind,ColId);
            dbf:= @colsnip^.fieldinfo;
            Vfield := POINTER(ORD(rowsnip) + rowsnip^.data +
                     colsnip^.fieldinfo.offset);
            END;
         END;


      {Pack value into record}
      RSize := rowsnip^.dbrecsize - sizeOF(preamble);
      DataPtr := POINTER(Ord(RowSnip) + RowSnip^.Data);
      RSizeAvail := RSize + RowSnip^.FreeBytes;
      {If this is a database record, must limit the record size to what intrinsics can handle.
      Otherwise, set maximum to a large but reasonable number.}
      IF CurTable = TList THEN RSizeAvail := CMin(RSizeAvail,MaxDBRecSize-SizeOf(PreAmble))
      ELSE RSizeAvail := CMin(RSizeAvail,MaxRecSize);
      pack(2,dbf,val^,length,DataPtr,RSizeAvail,RSize,Delta,ErrNum);
      IF errnum <> 0 then
         BEGIN
         Status := ErrNum;
         if trace2mmgr then writeln('pack in packfldh returns status ',status);
         Exit(PackFldh);
         END;

      {Update sizes and offsets}
      rowsnip^.freebytes := rowsnip^.freebytes - delta;
      rowsnip^.dbrecsize := rsize + sizeOF(preamble);
      reCalcOffsets(rowsnip,colId,vfield^.offset,delta);
      status := errnum;

      END;
999: END;
*)

{$S lmsearch }
Procedure parsesrch {value: ptrdata;
                    length: integer;
                    runptr : ptrruns;
                    numruns : integer;
                    var numstr :integer;
                    var sindex1 :integer;
                    var sindex2 : integer;
                    var len1 : integer;
                    var len2 : integer;
                    var status : integer};

   label 998,999;

   const prssrch = ' ParseSrch';

   VAR  i,j,k :integer;
        ptrd : ptrdata;
        NBThruString : str40;
        action:integer;
        oplen : integer;
        templen : integer;
        runpos : integer;
        fbold : boolean;
        valstr : CompStr;
        valptr : CompStrP;
        thruptr : CompStrP;


   begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if tracemmgr then writeln(MxMgr,prssrch);
   IF Trace2MMgr THEN
      begin
      writeln('runs :',numruns : 3);
      for i := 0 to numruns -1 do
         begin
         write(' ',runPtr^[i].lpfst:3);
         end;
      writeln;
      end;

   {Get THRU string with no blanks}
   NBThruString := copy(ThruString,2,ThruLength-2);
   thruptr := @NBthrustring;

   UpStrShift(thruptr);

   status := 0;
   IF length = 0 then
      begin
      numstr := 1;
      goto 998;
      end;

   if (numruns > 3) or (numruns < 0)  then
      begin
      status := BadSrchOp;
      numstr := 1;
      goto 998;
      end
   else
      begin
      {parse beginnig of string}

      {find beginning of string }
      i := 0;
      while (value^[i] = ORD(' ')) and (i < length) do i := i + 1;
      if i = length then
         begin
         numstr := 1;
         goto 998;
         end;

      templen := length-i;
      fbold := bold in runptr^[0].face;
      getaction(@value^[i],templen ,fbold,action,oplen,status);

      IF MMTrap1 THEN if status <> 0 then mmfatalerr(logicerr,prssrch,'');
      i :=  i + oplen;
      if  (numruns < 3) then
         begin
         {find beginning of string}
         while (value^[i] = ORD(' ')) and (i < length) do i := i + 1;

         {string better not be bold}
         if isbold(numruns,runptr,i,runpos) and (i < length ) then
            begin
            status := badsrchop;
            goto 998;
            end;
         {find end of string}
         j := 0;
         templen := length-i;
         while (value^[length-1-j] = ORD(' ')) and (j < templen) do j := j + 1;

         {return values }
         numstr := 1;
         sindex1 := i;
         len1 := length-i-j;
         sindex2 := 0;
         len2 := 0;
         end
      else if (numruns = 3) then
         begin
         if not (bold in runptr^[1].face )then
            begin
            status := badsrchOp;
            goto 998;
            end
         else
            begin

            if Trace2MMgr then writeln('numruns = 3');
            {find beginning of string1}
            while (value^[i] = ORD(' ')) and (i < length) do i := i + 1;

            {string better not be bold}
            if isbold(numruns,runptr,i,runpos) then
               begin
               status := badsrchop;
               goto 998;
               end;
            if Trace2MMgr  then writeln('finding end of string');
            {find end of string1}
            j := 0;
            while (value^[runptr^[1].lpfst-1-j] = ORD(' ')) and (j <
                   runptr^[1].lpfst) do j := j + 1;
            if (j = runptr^[1].lpfst) then goto 998;


            {set values for 1st string}
            sindex1 := i;
            len1 := runptr^[1].lpfst - i - j;

            if Trace2MMgr  then writeln('looking for thru ');
            {look for thru operator}
            i := runptr^[1].lpfst;
            while (value^[i] = ORD(' ')) and (i <= length) do i := i + 1;
            if i = length then goto 998;

            valptr := @valstr;
            ptrd := @valstr;
            moveleft(value^[i],ptrd^[1],thrulength-2);
            ptrd^[0] := thrulength-2;

            if CompStrMagitude(valptr,thruptr,veryweak) = 0 then

               begin

               if Trace2MMgr  then writeln('found thru');
               {found thru now look for beginning of string}
               i:= runptr^[2].lpfst;
               if (bold in runptr^[2].face) then
                  begin
                  status := badsrchop;
                  goto 998;
                  end;


               while (value^[i] = ORD(' ')) and (i <= length) do i := i + 1;
               if i = length then goto 998;
               sindex2 := i;

               if Trace2MMgr  then writeln('finding end of string');
               {now find end of string }
               j := 0;
               while (value^[length-1-j] = ORD(' ')) and (j<(length-runptr^[2].
                      lpfst))do j := j + 1;

               {return string2 values}
               len2 := length-i-j;
               numstr := 2;
               end
            else
               begin {bad value}
               sindex1 := 0;
               len1 := 0;
               sindex2 := 0;
               len2 := 0;
               status := BadSrchOp;
               goto 999;
               end;
            end;
         end
      else
         begin
         status := badsrchop;
         goto 998;
         end;
      end;


goto 999;

998:
      sindex1 := 0;
      len1 := 0;
      sindex2 := 0;
      len2 := 0;
999:
   if Trace2MMgr  then
      begin
      writeln('i1,i2,l1,l2,numstr,status',sindex1:2,sindex2:3,len1:3,len2:3,
               numstr:3,status:3);
      writeln('i,j',i:4,j:4);
      end;


   end;

