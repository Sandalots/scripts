{$S lmopendoc }
PROCEDURE GetSusData{VAR HndSusData: HndData;
                     VAR Len: INTEGER};

   CONST GSD = ' GetSusData';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,GSD);

   HndSusData := POINTER(ORD(FexecBlock));
   Len := FBlockLen;
   END;



{$S lminit }
procedure init_strategy;
var
        i : integer;
begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
        for i := 0 to max_filtrate do
            with eq_filtrate[i] do
                begin
                numerator := 1;
                denominator := 2;
                end;
        with eq_filtrate[0] do
            begin
            numerator := 1;
            denominator := 1;
            end;

        for i := 0 to max_filtrate do
            with ineq_filtrate[i] do
                begin
                numerator := 1;
                denominator := 2;
                end;
        with ineq_filtrate[0] do
            begin
            numerator := 1;
            denominator := 1;
            end;


        Run_Pages := 12;
        with strategy[onesided] do
            begin
            abs_ios := 0;
            abs_recs := 0;
            with fract_ios do
                begin
                numerator := 1;
                denominator := 5;
                end;
            with fract_recs do
                begin
                numerator := 1;
                denominator := 5;
                end;
            end;
        with strategy[twosided] do
            begin
            abs_ios := 1;
            abs_recs := 1;
            with fract_ios do
                begin
                numerator := 0;
                denominator := 1;
                end;
            with fract_recs do
                begin
                numerator := 0;
                denominator := 1;
                end;
            end;
        with strategy[equals] do
            begin
            abs_ios := 1;
            abs_recs := 1;
            with fract_ios do
                begin
                numerator := 0;
                denominator := 1;
                end;
            with fract_recs do
                begin
                numerator := 0;
                denominator := 1;
                end;
            end;
        with strategy[unbounded] do
            begin
            abs_ios := 0;
            abs_recs := 0;
            with fract_ios do
                begin
                numerator := 1;
                denominator := 1;
                end;
            with fract_recs do
                begin
                numerator := 1;
                denominator := 1;
                end;
            end;
end;


{$S lmscrap}
Procedure InitPasteRgs{var status};
(* status values : 1-nocolumns *)

const
  IP = 'InitPasteRgs';

var
  row : idtype;
  col : idtype;
  tabrecord : tablerecord;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  if tracemmgr then with selrg do
    writeln(IP,' selrg lo/hicol lo/hirow : ',ord(rkind):4,locol:4,hicol:4,lorow:4,hirow:4);

  {get the first and last column snipids and correct the selrg}
  if (selrg.rkind = arowrg) or (selrg.rkind = arowgrid)
  or (selrg.rkind = a1cellrg) or (selrg.rkind = awtboxrg) then
    begin
    if selrg.rkind <> a1cellrg then
      begin
      col := minfsnip;
      GetNxtVisCol(col);
      if col = pinfsnip then
        begin
        status := 1;
        exit(initpastergs);
        end;

      selrg.locol := col;
      end
    else col := selrg.locol;

    repeat                    {loop until you reach the last column}
      selrg.hicol := col;
      GetNxtVisCol(col);
    until col = pinfsnip;
    end;

  {always add rows if selection is in last row}
  if (selrg.lorow = tabledata.lastrow) or (selrg.rkind = a1cellrg) then selrg.hirow := pinfsnip;

  SwitchTable(TRUE,tabrecord);

  if (selrg.rkind = acolrg) or (selrg.rkind = awtboxrg) then       {get first row snipid if column range}
    begin
    GetSnipID(rowkind,mmfirst,0,row,row);
    selrg.lorow := row;
    end;

  if tracemmgr then with selrg do
    writeln(IP,' selrg rkind lo/hicol lo/hirow : ',ord(rkind):4,locol:4,hicol:4,lorow:4,hirow:4);
end;






{$S lmres }
PROCEDURE InitSnipPtr{snipType: SnipKind;
                      snipId : IdType};

   {This procedure sets up the RowSnip or ColSnip Ptr in globals and checks
    snip for validity}

   CONST ISP = ' InitSnipPtr';

   VAR h : TH;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,ISP);
   h := SnipToPtr(SnipId);
   IF sniptype = colkind then ColSnip := @h^^
   ELSE RowSnip := @h^^;
   IF Trace2MMgr THEN WriteLn('Address: ',Ord(@H^^));
   END;




{$S lmopendoc }
PROCEDURE InitTabRecords;

      {This procedure initializes the tabledata records with the characteristics
      of the list table. Modules responsible for switching to tables other
      than the list must make the necessary modifications to this information.}

      CONST ITR = ' InitTabRecords ';

      VAR FInfo: fontinfo;
          Status: INTEGER;
          Status2: BOOLEAN;
          I : integer;

      BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
      IF TraceMMGR then WriteLn(MxMgr,ITR);

      {Initialize the font information to default values}
      WITH MMFontinfo DO
         BEGIN
         WITH Font DO
            BEGIN
            fam := p12tile;
            dev := devscreen;
            seteface := [];
            END;
         DMPFont := Font;
         FontOptions := [PrintFont];
         {The following call should be moved to MMInit if it causes a costly swap-in.}
         Status2 := FmFontMetrics(Font,FInfo,Status);
         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn('***',ITR,'FmFontMetrics status: ',Status);
         WITH FInfo DO
            BEGIN
            CellWidth := WidMax + 1;
            CellHeight := Ascent + Descent + Leading;
            END;
         END;


      {First initialize the table information. This assumes the characteristics
      of the displayed list. When switching to other tables, this will have to
      be modified.}
      WITH TableData DO
         BEGIN
         ColTitAlign := Center;
         RowTitAlign := Left;
         ColCount := 0;
         FirstCol := NullSnip;
         LastCol := NullSnip;
         FirstRow := NullSnip;
         LastRow := NullSnip;
         TopRow := NullSnip;
         BottomRow := NullSnip;
         WITH MMFontinfo DO AdjustTableToFont(CellWidth,CellHeight);
         END;

      WITH TableChars DO
         BEGIN
         SplitTable := FALSE;
         RectBorder := TRUE;
         Marquee := TRUE ;
         ColHandles := FALSE;
         ColGrids := TRUE;
         ColGridHandles := TRUE;
         ColRangeOk := TRUE;
         EditColTitle := FALSE;
         InsertCols := FALSE;
         EdBlankCol := FALSE;
         RowHandles := FALSE;
         RowGrids := FALSE;
         RowRangeOk := TRUE ;
         RowGridHandles := TRUE;
         EditRowTitle := FALSE;
         InsertRows := FALSE;
         EdBlankRow := FALSE;
         EditTable := TRUE;
         ShoFormulas :=FALSE;
         Preview := FALSE;
         RectRgOk := TRUE;
         FieldPad := 4;
         ScrollIncr[rowkind] := 720;  {snip increments}
         ScrollIncr[colkind] := 150;
         END;

      {Load this information into the list table record}
      ListTable := TableData;
      ListChars := TableChars;

      END; {Procedure InitTableInfo}



{$S lmres2 }
PROCEDURE InsertColSnips{VAR HeadCol: IdType;
                         VAR TailCol: IdType;
                         PriorCol: IdType;
                         FirstCol: IdType;
                         LastCol: IdType};

   {This procedure pastes a linked list of columns starting with FirstCol
   and ending with LastCol into a linked list which starts with HeadCol
   and ends with TailCol. PriorCol is the id of the snip after which the
   new list will be spliced in. If PriorCol is null, the list will be
   spliced in at the beginning. HeadCol and TailCol may be null.}

   CONST ICS = ' InsertColSnips';

   VAR NextCol: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,ICS,HeadCol:4,TailCol:4,PriorCol:4,FirstCol:4,LastCol:4);

   {Set next pointer of PriorCol}
   IF PriorCol = NullSnip THEN
      BEGIN
      NextCol := HeadCol;
      HeadCol := FirstCol;
      END
   ELSE BEGIN
        SetSnipPtr(ColKind,PriorCol);
        NextCol := ColSnip^.NextSnip;
        ColSnip^.NextSnip := FirstCol;
        END;

   {Set prior pointer of firstCol}
   SetSnipPtr(ColKind,FirstCol);
   ColSnip^.PriorSnip := PriorCol;

   {Set next pointer of LastCol}
   IF FirstCol <> LastCol THEN SetSnipPtr(ColKind,LastCol);
   ColSnip^.NextSnip := NextCol;

   {Set prior pointer of NextCol}
   IF NextCol = NullSnip THEN TailCol := LastCol
   ELSE BEGIN
        SetSnipPtr(ColKind,NextCol);
        ColSnip^.PriorSnip := LastCol;
        END;

   END;


(*
{$S lmlist}
PROCEDURE InsertBlankRow{rowid1,rowid2:idtype; var newsnipid:idtype; var status:integer};

var blankptr : ptrdata;
    recsize: integer;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  recsize := GetRecSize;
  GetSnipBlock(newsnipid,recsize,status);
  if status <> 0 then
    if mmtrap1 then writeln('InsertBlankRow; GetSnipBlock status : ',status)
  else
    begin
    InitSnipPtr(colkind,newsnipid);
    BlankPtr := @colsnip^;
    BlankRecord(BlankPtr);

    InsertRowSnips(rowid1,rowid2,rowid1,newsnipid,newsnipid);
    end;

end;
*)

{$S lmlist }
PROCEDURE InsertRowSnips{VAR HeadRow: IdType;
                         VAR TailRow: IdType;
                         PriorRow: IdType;
                         FirstRow: IdType;
                         LastRow: IdType};

   {This procedure pastes a linked list of rows starting with FirstRow
   and ending with LastRow into a linked list which starts with HeadRow
   and ends with TailRow. PriorRow is the id of the snip after which the
   new list will be spliced in. If PriorRow is null, the list will be
   spliced in at the beginning. HeadRow and TailRow may be null.}

   CONST IRS = ' InsertRowSnips';

   VAR NextRow: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,IRS,HeadRow,TailRow,PriorRow,FirstRow,LastRow);

   {Set next pointer of priorrow}
   IF PriorRow = NullSnip THEN
      BEGIN
      NextRow := HeadRow;
      HeadRow := FirstRow;
      END
   ELSE BEGIN
        SetSnipPtr(RowKind,PriorRow);
        NextRow := RowSnip^.NextSnip;
        RowSnip^.NextSnip := FirstRow;
        END;

   {Set prior pointer of firstrow}
   SetSnipPtr(RowKind,FirstRow);
   RowSnip^.PriorSnip := PriorRow;

   {Set next pointer of LastRow}
   IF FirstRow <> LastRow THEN SetSnipPtr(RowKind,LastRow);
   RowSnip^.NextSnip := NextRow;

   {Set prior pointer of NextRow}
   IF NextRow = NullSnip THEN TailRow := LastRow
   ELSE BEGIN
        SetSnipPtr(RowKind,NextRow);
        RowSnip^.PriorSnip := LastRow;
        END;

   END;


{$S lmsearch}
Function  isbold{numruns:integer; runptr:ptrruns;pos:integer;
                 var lastvalidrun : integer ):boolean};
   VAR
       i : integer;
       bool : boolean;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' IsBold ');

   i := 0;
   lastvalidrun := 0;
   while i <= numruns -1 do
      begin
      if (runptr^[i].lpfst <= pos) then lastvalidrun := i;
      i:= i+ 1;
      end;
   bool:= bold in runptr^[lastvalidrun].face;
   isbold := bool;
   if Trace2MMgr then writeln('is bold :',bool);
   END;


{$S lmres }
Function ListCardinality{:longint};

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGr THEN WriteLn(MxMgr,' ListCardinality ');

   if (curtable = tlist) then
      BEGIN
      IF MMTrap1 THEN IF ListRowCount <= 0 THEN MMFatalErr(LogicErr,'ListCardinality','');
      ListCardinality := ListRowCount;
      END

   else if (curTable = tsearch) then
      listCardinality := 1

   else if (curtable = tcolspecs) THEN
      BEGIN
      IF (CreatingTable OR RedefiningTable) then listCardinality := 2
      ELSE ListCardinality := 4;
      END;

   END;

{$S lmscrap}
function LLCountSnips{kind : snipkind; var rg : range):integer};

const
  CS = 'LLCountSnips';

var
  snip : idtype;
  cnt : integer;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  with rg do
    begin
    if kind = ColKind then              {called for all possible ranges}
      begin
      snip := locol;
      if rkind = a1cellrg then hicol := pinfsnip;
      if snip = minfsnip then getnxtviscol(snip);
      cnt := 1;
      while (snip <> pinfsnip) and (snip <> hicol) do
        begin
        getnxtviscol(snip);
        if (snip <> pinfsnip) then cnt := cnt+1;
        end;
      if mmtrap1 then writeln(CS,'; column count : ',cnt);
      end
    else {kind = rowkind}               {only called for rectrg and rowrg}
      begin
      snip := rg.lorow;
      cnt := 1;
      while (snip <> hirow) do
        begin
        cnt := cnt+1;
        getsnipid(rowkind,mmnext,0,snip,snip);
        end;
      if mmtrap1 then writeln(CS,'; row count : ',cnt);
      end;
    end;

  LLCountSnips := cnt;

end;    {LLCountSnips}


{$S lmscrap}
procedure LLPxHcsMtx{(index:TB)};
begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
(*
  if rghcs^[index]^^.tycs = tycsMtrx then
     writeln ( 'Type is indeed tycsMtrx' )
   else
     writeln ( 'Oshigosh, type is NOT tycsMtrx' )
*)
end;


{$S lmscrap}
Procedure LLSeqLpdMtx{(Lpd: Tlpd; var achad: Tachad)};

{********************************************************************************
Function: Starting at Lplim in the lpd return as large a run as possible, never
more than allowed by the interval in achad. If achad.rgch is nil then set rgch
to the row data array.

errors : Stream is not of type matrix.
*********************************************************************************}
label 100, 50;

var
  kludge: record
             case integer of
                1:(a: integer;
                   b: integer);
                2:(c: longint);
           end;

  lp: Tlp;
  i, cch: TC;
  AchadSrc: TAchad;
  LpRow: integer;
  ichoflp: TC;
  found: boolean;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  Lpd^.rce := @lpd^.arce;
  movergch(pointer(ord(lpd^.rce)),@arcestd, arcestd.cb);
{ The only part of the arce that is not standard is the font }

   found := false;
   i := 0;
   while (i <= ifntlst) and not(found) do
     begin
     if argfam[i] = UTinforec.lcfont then
       begin
       lpd^.rce^.ifnt := i;
       found := true;
       end;
     i := i + 1;
     end;
   if not found then lpd^.rce^.ifnt := 0;

  with kludge do
     begin
     c := lpd^.lplim;
     ichoflp := b;
     LpRow := a;
     end;

  {set global to where we left off copying data last from utchhandle to stream}
  UTCharsTaken := ichoflp;
  if tracemmgr then writeln('LLSeqlpdmtx; utcharstaken : ',utcharstaken);

  cch := achad.ichlim - achad.ichFst;

{ Get the text }
  if not GetLLCUTRow(LpRow) then begin
    lpd^.arce.fvan := true;
    achadsrc.ichfst := achadsrc.ichlim;
    cch := 0;
    goto 50;
  end;

{ check for vanished run }
  if ichoflp >= UTCharCount then
    with kludge do
       begin
       lpd^.arce.fvan := true;
       a := Lprow+1;
       b := 0;
       lpd^.lplim := c;
       goto 100
       end
  else
    lpd^.arce.fvan := false;

{ Set the starting position to the old ending position }
  lpd^.lp := lpd^.lplim;
  achadsrc.ichfst := ichoflp;

{ return the minimum of the rest of the row or the size of the achad array }
  cch := LpMinP(UTCharCount - ichoflp, cch);
  achadsrc.ichlim := achadsrc.ichfst + cch;

{ Set the paragraph descriptor }
  lpd^.rpe := @lpd^.arpe;
  moveRgch(@lpd^.arpe, @arpeStd, arpeStd.cb);
  with kludge do
     begin
     a := lprow;
     b := 0;
     lpd^.lpfstpar := c;
     b := cch;
     lpd^.lplimpar := c;
     end;

  { stuff the tab array }
  for i := 0 to UTinforec.numtabs - 1 do
     lpd^.rpe^.argtbd[i] := UTinforec.tabs[i];
  {should this be -1}
  lpd^.rpe^.itblim := UTinforec.numtabs;

  with lpd^.rpe^ do
     begin
     xLftFst := leftmarg;   { first left marg }
     xLftBody := leftmarg;       { left body margin }
     xRt := 1400;           { right margin }
     end;

50:
  achadsrc.rgch := @UTchhandle^^;

{Set the return achad}
if achad.rgch = nil then
   achad := achadsrc
else begin
   achad.ichlim := achad.ichfst + cch;
   moveachad(achad,achadsrc);
end;

with kludge do
  begin
  a := LpRow;
  b := achadsrc.ichlim;
  lpd^.lplim := c;
  end;

100:
end;


{$S lmcolspec }
PROCEDURE LoadColSpecs{VAR TableInfo: TableRecord};

   {This procedure loads up the structures necessary to support the column
   spec table.}

   CONST LCSpec = ' LoadColSpecs';

   VAR Column: IdType;
       Status: INTEGER;
       NewColCount: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,LCSpec);

   {Initialize flag which says 'change of magnitude' alert has not been put up yet}
   MagCaution := FALSE;

   {If the table is being redefined, move the list snips out of the way,
   and then make a copy of them and put them back on the ListTable. Before
   making the copy, set the MiscId field equal to the snipid of each column.
   When the copy is made, then each of the copied columns will point back
   to their originals. This is necessary in order to know which column in
   the old list maps to which columns in the new list.}

   IF RedefiningTable THEN WITH CopyListColumns DO
      BEGIN
      {Make sure that the copy needs to be created. It may already be created if RecreateListFile
      returned an error, and now we want to redisplay the add/delete table.}
      IF FirstCol = NullSnip THEN
         BEGIN
         FirstCol := ListTable.FirstCol;
         LastCol := ListTable.LastCol;
         ColCount := ListTable.ColCount;

         Column := FirstCol;
         WHILE Column <> NullSnip DO
            BEGIN
            SetSnipPtr(ColKind,Column);
            WITH ColSnip^ DO
               BEGIN
               MiscId := Column;
               Column := NextSnip;
               END;
            END;

         CopyColSnips(FirstCol,LastCol,NullSnip,ListTable.FirstCol,ListTable.LastCol);
         HScrollId := NullSnip;
         END;
      END;


   {Now initialize the table information & misc for this table}
   ColumnsCut := FALSE;
   CSKeys := NSKeys;
   CurTable := TColSpecs;
   TableChars := ListChars;  {Load in a known set of parameters, to which we
                             can make a few modifications to correspond to
                             the new table characteristics.}

   WITH TableChars DO
      BEGIN
      ColHandles := FALSE;
      ColGridHandles := TRUE;
      InsertCols := TRUE;
      RowHandles := FALSE;
      RowGridHandles := FALSE;
      RowGrids := TRUE;
      EditColTitle := TRUE;
      ColRangeOk := TRUE;
      RectRgOK := FALSE;
      TableInfo := TableChars;
      END;

   {Find the greatest length among the four row header phrases.  If creating or redefining table, use}
   { the greater of the phrase lengths for the sort and visible rows only.                           }

{aw} {european}
   SizeRowTitle := length(DTypHeader);
   IF length(DFmtHeader) > SizeRowTitle THEN SizeRowTitle := length(DFmtHeader);
   IF NOT (CreatingTable OR RedefiningTable) THEN
      BEGIN
      IF length(SortHeader) > SizeRowTitle THEN SizeRowTitle := length(SortHeader);
      IF length(VisiHeader) > SizeRowTitle THEN SizeRowTitle := length(VisiHeader);
      END;

   {Row title width based on max # of characters and font size}
   TableData.RowTitleWidth := ((SizeRowTitle + (SizeRowTitle div 3)) * MMFontinfo.CellWidth);

   {Generate the set of spec table column snips}
   MakeColSpecSnips;

   {Now create four empty row snips with appropriate row titles}
   BlankRow(DTypHeader,TRUE,TypeRow,Status);
   BlankRow(DFmtHeader,TRUE,EditCRow,Status);

   {Only put up the other rows if the list is already created,
   or if we are not redefining the table}
   IF NOT (CreatingTable OR RedefiningTable) THEN
      BEGIN
      BlankRow(SortHeader,TRUE,SortRow,Status);
      BlankRow(VisiHeader,TRUE,VisibleRow,Status);
      END
   ELSE BEGIN {These variables are checked by fexec, so null out if not used.}
        SortRow := NullSnip;
        VisibleRow := NullSnip;
        END;

   {For each column in the list, generate the appropriate ascii information
   and place it in the appropriate field of the appropriate row snip.}
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      PackCSCol(Column);
      SetSnipPtr(ColKind,Column);
      Column := ColSnip^.NextSnip;
      END; {While loop}


  {If redefining the table, add 5 blank columns for the user to use}
  IF RedefiningTable THEN
     BEGIN
     {The actual number added will be less than 5 if there are already 96 or more columns}
     NewColCount := CMin(5,(MaxCols - TableData.ColCount));
     IF NewColCount > 0 THEN
        BEGIN
        {Make sure there is enough memory.}
        IF EnoughMemory(TableData.ColCount + NewColCount,MMFontInfo.CellHeight) THEN
           BEGIN
           {Now add in the columns}
           WHILE NewColCount > 0 DO
              BEGIN
              AddCol(Status);
              IF Status <> 0 THEN NewColCount := 0 ELSE NewColCount := NewColCount - 1;
              END;
           END; {EnoughMemory}
        END; {NewColCount > 0}
     END; {Redefining}


  {Set table title}
  IF CreatingTable THEN
     BEGIN
     GetAlert(LMALERTS,ActShowList,@ListTitle);
     ListFormChanged := TRUE; {Causes list manager info to be written to data file.}
     END

  ELSE IF RedefiningTable THEN GetAlert(LMAlerts,RedefTitle,@ListTitle)

  ELSE GetAlert(LMALERTS,ColDescr,@ListTitle);

  promptString := ListTitle;
  END;



{$S lmlist }
PROCEDURE LoadCr;

   CONST LCR = ' LoadCr';

   VAR Row: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,LCR);
   {Save the current range on CurRgSnip and release row memory}
   SaveCr;

   {Put current range list into row list memory}
   TableData.TopRow := CurRgSnip;
   CurRgList := FALSE;
   CurRgSnip := NullSnip;

   {Find the bottom of the current range}
   Row := TableData.TopRow;
   While Row <> NullSnip DO
      BEGIN
      SetSnipPtr(RowKind,Row);
      Row := RowSnip^.NextSnip;
      END;
   TableData.BottomRow := RowSnip^.SnipId;
   END;



{$S lmscrap }
PROCEDURE LoadCutCols{VAR TableInfo:TableRecord};

   CONST LCC = ' LoadCutCols';

   VAR Column: IdType;
       VisFlag: BOOLEAN;
       SRgFound: BOOLEAN;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,LCC);
{  IF MMTrap1 THEN IF CurTable <> TColSpecs THEN MMFatalErr(LogicErr,LCC,''); }

   {Switch list/colspec table params into background}
   IF CurTable = TList THEN
     BEGIN
     ListTable := TableData;
     ListChars := TableChars;
     TableData.ColTitleHeight := 0;
     END
   ELSE {CurTable = TColSpecs}
     BEGIN
     ColSpecChars := TableChars;
     ColSpecData := TableData;

     {Load in the list table characteristics, since they are close to what is needed}
     TableChars := ListChars;
     CurTable := TCutCols;
     END;

   {Customize}
   WITH TableChars DO
      BEGIN
      IF (CurTable = TList) THEN RowGrids := FALSE ELSE RowGrids := TRUE;
      RowHandles := FALSE;
      RowGridHandles := FALSE;
      EditTable := False;
      END;
   WITH TableData DO
      RowTitleWidth := 0;

   {Loop through all columns and make the uncut ones invisible, and the cut
   ones visible. Use the MiscId field to remember the state of the old
   visibility for switching back to the normal table.
   VisFlag := FALSE;
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      IF Column = MMScrapRg.loCol THEN VisFlag := TRUE;
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^ DO
         BEGIN
         MiscId := ORD(Visible);
         if fieldinfo.fldtype <> tick then Visible := VisFlag;
         IF Column = MMScrapRg.hiCol THEN VisFlag := FALSE;
         Column := NextSnip;
         END;
      END;}

   {go through all the columns; if the column is not in the scrap range, remember its}
   { old visibility and reset to FALSE.  if it is in scrap range, just remember vis  }
   Column := TableData.FirstCol;
   SrgFound := FALSE;
   while column <> nullsnip do          {loop through columns}
     begin
     setsnipptr(colkind,column);
     with colsnip^ do
       begin
       if column = mmscraprg.locol then SRgFound := TRUE;
       miscid := ord(visible);                            {remember old visibility}
       if NOT SRgfound then visible := FALSE;             {reset to FALSE if not in scraprg}
       if column = mmscraprg.hicol then SRgFound := FALSE;
       column := nextsnip;
       end;
     end;

   TableInfo := TableChars;
   END;

{$S lmscrap }
PROCEDURE LoadCut_RectRg{VAR TableInfo: TableRecord};

   CONST LCR = ' LoadCut_RectRg';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,LCR);
   IF MMTrap1 THEN IF CurTable <> TList THEN MMFatalErr(LogicErr,LCR,'');

   {Save state of list}
   ListTable := TableData;
   ListChars := TableChars;

   {Customize the table parameters}
   WITH TableChars DO
      BEGIN
      RowHandles := FALSE;
      RowGridHandles := FALSE;
      EditTable := FALSE;
      END;

   {Set in pointers to the cut rows}
   WITH TableData DO
      BEGIN
      FirstRow := MMScrapRg.loRow;
      LastRow := MMScrapRg.hiRow;
      TopRow := MMScrapRg.loRow;
      BottomRow := MMScrapRg.hiRow;

      FirstCol := MMScrapRg.loCol;
      LastCol := MMScrapRg.hiCol;
      ColTitleHeight := 0;
      RowTitleWidth := 0;

      {kludge to make rectrgs show up in scrap}
      SetSnipPtr(ColKind,LastCol);
      SaveColNext := ColSnip^.NextSnip;
      ColSnip^.NextSnip := nullsnip;

      SetSnipPtr(RowKind,LastRow);
      SaveRowNext := RowSnip^.NextSnip;
      RowSnip^.NextSnip := nullsnip;

      END;

   CurTable := TCutRectRg;
   TableInfo := TableChars;
   END;




{$S lmscrap }
PROCEDURE LoadCutRows{VAR TableInfo: TableRecord};

   CONST LCR = ' LoadCutRows';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,LCR);
   IF MMTrap1 THEN IF CurTable <> TList THEN MMFatalErr(LogicErr,LCR,'');

   {Save state of list}
   ListTable := TableData;
   ListChars := TableChars;

   {Customize the table parameters}
   WITH TableChars DO
      BEGIN
      RowHandles := FALSE;
      RowGridHandles := FALSE;
      EditTable := FALSE;
      END;

   {Set in pointers to the cut rows}
   WITH TableData DO
      BEGIN
      if MMScrapRg.rkind = aRowRg then
        begin
        if MMScrapRg.loRow = minfsnip then
          begin
          GetSnipID(rowkind,mmfirst,0,FirstRow,FirstRow);
          BottomRow := FirstRow;
          end
        else
          begin
          FirstRow := MMScrapRg.loRow;
          TopRow := FirstRow;
          end;
        BottomRow := MMScrapRg.hiRow;
        LastRow := MMScrapRg.hiRow;
        end;
      ColTitleHeight := 0;
      RowTitleWidth := 0;
      END;

   CurTable := TCutRows;
   TableInfo := TableChars;
   END;



{$S lmlist }
PROCEDURE LoadList{VAR TableInfo: TableRecord;
                   ShowLastList: BOOLEAN;
                   SearchList: BOOLEAN;
                   SortList: BOOLEAN};

   LABEL 999;

   CONST LdList = ' LoadList ';

   VAR Status: INTEGER;
       Column: IdType;
       SortIndex: INTEGER;
       NTriples: INTEGER;
       NKeys: INTEGER;
       ConstPtr : ptrdata;
       ExprPtr : ptrExpr;
       NewScanRequired: BOOLEAN;
       TitleMsg: INTEGER;
       Sorting: BOOLEAN;
       Searching: BOOLEAN;
       SwapSpace: LONGINT;
       DataSpace: LONGINT;
       CurCodeSize: LONGINT;
       MaxCodeSize: LONGINT;
       WaitMsgUp: BOOLEAN;
       ErrStatus: INTEGER;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Trace this sucker!}
   IF TraceMMGR then WriteLn(MxMgr,LdList,ShowLastList,SearchList,SortList);

   {Initialize globals for list.}
   SwitchToList;

   {If we are to display the same list as before, set the search and sort booleans appropriately.
   The variables SearchRequested and SortRequested indicate what was requested the last time
   when LoadList was called.}
   IF ShowLastList THEN
      BEGIN
      IF TraceMMgr THEN WriteLn('SearchRequested: ',SearchRequested,' SortRequested: ',SortRequested);
      SearchList := SearchRequested;
      SortList := SortRequested;
      END;

   {Initialize sort and search structures}
   IF TraceMMgr THEN WriteLn('SearchValid: ',SearchValid,' SortValid: ',SortValid);

   {If the sort criteria has changed, generate a new one. The variable SortValid indicates whether
   the user has changed the sort criteria since the last time LoadList was called. If they have
   changed, then a new set of sort structures as required by DiffOpen must be generated.}
   IF NOT SortValid THEN
      BEGIN
      {Loop through all of the column snips }
      NSKeys := 0;
      Column := TableData.FirstCol;
      WHILE Column <> NullSnip DO
         BEGIN
         SetSnipPtr(ColKind,Column);
         IF ColSnip^.SortOrder <> 0 THEN
            BEGIN {Column is a sort key}
            SortIndex := ColSnip^.SortOrder - 1;
            WITH SortArray[SortIndex] DO
               BEGIN
               AorD := ColSnip^.SortDirection;
               Field := ColSnip^.FieldNum;
               END;
            NSKeys := NSKeys + 1;
            END;

         Column := ColSnip^.NextSnip;
         END;

      SortPtr := @SortArray;
      END;


   {Initialize search variables. }
   IF ExprHnd = nil then ExprPtr := nil
   ELSE ExprPtr := ExprHnd^;
   IF ConstHnd = nil then ConstPtr := nil
   ELSE ConstPtr := ConstHnd^;

   IF TraceMMgr THEN WriteLn('NSKeys: ',NSKeys,' NumTriples: ',NumTriples);

   {Now figure out whether we really want to sort or search. The variable Searching is only set
   if the user has requested searching, and has also specified a search criteria. The variable
   Sorting is only set if the user has requested sorting, and a sort order has been specified.
   The variables searching and sorting differ from what the user requests in that they are only
   set if it does not result in a null search or sort.}
   IF SearchList AND (NumTriples <> 0) THEN Searching := TRUE ELSE Searching := FALSE;
   IF SortList AND (NSKeys <> 0) THEN Sorting := TRUE ELSE Sorting := FALSE;
   IF TraceMMgr THEN WriteLn('Searching: ',Searching,' Sorting: ',Sorting);


   {If the user has not changed the search and sort criteria, and is also requesting the same display
   (sorted, searched, etc.) to be generated, we will scroll the list to
   where it was before. Otherwise, it will be displayed from the beginning. The variable
   SortValid tells us if the user changed the sort criteria since the last display of the
   list. The variable SearchValid tells us if the search criteria changed. ListScrollValid
   controls the initial scrolling point and is interrogated inside GetCurPosSnip. Oh - in order
   to scroll to the same place, we need to check ListScrollValid to make sure that a valid
   handle has been stored. ListScrollValid plays two parts - After WriteList is called, it
   indicates if a scroll handle has been saved. After a subsequent LoadList, it indicates whether
   to actually try to use the handle.}
   IF ListScrollValid
      AND SortValid     {User has not changed sort specs}
      AND SearchValid   {User has not changed search specs}
      AND (Searching = Searched)  {Request is same as last display}
      AND (Sorting = Sorted)      {Request is same as last display}
      THEN ListScrollValid := TRUE ELSE ListScrollValid := FALSE;


   {Now figure out if a new scan is required. The variable Searched indicates that the last time
   the list was displayed, the user requested it searched, AND there was a search criteria in
   effect. The variable Sorted indicates that the last time the list was displayed, the user
   requested sorting other than the default. Basically, if what was requested this time matches
   what was actually done last time, no new scan is required. Also check to see if the search
   or sort criteria has been changed, and if so, if the user is requesting search or sorting.
   The variables SearchValid and SortValid indicate if the user changed the criteria since the
   last time that loadlist was called.}
   IF (NOT ScanOpen)                    {Scan not open}
   OR (Searching AND (NOT SearchValid)) {Search criteria changed and searching requested}
   OR (Sorting AND (NOT SortValid))     {Sort criteria changed and sorting requested}
   OR (Searching <> Searched)           {Search criteria the same, but request is different from last display}
   OR (Sorting <> Sorted)               {Sort criteria the same, but request is different from last display}
   THEN NewScanRequired := TRUE ELSE NewScanRequired := FALSE;


   {Open a new scan if necessary}
   IF NewScanRequired THEN
      BEGIN
      IF TraceMMgr then WriteLn(MxMgr,LdList,'New scan required...');
      IF ScanOpen THEN
         BEGIN
         {Close the scan - there are no updates, since we would
         not leave the scan open otherwise.}
         DiffClose(Status,ScanId,FALSE);
         IF Status <> NoErr THEN
            BEGIN
            IF MMTrap1 THEN WriteLn('***DiffClose status: ',Status);
            {Should not be able to run out of disc space at this point.
            Any error is rather unexpected. However, an error will not
            really affect any subsequent processing. If it affects a
            subsequent call to the database, it will be handled later.}
            END;

         ScanOpen := FALSE;
         IF TraceMMgr then WriteLn(MxMgr,LdList,'Differential file closed');
         END;

      {Reset some globals}
      BlankLine := FALSE;
      RowChanged := NullSnip;
      ListModified := FALSE;

      {If sorting or searching is going to occur, set the variables which will cause DiffOpen to do so}
      IF Sorting THEN NKeys := NSKeys ELSE NKeys := 0;
      IF Searching THEN NTriples := NumTriples ELSE NTriples := 0;

      {If this is a non-default order sort, with no search, on a fairly large file,
      it is guaranteed to take a bit of time. In this case, put up a wait alert}
      IF Sorting AND (NOT Searching) AND (ListRowCount > 50)
         AND (NOT ((NKeys = 1) AND (SortArray[0].Field = 0))) THEN {Default sort order}
         BEGIN
         WaitAlert(LMAlerts,WaitSort);
         WaitMsgUp := TRUE;
         END
      ELSE WaitMsgUp := FALSE;

      IF TraceMMgr THEN WriteLn(MxMgr,LdList,'DiffOpen Sort params ',NKeys,SortPtr^[0].AOrD,SortPtr^[0].Field);

      {Open the differential scan}
      Sched_Class(ErrStatus,FALSE);
      DiffOpen(Status,ScanId,Next,ExprPtr,NTriples,ConstPtr,
               ConstSize,NKeys,SortPtr,@Temp1PName,@Temp2PName,DOLDSN);
      Sched_Class(ErrStatus,TRUE);

      {Take the wait message down if it is up}
      IF WaitMsgUp THEN EndWaitAlert;

      IF Status <> NoErr THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***',LdList,' DiffOpen status: ',Status);

         {Put up an alert box}
         DBAlert(DisplayErr,Status);
         ListRowCount := 0;
         ScanOpen := FALSE;
         SortValid := FALSE;
         SearchValid := FALSE;

         {The following are set so that no title will be displayed in the event of error.}
         Searched := FALSE;
         Sorted := FALSE;

         {Set row pointers for null list}
         WITH TableData DO
            BEGIN
            FirstRow := PInfSnip;
            LastRow := MInfSnip;
            END;
         END

      ELSE BEGIN
           IF TraceMMgr then WriteLn(MxMgr,LdList,'Differential file opened');
           {Set status globals relating to this scan}
           ScanOpen := TRUE;

           {Remember what options were used on this scan for next time}
           Sorted := Sorting;
           Searched := Searching;

           {Reset search and sort change indicators}
           SortValid := TRUE;
           SearchValid := TRUE;

           {Remember what was requested, in case we want to redisplay the same list as before}
           SearchRequested := SearchList;
           SortRequested := SortList;

           ListRowCount := {set to record count of data file}
           Pfiletable^[pscantable^[pdifftable^[scanid]^.realid]^.onfile]^.nrecs;
           END;

      END; {NewScanRequired}

   {Return the table information}
999: TableInfo := TableChars;

   {Generate the proper title}
   IF NOT (Searched OR Sorted) THEN ListTitle := ''
   ELSE BEGIN
        IF (Searched AND Sorted) THEN TitleMsg := SrchSortTitle
        ELSE IF Searched THEN TitleMsg := SrchTitle
        ELSE IF Sorted THEN TitleMsg := SortTitle;

        GetAlert(LMAlerts,TitleMsg,@ListTitle);
        END;

   promptString := ListTitle;

   IF MMTrap2 THEN
      BEGIN
      Mem_Info(Status,SwapSpace,DataSpace,CurCodeSize,MaxCodeSize);
      IF Status <> 0 THEN WriteLn(Bell,'***',LdList,'Mem_Info status: ',Status);
      WriteLn('*** SwapSpace: ',SwapSpace,' DataSpace: ',DataSpace,' CurCodeSize: ',CurCodeSize,' MaxCodeSize: ',MaxCodeSize);
      END;
   END;




{$S lmsearch }
PROCEDURE LoadSearch  {VAR TableInfo: TableRecord};

   {This procedure loads up the structures necessary to support the search
   criteria table.}

   CONST LSrch  = ' LoadSearch';
         BufSize = 200;


   VAR ListColSnip: PtrColSnip;
       SpecColSnip: PtrColSnip;
       Column: IdType;
       Len: INTEGER;
       Status: INTEGER;
       ROW : IdType;
       realid : Integer;
       SpecColId : Idtype;
       ListColId : Idtype;
       srchNull : boolean;
       countcomp : integer;
       eptr : ptrexpr;
       foffset : integer;
       voffset : integer;
       oplen : integer;
       tripleIndex : integer;
       cptr : ptrdata;
       vptr : ptrvfld;
       i:integer;
       srchRow : IdType;
       Foundit : Boolean;
       dbfldptr : ptrdbfield;
       bfldptr : ptrdata;
       hdata : hnddata;
       fldsnip : idtype;
       errnum : integer;
       uplen : integer;
       oldoffset : integer;
       Rarray : Array [0..maxrun] of run;
       numruns : integer;
       startbold,endbold: integer;
       oldaction : integer;
       runptr : ptrruns;
       len1,len2,len3 : integer;
       fbold : boolean;
       buf1Snip,
       buf2Snip,
       buf3snip: idtype;
       bptrh,
       bptr2h,
       bptr3h : hnddata;
       bptr3 : ptrdata;
       buf1size : integer;
       buf2size : integer;





   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,LSrch);

   buf1size := bufsize;
   buf2size := bufsize;
   GetSnipBlock(buf1Snip,buf1size,Status);
   GetSnipBlock(buf2Snip,buf2size,Status);

   bptrh := POINTER(ORD(SniptoPtr(Buf1Snip)));
   bptr2h := POINTER(ORD(SniptoPtr(Buf2Snip)));
   {Now initialize the table information for this table}
   CurTable := TSearch;
   TableChars := ListChars;  {Load in a known set of parameters, to which we
                             can make a few modifications to correspond to
                             the new table characteristics.}

   WITH TableChars DO
      BEGIN
      ColRangeOK := FALSE;
      RectRgOK := FALSE;
      TableInfo := TableChars;
      RowHandles := FALSE;
      RowGridHandles := FALSE;
      END;

   Tabledata.RowTitleWidth := 10;
   {Generate the set of spec table column snips}
   MakeColSpecSnips;

   {Sometimes, we need to make modifications to the colspec snips necessary for
   this particular table. In this case, however, no modifications
   are necessary.}

   {Loop through all of the col spec snips and transfer information to list.
   Must remember that any operation which changes the value in a snip could
   cause all snips to relocate, consequently the snip pointers must constantly
   be reset.}
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      IF Trace2MMgr then
         BEGIN
         WRITELN('row, col: ', row:4, column:4);
         END;

      SpecColId := Column;
      SetSnipPtr(ColKind,SpecColId);
      ListColId := ColSnip^.ListSnip;
      SpecColSnip := ColSnip;
      SetSnipPtr(ColKind,ListColId);
      ListColSnip := ColSnip;

      SpecColSnip^.fieldinfo.options := ListColSnip^.fieldinfo.options;

      {continue to loop}
      Column := SpecColSnip^.NextSnip;

      END; {while column}



  {Now create one empty row }
  BlankRow('',TRUE,SrchRow,Status);
  BlankRow('',TRUE,RunRow,Status);

  {unhook it from the list}
  setsnipPtr(rowkind,SrchRow);
  rowsnip^.nextsnip := nullsnip;

  with tabledata do
    begin
    bottomrow := srchrow;
    lastrow := srchrow;
    end;

  setsnipPtr(rowkind,runrow);
  rowsnip^.priorsnip := nullsnip;


  {loop thru triples }

  TripleIndex := 0;
  While TripleIndex < NumTriples do
     BEGIN {step thru triples}
     IF ExprHnd^^[tripleIndex].action = ex_And then
        BEGIN
        {Skip it}
        TripleIndex := TripleIndex + 1;
        END
     ELSE
        BEGIN
        len := 0;
        case ExprHnd^^[tripleIndex].action of
            ex_eq:
                  BEGIN
                  bptrh^^[0] := ORD('=');
                  len := 1;
                  END;
            ex_ne:
                  BEGIN
                  bptrh^^[0] := ORD('<');
                  bptrh^^[1] := ORD('>');
                  len := 2;
                  END;
            ex_lt:
                  BEGIN
                  bptrh^^[0] := ORD('<');
                  len := 1;
                  END;
            ex_gt:
                  BEGIN
                  bptrh^^[0] := ORD('>');
                  len := 1;
                  END;
            ex_le:
                  BEGIN
                  bptrh^^[0] := ORD('<');
                  bptrh^^[1] := ORD('=');
                  len := 2;
                  END;
            ex_ge:
                  BEGIN
                  bptrh^^[0] := ORD('>');
                  bptrh^^[1] := ORD('=');
                  len := 2;
                  END;
            otherwise
                  BEGIN
                  IF MMTrap1 THEN MMFatalErr(LogicErr,Lsrch,'');
                  END;

            END; {CASE}


        {Now for this triple loop thru columns looking for the field}

        oplen := len;
        Column := TableData.FirstCol;
        Foundit := FALSE;
        WHILE (Column <> NullSnip )AND (NOT FoundIt) DO
           BEGIN

           SpecColId := Column;
           SetSnipPtr(ColKind,SpecColId);
           ListColId := ColSnip^.ListSnip;
           SpecColSnip := ColSnip;
           SetSnipPtr(ColKind,ListColId);
           ListColSnip := ColSnip;

           IF ListColSnip^.Fieldnum  = ExprHnd^^[tripleIndex + 1].fldid then
              foundit := true
           ELSE
              BEGIN
              {continue to loop}
              Column := SpecColSnip^.NextSnip;
              END;

           END; {while column}

        {found the field, speccolsnip points to the spec col snip }

        {now go after the constant and pack the constants into the blankrow}

        IF MMTrap1 THEN IF column = nullsnip then MMFatalErr(LogicErr,Lsrch, '');

        if cellblank(srchrow,speccolsnip^.snipid) then
           begin
           With ExprHnd^^[tripleindex + 2] do
              BEGIN

              {save old offset}
              oldoffset := listcolsnip^.fieldinfo.offset;
              dbfldptr := @listcolsnip^.fieldinfo;

              {now the correct offset}
              dbfldptr^.offset := desc.offset;

              {unpack from const record }
              unpack(dbfldptr,@bptrh^^[len],Buf1size-len,uplen,ConstHnd^,errnum);
              if errnum = dsptoosmall then
                 begin
                 expsnipblock(buf1snip,uplen+len,Status);
                 buf1size := uplen+len;
                 SetSnipPtr(ColKind,SpecColId);
                 SpecColSnip := ColSnip;
                 SetSnipPtr(ColKind,ListColId);
                 ListColSnip := ColSnip;
                 dbfldptr := @listcolsnip^.fieldinfo;
                 unpack(dbfldptr,@bptrh^^[len],buf1size-len,uplen,ConstHnd^,errnum);
                 IF MMTrap1 THEN if errnum <> 0 then MMFatalErr(Errnum,Lsrch,'Unpack1');

                 end
              else IF MMTrap1 THEN if errnum <> 0 then MMFatalErr(Errnum,Lsrch,'Unpack2');
              len := len + uplen;
              SetSnipPtr(ColKind,SpecColId);
              SpecColSnip := ColSnip;
              SetSnipPtr(ColKind,ListColId);
              ListColSnip := ColSnip;
              dbfldptr := @listcolsnip^.fieldinfo;
              listcolsnip^.fieldinfo.offset := oldoffset;

              {Pack into srchrow}
              PackField(SrchRow, SpecColsnip^.snipid,NIL,bptrh,len,status);
              IF MMTrap1 THEN if status <> 0 then MMFatalErr(Errnum,lsrch,'PackField');

              END;{with}
           SetSnipPtr(ColKind,SpecColId);
           SpecColSnip := ColSnip;
           SetSnipPtr(ColKind,ListColId);
           ListColSnip := ColSnip;
           dbfldptr := @listcolsnip^.fieldinfo;
           if oplen = 0 then
              begin
              setrun(rarray[0],0,false);
              numruns := 1;
              end
           else
              begin
              setrun(rarray[0],0,true);
              setrun(rarray[1],oplen,false);
              numruns := 2;
              end;

           CellRun(MMwrite,srchrow,speccolid,@Rarray,numruns,status);
           IF MMTrap1 THEN if status <> 0 then mmfatalerr(logicerr,lsrch,'cellrun');
           END

        ELSE
           BEGIN {This must be the thru operator}
           {get old value }
           len := buf1size;
           CellValue(MMREAD,srchrow,speccolid,bptrh^,True,len,status);
           if status = cvnotenuff then
              begin
              ExpSnipBlock(Buf1Snip,len,Status);
              buf1size := len;
              CellValue(MMREAD,srchrow,speccolid,bptrh^,True,len,status);
              IF MMTrap1 THEN if status <> 0 then mmfatalerr(status  ,lsrch,'cellvalue1');
              SetSnipPtr(ColKind,SpecColId);
              SpecColSnip := ColSnip;
              SetSnipPtr(ColKind,ListColId);
              ListColSnip := ColSnip;
              end
           else IF MMTrap1 THEN if status <> 0 then mmfatalerr(status  ,lsrch,'cellvalue2');

           numruns := maxrun;
           CellRun(MMREAD,srchrow,speccolid,@rarray,numruns,status);
           IF MMTrap1 THEN if status <> 0 then mmfatalerr(status  ,lsrch,'cellrun');

           {get operator len}
           runptr := @Rarray;
           fbold := bold in runptr^[0].face;
           getaction(Bptrh^,len,fbold,oldaction,oplen,status);
           IF MMTrap1 THEN if status <> 0 then mmfatalerr(status  ,lsrch,'getaction');

           {adjust string}
           moveleft(bptrh^^[oplen],bptrh^^[0],len-oplen);
           len1 := len - oplen;


           {now pack in the new string}
           With ExprHnd^^[tripleindex + 2] do
              BEGIN

              SetSnipPtr(ColKind,SpecColId);
              SpecColSnip := ColSnip;
              SetSnipPtr(ColKind,ListColId);
              ListColSnip := ColSnip;
              dbfldptr := @listcolsnip^.fieldinfo;
              {save old offset}
              oldoffset := listcolsnip^.fieldinfo.offset;
              dbfldptr := @listcolsnip^.fieldinfo;

              {now the correct offset}
              dbfldptr^.offset := desc.offset;

              {unpack from const record }
              unpack(dbfldptr,bptr2h^,Buf2size,uplen,ConstHnd^,errnum);
              if errnum = dsptoosmall then
                 begin
                 ExpSnipBlock(buf2Snip,uplen,Status);
                 buf2size := uplen;
                 SetSnipPtr(ColKind,SpecColId);
                 SpecColSnip := ColSnip;
                 SetSnipPtr(ColKind,ListColId);
                 ListColSnip := ColSnip;
                 dbfldptr := @listcolsnip^.fieldinfo;
                 unpack(dbfldptr,bptr2h^,buf2size,uplen,ConstHnd^,errnum);

                 end
              else IF MMTrap1 THEN if errnum <> 0 then MMFatalErr(Errnum,Lsrch,'Unpack');
              len2 := uplen;



              if oldaction = ex_le then
                 begin
                 {switch pointers}
                 buf3snip := buf2snip;
                 buf2snip := buf1snip;
                 buf1snip := buf3snip;

                 bptr3h := bptr2h;
                 bptr2h := bptrh;
                 bptrh := bptr3h;

                 len3 := len2;
                 len2 := len1;
                 len1 := len3;
                 end
              else
                 begin
                 end;
              {place in the thru string}
              startbold := len1;

              bptr3 := @Thrustring;
              bptr3 := POINTER(ORD(bptr3) + 1);

              if (buf1size < len1+ThruLength) then
                 begin
                 expsnipblock(buf1snip,buf1size+10,Status);
                 buf1size := buf1size+10;
                 SetSnipPtr(ColKind,SpecColId);
                 SpecColSnip := ColSnip;
                 SetSnipPtr(ColKind,ListColId);
                 ListColSnip := ColSnip;
                 dbfldptr := @listcolsnip^.fieldinfo;
                 end;
              moveleft(bptr3^,bptrh^^[len1],ThruLength);

              endbold := startbold + ThruLength;
              len := len1 + ThruLength;

              {move in string2}
              if (buf1size < len1+len2) then
                 begin
                 expsnipblock(buf1snip,buf1size+len2,Status);
                 buf1size := buf1size+10;
                 SetSnipPtr(ColKind,SpecColId);
                 SpecColSnip := ColSnip;
                 SetSnipPtr(ColKind,ListColId);
                 ListColSnip := ColSnip;
                 dbfldptr := @listcolsnip^.fieldinfo;
                 end;
              moveleft(bptr2h^^,bptrh^^[len],len2);
              len := len + len2;

              listcolsnip^.fieldinfo.offset := oldoffset;

              {Pack into srchrow}
              PackField(SrchRow, SpecColsnip^.snipid,NIL,bptrh,len,status);
              IF MMTrap1 THEN if status <> 0 then MMFatalErr(Errnum,lsrch,'PackField');

              END;{with}
           SetSnipPtr(ColKind,SpecColId);
           SpecColSnip := ColSnip;
           SetSnipPtr(ColKind,ListColId);
           ListColSnip := ColSnip;
           With RArray[0] do
              begin
              lpfst := 0;
              font := MMFontinfo.Font.fam;
              face := MMFontinfo.font.seteface - [bold];
              end;
           With RArray[1] do
              begin
              lpfst := startbold;
              font := MMFontinfo.Font.fam;
              face := MMFontinfo.font.seteface + [bold];
              end;
           With RArray[2] do
              begin
              lpfst := endbold;
              font := MMFontinfo.Font.fam;
              face := MMFontinfo.font.seteface - [bold];
              end;

           numruns := 3;
           CellRun(MMwrite,srchrow,speccolid,@Rarray,numruns,status);
           IF MMTrap1 THEN if status <> 0 then mmfatalerr(logicerr,lsrch,'cellrun');
           END;


        TripleIndex := TripleIndex + 3;
        END;{of packing a non and (comp, field , const) series of triples}

     END;{while tripleindex}

  {All done, I think}
  GetAlert(LMALERTS,SearchSpecs,@ListTitle);
  promptString := ListTitle;

  FreSnipBlock(Buf1Snip);
  FreSnipBlock(Buf2Snip);

  END;

