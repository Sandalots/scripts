UNIT lmmat;  {=== EUROPEAN/UNIVERSAL TEXT VERSION ===}
{Copyright 1983,1984, Apple Computer Inc.}
INTERFACE {***********************************************************}

{$SETC SAMPCALLS := FALSE}

{$SETC ForOS := TRUE }
{$DECL IsIntrinsic}
{$SETC IsIntrinsic := TRUE}
{$DECL UTProblems}
{$SETC UTProblems := FALSE}
{$DECL WithUObject}
{$SETC WithUObject := FALSE}

{$IFC NOT WithUObject}
    {$SETC LibraryVersion := 30 } { 10 = 1.0 libraries; 13 = 1.3 libraries; 10 = Pepsi, 30 = Spring, etc. }
{$ENDC}

USES
{$IFC SAMPCALLS}
     {$U  apll/tracecalls.obj} tracecalls,
{$ENDC}
     {$U  unitStd }        UnitStd,
     {$U  unitHz}          UnitHz,
     {$U  storage}         Storage,
     {$U  QuickDraw}       QuickDraw,
     {$U  Fontmgr}         Fontmgr,
     {$U  WMLSTD}          WMLSTD,
     {$U  WMLSB}           WMLSB,
     {$U  dbenv}           dbenv,
     {$U  fedec}           FEdec,
     {$U  Fld.Obj}         FieldEdit,
     {$U  teenv.Obj}       teenv,
     {$U  tm.Obj}          tm,
     {$U  dbdecl1.Obj}     dbdecl1,
     {$U  uunivtext}       UUniversalText,
     {$U  inter.obj}       international,
     {$U  libos/syscall.Obj}     syscall,
     {$U  libos/psyscall.Obj}     psyscall,
     {$U  wm.events.obj}   events,
     {$U  wm.folders.obj}  folders,
     {$U  wm.menus.obj}    menus,
     {$U  alertmgr}        alertmgr,
     {$U  apll/qiunit}          QIUnit,
     {$U  lowlevel.Obj}    lowlevel,
     {$U  pooler.Obj}      pooler,
     {$U  heap.Obj}        heap,
{$IFC PRERELEASE }
     {$U  pstuff.Obj}      pstuff,
{$ENDC }
     {$U  czcompact.Obj}   czcompact,
     {$U  vltree.Obj}      vltree,
     {$U  scan.Obj}        scan,
     {$U  labscan.Obj}     labscan,
     {$U  apll/dbconvert.Obj}   dbconvert,
     {$U  schema.Obj}      schema,
     {$U  libdb/extnsort.Obj}    Extnsort,
     {$U  apll/lmscan.obj}      lmscan,
     {$U  libdb/indexbld}        indexbld,
     {$U  recovery}        recovery,
     {$U  pmdecl}          PmDecl,
     {$U  PrStdInfo  }  PrStdInfo,
     {$U  PrPublic}  PrPublic,
{u}  {$U  scrap}           scrap,
     {$U  unitFile.obj}    unitFile,
     {$U  unitFmt.obj}     unitFmt,
     {$U  unitCs.obj}      UnitCs,
     {$U  unitFF.obj}      unitFF;


{$SetC MMDebug := TRUE}
{$SetC MMSymbols := TRUE}
{$SetC MMDebug := FDbgOK}
{$SetC MMSymbols := FSymOk}

CONST

      {Error constants for error messages in the list manager alert file.
      These constants should map one for one with alert file messages.
      In other words, there should be no messages in the alert file which
      do not correspond to one of the constants below.}

      MaxDBRecSize = 1000;

      {*** Note - dont use 1,2,3,4,or 5. These are used by alert manager}

      LogicErr = 10;
      NoColErr = 11;        {No columns filled in when creating.}
      BadSrchOp = 12;       {Bad search specification.}
      Insert1Err = 13;      {Could not paste any rows at this location.}
      Insert2Err = 14;      {Could not paste all rows at this location.}
      InvDTypeErr = 15;     {Data type is unknown or mistyped.}
      InvSortErr = 16;      {Invalid sort specification.}
      InvVisErr = 17;       {Invalid visibility specification.}
      NoMemErr = 18;        {Not enough memory left.}
      NoRoomErr = 19;       {Not enough space on disc.}

      IOErrErr = 20;        {Read error.}
      OtherDBErr = 21;      {Other I/O error.}
      ColInScrap = 22;      {Column is already in the scrap.}
      NoRowPaste = 23;      {There are no rows to paste.}
      NoColPaste = 24;      {There are no columns to paste.}
      MustPasteCol = 25;    {You must paste the columns back.}
      ColDescr = 26;        {Column Descriptions title.}
      ActShowList = 27;     {Show new list to create.}
      ECLen = 28;           {Edit check too long.}
      ModNoDisc = 30;       {Not enough disc to modify field. - Title error}

      SearchSpecs = 31;     {Search Specifications title.}
      ModNoMem = 32;        {Not enough memory to modify field. - Title error}
      ModErr = 33;          {Unable to modify field.}
      CopyErr = 34;         {Unable to copy another row.}
      PasteErr = 35;        {Unable to paste another row.}
      CutErr = 36;          {Unable to cut another row.}
      UpdateErr = 37;       {Unable to update another row.}
      DisplayErr = 38;      {Unable to display the entire list.}
      AddRowErr = 39;       {Unable to add new row.}

      recbackup = 44;       {Backup - repair now?}
      recunsuccess = 45;    {Recovery was unsuccessful.}
      recbadfile = 46;      {Damaged list - do you want to recover?}
      recwait = 47;         {Wait - list is being recovered.}
      PostNoRoom = 48;      {Ran out of disc space on posting.}
      PostIOErr = 49;       {I/O error while posting.}

      PostOtherErr = 50;    {Unexpected error while posting.}
      IntErr = 52;          {Internal error}
      DiscOpenErr = 53;     {Not enough free disc space to open document}
      InvEchk = 54;         {Invalid edit check}
      MemOpenErr = 55;      {Not enough memory/disc to open list}
      Mem2Err = 56;         {Not enough memory/disc to add another column}
      MaxColErr = 57;       {Cannot create a list with more than 100 columns}
      DiscCreateErr = 58;   {Cannot get enough disc to create list.}
      FontMemErr = 59;      {Not enough memory/disc for smaller font}

      Pagestr = 61;         {'Page' .}
      badkeyinp = 62;       {Selection required for key input.}
      beepit = 63;          {Beep.}
      TooNewErr = 64;       {Version of document is incompatible with software (Newer)}
      SrchTooBig = 65;      {Ran out of room building search criteria.}
      FileErr = 66;         {Inconsistency in the file system}
      WaitSave = 69;        {wait saving the doc}

      prtprop=70;           {print proportional warning}
      printclose = 71;      {print wrong wheel}
      smlbadts = 72;        {type style chosen doesn't match printer}
      smlbadfmt = 73;       {print pref changed so it doesnt match printer}
      acttosee = 74;        {activate to see}
      prPrferr = 75;        {error from pref dialog}
      prInsErr = 76;        {error from instance dialog}
      prBgdTerr = 77;       {Error from Monitor the Printer}
      FieldFull = 78;       {Field is full}
      FldNoMod = 79;        {Can't modify field}

      SelZero = 80;         {Selection zero length}
      ScrapErr = 81;        {Scrap cannot be dellt with}
      NoUndo = 82;          {Last operation cannot be undone}
      InvEdit = 83;         {Invalid edit operation}
      StrRoom = 84;         {Not enough room in display string array}
      RecRoom = 85;         {Not enough room in record}
      RestConf = 86;        {Confirm restructuring}
      WaitCreate = 87;      {Wait for list creation}
      RestWait = 88;        {Wait for list restructuring}
      RestNoDisc = 89;      {Not enough disc space for restructuring}

      RestNoMem = 90;       {Not enough memory for restructuring}
      RestTooBig = 91;      {Target record size too big, cancel operation?}
      RedefTitle = 92;      {Table title for add/delete columns}
      ConfUndo = 93;        {confirm undo all edits}
      RestBackup = 94;      {Advise backup before redefining}
      SortConf = 95;        {Confirm change of sort order}
      ColLenErr = 96;       {Column title may not be longer than 255 characters}
      printugly = 97;       {printing will be ugly -- proportional}
      badwheel = 98;        {font on on typewriter wheel}
      prBgdFerr = 99;       {Error from prbgd after printing}

      SrchSortTitle = 100;  {Title for searched and sorted list}
      SrchTitle = 101;      {Title for searched list}
      SortTitle = 102;      {Title for sorted list}
      FromStr = 103;        {'from'}
      ScrapCutFld = 104;    {Scrap error  fld editor reported}
      ScrapCopyFld = 105;   {Scrap error fld editor reported}
      ScrapOpFailed = 106;  {Scrap operation failed }
      WaitSort = 107;       {List is being reordered...}
      pruglyts = 108;       {prop wheel , typestyle change}
      badwhts  = 109;       {wheel mismatch, typestyle change}
      UndoNotOk = 110;      {not an undoable operation}
      FETab = 111;          {field editor word parsing table}
      fealocerr = 112;      {feallocation failed}
      fenoundo = 113;       {fenotundoable }

      DataType = 114;       {ColSpec datatype row header}
      DataFormat = 115;     {ColSpec data format row header}
      SortOrder = 116;      {ColSpec sort order row header}
      Visible = 117;        {ColSpec visible row header}

      ThruOperator = 118;   {SearchSpecs table THRU operator string}

      SortAsc = 119;        {Sort Order ascending string }
      SortDes = 120;        {Sort Order descending string}

      VisYes = 121;         {Column Visibility on string }
      VisNo = 122;          {Column Visibility off string }

      DTText = 123;         {Data Type 'text' string}
      DTNumber = 124;       {Data Type 'number' string}
      DTDate = 125;         {Data Type 'date' string}
      DTSocSec = 126;       {Data Type 'social security' string}
      DTTelephone = 127;    {Data Type 'telephone' string}
      DTTime = 128;         {Data Type 'time' string}
      DTZipCode = 129;      {Data Type 'zip code' string}
      DTMoney = 130;        {Data Type 'money' string}
      DTTicket = 131;       {Data Type 'ticket' string}

      FmtIsString = 132;    {Format is: string for data format error messages}

      ConvertFile = 133;    {Ask user if he wants to convert file and lose some stuff}
      CvtMktcode = 134;     {Ask user if he wants to convert to another language}
      LMMktCode = 135;      {LMALERT file market code}

      NeedCvtErr = 136;     {Error message}
      ConvWait = 137;       {Conversion wait alert}
      ConvBackup = 138;     {Conversion backup ask alert}
      ConvUnsuccessful = 139;  {Conversion unsuccessul}
      CvtWait = 140;        {CvtEdChk wait alert}

      TooOldErr = 141;      {Document version too old to convert}

      UTHeapProb = 142;     {Document version too old to convert}

      PasteEdChk = 143;     {Edit check problem during paste}
      PasteFailed = 144;    {Paste aborted}
      RgNoMatch = 145;      {Scrap range not compatible with table range}
      PasteRecFull = 146;   {couldn't complete paste cuz record full}
      PasteTechDiff = 147;  {technical difficulties in accessing list for paste}

      ScrapNoRoom = 148;    {not enough room to generate scrap image}
      NoScrapPic  = 149;    {picture was greater than 32K}

      DBCMktCode = 1050;    {DBCALERT file market code}

      {End of constants for list manager alert file}


      {Return status for OpenDocument}
      MMBadData = 1;
      MMNoDisc = 2;
      MMNoMem = 3;
      MMIntErr = 4;
      MMTooNewDoc = 5;
      MMNeedToCvt = 6;
      MMCvtErr = 7;
      MMTooOldDoc = 8;
      MMBadPassWd = 9;

      {***** Error status range corrections *****}
      FEErr = 1000;
      CVTErr = 3102; {dsptoosmall = 3100, rectoosmall = 3101}{pack,unpack}
      DBErr = 3400;

      {$IFC NOT MMDEBUG }
      Trace2MMgr = FALSE;
      TraceMMgr = FALSE;
      MMTrap1 = FALSE;
      MMTrap2 = FALSE;
      TraceLmPrint = FALSE;
      {$ENDC }



TYPE StringType = string[255];
     StrPtrType = ^StringType;

     TableType = (TList,TSearch,TColSpecs,TNone,TCutCols,TCutRows,TCutRectRg);

     {Action types for OpenDocument}
     DocActionType = (MMOpen,MMResume,MMCreate,MMRecover);

     FontDisp = (smallfont, mediumfont, largefont, printfont);
     FOptionType = SET OF FontDisp;

     {Font information record}
     FontRec = RECORD
               Font: TlFntId;
               DMPfont : tlfntid;
               FontOptions : FOptionType;
               CellWidth: INTEGER;
               CellHeight: INTEGER;
               END;



VAR

     {$IFC MMDEBUG }
     TraceMMgr: BOOLEAN;
     Trace2MMgr: BOOLEAN;
     TraceLmPrint: BOOLEAN;
     MMTrap1: BOOLEAN;
     MMTrap2: BOOLEAN;
     {$ENDC }

     {International comparison routine flag initialized in initfex}
     VeryWeak: Boolean;
     MMScrapRg: range;

     SelRg:   Range;                           {universal text selection range}
     UpdRowErr: boolean;                       {error occurred in updaterow during paste}
     IgnoreEdChkErrs: boolean;                 {ignore edit check errs while pasting}
     IgnoreRowFull: boolean;                   {continue pasteing if row too full}
     readutext: TReadUnivText;                 {universal text object}
     uterminator: char;                        {universal text field terminator}
     utextrestart: boolean;                    {restarted reading of utext}

     DocSuspended: BOOLEAN; {Was document suspended?}
     DocPassWord: E_Name;

     CurTable: TableType;     {Currently active table}

     CreatingTable : BOOLEAN;
     RedefiningTable: BOOLEAN;
     ColumnsCut: BOOLEAN;
     RowsCut: BOOLEAN;

     ListTitle: stringtype;

     PromptString: stringtype;

     LFname : str255; {This is not used by the matrix manager, but needs to be here because it is used
                       by both the printing and higher level code. It does not need to be stored
                       when suspending.}

     SnipZone: THz; {Pointer to the storage manager snip zone}

     ErrorList : Boolean;

     Scrolling : Boolean;
     CurRgList : Boolean;

     {Column spec table row pointers}
     TypeRow : Idtype;
     EditCRow : IdType;
     SortRow : IdType;
     VisibleRow : Idtype;

     ThruString : Str40;
     ThruLength : Integer;

     {Refnums for phrase files}
     LMAlerts,
     DBCAlerts : TAlertFile;

     {Time record used to associate the scrap with an open document}
     DocScrapId: Time_Rec;

     {The following font and print information is 'read only' by fexec. In order to set
     this information, an appropriate procedure must be called.}
     MMFontInfo: FontRec;
     MMPrintPreference : TPrRec;

     ToolMarketCode : integer;


   (*********************************************************************************
      Common Interface routines
   **********************************************************************************)
   procedure CellInfo
     (parName      : cellParType;       {which parameter to read/write}
      mode         : IOModeType;        {reading/writing mode flag}
      rowId, colId : idType;            {location of cell}
      var cellRec  : cellRecord         {record to be read/written}
     );

   procedure CellRun
      (mode         : IOmodeType;
       rowId, colId : idType;
       value        : ptrRuns;
       var numRuns,
           status   : integer
      );

   procedure CellValue
     (mode         : IOModeType;        {reading/writing mode flag}
      rowId, colId : idType;            {location of cell}
      value        : ptrData;           {ptr to where chrs are to go}
      wideFlg      : boolean;           {format for wide angle display? }
      var numBytes,                     {max # of chrs /actual # chrs returned}
          status   : integer            {error status number}
     );
(*
   function FinalDataSnip
     (aKind        : SnipKind):idType;  {type of snip : row or column}
*)
   procedure FoldedFormula
     (rowId, colId : idType;            {location of cell}
      formula      : ptrData;           {ptr to formula characters}
      var numBytes : integer            {error status number}
     );

   procedure GetSnipId
     (snip       : snipKind;            {type of information desired: row or column}
      mode       : idModeType;          {mode of information desired: first/last...}
      position   : fract;               {position in [0 .. 1000] for fraction oper}
      refId      : idType;              {reference snip for next/prior oper}
      var snipId : idType               {resulting snip information}
     );

   function LLCountSnips(kind : snipkind; var rg : range):integer;

   function mmBreakSnip
     (aKind : snipKind;
      aSnip : idType
     ) : Boolean;

   procedure mmMapSnip
     (snip          : snipKind;         {type of snip to map}
      oldSnipId     : idType;           {value of snip to be mapped}
      var newSnipId : idType;           {new value of snip after mapping}
      var status    : integer           {mapping status number}
     );

   procedure SetSnipWidth
     (rg         : range;               {range of cells to be operated on}
      width      : integer              {width of those cells}
     );

   function  SnipLT
     (snip     : snipKind;              {type of snips to be tested}
      snipId1,                          {snips to be compared}
      snipId2  : idType
     ) :  boolean;

   function  SnipWidth
     (snip   : snipKind;                {type of information desired}
      snipId : idType                   {snip for which the data is desired}
     ) : integer;                       {width of the snip}
{u}
   procedure SwitchTable
    (scrapTable    : boolean;            {table to switch to}
     var tableinfo : tableRecord);       {table information}

   (**********************************************************************************)


     PROCEDURE AbortCloseDocument;

     PROCEDURE BlankRow(Title: STR40;
                        LinkToTbl: Boolean;
                        VAR Snip: IdType;
                        VAR Status: INTEGER);

     PROCEDURE CalcThumb(Horiz: BOOLEAN;
                         VAR NewPos: INTEGER);

     FUNCTION CellBlank(RowId: IdType;
                        ColId: IdType): BOOLEAN;

     PROCEDURE ChangeColSpecs(VAR CStatus: INTEGER);

     PROCEDURE ChangeSrch(var csstatus : integer; var row,column : idtype);
{u}
     Procedure clearRg(rg:range);

     PROCEDURE CloseDocument;

     FUNCTION CloseOK: BOOLEAN;

     PROCEDURE CreateListFile(FileNamePtr: ptrpathname;
                              VAR Status: INTEGER);

     PROCEDURE CutCols(ColId1: IdType;
                       ColId2: IdType);

     PROCEDURE CutRows(RowId1: IdType;
                       RowId2: IdType);

     PROCEDURE CutTable;

     PROCEDURE GenDataType(DataType: INTEGER;
                           ValuePtr: PtrData;
                           VAR Len: INTEGER);

     PROCEDURE GenSort(Order: INTEGER;
                       Direction: INTEGER;
                       ColId: IdType;
                       ValuePtr: PtrData;
                       VAR Len: INTEGER);

     PROCEDURE GenUniversal(var status:integer);

     PROCEDURE GenVisible(Vis: BOOLEAN;
                          ValuePtr: PtrData;
                          VAR Len: INTEGER);

     PROCEDURE GetCurPosSnip(VAR RowId: IdType;
                             VAR ColId: IdType);

     PROCEDURE GetEchk(Column: IdType; VAR edit:str40);

     PROCEDURE GetSusData(VAR HndSusData: HndData;
                          VAR Len: INTEGER);

     PROCEDURE Init_Strategy;

     PROCEDURE InitPasteRgs(var status: integer);

     PROCEDURE LLPxHcsMtx(index:TB);

     PROCEDURE LLSeqLpdMtx(Lpd: Tlpd; var achad: Tachad);

     PROCEDURE LoadColSpecs(VAR TableInfo: TableRecord);

     PROCEDURE LoadCR;

     PROCEDURE LoadCutCols(VAR TableInfo: TableRecord);

     PROCEDURE LoadCut_RectRg(VAR TableInfo: TableRecord);

     PROCEDURE LoadCutRows(VAR TableInfo: TableRecord);

     PROCEDURE LoadList(VAR TableInfo: TableRecord;
                        ShowLastList: BOOLEAN;
                        SearchList: BOOLEAN;
                        SortList: BOOLEAN);

     PROCEDURE LoadSearch(VAR TableInfo: TableRecord);

     PROCEDURE MMErrFile(Status: INTEGER;
                         VAR ErrFile: TAlertFile;
                         VAR ErrNum: INTEGER);

     PROCEDURE MMFatalErr(Status: INTEGER;
                          CurProc: Str40;
                          CallProc: Str40);

     PROCEDURE MMInit(dbcAlert:TAlertFile; VAR Status: INTEGER);

     PROCEDURE MMPrint;

     PROCEDURE NextCell(Mode: MCType;
                        CurCell: Range;
                        VAR NxtCell: Range);

     PROCEDURE OpenDocument(FileNamePtr: PtrPathName;
                            Action: DocActionType;
                            VAR Status: INTEGER);

     PROCEDURE PasteCols(PriorCol: IdType);

{    PROCEDURE PasteRows(PriorRow: IdType); }

     FUNCTION PasteAbort(lstatus:integer):boolean;

     PROCEDURE PasteCache(var status : integer; ucols : integer; duplicate : boolean);
     PROCEDURE PasteFile(var status : integer; ucols : integer; duplicate : boolean);
     PROCEDURE PasteNew(var status : integer; ucols : integer; duplicate : boolean);

     PROCEDURE PasteDup(row,col : idtype; ucols : integer; var status : integer);

     PROCEDURE PutPrintPrf(PrintInfo: TPrRec);

     PROCEDURE PutTableFont(FontId: TlFntId;
                            CellW: INTEGER;
                            CellH: INTEGER;
                            VAR Status: INTEGER);

     PROCEDURE ReCreateListFile(VAR Status: INTEGER);

     PROCEDURE RelCrgList;

     PROCEDURE RelScrap;

{     PROCEDURE RowError(CurRange: Range); }

     PROCEDURE SetFontOptions(FOptions: FOptionType);

     PROCEDURE SetUserFont(UFont: TlFntId);

     PROCEDURE ShrinkHeap;

     PROCEDURE SuspendDoc;

     PROCEDURE Un_loadCutRectRg(VAR TableInfo: TableRecord);

     PROCEDURE UnloadCutCols(VAR TableInfo: TableRecord);

     PROCEDURE Unload_CutRows(VAR TableInfo: TableRecord);

     PROCEDURE UndoTableEdits(VAR Status: INTEGER);

     PROCEDURE UnPasteCols;

     PROCEDURE UpdateRow;

     PROCEDURE WriteList(VAR Status: INTEGER);





IMPLEMENTATION
{$R-}

{$IFC MMSymbols }
{$D+}
{$ELSEC }
{$D- }
{$ENDC }

{$S matmgr4  }

CONST MxMgr = 'MatMgr';                  {String used to identify module in errors}

      DBBuffers = 7;                     {Number of database intrinsic buffers. Each buffer
                                         requires 2048 bytes.}

      DBHeapSize = 4000;                 {This size has been tested and verified to be big enough
                                         for worst case list manager records - 101 fields, 1000
                                         byte records, without requiring the DB heap to expand. The
                                         absolute worst case is more around 5000, but this will
                                         rarely occur, and in the event that it does, the db
                                         intrinsics will automatically expand the heap, given the
                                         memory and disc resources. The objective here is to provide
                                         enough space such that the heap will never need to expand,
                                         especially during a posting, such that you will never run
                                         out of heap memory or disc space after the user has spent
                                         perhaps hours working on the diff file.}

      DiffFilePages = 3;                 {This number determines how many db pages are left in the
                                         differential file after posting and truncation. It is necessary
                                         to leave a small number so that redisplays work efficiently,
                                         but also such that disc space is not wasted.}

      MaxSnips = 325;                    {Maximum number of snips allowed. This is the minimum necessary
                                         to perform all list manager functions on a 100 column list.}

      MaxCols = 100;                     {Maximum number of columns in a list, not counting ticket field.}

      InitSegPages = 25;                 {Initial number of disc pages in snip segment}
      InitMemPages = 12;                 {Initial number of memory pages in snip segment. The memory
                                         size starts out small to allow more memory for swapping during
                                         the time the document is being opened. More space is not needed
                                         until the list is actually displayed, which is in the final
                                         stages of document opening.}

      BlankCols = 10;                    {Number of initial columns creating}
      MinFreePages = 9;                  {Min number of free pages in suspend
                                         file to release in case you run out
                                         of space during posting. This is
                                         equivalent to 2 database blocks, (8pgs)
                                         since the first page can't be
                                         deallocated.}
      MaxRecSize = 5000;                 {Max size of a row snip record, which is large enough to
                                         contain 100 40 byte edit checks plus some. It is not, however,
                                         large enough to contain the worst case search specification,
                                         so it is possible to get a CellValue error entering huge
                                         search criteria.}

      {Logical data segment assigments}
      IP1LDSN =  3;  {For InitPool}
      SnipLDSN = 4;  {Snip heap also requires 5 to expand into}
      DOLDSN  =  6;  {For DiffOpen - used for sorting, and if possible,
                     should be allowed to expand into 14,15, etc...}


      {File name suffixes. Warning - the ListSuffix is not currently used,
      because it is null. If this suffix is ever to be non-null, the code
      will have to be modified to use this suffix. However, all of the other
      suffixes may be changed by simply changing their value here.}
      ListSuffix = '';
      DiffSuffix = '$D';
      Temp1Suffix = '$D1';
      Temp2Suffix = '$D2';
      RedunSuffix = '$R';
      SuspendSuffix = '$S';
      HeapSuffix = '$H';
      NewSuffix = '$New';


      {Error status code for ChkCurRg}
      NotInRg = 1;

      {Error status code for ReadListForm}
      BadLForm = 1;

      maxTriples = 20;
      maxConst=100;
      maxVisRows = 20;
      ColExpansion = 20;

      ColWidth = 100;
      maxcolwidth = 719;
      mincolwidth = 7;
      RowWidth = 12;

      recExpand = 10;


      MaxSetSize = 14;   {((MaxCols +15) div 16)*2}
      MaxIntWdSize = 6;  {MaxSetSize div 2 -1}

      {Code/Version types for information blocks in the data file label. These codes serve a dual
      purpose. Each code designates a particular type of information which is stored in the
      database label records. When opening a file, all possible information is set to defaults.
      Then the information is read in, and whatever codes are found which the software recognizes
      are used to override the appropriate defaults. The result is that information which is not
      recognized by the software is not used, and defaults result. This mechanism is intended to
      also solve the problem when a particular type of information is changed, such that the new
      block would not be recognized by old software. In this case, the new information should be
      assigned a new unique code/version number. For example, if the font information should change,
      then change the font code to the next higher available number, in this case #8. If you then
      open a file created with the new format using old software, the old software will not recognize
      the new code and consequently will use defaults for the font information. Conversely, when the
      new software opens an old file, it would ignore the old font information and substitute a
      default in the new format. If you wanted to add the code, you could also convert an old format
      into a new. One disadvantage is that when you open a new file with old software, any new
      unrecognized formats will be lost and defaults substituted when a new form is written out
      when the list is closed. However, this seems to be a more flexible approach than just refusing
      to open the list at all.}
      LstFormCode = 100;
      NoCode = 0;
      WidthCode = 1;
      SortCode = 2;
      VisCode = 3;
      SearchCode = 4;
      OrderCode = 5;
      FontCode = 6;
      PrintCode = 7;

      {These version numbers were incremented by 1 for the international version.}

      SCurVersion = 106; {This is the version number of the suspend information.
                         If the format of the suspend record should change, it
                         is absolutely necessary to increment this number, so
                         that existing suspended files will be recognized as
                         being written by incompatible software.}       {+1 for spring}

      ListVersion = 1; {This is the version number of the list. In the event that the format of information
                       changes so drastically that the individual information block version strategy will
                       not work or is impractical, this number may be incremented to cause lists which
                       are created with new software to be unopenable on older software.}

      UTMaxCols = 45;     { max number of tabs for tab table  }
      UTMaxChrs = 1000;  { max number of chars in a row (very generous) }
      LeftMarg = 90;     {for universal text : left margin }




TYPE ColSnipRecord = RECORD
                     RecSize: INTEGER;    {Size of the col snip descriptor record}
                     SnipId: IdType;      {Snip Id}
                     SnipType: SnipKind;  {Kind of snip - row or column}
                     NextSnip: IdType;    {SnipId of next column}
                     PriorSnip: IdType;   {SnipId of prior column}
                     ListSnip : Idtype;   {SnipId of the corresponding List snip}
                     Order: INTEGER;      {Snip order for sniplt}
                     Width: INTEGER;      {Width of column in pixels}
                     MiscId: IdType;      {Miscellaneous at different times}
                     NewColumn: BOOLEAN;  {Has column been created yet?}
                     FieldNum: INTEGER;   {Field number of column}
                     SortOrder: INTEGER;  {Sort order of column}
                     SortDirection: INTEGER; {Sort direction}
                     Visible: BOOLEAN;    {Is column visible}
                     freebytes: integer;  {number of available bytes}
                     FieldInfo: dbfield;  {Field descriptor record}
                     END;

     RowSnipRecord = RECORD
                     RecSize: INTEGER;  {Size of the row snip descriptor record}
                     SnipId: IdType;      {Snip Id}
                     SnipType: SnipKind;  {Kind of snip - row or column}
                     NextSnip: IdType;
                     PriorSnip: IdType;
                     handoffset: integer;     {integer offset to lmhandle  .}
                     dbrecsize: integer;   {current length of dbrecord}
                     freebytes: integer;   {number of bytes free for expansion}
                     RowTitle: INTEGER; {Offset to title, if there is one}
                     bitoffset : integer;
                     ErrorCode : integer;
                     Data: INTEGER; {Offset to actual record}
                     {Variable length data follows}
                     END;

     TabInfoRecord = RECORD                  {Global information about table}
                     ColTitAlign: INTEGER;   {Alignment of column title}
                     RowTitAlign: INTEGER;   {Alignment of row titles}
                     RowHeight: INTEGER;     {Height of each row in pixels}
                     ColCount: INTEGER;      {Number of Columns}
                     FirstCol: IdType;  {Points to first column}
                     LastCol: IdType;   {Points to last column}
                     FirstRow: IdType;  {Points to first row}
                     LastRow: IdType;   {Points to last row}
                     TopRow: IdType;    {Points to topmost row}
                     BottomRow: IdType; {Points to bottommost row}
                     rowtitlewidth : integer ; {width of rowtitles in pixels}
                     coltitleheight : integer ; {height of coltitles in pixels}
                     END;

    {FirstRow, ... Last Row Point to the first and last entries in the
    linked list of snips.  They are used to return the appropriate ids when
    GetSnipId (First,Last) is called.  In the case of FirstRow and LastRow,
    these will be set to null if the record does not happen to reside in
    memory. See ref n810615p4.}

    {Top and Bottom rows are snipids of the topmost and bottommost rows in memory.
    They are necessary for scanning forward and back, as well as garbage
    collection. See ref N810615p5.}

    {This type record contains information to keep a list of deleted columns}
    CutColRecord = RECORD
                   ColCount: INTEGER;
                   FirstCol: IdType;
                   LastCol: IdType;
                   END;

    {This type record contains information to keep a list of deleted rows}
    CutRowRecord = RECORD
                   FirstRow: IdType;
                   LastRow: IdType;
                   END;

    ptrrowsnip = ^ RowSnipRecord;
    ptrcolSnip = ^ ColSnipRecord;

    DataArea = ARRAY[0..0] OF INTEGER; {Snip storage area}
    ptrDataArea = ^DataArea;

    handexpr = ^ ptrexpr;
    handconst = hnddata;
    HeaderPtr = ^Header;

    {Following types are used in suspending and resuming}
    BlockCode = (MGlobals,MSnip,Fexec);

    SuspHeader = RECORD
                 Code: BlockCode;
                 Len: INTEGER;
                 SnipId: IdType;
                 END;

    SuspendRecord = RECORD
                    {The first set of variables are in the interface}
                    CurTable: TableType;     {Currently active table}
                    CreatingTable : BOOLEAN;
                    ColumnsCut: BOOLEAN;
                    RowsCut: BOOLEAN;
                    ListTitle: stringtype;
                    PromptString: stringtype;
                    SizeRowTitle: Integer;
                    LFname : str40;       {This is no longer used. However, it is being left in for now
                                          so that suspended stationary created by Pubs will be OK}
                    DocPassWord: E_Name;

                    ErrorList : Boolean;
                    Scrolling : Boolean;
                    CurRgList : Boolean;
                    TypeRow : Idtype;
                    EditCRow : IdType;
                    SortRow : IdType;
                    VisibleRow : Idtype;
                    DocScrapId: Time_Rec;
                    MMPrintPreference: TPrRec;
                    MMFontInfo: FontRec;

                    {The next set of variables are in the implementation}
                    SnipMap: ARRAY[1..MaxSnips] OF INTEGER;
                    FreeSnipList: IdType;
                    TableData: TabInfoRecord;
                    TableChars: TableRecord;
                    ListTable: TabInfoRecord;
                    ListChars: TableRecord;
                    ColSpecData: TabInfoRecord;
                    ColSpecChars: TableRecord;
                    CutCol: CutColRecord;
                    CutRow: CutRowRecord;
                    MMScrapRg: Range;
                    TableCut: BOOLEAN;
                    ListHeader: Header;
                    ScanOpen: boolean;
                    ScanId:Integer;
                    BlankLine: BOOLEAN;
                    BlankHandle: LMHandle;
                    RowChanged: IdType;
                    ListRowCount: LONGINT;
                    ListModified: BOOLEAN;
                    SchemaChanged: BOOLEAN;
                    ListFormChanged: BOOLEAN;
                    SortValid: BOOLEAN;
                    SortPtr: PtrIDesc;
                    NSKeys: INTEGER;
                    CSKeys: INTEGER;
                    SortArray: ARRAY[0..MaxCols] OF ISegment;
                    SearchValid: BOOLEAN;
                    NumTriples: INTEGER;
                    ConstSize: INTEGER;
                    Constsnip : Idtype;
                    Exprsnip : Idtype;
                    RunRow : Idtype;
                    NullNA : Array [0..MaxIntWdSize] of Integer;
                    CurRgSnip : IDtype;
                    InsertAtTop : Boolean;
                    ListScrollValid: Boolean;
                    ListTopHandle: LmHandle;
                    HScrollId: IdType;
                    BytesAdded: LONGINT;
                    RedefiningTable: BOOLEAN;
                    DelCol: CutColRecord;
                    CopyListColumns: CutColRecord;
                    ColumnsDeleted: BOOLEAN;
                    SVersion: INTEGER; {Version # of suspend information}
                    Sorted: BOOLEAN;
                    SortRequested: BOOLEAN;
                    Searched: BOOLEAN;
                    SearchRequested: BOOLEAN;
                    MagCaution: BOOLEAN;
                    END;

  {universal text}
  UTinfo = record  { all unit-global information  }

        NumTabs :     integer;    { number of elements in the Tabs[] array }
        LCFont:       TFam;
        ThisRow:      integer ;    { most recent row already built; initialized to -1,
                                       indicating that no row has yet been built}
        RowIndx:      integer;     {index Seqldpmtx uses to keep track of rows}
        Tabs:         array [ 0 .. UTMaxCols ] of TTbd ;
        end;

  UTChars = array[0..0] of byte;
  UTCharsPtr = ^UTChars;
  UTCharsHdl = ^UTCharsPtr;

  UTTabs = array[0..0] of TTbd;
  UTTabsPtr = ^UTTabs;
  UTTabsHdl = ^UTTabsPtr;


VAR {SnipMap contains integers which when added to the address of the
    start of the snip zone, yield the address of the snip. This way the
    pointer to a snip block may be stored in one word rather than two.}
    SnipMap: ARRAY[1..MaxSnips] OF INTEGER;

    FreeSnipList: IdType;      {Points to first in free snip list in snipmap}

    BlankLine: BOOLEAN;
    RowChanged: IdType;

    TableData: TabInfoRecord;  {Contains table info of currently active table.}
    TableChars: TableRecord;
    ListTable: TabInfoRecord;
    ListChars: TableRecord;
    ColSpecData: TabInfoRecord;
    ColSpecChars: TableRecord;

    {Structures to support cutting rows and columns}
    CutCol: CutColRecord;
    DelCol: CutColRecord;
    ColumnsDeleted: BOOLEAN;
    CutRow: CutRowRecord;
    TableCut: BOOLEAN;

    {Place to keep copy of list snips during list restructuring}
    CopyListColumns: CutColRecord;

    ListHeader: Header;          {File label header information}

    {The next set of variables are pointers which are set directly to
    the location in memory where the snips reside so that access to the
    components of the record are not so indirect.}

    RowSnip: ptrRowSnip; {Pointer to set to actual location}
    ColSnip: ptrColSnip;

    SaveColNext: IdType;
    SaveRowNext: IdType;

    {Scan Data Structures }
    ScanOpen: boolean;
    ScanId:Integer;
{   BlankLine: BOOLEAN;}
    BlankHandle: LMHandle;
    ListRowCount: LONGINT;
    ListModified: BOOLEAN;
    SchemaChanged: BOOLEAN;
    ListFormChanged: BOOLEAN;
{u} Convert: BOOLEAN;
    CvtEditChk: Boolean;

    {Files necessary for scans}
    FilePName: pathname;   {Data file}
    DiffPName: pathname;   {Differential file}
    Temp1PName: pathname;  {Temporary for sorts}
    Temp2PName: pathname;  {Another temporary for sorts}

    {Sort data structures}
    Sorted: BOOLEAN;
    SortRequested: BOOLEAN;
    SortValid: BOOLEAN;
    SortPtr: PtrIDesc;
    NSKeys: INTEGER;
    CSKeys: INTEGER;
    SortArray: ARRAY[0..MaxCols] OF ISegment;

    {Search data structures}
    Searched: BOOLEAN;
    SearchRequested: BOOLEAN;
    SearchValid: BOOLEAN;
    ExprHnd: handExpr;
    NumTriples: INTEGER;
    ConstHnd: HandConst;
    ConstSize: INTEGER;
    Constsnip : Idtype;
    Exprsnip : Idtype;
    RunRow : Idtype;

    {stuff for diffs }

    NullNA : Array [0..MaxIntWdSize] of Integer;

    CurRgSnip : IDtype;
    InsertAtTop : Boolean;

    {Saved handle for saving scroll position}
    ListScrollValid: Boolean;
    ListTopHandle: LmHandle;
    HScrollId: IdType;

    {Print stuff}
    Printing: BOOLEAN;
    MMPrintDefault: TPrRec;

    {Suspend file stuff}
    SuspRefNum: INTEGER;
    SuspFreeBytes: LONGINT;
    BytesAdded: LONGINT;

    {Snip data structure stuff}
    SegPtr : ptrDataArea; {pointer to snip data segment area}
    MMCallingMakeSpace: BOOLEAN; {Tells makespace who is calling}
    LoadingSnips: BOOLEAN; {Tells makespace not to try to free up snips}
    ZoneSize: LONGINT; {Current size of snip zone}
    SegMemSize: LONGINT; {Current memory size of snip data segment}
    SegDiscSize: LONGINT; {Current disc size of snip data segment}
    SegRefNum: INTEGER; {Refnum of data segment}
    StatusMakeSpace: INTEGER; {Set by MakeSpace when failure to expand data segment occurs}

    FexecBlock: TH; {Pointer to the fexec suspend info block}
    FBlockLen: INTEGER; {Length of fexec suspend block}

    {Misc}
    MagCaution: BOOLEAN;
    Bell: Char;

    {universal text}
    UTScrapRg : range;
    UTCharWidth : integer;
    UTCharCount : integer;              {number of characters to be taken by stream}
    UTCharsTaken : integer;             {number of characters already taken by stream mechanism}
    UTinforec : UTinfo;                 {"LCM" record}
    UTChhandle : UTcharshdl;            {handle off which the character stream is accessed}
    UTTabhandle : UTtabshdl;            {handle off which the tab descriptors are accessed}
    UTHalfDxMin : integer;              {Half of lotus's 'dxMinTab', rounded up if necessary
                          NB: twice this is used instead of dxMinTab everywhere, as bulletproofing
                              against the chance that someday dxMinTab may turn out to be an odd number } {+}
{$IFC MMDEBUG}
    UTTabChars : integer;
    UTTabStops : integer;
    UTRowCount : integer;
{$ENDC}

    {ColSpecs Row Header Vars}
    SizeRowTitle: Integer; {Number of characters in colspec table row header}
    DTypHeader: Str40;  {Data Type row header for colspec table}
    DFmtHeader: Str40;  {Data Format row header for colspec table}
    SortHeader: Str40;  {Sort Order row header for colspec table}
    VisiHeader: Str40;  {Visibility row header for colspec table}

    SrtAscString: String[20];   {Sort Order Ascending String}
    SrtDesString: String[20];   {Sort Order Descending String}

    VisYesString: String[20];   {Column Visibility on String}
    VisNoString:  String[20];   {Column Visibility off String}

    DTTextString: String[20];   {Data Type string for 'text'}
    DTNumbString: String[20];   {Data Type string for 'number'}
    DTDateString: String[20];   {Data Type string for 'date'}
    DTSocSString: String[20];   {Data Type string for 'social security'}
    DTTeleString: String[20];   {Data Type string for 'telephone'}
    DTTimeString: String[20];   {Data Type string for 'time'}
    DTZipCString: String[20];   {Data Type string for 'zip code'}
    DTMonyString: String[20];   {Data Type string for 'money'}
    DTTcktString: String[20];   {Data Type string for 'ticket'}



(**************************FORWARDS*****************************)

PROCEDURE AddBlank(VAR RowId: IdType); FORWARD;

PROCEDURE BoldTypedOps(value:ptrdata;Rarray:ptrruns;sindex1:integer;
                       len1:integer;VAR newnumruns,status:integer); FORWARD;

PROCEDURE CellV(Mode: IOModeType;
                RowId:  IdType;
                ColId:  IdType;
                Value:  PtrData;
                HValue: HndData;
                WideFlg: BOOLEAN;
                VAR Length:  INTEGER;
                VAR Status: INTEGER); FORWARD;
(*
PROCEDURE CellVH(Mode: IOModeType;
                 RowId:  IdType;
                 ColId:  IdType;
                 ValueH:  hndData;
                 WideFlg: BOOLEAN;
                 VAR Length:  INTEGER;
                 VAR Status: INTEGER); FORWARD;
*)
PROCEDURE CheckDataType(VAR DataType: INTEGER;
                        ValuePtr: PtrData;
                        Len: INTEGER;
                        VAR Status: INTEGER); FORWARD;
{$IFC MMDEBUG }
PROCEDURE CheckSnipId(SnipType: SnipKind;
                      SnipId: IdType); FORWARD;
{$ENDC}
PROCEDURE CheckSort(VAR Order: INTEGER;
                    VAR Direction: INTEGER;
                    ValuePtr: PtrData;
                    Len: INTEGER;
                    VAR Status: INTEGER); FORWARD;

PROCEDURE CheckVisible(VAR Vis: BOOLEAN;
                       ValuePtr: PtrData;
                       Len: INTEGER;
                       VAR Status: INTEGER); FORWARD;

PROCEDURE ChkCurRg(hand:lmhandle;
                   where :idmodetype;
                   var snipid : idtype;
                   var status: integer); FORWARD;

PROCEDURE CopyColSnips(FirstCol: IdType;
                       LastCol : IdType;
                       PriorCol : IdType;
                       VAR FirstCopyCol: IdType;
                       VAR LastCopyCol: IdType); FORWARD;

PROCEDURE CreateSchemaForm(VAR FormId: IdType); FORWARD;

PROCEDURE CutColSnips(VAR HeadCol: IdType;
                      VAR TailCol: IdType;
                      FirstCol: IdType;
                      LastCol: IdType); FORWARD;

PROCEDURE CutRowSnips(VAR HeadRow: IdType;
                      VAR TailRow: IdType;
                      FirstRow: IdType;
                      LastRow: IdType); FORWARD;

PROCEDURE CvtEdChk(formid:idtype;
                   fldindx:integer;
                   columnid:idtype;
                   var status:integer); FORWARD;

PROCEDURE DeleteDocFiles(FileName: PathName); FORWARD;

PROCEDURE DBAlert(ErrNum: INTEGER;
                  DBStatus: INTEGER); FORWARD;

PROCEDURE DelColAttr(colsptr:ptrcolsnip;
                     initoffset: integer); FORWARD;
{$IFC MMDEBUG }
PROCEDURE DUMPCol(Tit: STR40;
                  ColPtr: PtrData); FORWARD;

PROCEDURE DumpCols(ColId: IdType); FORWARD;

PROCEDURE dumpcrglist; FORWARD;

PROCEDURE DumpField(Ptr: PtrData); FORWARD;

PROCEDURE DumpHeader(Ptr: PtrData); FORWARD;

PROCEDURE DumpRow(RowPtr: PtrData); FORWARD;

PROCEDURE DumpRows(RowId: IdType); FORWARD;

PROCEDURE DumpTB; FORWARD;
{$ENDC}
FUNCTION EnoughDisc(MoreBytes: INTEGER): BOOLEAN; FORWARD;

FUNCTION EnoughMemory(NumColumns: INTEGER;
                      CellHeight: INTEGER): BOOLEAN; FORWARD;

PROCEDURE ExpSnipBlock(SnipId: IdType;
                       NewSize: INTEGER;
                       VAR Status: INTEGER); FORWARD;

FUNCTION FileSuspended(DataFileName: PathName;
                       VAR FStatus: INTEGER): BOOLEAN; FORWARD;

Procedure FindpctCol (pct:fract;VAR snipid:idtype); Forward;

Procedure FindpctRow(pct:fract;VAR snipid:idtype); Forward;

PROCEDURE FreSnipBlock( SnipId: IdType); FORWARD;

PROCEDURE GenEdit(Edit: StrPtrType;
                  ValuePtr: PtrData;
                  VAR Len: INTEGER); FORWARD;

PROCEDURE GenListForm(VAR SnipId: IdType); FORWARD;

PROCEDURE GenNewSorts; FORWARD;

Procedure getaction(value: ptrdata;
                    length: integer;
                    itsbold : boolean;
                    var action: integer;
                    var oplen: integer;
                    var status : integer); FORWARD;

function GetLLCUTRow(var rowindex:integer):boolean; FORWARD;

procedure GetNxtVisCol(VAR RId: IdType); FORWARD;

PROCEDURE GetOptions(DataType: INTEGER;
                     VAR Options: elemset); FORWARD;

procedure GetPrvVisCol(VAR RId: IdType); FORWARD;

FUNCTION GetRecSize: INTEGER; FORWARD;

PROCEDURE GetSnipBlock(VAR SnipId: IdType;
                       ByteSize: INTEGER;
                       VAR Status: INTEGER); FORWARD;

PROCEDURE InitSnipPtr(snipType: SnipKind;
                     snipId : IdType); FORWARD;

PROCEDURE InitTabRecords; FORWARD;

PROCEDURE InsertColSnips(VAR HeadCol: IdType;
                         VAR TailCol: IdType;
                         PriorCol: IdType;
                         FirstCol: IdType;
                         LastCol: IdType); FORWARD;

PROCEDURE InsertRowSnips(VAR HeadRow: IdType;
                         VAR TailRow: IdType;
                         PriorRow: IdType;
                         FirstRow: IdType;
                         LastRow: IdType); FORWARD;

Function  isbold(numruns:integer;
                 runptr:ptrruns;
                 pos:integer;
                 var lastvalidrun : integer ):boolean; FORWARD;

Function ListCardinality:longint; Forward;

PROCEDURE MakeColSpecSnips; FORWARD;

PROCEDURE MakeListFormChanges(FormId: IdType); FORWARD;

Function MakeSpace(hz: THz;
                   cbNeed: Integer): INTEGER; FORWARD;

PROCEDURE MarksRevenge(var result : integer;
                       var warnings : elemset;
                       lsid : integer); FORWARD;

PROCEDURE MMInitFiles; FORWARD;

PROCEDURE NewCSCol(ListColId: IdType;
                   VAR CSColId: IdType); FORWARD;

PROCEDURE NewListCol(VAR NewColId: IdType;
                     ColOrder: INTEGER); FORWARD;

PROCEDURE PackCSCol(Column: IdType); FORWARD;

PROCEDURE PackField ( RowId:  IdType;
                      ColId:  IdType;
                      val:  PtrData;
                      hval: HndData;
                      VAR Length:  INTEGER;
                      VAR Status: Integer); FORWARD;
(*
PROCEDURE PackFldH ( RowId:  IdType;
                     ColId:  IdType;
                     val:  HndData;
                     VAR Length:  INTEGER;
                     VAR STatus : integer); FORWARD;
*)
Procedure parsesrch (value: ptrdata;
                    length: integer;
                    runptr : ptrruns;
                    numruns : integer;
                    var numstr :integer;
                    var sindex1 :integer;
                    var sindex2 : integer;
                    var len1 : integer;
                    var len2 : integer;
                    var status : integer); FORWARD;

PROCEDURE PrepColumns; FORWARD;

FUNCTION PtrToSnip(HeapPtr:TH): IdType; FORWARD;

PROCEDURE ReadListForm(DBScanId: INTEGER;
                       VAR SnipId: IdType;
                       VAR Status: INTEGER); FORWARD;

PROCEDURE ReCalcOffsets(rsnip:ptrrowsnip;
                        colsnipchg:idtype;
                        initoffset:integer;
                        delta:integer); FORWARD;

PROCEDURE ReCalcSortOrders(ColId: IdType;
                           VAR NewOrder: INTEGER); FORWARD;

PROCEDURE RecoverList(LFName: PathName;
                      VAR Status: INTEGER); FORWARD;

PROCEDURE ReleaseColSnips; FORWARD;

PROCEDURE ReleaseRowSnips; FORWARD;

PROCEDURE ReleaseSnips(Snip: SnipKind;
                       SnipId: IdType); FORWARD;

PROCEDURE ReOrderColumns(VAR FirstCol: IdType;
                         VAR ColCount: INTEGER); FORWARD;

PROCEDURE SaveCr; FORWARD;

PROCEDURE SaveScroll; FORWARD;

PROCEDURE SrchTWrite(Mode: IOModeType;
                     RowId:  IdType;
                     ColId:  IdType;
                     Value:  PtrData;
                     WideFlg: BOOLEAN;
                     VAR numbytes:  INTEGER;
                     VAR Status: INTEGER); FORWARD;

PROCEDURE StripBlanks(DataPtr: PtrData;
                      VAR Len: INTEGER); FORWARD;

PROCEDURE SetFieldAttr(ColId: IdType;
                       Attr: INTEGER;
                       Value: PtrData;
                       Len: INTEGER); FORWARD;

procedure setrun(var thisrun:run;fstpos:integer;itsbold:boolean); Forward;

procedure SetSnipPtr(snipType: SnipKind;
                     snipId : IdType); Forward;

Procedure setuprec(rsnip:ptrrowsnip;
                   snipid : idtype;
                   len:integer;
                   setsize:integer;
                   usererror:integer;
                   errbitptr : ptrdata;
                   var status : integer ); Forward;

PROCEDURE setuptriple(tripleindex : integer;
                      strptr : ptrdata;
                      strlen:integer;
                      itsbold : boolean;
                      listsnip,specsnip,row:idtype;
                      countcomp:integer;
                      VAR foffset, voffset,cumsize,cumvsize, status : integer); FORWARD;

PROCEDURE setupandtriple(tripleindex,lasttriple,lastlasttriple:integer); Forward;

FUNCTION SnipToPtr(SnipId:Idtype) : TH; FORWARD;

PROCEDURE SwitchToList; FORWARD;

PROCEDURE SwitchFromList; FORWARD;

FUNCTION VarField(ptrcs: ptrcolsnip): BOOLEAN; FORWARD;

PROCEDURE WritListForm(FileName: PathName;
                       VAR FormId: IdType); FORWARD;



{*****************************End Forwards ************************}



{**************************** Externals ***************************}
PROCEDURE ClearScrap(status:integer);EXTERNAL;

PROCEDURE DoFldrUpdate;EXTERNAL;

PROCEDURE FatalError(module:str40; proc:str40; msg:str40);EXTERNAL;

PROCEDURE LoadTable( rowband,colband:tmband);EXTERNAL;

PROCEDURE PrintList; EXTERNAL;

PROCEDURE PutSusData(VAR HndSusData: HndData;
                     VAR Len: INTEGER); EXTERNAL;

PROCEDURE SaveTable(var rowband,colband:tmband);EXTERNAL;

procedure WriteLLCUT (tblCharWid : integer; Tblfntid : TLfntid; var status : integer );EXTERNAL;

{***************************** End Externals ***********************}

{$S lmlist  }
PROCEDURE AddBlank{VAR RowId: IdType};

   {This procedure adds a blank line to the end of the differential file if necessary.}

   LABEL 500;

   CONST ABlank = ' AddBlank ';

   VAR BlankId: IdType;
       PtrHandle: ^LmHandle;
       DataPtr: PtrData;
       Status: INTEGER;
       EvenRecordSize: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Trace}
   IF TraceMMGR then WriteLn(MxMgr,ABlank);

   {Note - should not have to check for ScanOpen because Addblank should
   never be called until an EOS is encountered, which implies the scan is open.}
   IF MMTrap1 THEN IF NOT ScanOpen THEN WriteLn(Bell,'***Scan not open');

   {Set RowId to indicate end of table here, so we can exit out from
   several places without having to set it each time.}
   RowId := PInfSnip;

   IF BlankLine OR ErrorList THEN Exit(AddBlank);

   {Make sure there is enough spare disc space available}
   IF NOT EnoughDisc(ListHeader.RecSize) THEN
      BEGIN
      DBAlert(AddRowErr,NoRoom);
      GOTO 500; {Error cleanup}
      END;

   {Add the blank row to the row snip list}
   BlankRow('',TRUE,BlankId,Status);
   IF Status <> 0 THEN
      BEGIN {Ran out of either memory or disc space for snip data segment.}
      DBAlert(AddRowErr,Status); {Status is either NoRoom or NoMem}
      GOTO 500; {Error cleanup}
      END;

   {Add one to the recordsize if necessary to make it even, since the
   database intrinsics require this. We do not have to worry that one
   extra byte is read at the end, because procedure BlankRow just
   allocated a bunch of slack bytes there.}
   SetSnipPtr(RowKind,BlankId);
   EvenRecordSize := Rowsnip^.DBRecSize;
   IF Odd(EvenRecordSize) THEN EvenRecordSize := EvenRecordSize + 1;

   {Now add the new row to the differential file}
   {NOTE!! LMInsert will insert the blank record after the current of
   scan. At the time of this writing, procedure AddBlank is only called
   after EOS has been reached. If AddBlank ever starts adding records in
   places other than the end of the file, then AddBlank will have to be
   modified to position to the end of the file before calling LMInsert.}

   DataPtr := POINTER(ORD(RowSnip) + RowSnip^.HandOffset);
   LmInsert(Status,ScanId,DataPtr,EvenRecordSize);
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***AddBlank LMInsert status: ',status);
      DBAlert(AddRowErr,Status);

      {Cut the row out of list}
      WITH TableData DO CutRowSnips(TopRow,BottomRow,BlankId,BlankId);

      {Release the snip }
      FreSnipBlock(BlankId);

500:  {Now tie off the end of the data structures so that we don't keep trying to add a row}
      WITH TableData DO
         BEGIN
         IF TopRow = NullSnip THEN {No other rows}
            BEGIN
            FirstRow := PInfSnip;
            LastRow := MInfSnip;
            END
         ELSE LastRow := BottomRow;
         END;

      {Return end of table status}
      RowId := PInfSnip;
      EXIT(AddBlank);
      END;


   BlankLine := TRUE;
   PtrHandle := @DataPtr^;
   BlankHandle := PtrHandle^;
   WITH TableData DO
      BEGIN
      BottomRow := BlankId;
      IF FirstRow = BlankId THEN TopRow := BlankId;
      END;
   RowId := BlankId;

   {Since this is the new last row in the file, the list cardinality may be updated.}
   ListRowCount := PtrHandle^.High;
   END;



{$s lmclosedoc}
PROCEDURE AbortCloseDocument;

   CONST ACD = ' AbortCloseDocument ';

   VAR Status: INTEGER;
       RecSize: INTEGER;
       DummySet: ARRAY [0..MaxIntWdSize] OF INTEGER;
       UserError: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF MMTrap1 THEN WriteLn(Bell,MxMgr,ACD);

   {This procedure is only called when the list manager has terminated abnormally.
   Consequently, the strategy will be to close down the data files so that they
   will not require a recovery. The differential file is closed in an unposted
   state, because attempting to do the post at this time could run into trouble.
   The fact that the posting has not been done will be recognized when the document
   is reopened, and the posting will be done at that time, when hopefully the
   system is in better shape and more likely to survive such an operation.

   {However, we will try to remove the blank line, if there is one. Don't
   bother to check status, because we are already in trouble.}
   IF NOT CreatingTable THEN
      BEGIN
      IF BlankLine THEN
         BEGIN
         {Fetch it}
         LMFetch(Status,UserError,@DummySet,ScanId,Exact,BlankHandle,RecSize);
         IF MMTrap1 THEN IF Status > 0 THEN WriteLn(Bell,ACD,'LMFetch status: ',Status);

         {Delete it}
         LMDelete(Status,ScanId);
         IF MMTrap1 THEN IF Status > 0 THEN WriteLn(Bell,ACD,'LMDelete status: ',Status);
         END;

      {Close the differential and data file with updates unposted}
      DiffDestroy(Status,ScanId);
      IF MMTrap1 THEN IF Status > 0 THEN WriteLn(Bell,ACD,'DiffDestroy status: ',Status);
      END; {Not CreatingTable}

   {Close the suspend file}
   Close_Object(Status,SuspRefNum);
   IF MMTrap1 THEN IF Status > 0 THEN WriteLn(Bell,ACD,'Close_Object status: ',Status);

   {Close the snip data segment}
   Close_DataSeg(Status,SegRefNum);
   IF MMTrap1 THEN IF Status > 0 THEN WriteLn(Bell,ACD,'Close_DataSeg status: ',Status);

   {Thats all we will try to do}
   END;




{$S lmcolspec }
PROCEDURE AddCol(VAR Status: INTEGER);

   CONST AC = ' AddCol ';

   VAR ListCol: IdType;
       CSCol: IdType;
       Column: IdType;
       Row: IdType;
       NewFieldSize: INTEGER;
       VDataLength: INTEGER;
       OldVData: PtrData;
       NewVData: PtrData;
       VFieldPtr: ^VFld;
       OldBitEnd: PtrData;
       NewBitEnd: PtrData;
       SetSpace: INTEGER;
       OldSetSize: INTEGER;
       NewSetSize: INTEGER;
       FieldOffset: INTEGER;
       LStatus: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,AC);
   Status := 0;

   {See if there are any deleted columns which may be reused}
   IF ColumnsDeleted THEN
      BEGIN
      IF Trace2MMgr THEN WriteLn('Reusing deleted column');
      {Cut the column out of the column list}
      WITH TableData DO
         BEGIN
         CutColSnips(FirstCol,LastCol,Delcol.FirstCol,DelCol.FirstCol);
         END;

      WITH DelCol DO
         BEGIN
         {Remember the field offset}
         SetSnipPtr(ColKind,FirstCol);
         FieldOffset := ColSnip^.FieldInfo.Offset;

         {Get rid of the column snip}
         FreSnipBlock(FirstCol);

         {Update the deleted column range}
         IF FirstCol = LastCol THEN ColumnsDeleted := FALSE
         ELSE FirstCol := TableData.FirstCol;
         END;

      {Create a default colspec column snip}
      NewCSCol(NullSnip,CSCol);

      {Put in the offset of the old column}
      SetSnipPtr(ColKind,CSCol);
      ColSnip^.FieldInfo.Offset := FieldOffset;

      {Link column into the table column snips}
      WITH TableData DO
         BEGIN
         InsertColSnips(FirstCol,LastCol,LastCol,CSCol,CSCol);

         {Reorder the columns}
         ReOrderColumns(FirstCol,ColCount);
         END;

      {Pack all of the cells with colspec info}
      PackCSCol(CSCol);

      {All Done}
      Exit(AddCol);
      END; {ColumnsDeleted}


   {Check that max columns not exceeded}
   IF TableData.ColCount >= (MaxCols) THEN
      BEGIN
      IF CautionAlert(LMAlerts,MaxColErr) THEN;
      Status := MaxColErr;
      EXIT(AddCol);
      END;

   {Make sure there is enough memory/disc for new column}
   IF NOT EnoughMemory(TableData.ColCount + 1,MMFontInfo.CellHeight) THEN
      BEGIN
      IF CautionAlert(LMAlerts,Mem2Err) THEN;
      Status := Mem2Err;
      EXIT(AddCol);
      END;


   {Create a new colspec column}
   NewCSCol(NullSnip,CSCol);

   {Link the new colspec column into the list.}
   WITH TableData DO
      BEGIN
      InsertColSnips(FirstCol,LastCol,LastCol,CSCol,CSCol);
      ColCount := ColCount + 1;

      {Reorder the columns}
      ReOrderColumns(FirstCol,ColCount);

      {check to see if the error bitmap must be expanded}
      OldSetSize := ((ColCount - 1 + 15) DIV 16) * 2;
      NewSetSize := ((ColCount + 15) DIV 16) * 2;
      IF NewSetSize > OldSetSize THEN SetSpace := 2 ELSE SetSpace := 0;
      END;

   {Now, all row snips must be expanded by an amount
   equal to the size of the new column.}
   NewFieldSize := 4;
   Row := TableData.FirstRow;
   WHILE Row <> NullSnip DO
      BEGIN
      SetSnipPtr(RowKind,Row);
      IF RowSnip^.FreeBytes < (NewFieldSize + SetSpace) THEN
         BEGIN {Expand the row snip}
         ExpSnipBlock(Row,RowSnip^.RecSize + NewFieldSize + SetSpace,LStatus);
         SetSnipPtr(RowKind,Row);
         WITH RowSnip^ DO
            BEGIN
            RecSize := RecSize + NewFieldSize + SetSpace;
            FreeBytes := FreeBytes + NewFieldSize + SetSpace;
            END;
         END;

      {Shift everything past the bitmap down if necessary}
      IF SetSpace <> 0 THEN WITH RowSnip^ DO
         BEGIN
         OldBitEnd := POINTER(Ord(RowSnip) + BitOffSet + OldSetSize);
         NewBitEnd := POINTER(Ord(OldBitEnd) + 2);
         MoveRight(OldBitEnd^,NewBitEnd^,DBRecSize);
         FreeBytes := FreeBytes - 2;
         ClearSet(OldBitEnd,16);
         HandOffSet := HandOffSet + 2;
         Data := Data + 2;
         END;


      {Shift all variable length data down to make
      room for the new column field.}
      SetSnipPtr(ColKind,CSCol);
      VDataLength := RowSnip^.DBRecSize - SizeOf(PreAmble)
                     - ColSnip^.FieldInfo.Offset;
      OldVData := POINTER(Ord(RowSnip) + RowSnip^.Data
                  + ColSnip^.FieldInfo.Offset);
      NewVData := POINTER(Ord(OldVData) + NewFieldSize);
      MoveRight(OldVData^,NewVData^,VDataLength);

      {Adjust the various counts in the row snip}
      WITH RowSnip^ DO
         BEGIN
         FreeBytes := FreeBytes - NewFieldSize;
         DBRecSize := DBRecSize + NewFieldSize;
         END;

      {For each column, adjust the offsets of the variable fields.
      When the new column is reached, initialize it.}
      Column := TableData.FirstCol;
      WHILE Column <> NullSnip DO
         BEGIN
         SetSnipPtr(ColKind,Column);
         VFieldPtr := Pointer(Ord(RowSnip) + RowSnip^.Data
                      + ColSnip^.FieldInfo.Offset);

         IF Column = CSCol THEN
            BEGIN
            VFieldPtr^.Offset := RowSnip^.DBRecSize - SizeOf(PreAmble);
            VFieldPtr^.Size := 0;
            END

         ELSE VFieldPtr^.Offset := VFieldPtr^.Offset + NewFieldSize;

         Column := ColSnip^.NextSnip;
         END;

      Row := RowSnip^.NextSnip;
      END; {while row <> nullSnip}

   {Now pack all cells of the column with colspec info}
   PackCSCol(CSCol);

   END;


{$S lmopendoc }
PROCEDURE AdjustTableToFont(CellW: INTEGER;
                            CellH: INTEGER);

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' AdjustTableToFont ');
   WITH TableData DO
      BEGIN
      ColTitleHeight := Cmin(CBitMapV,(CellH + (CellH DIV 2)));
      RowHeight := CellH;
      RowTitleWidth := CellH;
      END;
   END;


{$S lmres2 }
PROCEDURE BlankRecord(Buffer: PtrData);

   CONST BR = ' BlankRecord ';

   VAR RecSize: INTEGER;
       Column: IdType;
       NextCol: IdType;
       VFieldPtr: ^VFld;
       FieldPtr: PtrDBField;
       Delta: INTEGER;
       ErrNum: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,BR);

   {Get the record Size}
   RecSize := GetRecSize;

   {Loop through all the columns and initialize the fields}
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      NextCol := ColSnip^.NextSnip;

      IF VarField(ColSnip) THEN
         BEGIN
         VFieldPtr := Pointer(Ord(Buffer) + ColSnip^.FieldInfo.Offset);
         with VFieldPtr^ do
           begin
           Size := 0;
           Offset := RecSize; {Must point at end of record}
           end;
         END

      ELSE BEGIN
           FieldPtr := @ColSnip^.FieldInfo;
           Pack(0,FieldPtr,Nil,0,Buffer,1000,RecSize,Delta,ErrNum);
           IF MMTrap1 THEN IF ErrNum <> 0 THEN WriteLn(Bell,'***',BR,'Pack status: ',ErrNum);
           END;

      Column := NextCol;
      END;

   END;



{$S lmres2  }
PROCEDURE BlankRow{Title: STR40;
                   LinkToTbl: boolean;
                   VAR Snip: IdType;
                   VAR Status: INTEGER};

   {This procedure is used to create blank row snips It also will add in a title to
    the row snip.  The id of the snip is returned.}
   {If linktotbl flag is TRUE, link snip into table; if not, just create snip - AF}

   CONST BlkRow = ' BlankRow ';

   VAR RecordSize: INTEGER;
       Expansion: INTEGER;
       SnipSize: INTEGER;
       NewSnipId: IdType;
       NextFree: INTEGER;
       BytePtr: PtrData;
       VFieldPtr: ^Vfld;
       SortId: LMHandle;
       SortIdPtr: ^LMHandle;
       I: INTEGER;
       TitleLength: INTEGER;
       PreAmbSize: INTEGER;
       SetSize : INTEGER;
       FieldPtr: PtrDBField;
       RecPtr: PtrData;
       MaxRecSize: INTEGER;
       DeltaSize: INTEGER;
       Column: IdType;
       HeadSnip: idType;
       TailSnip: idtype;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Trace}
   IF TraceMMGR then WriteLn(MxMgr,BlkRow);

   {First compute the necessary size}
   SetSize := ((TableData.ColCount + 15) div 16) * 2;
   PreAmbSize := SIZEOF(PreAmble);
   IF CurTable = TList THEN RecordSize := ListHeader.RecSize
   ELSE RecordSize := TableData.ColCount * 4;
   Expansion := RecExpand;   {Additional space to add values}
   Snipsize := SIZEOF(RowSnipRecord)
               + SetSize
               + LENGTH(Title) + 1
               + PreAmbSize
               + RecordSize
               + Expansion;

    {Now get the row snip}
    GetSnipBlock(NewSnipId,SnipSize,Status);
    IF Status <> 0 THEN Exit(BlankRow); {Status is passed up}
    Snip := NewSnipId;

    {Initialize the snip}
    InitSnipPtr(RowKind,NewSnipId);
    NextFree := SIZEOF(RowSnipRecord); {First place to put stuff}
    WITH RowSnip^ DO
       BEGIN
       RecSize := SnipSize;
       SnipId := NewSnipId;
       SnipType := RowKind;
       NextSnip := NullSnip;      {Will be linked in later}
       PriorSnip := NullSnip;     {Will be linked in later}
       DBRecSize := RecordSize + PreAmbSize;   {data base record size}
       FreeBytes := Expansion;

       {Move in the title and offset}
       IF Trace2MMgr THEN WriteLn('title/ offset move');
       RowTitle := NextFree;
       BytePtr := POINTER(ORD(RowSnip) + RowTitle);
       TitleLength := LENGTH(Title) + 1;
       MOVELEFT(Title,BytePtr^,TitleLength);
       NextFree := NextFree + TitleLength;

       IF Trace2MMgr THEN WriteLn('odd address correction');
       IF Odd(ORD(RowSnip) + NextFree) THEN
          BEGIN
          NextFree := NextFree + 1;
          FreeBytes := FreeBytes - 1;
          END;

       {now the error bitmat}
       IF Trace2MMgr THEN WriteLn('error bitmap');
       BitOffset := NextFree;
       BytePtr := Pointer(ORD(rowsnip) + bitOffset);
       clearset(byteptr,TableData.colcount);
       errorcode := noerr;
       NextFree := NextFree + SetSize;

       {Since the dfile id is computed from the id of the snip on the end of
       the list, this id is not computed until later on. However, for now,
       the offset may be filled in. Since the database intrinsics require the
       preamble to start on an even byte, this adjustment is done if necessary.}
       IF Trace2MMgr THEN Writeln('Handle offset fillin');
       IF Odd(ORD(RowSnip) + NextFree) THEN
          BEGIN
          NextFree := NextFree + 1;
          FreeBytes := FreeBytes - 1;
          END;
       HandOffset := NextFree;
       NextFree := NextFree + PreAmbSize;
       END; {With RowSnip^ DO}

    {Initialize data area to a blank record}
    RowSnip^.Data := NextFree;
    BlankRecord(Pointer(Ord(RowSnip) + RowSnip^.Data));

    if LinkToTbl then
      begin

      {Now link it in to the row snip linked list}
      IF TableData.TopRow <> NullSnip then
        BEGIN  {Link it in to the current list}
        {First modify next pointer of current end of list, and get out sort id}
        SetSnipPtr(RowKind,tabledata.bottomrow);
        RowSnip^.NextSnip := NewSnipId;
        SortIdPtr := POINTER(ORD(RowSnip) + RowSnip^.HandOffset);
        SortId := SortIdPtr^;

        {Now fix up prior link of new snip, and construct sort id}
        SetSnipPtr(RowKind,NewSnipId);
        RowSnip^.PriorSnip := tabledata.bottomrow;
        SortIdPtr := POINTER(ORD(RowSnip) + RowSnip^.HandOffset);
        SortId.High := SortId.High + 1;
        SortIdPtr^ := SortId;

        {Now fix up the pointers to end of list}
        WITH TableData DO
          begin                                { then reset the tabledata structure      }
          BottomRow := NewSnipId;
          LastRow := NewSnipId;
          end;

        end
      else
        begin     {this is the first snip on the list}

        WITH TableData DO
           BEGIN
           FirstRow := NewSnipId;
           TopRow := NewSnipId;
           LastRow := NewSnipId;
           BottomRow := NewSnipId;
           END;

        {Construct the sort id}
        SortIdPtr := POINTER(ORD(RowSnip) + RowSnip^.HandOffset);
        with SortIdPtr^ do
          begin
          High := 1;
          Low := 0;
          end;
        end;
      end;

   END;


{$S lmsearch}
PROCEDURE BoldTypedOps{value:ptrdata;Rarray:ptrruns;sindex1:integer;
                       len1:integer;VAR newnumruns,status:integer};
   VAR

      i : integer;
      action,
      oplen,
      gastatus : integer;
      thruptr : CompStrP;
      valstr : CompStr;
      valptr : CompStrP;
      vptr : ptrdata;
      stoppt : integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if tracemmgr then writeln('boldtypedops');
   thruptr := @thrustring;
   getaction(@value^[sindex1],len1,true,action,oplen,gastatus);
   if trace2mmgr then
       writeln('after getaction call - oplen: ',oplen:4, 'sindex1: ' ,sindex1:4);

   if oplen > 0 then
      begin
      {found an operator at the beginning}

      {create runs}

      setrun(Rarray^[0],0,true);
      setrun(Rarray^[1],sindex1+oplen,false);
      newnumruns := 2;

      status := 0;

      end
   else
      begin
      {no leading operator, either none or thru}
      valptr := @valstr;
      vptr := @valstr;

      {check for thru}
      stoppt := sindex1 + len1 - thrulength;
      i := sindex1;
      while i <= stoppt do
        begin
        moveleft(value^[i],vptr^[1],thrulength);
        vptr^[0] := thrulength;
        if CompStrMagnitude(valptr,thruptr,veryweak) = 0 then
          begin
          {create runs}
          if trace2mmgr then writeln('found thru ');
          setrun(Rarray^[0],0,false);
          setrun(Rarray^[1],sindex1+i+1,true);
          setrun(Rarray^[2],sindex1+i+thrulength-1,false);
          newnumruns := 3;
          status := 0;
          exit(boldtypedops);
          end;
        i := i+1;
        end;

      {out of for loop and didn't find it}
      status := -1;
      newnumruns := 0;

      end;

   END;



{$S lmres}
PROCEDURE CalcThumb{Horiz:BOOLEAN;
                    VAR NewPos:iINTEGER};

   {This procedure returns the proper position of the horizontal or
   vertical elevator, given the current table view.}

   CONST CT = ' CalcThumb ';

   VAR TopSnip: IdType;
       LeftSnip: IdType;
       ptrh : ptrlmhandle;
       thispos : longint;
       Column: IdType;
       CurPt: Point;
       VisRg: Range;

    FUNCTION LeftAligned: BOOLEAN;
       {This function returns true if the leftmost column is left aligned.}
       VAR Band: TMBand;
       BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
       TMSaveBands;
       TMSaveNextBand(Band);
       IF Band.TMBKind = RowKind THEN TMSaveNextBand(Band);
       IF Band.TMBHideP = 0 THEN LeftAligned := TRUE ELSE LeftAligned := FALSE;
       END;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,CT,'Horiz: ',Horiz);
   {Get point in current view}
   TMCurVwPt(CurPt);
   IF Trace2MMgr THEN WriteLn('H: ',CurPt.H,' V: ',CurPt.V);
   {Get currently visible range}
   VisRgOfView(CurPt,VisRg);
   WITH VisRg DO
      BEGIN
      TopSnip := LoRow;
      LeftSnip := LoCol;
      END;
   IF Trace2MMgr THEN WriteLn('TopSnip: ',TopSnip,' LeftSnip: ',LeftSnip);

   IF Horiz THEN
      BEGIN {Horizontal scrolling}
      {See if first visible column is showing.}
      Column := TableData.FirstCol;
      IF Column <> NullSnip THEN
         BEGIN
         SetSnipPtr(ColKind,Column);
         IF NOT ColSnip^.Visible THEN GetNxtVisCol(Column);
         END;
      IF Trace2MMgr THEN WriteLn('FirstColumn: ',Column);

      IF ((LeftSnip = Column)    {Is first visible column showing...}
         AND LeftAligned)        {...and left aligned?}   (*SnipAllInBand(ColKind,CurPt.H,LeftSnip)*)
      OR (Column = NullSnip) {No columns}
      OR (Column = PInfSnip) {No Visible Columns}
      OR (LeftSnip = NullSnip)
      OR (LeftSnip = MInfSnip)
      THEN NewPos := 0

      ELSE BEGIN {Elevator not set to 0}
           {If there is any gray showing, peg elevator to bottom}
           IF GrayOfBand(ColKind,CurPt.H) <> 0 THEN NewPos := 1000

           ELSE BEGIN {Elevator not 0 or 1000}
                SetSnipPtr(ColKind,LeftSnip);
                ThisPos := ColSnip^.Order;
                NewPos := ((ThisPos-1) * 1000) DIV (TableData.ColCount - 1);
                {Allow for minimum space at left and right of elevator.}
                IF NewPos < 30 THEN NewPos := 30
                ELSE IF NewPos > 970 THEN NewPos := 970;
                END; {Elevator not 0 or 1000}
           END; {Elevator not 0}
      END {Horizontal scrolling}

   ELSE BEGIN {Vertical scrolling}
        IF Trace2MMgr THEN WriteLn('FirstRow: ',TableData.FirstRow);
        IF ((TopSnip = TableData.FirstRow)             {Is first row is showing...}
           AND SnipAllInBand(RowKind,Curpt.V,TopSnip)) {...and completely visible?}
        OR (TableData.TopRow = NullSnip) {No Rows}
        OR (TopSnip = NullSnip)
        OR (TopSnip = MInfSnip)
        THEN NewPos := 0

        ELSE BEGIN {Elevator not set to 0}
             {If there is any gray showing, peg elevator}
             IF GrayOfBand(RowKind,CurPt.V) <> 0 THEN NewPos := 1000

             ELSE BEGIN {Elevator not set to 0 or 1000}
                  setsnipptr(rowkind,TopSnip);
                  ptrh := POINTER(ORD(rowsnip) + Rowsnip^.handoffset);
                  thispos := ptrh^.high;
                  thispos := ((thispos - 1)* 1000);
                  if listcardinality > 1 then thispos := thispos div (listcardinality - 1);
                  NewPos := thispos;

                  {Allow for minimum space at top and bottom of elevator.}
                  IF NewPos < 20 THEN NewPos := 20
                  ELSE IF NewPos > 980 THEN NewPos := 980;
                  END; {Elevator not set to 0 or 1000}
              END; {Elevator not  set to 0}
        END; {Vertical scrolling}
   IF Trace2MMgr THEN WriteLn('NewPos: ',NewPos);
   END;



{$S lmres }
FUNCTION CellBlank{RowId: IdType;
                   ColId: IdType): BOOLEAN};

   {CellBlank returns true if the cell indicated by the column and row
   identifiers is blank, that is, has a length of zero. Fields which contain
   all blanks should not be possible, since they are stripped out on entry. }

   CONST CBlank = ' CellBlank ';
         MaxString = 1; {Don't need to get value, just length if nonzero}


   VAR  Len : integer;
        Status : integer;
        Value : ptrdata;
        valArray : Array [0..MaxString] of Byte;



   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,CBlank);
   Len := MaxString;
   Value := @ValArray;
   CellV(MMRead,rowId,colId,Value,NIL,True,Len,Status);
   IF MMTrap1 THEN IF (Status <> 0)
   AND (Status <> dsptoosmall) AND (Status <> CVNotEnuff) THEN
      BEGIN
      WriteLn(Bell,'***CellV status: ',status);
      END;

   IF len = 0 then CellBlank := TRUE ELSE CellBlank := FALSE;

   END; {Function CellBlank}





{$I apll/lmmat2.text}
{$I apll/lmmat3.text}
{$I apll/Lmmat4.text}
{$I apll/Lmmat5.text}
{$I apll/Lmmat6.text}
{$I apll/Lmmat7.text}
{$I apll/Lmmat8.text}
{$I apll/Lmmat9.text}
{$I apll/Lmmat10.text}

{$S lminit}

END.

