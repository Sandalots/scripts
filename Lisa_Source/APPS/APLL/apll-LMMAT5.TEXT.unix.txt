{$S lmopendoc }
FUNCTION FileSuspended{(DataFileName: PathName;
                        VAR FStatus: INTEGER)    : BOOLEAN};

   LABEL 500,800,900,950;

   CONST S = ' FileSuspended';

   VAR FCursor: LONGINT;
       BCursor: LONGINT;
       Count: LONGINT;
       Actual: LONGINT;
       Header: SuspHeader;
       HeapBlock: TH;
       Status: INTEGER;
       Length: INTEGER;
       SetSize: INTEGER;
       ClosedNormal: BOOLEAN;
       SuspendData: SuspendRecord;
       I: INTEGER;
       DeltaSize: LONGINT;
       NewSegSize: LONGINT;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,S);

   {Error strategy: All failures to resume the document are covered up,
   and the function simply pretends in this case that the file was not
   suspended. This is because in case of an error, there is no recourse
   but to destroy the suspend information anyway, so we might as well do
   it automatically. The only exception to this is if we fail to get a
   data segment large enough to handle the list - in this case an error
   status is returned, and the calling procedure OpenDocument will report
   a lack of disc space and throw up an alert message.}
{u}
   {Set function false here, so we can exit out in case of trouble,
   in which case we will simply pretend that the file was not suspended.}
   FileSuspended := FALSE;
   FStatus := 0;
   Convert := FALSE;
   CvtEditChk := FALSE;

   {Read the first code and length. Suspend file should already be open.}
   FCursor := 0;
   Count := 4;
   Read_Data(Status,SuspRefNum,ORD(@Header),Count,Actual,Absolute,FCursor);
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn(Bell,'***FS; First Read_Data status: ',status);
      GOTO 800;
      END;

   {First block should be MGlobals}
   IF Header.Code <> MGlobals THEN
     BEGIN
     IF MMTrap1 THEN Writeln(Bell,'***FS; Header.Code <> MGlobals');
     GOTO 800;
     END;

   {Make sure size of information is same as size of suspend record. If
   not, it may mean the software version has changed.}
   Count := SizeOf(SuspendRecord);
   IF Trace2MMgr THEN WriteLn('Suspend record length: ',Count);
   IF Count <> (Header.Len - 4) THEN
      BEGIN
      IF MMTrap1 THEN WriteLn(Bell,'***FS; Suspend record length incompatible with data');
      GOTO 800;
      END;

   {Read into suspend record}
   BCursor := FCursor + 4;
   Read_Data(Status,SuspRefNum,ORD(@SuspendData),Count,Actual,Absolute,BCursor);
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***FS; Read_Data status: ',Status);
      GOTO 800;
      END;

   {First check the version number of the suspend information to make sure
   that it was written by this version of the software.}
   IF SuspendData.SVersion <> SCurVersion THEN
      BEGIN
      IF MMTrap1 THEN WriteLn(Bell,'***FS; This version incompatible with suspend record');
      GOTO 800;
      END;
{u}
   {Check the market code of the suspend information to make sure
   that it matches the market code of the tool.}
   IF SuspendData.ListHeader.MarketCode <> ToolMarketCode THEN
      BEGIN
      IF MMTrap1 THEN WriteLn(Bell,'***FS; The doc market code does not match the tool market code');
      IF (askalert(LMALERTS,CvtMktCode) = 1) THEN FStatus := MMNeedToCvt
      ELSE IF (askalert(LMALERTS,ConvBackup) = 1) THEN FStatus := MMNeedToCvt
           ELSE BEGIN
                CvtEditChk := TRUE;
                GOTO 800;
                END;
      GOTO 950;
      END;

   {Now load up the globals}
   CurTable := SuspendData.CurTable;
   CreatingTable := SuspendData.CreatingTable;
   ColumnsCut := SuspendData.ColumnsCut;
   RowsCut := SuspendData.RowsCut;
   ListTitle := SuspendData.ListTitle;
   PromptString := SuspendData.PromptString;
   SizeRowTitle := SuspendData.SizeRowTitle;
   DocPassWord := SuspendData.DocPassWord;

   ErrorList := SuspendData.ErrorList;
   Scrolling := SuspendData.Scrolling;
   CurRgList := SuspendData.CurRgList;
   TypeRow := SuspendData.TypeRow;
   EditCRow := SuspendData.EditCRow;
   SortRow := SuspendData.SortRow;
   VisibleRow := SuspendData.VisibleRow;
   RedefiningTable := SuspendData.RedefiningTable;
   DocScrapId := SuspendData.DocScrapId;

   {The next set of variables are in the implementation}
   i := 1;
   while i <= maxsnips do
     begin
     SnipMap[i] := SuspendData.SnipMap[i];
     i := i+1;
     end;
   FreeSnipList := SuspendData.FreeSnipList;
   TableData := SuspendData.TableData;
   TableChars := SuspendData.TableChars;
   ListTable := SuspendData.ListTable;
   ListChars := SuspendData.ListChars;
   ColSpecData := SuspendData.ColSpecData;
   ColSpecChars := SuspendData.ColSpecChars;
   CutCol := SuspendData.CutCol;
   CutRow := SuspendData.CutRow;
   MMScrapRg := SuspendData.MMScrapRg;
   TableCut := SuspendData.TableCut;
   ListHeader := SuspendData.ListHeader;

   ScanOpen := SuspendData.ScanOpen;
   ScanId := SuspendData.ScanId;
   BlankLine := SuspendData.BlankLine;
   BlankHandle := SuspendData.BlankHandle;
   RowChanged := SuspendData.RowChanged;
   ListRowCount := SuspendData.ListRowCount;
   ListModified := SuspendData.ListModified;
   SchemaChanged := SuspendData.SchemaChanged;
   ListFormChanged := SuspendData.ListFormChanged;
   SortValid := SuspendData.SortValid;
   SortPtr := SuspendData.SortPtr;
   NSKeys := SuspendData.NSKeys;
   CSKeys := SuspendData.CSKeys;

   i := 0;
   while i <= maxcols do
     begin
     SortArray[i] := SuspendData.SortArray[i];
     i := i+1;
     end;

   SearchValid := SuspendData.SearchValid;
   NumTriples := SuspendData.NumTriples;
   ConstSize := SuspendData.ConstSize;
   ConstSnip := SuspendData.Constsnip;
   ExprSnip := SuspendData.Exprsnip;
   RunRow := SuspendData.RunRow;

   i := 0;
   while i <= MaxIntWdSize do
     begin
     NullNA[i] := SuspendData.NullNA[i];
     i := i+1;
     end;

   CurRgSnip := SuspendData.CurRgSnip;
   InsertAtTop := SuspendData.InsertAtTop;
   ListScrollValid := SuspendData.ListScrollValid;
   ListTopHandle := SuspendData.ListTopHandle;
   HScrollId := SuspendData.HScrollId;
   MMFontinfo := SuspendData.MMFontinfo;
   BytesAdded := SuspendData.BytesAdded;
   DelCol := SuspendData.DelCol;
   CopyListColumns := SuspendData.CopyListColumns;
   ColumnsDeleted := SuspendData.ColumnsDeleted;
   MMPrintPreference := SuspendData.MMPrintPreference;
   Sorted := SuspendData.Sorted;
   SortRequested := SuspendData.SortRequested;
   Searched := SuspendData.Searched;
   SearchRequested := SuspendData.SearchRequested;
   MagCaution := SuspendData.MagCaution;

   {Make sure there is enough memory to operate on this file}
   IF NOT EnoughMemory(TableData.ColCount,MMFontinfo.CellHeight) THEN
      BEGIN
      {All errors are assumed to be failure to get datasegment disc space}
      FStatus := DiscOpenErr;
      GOTO 950;
      END;

   {Now read in the snips}
   FCursor := FCursor + Header.Len;
   WHILE TRUE DO
      BEGIN
      Count := 6;
      Read_Data(Status,SuspRefNum,ORD(@Header),Count,Actual,Absolute,FCursor);
      IF Status <> 0 THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***Snip Read_Data status: ',Status);
         GOTO 900;
         END;

      IF Header.Code <> MSnip THEN GOTO 500;

      {NOTE!!! It is absolutely necessary that the original snip map be
      restored before any snip blocks are restored. Presumably, the only
      thing which changes is the handles of the snips, and the original
      list of free snips should be unaltered.}

      {Allocate a block. Set global LoadingSnips to True in case MakeSpace gets called, so that
      it won't try to go through the snips structures and throw them out.}
      Length := Header.Len - 6;
      IF Trace2MMgr THEN WriteLn('SnipId: ',Header.SnipId,' Length: ',Length);
      LoadingSnips := TRUE;
      HeapBlock := HAllocate(SnipZone,Length);
      LoadingSnips := FALSE;
      IF Ord(HeapBlock) = Ord(HNil) THEN
         BEGIN {Unable to get the space}
         IF MMTrap1 THEN WriteLn(Bell,S,'HAllocate failed, MakeSpace Status: ',StatusMakeSpace);
         FStatus := StatusMakeSpace;
         GOTO 950;
         END;

      {Read the data into the snip block}
      Count := Length;
      BCursor := FCursor + 6;
      Read_Data(Status,SuspRefNum,ORD(@HeapBlock^^),Count,Actual,Absolute,BCursor);
      IF Status <> 0 THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***Read_Data status: ',Status);
         GOTO 900;
         END;

      {Install pointer in original snip id}
      SnipMap[Header.SnipId] := PtrToSnip(HeapBlock);

      {Update the file pointer}
      FCursor := FCursor + Header.Len;
      END;


500:  {The last block had better be the fexec block}
      IF Header.Code <> Fexec THEN GOTO 900;

      {Allocate a block}
      Length := Header.Len - 4;
      IF Trace2MMgr THEN WriteLn('Fexec block length: ',Length);
      LoadingSnips := TRUE;  {Causes MakeSpace not to throw out snips if it is called from HAllocate.}
      FexecBlock := HAllocate(SnipZone,Length);
      LoadingSnips := FALSE;
      IF Ord(FExecBlock) = Ord(HNil) THEN
         BEGIN {Unable to get the space}
         IF MMTrap1 THEN WriteLn(Bell,S,'HAllocate failed, MakeSpace Status: ',StatusMakeSpace);
         FStatus := StatusMakeSpace;
         GOTO 950;
         END;
      FBlockLen := Length;

      {Read the data into the block}
      Count := Length;
      BCursor := FCursor + 4;
      Read_Data(Status,SuspRefNum,ORD(@FexecBlock^^),Count,Actual,Absolute,BCursor);
      IF Status <> 0 THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***Read_Data status: ',Status);
         GOTO 900;
         END;


     {All the data structures should be restored at this point}

     {Next step is to open the data file if necessary}
     IF NOT CreatingTable THEN
        BEGIN
        IF Trace2MMgr THEN WriteLn('Not creatingtable');
        {The file names must be reset, in case a suspended document was copied
        to another prefix. This may be possible if the document was suspended,
        and then the tool is removed. It may also happen if a filer directory
        recovery occurs.}
        FilePName := DataFileName;
        Temp1PName := ConCat(FilePName,'$D1');
        Temp2PName := ConCat(FilePName,'$D2');
        DiffPName := ConCat(FilePName,'$D');

        IF Trace2MMgr THEN WriteLn('Set SetSize...');
        SetSize := ((ListHeader.NFields + 15) DIV 16) * 2;
        IF Trace2MMgr THEN WriteLn('SetSize: ',SetSize);
        IF Trace2MMgr THEN WriteLn('Calling SetSet...');
        WITH TableData,ListHeader DO SetSet(@NullNA,NFields,NFields);

        IF Trace2MMgr THEN WriteLn('Opening differential file...');
        DiffCreate(Status,ScanId,ClosedNormal,DocPassWord,@FilePName,@DiffPName,@NullNA,SetSize);
        IF Trace2MMgr THEN WriteLn('Return from DiffCreate.');
        IF Status <> 0 THEN
           BEGIN
           IF MMTrap1 THEN WriteLn('***DiffCreate status: ',Status);
           GOTO 900;
           END;

        {Make sure the differential file was also suspended}
        IF ClosedNormal AND ScanOpen THEN
           BEGIN
           IF MMTrap1 THEN WriteLn('***Diff file not suspended as expected..');
           DiffDestroy(Status,ScanId);
           GOTO 900;
           END;
        END;

     {Reset some of the global pointers which use actual addresses}
     IF Trace2MMgr THEN WriteLn('Reseting global pointers...');
     SortPtr := @SortArray;
     IF ExprSnip <> NullSnip THEN ExprHnd := POINTER(ORD(SnipToPtr(ExprSnip)))
        ELSE ExprHnd := NIL;
     IF ConstSnip <> NullSnip THEN ConstHnd := POINTER(ORD(SnipToPtr(ConstSnip)))
        ELSE ExprHnd := NIL;

     {Initialize all other variables which must be initialized for each
     document, but which are not written to the suspend file.}
     Printing := FALSE;

     IF Trace2MMgr THEN WriteLn('**Successful resumption**');
     FileSuspended := TRUE;

800: {Set EOF of suspendfile to zero. Otherwise, we will
     try to resume again the next time the file is opened.}
     BCursor := 0;
     Count := 0;
     Read_Data(Status,SuspRefNum,ORD(@Header),Count,Actual,Absolute,BCursor);
     IF MMTrap1 THEN IF NOT (Status IN [0,956]) THEN WriteLn(Bell,'***Read_Data 0,0 status: ',status);
     IF Trace2MMgr THEN WriteLn('Truncating suspend file...');
     Truncate(Status,SuspRefNum);
     IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***Truncate status: ',status);

     Exit(FileSuspended);

900: {Come here in the case of an error which is to be faked as a non-suspend.
     Need to clean up the zone and reinitialize globals}
     MMInitFiles;
     GOTO 800; {Truncate suspend file}

950: {Come here in case of an error, but you want to preserve suspend file}
     END;

(*
{u}
{$S lmscrap}
Function FinalDataSnip{(aKind:SnipKind) : idType};

var idsnip : idType;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  if mmtrap1 then writeln('FinalDataSnip');

  if akind = colkind then
    begin
    Getsnipid(colkind,mmlast,0,idsnip,idsnip);
    FinalDataSnip := idsnip;
    end
  else FinalDataSnip := MMScrapRg.hirow;

end;
*)


{$S lmres }
Procedure FindPctCol{pct:fract;
                     VAR snipid:idtype};

   {Returns the snipid of the column which is the specified percentage of
   the way through the columns. If the closest column is invisible, it returns
   the next higher visible column. If there are no next higher visible columns,
   it returns the next lower visible column. If there are no visible columns, it
   returns PInfSnip}

   LABEL 500;

   CONST FPC = ' FindPctCol';

   VAR Column : Idtype;
       LastVisible: IdType;
       ColOrder: INTEGER;
       TotalColumns: LongInt;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,FPC);
   TotalColumns := TableData.ColCount;
   ColOrder := ((Pct * (TotalColumns - 1)) DIV 1000) + 1;
   {Loop through the visible columns and find one with an order equal}
   LastVisible := PInfSnip;
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      IF ColSnip^.Visible THEN
         BEGIN
         IF ColSnip^.Order >= ColOrder THEN GOTO 500
         ELSE LastVisible := Column;
         END;
      Column := ColSnip^.NextSnip;
      END;

500: IF Column = NullSnip THEN SnipId := LastVisible ELSE SnipId := Column;
   IF TraceMMgr THEN WriteLn(FPC,' returns snipid of: ',SnipId);
   END;



{$S lmlist}
Procedure FindpctRow{pct:fract;VAR snipid:idtype};

   LABEL 500,999;

   Const maxflds = 20;
         FPR = ' FindPctRow ';

   VAR  nthrow : longint;
        ptrhand : ^ lmhandle;
        h,
        shandle  : lmhandle;
        pf : ptrfint8;
        thisrow : ptrrowsnip;
        ErrBits : Array [0..MaxFlds] of Integer;
        UserError : Integer;
        setsize : integer;
        len : integer;
        status : integer;
        cstatus : integer;
        AlertMsg: INTEGER;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if tracemmgr then WriteLn(MxMgr,FPR,' Pct: ',Pct:5,' SnipId: ',SnipId);

   if pct = 0 then
      BEGIN
      IF CurTable = TList THEN SaveCr;
      GetSnipid(rowkind,MMFirst,0,snipid,snipid);
      END

   else if pct = 1000 then
      BEGIN
      IF CurTable = TList THEN SaveCr;
      getsnipid(rowkind,mmlast,0,snipid,snipid);
      IF Trace2MMgr THEN WriteLn(FPR,'Id returned from GSI Last: ',SnipId);
      END

   else
      begin
      if curtable = tlist then
         begin
         {Next operation saves current range and clears out list}
         saveCR;

         {Check to see if scan is open. If not, there should be no rows at all in the cache} {**LM203**}
         IF NOT ScanOpen THEN
            BEGIN
            SnipId := PInfSnip; {Return end of table, since there should be no rows.}
            GOTO 999;
            END;

         {compute desired handle}
         nthrow := 1 + (listcardinality * pct) div 1000;
         pf := @h;
         ptrhand := @h;
         pf^.high := nthrow;
         pf^.low := 0;
         {init set size}
         SetSize := ((TableData.ColCount + 15) div 16) * 2;

         {Try to find the record}
         lmfetch(status,userError,@ErrBits,scanid,exact,ptrhand^,len);
         if (status = eos)   then
            begin
            getsnipid(rowkind,mmlast,0,snipid,snipid);
            GOTO 999;
            end;
         IF MMTrap1 THEN IF (Status <> 0) AND (Status <> NotFound) THEN WriteLn(Bell,'***',FPR,'LMFetch1 status: ',status);

         IF Status = NotFound THEN
            BEGIN {go get the next record}
            lmfetch(status,userError,@ErrBits,scanid,next,shandle,len);
            IF status = EOS then
               BEGIN
               getsnipid(rowkind,mmlast,0,snipid,snipid);
               GOTO 999;
               END;
            IF MMTrap1 THEN IF (Status <>0 ) THEN WriteLn(Bell,'***',FPR,'LMFetch2 status: ',status);
            END;

         IF status <> noerr then GOTO 500;

         {Now we have the record we want.}
         IF curRgList then {see if it is on the current range.}
            BEGIN
            chkCurRg(Pdifftable^[scanid]^.curhandle,MMFIRST,snipid,cstatus);
            IF cstatus = 0 then exit(findpctrow);
            END;

         GetSnipBlock(snipid,len + sizeOf(rowsniprecord)+SetSize + RecExpand,Status);
         IF Status <> 0 THEN
            BEGIN
            IF MMTrap1 THEN WriteLn('***',FPR,'GetSnipblock status: ',Status);
            GOTO 500;
            END;

         InitSnipPtr(rowkind,snipid);
         SetUpRec(rowsnip,snipid,len,setsize,usererror,@ErrBits,status);
         WITH TableData DO {Insert row into list}
         InsertRowSnips(TopRow,BottomRow,NullSnip,SnipId,SnipId);
         END


      else if curtable = tcolspecs then
         begin
         IF (CreatingTable OR RedefiningTable) THEN
            BEGIN
            IF Pct <= 500 THEN SnipId := TypeRow
            ELSE SnipId := EditCRow;
            END
         ELSE BEGIN
              if pct <= 250 then snipid := typerow
              else if pct <= 500 then snipid := editcrow
              else if pct <= 750 then snipid := sortrow
              else snipid := visiblerow;
              END;
         end

      else if curtable = tsearch then
         begin
         getsnipid(rowkind,mmfirst,0,snipid,snipid);
         end;

      end;

999: EXIT(FindPctRow);

500: {Error happened in database or memory procedures}
   {Put up alert box}
   DBAlert(DisplayErr,Status);

   {Set variables to make this appear an empty table}
   SnipId := PInfSnip;
   WITH TableData DO
      BEGIN
      FirstRow := PInfSnip;
      LastRow := MInfSnip;
      END;
   END;


{$S lmmisc  }
procedure FoldedFormula {rowId, colId : idType;            location of cell
                         formula      : ptrData;           ptr to formula characters
                         var numBytes : integer            error status number  };
     BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
     IF TraceMMgr THEN WriteLn(MxMgr,' FoldedFormula ');
     if mmtrap1 then Writeln(bell,'foldedformula called');
     END;


{$S lmres  }
PROCEDURE FRESNIPBLOCK{ SnipId: IdType};

   {This Procedure frees up a snip and deallocates storage for the snip}

   CONST FSB = ' FreSnipBlock';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,FSB,' SnipId: ',SnipId:3);

   {Deallocate Snip Storage}
   FreeBk(SnipZone,SnipToPtr(SnipId),tyBkStd );

   {Put Freed up snip back on Free List}
   SnipMap[snipId] := FreeSnipList;
   FreeSnipList := SnipId;

   END;



{$S lmcolspec }
PROCEDURE GenDataType{DataType: INTEGER;
                         ValuePtr: PtrData;
                         VAR Len: INTEGER};

   CONST GDT = ' GenDataType';

   VAR DataString: STRING[20];
       DataPtr: PtrData;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,GDT);

   CASE DataType OF
      Lets: DataString := DTTextString;
      Num: DataString := DTNumbString;
      Dt: DataString := DTDateString;
      SS: DataString := DTSocSString;
      Ph: DataString := DTTeleString;
      Tim: DataString := DTTimeString;
      Zip: DataString := DTZipCSTring;
      Dol: DataString := DTMonyString;
      Tick: DataString := DTTcktString;
      OTHERWISE  IF MMTrap1 THEN MMFatalErr(LogicErr,GDT,'');
      END;

   Len := LENGTH(DataString);
   DataPtr := @DataString;
   MOVELEFT(DataPtr^[1],ValuePtr^,Len);
   END;



{$S lmcolspec }
PROCEDURE GenEdit{Edit: StrPtrType;
                  ValuePtr: PtrData;
                  VAR Len: INTEGER};

   VAR EditPtr: PtrData;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,' GenEdit ');

   Len := Length(Edit^);
   IF Len > 0 THEN
      BEGIN
      EditPtr := @Edit^;
      MOVELEFT(EditPtr^[1],ValuePtr^,Len);
      END;
   END;



{$S lmclosedoc }
PROCEDURE GenListForm{VAR SnipId: IdType};

   CONST GLF = ' GenListForm';

   TYPE IArray = ARRAY[0..1] OF INTEGER;

   VAR FormSize: INTEGER;
       FormId: IdType;
       FormPtr: ^IArray;
       NextAvail: INTEGER;
       Column: IdType;
       IntArray: ^IArray;
       Order: INTEGER;
       OrderSize: INTEGER;
       WidthSize: INTEGER;
       TripSize: INTEGER;
       SortSize: INTEGER;
       SearchSize: INTEGER;
       VisSize: INTEGER;
       FontSize: INTEGER;
       PrintSize: INTEGER;
       I: INTEGER;
       Status: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,GLF);

   {Count up the sizes of all the pieces to be stored in the form.}
   {Note: Sizes are figured in terms of INTEGERS!}

   {determine size of column information; all the same at this time}
   OrderSize := TableData.ColCount + 2;         {Determine size of column order information}
   WidthSize := OrderSize;                      {Determine size of column width information}
   VisSize := OrderSize;                        {Determine size of column visibility information}

   {Determine size of printer preference information}
   PrintSize := SizeOf(MMPrintPreference) + 2;

   {Determine size of column sort order information.}
   SortSize := (TableData.ColCount * 2) + 2;

   {Determine size of search criteria information}
   IF NumTriples <= 0 THEN SearchSize := 0
   ELSE BEGIN
        TripSize := NumTriples * SizeOf(Triple);
        SearchSize := 5 + ConstSize + TripSize;
        END;

   {Determine the size of font information}
   FontSize := SizeOf(FontRec) + 2;

   {Now add up all the pieces to get the total. Add 1 to contain total size.}
   FormSize := OrderSize + WidthSize + VisSize + SortSize
                         + SearchSize + FontSize + PrintSize + 1;


   {Now get a snip block to contain the form}
   GetSnipBlock(FormId,FormSize*2,Status);
   InitSnipPtr(ColKind,FormId);
   FormPtr := @ColSnip^;


   {Now write the information into the form}
   FormPtr^[0] := FormSize * 2; {Form size stored as bytes.}
   NextAvail := 1;

   {Write in the column order information}
   IF OrderSize > 0 THEN
      BEGIN
      IF Trace2MMgr then WriteLn(MxMgr,GLF,'Generating order block');
      FormPtr^[NextAvail] := OrderSize; {Length}
      FormPtr^[NextAvail + 1] := OrderCode; {info block identifier}
      IntArray := @FormPtr^[NextAvail + 2];
      Column := TableData.FirstCol;
      Order := 1;
      WHILE Column <> NullSnip DO
         BEGIN
         SetSnipPtr(ColKind,Column);
         IntArray^[ColSnip^.FieldNum] := Order;
         Order := Order + 1;
         Column := ColSnip^.NextSnip;
         END;
      NextAvail := NextAvail + FormPtr^[NextAvail]; {Add length to index}
      END;


   {Write in the column width information}
   FormPtr^[NextAvail] := WidthSize; {Length}
   FormPtr^[NextAvail + 1] := WidthCode; {info block identifier}
   IntArray := @FormPtr^[NextAvail + 2];
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      IntArray^[ColSnip^.FieldNum] := ColSnip^.Width;
      Column := ColSnip^.NextSnip;
      END;
   NextAvail := NextAvail + FormPtr^[NextAvail]; {Add length to index}


   {Write in the column visibility information}
   FormPtr^[NextAvail] := VisSize; {Length}
   FormPtr^[NextAvail + 1] := VisCode; {info block identifier}
   IntArray := @FormPtr^[NextAvail + 2];
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^ DO
         BEGIN
         IF Visible THEN IntArray^[FieldNum] := 1
         ELSE IntArray^[FieldNum] := 0;
         END;
      Column := ColSnip^.NextSnip;
      END;
   NextAvail := NextAvail + FormPtr^[NextAvail]; {Add length to index}


   {Write in the column sort order information}
   IF SortSize > 0 THEN
      BEGIN
      FormPtr^[NextAvail] := SortSize; {Length}
      FormPtr^[NextAvail + 1] := SortCode; {info block identifier}
      IntArray := @FormPtr^[NextAvail + 2];
      Column := TableData.FirstCol;
      WHILE Column <> NullSnip DO
         BEGIN
         SetSnipPtr(ColKind,Column);
         IntArray^[ColSnip^.FieldNum * 2] := ColSnip^.SortOrder;
         IntArray^[ColSnip^.FieldNum * 2 + 1] := ColSnip^.SortDirection;
         Column := ColSnip^.NextSnip;
         END;
      NextAvail := NextAvail + FormPtr^[NextAvail]; {Add length to index}
      END;


   {Write in the search criteria information}
   IF SearchSize > 0 THEN
      BEGIN
      IntArray := @FormPtr^[NextAvail];
      IntArray^[0] := SearchSize; {Length}
      IntArray^[1] := SearchCode; {info block identifier}
      IntArray^[2] := NumTriples;
      IntArray^[3] := TripSize; {Added in case SizeOf(Triples) changes.}
      IntArray^[4] := ConstSize;

      {Move in the block of triples}
      MoveLeft(ExprHnd^^,IntArray^[5],TripSize);

      {Move in the block of constants}
      MoveLeft(ConstHnd^^,IntArray^[5+TripSize],ConstSize);

      NextAvail := NextAvail + FormPtr^[NextAvail]; {Add length to index}
      END;

   {Write in the font information}
   IF FontSize > 0 THEN
      BEGIN
      IF Trace2MMgr then WriteLn(MxMgr,GLF,'Generating font block');
      FormPtr^[NextAvail] := FontSize; {Length}
      FormPtr^[NextAvail + 1] := FontCode; {info block identifier}
      MoveLeft(MMFontinfo,FormPtr^[NextAvail+2],SizeOf(FontRec));
      NextAvail := NextAvail + FormPtr^[NextAvail]; {Add length to index}
      END;

   {Write in the printer preference information}
   IF PrintSize > 0 THEN
      BEGIN
      IF Trace2MMgr then WriteLn(MxMgr,GLF,'Generating print preference block');
      FormPtr^[NextAvail] := PrintSize; {Length}
      FormPtr^[NextAvail + 1] := PrintCode; {info block identifier}
      MoveLeft(MMPrintPreference,FormPtr^[NextAvail+2],SizeOf(MMPrintPreference));
      NextAvail := NextAvail + FormPtr^[NextAvail]; {Add length to index}
      END;

   {Return snip id}
   SnipId := FormId;
   END;



{$S lmcolspec }
PROCEDURE GenNewSorts;

   CONST GNSorts = ' GenNewSorts';

   VAR Column: IdType;
       NextCol: IdType;
       Status: INTEGER;
       Len: INTEGER;
       Data: ARRAY[0..20] OF Byte;
       RowRange: Range;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,GNSorts);
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);

      {Generate the ascii representation of the sort order and direction.}
      WITH ColSnip^ DO
         BEGIN
         NextCol := NextSnip;
         GenSort(SortOrder,SortDirection,NullSnip,@Data,Len);
         END;

      {Now pack it into the sort row record}
      PackField(SortRow,Column,@Data,NIL,Len,Status);
      IF MMTrap1 THEN IF Status <> 0 THEN MMFatalErr(Status,GNSorts,'PackField');

      Column := NextCol;
      END;

   {Now redisplay the sort order row}
   WITH RowRange DO
      BEGIN
      LoRow := SortRow;
      LoCol := MInfSnip;
      HiRow := SortRow;
      HiCol := PInfSnip;
      RKind := ARowRg;
      END;
   NewRgImg(RowRange);
   END;



{$S lmcolspec }
PROCEDURE GenSort{Order: INTEGER;
                  Direction: INTEGER;
                  ColId: IdType;
                  ValuePtr: PtrData;
                  VAR Len: INTEGER};

      {This procedure accepts the internal form of a sort specification and
      converts it to a text string which may be displayed in a spec table.}

      CONST GSort = ' GenSort';

      TYPE Str20 = STRING[20];
           PtrStr = ^Str20;

      VAR SortData: Array[0..20] OF BYTE;
          SortString: PtrStr;

      BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
      IF TraceMMgr THEN WriteLn(MxMgr,GSort,Order:3,Direction:3);

      IF Order = 0 THEN Len := 0
      ELSE BEGIN
           IF Order = -1 THEN
              BEGIN {A -1 signifies that this procedure should determine
              {the order. If the column already has an order, then this
              order is retained. Otherwise, the next available order number
              is chosen.}
              SetSnipPtr(ColKind,ColId);
              IF ColSnip^.SortOrder <> 0 THEN Order := ColSnip^.SortOrder
              ELSE Order := CSKeys + 1;
              END;

           SortData[0] := 0;
           SortString := @SortData[0];
           IF Direction = 0 THEN SortString^ := concat(SrtAscString,'(')
              ELSE SortString^ := concat(SrtDesString,'(');

           {Now convert the order to ascii an append to end}
           Len := 0;
           IF Trace2MMgr THEN WriteLn(MxMgr,GSort,SortString^,Len,Order);
           IntToAscii(@SortData[Length(SortString^)+1],Len,Order,Nofill,0);
           SortData[0] := SortData[0] + Len;
           IF Trace2MMgr THEN WriteLn(MxMgr,GSort,SortString^,Len);

           {Tack on the final ')'}
           SortString^ := ConCat(SortString^,')');
           Len := LENGTH(SortString^);

           {If the order is 1, then don't display the number}
           IF Order = 1 THEN Len := Len - 3;

           MOVELEFT(SortData[1],ValuePtr^,Len);
           IF Trace2MMGR then WriteLn(MxMgr,GSort,SortString^);
           END;
      END;

{u}
{$S lmscrap}
PROCEDURE GenUniversal{(var status)};

const
    GN = 'genuniversal';

var fInfo : fontinfo;
    done : boolean;
    index : TB;      { for use with ICSCreate }
    TempHz : THz;
    colwidth : integer;
    sstat : integer;
    tblfntid : TLfntid;
    arraysize : integer;

    PROCEDURE Depart;
    begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
    { reset mm to operate off main matrix }
    if mmtrap2 then writeln('Depart from Genuniversal');

    SwitchTable(false,tblPars);                            { get current-table info in MM straight }
    FreeH(TempHz, pointer(ord(UTChhandle)));               { release char array space used }
    unBindUTDSeg(sstat);                                   { release the UT Data Segment }
    if sstat <> 0 then if mmtrap1 then writeln('Depart; unbind status : ',sstat);

    exit(GenUniversal)
    end;


 begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
{$IFC MMDEBUG}
 if mmtrap1 then        {initialize globals for tracing}
   begin
   UTtabchars := 0;
   UTtabstops := 0;
   UTrowcount := 0;
   end;
{$ENDC}
 if mmtrap1 then writeln(gn);
 status := 0;
 UTChHandle := NIL;
 UTTabHandle := NIL;

 {get font information for WriteLCut calls}
 if not FMFontMetrics(MMFontInfo.font,fInfo,sstat) then
    begin
    if mmtrap1 then writeln(gn,'; FMFontMetrics error : ',sstat);
    status := 1;
    depart;
    end;

 tblfntid := MMFontInfo.font;
 UTCharWidth := fInfo.widMax + 1;      {global in TE}
 UTScrapRg := MMScrapRg;           {global in lmmat}
 UTCharsTaken := 0;

 {this is the number of pixels of 'horizontal leading' placed to the
  left and right of each lc/bg column, in order not to violate Lotus's
  restriction of the smallest distance allowed between 2 tabs }
 UTHalfDxMin := (dxMinTab + 1) div 2;

 BindUTDSeg(sstat) ;             { make sure rghcs is in memory }
 if sstat <> 0 then if mmtrap1 then writeln(gn,'; bindutdseg status : ',sstat);

 {set up such that subsequent MM calls will refer to the Scrap }
 SwitchTable(true,tblPars);

{redefine the scrap region record}
 with UTScrapRg do
   begin
   case RKind of
    aNullRg,aRowGrid,aColGrid,aRowHedRg,aColHedRg,aTblHedRg:
       begin  { nothing to do }
          status := 0;
          depart;
       end;

    aRowRg :
       begin  {find final column which has data}
       rkind := aRectRg;
       if locol = minfsnip then GetNxtVisCol(locol);
       getsnipid(colkind,mmlast,0,hicol,hicol);
       end;

    aColRg :
       begin
       rkind := aRectRg;
       if lorow = minfsnip then GetSnipId(rowKind,mmFirst,0,lorow,lorow);
       end;

    aWTBoxRg :
       begin
       rkind := aRectRg;
       if locol = minfsnip then GetNxtVisCol(locol);
       if lorow = minfsnip then GetSnipId(rowKind,mmFirst,0,lorow,lorow);
       getsnipid(colkind,mmlast,0,hicol,hicol);
       end;

    aRectRg :
       begin
       end;

    end { case } ;

 end ;{ with }

 { allocate space }
 TempHz := TheHeap;

 {allocate the UTchar and UTtab arrays}
 arraysize := UTMaxChrs;
 if mmtrap2 then writeln(gn,'; char arraysize : ',arraysize:8);
 UTChhandle := pointer(ord(HAllocate(TempHz,arraysize)));
 if ( ord(UTChhandle) = ord(HNil) ) then
    begin
    if mmtrap1 then writeln(gn,'; hallocate problem for utchars');
    status := UTHeapProb;
    depart;
    end;

 with UTinforec do
   begin
   LCFont := TblFntID.fam;   { set table's Font into info record }
   thisRow := -1;            { no row yet retrieved }
   NumTabs := UTMaxCols;
   end;

 { get new rghcs index... }
 index := IcsCreate(tycsMtrx,SizeOf(Tcs),TempHz);

 {set up the array of procpointers ... }
 with rghcs^[index]^^.cspd do
   begin
   ArgProc[iprocFreeICS] := pointer(ProcNil);
   ArgProc[iprocPxHcs]   := @LLPxHcsMtx;
   ArgProc[IprocSeqLpd]  := @LLSeqLpdMtx;
   argproc[IProcFindLpFixed] := @FindLpFstPar;
   argproc[IProcFSelLpBounds] := @TrueStdSelLpBounds;
   end;

 PutCSScrap(index, sstat);
{$IFC MMDEBUG}
 if mmtrap1 then
   begin
   writeln;
   writeln('+++ UTRowcount : ',UTrowcount,'  UTTabchars : ',UTtabchars,'  UTTabstops : ',UTtabstops);
   writeln;
   end;
{$ENDC}
 if sstat <> 0 then
   begin
   if mmtrap1 then writeln('PutCSScrap error : ',sstat);
   status := 2;
   end;

 FreeIcs(index) ;

 depart;  { will among other things unbind the UTDSeg }

 end;


{$S lmcolspec }
PROCEDURE GenVisible{Vis: BOOLEAN;
                        ValuePtr: PtrData;
                        VAR Len: INTEGER};

      VAR VisString: STRING[20];
          VisPtr: PtrData;

      BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
      IF TraceMMGR then WriteLn(MxMgr,' GenVisible ');

      IF Vis THEN VisString := VisYesString ELSE VisString := VisNoString;
      Len := LENGTH(VisString);
      VisPtr := @VisString;
      MOVELEFT(VisPtr^[1],ValuePtr^,Len);
      END;


{$S lmsearch}
Procedure getaction{value: ptrdata;
                    length: integer;
                    itsbold : boolean;
                    var action: integer;
                    var oplen: integer;
                    var status : integer};

   label 999;
   const getact = ' GetAction';

   var
        i : integer;
        ch, ch2 : char;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if tracemmgr then writeln(MxMgr,getact);
   status := 0;
   IF (length = 0) or Not itsBold  then
      begin
      oplen := 0;
      action := ex_eq;
      goto 999;
      end;

   ch := chr(value^[0]);
   if length > 1 then ch2 := chr(value^[1]);
   IF ch = '<' THEN
      BEGIN
      if length > 1 then
         begin
         if ch2 = '=' then
            begin
            action := ex_le;
            oplen := 2;
            end
         ELSE IF ch2 = '>' then
            begin
            oplen := 2;
            action := ex_ne;
            end
         ELSE
            begin
            action := ex_lt;
            oplen := 1;
            end;
         end

      ELSE
         begin
         action := ex_lt;
         oplen := 1;
         end;
      END

   ELSE IF ch = '>' THEN
      BEGIN
      if length >1 then
         begin
         if ch2 = '=' then
            begin
            action := ex_ge;
            oplen :=2;
            end
         ELSE
            begin
            oplen := 1;
            action := ex_gt;
            end;
         end
      else
         begin
         oplen := 1;
         action := ex_gt;
         end;
      END
   ELSE IF ch = '=' THEN
      BEGIN
      oplen := 1;
      action := ex_eq;
      END
   ELSE
      BEGIN
      action := ex_eq;
      oplen := 0;
      END;


999:
END;


{$S lmres2 }
Procedure GetCurPossnip{VAR RowId: Idtype;
                        VAR ColId: IdType};

   {GetCurPosSnip will return the row and column position to which a table
   should be scrolled to when displayed initially.}

   {Rules: table for which current position is needed must have already been
   loaded.}

   Label 400,500;

   CONST maxflds = 20 ; {20 wds * 16 }
         GCPS = ' GetCurPosSnip ';

   VAR   len, status, setsize : integer;
         ErrBits : Array [0..MaxFlds] of Integer;
         UserError : Integer;
         snipid : idtype;
         TopHandle: LMHandle;
         AlertMsg: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if tracemmgr then writeln(MxMgr,gcps,RowId,' ',ColId);

   IF (CurTable = TList) THEN
      BEGIN
      {Make sure cache is empty. It may not be if we have just finished printing. However,
      it should be if we have just loaded up the list table.}
      IF CurRgList THEN RelCrgList;
      ReleaseRowSnips;
      END;

   IF (CurTable = TList) AND ListScrollValid THEN
      BEGIN
      {This is the list, it has already been created, and procedure
      LoadList has already determined that the stored handle is valid to use.}

      TopHandle := ListTopHandle;

      lmfetch(status,userError,@ErrBits,scanid,exact,TopHandle,len);
      IF trace2mmgr THEN IF Status <> NoErr THEN writeln('lmfetch1 status: ',status);
      IF MMTrap1 THEN IF (Status <> NoErr) AND (Status <> EOS) AND (Status <> NotFound)
      THEN WriteLn(Bell,'***',GCPS,'LMFetch1 Status: ',Status);

      IF status = notfound then
         begin {get the next record}
         lmfetch(status,userError,@ErrBits,scanid,next,TopHandle,len);
         IF trace2mmgr THEN IF Status <> NoErr THEN writeln('lmfetch2 status: ',status);
         IF MMTrap1 THEN IF (Status <> 0) AND (Status <> EOS) THEN
         WriteLn(Bell,'***',GCPS,'LMFetch2 Status: ',Status);
         END;

      IF status = EOS then
         begin {handle not found so start with last}
         Getsnipid(rowkind,MMlast,0,snipid,snipid);
         RowId := snipid;
         goto 500;
         END;

      IF Status <> NoErr THEN GOTO 400; {Error in database intrinsics}

      {put the record into a snip and on the list}
      SetSize := ((TableData.ColCount + 15) div 16) * 2;
      GetSnipBlock(snipid,len + sizeOf(rowsniprecord)+ SetSize + RecExpand,Status);
      IF Status <> 0 THEN
400:       BEGIN
         RowId := PInfSnip;
         {Put up an alert box}
         DBAlert(DisplayErr,Status);
         GOTO 500;
         END;

      InitSnipPtr(rowkind,snipid);
      SetUpRec(rowsnip,snipid,len,setsize,usererror,@ErrBits,status);
      WITH TableData DO {Insert row in snip}
      InsertRowSnips(TopRow,BottomRow,NullSnip,SnipId,SnipId);
      RowId := snipid;
      END

   ELSE BEGIN {In all other cases, return the first row on the list}
        GetSnipId(RowKind,MMFirst,0,RowId,RowId);
        END;



500: {Now get the horizontal position}
   IF (HScrollId = NullSnip)
   OR (HScrollId = MInfSnip)
   OR (HScrollId = PInfSnip)
   THEN BEGIN
        GetSnipId(ColKind,MMFirst,0,SnipId,SnipId);
        ColId := SnipId;
        END

   ELSE CASE CurTable OF

      TList: BEGIN
             {If the column is not invisible, return it, otherwise simply
             go after the first.}
             SetSnipPtr(ColKind,HScrollId);
             IF ColSnip^.Visible THEN ColId := HScrollId
             ELSE BEGIN
                  GetSnipId(ColKind,MMFirst,0,SnipId,SnipId);
                  ColId := SnipId;
                  END;
             END;

      TColSpecs,
      TSearch: BEGIN
               SetSnipPtr(ColKind,HScrollId);
               ColId := ColSnip^.ListSnip;
               END;

      OTHERWISE IF MMTrap1 THEN MMFatalErr(LogicErr,GCPS,'');
      END; {Case}

   if trace2mmgr then
      begin
      writeln(gcps, ' exit RowId: ',RowId:3,'ColId: ',ColId:3);
      end;

   END;


{$S lmres }
PROCEDURE GetEchk{Column: IdType; VAR edit:str40};

   CONST GEchk = ' GetEchk';

   VAR Len: INTEGER;
       ListCol: IdType;
       BytePtr1: PtrData;
       BytePtr2: PtrData;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,GEchk);

   {Since the edit check is displayed in both the list and the search spec
   table, it has to handle both cases. }
   IF curTable = tList then ListCol := Column
   ELSE BEGIN
        SetSnipPtr(ColKind,Column);
        ListCol := ColSnip^.ListSnip;

        {If null, this is a new column, so return default text edit check.
        This should not happen, since new columns only appear in the colspec
        table, and edit checks should not be displayed in the error message.
        Due to a bug at the current time, however, they are, so the following
        code is necessary to keep the system from crashing in the interim.}
        IF ListCol = NullSnip THEN
           BEGIN
           Edit := '';
           Exit(GetEChk);
           END;
        END;

   {Get the necessary information out of the list column snip}
   SetSnipPtr(ColKind,ListCol);
   WITH ColSnip^ DO
      BEGIN

      {Get out edit check string}
      IF FieldInfo.Display = FNilVal THEN Edit := ''
      ELSE BEGIN
           BytePtr1 := POINTER(ORD(@ColSnip^.FieldInfo) + FieldInfo.Display);
           BytePtr2 := @Edit;
           Len := BytePtr1^[0];
           MoveLeft(BytePtr1^,BytePtr2^,cmin(Len+1,41));
           END;

      END;

   END;

{$S lmscrap}
function GetLLCUTRow{(var rowindex:integer):boolean};

{ For each row in the ScrapRg, fill the Tabs array and the Chars array of the
  UTinfo record with correct information, and also update UTinforec.ThisRow.
  The trailing carriage return is also sent, and hence UTCharCount can turn
  out to be as small as one, but never zero.

  Function value TRUE means that a proper row has been returned; FALSE
  indicates that "Row" was too small or too big  }
LABEL 999;

CONST
  chreturn = 13;
  GL = 'GetLLCutRow';

VAR
       TextBuffer:     array[0..999] of byte ; { MM "cellValue" text placed here }
       CellRec:        CellRecord;  { MM "CellValue" data placed here }
       Col:            integer;
       CurChar:        integer;
       CurCharPos:     integer;
       status:         integer;
       ColumnWidth:    integer;
       CharCnt:        integer;
       done:           boolean;
       tabindx:        integer;
       RowSnipId:      integer;
       lastcol :       integer;
       handleptr :     ^LMhandle;
       oldbasepixel :  integer;
       newbasepixel :  integer;


    function ffConvert(oldPixel: INTEGER) : INTEGER;    { performs miracle conversion to Lotus's
                                                                  Metric space }
       VAR L :  LONGINT ;
       BEGIN
    {$IFC SAMPCALLS}    ALogCall;     {$ENDC}
           L := OldPixel ;
           ffConvert :=  ( ( L * 100 ) + 95 ) DIV 96 ;
       END ;

BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
  GetLLCutRow := TRUE;   {initialize}

  RowSnipId := UTinforec.thisrow;   {get the last row snipid}
  {Set the row to the first row of the range or get the next row in the range}
  if RowSnipId = -1 then       {if this is the first time through, init rowsnipid}
    begin
    rowindex := 0;
    RowSnipId := UTScrapRg.lorow;
    end
  else if (UTinforec.RowIndx = rowindex) then    {if still on same rowindex, quit and get next rowsnipid}
         begin
         if (UTCharsTaken >= UTcharCount) then
           begin
           if RowSnipId = UTScrapRg.hirow then GetLLCutRow := FALSE
           else begin
                GetSnipId(rowKind,mmNext,0,RowSnipId,RowSnipId);
                if RowSnipId <> pinfsnip then
                  begin
                  SetSnipPtr(rowkind,RowSnipId);
                  handleptr := pointer(ord(rowsnip) + rowsnip^.handoffset);
                  if (((MMScrapRg.rkind = acolrg) or (MMScrapRg.rkind = aWTBoxRg))
                  and (blankline)
                  and (handleptr^.high = blankhandle.high) and
                      (handleptr^.low = blankhandle.low)) then GetLLCutRow := FALSE;
                  end;
                end;
           goto 999;
           end
         else goto 999;         {not finished getting all chars in array yet}
         end
       else if (RowSnipId = pinfsnip) then      {if no more rows, quit}
         begin
         GetLLCutRow := FALSE;
         goto 999;
         end;

  {Get the first column in the range}
  col := UTScrapRg.locol;
  lastcol := UTScrapRg.hicol;
{$IFC MMDEBUG}
  if mmtrap1 then UTrowcount := UTrowcount+1;
{$ENDC}
  curCharPos := 0;
  tabindx := 0;
  oldbasepixel := UThalfDxMin;
  done := FALSE;
  while NOT done do     { repeat for each matrix column in the Scrap }
    begin

    {insert a tab character}
    UTchhandle^^[CurCharPos] := chTab;
    CurCharPos := CurCharPos + 1;
    tabindx := tabindx+1;
    if tracemmgr then writeln('<TAB>');
    if tracemmgr then writeln('GetLLCutRow; tabindx : ',tabindx);

    CharCnt := UTMaxChrs;
    CellValue(mmRead,RowSnipId,col,@TextBuffer,false,CharCnt,status);
    if status <> 0 then if mmtrap1 then writeln(GL,'cellvalue status : ',status);

   { determine alignment information }
   CellInfo(cRecord,mmRead,RowSnipId,col,CellRec);
   ColumnWidth := SnipWidth(ColKind,col) div UTCharWidth;

   { Adjust tab array as needs be... }
   if tabindx <= UTMaxCols then
     begin
     with UTInfoRec.Tabs[Tabindx-1], CellRec do
       begin
       newbasepixel := oldbasepixel + ffconvert(ColumnWidth * UTCharWidth) + 2 * UThalfdxmin;
       case align of
          right:
            begin
              x := newbasepixel - UThalfdxmin ;
              quad := quadR
            end;
          center:
            begin
              x := (newbasepixel + oldbasepixel) div 2 ;
              quad := quadC
            end;
          otherwise
            begin
              x := oldbasepixel + UThalfdxmin ;    {+}
              quad := QuadL
            end
        end; {case}
        tyfill := tyfillnil;
        x := x + leftmarg  ;      { Start tabs at 1" }   {+}
        end; { with tabs }
     end;
   oldbasepixel := newbasepixel;

   curchar := 1;
   while curchar <= CharCnt do
     begin
     UTchhandle^^[curCharPos + curChar - 1 ] := TextBuffer[curChar-1];
     if tracemmgr then write(chr(textbuffer[curchar-1]));
     curchar := curchar+1;
     end;

   {Adjust curCharPos upward by desired amount, taking into account the tab character...}
   curCharPos := curCharPos + CharCnt;

   {Stop at end of column range}
   if col = lastcol then done := true
   else     {GetNxtVisCol will return pinfsnip when there are no more columns; stop when this occurs}
     begin
     GetNxtVisCol(col);
     if col = pinfsnip then done := TRUE;
     end;

   end ;{ current column }

   with UTinforec do
     begin
     numtabs := tabindx;
     if tabindx > UTmaxcols then numtabs := UTmaxcols;
     end;

   if mmtrap2 then writeln('GetLLCutRow; ROW tabchars : ',tabindx,'  tabstops : ',utinforec.numtabs);
{$IFC MMDEBUG}
   if mmtrap1 then
     begin
     if tabindx > UTtabchars then UTtabchars := tabindx;
     if utinforec.numtabs > UTtabstops then UTtabstops := utinforec.numtabs;
     end;
{$ENDC}
   UTchhandle^^[CurCharPos] := chReturn;    { add ASCII carriage-return }
   if tracemmgr then writeln('<CR>');
   UTCharCount := CurCharPos + 1 ;
   if tracemmgr then writeln('GetLLCutRow; charcount : ',utcharcount);
999:
   UTinforec.ThisRow := RowSnipId;
   UTinforec.RowIndx := RowIndex;
 end { procedure GetLLCUTRow };


(*
{$S lmlist}
Procedure GetNxtCell{nxtrow:boolean;            {go to next row for next cell}
                      var Status:integer};      {status}

{Given a current cell range descriptor and the selection range descriptor in NxtCell, this }
{  procedure finds the next cell range descriptor and puts it in CurCell.                  }
{  status returns : 0-okay   1-end of selection range   2-blankrow problem                 }

label 10,20,999;

const GNC = 'GetNxtCell';

var nxtcol : idType;
    lastviscol : idType;
    newsnip : idType;
    col : idtype;
    startrg : range;
    priorrow : idtype;
    lastrow : idtype;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  status := 0;

  if tracemmgr then writeln(GNC,'; nxtrow : ',nxtrow);
  if tracemmgr then with CellRg do
        writeln(GNC,'; CellRg lo/hicol lo/hirow : ',ord(rkind):4,locol:4,hicol:4,lorow:4,hirow:4);
  if tracemmgr then with SelRg do
        writeln(GNC,'; SelRg lo/hicol lo/hirow : ',ord(rkind):4,locol:4,hicol:4,lorow:4,hirow:4);
  if tracemmgr then with pasteRg do
        writeln(GNC,'; PasteRg lo/hicol lo/hirow : ',ord(rkind):4,locol:4,hicol:4,lorow:4,hirow:4);

  with CellRg do
    begin

    {find the next cell!}
    {We know that curcell is in the selection range.  If the column is not the last column, }
    {  then get the next column and transfer all other current cell info to the nxtcell     }
    if (locol <> PasteRg.hicol) and NOT(nxtrow) then
      begin
      lastviscol := locol;
      GetNxtVisCol(locol);                      {will return the next visible column}
      if locol = pinfsnip then goto 10;        {no more visible cols in this row}
      hicol := locol;
      end
    else        {we are at the last column of the selection range and have to go to next row}
      begin
      {We know that curcell is in the selection range.  If the row is not the last row, }
      {  then get the next row and transfer all other current cell info to the nxtcell  }
      if NOT RowsAdded then      {once you start to add rows, keep adding them}
        begin

        UpdateRow;      {update the last row changed}

10:     if (((selrg.rkind = arectrg) or (selrg.rkind = arowrg)) and (lorow <> PasteRg.hirow))
          or (lorow <> tabledata.lastrow) then
          begin
          lastrow := lorow;
          {see if there is another row after this one}
          GetSnipId(RowKind,MMNext,0,lorow,lorow);

          if lorow = tabledata.lastrow then     {don't use lastrow; add a new row}
            begin
            lorow := lastrow;
            goto 20;
            end;

          rowchanged := lorow;    {so next updaterow will update this new row}
          hirow := lorow;
          if (selrg.rkind <> arectrg) and (selrg.rkind <> arowrg) then pasterg.hirow := hirow;

          locol := selrg.locol;                       {get the first visible column}
          hicol := locol;
          end;
        end
      else         {we're at end of selection range}
        begin
20:     if (selrg.rkind = arowgrid) or (selrg.rkind = acolrg)
        or (selrg.rkind = a1cellrg) or (selrg.rkind = awtboxrg) then    {add a row after the last row}
          begin
          priorrow := pasterg.hirow;
          BlankRow('',priorrow,newsnip,status);
          if status <> 0 then
            begin
            if mmtrap1 then writeln('Getnxtcell BlankRow Status : ',status);
            status := 2;
            exit(getnxtcell);
            end;

          RowsAdded := TRUE;
          rowchanged := nullsnip;     {don't update an added row}

          if PastePoint = -1 then PastePoint := priorrow;

          lorow := newsnip;
          hirow := newsnip;
          locol := pasterg.locol;
          hicol := hicol;

          pasterg.hirow := newsnip;

          end
        else
          begin
          if mmtrap1 then writeln(GNC,'; end of paste range');
          status := 1;
          end;
      end;
    end;
  end;   {with CellRg}
999:

  if tracemmgr then with CellRg do
        writeln(GNC,'; CellRg lo/hicol lo/hirow : ',ord(rkind):4,locol:4,hicol:4,lorow:4,hirow:4);
  if tracemmgr then with SelRg do
        writeln(GNC,'; SelRg lo/hicol lo/hirow : ',ord(rkind):4,locol:4,hicol:4,lorow:4,hirow:4);
  if tracemmgr then with PasteRg do
        writeln(GNC,'; PasteRg lo/hicol lo/hirow : ',ord(rkind):4,locol:4,hicol:4,lorow:4,hirow:4);
  if tracemmgr then writeln('========================================================================');

end;    {GetNxtCell}
*)


{$S lmres }
Procedure GetNxtVisCol{VAR rid: idtype};

   LABEL 999;

   VAR Col: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WRiteln(MxMgr,' GetNxtVisCol');

   IF Rid = PInfSnip THEN GOTO 999;
   IF (Rid = MInfSnip) AND (tabledata.firstcol = nullsnip) then
      BEGIN
      RID := pinfsnip;
      goto 999;
      END
   ELSE IF (Rid = MInfSnip) AND (tabledata.firstcol <> nullsnip) then
      BEGIN
      RID := tabledata.firstcol;
      setsnipptr(colkind,rid);
      if colsnip^.visible then goto 999;
      END;
   SetSnipPtr(ColKind,Rid);

   WHILE TRUE DO
      BEGIN
      Col := ColSnip^.NextSnip;
      IF Col = NullSnip THEN
         BEGIN
         Rid := PInfSnip;
         GOTO 999;
         END
      ELSE BEGIN
           SetSnipPtr(ColKind,Col);
           IF ColSnip^.Visible THEN
              BEGIN
              Rid := Col;
              GOTO 999;
              END;
           END;
      END;
   999: END;


{$S lmclosedoc }
PROCEDURE GetOptions{DataType: INTEGER;
                     VAR Options: elemset };

   {This procedure determines the options -- alignment and nullok characteristics}

   CONST GRT = ' GetOptions';

   VAR TotalDigits: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if Tracemmgr then WriteLn(MxMgr,GRT);

   CASE DataType OF
      SS,
      Zip,
      Ph: BEGIN
          Options := [dbcentered,dbnullok];
          END;

      Tick,
      Tim,
      Dol,
      Num: BEGIN
           Options := [dbright,dbnullok];
           END;

      Dt,
      Lets: BEGIN
            Options := [dbleft ,dbnullok];
            END;

      OTHERWISE IF MMTrap1 THEN MMFatalErr(LogicErr,GRT,'');

      END; {Case on datatype}
   END;



{$S lmres }
Procedure GetPrvVisCol{VAR rid: idtype};

   LABEL 999;
   VAR Col: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then Writeln(MxMgr,' GetPrvVisCol');

   IF Rid = MInfSnip THEN GOTO 999;
   IF (Rid = PInfSnip) AND (tabledata.lastcol = nullsnip) then
      BEGIN
      RID := minfsnip;
      goto 999;
      END
   ELSE IF (Rid = PInfSnip) AND (tabledata.lastcol <> nullsnip) then
      BEGIN
      RID := tabledata.lastcol;
      setsnipptr(colkind,rid);
      if colsnip^.visible then goto 999;
      END;

   SetSnipPtr(ColKind,Rid);

   WHILE TRUE DO
      BEGIN
      Col := ColSnip^.PriorSnip;
      IF Col = NullSnip THEN
         BEGIN
         Rid := MInfSnip;
         GOTO 999;
         END
      ELSE BEGIN
           SetSnipPtr(ColKind,Col);
           IF ColSnip^.Visible THEN
              BEGIN
              Rid := Col;
              GOTO 999;
              END;
           END;
      END;
999: END;


{$S lmres2 }
FUNCTION GetRecSize{:INTEGER};

   {This procedure returns the fixed length size of a record}

   CONST GRS = ' GetRecSize ';

   VAR Column: IdType;
       MaxOffset: INTEGER;
       SizeOfMaxOffset: INTEGER;
       RecSize: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,GRS);

   MaxOffset := 0;
   SizeOfMaxOffset := 0;
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^.FieldInfo DO IF Offset >= MaxOffset THEN
         BEGIN
         MaxOffset := Offset;
         SizeOfMaxOffset := Size;
         END;
      Column := ColSnip^.NextSnip;
      END;

   RecSize := MaxOffset + SizeOfMaxOffset;
   GetRecSize := RecSize;
   IF Trace2MMgr THEN WriteLn(MxMgr,GRS,'returns record size of: ',RecSize);
   END;


{$S lmres }

PROCEDURE GETSNIPBLOCK{VAR SnipId: IdType;
                       ByteSize: INTEGER;
                       VAR Status: INTEGER};

   {This procedure allocates a block of the specified size in bytes. It is
   also responsible for assigning a snip identifier, and setting the pointer
   in the snipmap to point to the new block.

   If HAllocate causes MakeSpace to be called, in 95% of the cases MakeSpace
   will be able to successfully get more space, because the procedure EnoughMemory
   has tried to calculate the worst case for any given list. However, in some cases
   the heuristic does not work and it is possible to run out of data segment space.
   In this case, HAllocate will return HNil as the pointer to indicate it failed. However,
   this does little to tell us why it failed. Consequently, when MakeSpace fails, it sets
   a global status variable StatusMakeSpace, which is then used by this procedure to
   determine if it was disc or memory which could not be obtained. This information is
   then converted into the two error returns NoRoom and NoMem and passed on up.

   It is not necessary for all calls to this procedure to check status. Specifically, calls when
   the list is displayed should check status, and calls in any other table need not. This is because
   the worst case requirements in any table other than the list are easy to calculate and the heuristic
   will always work. However, the memory requirements of the list display depend on the size of the
   records, which for any list which has a text field could be 1K bytes per record.}

   CONST GSB = ' GetSnipBlock';

   VAR HeapBlock : TH;
       I: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then Writeln(MxMgr,GSB,' Size: ',ByteSize:3);

   {Make sure there is room on the free snip list}
   IF FreeSnipList = 0 THEN
      BEGIN
      MMCallingMakeSpace := TRUE;
      I := MakeSpace(SnipZone,0);
      MMCallingMakeSpace := FALSE;
      IF FreeSnipList = 0 then
         BEGIN
         if mmtrap1 then WriteLn(Bell,'***No more free snips on free snip list');
         MMFatalErr(LogicErr,GSB,'');
         END;
      END;

   {It is necessary to call Hallocate three times, because if makespace is
   called, it may do one of three things. If the heap is smaller than the
   data segment, it will notify the storage manager of the extra space on
   the first call. If there is no slack space in the data segment, it will
   then attempt to free up snips. If there are no snips to free up, it will
   then attempt to expand the data segment. It therefore takes three calls
   to insure that MakeSpace has run out of options. If on the third try, the
   data segment fails to expand, the procedure MakeSpace will set the global
   variable StatusMakeSpace to the status returned from Size_DataSeg.}

   StatusMakeSpace := 0; {Clear in case MakeSpace fails}

   HeapBlock := HAllocate(SnipZone,ByteSize);

   IF (ORD(Heapblock) = ORD(hnil))  then
      BEGIN
      IF MMTrap1 THEN WriteLn('*** First HAllocate in GetSnipBlock failed');
      HeapBlock := HAllocate(SnipZone,ByteSize);
      IF ORD(Heapblock) = ORD(hnil) then
         BEGIN
         IF MMTrap1 THEN WriteLn('*** Second HAllocate in GetSnipBlock failed');
         HeapBlock := HAllocate(SnipZone,ByteSize);
         IF ORD(Heapblock) = ORD(hnil) then
            BEGIN
            IF StatusMakeSpace = 309 THEN Status := NoRoom ELSE Status := NoMem;
            IF MMTrap1 THEN WriteLn(Bell,'*** Third HAllocate in GetSnipBlock failed. Status:',Status);
            Exit(GetSnipBlock);
            END;
         END;
      END;

   SnipId := FreeSnipList;
   FreeSnipList := SnipMap[SnipId];
   SnipMap[SnipId] := PtrToSnip(HeapBlock);

   Status := 0;
   IF TraceMMgr THEN WriteLn('getsnipblock; SnipId, free: ',SnipId:3,freesniplist:3);
   END;


{$S lmres }
PROCEDURE GetSnipId{Snip: Snipkind;
                    Mode: IdModeType;
                    Position: FRACT;
                    RefId: IdType;
                    VAR SnipId: IdType};

   {GetSnipId returns the identifier of a snip whose relative position is
   determined by the Mode parameter. The mode parameter takes on the
   following values:

    MMFirst    - Return the SnipId of the first snip in the table.
    MMLast     - Return the SnipId of the last snip in the table.
    MMNext     - Return the SnipId of the snip following the snip whose identifier is
               in RefId.
    MMPrior    - Return the SnipId of the snip preceeding the snip whose identifier is
               in RefId.
    MMFraction - Return the SnipId of the snip which is some fraction of the way through
               the table, where the fraction is a real number from 0 to 1 passed
               in through the Position parameter.}


   LABEL 400,
         500, {Handle errors for db intrinsics}
         999; {Used to exit the procedure}

   CONST GetSId = ' GetSnipId';
         maxflds = 20 ; {20 wds * 16 }

   VAR   Len: Integer;
         Src : ptrdata;
         Dest : ptrdata;
         status : integer;
         thisrow : ptrRowSnip;
         realmode : idmodetype;
         shandle: lmhandle;
         ptrhand: ^ lmhandle;
         ptrerr : Ptrdata;
         ErrBits : Array [0..MaxFlds] of Integer;
         UserError : Integer;
         setsize : integer;
         cstatus : integer;
         TopRow: IdType;
         OldCol: IdType;
         NewCol: IdType;
         OldPosition: INTEGER;
         AlertMsg: INTEGER;
         CurPt: Point;
         VisRg: Range;



   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then
   WriteLn(MxMgr,GetSId,' Sniptype:',Ord(Snip):3,' Mode:',Ord(Mode):3,
           ' RefId:',RefId:3);

   realMode := Mode;

   {Check for various errors}
   IF MMTrap1 THEN
      BEGIN
      IF NOT(Snip IN [Colkind,Rowkind]) THEN
         BEGIN
         WriteLn(Bell,'***Invalid snip type');
         MMFatalErr(LogicErr,GetSId,'');
         END;
      IF NOT(Mode IN [MMFirst,MMLast,MMNext,MMPrior,MMFraction]) THEN
         BEGIN
         WriteLn(Bell,'***Invalid mode');
         MMFatalErr(LogicErr,GetSId,'');
         END;

      {Check for anomalous parameters}
      IF (Mode in [MMNext,MMPrior]) AND (RefId = NullSnip) then
         BEGIN
         WriteLn(Bell,'***RefId is null for mode next/prior');
         MMFatalErr(LogicErr,GetSId,'');
         ENd;
      END;

   {init set size}
   SetSize := ((TableData.ColCount + 15) div 16) * 2;

400: {Determine if the snip is a row or column and case appropriately}
   CASE Snip OF


Rowkind: CASE RealMode OF


MMFirst: BEGIN
         InsertAtTop := TRUE;
         IF TableData.FirstRow <> nullSnip then
            BEGIN
            SnipId := TableData.FirstRow;
            GOTO 999;
            END;

         {Set snipid to PInf here. If we run into trouble later,
         this will be the default value returned.}
         SnipId := PInfSnip;

         {If this is not the list, or if we were unable to open
         the scan, then we can simply return PInfSnip}
         IF (CurTable <> TList) OR NOT ScanOpen then GOTO 999;

         {Note - memory management scheme cannot handle a call to
         getsnipid first for rows when scrolling has caused the
         first snips to be thrown out.}
         IF MMTrap1 THEN IF TableData.TopRow <> NullSnip THEN
            BEGIN
            WriteLn('***',GetSId,'MMFirst FirstRow,TopRow: ',TableData.FirstRow,TableData.TopRow);
            MMFatalErr(LogicErr,GetSId,'');
            END;

         IF Trace2MMgr THEN
            BEGIN
            WriteLn(MxMgr,' ',GetSid,' LMFetch Params');
            WriteLn('Status','Scanid','First','Len');
            WriteLn(Status,Scanid,First,len);
            END;

         lmfetch(status,userError,@ErrBits,scanid,first,shandle,len);
         IF status <>  EOS THEN
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,GetSID,'MMFirst LMFetch1 status: ',Status);
            GOTO 500;
            END;

         lmfetch(status,userError,@ErrBits,scanid,next,shandle,len);
         IF status = EOS then
            BEGIN
            AddBlank(SnipId);
            GOTO 999;
            END;

         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,GetSID,'MMFirst LMFetch2 status: ',Status);
         IF status > 0 then GOTO 500;

         IF curRgList then
            BEGIN
            chkCurRg(Pdifftable^[scanid]^.curhandle,MMFIRST,snipid,cstatus);
            IF cstatus = 0 then goto 999;
            END;

         GetSnipBlock(snipid,len+sizeOf(rowsniprecord) + setsize + RecExpand,Status);
         IF Status <> 0 THEN
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,GetSID,'MMFirst GetSnipBlock status: ',Status);
            GOTO 500;
            END;

         TableData.FirstRow := snipid;
         InitSnipPtr(rowkind,snipid);
         SetUpRec(rowsnip,snipid,len,setsize,usererror,@ErrBits,status);
         WITH TableData DO
         InsertRowSnips(TopRow,BottomRow,NullSnip,SnipId,SnipId);
         END; {MMFirst}




MMLast:  BEGIN
         InsertAtTop := False;
         WITH TableData DO IF LastRow <> nullSnip then
            BEGIN
            IF LastRow = MInfSnip THEN SnipId := PInfSnip
            ELSE SnipId := LastRow;
            GOTO 999;
            END;

         {Set the default snipid in case trouble is encountered. This is
         usually PInfSnip. However, it is also possible to go through this
         section of code by getting a MMPrior of PInfSnip. In this case,
         the default return is MInfSnip}
         IF Mode = MMLast THEN SnipId := PInfSnip ELSE SnipId := MInfSnip;

         {If this is not the list, or if we were unable to open
         the scan, then we can simply return PInfSnip}
         IF (CurTable <> TList) OR NOT ScanOpen then GOTO 999;

         {Note - cache scheme cannot handle a call to getsnipid last
         when there is already a list of snips in memory.}
         IF MMTrap1 THEN IF TableData.BottomRow <> NullSnip THEN
            BEGIN
            WriteLn('***',GetSId,'MMLast LastRow, BottomRow: ',TableData.LastRow,TableData.BottomRow);
            MMFatalErr(logicerr,GetSid,'');
            END;

         {Position to the end of file}
         lmfetch(status,userError,@ErrBits,scanid,last,shandle,len);
         IF status <>  EOS THEN
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,GetSID,'MMLast LMFetch1 status: ',Status);
            GOTO 500;
            END;

         {If there is no blank line, then add it and return its id as last.}
         IF NOT BlankLine THEN
            BEGIN
            AddBlank(SnipId) ;
            {Next line necessary because AddBlank sets FirstRow if there
            are no snips on the list, and in this case, firstrow is not
            known.}
            TableData.FirstRow := NullSnip;
            GOTO 999;
            END;

         {Go get the blank line}
         lmfetch(status,userError,@ErrBits,scanid,prior,shandle,len);
         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,GetSId,'MMLast LMFetch2 status: ',Status);
         IF status > 0 THEN GOTO 500;

         {See if this record is on the current range list already.}
         IF curRgList then
            BEGIN
            chkCurRg(Pdifftable^[scanid]^.curhandle,MMLAST,snipid,cstatus);
            IF cstatus = 0 then goto 999;
            END;

         {Create a snip for the retrieved record.}
         GetSnipBlock(snipid,len+sizeOf(rowsniprecord)+SetSize+RecExpand,Status);
         IF Status <> 0 THEN
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,GetSID,'MMLast GetSnipBlock status: ',Status);
            GOTO 500;
            END;

         TableData.LastRow := snipid;
         InitSnipPtr(rowkind,snipid);
         SetUpRec(rowsnip,snipid,len,setsize,usererror,@ErrBits,status);
         WITH TableData DO
         InsertRowSnips(TopRow,BottomRow,BottomRow,SnipId,SnipId);
         END;



MMNext:  BEGIN
         InsertAtTop := False;

         {Set Snipid to PInf here. This will be the default returned
         in case we run into trouble with the intrinsics.}
         SnipId := PInfSnip;

         IF (refid = TableData.LastRow)
         OR (refId = PInfSnip) THEN GOTO 999;

         IF RefId = MInfSnip THEN
            BEGIN
            WITH TableData DO IF FirstRow <> NullSnip THEN
               BEGIN
               SnipId := FirstRow;
               GOTO 999;
               END;
            {Process as though it were an MMFirst}
            RealMode := MMFirst;
            GOTO 400;
            END;

         {At this point, we know refid is a real snip.}
         SetSnipPtr(snip,refid);
         IF RowSnip^.nextSnip <> nullSnip then
            BEGIN
            SnipId := RowSnip^.NextSnip;
            GOTO 999;
            END;

         {The next snip is null, and furthermore, it is not the last
         one in the table. Consequently, this had better be the list.}

         {If the scan is not open, return the default PInf}
         IF NOT ScanOpen THEN GOTO 999;

         ptrhand := POINTER(ORD(rowsnip) + rowsnip^.handoffset);
         lmfetch(status,userError,@ErrBits,scanid,exact,ptrhand^,len);
         IF status <> noerr then
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,GetSId,'MMNext LMFetch1 status: ',Status);
            GOTO 500;
            END;

         lmfetch(status,userError,@ErrBits,scanid,next,shandle,len);
         IF status = EOS then
            BEGIN
            TableData.LastRow := RefId;
            AddBlank(SnipId);
            GOTO 999;
            END;

         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,GetSId,'MMNext LMFetch2 status: ',Status);
         IF status > 0 then GOTO 500;

         IF curRgList then
            BEGIN
            chkCurRg(Pdifftable^[scanid]^.curhandle,MMLAST,snipid,cstatus);
            IF cstatus = 0 then goto 999;
            END;

         GetSnipBlock(snipid,len + sizeOf(rowsniprecord)+SetSize + RecExpand,Status);
         IF Status <> 0 THEN
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,GetSID,'MMNext GetSnipBlock status: ',Status);
            GOTO 500;
            END;

         InitSnipPtr(rowkind,snipid);
         SetUpRec(rowsnip,snipid,len,setsize,usererror,@ErrBits,status);
         WITH TableData DO {Link new snip into bottom of list}
         InsertRowSnips(TopRow,BottomRow,BottomRow,SnipId,SnipId);
         END;




MMPrior: BEGIN
         InsertAtTop := TRUE;

         {Set Snipid to MInf here. This will be the default returned
         in case we run into trouble with the intrinsics.}
         SnipId := MInfSnip;

         IF (refid = TableData.FirstRow)
         OR (refId = MInfSnip) THEN GOTO 999;

         IF RefId = PInfSnip THEN
            BEGIN
            WITH TableData DO IF LastRow <> NullSnip THEN
               BEGIN
               SnipId := LastRow;
               GOTO 999;
               END;
            {process this as though it were an MMLast}
            RealMode := MMLast;
            GOTO 400;
            END;

         {At this point, we know refid is a real snip.}
         SetSnipPtr(snip,refid);
         IF RowSnip^.PriorSnip <> nullSnip then
            BEGIN
            SnipId := RowSnip^.PriorSnip;
            GOTO 999;
            END;

         {The prior snip is null, and furthermore, it is not the first
         one in the table. Consequently, this had better be the list.}

         {If the scan is not open, return the default MInf}
         IF NOT ScanOpen THEN GOTO 999;

         ptrhand := POINTER(ORD(rowsnip) + rowsnip^.handoffset);
         lmfetch(status,userError,@ErrBits,scanid,exact,ptrhand^,len);
         IF status <> 0 then
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,GetSId,'MMPrior LMFetch1 status: ',Status);
            GOTO 500;
            END;

         lmfetch(status,userError,@ErrBits,scanid,prior,shandle,len);
         IF status = EOS then
            BEGIN
            TableData.FirstRow := Refid;
            GOTO 999;
            END;

         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,GetSId,'MMPrior LMFetch2 status: ',Status);
         IF status > 0 then GOTO 500;

         IF curRgList then
            BEGIN
            chkCurRg(Pdifftable^[scanid]^.curhandle,MMFIRST,snipid,cstatus);
            IF cstatus = 0 then goto 999;
            END;

         GetSnipBlock(snipid,len+sizeOf(rowsniprecord)+SetSize + RecExpand,Status);
         IF Status <> 0 THEN
            BEGIN
            IF MMTrap1 THEN WriteLn(Bell,GetSID,'MMPrior GetSnipBlock status: ',Status);
            GOTO 500;
            END;

         InitSnipPtr(rowkind,snipid);
         SetUpRec(rowsnip,snipid,len,setsize,usererror,@ErrBits,status);
         WITH TableData DO {Insert row into beginning of list}
         InsertRowSnips(TopRow,BottomRow,NullSnip,SnipId,SnipId);
         END;




MMFraction: BEGIN
            FindPctRow(position,snipid);
            IF Trace2MMgr THEN WriteLn(GetSId,'Id returned from FindPctRow: ',SnipId);
            END;

         END; {case mode}



      Colkind:
      BEGIN
      CASE RealMode OF

         MMFirst: BEGIN
                  {Return SnipId of first col}
                  SnipId := Tabledata.FirstCol;
                  if snipid = nullsnip then
                     begin
                     snipid := pinfsnip;
                     end
                  else
                     begin
                     SetSnipPtr(colkind,snipId);
                     IF NOT colsnip^.visible then getnxtviscol(snipId);
                     end;

                  END;

         MMLast: BEGIN
                 {Return SnipId of last col}
                 SnipId := tableData.LastCol;
                 if snipid = nullsnip then
                    begin
                    snipid := pinfsnip;
                    end
                 else
                    begin
                    SetSnipPtr(colkind,snipId);
                    IF NOT colsnip^.visible then getprvviscol(snipId);
                    end;
                 END;

         MMNext: BEGIN
                 {Find next visible column}
                 SnipId := RefId;
                 GetNxtVisCol(SnipId);
                 END;

         MMPrior: BEGIN
                  {Find prior visible column}
                  SnipId := RefId;
                  getprvviscol(snipId);
                  END;

         MMFraction: BEGIN
                     {Get the column id of the requested position}
                     FindPctCol(Position,NewCol);

                     {If PInfSnip is returned, it means there are no visible cols}
                     IF NewCol = PInfSnip THEN
                        BEGIN
                        IF Trace2MMgr THEN WriteLn('No columns are visible');
                        SnipId := PInfSnip;
                        GOTO 999;
                        END;

                     {Get the column snipid of the current scroll position.}
                     {Get point in current view}
                     TMCurVwPt(CurPt);
                     IF Trace2MMgr THEN WriteLn('H: ',CurPt.H,' V: ',CurPt.V);
                     {Get currently visible range}
                     VisRgOfView(CurPt,VisRg);
                     OldCol := VisRg.LoCol;

                     {If OldCol is null, it means that the current table is
                     not displaying any columns. In this case, always return
                     the snip which was returned by FindPctCol}
                     CASE OldCol OF
                        PInfSnip,MInfSnip,NullSnip:
                           BEGIN
                           IF Trace2MMgr THEN WriteLn('No columns were visible');
                           SnipId := NewCol;
                           GOTO 999;
                           END;
                        END; {Case}

                     {Get the elevator position of the current column}
                     CalcThumb(TRUE,OldPosition);

                     {If the user has moved the elevator left, we will always
                     scroll right and vice versa. Determine which way the
                     elevator moved.}
                     IF OldPosition > Position THEN
                        BEGIN
                        {Elevator has been moved left. This means scroll right.
                        It also means that the snip returned will be prior to
                        the snip currently on the left side of the screen}
                        IF Trace2MMgr THEN WriteLn('Elevator moved to left');
                        IF SnipLT(ColKind,NewCol,OldCol) THEN SnipId := NewCol
                        ELSE BEGIN
                             {This case occurs when the elevator is pegged
                             to the right side because gray is showing, and
                             although the new position of the elevator maps
                             to a snip which is to the right of the current
                             one, we know that because the user moved the
                             elevator left that he really wants to scroll right.

                             This case also occurs when the new position still maps to the same
                             column which is already showing. In this case, the elevator may be
                             anywhere.}
                             IF Trace2MMgr THEN WriteLn('Getting prior column..');

                             {Get the visible column prior to current}
                             SnipId := OldCol;
                             GetPrvVisCol(SnipId);
                             IF SnipId = MInfSnip THEN SnipId := OldCol;
                             END;
                        END

                     ELSE IF OldPosition < Position THEN
                          BEGIN
                          {Elevator has been moved to the right. New snip
                          must follow the current one.}
                          IF Trace2MMgr THEN WriteLn('Elevator moved to right');
                          IF SnipLT(ColKind,OldCol,NewCol) THEN SnipId := NewCol
                          ELSE BEGIN
                               {Get the visible column next after current}
                               IF Trace2MMgr THEN WriteLn('Getting next column..');
                               SnipId := OldCol;
                               GetNxtVisCol(SnipId);
                               IF SnipId = PInfSnip THEN SnipId := OldCol;
                               END;
                          END

                     ELSE BEGIN
                          {No movement. In most cases, return the same column which is currently
                          showing. However, if the endpoints are involved, return the snip which
                          would have been returned if the user had moved the elevator there from
                          somewhere else. }
                          IF (Position = 0) OR (Position = 1000) THEN SnipId := NewCol ELSE SnipId := OldCol;
                          END;
                     END;

         END; {case mode}

         END; {Colkind}

   END; {CASE Snip}

999:if TraceMMGR then WriteLn(MxMgr,GetSId,' Snip returned: ',snipid:3);
   EXIT(GetSnipId);

500: {Problem occurred with the database intrinsics}
   {Set appropriate conditions so that structures are valid}
   WITH TableData DO CASE RealMode OF

      MMFirst,MMLast: BEGIN
                      FirstRow := PInfSnip;
                      LastRow := MInfSnip;
                      END;
      MMNext: BEGIN
              SnipId := PInfSnip;
              LastRow := BottomRow;
              END;

      MMPrior: BEGIN
               SnipId := MInfSnip;
               FirstRow := TopRow;
               END;

      END; {Case}

   {Put up an alert box}
   DBAlert(DisplayErr,Status);

   {Now update region invalidated by alert box in case scrolling was going on.}
   DoFldrUpdate;

   {Null out the current range. This is done because the only response GetSnipId can give to
   the table editor when an error occurs is to pretend that the table is actually smaller than
   it really is. This leads to problems if the current range happens to be outside of the
   truncated table. So we just get rid of the current range when an error occurs.}
   NullCR;
   IF CurRgList THEN RelCrgList;
   GOTO 999;
   END;

{$S lminit}

Procedure GetStrings;

var AlertString : stringtype;
    TruncString : Str40;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

   {Call GetAlert to get the colSpecs row headers from the LMALERT file.  Read alert phrase into }
   { a string of 255 bytes but only use the first 40 characters.                                 }

   GetAlert(LMALERTS,DataType,@AlertString);
   DTypHeader := Copy(AlertString,1,cmin(length(AlertString),40));
   GetAlert(LMALERTS,DataFormat,@AlertString);
   DFmtHeader := Copy(AlertString,1,cmin(length(AlertString),40));
   GetAlert(LMALERTS,SortOrder,@AlertString);
   SortHeader := Copy(AlertString,1,cmin(length(AlertString),40));
   GetAlert(LMALERTS,Visible,@AlertString);
   VisiHeader := Copy(AlertString,1,cmin(length(AlertString),40));

   {Call GetAlert to read in THRU operator string into a 255 byte string.  Only use the first }
   { 38 characters.  Pad string with a blank at beginning and end.                            }

   GetAlert(LMALERTS,ThruOperator,@AlertString);

   TruncString := Copy(AlertString,1,cmin(length(AlertString),38));
   ThruString := concat(' ',TruncString,' ');
   ThruLength := length(ThruString);

   {Call Getalert to read in the Sort strings}

   GetAlert(LMALERTS,SortAsc,@AlertString);
   SrtAscString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,SortDes,@AlertString);
   SrtDesString := copy(AlertString,1,cmin(length(AlertString),20));

   GetAlert(LMALERTS,VisYes,@AlertString);
   VisYesString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,VisNo,@AlertString);
   VisNoString := copy(AlertString,1,cmin(length(AlertString),20));

   GetAlert(LMALERTS,DTText,@AlertString);
   DTTextString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,DTNumber,@AlertString);
   DTNumbString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,DTDate,@AlertString);
   DTDateString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,DTSocSec,@AlertString);
   DTSocSString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,DTTelephone,@AlertString);
   DTTeleString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,DTTime,@AlertString);
   DTTimeString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,DTZipCode,@AlertString);
   DTZipCString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,DTMoney,@AlertString);
   DTMonyString := copy(AlertString,1,cmin(length(AlertString),20));
   GetAlert(LMALERTS,DTTicket,@AlertString);
   DTTcktString := copy(AlertString,1,cmin(length(AlertString),20));

end;




