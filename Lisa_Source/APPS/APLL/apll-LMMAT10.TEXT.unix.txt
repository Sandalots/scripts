{$S lmres}
FUNCTION SnipToPtr{SnipId:Idtype) : TH};
   {This routine converts a snipmaped pointer to a real snipzone pointer }

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

   SnipToPtr := POINTER(ORD(SnipZone) + SnipMap[SnipId]);
   END;



{$S lmres }
FUNCTION SnipWidth{Snip: Snipkind;
                   SnipId: IdType): INTEGER};

    {This function returns the width in pixels of the snip whose identifier
    is passed in SnipId.}


    CONST SWidth = ' SnipWidth';

    BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
    IF TraceMMGR then WriteLn(MxMgr,SWidth,' SnipKind: ',Ord(Snip):2,' SnipId: ',SnipId:4);

    {Check for various errors. Errors of these kind are generally caused by
    bugs at the upper level. However, in this particular case, it may only
    result in some wierd behavior, which would be preferable to causing the
    system to crash. For this reason, if such an error is detected, a 0 is
    returned as the width with the hope that the system will keep running.}
    IF NOT(Snip IN [Colkind,Rowkind]) THEN
       BEGIN
       IF MMTrap1 THEN WriteLn(Bell,'***Invalid snip type passed to SnipWidth');
       SnipWidth := 0;
       Exit(SnipWidth);
       END;
    IF (SnipId < -2) OR (SnipId = NullSnip) THEN
       BEGIN
       IF MMTrap1 THEN WriteLn(Bell,'***Bad snip to SnipWidth: ',SnipId);
       SnipWidth := 0;
       Exit(SnipWidth);
       END;

    {Determine if snip is a row or a column and return the appropriate width.}
    CASE Snip OF

       Colkind: BEGIN
                IF snipid = minfsnip then snipwidth := TableData.rowtitlewidth
                ELSE BEGIN
                     {Set up snip pointer }
                     SetSnipPtr(snip,snipid);

                     SnipWidth := ColSnip^.Width;
                     END;
                END; {Colkind}


       RowKind: BEGIN
                IF snipid = minfsnip then snipwidth := TableData.coltitleheight
                ELSE SnipWidth := TableData.RowHeight;
                END; {Rowkind}

       END; {CASE Snip}

    END;


{$S lmsearch }
PROCEDURE SrchTWrite{Mode: IOModeType;
                     RowId:  IdType;
                     ColId:  IdType;
                     Value:  PtrData;
                     WideFlg: BOOLEAN;
                     VAR numbytes:  INTEGER;
                     VAR Status: INTEGER};

   LABEL 999;

   const cbufsize = 200;
         STW = ' SrchTWrite ';

   VAR i,j:integer;
       buf1snip,
       buf2snip : idtype;
       buf1hnd,
       buf2hnd : hnddata;
       Buf1size,Buf2size : integer;
       SpecColid, ListColId : idtype;
       SpecColSnip,ListColSnip: ptrcolsnip;
       action,oplen : integer;
       hdata : hnddata;
       vptr : ptrvfld;
       rsize,rsizeavail : integer;
       uplen,delta : integer;
       oldoffset:integer;
       Rarray : Array [0..maxrun] of run;
       numruns : integer;
       numstr : integer;
       sindex1,sindex2 : integer;
       Len,len1,len2 : integer;
       startbold,endbold : integer;
       bptr : ptrdata;
       newnumruns : integer;
       Rarray2: Array [0..maxrun] of run;
       FldPtr: PtrDBField;
       ErrNum: INTEGER;
       LStatus: INTEGER;
       index : integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,STW);

   buf1size := cbufsize;
   buf2size := cbufsize;

   GetSnipBlock(buf1snip,buf1size,LStatus);
   getsnipBlock(buf2snip,buf2size,LStatus);

   buf1hnd := POINTER(ORD(SNIPTOPTR(buf1snip)));
   buf2hnd := POINTER(ORD(SnipToPtr(Buf2snip)));

   SearchValid := FALSE;
   numruns := maxrun-1;
   CellRun(MMread ,rowid,colid,@Rarray,numruns,status);
   if mmtrap1 then if status <> 0 then
      BEGIN
      WriteLn(Bell,'***CellRun status: ',Status);
      status := badsrchop;
      goto 999;
      END;

   {run matches string  }
   { now modify string by stripping off blanks at beginning, and adjust run accordingly}

   i := 0;
   while (value^[i] = ORD(' ')) AND (i<numbytes) do i := i+1;
   for j := 0 to numruns do Rarray[j].lpfst := Rarray[j].lpfst-i;
   value := @value^[i];
   numbytes := numbytes-i;

   parsesrch(value,numbytes,@Rarray,numruns,numstr,
             sindex1,sindex2,len1,len2,status);
   if status <> 0 then
      begin
      status := badsrchop;
      goto 999;
      end;



  if (numstr = 1) and ((numruns=1) ) then
     begin
     {check for typed in stuff}

     For i := 0 to maxrun do
       RArray2[i] := Rarray[i];

     BoldTypedOps(value,@Rarray2,sindex1,len1,newnumruns,status);

     if status = 0 then
        begin
        {found an operator}

        parsesrch(value,numbytes,@Rarray2,newnumruns,numstr,
               sindex1,sindex2, len1, len2,status);


        if trace2mmgr then writeln('parsrch returns status:' ,status:4);

        if status <> 0 then
           begin
           {reset back to normal runs; this is a real equality}

           parsesrch(value,numbytes,@Rarray,numruns,numstr,
                     sindex1,sindex2, len1, len2,status);

           end
        else
           begin
           {found an operator and parsed it successfully}
           For i := 0 to maxrun do
             RArray[i] := Rarray2[i];
           Cellrun(mmwrite,rowid,colid,@Rarray,newnumruns,status);
           if status <> 0 then
              begin
              status := srchtoobig;
              goto 999;
              end;
           numruns := newnumruns;
           end;
        end;
     end;

   if trace2mmgr then
       writeln('numstr ',numstr:3,'sindex1 ',sindex1:4,'len1 ',len1:4);

   SpecColId := Colid;
   SetSnipPtr(ColKind,SpecColId);
   ListColId := ColSnip^.ListSnip;
   SpecColSnip := ColSnip;
   SetSnipPtr(ColKind,ListColId);
   ListColSnip := ColSnip;

   {construct a field datastructure for legal and pack }
   oldoffset := listcolsnip^.fieldinfo.offset;
   fldptr := @listcolsnip^.fieldinfo;
   {now the correct offset}

   fldptr^.offset := 0;


   {initialize the record }
   if (fldptr^.reptype = ftypvstr)  or (fldptr^.reptype = ftypvnull) then
      begin
      vptr := POINTER(ORD(buf1hnd^) + 0) ;
      vptr^.offset := 4;
      vptr^.size := 0;
      end;


   {check for legality}

   legal(fldptr,@value^[sindex1],len1,errnum);
   if errnum <> 0 then
      begin
      if trace2mmgr then writeln('error from legal: ',errnum:4);
      fldptr^.offset := oldoffset;
      status := errnum + CvtErr;
      goto 999;
      end;

   {setup for pack call }
   if trace2mmgr then writeln('before 1st pack');

   rsize := fldptr^.size;
   rsizeavail := cmin(buf1size ,maxdbrecsize-sizeof(Preamble));

   pack(0,fldptr, @value^[sindex1], len1, buf1hnd^, rsizeavail, rsize,
        delta, errnum);

   if errnum = rectoosmall then
      begin
      expsnipblock(buf1snip,buf1size+delta,LStatus);
      buf1size := buf1size+delta;
      rsizeavail := cmin(buf1size ,maxdbrecsize-sizeof(Preamble));
      SetSnipPtr(ColKind,SpecColId);
      SpecColSnip := ColSnip;
      SetSnipPtr(ColKind,ListColId);
      ListColSnip := ColSnip;
      fldptr := @listcolsnip^.fieldinfo;
      pack(0,fldptr, @value^[sindex1], len1, buf1hnd^, rsizeavail, rsize,
        delta, errnum);
      if errnum = rectoosmall then
         begin
         status := srchtoobig;
         goto 999;
         end;

      end
   else if errnum <> 0 then
      begin
      status := srchtoobig;
      goto 999;
      end;

   if trace2mmgr then if delta <> len1 then
      writeln('delta <> len1 : ', delta:4);


   {unpack the value back}

   if trace2mmgr then writeln('before 1st unpack');
   i := 0;
   while (value^[i] = ORD(' ')) and (i < sindex1) do i := i + 1;
   getaction(@value^[i],sindex1-i,true,action,oplen,status);
   if oplen >0 then
      begin

      moveleft(value^,buf2hnd^^,sindex1);
      len := sindex1;
      while (len-1 >= 0) and (buf2hnd^^[len-1] = ord(' ')) do len := len - 1;
      end
   else {oplen = 0}
      begin
      if (len1>0) and (numstr = 1) then
         begin
         buf2hnd^^[0] := ord('=');
         len :=1;
         end
      else len := 0;{a thru b}
      end;


   unpack(fldptr,@buf2hnd^^[len],buf2size-len,uplen,buf1hnd^,errnum);
   if errnum = dsptoosmall then
      begin
      expsnipblock(buf2snip,uplen+len,LStatus);
      buf2size := uplen+len;
      SetSnipPtr(ColKind,SpecColId);
      SpecColSnip := ColSnip;
      SetSnipPtr(ColKind,ListColId);
      ListColSnip := ColSnip;
      fldptr := @listcolsnip^.fieldinfo;
      unpack(fldptr,@buf2hnd^^[len],buf2size-len,uplen,buf1hnd^,errnum);
      end
   else if errnum <>  0 then
      begin
      IF trace2mmgr then writeln('error from unpack ',errnum : 4);
      status := srchtoobig;
      goto 999;
      end;

   if numstr = 1 then
      begin

      if (numruns = 1) and (len = 0) then
         begin
         {empty cell}
         end
      else
         begin
         setrun(Rarray[0],0,true);
         setrun(Rarray[1],len,false);
         numruns := 2;
         end;
      end;

   len := uplen + len ;

   IF numstr = 2 then
      begin
      startbold := len;
      {move in thru }
      if trace2mmgr then writeln('about to put in thru ');

{u}   if len+ThruLength > buf2size then
         begin
         expsnipblock(buf2snip,buf2size+10,LStatus);
         buf2size := buf2size+10;
         SetSnipPtr(ColKind,SpecColId);
         SpecColSnip := ColSnip;
         SetSnipPtr(ColKind,ListColId);
         ListColSnip := ColSnip;
         fldptr := @listcolsnip^.fieldinfo;
         end;

      bptr := @ThruString;
      bptr := Pointer(ord(bptr) + 1);
      moveleft(bptr^,buf2hnd^^[len],ThruLength);

      len := Len + ThruLength;

      endbold := len;
      {initialize the record }
      if (fldptr^.reptype = ftypvstr)  or (fldptr^.reptype = ftypvnull) then
         begin
         vptr := POINTER(ORD(buf1Hnd^) + 0);
         vptr^.offset := 4;
         vptr^.size := 0;
         end;


      {check for legality}

      if trace2mmgr then writeln('check 2nd string for legal');
      legal(fldptr,@value^[sindex2],len2,errnum);
      if errnum <> 0 then
         begin
         if trace2mmgr then writeln('error from legal: ',errnum:4);
         fldptr^.offset := oldoffset;
         status := errnum + CvtErr;
         goto 999;
         end;

      {setup for pack call }

      rsize := fldptr^.size;
      rsizeavail := cmin(buf1size,maxdbrecsize-sizeOF(preamble));

      if trace2mmgr then
         begin
         writeln(' before 2nd pack','rsizeavail', rsizeavail:5);
         writeln('buf1size,len', buf1size:5,len:5);
         end;
      pack(0,fldptr, @value^[sindex2], len2, buf1hnd^, rsizeavail, rsize,
         delta, errnum);

      if trace2mmgr then
         begin
         writeln(' after 2nd pack','errnum', errnum:5);
         writeln('delta', delta:5);
         end;
      if errnum = rectoosmall then
         begin
         expsnipblock(buf1snip,buf1size+delta,LStatus);
         buf1size := buf1size+delta;
         rsizeavail := cmin(buf1size,maxdbrecsize-sizeOF(preamble));
         if trace2mmgr then
            begin
            writeln(' before 2nd pack after exp ',
                      'rsizeavail', rsizeavail:5);
            writeln('buf1size,len', buf1size:5,len:5);
            end;
         SetSnipPtr(ColKind,SpecColId);
         SpecColSnip := ColSnip;
         SetSnipPtr(ColKind,ListColId);
         ListColSnip := ColSnip;
         fldptr := @listcolsnip^.fieldinfo;
         pack(0,fldptr, @value^[sindex2], len2, buf1hnd^, rsizeavail, rsize,
           delta, errnum);
         if errnum = rectoosmall then
            begin
            status := srchtoobig;
            goto 999;
            end;
         end
      else if errnum <> 0 then
         begin
         status:= srchtoobig;
         goto 999;
         end;

      if trace2mmgr then if delta <> len then
         writeln('delta : ', delta:4);


      {unpack the value back}
      if trace2mmgr then writeln(' before 2nd unpack');

      unpack(fldptr,@buf2hnd^^[len],buf2size-len,uplen,buf1hnd^,errnum);
      if errnum = dsptoosmall then
         begin
         expsnipblock(buf2snip,uplen+len,LStatus);
         buf2size := uplen+len;
         SetSnipPtr(ColKind,SpecColId);
         SpecColSnip := ColSnip;
         SetSnipPtr(ColKind,ListColId);
         ListColSnip := ColSnip;
         fldptr := @listcolsnip^.fieldinfo;
         unpack(fldptr,@buf2hnd^^[len],buf2size-len,uplen,buf1hnd^,errnum);
         end
      else if errnum <>  0 then
         begin
         IF trace2mmgr then writeln('error from unpack ',errnum : 4);
         status := srchtoobig;
         goto 999;
         end;
      len := len + uplen;
      setrun(Rarray[0],0,false);
      setrun(Rarray[1],startbold,true );
      setrun(Rarray[2],endbold,false);

      numruns := 3;
      end;

   SetSnipPtr(ColKind,SpecColId);
   SpecColSnip := ColSnip;
   SetSnipPtr(ColKind,ListColId);
   ListColSnip := ColSnip;

   listcolsnip^.fieldinfo.offset := oldoffset;


   {put back into the real string}

   IF trace2mmgr then writeln('uplen ',uplen:4);

   if trace2mmgr then writeln('before cellv');
   CellV(Mode,RowId,ColId,NIL,buf2hnd,WideFlg,len,Status);
   if status <> 0 then
      BEGIN
      status := srchtoobig;
      goto 999;
      END;

   if trace2mmgr then writeln('before cellrun');

   {blank cells have no runs}
   if len = 0 then numruns := 0;

   CellRun(MMwrite,rowid,speccolid,@Rarray,numruns,status);
   if status <> 0 then
      BEGIN
      status := srchtoobig;
      goto 999;
      END;

   if trace2mmgr then writeln('exiting cellvalue for tsearch');

999: {Free up the buffers}
   fresnipblock(buf1snip);
   fresnipblock(buf2snip);

   END;



{$S lmcolspec }
PROCEDURE StripBlanks{DataPtr: PtrData;
                       VAR Len: INTEGER};

    CONST SB = ' StripBlanks';

    VAR I: INTEGER;

    BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
    IF TraceMMgr THEN WriteLn(MxMgr,SB);
    {Strip off leading blanks}
    I := 0;
    WHILE (I < Len) AND (DataPtr^[I] = Ord(' ')) DO I := I + 1;
    IF I > 0 THEN
       BEGIN
       Len := Len - I;
       MoveLeft(DataPtr^[I],DataPtr^[0],Len);
       END;

    {Strip trailing blanks}
    I := Len - 1;
    WHILE (I >= 0) AND (DataPtr^[I] = Ord(' ')) DO I := I - 1;
    Len := I + 1;
    END;



{$S lmclosedoc }
PROCEDURE SuspendDoc;

   LABEL 700,800,900;

   CONST SD = ' SuspendDoc';

   VAR Header: SuspHeader;
       Status: INTEGER;
       Length: LONGINT;
       Length2: INTEGER;
       Actual: LONGINT;
       I,J: INTEGER;
       Hand: TH;
       SusDataPtr: HndData;
       SuspendData: SuspendRecord;
       Col: IdType;
       PriorCol: IdType;
       PriorOrder: INTEGER;
       DDiscSize: LONGINT;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,SD);

   {Error strategy: The only real error which is possible, other than
   catastrophic errors in the file system, would be to run out of disc
   space when trying to write the suspend information. However, space
   for suspending should be guaranteed. This is because the space used
   by the snip data segment is released prior to writing to the suspend
   file, and this space should be more than enough since the contents of
   this segment make up most of the suspend information.
   Consequently, the probability
   of a failure in this procedure is so small that there is little
   point in putting in a lot of code to back out of an unsuccessful suspend.
   In the event a failure does occur, the user will end up losing whatever
   updates were unposted.

   In the future, it may be desirable to add a status parameter to this
   procedure, so that the user may be notified if problems occur.}

   {If this is the colspec table and columns have been cut, then it is
   necessary to paste them back in before suspending. This is because the
   contents of the scrap are not saved, yet we can't lose the columns.}
   IF (NOT CreatingTable) AND (CurTable = TColSpecs) AND ColumnsCut THEN
      BEGIN
      UnPasteCols;
      ClearScrap(status);
      END;

   {Get rid of any unnecessary snips}
   MMCallingMakeSpace := TRUE;
   I := MakeSpace(SnipZone,0);
   MMCallingMakeSpace := FALSE;

   {Release the disc space associated with the snip zone. This will free up space for the
   suspend file if necessary. It also causes the data seg to be unswappable until closed, however.}
   DDiscSize := -SegDiscSize;
   Size_DataSeg(Status,SegRefNum,0,SegMemSize,DDiscSize,SegDiscSize);
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***Size_DataSeg status: ',Status);

   {Write out the interface globals}
   SuspendData.CurTable := CurTable;
   SuspendData.CreatingTable := CreatingTable;
   SuspendData.ColumnsCut := ColumnsCut;
   SuspendData.RowsCut := RowsCut;
   SuspendData.ListTitle := ListTitle;
   SuspendData.DocPassWord := DocPassword;
   SuspendData.PromptString := PromptString;
   SuspendData.SizeRowTitle := SizeRowTitle;
   SuspendData.ErrorList := ErrorList;
   SuspendData.Scrolling := Scrolling;
   SuspendData.CurRgList := CurRgList;
   SuspendData.TypeRow := TypeRow;
   SuspendData.EditCRow := EditCRow;
   SuspendData.SortRow := SortRow;
   SuspendData.VisibleRow := VisibleRow;
   SuspendData.RedefiningTable := RedefiningTable;
   SuspendData.DocScrapId := DocScrapId;

   {The next set of variables are in the implementation}

   I := 1;
   while I <= maxsnips do
     begin
     SuspendData.SnipMap[I] := SnipMap[I];
     I := I + 1;
     end;

   SuspendData.FreeSnipList := FreeSnipList;
   SuspendData.TableData := TableData;
   SuspendData.TableChars := TableChars;
   SuspendData.ListTable := ListTable;
   SuspendData.ListChars := ListChars;
   SuspendData.ColSpecData := ColSpecData;
   SuspendData.ColSpecChars := ColSpecChars;
   SuspendData.CutCol := CutCol;
   SuspendData.CutRow := CutRow;
   SuspendData.MMScrapRg := MMScrapRg;
   SuspendData.TableCut := TableCut;
   SuspendData.ListHeader := ListHeader;
   SuspendData.ScanOpen := ScanOpen;
   SuspendData.ScanId := ScanId;
   SuspendData.BlankLine := BlankLine;
   SuspendData.BlankHandle := BlankHandle;
   SuspendData.RowChanged := RowChanged;
   SuspendData.ListRowCount := ListRowCount;
   SuspendData.ListModified := ListModified;
   SuspendData.SchemaChanged := SchemaChanged;
   SuspendData.ListFormChanged := ListFormChanged;
   SuspendData.SortValid := SortValid;
   SuspendData.SortPtr := SortPtr;
   SuspendData.NSKeys := NSKeys;
   SuspendData.CSKeys := CSKeys;

   I := 0;
   while I <= maxcols do
     begin
     SuspendData.SortArray[I] := SortArray[I];
     I := I+1;
     end;

   SuspendData.SearchValid := SearchValid;
   SuspendData.NumTriples := NumTriples;
   SuspendData.ConstSize := ConstSize;
   SuspendData.Constsnip := ConstSnip;
   SuspendData.Exprsnip := ExprSnip;
   SuspendData.RunRow := RunRow;

   I := 0;
   while I <= maxintwdsize do
     begin
     SuspendData.NullNA[I] := NullNA[I];
     I := I+1;
     end;

   SuspendData.CurRgSnip := CurRgSnip;
   SuspendData.InsertAtTop := InsertAtTop;
   SuspendData.ListScrollValid := ListScrollValid;
   SuspendData.ListTopHandle := ListTopHandle;
   SuspendData.HScrollId := HScrollId;
   SuspendData.MMFontinfo := MMFontinfo;
   SuspendData.BytesAdded := BytesAdded;
   SuspendData.SVersion := SCurVersion;
   SuspendData.DelCol := DelCol;
   SuspendData.CopyListColumns := CopyListColumns;
   SuspendData.ColumnsDeleted := ColumnsDeleted;
   SuspendData.MMPrintPreference := MMPrintPreference;
   SuspendData.Sorted :=  Sorted;
   SuspendData.SortRequested := SortRequested;
   SuspendData.Searched := Searched;
   SuspendData.SearchRequested := SearchRequested;
   SuspendData.MagCaution := MagCaution;

   Header.Code := MGlobals;
   Length := SizeOf(SuspendRecord);
   IF Trace2MMgr THEN WriteLn('Matrix manager globals length: ',Length);
   Header.Len := Length + 4;

   {First write code and length}
   Write_Data(Status,SuspRefNum,ORD(@Header),4,Actual,Sequential,0);
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***Write_Data status: ',status);
      GOTO 800;
      END;

   {Now write  actual interface globals}
   Write_Data(Status,SuspRefNum,ORD(@SuspendData),Length,Actual,Sequential,0);
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***Write_Data status: ',status);
      GOTO 800;
      END;

   {Now write out all of the snip blocks. Loop through the snip map, and for
   each cell which is not null, get the length and address of the snip and
   write it to the file.}

   {Loop through the list of free snips and set their pointers to null. This
   is necessary so that in the next step, we can loop through the entire snip
   map and distinguish valid snips from free ones. Given a snip on the map as
   it stands, there is no way to tell if it points to a real block or is on
   the free list}
   IF  Trace2MMgr THEN WriteLn('Setting free list null...');

   I := FreeSnipList;
   WHILE I <> NullSnip DO
     BEGIN
     J := SnipMap[I]; {Point to next on free list}
     SnipMap[I] := NullSnip;
     I := J;
     END;

   {Now loop through all the snips which have blocks allocated}
   IF Trace2MMgr THEN WriteLn('Writing out snip blocks...');
   I := 1;
   while I <= maxsnips do
     begin
     IF SnipMap[I] <> NullSnip THEN
         BEGIN
         {Get the handle of the snip block}
         Hand := SnipToPtr(I);

         {Get the length of the snip block}
         Length2 := CBDataOfH(SnipZone,Hand);
         IF Trace2MMgr THEN WriteLn('SnipId: ',I,' Length: ',Length2);

         {Write the header}
         WITH Header DO
            BEGIN
            Code := MSnip;
            Len := Length2 + 6;
            SnipId := I;
            END;

         Write_Data(Status,SuspRefNum,ORD(@Header),6,Actual,Sequential,0);
         IF Status <> 0 THEN
            BEGIN
            IF MMTrap1 THEN WriteLn('***Write_Data status: ',status);
            GOTO 800;
            END;

         {Now write  actual snip block}
         Length := Length2;
         Write_Data(Status,SuspRefNum,ORD(@Hand^^),Length,Actual,Sequential,0);
         IF Status <> 0 THEN
            BEGIN
            IF MMTrap1 THEN WriteLn('***Write_Data status: ',status);
            GOTO 800;
            END;
         END;
     I := I+1;
     end; {while}

   {Now go get all of the information from the folder executive}
   IF Trace2MMgr THEN WriteLn('Calling PutSusData');
   PutSusData(SusDataPtr,Length2);
   IF Trace2MMgr THEN WriteLn('Address: ',ORD(@SusDataPtr^^),' ','Length: ',Length2);
   WITH Header DO
      BEGIN
      Code := Fexec;
      Len := Length2 + 4;
      END;

   {Write header}
   Write_Data(Status,SuspRefNum,ORD(@Header),4,Actual,Sequential,0);
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***Write_Data status: ',status);
      GOTO 700;
      END;

   {Write fexec globals}
   Write_Data(Status,SuspRefNum,ORD(@SusDataPtr^^),Length2,Actual,Sequential,0);
   IF Status <> 0 THEN IF MMTrap1 THEN WriteLn('***Write_Data status: ',status);

700: {Get rid of the block containing fexec globals}
   IF Trace2MMgr THEN WriteLn('Freeing fexec block...');
   Hand := POINTER(ORD(SusDataPtr));
   FreeH(HzFromH(Hand),Hand);

800: {All information has been written - Truncate and close the suspend file}
   IF Trace2MMgr THEN WriteLn('Truncating suspend file...');
   Truncate(Status,SuspRefNum);
   IF MMTrap1 THEN IF (Status <> 0) AND (Status <> 982) THEN WriteLn(Bell,'***Truncate status: ',Status);

   {Free up the disc space allocated past the end of file, but only if we are
   not holding it in reserve for posting.}
   IF BytesAdded = 0 THEN Compact(Status,SuspRefNum);
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn('***Compact status: ',status);

   IF Trace2MMgr THEN WriteLn('Closing suspend file...');
   Close_Object(Status,SuspRefNum);
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***Close_Object status: ',status);

900: {Close the differential and data file. Leave the differential file as is}
   IF NOT CreatingTable THEN
      BEGIN
      IF Trace2MMgr THEN WriteLn('Closing diff file...');
      DiffDestroy(Status,ScanId);
      IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***DiffDestroy status: ',status);
      END;

   {Close the data segment. Since it has been previously killed,
   this should cause it to be deleted.}
   Close_DataSeg(Status,SegRefNum);
   IF MMTrap1 THEN IF Status <> 0 THEN WRiteLn(Bell,'***Close_DataSeg status: ',status);

   {All done}
   END;



{$S lmres }
PROCEDURE SwitchFromList;

     {This procedure stores the global list pointers, etc, away in the
     ListTable record, and then clears the pointers and globals in the
     TableData record.}

     CONST SFL = ' SwitchFromList';

     BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
     IF TraceMMGR then WriteLn(MxMgr,SFL);

     ReleaseRowSnips;
     ListTable := TableData;

     WITH TableData DO
        BEGIN
        ColCount := 0;
        FirstCol := NullSnip;
        LastCol := NullSnip;
        END;

     END;

{u}
{$S lmscrap}
Procedure SwitchTable{(ScrapTable:boolean; var tableInfo:tableRecord)};

var
  row : idType;
  col : idType;
  Startrg : range;
  r : rect;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  if ScrapTable then    {from table to scrap}
    begin
    SaveScroll;

    if (MMScrapRg.rkind = aColRg) or (MMScrapRg.rkind = aWTBoxRg) then
      begin
      if tracemmgr then writeln('switchtable to scrap; currglist : ',currglist);
      printing := TRUE;         {set this flag so makespace will make cache work right}
      if CurRgList then RelCrgList;
      ReleaseRowSnips;

      {tell TE that the table has changed}
      GetSnipid(rowkind,mmfirst,0,row,row);
      GetSnipid(colkind,mmfirst,0,col,col);
      SetRg(StartRg,a1CellRg,row,col,row,col);
      ReBldTbl(StartRg);
      end;
    TableInfo := TableChars;
    end
  else {from Scrap to Table}
    begin
    if (MMScrapRg.rkind = aColRg) or (MMScrapRg.rkind = aWTBoxRg) then
      begin
      printing := FALSE;
      if tracemmgr then writeln('switchtable from scrap');
      GetCurPosSnip(row,col);
      SetRg(StartRg,a1CellRg,row,col,row,col);
      ReBldTbl(StartRg);
      end;
    TableInfo := TableChars;
    end;

end;

{$S lmres }
PROCEDURE SwitchToList;

     {This procedure initializes the necessary table globals for the list.}

     CONST STL = ' SwitchToList';

     BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
     IF TraceMMGR then WriteLn(MxMgr,STL);

     {Initialize the table information}
     CurTable := TList;
     TableData := ListTable;
     TableChars := ListChars;

     WITH TableData DO
        BEGIN
        {Don't init column pointers! ...They point to valid column specs.}
        {However, row pointers should be initialized}
        FirstRow := NullSnip;
        LastRow := NullSnip;
        TopRow := NullSnip;
        BottomRow := NullSnip;
        END;


  END;


{$S lmfilemenu }
PROCEDURE UndoTableEdits{VAR Status: INTEGER};

   CONST UTE = ' UndoTableEdits ';

   VAR TabRecord: TableRecord;
       Search: BOOLEAN;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,UTE);

   {Release any rows or columns in the scrap}
   RelScrap;

   {Case according to the current table}
   CASE CurTable OF

      TList:  BEGIN {This is a list}
              {Get rid of all updates in the differential file}
              DiffClose(Status,ScanId,FALSE); {NoPost close}
              IF Status <> 0 THEN
                 BEGIN
                 {Can't have run out of room, so problem is pretty
                 serious. However, since problem is serious, it means
                 the diff file is in no shape to post anyway, so the
                 changes are in effect, undone!!!. No real need to report
                 error to user at this time.}
                 IF MMTrap1 THEN WriteLn(Bell,'***UndoTableEdits DiffClose status: ',status);
                 END;
              ScanOpen := FALSE;
              BytesAdded := 0; {Reset counter of modifications for guaranteeing posting.}

              {Reset cut table flag}
              TableCut := FALSE;

              {If there are any current range snips, get rid of them too}
              IF CurRgList THEN RelCrgList;

              {Now load up the list again.}
              SwitchFromList;
              LoadList(TabRecord,TRUE,FALSE,FALSE);
              END;

      TColSpecs: BEGIN
                 {Remove all of the colspec table column and row snips}
                 ReleaseColSnips;
                 ColumnsCut := FALSE;
                 ColumnsDeleted := FALSE;

                 ReleaseRowSnips;

                 {If the table was being redefined, bring in the old copy
                 of the list snips and cancel redefine.}
                 IF RedefiningTable THEN WITH ListTable DO
                    BEGIN
                    {Release the list snips}
                    ReleaseSnips(ColKind,FirstCol);

                    {Since reference snips for HScrollId have been
                    released, must null out horiz scroll position}
                    HScrollId := NullSnip;

                    {Move copy of list snips back to ListTable}
                    FirstCol := CopyListColumns.FirstCol;
                    LastCol := CopyListColumns.LastCol;
                    ColCount := CopyListColumns.ColCount;
                    CopyListColumns.FirstCol := NullSnip; {Mark copy eliminated}
                    END;

                 {Load in a fresh redefining col spec table.}
                 LoadColSpecs(TabRecord);
                 END;

      TSearch: BEGIN
               {Remove all search table column and row snips}
               ReleaseColSnips;
               ReleaseRowSnips;

               {Load in a fresh search table.}
               LoadSearch(TabRecord);
               END;

      OTHERWISE IF MMTrap1 THEN MMFatalErr(LogicErr,UTE,'');
      END; {Case}
   END;

{$S lmscrap }
PROCEDURE Un_loadCutRectRg{VAR TableInfo: TableRecord};

   CONST UCR = ' Un_loadCutRectRg';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,UCR);

   {Switch back to the list. Remember both column and row snip pointers point
   at real lists of columns and rows.}

   {kludge to make rectrgs show up in scrap}
   with tabledata do
     begin
     SetSnipPtr(ColKind,LastCol);
     ColSnip^.NextSnip := SaveColNext;

     SetSnipPtr(RowKind,LastRow);
     RowSnip^.NextSnip := SaveRowNext;
     end;

   CurTable := TList;
   TableData := ListTable;
   TableChars := ListChars;
   TableInfo := TableChars;
   END;



{$S lmscrap }
PROCEDURE Unload_CutRows{VAR TableInfo: TableRecord};

   CONST UCR = ' Unload_CutRows';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,UCR);

   {Switch back to the list. Remember both column and row snip pointers point
   at real lists of columns and rows.}
   CurTable := TList;
   TableData := ListTable;
   TableChars := ListChars;
   TableInfo := TableChars;
   END;



{$S lmscrap }
PROCEDURE UnloadCutCols{VAR TableInfo:TableRecord};

   CONST UCC = ' UnloadCutCols';

   VAR Column: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,UCC);
{  IF MMTrap1 THEN IF CurTable <> TCutCols THEN MMFatalErr(LogicErr,UCC,''); }

   {Loop through all of the columns and restore previous visibility}
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^ DO
         BEGIN
         IF MiscId = Ord(TRUE) THEN Visible := TRUE
         ELSE {IF (CurTable = TCutCols) THEN} Visible := FALSE;
         Column := NextSnip;
         END;
      END;

   {Switch table params back to colspec params}
   IF (CurTable = TList) THEN
     BEGIN
     TableData := ListTable;
     TableChars := ListChars;
     END
   ELSE {CurTable = TCutCols}
     BEGIN
     CurTable := TColSpecs;
     TableData := ColSpecData;
     TableChars := ColSpecChars;
   END;
   TableInfo := TableChars;

   END;




{$S lmclosedoc }
PROCEDURE UnPasteCols;

   CONST UPC = ' UnPasteCols ';

   VAR I: INTEGER;
       PriorOrder: INTEGER;
       PriorCol: IdType;
       Col: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,UPC);

   {This procedure takes any columns in the scrap and pastes them back
   into the list in their original location}

   {Make sure there is something to paste back}
   IF NOT ColumnsCut THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***UnPasteCols called with no columns in scrap');
      Exit(UnPasteCols);
      END;

   {Determine snipId of previous column}
   SetSnipPtr(Colkind,CutCol.FirstCol);     {LM192}
   PriorCol := ColSnip^.PriorSnip;          {LM192}
   (*PriorCol := CutCol.FirstCol;
   GetPrvVisCol(PriorCol);
   IF PriorCol = MInfSnip THEN PriorCol := NullSnip;*)

   {Now paste the columns back in}
   PasteCols(PriorCol);
   END;



{$S lmres  }
PROCEDURE UpdateRow;

   {This procedure is called from the folder exec whenever the cursor moves
   out of a row. It must be called after the contents of any cell under
   modification have been entered, but before the cursor is moved.

   It first checks to see if there is a line which has been modified. If so,
   it causes it to be entered into the differential file.

   It then checks to see if there is no longer a blank line, and if not, adds the
   blank line and notifies the table manager.}

   LABEL 500;

   CONST UpRow  = ' UpdateRow ';

   VAR OldLastRow: IdType;
       RowId: IdType;
       DataPtr: PtrData;
       Status: INTEGER;
       CurRecSize: INTEGER;
       NewRecSize: INTEGER;
       HandlePtr: ^LMHandle;
       ErrPtr : PtrBits;
       AlertMsg: INTEGER;


   FUNCTION RowBlank(RowId: IdType): BOOLEAN;

      CONST RB = ' RowBlank';

      VAR Column: IdType;

      BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
      IF TraceMMgr THEN WriteLn(MxMgr,RB,'RowId: ',RowId:4);
      RowBlank := TRUE;
      Column := TableData.FirstCol;
      WHILE Column <> NullSnip DO
         BEGIN
         IF NOT CellBlank(RowId,Column) THEN
            BEGIN
            SetSnipPtr(ColKind,Column);
            IF ColSnip^.FieldInfo.FldType = Tick
            THEN Column := ColSnip^.NextSnip
            ELSE BEGIN
                 RowBlank := FALSE;
                 Column := NullSnip;
                 END;
            END

         ELSE BEGIN
              SetSnipPtr(ColKind,Column);
              Column := ColSnip^.NextSnip;
              END;

         END; {WHILE}
      END; {PROCEDURE}



   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Trace}
   IF TraceMMGR then WriteLn(MxMgr,UpRow);
   UpdRowErr := FALSE;

   IF (CurTable = TList) THEN
      BEGIN
      {If a line has been modified, enter it into the diff file}
      IF RowChanged <> NullSnip THEN
         BEGIN
         {Check scanopen in case there was trouble}
         IF NOT ScanOpen THEN
            BEGIN
            Status := 999;
            GOTO 500;
            END;

         {Make the record current of scan}
         SetSnipPtr(RowKind,RowChanged);
         HandlePtr := POINTER(ORD(RowSnip) + RowSnip^.HandOffset);
         ErrPtr := POINTER(ORD(Rowsnip) + RowSnip^.BitOffset);
         LMFetch(Status,rowsnip^.errorcode,errptr,ScanId,Exact,HandlePtr^,CurRecSize);
         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',UpRow,'LMFetch exact status: ',Status);
         IF Status <> NoErr THEN GOTO 500;

         {Now update the record}
         DataPtr := @HandlePtr^;
         NewRecSize := RowSnip^.DBRecSize; {Recsize must be even for LMUpdate}
         IF ODD(NewRecSize) THEN NewRecSize := NewRecSize + 1;
         LMUpdate(Status,ScanId,DataPtr,NewRecSize);
         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',UpRow,'LMUpdate status: ',Status);
         IF Status <> 0 THEN
500:        BEGIN
            UpdRowErr := TRUE;
            DBAlert(UpdateErr,Status);
            END

         ELSE BEGIN {Update succeeded}
              {Update count of new bytes added}
              BytesAdded := BytesAdded + CMax(0,(NewRecSize - CurRecSize));

              {Check to see if a new blank line should be added. If there is a blank line,
              then find out if the row which was just updated is the same as the blank line.}
              IF (BlankLine)
              AND (HandlePtr^.High = BlankHandle.High) AND (HandlePtr^.Low = BlankHandle.Low) THEN
                 BEGIN {Row which was updated was the blank row. Check if it is still blank}
                 IF Trace2MMgr THEN WRiteLn(UpRow,'Blank row was updated...');
                 IF NOT RowBlank(RowChanged) THEN
                    BEGIN {Blank line is no longer blank}
                    IF Trace2MMgr THEN WriteLn(UpRow,'Blank row is no longer blank');
                    BlankLine := FALSE;

                   {Since there is no longer a blank line, add one so long as the last row
                   in the list is still in the cache. If not, it will be added automatically
                   the next time that the list is scrolled to the bottom.}
                   IF (RowChanged = TableData.LastRow) THEN
                      BEGIN
                      IF Trace2MMgr THEN WriteLn(UpRow,'Adding new blank row...');
                      OldLastRow := TableData.LastRow;
                      AddBlank(RowId);

                      {Notify the table editor of the change. Note that in this case, we
                      do not want the screen to scroll, since simply entering a cell
                      should not cause scrolling, because it may be as the result of
                      clicking elsewhere, and if the screen moves, the point at which the
                      user clicked will not be correct.}
                      TMNewSnips(RowKind,OldLastRow,FALSE);
                      END; {New blank line added}
                   END; {Blank line no longer blank}
                 END;  {Blank line was updated}

              {Update globals}
              ListModified := TRUE;
              RowChanged := NullSnip;
              END;
         END; {RowChanged <> NullSnip}

      IF Trace2MMgr  THEN
         BEGIN
         IF Blankline THEN Writeln(MxMgr,UpRow,'Blankline = TRUE')
         ELSE Writeln(MxMgr,UpRow,'Blankline = FALSE');
         END;

      END; {CurTable = TList}
   END;

(*
{$S lmcolspec  }
PROCEDURE UpShift{Value: PtrData;
                  Len: INTEGER};

   VAR I: INTEGER;
       Char: BYTE;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' UpShift ');

   FOR I := 0 TO Len - 1 DO
      BEGIN
      Char := Value^[I];
      IF (Char >= Ord('a')) AND (Char <= Ord('z'))
      THEN Value^[I] := Char - (Ord('a') - Ord('A'));
      END;
   END;
*)


{$S lmres  }
FUNCTION VarField{ptrcs: ptrcolsnip): BOOLEAN};

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF Trace2MMgr THEN WriteLn(MxMgr,' VarField ');

   IF (ptrcs^.fieldinfo.reptype = ftypvstr ) OR
      (ptrcs^.fieldinfo.reptype = ftypvnull) then VarField := true
   ELSE VarField := false;
   END;



{$S lmlist }
PROCEDURE WriteList{VAR Status: INTEGER};

   {This procedure returns a nonzero status if anything went wrong in posting
   the updates. The scan is left open and the list should be redisplayed.
   Alert messages are displayed from this procedure. Running out of disc space is
   considered to be a serious error and unpdates are lost. This is because there
   is already an algorithm in place to try to prevent this error from ever occurring,
   and if it fails, this is a bug. The only errors which will cause Writelist to
   redisplay the table and refuse posting is in the case of user violations, which
   cannot occur first release.}

   LABEL 200,300,400,450,500;

   CONST WrtList = ' WriteList ';

   VAR RecSize: INTEGER;
       dummyset : Array [0..MaxIntWdSize] of Integer;
       UserError : integer;
       ConstPtr: PtrData;
       ExprPtr: PtrExpr;
       AlertMsg: INTEGER;
       StartRg: Range;
       Row: IdType;
       Col: IdType;
       TableInfo: TableRecord;
       ErrStatus: INTEGER;



   FUNCTION SpaceReleased(PagesToLeave: INTEGER): BOOLEAN;

      {This function cuts back the size of the suspend file, if it contains more pages than
      what is specified in PagesToLeave. If not, it returns false. The deallocated pages
      are then used to post updates from the differential file.}

      CONST SR = ' SpaceReleased ';

      VAR Status: INTEGER;
          SuspPages: INTEGER;
          DeallocPages: LONGINT;
          ActualDealloc: LONGINT;

      BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
      IF TraceMMgr THEN WRiteLn(MxMgr,SR,' PagesToLeave: ',PagesToLeave);

      {The following is a kludge to account for the fact that the first
      page in a file cannot be deallocated.}
      IF PagesToLeave = 0 THEN PagesToLeave := 1;

      SuspPages := (SuspFreeBytes + 511)  DIV 512;
      IF ((SuspPages = 1) AND (PagesToLeave = 1)) {Can't get rid of first block}
      OR (SuspPages <= PagesToLeave) THEN {No extra pages in suspend file}
         BEGIN
         {No free pages can be deallocated}
         SpaceReleased := FALSE;
         Exit(SpaceReleased);
         END;

      {Now deallocate the proper number of pages from the suspend file}
      IF MMTrap1 THEN WRiteLn('*** Cutting back suspendfile from ',SuspPages,' to: ',PagesToLeave,' pages');
      Deallocpages := SuspPages - PagesToLeave;
      Allocate(Status,SuspRefNum,FALSE,-DeallocPages,ActualDealloc);
      IF MMTrap1 THEN
         BEGIN
         IF Status <> 0 THEN WriteLn(Bell,'***',SR,'Allocate status: ',Status);
         IF ActualDealloc <> -DeallocPages
         THEN WriteLn(Bell,'***',SR,'Pages actually deallocated: ',ActualDealloc);
         END;

      {Subtract bytes deallocated from count of bytes in suspend file.}
      SuspFreeBytes := SuspFreeBytes + (ActualDealloc * 512); {Remember ActualDealloc is negative value}
      SpaceReleased := TRUE;
      END;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,WrtList);
   Status := 0;

   {Make sure the current table is the list}
   IF MMTrap1 THEN IF (CurTable <> TList) THEN MMFatalErr(LogicErr,WrtList,'');

   {Shrink the snip zone down}
   ShrinkHeap;

   {release any snips off screen since range is invalid. This must be done
   even if there is an error, since the rows could change.}
   IF CurRgList then relcrglist;

   {If a blank line was added, remove it first}
   IF BlankLine THEN
      BEGIN
      {Fetch blank line}
      LMFetch(Status,UserError,@DummySet,ScanId,Exact,BlankHandle,RecSize);
      IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',WrtList,'LMFetch exact status: ',Status);
      IF Status > NoErr THEN
         BEGIN
         {Failure to find the blank line is serious. Something is badly screwed.}
         GOTO 400;
         END;

      {Now delete the blank line}
      LMDelete(Status,ScanId);
      IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',WrtList,'LMDelete status: ',Status);
      IF Status > NoErr THEN
         BEGIN
         {Note - it should be impossible to get a NoRoom error when deleting
         the blank line, because the differential file uses fixed length keys.
         Therefore, an error at this point must be more serious.}
         GOTO 400;
         END;

      BlankLine := FALSE;
      END;

   {If modifications have occurred to the list, close the scan and post them.}
   IF ListModified THEN
      BEGIN
      {Cut back on the size of the suspend file to make room for posting}
      IF SpaceReleased(MinFreePages) THEN;

      {If the table has been cut, delete all records which meet the selection criteria.}
      IF TableCut THEN
         BEGIN
         {Delete all records which meet the selection criteria}
         IF ExprHnd = Nil THEN ExprPtr := Nil ELSE ExprPtr := ExprHnd^;
         IF ConstHnd = Nil THEN ConstPtr := Nil ELSE ConstPtr := ConstHnd^;

200:     DiffWADelete(Status,ScanId,ExprPtr,NumTriples,ConstPtr,ConstSize,4);
         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',WrtList,'DiffWild status: ',Status);
         IF Status > NoErr THEN
            BEGIN
            IF Status = NoRoom THEN IF SpaceReleased(0) THEN GOTO 200; {Retry}
            GOTO 400; {Serious}
            END;
         TableCut := FALSE;
         END;

300:  {Close the scan and post the updates}
      Sched_Class(ErrStatus,FALSE);
      DiffClose(Status,ScanId,TRUE);
      Sched_Class(ErrStatus,TRUE);
      IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',WrtList,'DiffClose status: ',Status);
         IF Status > NoErr THEN
         BEGIN
         IF Status = NoRoom THEN IF SpaceReleased(0) THEN GOTO 300; {Retry}
         GOTO 400; {Serious problem}
         END;

      ScanOpen := FALSE;
      END;

   {Now that everything has succeeded, it is possible to clean up
   the scrap without the possibility of having to redisplay
   in the event of an error}

   {Remember the scroll position}
   SaveScroll;

   {Reinitialize the number of bytes added since the last post}
   BytesAdded := 0;

   {Remember the list global information}
   SwitchFromList;
   CurTable := TNone;
   EXIT(WriteList);

400: {Serious problem with posting. Put up an alert,
   then cancel all of the changes. }

   IF Status = IOErr THEN AlertMsg := PostIOErr
   ELSE IF Status = NoRoom THEN AlertMsg := PostNoRoom
   ELSE AlertMsg := PostOtherErr;
   IF CautionAlert(LMAlerts,AlertMsg) THEN;

450: {Get rid of all the updates.}
   DiffClose(Status,ScanId,FALSE); {A 'no post' close}
   {No point in checking status, we already know there is a problem.}

   {Reset some flags}
   TableCut := FALSE;
   ScanOpen := FALSE;
   BlankLine := FALSE;

   {Forget the scroll position}
   ListScrollValid := FALSE;

   {Remember the list global information}
   SwitchFromList;
   CurTable := TNone;

   Status := 0;
   EXIT(WriteList);



500: {Come here if a Some_Violations error is returned. In this
   case give the user the choice of redisplaying what is left unposted,
   or allow him to cancel the remaining changes. This has not been implemented}

   (*{Put up the alert}
   AlertMsg := PostViolate;
   IF (askAlert(LMAlerts,AlertMsg) = 1) THEN GOTO 450;

   {Redisplay the unposted changes}

   {Set Status}
   Status := Status + DBErr;

   {Remove snips and switch into background}
   SwitchFromList;

   {Forget the scroll position}
   ListScrollValid := FALSE;

   {Load the list back up}
   {NOTE - must set some kind of flag to cause proper redisplay, similar
   to the way closed normal worked, but not tied to DiffOpen}
   {NOT YET IMPLEMENTED}
   LoadList(TableInfo,TRUE);

   {Redisplay the list}
   GetSnipId(RowKind,MMFirst,0,Row,Row);
   GetSnipId(ColKind,MMFirst,0,Col,Col);
   SetRg(StartRg,A1CellRg,Row,Col,Row,Col);
   ReBldTbl(StartRg);
   TmShoNewTbl;*)
   END;



{$S lmclosedoc }
PROCEDURE WritListForm{FileName: PathName;
                       VAR FormId: IdType};

   LABEL 400,500;

   CONST WLF = ' WritListForm ';
         MaxLabelRecord = 100; {50 words - size recommended by Chris Franklin}
         MaxLblIndex = 49;  {One less than maxlabelrecord}

   VAR FormPtr: PtrData;
       MoveTo: PtrData;
       Status: INTEGER;
       LabelRecord: ^LabelEntry;
       RecArray: ARRAY[0..MaxLblIndex] OF INTEGER;
       LabHdrSize: INTEGER;
       WordsLeft: INTEGER;
       NextChunk: INTEGER;
       MaxChunkSize: INTEGER;
       Ticket: BOOLEAN;
       MoveLen: INTEGER;
       WriteLen: INTEGER;
       LabelHdr: LabelEntry;
       ScanId: INTEGER;
       BytesLeft: INTEGER;
       AlertMsg: INTEGER;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,WLF);

   {Make sure the list is current}
   IF MMTrap1 THEN IF CurTable <> TList THEN MMFatalErr(LogicErr,WLF,'');

   {Set pointers to form}
   InitSnipPtr(ColKind,FormId);
   FormPtr := @ColSnip^;

   {Open a label update type access on the file}
   OpenScan(Status,@FileName,@FileName,ScanId,LabelUpdate);
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***OpenScan status: ',Status);
      GOTO 500;
      END;
   IF Trace2MMgr  then WriteLn(MxMgr,WLF,'ScanOpened');

   {Initialize various things necessary to write out label records}
   LabelRecord := @RecArray;
   LabHdrSize := SizeOf(LabelEntry);
   MoveTo := POINTER(ORD(LabelRecord) + LabHdrSize);
   WITH LabelRecord^ DO
      BEGIN
      LType := LstFormCode;
      Seq := -1;
      VarFld.Offset := LabHdrSize;
      END;
   MoveLeft(FormPtr^[0],BytesLeft,2); {Size of form in bytes.}
   IF Trace2MMgr  THEN WriteLn(MxMgr,WLF,'Formsize: ',FormPtr^[1]);
   NextChunk := 0;
   MaxChunkSize := MaxLabelRecord - LabHdrSize;
   Ticket := TRUE;

   {Loop as many times as necessary to write the form into the labels}
   WHILE BytesLeft > 0 DO
      BEGIN
      IF Trace2MMgr  THEN WriteLn(MxMgr,WLF,'Bytesleft: ',BytesLeft);
      {Move a block of information into record to be written}
      LabelRecord^.Seq := LabelRecord^.Seq + 1;

      IF BytesLeft >= MaxChunkSize THEN MoveLen := MaxChunkSize
         ELSE MoveLen := BytesLeft;
      LabelRecord^.VarFld.Size := MoveLen;

      {Now move the next chunk of words into the label record}
      MoveLeft(FormPtr^[NextChunk],MoveTo^,MoveLen);

      {Write out the next label}
      WriteLen := LabHdrSize + MoveLen;
      LInsert(Status,ScanId,@LabelRecord^,WriteLen,Ticket);
      IF Status <> 0 THEN
         BEGIN
         IF MMTrap1 THEN WriteLn('***LInsert status: ',Status);
         GOTO 500;
         END;
      IF Trace2MMgr  then WriteLn(MxMgr,WLF,'Label inserted');

      {Update the counts and other miscellaneous}
      Ticket := FALSE; {Only true the first call to LInsert}
      BytesLeft := BytesLeft - MoveLen;
      NextChunk := NextChunk + MoveLen;
      END;

   {Free up the space for the form, since it is no longer needed.}
   FreSnipBlock(FormId);
   FormId := NullSnip;


   {Now, it is necessary to delete the old list form, if it exists}

   {First, retrieve the last label written to get the ticket number}
   {This will get us the ticket number being used.}
   MoveLeft(PScanTable^[ScanId]^.PtrCos^,LabelHdr,LabHdrSize);

   {Now fetch the first label of type listform}
   LFetch(Status,ScanId,Approx,1,@LabelHdr);
   If Status <> NoErr THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***LFetch status: ',Status);
      GOTO 500;
      END;
   IF Trace2MMgr  then WriteLn(MxMgr,WLF,'Label fetched  approx');

   {Point the label pointer at it}
   LabelRecord := @PScanTable^[ScanId]^.PtrCos^;

   WHILE TRUE DO
      BEGIN
      IF Trace2MMgr  then WriteLn(MxMgr,WLF,'Label is of type listform');
      {If the record does not have the same ticket number as the records
      which we just added, then it must be old and should be deleted.}
      IF LabelRecord^.ENum <> LabelHdr.ENum THEN
         BEGIN
         LDelete(Status,ScanId,Current,0,Nil);
         IF Status <> NoErr THEN
            BEGIN
            IF MMTrap1 THEN WriteLn('***LDelete status: ',Status);
            GOTO 500;
            END;
         IF Trace2MMgr  then WriteLn(MxMgr,WLF,'Label deleted');
         END;

      {Get the next label}
      LFetch(Status,ScanId,Next,0,Nil);
      IF (Status <> NoErr) AND (Status <> EOS) THEN
         BEGIN
         IF MMTrap1 THEN WriteLn('***LFetch status: ',Status);
         GOTO 500;
         END;
      IF Trace2MMgr  then WriteLn(MxMgr,WLF,'Return from Lfetch next');

      {If EOS is reached, or a different type label record, then we are done.}
      IF Status = EOS THEN GOTO 400
      ELSE BEGIN
           LabelRecord := @PScanTable^[ScanId]^.PtrCos^;
           IF LabelRecord^.LType <> LstFormCode THEN GOTO 400;
           END;
      END;


400: {Now close down the scan}
   IF Trace2MMgr  then WriteLn(MxMgr,WLF,'Calling CloseScan');
   CloseScan(Status,ScanId);
   IF Status <> NoErr THEN
      BEGIN
      IF MMTrap1 THEN WriteLn(Bell,'***CloseScan status: ',Status);
      GOTO 500;
      END;
   IF Trace2MMgr  then WriteLn(MxMgr,WLF,'Scan Closed');

   Exit(WritListForm);

500: {Problem with database intrinsics.}
   {Strategy is just to exit. Cannot put up alert at this point. Any damage to the list
   form will be repaired the next time the form is read in and written out.}

   {Get rid of the form if necessary.}
   IF FormId <> NullSnip THEN FreSnipBlock(FormId);
   END;




