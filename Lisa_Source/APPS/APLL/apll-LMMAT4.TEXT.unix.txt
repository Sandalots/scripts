
{$S lmlist  }
PROCEDURE ChkCurRg{hand:lmhandle; where :idmodetype; var snipid : idtype;
                    var status: integer};
   Label 100;

   CONST CCR = ' ChkCurRg ';

   VAR row: IDType;
       plmh : ptrlmhandle;
       nextrow, prevrow : Idtype;
       thisrow : ptrrowsnip;
       lastrow : idtype;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,CCR);
   IF MMTrap1 THEN IF NOT ((where = mmfirst) OR (where = mmlast)) then
      BEGIN
      WriteLn(Bell,'***Invalid mode');
      MMFatalErr(LogicErr,CCR,'');
      END;

   row := curRgSnip;
   while row <> nullsnip do
      begin
      setsnipPtr(rowkind,row);
      NextRow := RowSnip^.NextSnip;
      ThisRow := RowSnip;
      plmh := POINTER(ORD(rowsnip) + rowsnip^.handoffset);
      IF comphand(hand,plmh^) = eq  then
         begin {found something so take entire curRglist  and put into cache}
         if Trace2MMgr then writeln('this rowid is in curRglist: ',row);
         snipid := row;

         IF MMTrap1 THEN
            BEGIN
            Writeln('***Transferring current range to cache...');
            IF Trace2MMgr THEN
               BEGIN
               {$IFC MMDEBUG }
               DumpCrgList;
               {$ENDC }
               END;
            END;

         Row := CurRgSnip;
         while row <> nullsnip do
           begin
           {find end of curRglist}
           setsnipPtr (rowkind,row);
           nextrow := rowsnip^.nextsnip;
           lastrow := row;
           row := nextrow;
           end;

         {curRgsnip is top of currrglist; lastrow is bottom of currRglist }

         if tabledata.toprow = nullsnip then
            begin
            {Empty Cache}

            tabledata.toprow := curRgsnip;
            tabledata.bottomrow := lastrow;
            CurRglist := FALSE;
            CurRgsnip := nullsnip;
            status := 0;
            goto 100;
            end

         else
            BEGIN
            IF where = mmfirst then
               begin
               {now add to top of cache}
               setsnipPtr(rowkind,tabledata.toprow);
               rowsnip^.priorsnip := lastrow;
               setsnipptr(rowkind,lastrow);
               rowsnip^.nextsnip := tabledata.toprow;
               tabledata.toprow := CurRgsnip;
               CurRglist := FALSE;
               CurRgsnip := nullsnip;
               status := 0;
               GOTO 100;

               end

            ELSE
               begin
               {now add to bottom of  cache}
               setsnipPtr(rowkind,tabledata.bottomrow);
               rowsnip^.nextsnip :=  CurRgsnip;
               setsnipPtr(rowkind,curRgsnip);
               rowsnip^.priorsnip := tabledata.bottomrow;
               tabledata.bottomrow := lastrow;
               CurRglist := FALSE;
               CurRgsnip := nullsnip;
               status := 0;
               GOTO 100;
               end;
            end;
         end;
      row := nextrow;
      end;


   Status := NotInRg; {Row is not in range}

100:
      IF Trace2MMGR then
         begin
         writeln('status ',status:4);
         {$IFC MMDEBUG }
         dumpcrglist;
         {$ENDC }
         end;
   END;

{u}
{$S lmscrap }
Procedure clearRg{rg:range};

   CONST clrrg = ' ClearRg ';

   VAR Row,Column : Idtype;
       NextRow,NextColumn : Idtype;
       arun: Array[0..0] of run;
       length : integer;
       numruns : integer;
       buf : Integer;
       status : integer;
       listsnip : idtype;
       done : boolean;
       done2 : boolean;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,Clrrg,'lo/hicol lo/hirow : ',rg.locol:3,rg.hicol:3,rg.lorow:3,rg.hirow:3);
   printing := TRUE;    {so makespace will cycle cache correctly}

   done := FALSE;
   with rg do
     begin
     if lorow = minfsnip then GetSnipId(rowkind,mmfirst,0,lorow,lorow);
     if locol = minfsnip then locol := tabledata.firstcol;
     if hicol = pinfsnip then hicol := tabledata.lastcol;
     end;

   row := rg.lorow;
   WHILE NOT done DO      {until row = rg.hirow}
     begin
     {loop thru columns and set each field null}
     Column := rg.locol;
     done2 := FALSE;
     WHILE NOT done2 DO    {until col = rg.hicol}
        begin

        IF Trace2MMGR then WRITELN('row, col: ', row:4, column:4);
        SetSnipPtr(ColKind,Column);
        NextColumn := Colsnip^.NextSnip;

        IF ColSnip^.fieldinfo.reptype <> FtypTick then
           BEGIN {set value to zero length}
           IF CurTable = TSearch THEN
              BEGIN

              {blank cells have no runs}
              numruns := 0;
              cellrun(mmwrite,row,column,@arun,numruns,status);
              IF MMTrap1 THEN if status <> 0 then mmfatalerr(status,clrrg,'cellrun');
              END;

           IF (CurTable = TColSpecs) AND (Row = SortRow) THEN
              BEGIN
              {Sort order row is cleared differently for efficiency}
              SetSnipPtr(ColKind,Column);
              ColSnip^.SortOrder := 0;
              CSKeys := 0;
              END
           ELSE BEGIN
                length := 0;
                cellvalue(MMwrite,row,column,@buf,true,length,status);
                IF MMTrap1 THEN if status <> 0 then mmfatalErr(status,clrrg,'cellvalue');
                END;
           END;

        if (column = rg.hicol) or (nextColumn = NullSnip) then done2 := TRUE
        else Column := nextColumn;
        {continue to loop}
        end;

     {Update the row}
     IF (CurTable = TColSpecs) AND (Row = SortRow) THEN
        BEGIN
        GenNewSorts;
        SortValid := FALSE;
        ListScrollValid := FALSE;
        END
     ELSE UpdateRow;

     if (row = rg.hirow) or (row = tabledata.lastrow) then done := TRUE
     else
       begin
       GetSnipId(rowkind,mmnext,0,row,row);
       if row = pinfsnip then done := TRUE;
       end;

     end;
   printing := FALSE;   {reset flag}

   END;

(*
{$S lmres }
Procedure clearRows{row1,row2:idtype};

   CONST clrrow = ' ClearRow ';

   VAR Row,Column : Idtype;
       NextRow,NextColumn : Idtype;
       arun: Array[0..0] of run;
       length : integer;
       numruns : integer;
       buf : Integer;
       status : integer;
       listsnip : idtype;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,Clrrow,' Row1: ',Row1:3,' Row2: ',Row2:3);
   Row := row1;
   WHILE TRUE DO
      BEGIN
      {loop thru columns and set each field null}
      Column := TableData.FirstCol;
      WHILE Column <> NullSnip DO
         BEGIN
         IF Trace2MMGR then WRITELN('row, col: ', row:4, column:4);
         SetSnipPtr(ColKind,Column);
         NextColumn := Colsnip^.NextSnip;

         IF ColSnip^.fieldinfo.reptype <> FtypTick then
            BEGIN {set value to zero length}
            IF CurTable = TSearch THEN
               BEGIN

               {blank cells have no runs}
               numruns := 0;
               cellrun(mmwrite,row,column,@arun,numruns,status);
               IF MMTrap1 THEN if status <> 0 then mmfatalerr(status,clrrow,'cellrun');
               END;

            IF (CurTable = TColSpecs) AND (Row = SortRow) THEN
               BEGIN
               {Sort order row is cleared differently for efficiency}
               SetSnipPtr(ColKind,Column);
               ColSnip^.SortOrder := 0;
               END
            ELSE BEGIN
                 length := 0;
                 cellvalue(MMwrite,row,column,@buf,true,length,status);
                 IF MMTrap1 THEN if status <> 0 then mmfatalErr(status,clrrow,'cellvalue');
                 END;
            END;

         Column := nextColumn;
         {continue to loop}
         END; {while column}

      {Update the row}
      IF (CurTable = TColSpecs) AND (Row = SortRow) THEN
         BEGIN
         GenNewSorts;
         SortValid := FALSE;
         ListScrollValid := FALSE;
         CSKeys := 0;                {Fix for bug LL186}
         END
      ELSE UpdateRow;

      IF Row = Row2 THEN Exit(ClearRows)
      ELSE BEGIN
           SetSnipPtr(RowKind,Row);
           row := RowSnip^.NextSnip;
           END;
      END;

   END;
*)




{$S lmclosedoc }
PROCEDURE CloseDocument;

   CONST CD = ' CloseDocument ';

   VAR FormId: IdType;
       FormPtr: PtrData;
       Temp: ^Header;
       AlertMsg: INTEGER;
       Status: INTEGER;
       SuspFName: PathName;
       Actual: LONGINT;
       ErrStatus: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,CD);

   {This procedure should only be called when the function CloseOK returns TRUE. It should never
   be called on an abnormal termination or if there are unposted updates.

   This procedure may not put up an alert box if trouble is encountered, because the folder may not
   be active at the time. Any serious errors which occur will be handled when the document is reopened.}

   {If the table is under creation, then actually suspend the list}
   IF CreatingTable or Redefining THEN
      BEGIN
      Sched_Class(ErrStatus,FALSE);
      SuspendDoc;
      Sched_Class(ErrStatus,TRUE);
      Exit(CloseDocument);
      END;

   {If the current table is the colspec table, post the changes. We have
   to be careful, however, that no errors will occur which will cause an
   alert to be thrown up, because CloseDocument can be called when the
   document is inactive. However, this should only happen if the folder
   exec has already called CloseOK to make sure that this is ok.}
   IF CurTable <> TNone THEN
      BEGIN
      {Some table is still current}
      IF Trace2MMgr THEN WriteLn('Table is current during close...');

      {Make sure it is ok to close}
      IF NOT CloseOK THEN
          BEGIN
          {Not OK to close...This should not happen.}
          IF MMTrap1 THEN WriteLn(Bell,'***CloseDocument called when not OK to close!!');
          AbortCloseDocument;
          Exit(CloseDocument);
          END;

      {Switch out of current table}
      CASE CurTable OF
         TColSpecs: BEGIN
                    IF ColumnsCut THEN
                       BEGIN
                       if mmtrap1 then WriteLn(Bell,'***Columns still cut at docclose');
                       UnPasteCols;
                       END;
                    ChangeColSpecs(Status);
                    IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***ChangeColSpecs status: ',Status);
                    END;

         TSearch: BEGIN
                  {Don't post changes}
                  ReleaseRowSnips;
                  ReleaseColSnips;
                  END;

         TList: BEGIN
                SwitchFromList;
                END;

         END;  {Case}

      END; {CurTable <> TNone}


   {Switch to the list if changes must be made to the data file.}
   IF SchemaChanged OR ListFormChanged THEN SwitchtoList;

   {If the schema form has changed, write out a new one}
   IF SchemaChanged THEN
      BEGIN
      Sched_Class(ErrStatus,FALSE);
      IF Trace2MMGR then WriteLn(MxMgr,CD,'Schema has changed');
      CreateSchemaForm(FormId);
      InitSnipPtr(ColKind,FormId);
      FormPtr := @ColSnip^;

      IF Trace2MMGR THEN
         BEGIN
         Temp := @FormPtr^;
         WriteLn(MxMgr,CD,'FormSize: ',Temp^.Space);
         END;

      MakeFormFile(Status,FormPtr,@FilePName,FALSE);
      IF MMTrap1 THEN IF Status > 0 THEN WriteLn(Bell,CD,'MakeFormFile status: ',Status);
      IF Trace2MMGR then WriteLn(MxMgr,CD,'New schema written');
      SchemaChanged := FALSE;

      FreSnipBlock(FormId);
      Sched_Class(ErrStatus,TRUE);
      END;

   {If the list form information has changed, write out new labels}
   IF ListFormChanged THEN
      BEGIN
      Sched_Class(ErrStatus,FALSE);
      IF Trace2MMGR then WriteLn(MxMgr,CD,'List form has changed');
      GenListForm(FormId);
      IF Trace2MMGR then WriteLn(MxMgr,CD,'New list form generated');
      WritListForm(FilePName,FormId);
      IF Trace2MMGR then WriteLn(MxMgr,CD,'New list form written');
      ListFormChanged := FALSE;
      Sched_Class(ErrStatus,TRUE);
      END;

   {DiffClose is only called in order to truncate the differential file, in the event that the scan
   has been left open. There should not be any unposted updates, otherwise CloseDocument should not
   have been called... CloseOk would have returned false. This is why a 'nopost' close is done.}
   IF ScanOpen THEN
      BEGIN
      Sched_Class(ErrStatus,FALSE);
      DiffClose(Status,ScanId,FALSE);
      Sched_Class(ErrStatus,TRUE);
      IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,CD,'***DiffClose status: ',Status);
      END;

   {Close differential file and data file}
   Sched_Class(ErrStatus,FALSE);
   IF Trace2MMGR then WriteLn(MxMgr,CD,'Calling DiffDestroy');
   DiffDestroy(Status,ScanId);
   IF Trace2MMGR THEN WriteLn(MxMgr,CD,'Return from DiffDestroy');
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,CD,'***DiffDestroy status: ',Status);

   {NOTE***Following code not necessary if suspend file deleted***}
   {Set EOF of suspendfile to zero.}
   Read_Data(Status,SuspRefNum,ORD(@Status),0,Actual,Absolute,0);
   IF MMTrap1 THEN IF (Status <> 0) AND (Status <> 956) THEN WriteLn(Bell,'***',MxMgr,CD,'Read_Data 0,0 status: ',status);

   IF Trace2MMgr THEN WriteLn('Truncating suspend file...');
   Truncate(Status,SuspRefNum);
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',MxMgr,CD,'Truncate status: ',status);

   {Close the suspend file}
   Close_Object(Status,SuspRefNum);
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',MxMgr,CD,'Close_Object status: ',status);

   {Delete the suspend file}
   (*Note - for performance reasons this code is commented out. This way the
   file does not have to be recreated each time a document is opened. If it
   is later determined that saving the disc space is more important, than
   this code can be reactivated.
   SuspFName := ConCat(FilePName,'$S');
   Kill_Secure(Status,SuspFName,DocPassWord);
  {Kill_Object(Status,SuspFName);}
   IF MMTrap1 THEN IF Status > 0 THEN WriteLn(Bell,'***',MxMgr,CD,'Kill_Object status: ',Status);*)

   {Close the snip data segment. This will cause it to be deleted, since
   it was killed right after creation.}
   Close_DataSeg(Status,SegRefNum);
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***',MxMgr,CD,'Close_DataSeg status: ',Status);

   Sched_Class(ErrStatus,TRUE);
   END;



{$S lmclosedoc }
FUNCTION CloseOK;

{This function will return true if it is ok to call closedocument without
first posting any of the tables via WriteList,ChangeColSpecs, or ChangeSearch.
A return of true indicates that the user is in a state where we can close the
document without requiring alerts of any kind, either decision-wise or error.
This is absolutely necessary because the document may not be active.}

VAR OKClose: BOOLEAN;

BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
IF TraceMMGr THEN Write(MxMgr,' CloseOK ');

CASE CurTable OF

   TSearch,
   TNone,
   TColSpec: BEGIN
             {Note - When creatingtable or redefining (TColSpec), it is always ok to close, because
             we always suspend in this case.}
             OKClose := TRUE;
             END;

   TList: BEGIN
          IF (RowChanged <> NullSnip) OR  ListModified THEN OKClose := FALSE
          ELSE OKClose := TRUE;
          END;

   OTHERWISE OKClose := FALSE;

   END;

CloseOk := OKClose;
IF TraceMMgr THEN WriteLn(OKClose);
END;


(*
{$S lmlist }
PROCEDURE Copy_RowSnips{FirstRow: IdType;
                        LastRow: IdType;
                        VAR FirstCopyRow: IdType;
                        VAR LastCopyRow: IdType;
                        VAR Status: INTEGER};

  {This procedure duplicates a linked list of row snips which start with
  FirstRow and end with LastRow. The linked list may be part of a larger
  list.}

  CONST CRS = ' Copy_RowSnips ';

  VAR OldRow: IdType;
      NextOld: IdType;
      SnipLength: INTEGER;
      NewRow: IdType;
      OldSnip: PtrData;
      NewSnip: PtrData;

  BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
  IF TraceMMgr THEN WriteLn(MxMgr,CRS,FirstRow,LastRow,FirstCopyRow,LastCopyRow);

  FirstCopyRow := NullSnip;
  LastCopyRow := NullSnip;
  OldRow := FirstRow;
  Status := 0;

  WHILE OldRow <> NullSnip DO
     BEGIN
     SetSnipPtr(RowKind,OldRow);
     NextOld := RowSnip^.NextSnip;

     {Get the size of the snip and create a duplicate}
     SnipLength := RowSnip^.RecSize;
     GetSnipBlock(NewRow,SnipLength,Status);
     IF Status <> 0 THEN
        BEGIN
        ReleaseSnips(RowKind,FirstCopyRow); {Get rid of any copies already created}
        Exit(Copy_RowSnips); {Status is passed up}
        END;

     {Move the information from the old snip to the new}

     SetSnipPtr(RowKind,OldRow);
     OldSnip := @RowSnip^;
     InitSnipPtr(RowKind,NewRow);
     NewSnip := @RowSnip^;
     MoveLeft(OldSnip^,NewSnip^,SnipLength);

     {Since the snip has a new id, reset the self identifying snip field.
     Also null the prior and next pointers.}
     WITH RowSnip^ DO
        BEGIN
        SnipId := NewRow;
        NextSnip := NullSnip;
        PriorSnip := NullSnip;
        END;

     {Add to the end of the new list}
     InsertRowSnips(FirstCopyRow,LastCopyRow,LastCopyRow,NewRow,NewRow);

     IF OldRow = LastRow THEN OldRow := NullSnip {Exit}
     ELSE OldRow := NextOld;
     END;
  END;
*)


{$S lmcolspec}
PROCEDURE CopyColSnips{FirstCol: IdType;
                       LastCol : IdType;
                       PriorCol : IdType;
                       VAR FirstCopyCol: IdType;
                       VAR LastCopyCol: IdType};

  CONST CCS = ' CopyColSnips ';

  VAR OldCol: IdType;
      NextOld: IdType;
      SnipLength: INTEGER;
      NewCol: IdType;
      OldSnip: PtrData;
      NewSnip: PtrData;
      Status: INTEGER;

  BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
{u}
  IF TraceMMgr THEN WriteLn(MxMgr,CCS,FirstCol,LastCol,PriorCol,FirstCopyCol,LastCopyCol);

  FirstCopyCol := NullSnip;
{ LastCopyCol := NullSnip; }
  LastCopyCol := PriorCol;
  OldCol := FirstCol;

  WHILE OldCol <> NullSnip DO
     BEGIN
     SetSnipPtr(ColKind,OldCol);
     NextOld := ColSnip^.NextSnip;

     {Get the size of the snip and create a duplicate}
     SnipLength := ColSnip^.RecSize;
     GetSnipBlock(NewCol,SnipLength,Status);

     {Move the information from the old snip to the new}
     SetSnipPtr(ColKind,OldCol);
     OldSnip := @ColSnip^;
     InitSnipPtr(ColKind,NewCol);
     NewSnip := @ColSnip^;
     MoveLeft(OldSnip^,NewSnip^,SnipLength);

     {Since the snip has a new id, reset the self identifying snip field.
     Also null the prior and next pointers.}
     WITH ColSnip^ DO
        BEGIN
        SnipId := NewCol;
        NextSnip := NullSnip;
        PriorSnip := NullSnip;
        END;

     {Add to the end of the new list}
     InsertColSnips(FirstCopyCol,LastCopyCol,LastCopyCol,NewCol,NewCol);

     if OldCol = LastCol then OldCol := NullSnip   {exit}
     else OldCol := NextOld;

{    OldCol := NextOld;}
     END;

  END;


(*
{$S lmlist }
PROCEDURE CopyRows{RowId1: IdType;
                   RowId2: IdType};

   CONST CR = ' CopyRows ';

   VAR Status: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,CR,'RowId1: ',RowId1:4,' RowId2: ',RowId2:4);
   {Since rows may only be copied when the list is current, this assumption is made.}

   {If there are already rows in the scrap, get rid of them}
   {IF RowsCut THEN} RelScrap;

   {Copy the rows into the scrap}
   WITH CutRow DO Copy_RowSnips(RowId1,RowId2,FirstRow,LastRow,Status);
   IF Status <> 0 THEN
      BEGIN {Copy_RowSnips releases all snips on FirstRow chain upon failure}
      DBAlert(CopyErr,Status);
      RowsCut := FALSE;
      Exit(CopyRows);
      END;

   With CutRow do
     begin
     cutrow.firstrow := rowid1;
     cutrow.lastrow := rowid2;
     end;

   RowsCut := TRUE;

   END;
*)


{$S lmclosedoc }
PROCEDURE CreateListFile{FileNamePtr: ptrpathname;
                         VAR Status: INTEGER};
   LABEL 400,500;

   CONST CFile = ' CreateListFile ';

   VAR Column: IdType;
       NextCol: IdType;
       FormPtr: PtrData;
       FormId: IdType;
       NextOffset: INTEGER;
       FldNumber: INTEGER;
       TicName: STRING[10];
       TicNameLen: INTEGER;
       TicEdit: ECStr;
       TicEditLen: INTEGER;
       TicId: IdType;
       BlockSize: INTEGER;
       Source: PtrData;
       Target: PtrData;
       StartRg: Range;
       Row: IdType;
       Col: IdType;
       TableInfo: TableRecord;
       SetSize: INTEGER;
       RedundantFile: PathName;
       DataCreated: BOOLEAN;
       RedunCreated: BOOLEAN;
       ClosedNormal: BOOLEAN;
       I: INTEGER;
       LStatus: INTEGER;



   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,CFile);
   IF MMTrap1 THEN
      BEGIN
      IF CurTable <> TColSpecs THEN MMFatalErr(LogicErr,CFile,'');
      {Make sure table needs to be created}
      IF NOT CreatingTable THEN MMFatalErr(LogicErr,CFile,'');
      END;

   {Init}
   TicId := NullSnip;
   FormId := NullSnip;
   DataCreated := FALSE;
   RedunCreated := FALSE;
   Status := 0;

   {Update the list column snips}
   ChangeColSpecs(Status);
   {Alerts have already been displayed in case of error}
   IF Status <> 0 THEN EXIT(CreateListFile);

   {Switch back to the table}
   SwitchToList;

   {Remove all non blank columns.}
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      NextCol := ColSnip^.NextSnip;
      IF CellBlank(MInfSnip,Column) THEN
         BEGIN
         WITH TableData DO
            BEGIN
            CutColSnips(FirstCol,LastCol,Column,Column);
            ColCount := ColCount - 1;
            END;
         {Dont try to remember horizontal scroll position if we are
         deleting what used to be the first column}
         IF Column = HScrollId THEN HScrollId := NullSnip;
         END;
      Column := NextCol;
      END;

   {Return error if no columns left}
   IF TableData.ColCount = 0 THEN
      BEGIN
      {Initialize the column snip structures again}
      FOR I := 1 TO BlankCols DO
         BEGIN
         {Create a default list column}
         NewListCol(Column,I);

         {Link this snip into the end of the list of column snips}
         WITH TableData DO
            BEGIN
            InsertColSnips(FirstCol,LastCol,LastCol,Column,Column);
            ColCount := ColCount + 1;
            END;
         END; {For Loop}

      Status := NoColErr;
      GOTO 500;
      END;

   {Put up a wait alert}
   WaitAlert(LMAlerts,WaitCreate);

   {Create a ticket field and link it in as the second column. Then loop
   through all of the columns and set the field reptypes, sizes, options,
   and offsets. This is all done by procedure PrepColumns.}
   PrepColumns;

   {Now create the schema file from the column snip and related structures}
   CreateSchemaForm(FormId);
   InitSnipPtr(ColKind,FormId);
   FormPtr := @ColSnip^;

   {Destroy the file if its already there}
   Kill_Secure(Lstatus,filenameptr^,DocPassWord);
  {Kill_Object(Lstatus,filenameptr^);}
   IF MMTrap1 THEN IF (LStatus > 0) AND (LStatus <> 894) THEN WriteLn(Bell,'***Datafile DeleteFile status: ',Status);

   RedundantFile := Concat(FileNamePtr^,RedunSuffix);
   Kill_Secure(Lstatus,RedundantFile,DocPassWord);
  {Kill_Object(Lstatus,RedundantFile);}
   IF MMTrap1 THEN IF (LStatus > 0) AND (LStatus <> 894) THEN WriteLn(Bell,'***Redundant DeleteFile status: ',Status);

   DiffPName := Concat(FileNamePtr^,DiffSuffix);
   Kill_Secure(Lstatus,DiffPName,DocPassWord);
  {Kill_Object(Lstatus,DiffPName);}
   IF MMTrap1 THEN IF (LStatus > 0) AND (LStatus <> 894) THEN WriteLn(Bell,'***DiffFile DeleteFile status: ',Status);

   {Now call the intrinsic to create the file}
   MakeFormFile(LStatus,FormPtr,@FileNamePtr^,TRUE);
   IF LStatus <> NoErr THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***MakeFormFile status: ',LStatus);
400:  CASE LStatus OF
         {Check for enough disc space}
         NoRoom,
         {Make_File} 854,855: Status := DiscCreateErr;

         {File inconsistency or io errors}
         IOErr, Inconsistent,
         {Make_File,Lookup,Close_Object} 802,835,848,849,
         {Open} 871,
         {Info} 1190,
         {Close_Object} 610: Status := FileErr;

         OTHERWISE
            BEGIN
            {600 range means inconsistent file system}
            IF (LStatus >= 600) AND (LStatus <= 699) THEN Status := FileErr
            {All others are internal}
            ELSE Status := IntErr;
            END;
         END; {Case}

      GOTO 500;
      END; {LStatus <> 0}
   DataCreated := TRUE;



   {Create the redundant file for recovery purposes}
   CloneFile(LStatus,@FileNamePtr^,@RedundantFile,TRUE);
   IF LStatus <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***CloneFile status: ',LStatus);
      {The errors for Clonefile are exactly the same as MakeFormFile}
      GOTO 400;
      END;
   RedunCreated := TRUE;



   {Now that file is created, initialize list header record}
   MoveLeft(FormPtr^,ListHeader,SizeOf(Header));

   {Name the differential file and other necessary files}
   DiffPName := ConCat(FilePName,DiffSuffix);

   {The following files are needed by DiffOpen}
   Temp1PName := ConCat(FilePName,Temp1Suffix);
   Temp2PName := ConCat(FilePName,Temp2Suffix);

   {Create the differential file}
   setsize := ((TableData.colcount + 15) div 16) * 2;
   WITH TableData DO SetSet(@NullNA,ColCount,ColCount);
   IF Trace2MMgr then WriteLn(MxMgr,CFile,'Creating differential file...');
   DiffCreate(LStatus,ScanId,ClosedNormal,DocPassWord,@FilePName,@DiffPName,@NullNA,setsize);
   IF (LStatus <> NoErr) THEN
      BEGIN
      CASE LStatus OF
         {The following are errors caused by a lack of disc space}
         NoRoom,
         {Make_File} 854,855: Status := DiscCreateErr;

         {The next set of errors are due to corrupted data}
         IOErr,Inconsistent,
         {Open} 871,
         {Lookup,Make_File,Close_Object} 835,848,849,
         {Info} 1190,
         {Make_File,Close_Object} 802,
         {Close_Object} 610: Status := FileErr;

         OTHERWISE
            BEGIN
            {600 range is inconsistent file system}
            IF (LStatus >= 600) AND (LStatus <= 699) THEN Status := FileErr
            {All other errors are considered to be internal}
            ELSE Status := IntErr;
            END;
         END; {Case}

      GOTO 500;
      END;

   {Now that the file is definitely created, and there will be no errors which
   cause it not to be, flag all of the columns as being created.}
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^ DO
         BEGIN
         Column := NextSnip;
         NewColumn := FALSE;
         END;
      END;

   {Release the form  space}
   FreSnipBlock(FormId);

   {Switch list into background}
   SwitchFromList;

   {Flag file as created}
   CreatingTable := FALSE;

   {Take down wait alert}
   EndWaitAlert;

   Exit(CreateListFile);

500: {Error occurred.}
   IF Trace2MMgr THEN WriteLn('Handling error during CreateListFile...');
   {Destroy the file if it was created}
   IF DataCreated THEN
      BEGIN
      DeleteFile(Lstatus,@filenameptr^);
      IF MMTrap1 THEN WriteLn(Bell,'***Datafile DeleteFile status: ',LStatus);
      END;

   {Destroy the redundant file if it was created}
   IF RedunCreated THEN
      BEGIN
      DeleteFile(Lstatus,@RedundantFile);
      IF MMTrap1 THEN WriteLn(Bell,'***Redundant DeleteFile status: ',LStatus);
      END;

   {If the ticket field has been added, remove it}
   IF TicId <> NullSnip THEN WITH TableData DO
      BEGIN
      CutColSnips(FirstCol,LastCol,TicId,TicId);
      ColCount := ColCount - 1;

      {Now we have to reorder the columns}
      FldNumber := 0;
      Column := TableData.FirstCol;
      WHILE Column <> NullSnip DO
         BEGIN
         SetSnipPtr(ColKind,Column);
         WITH ColSnip^ DO
            BEGIN
            FieldNum := FldNumber;
            FldNumber := FldNumber + 1;
            Order := FldNumber;
            Column := NextSnip;
            END;
         END;
      END;

   {Release the form  space if it has been generated}
   IF FormId <> NullSnip THEN FreSnipBlock(FormId);

   {Switch list back into background}
   SwitchFromList;

   {Put up the error alert}
   IF CautionAlert(LMAlerts,Status) THEN;

   {Regenerate col spec table}
   LoadColSpecs(TableInfo);

   {Rebuild the table again and repaint.}
   GetSnipId(RowKind,MMFirst,0,Row,Row);
   GetSnipId(ColKind,MMFirst,0,Col,Col);
   SetRg(StartRg,A1CellRg,Row,Col,Row,Col);
   ReBldTbl(StartRg);
   TmShoNewTbl;
   END;





{$S lmclosedoc }
PROCEDURE CreateSchemaForm{VAR FormId: IdType};

   {This procedure creates a schema form in memory from the data structures.
   This form is placed in a snip block and the Id is returned.}

   CONST CSForm = ' CreateSchemaForm ';

   TYPE IntArray = ARRAY[0..1] OF INTEGER;

   VAR Column: IdType;
       FieldCount: INTEGER;
       FormSize: INTEGER;
       FormPtr: PtrData;
       HeaderPtr: ^Header;
       NextLoc: INTEGER;
       FieldSize: INTEGER;
       FieldPtr: ^DBField;
       ArrayId: IdType;
       SnipArray: ^IntArray;
       I: INTEGER;
       MaxOffset: INTEGER;
       MaxOffSize: INTEGER;
       Status: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,CSForm);

   {Get a block to contain an array of snips in field order}
   FieldCount := TableData.ColCount;
   GetSnipBlock(ArrayId,FieldCount*2,Status);
   InitSnipPtr(ColKind,ArrayId);
   SnipArray := @ColSnip^;


   {Figure out how much space the form will require.}
   {Loop through all of the column snips and add up the space required for the
   column snip records. Then add this to the space required for a header
   record.}
   FormSize := 0;
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^ DO
         BEGIN
         {Add field information record size to form size}
         FieldSize := FieldInfo.FldSize;
         IF ODD(FieldSize) THEN FieldSize := FieldSize + 1; {Field size must be even}
         FormSize := FormSize + FieldSize;

         {put the snipid of this snip into the array in field order}
         SnipArray^[FieldNum] := SnipId;

         {Loop to next column}
         Column := NextSnip;
         END;
      END;


   {Now add in the header record space}
   FormSize := FormSize + SIZEOF(Header);

   {Get space to create the form}
   GetSnipBlock(FormId,FormSize,Status);
   InitSnipPtr(ColKind,FormId);
   FormPtr := @ColSnip^;

   {Since the heap may have changed due to GetSnipBlock, reset sniparray pointer.}
   InitSnipPtr(ColKind,ArrayId);
   SnipArray := @ColSnip^;

   {Now loop through the columns in field number order and load in the information}
   NextLoc := SIZEOF(Header);   {First field location}
   I := 0;
   MaxOffset := 0;
   WHILE I < FieldCount DO
      BEGIN
      SetSnipPtr(ColKind,SnipArray^[I]);

      {look for the field with the maximum offset}
      WITH ColSnip^.FieldInfo DO
         BEGIN
         IF Offset > MaxOffset THEN
            BEGIN
            MaxOffset := Offset;
            MaxOffSize := Size;
            END;
         END;

      FieldSize := ColSnip^.FieldInfo.Fldsize;
      FieldPtr := @FormPtr^[NextLoc];
      MoveLeft(ColSnip^.FieldInfo,FieldPtr^,FieldSize);
      NextLoc := NextLoc + FieldSize;

      {Make the correction if field size is odd}
      IF ODD(FieldSize) THEN
         BEGIN
         FieldPtr^.FldSize := FieldPtr^.FldSize + 1;
         FormPtr^[NextLoc] := 0; {Clear slack byte}
         NextLoc := NextLoc + 1;
         END;

      I := I + 1;
      END;


   {Create the header}
   HeaderPtr := @FormPtr^;
   IF NOT (CreatingTable OR RedefiningTable) THEN
      BEGIN
      HeaderPtr^ := ListHeader;
      HeaderPtr^.Space := FormSize - SIZEOF(Header); {Form size may have changed.}
      END

   ELSE BEGIN {New file, new schema from scratch.}
        WITH HeaderPtr^ DO
           BEGIN
           Space := FormSize - SIZEOF(Header);
           Version := ListVersion; {Upper byte ignored but set internally by intrinsics.}
           NFields := FieldCount;
           NKeys := 2;  {First field plus the ticket field.}
           NSort := 2;  {First field plus the ticket field.}

           HeaderPtr^.MarketCode := ToolMarketCode;

           {The number of key bytes is set to the offset of the ticket
           field added to its size.}
           SetSnipPtr(ColKind,TableData.FirstCol);
           SetSnipPtr(ColKind,ColSnip^.NextSnip);
           WITH ColSnip^.FieldInfo DO
           KeyBytes := Offset + Size;

           {Recordsize must be computed by taking the offset of the last field in
           the record, and adding in its size. Chris claims it is not necessary
           to make the record size an even number.}
           RecSize := MaxOffset + MaxOffSize;

           Flags := [0];
           END;

        END;


   {Delete the snip array}
   FreSnipBlock(ArrayId);
   END;


{$S lmcolspec }

PROCEDURE CutCols{ColId1: IdType;
                  ColId2: IdType};

   CONST CC = ' CutCols ';

   VAR CutColCount: INTEGER;
       Column: IdType;
       PriorCol: IdType;
       NextCol: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,CC,' ColId1: ',ColId1:4,' ColId2: ',ColId2:4);
{  IF MMTrap1 THEN IF CurTable <> TColSpecs THEN MMFatalErr(LogicErr,CC,''); }
{u}
   {Release anything already in the scrap}
   RelScrap;

   IF (CurTable = TColSpecs) THEN
     BEGIN
     {Loop through the cut columns and make them invisible}
     Column := ColId1;
     WHILE Column <> NullSnip DO
        BEGIN
        SetSnipPtr(ColKind,Column);
        WITH ColSnip^ DO
           BEGIN
           Visible := FALSE;
           IF Column = ColId2 THEN Column := NullSnip ELSE Column := NextSnip;
           END;
        END;

     {Remember the range of cut columns}
     With CutCol DO
        BEGIN
        FirstCol := ColId1;
        LastCol := ColId2;
        ColumnsCut := TRUE;
        END;
     {Get the previous visible column for the table editor}
     PriorCol := ColId1;
     GetPrvVisCol(PriorCol);

     {Notify the table manager of the change.}
     TMNewSnips(ColKind,PriorCol,TRUE);
     END;
   END;



{$S lmcolspec }
PROCEDURE CutColSnips{VAR HeadCol: IdType;
                      VAR TailCol: IdType;
                      FirstCol: IdType;
                      LastCol: IdType};

   {This procedure cuts a linked list beginning with FirstCol and ending
   with LastCol out of a linked list which begins with HeadCol and ends
   with TailCol.}

   CONST CCS = ' CutColSnips ';

   VAR PriorCol: IdType;
       NextCol: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,CCS,HeadCol:4,TailCol:4,FirstCol:4,LastCol:4);

   {Set prior of FirstCol null}
   SetSnipPtr(ColKind,FirstCol);
   PriorCol := ColSnip^.PriorSnip;
   ColSnip^.PriorSnip := NullSnip;

   {Set next of LastCol null}
   IF FirstCol <> LastCol THEN SetSnipPtr(ColKind,LastCol);
   NextCol := ColSnip^.NextSnip;
   ColSnip^.NextSnip := NullSnip;

   {Set next of PriorCol}
   IF PriorCol = NullSnip THEN HeadCol := NextCol
   ELSE BEGIN
        SetSnipPtr(ColKind,PriorCol);
        ColSnip^.NextSnip := NextCol;
        END;

   {Set prior of NextCol}
   IF NextCol = NullSnip THEN TailCol := PriorCol
   ELSE BEGIN
        SetSnipPtr(ColKind,NextCol);
        ColSnip^.PriorSnip := PriorCol;
        END;

   END;


(*
{$S lmlist}
PROCEDURE CutRectRg{currg:range};

var status:integer;

BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  {make a copy of the rowsnips and save ids in cutrow structure}
  copy_rowsnips(currg.lorow,currg.hirow,cutrow.firstrow,cutrow.lastrow,status);
  if mmtrap1 then if status <> 0 then mmfatalerr(status,'cutrectrg','');

  rowscut := TRUE;

END;
*)


{$S lmscrap }

PROCEDURE CutRows{RowId1: IdType;
                  RowId2: IdType};

   LABEL 100,500;

   CONST CR = ' CutRows ';

   VAR HandlePtr: ^LMHandle;
       ErrPtr: PtrBits;
       Row: IdType;
       PriorRow: IdType;
       Status: INTEGER;
       RecSize: INTEGER;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,CR,' RowId1: ',RowId1:4,' RowId2: ',RowId2:4);
   {The assumption is made that the list is current}
   IF MMTrap1 THEN IF CurTable <> TList THEN MMFatalErr(LogicErr,CR,'');

   {Make sure we do not cut the blank line.}
   IF Blankline THEN WITH TableData DO
      BEGIN
      IF Trace2MMgr THEN WriteLn(MxMgr,Cr,'Blankline: TRUE, LastRow: ',LastRow:4);
      IF RowId1 = LastRow THEN Exit(CutRows);
      IF RowId2 = LastRow THEN
         BEGIN
         SetSnipPtr(RowKind,RowId2);
         RowId2 := RowSnip^.PriorSnip;
         END;
      END;

   {Make a check to see if the scan is open - might have run into trouble.}
   IF NOT ScanOpen THEN
      BEGIN
      Status := 999; {cause general purpose error message}
      GOTO 100;
      END;

   {Loop through all rows to be cut and delete their entries from the diff file.}
   Row := RowId1;
   WHILE TRUE DO
      BEGIN
      SetSnipPtr(RowKind,Row);

      {Make the record current of scan}
      HandlePtr := Pointer(Ord(RowSnip) + RowSnip^.HandOffset);
      ErrPtr := Pointer(Ord(RowSnip) + RowSnip^.BitOffset);
      LMFetch(Status,RowSnip^.ErrorCode,ErrPtr,ScanId,Exact,HandlePtr^,RecSize);
      IF MMTrap1 THEN IF Status <> 0 THEN WriteLn('***',CR,'LMFetch status: ',Status);
      IF Status <> 0 THEN GOTO 100;

      {Delete the record}
      LMDelete(Status,ScanId);
      IF MMTrap1 THEN IF Status <> 0 THEN WriteLn('***',CR,'LMDelete status: ',Status);
      IF Status <> 0 THEN
100:     BEGIN
         {Put up error alert box}
         DBAlert(CutErr,Status);

         {Adjust RowId1 and RowId2 to indicate how far we actually deleted.}
         IF Row = RowId1 THEN RowId1 := NullSnip
         ELSE RowId2 := RowSnip^.PriorSnip;

         {Exit loop}
         GOTO 500;
         END;

      {If this was the last row changed, reset the indicator such that updaterow
      will not attempt to update a deleted row...this can happen if you first
      clear the row, then cut it, and then try to select elsewhere.}
      IF Row = RowChanged THEN RowChanged := NullSnip;

      IF Row = RowId2 THEN GOTO 500 {All done}
      ELSE Row := RowSnip^.NextSnip;
      END;


500:  {Now cut the rows out of the snip list.}
   IF RowId1 <> NullSnip THEN
      BEGIN
      {Remember prior row for table editor - note! cannot simply get
      priorsnip of rowid1 because the cut may cause all snips in the
      cache to be removed. This can happen when io errors have been
      encountered. Getsnipid will cause the proper links to be set in
      the case where no snips are left.}
      GetSnipId(RowKind,MMPrior,0,RowId1,PriorRow);

      {Now cut the row snips out of the list}
      WITH TableData DO CutRowSnips(TopRow,BottomRow,RowId1,RowId2);

      {Update first and last row pointers if necessary}
      WITH TableData DO
         BEGIN
         IF FirstRow <> NullSnip THEN FirstRow := TopRow;
         IF LastRow <> NullSnip THEN LastRow := BottomRow;
         END;

      with cutrow do
        begin
        FirstRow := RowId1;
        LastRow := RowId2;
        end;
      RowsCut := TRUE;
      ListModified := TRUE;

      {Notify the table manager of the change.}
      TMNewSnips(RowKind,PriorRow,TRUE);

      {Release the row snips}
      ReleaseSnips(RowKind,Rowid1);
      with cutrow do
        begin
        FirstRow := nullsnip;
        LastRow := nullsnip;
        end;
      RowsCut := FALSE;

      END;

   END;


{$S lmscrap }
PROCEDURE CutRowSnips{VAR HeadRow: IdType;
                      VAR TailRow: IdType;
                      FirstRow: IdType;
                      LastRow: IdType};

   {This procedure cuts a linked list beginning with FirstRow and ending
   with LastRow out of a linked list which begins with HeadRow and ends
   with TailRow.}

   CONST CR = ' CutRowSnips ';

   VAR PriorRow: IdType;
       NextRow: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,CR);

   {Set prior of FirstRow null}
   SetSnipPtr(RowKind,FirstRow);
   PriorRow := RowSnip^.PriorSnip;
   RowSnip^.PriorSnip := NullSnip;

   {Set next of LastRow null}
   IF FirstRow <> LastRow THEN SetSnipPtr(RowKind,LastRow);
   NextRow := RowSnip^.NextSnip;
   RowSnip^.NextSnip := NullSnip;

   {Set next of PriorRow}
   IF PriorRow = NullSnip THEN HeadRow := NextRow
   ELSE BEGIN
        SetSnipPtr(RowKind,PriorRow);
        RowSnip^.NextSnip := NextRow;
        END;

   {Set prior of NextRow}
   IF NextRow = NullSnip THEN TailRow := PriorRow
   ELSE BEGIN
        SetSnipPtr(RowKind,NextRow);
        RowSnip^.PriorSnip := PriorRow;
        END;

   END;


{$S lmscrap }
PROCEDURE CutTable;

   CONST CT = ' CutTable ';

   VAR Status: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,CT);
   IF MMTrap1 THEN IF CurTable <> TList THEN MMFatalErr(LogicErr,CT,'');

   {Release all of the row snips}
   ReleaseRowSnips;

   {Close the differential file without doing the updates}
   DiffClose(Status,ScanId,FALSE);

   {At this stage, the differential file is still open really, but empty.
   We will leave the ScanOpen boolean true, so that an empty table will
   be displayed. However, update the row count.}
   ListRowCount := 0;

   {Remove any current range row snips}
   IF CurRgList THEN RelCrgList;

   {Remember that the entire table has been cut, so that writelist will
   remove the necessary records before applying the updates in the
   differential file.}
   TableCut := TRUE;
   ListModified := TRUE;
   BlankLine := FALSE;
   END;


{$S lmrecov}
procedure CvtEdChk{formid:idtype; fldindx:integer; columnid:idtype; var status:integer};

{This procedure is called from OpenDocument to convert data formats to the formats of }
{ the tool language.  It calls the ConstructEditCheck routine to get a new editcheck, }
{ validates the reptype and then rebuilds the fieldinfo portion of the colsnip with   }
{ the new edit check.                                                                 }

label 900;

var
  edchk : ecstr;
  ecptr : ^ecstr;
  datasize : integer;
  dataptr : ptrdata;
  oldptr : ptrdata;
  ecsize : integer;
  oldecsize : integer;
  newsnipsize : integer;
  errstatus : integer;
  formptr : ptrdata;
  fldptr : ^DBField;
  newfldsize : integer;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  {Reset pointers to form and colsnip just in case...}
  InitSnipPtr(ColKind,FormId);
  FormPtr := @ColSnip^;
  FldPtr := @FormPtr^[FldIndx];

  {Set up pointers to the new block}
  InitSnipPtr(ColKind,ColumnId);

  {Construct a newedit check and validate the reptype}
  with colsnip^ do
    with fieldinfo do
      begin

      {Get the old edit check size}
      ecptr := @edchk;
      oldptr := pointer(ord(fldptr) + fldptr^.display);
      oldecsize := oldptr^[0];

      ConstructEditCheck(fldtype,editcheck,edchk,errstatus);
      if errstatus <> 0 then
        begin
        if mmtrap1 then writeln('*** ConstructEditCheck error : ', errstatus);
        status := mminterr;
        goto 900;
        end;
      ecsize := length(edchk);

      ValidRepType(errstatus,fldtype,editcheck,reptype,size);
      if errstatus <> 0 then
        begin
        if mmtrap1 then writeln('*** ValidRepType error : ', errstatus);
        status := mminterr;
        goto 900;
        end;
      end;

  if mmtrap1 then writeln('oldecsize, newecsize : ',oldecsize:8,ecsize:8);

  {Initialize the new fldsize}
  newfldsize := sizeof(DBField);
  if odd(sizeof(DBField)) then newfldsize := newfldsize+1;

  {Add length of name + length byte + maybe a pad byte}
  if (fldptr^.name <> FNilVal) then
    begin
    oldptr := pointer(ord(fldptr) + fldptr^.name);
    datasize := oldptr^[0];
    newfldsize := newfldsize+datasize+1;      {keep track of what actual old fldsize was}
    if odd(datasize+1) then newfldsize := newfldsize+1;
    end;

  {Determine if there is enough room in colsnip for new edit check}
  if ecsize > oldecsize then     {if new ecsize > old ecsize, expand colsnip}
    begin
    NewSnipSize := (ColSnip^.RecSize-oldecsize)+ecsize;
    ExpSnipBlock(ColumnId,NewSnipSize,ErrStatus);
    if ErrStatus <> 0 then
      begin
      status := mmNoMem;
      goto 900;
      end;
    InitSnipPtr(ColKind, ColumnId);
    end
  else NewSnipSize := ColSnip^.RecSize;

  {Rebuild the fieldinfo portion of the colsnip}
  with ColSnip^ do
    with fieldinfo do
      begin
      if mmtrap1 then writeln('newsnipsize, oldsize : ',newsnipsize:8,recsize:8);

      {Move edit check into fieldinfo record; the offset is NOT FNilVal if length is zero}
      dataptr := pointer(ord(@fieldinfo) + display);    {pointer to new structure edchk string}
      moveleft(ecptr^,dataptr^,ecsize+1);               {move new edchk into structure}
      newfldsize := newfldsize+ecsize+1;                {increment new structure size}
      if odd(ecsize+1) then                             {if size+1 is odd, pad with a byte}
        begin
        dataptr := pointer(ord(dataptr)+ecsize+2);      {reset new structure pointer for next string}
        newfldsize := newfldsize+1;                     {increment for pad byte}
        end
      else dataptr := pointer(ord(dataptr)+ecsize+1);   {reset new structure pointer for next string}

      {If there is a highval, move it into the fieldinfo record }
      if (fldptr^.highval <> FNilVal) then
        begin
        highval := newfldsize;                                  {set new offset to highval string}
        oldptr := pointer(ord(fldptr) + fldptr^.highval);       {pointer to old highval string}
        datasize := oldptr^[0];                                 {size of highval string}
        moveleft(oldptr^,dataptr^,datasize+1);                  {move highval into new structure}
        newfldsize := newfldsize + datasize+1;                  {increment newfldsize}
        if odd(datasize+1) then                                 {if the size+1 is odd, pad with a byte}
          begin
          dataptr := pointer(ord(dataptr)+datasize+2);          {reset new structure pointer for padding}
          newfldsize := newfldsize+1;                           {increment new fldsize}
          end
        else dataptr := pointer(ord(dataptr)+datasize+1);
        end
      else highval := FNilVal;

      {If there is a lowval, move it into the fieldinfo record }
      if (fldptr^.lowval <> FNilVal) then
        begin
        lowval := newfldsize;
        oldptr := pointer(ord(fldptr) + fldptr^.lowval);        {pointer to old lowval string}
        datasize := oldptr^[0];                                 {size of lowval string}
        moveleft(oldptr^,dataptr^,datasize+1);                  {move lowval string to new structure}
        newfldsize := newfldsize+datasize+1;                    {increment fldsize}
        if odd(datasize+1) then                                 {if the size+1 is odd, pad with a byte}
          begin
          dataptr := pointer(ord(dataptr)+datasize+2);          {reset new structure pointer for padding}
          newfldsize := newfldsize+1;                           {increment new fldsize}
          end
        else dataptr := pointer(ord(dataptr)+datasize+1);
        end
      else lowval := FNilVal;

      {If there is a defval, move it into the fieldinfo record }
      if (fldptr^.defval <> FNilVal) then
        begin
        defval := newfldsize;
        oldptr := pointer(ord(fldptr) + fldptr^.defval);        {pointer to old defval string}
        datasize := oldptr^[0];                                 {length of old defval string}
        moveleft(oldptr^,dataptr^,datasize+1);                  {move defval into new structure}
        newfldsize := newfldsize+datasize+1;                    {increment fldsize}
        if odd(datasize+1) then                                 {if the size+1 is odd, pad with a byte}
          begin
          dataptr := pointer(ord(dataptr)+datasize+2);          {reset new structure pointer for padding}
          newfldsize := newfldsize+1;                           {increment new fldsize}
          end
        else dataptr := pointer(ord(dataptr)+datasize+1);
        end
      else lowval := FNilVal;

      {adjust colsnip fieldinfo record size and free byte count}
      RecSize := NewSnipSize;
      FldSize := NewFldSize;
      Freebytes := RecSize - (sizeof(ColSnipRecord)-sizeof(DBField))-NewFldSize;

      end;

900:
end;


{$S lmerror }
PROCEDURE DBAlert{ErrNum: INTEGER;
                  DBStatus: INTEGER};

  {This procedure displays an alert which consists of two parts, a parameter
  which explains what could not be done, followed by a message which
  explains why it could not be done. The ErrNum which is passed in corresponds to an
  alert string which says what was being done. This string is then used as a parameter
  in a second alert which says why the action could not be done.}

  VAR ErrNum2: INTEGER;
      String1: Str255;

  BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
  IF TraceMMgr THEN WriteLn(MxMgr,' DBAlert ','ErrNum: ',ErrNum,' DBStatus: ',DBStatus);
  {The first error message tells what could not be done.}
  GetAlert(LMAlerts,ErrNum,@String1);

  {The second error message tells why it could not be done.}
  Case DBStatus of
     NoMem:  BEGIN
             ErrNum2 := NoMemErr;
             END;

     NoRoom: BEGIN
             ErrNum2 := NoRoomErr;
             END;

     IOErr:  BEGIN
             ErrNum2 := IOErrErr;
             END;

     OTHERWISE BEGIN
               ErrNum2 := OtherDBErr;
               END;
     END; {case}

  {Put the 'what' string in the alert}
  ParamAlert(String1,'','');

  {Put up the alert}
  IF CautionAlert(LMAlerts,ErrNum2) THEN;
  END;



{$S lmcolspec }
PROCEDURE DelColAttr{colsptr:ptrcolsnip;
                     initoffset: integer};

   CONST DCA = ' DelColAttr ';
   Type ia = Array [0..4] of integer;
   VAR
        ptrb,ptrc : ptrdata;
        ptra : ^ia;
        I,J : integer;
        oldlen, movelen : integer;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if traceMMGR then WriteLn(MxMgr,DCA,InitOffset);
   {delete the attribute with initoffset}
   ptrb := Pointer(ORD(@colsptr^.fieldinfo) + initoffset);
   ptrA := @colsptr^.fieldinfo.name;

   {find the attribute with that initoffset}
   I := 0;
   while (I <= 4) and (Ptra^[i] <> initoffset) do i := i + 1;
   IF MMTrap1 THEN IF I > 4 then MMFatalErr(LogicErr,'DelColAtr','');

   {Following code is put in to correct name offsets which have become corrupted prior to version A2}
   IF I = 0 THEN IF PtrA^[0] <> SizeOf(DBField) THEN
      BEGIN
      if mmtrap1 then WriteLn(Bell,'***',DCA,'Correcting odd name offset...',ColSptr^.FieldNum,PtrA^[0]);
      InitOffset := SizeOf(DBField);
      PtrA^[0] := InitOffset;
      ptrb := Pointer(ORD(@colsptr^.fieldinfo) + initoffset);
      END;

   {Find the next offset to determine the length.  Offsets must be in increasing order.}
   OldLen := ColsPtr^.FieldInfo.FldSize - InitOffset;
   J := I + 1;
   WHILE J <= 4 DO
      BEGIN
      IF PtrA^[J] <> FNilVal THEN
         BEGIN
         OldLen := PtrA^[J] - PtrA^[I];
         J := 5;
         END
      ELSE J := J + 1;
      END;
   IF Trace2MMgr THEN WriteLn(DCA,' OldLen: ',OldLen);

   {shift rest of record down}
   movelen := colsptr^.fieldinfo.fldsize - ( initoffset-1) - oldlen;
   ptrc := POINTER(ORD(ptrb) + oldlen);
   moveleft(ptrc^, ptrb^, movelen);
   colsptr^.fieldinfo.fldsize := colsptr^.fieldinfo.fldsize - oldlen;
   ptra^[i] := fnilval;
   colsptr^.freebytes := colsptr^.freebytes + oldlen;

   {now update any other attribute offsets just invalidated}
   i := 0;
   While (I <= 4)  do
      begin
      IF MMTrap1 THEN IF (Odd(PtrA^[I]) AND (PtrA^[I]<>FNilVal)) THEN WriteLn(Bell,'***',DCA,'Found odd offset: ',PtrA^[I],I);
      IF (ptra^[i] <> fnilval) and (ptra^[i] > initoffset) then ptra^[i] := ptra^[i] - oldlen;
      I := I + 1;
      end;

   END;



{$S lmrestruct }
PROCEDURE DeleteDocFiles{FileName: PathName};

   CONST DDF = ' DeleteDocFiles ';

   VAR KillFile: PathName;
       Status: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,DDF);

   {Delete the differential file}
   KillFile := ConCat(FileName,DiffSuffix);
   IF Trace2MMGr THEN WriteLn('Deleting differential file: ',KillFile);
   Kill_Secure(Status,KillFile,DocPassword);
  {Kill_Object(Status,KillFile);}
   IF MMTrap1 THEN IF (Status > 0) AND (Status <> 894) THEN
   WriteLn(Bell,'***',KillFile,' Kill_Object status: ',Status);

   {Delete the redundant file}
   KillFile := ConCat(FileName,RedunSuffix);
   IF Trace2MMGr THEN WriteLn('Deleting redundant file: ',KillFile);
   Kill_Secure(Status,KillFile,DocPassword);
  {Kill_Object(Status,KillFile);}
   IF MMTrap1 THEN IF (Status > 0) AND (Status <> 894) THEN
   WriteLn(Bell,'***',KillFile,' Kill_Object status: ',Status);

   {Delete the suspend file}
   KillFile := ConCat(FileName,SuspendSuffix);
   IF Trace2MMGr THEN WriteLn('Deleting suspend file: ',KillFile);
   Kill_Secure(Status,KillFile,DocPassword);
  {Kill_Object(Status,KillFile);}
   IF MMTrap1 THEN IF (Status > 0) AND (Status <> 894) THEN
   WriteLn(Bell,'***',KillFile,' Kill_Object status: ',Status);

   {Delete the list}
   KillFile := ConCat(FileName,ListSuffix);
   IF Trace2MMGr THEN WriteLn('Deleting list file: ',KillFile);
   Kill_Secure(Status,KillFile,DocPassword);
  {Kill_Object(Status,KillFile);}
   IF MMTrap1 THEN IF (Status > 0) AND (Status <> 894) THEN
   WriteLn(Bell,'***',KillFile,' Kill_Object status: ',Status);
   END;



{$IFC MMDEBUG }
{$S lmdebug   }
PROCEDURE DUMPCol{Tit: STR40;
                  ColPtr: PtrData};

   VAR CPtr: ^ColSnipRecord;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   Writeln(Tit,'***************** Col Snip ********************');
   CPtr := @ColPtr^;
   WITH CPtr^ DO
      BEGIN
      WriteLn('RecSize: ',recsize);
      Writeln('SnipId: ',Snipid);
      Writeln('NextSnip: ',Nextsnip);
      Writeln('PriorSnip: ',PriorSnip);
      Writeln('ListSnip: ',ListSnip);
      Writeln('Order: ',Order);
      Writeln('Width: ',Width);
      WriteLn('FieldNum: ',FieldNum);
      Writeln('SortOrder: ',SortOrder);
      WriteLn('SortDirection: ',SortDirection);
      Writeln('FreeBytes: ',FreeBytes);
      END;
   END;


{$S lmdebug }
PROCEDURE DumpCols{ColId: IdType};

   VAR I: INTEGER;
       Column: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   I := 0;
   Column := ColId;
   WHILE Column <> NullSnip DO
      BEGIN
      I := I + 1;
      WriteLn('Column: ',I);
      SetSnipPtr(ColKind,Column);
      DumpCol('',@ColSnip^);
      DumpField(@ColSnip^.FieldInfo);
      Column := ColSnip^.NextSnip;
      END;
   END;


{$S lmdebug   }
Procedure dumpcrglist;
   var row : idtype;
       i   : INteger;
   begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   writeln('curRgSnip ',curRgSnip:4 );
   row := curRgSnip;
   i:= 0;
   while row <> nullsnip do
      begin
      setsnipPtr(rowkind,row);
      write(row:3, '->',rowsnip^.nextsnip:4);
      i := i + 1;
      if i > 10 then
         begin
         writeln;
         i := 0;
         end;
      row := rowsnip^.nextsnip;
      end;
   writeln;
   end;

{$S lmdebug   }
Procedure DumpField{Ptr: PtrData};

   VAR Str: STRING[25];
       BPtr: PtrData;
       SPtr: PtrData;
       I: INTEGER;
       FPtr: ^DBField;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   FPtr := @Ptr^;
   WITH FPtr^ DO
      BEGIN
      Writeln('******* DBField Contents **********');
      WriteLn('FldSize: ',fldsize);
      WriteLn('Name: ',Name);
      WriteLn('DisPlay: ',Display);
      WriteLn('HighVal: ',HighVal);
      WriteLn('LowVal: ',LowVal);
      WriteLn('DefVal: ',DefVal);
      WriteLn('EditCheck: ',EditCheck[1],Editcheck[2],Editcheck[3],Editcheck[4],
                            Editcheck[5]);
      WriteLn('RepType: ',RepType);
      WriteLn('Offset: ',offset);
      WriteLn('Size: ',Size);

      BPtr := @Str;
      IF Name <> FNilVal THEN
         BEGIN
         SPtr := POINTER(Ord(FPtr) + Name);
         MoveLeft(SPtr^,BPtr^,20);
         WriteLn('Name^: ',Str);
         END
      ELSE WriteLn('Name^: *****');

      IF DisPlay <> FNilVal THEN
         BEGIN
         SPtr := POINTER(Ord(FPtr) + Display);
         MoveLeft(SPtr^,BPtr^,20);
         WriteLn('Display^: ',Str);
         END
      ELSE WriteLn('Display^: *****');
      END;
   END;


{$S lmdebug  }
PROCEDURE DumpHeader{Ptr: PtrData};

   VAR HPtr: ^Header;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   HPtr := @Ptr^;
   WITH HPtr^ DO
      BEGIN
      WriteLn('*********** Header Contents ***************');
      WriteLn('Space: ',space);
      WriteLn('Version: ',version);
      WriteLn('Nfields: ',nfields);
      Writeln('NKeys: ',nkeys);
      Writeln('NSort: ',nsort);
      Writeln('Keybytes: ',keybytes);
      Writeln('RecSize: ',recsize);
      END;
   END;



{$S lmdebug   }
PROCEDURE DUMPROW{RowPtr: PtrData};

   VAR RPtr: ^RowSnipRecord;
       Bptr1: Ptrdata;
       Bptr2: Ptrdata;
       CString: STRING[40];
       I: INTEGER;
       J: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   Writeln('***************** Row Snip ********************');
   RPtr := @RowPtr^;
   WITH RPtr^ DO
      BEGIN
      WriteLn('RecSize: ',recsize);
      Writeln('SnipId: ',Snipid);
      Writeln('NextSnip: ',Nextsnip);
      Writeln('PriorSnip: ',PriorSnip);
      Writeln('HandOffset: ',HandOffset);
      Writeln('DBRecSize: ',DBRecSize);
      Writeln('FreeBytes: ',FreeBytes);
      Writeln('RowTitle: ',RowTitle);
      WriteLn('BitOffset: ',BitOffset);
      Writeln('ErrorCode: ',Errorcode);
      WriteLn('Data: ',Data);

      Bptr1 := Pointer(Ord(RPtr) + BitOffset);
      Write('ErrorBits: ');
      FOR I := 0 TO (TableData.ColCount - 1) DO
         BEGIN
         IF InPset(Bptr1,I) THEN Write('1 ') ELSE Write('0 ');
         END;
      WriteLn('');

      Bptr1 := @CString;
      IF RowTitle <> FNilVal THEN
         BEGIN
         Bptr2 := POINTER(Ord(RPtr) + RowTitle);
         Moveleft(Bptr2^,Bptr1^,20);
         END
      ELSE CString := '';
      WriteLn('RowTitle^: ',CString);

      Bptr1 := POINTER(Ord(RPtr) + HandOffSet);
      WriteLn('Record Contents: ');
      J := 0;
      FOR I := 0 TO (DBRecSize - 1) DO
         BEGIN
         Write(Bptr1^[I]:4);
         J := J + 1;
         IF J = 10 THEN
            BEGIN
            J := 0;
            WriteLn('');
            END;
         END;
      Writeln('');
      END;
   END;


{$S lmdebug }
PROCEDURE DumpRows{RowId: IdType};

   VAR I: INTEGER;
       Row: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   I := 0;
   Row := RowId;
   WHILE Row <> NullSnip DO
      BEGIN
      I := I + 1;
      WriteLn('Row: ',I);
      SetSnipPtr(RowKind,Row);
      DumpRow(@RowSnip^);
      Row := RowSnip^.NextSnip;
      END;
   END;


{$S lmdebug   }
Procedure dumptb;

   var row : idtype;
       i   : INteger;

   begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   WriteLn('********************* Tabledata dump: ********************');
   WITH TableData DO
      BEGIN
      WriteLn('ColCount: ',ColCount:4,' FirstCol: ',FirstCol:4,' LastCol: ',
               LastCol:4);
      writeln('TopRow: ',toprow:4,' BottomRow: ',bottomrow:4,
              ' FirstRow: ',firstrow:4,' LastRow: ',lastrow:4);
      END;

   row := tabledata.toprow;
   i:= 0;
   while row <> nullsnip do
      begin
      setsnipPtr(rowkind,row);
      write(row:3);
      i := i + 1;
      if i > 10 then
         begin
         writeln;
         i := 0;
         end;
      row := rowsnip^.nextsnip;
      end;
   writeln;
   end;
{$ENDC }


{$S lmlist }
FUNCTION EnoughDisc{MoreBytes: INTEGER): BOOLEAN};

   CONST ED = ' EnoughDisc ';
         SlopFactor = 3;

   VAR PagesNeeded: INTEGER;
       MorePages: LONGINT;
       FreePages: INTEGER;
       MoreBlocks: INTEGER;
       Status: INTEGER;
       PagesGot: LONGINT;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Assumes the suspend file is already open}
   IF TraceMMgr THEN WriteLn(MxMgr,ED,'MoreBytes: ',MoreBytes);

   {Add morebytes to current count}
   BytesAdded := BytesAdded + MoreBytes;

   {Determine how many pages this is.}
   PagesNeeded := (((BytesAdded * SlopFactor) + 511) DIV 512);
   {Make sure there is at least a certain minimum number of free pages}
   IF PagesNeeded < MinFreePages THEN PagesNeeded := MinFreePages;

   FreePages := (SuspFreeBytes + 511) DIV 512;
   IF PagesNeeded > FreePages THEN
      BEGIN
      MoreBlocks := ((PagesNeeded - FreePages + 3) DIV 4);
      MorePages := MoreBlocks * 4;
      PagesGot := 0;
      IF Trace2MMgr THEN
         BEGIN
         WriteLn('BytesAdded: ',BytesAdded,' PagesNeeded: ',PagesNeeded);
         WRiteLn('SuspFreeBytes: ',SuspFreeBytes,' FreePages: ',FreePages);
         END;

      IF MMTrap1 THEN WriteLn
      ('*** Expanding suspendfile by ',MorePages:2, ' pages from ',FreePages:2,' pages');

      {Must try to allocate more pages on suspendfile}
      Allocate(Status,SuspRefNum,FALSE,MorePages,PagesGot);
      IF (Status <> 0) OR (PagesGot < MorePages) THEN
         BEGIN
         IF MMTrap1 THEN IF Status <> 0 THEN WriteLn('***',ED,' Allocate status: ',Status);
         SuspFreeBytes := SuspFreeBytes + (PagesGot * 512);
         EnoughDisc := FALSE;
         Exit(EnoughDisc);
         END;

      IF Trace2MMgr THEN WriteLn(' PagesGot: ',PagesGot);
      SuspFreeBytes := SuspFreeBytes + (PagesGot * 512);
      END;

   EnoughDisc := TRUE;
   END;


{$S lmopendoc }
FUNCTION EnoughMemory{NumColumns: INTEGER
                      CellHeight: INTEGER};

   {This function determines the minimum amount of memory space required
   to support a list with a certain number of columns. It also takes into
   account the height of the font, which determines how many rows you can
   get on the screen. If there is not enough space, it attempts to
   increase the size of the data segment.}

   LABEL 500;

   CONST ColSnipSize = 130;
         AvgFieldSize = 10;
         MaxDBRecSize = 1000;
         MiscSpace = 200;
         ZoneOverhead = 1200; {250 snips @4 bytes per, plus miscellaneous}
         EM = ' EnoughMemory';
         MaxPixels = 240;

   VAR Status: INTEGER;
       ColSpace: LONGINT;
       RowSpace: LONGINT;
       RowSize: LONGINT;
       SpaceRequired: LONGINT;
       DeltaSize: LONGINT;
       FieldSpace: LONGINT;
       RowOverHead: LONGINT;
       BitMapSize: INTEGER;
       MaxRowsPerScreen: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr
   THEN WriteLn(MxMgr,EM,' NumColumns: ',NumColumns:4,' CellHeight: ',CellHeight:3);

   {Compute space for the column snips}
   ColSpace := NumColumns * ColSnipSize;
   IF Trace2MMgr THEN WriteLn('Column space: ',ColSpace);

   {Compute the space required for a screen full of rows, plus a screen
   full on the current selection list, plus a full screen in the scrap,
   plus another 3/4 screen full for page scrolling, since you need both the
   visible screen and the next screen in that case. This amounts to 3.75
   screen fulls in all}
   FieldSpace := CMin(MaxDBRecSize,(NumColumns * AvgFieldSize));
   BitMapSize := ((NumColumns + 15) DIV 16) * 2;
   RowOverHead := SizeOf(RowSnipRecord) + SizeOf(PreAmble) + BitMapSize;
   RowSize := RowOverhead + FieldSpace;
   MaxRowsPerScreen := MaxPixels DIV CellHeight;
   IF Trace2MMgr THEN WriteLn('MaxRowsPerScreen: ',MaxRowsPerScreen);
   RowSpace := RowSize * 3 * (MaxRowsPerScreen + (MaxRowsPerScreen DIV 4));
   IF Trace2MMgr THEN WriteLn('RowSize: ',RowSize,' RowSpace: ',RowSpace);

   {Compute the total. This includes the column snips, the row snips, plus
   enough left over to accommodate miscellaneous snips like the search
   constants and expressions. Also includes storage manager overhead.
   You do not have to account for the list form and the file form, because
   at the time these forms are created, the row snips have been released.
   You also should not have to account for the fexec suspend block, because
   prior to a suspend, any rows in the scrap will have been released and
   this should more than make enough room.}
   SpaceRequired := ColSpace + RowSpace + ZoneOverhead + MiscSpace;
   IF Trace2MMgr THEN WriteLn('SpaceRequired: ',SpaceRequired);

500: {Check space required against current segment disc size}
   IF SpaceRequired > SegDiscSize THEN
      BEGIN
      {Try to get more disc space for segment}
      DeltaSize := SpaceRequired - SegDiscSize;
      IF MMTrap1
      THEN WriteLn('***Expanding segment disc size from: ',SegDiscSize,' to: ',SpaceRequired);
      Size_DataSeg(Status,SegRefNum,0,SegMemSize,DeltaSize,SegDiscSize);
      IF Status > 0 THEN
         BEGIN
         IF MMTrap1 THEN WriteLn('***',EM,'Size_DataSeg status: ',status);
         EnoughMemory := FALSE;
         EXIT(EnoughMemory);
         END;

      IF MMTrap1 THEN WriteLn('***Disc size of segment expanded to: ',SegDiscSize,' bytes');
      END;

   EnoughMemory := TRUE;
   END;



{$S lmres }
PROCEDURE ExpSnipBlock{SnipId: IdType;
                       NewSize: INTEGER;
                       VAR Status: INTEGER};

   CONST ESB = ' ExpSnipBlock ';

   VAR ActualSize: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,ESB,SnipId,NewSize);
   Status := 0;
   StatusMakeSpace := 0;

   {Expand the size of the snip block}
   ChangeSizeH(SnipZone,SnipToPtr(SnipId),NewSize);

   {Now verify that the size is adequate.}
   ActualSize := CbDataOfH(SnipZone,SnipToPtr(SnipId));
   IF ActualSize >= NewSize THEN Exit(ExpSnipBlock);    {Success!}

   {Expansion failed for some reason. Try again, since more than one call to
   MakeSpace may be necessary before all of its options are exhausted.}
   IF MMTrap1 THEN WriteLn(Bell,'***',ESB,'First ChangeSizeH failed..');

   {Try again to expand the size of the snip block}
   ChangeSizeH(SnipZone,SnipToPtr(SnipId),NewSize);

   {Now verify that the size is adequate.}
   ActualSize := CbDataOfH(SnipZone,SnipToPtr(SnipId));
   IF ActualSize >= NewSize THEN Exit(ExpSnipBlock);

   {Expansion failed. Return error status}
   IF StatusMakeSpace = 309 THEN Status := NoRoom ELSE Status := NoMem;
   IF MMTrap1 THEN WriteLn(Bell,'***',ESB,'Second ChangeSizeH failed, ExpSnipBlock final status: ',Status);
   END;




