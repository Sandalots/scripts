
{$S lmscrap}
function PasteAbort{(lstatus:integer):boolean};

var
  alertnumber : integer;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
  if mmtrap1 then writeln('PasteAbort');

  if lstatus = rectoosmall then alertnumber := PasteRecFull
  else if (lstatus = nomem) or (lstatus = noroom) then
         begin
         DBAlert(PasteTechDiff,lstatus);
         PasteAbort := TRUE;
         exit(PasteAbort);
         end
  else alertnumber := PasteEdChk;

  if ((alertnumber = PasteEdChk) and IgnoreEdChkErrs)
  or ((alertnumber = PasteRecFull) and IgnoreRowFull) then PasteAbort := FALSE
  else
    begin
    {see if the user wants to continue or abort paste operation}
    if askalert(lmalerts,alertnumber) = 2 then
      begin
      if (alertnumber = PasteEdChk) then IgnoreEdChkErrs := TRUE else IgnoreRowFull := TRUE;
      PasteAbort := FALSE;
      end
    else PasteAbort := TRUE;     {abort}
    end;

end;



{$S lmscrap}
procedure PasteCache{var status : integer; ucols : integer; duplicate : boolean};
{ status : 1-no universal text (done) or abort or stop  }

label 10,20,99;

const
  pc = 'PasteCache';

var
  row : idtype;
  col : idtype;
  charcnt : integer;
  lstatus : integer;
  overflow : boolean;
  tabtyp : ttabtypes;
  handleptr : ^LMHandle;
  PCAbort : boolean;
  EOLflag : boolean;
  ucolcnt : integer;
  ClearingField : boolean;
  i : integer;

  procedure Depart;
  begin
    updaterow;
    status := 1;
    exit(pastecache);
  end;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  if mmtrap1 then writeln(pc);

  IgnoreEdChkErrs := FALSE;
  status := 0;
  PCAbort := FALSE;
  EOLflag := TRUE;

  {see if there is any universal text}
  if readutext.READFIELD(1000,overflow,uterminator,tabtyp) then
    begin
    charcnt := readutext.data.size;
    readutext.data.STOPEDIT;
    if mmtrap2 then
      begin
      write('len : ',charcnt,' ==> ');
      for i := 1 to charcnt do write(readutext.buffer.AT(i):1);
      writeln;
      end;
    end
  else begin
       status := 1;
       exit(pastecache);
       end;

  {loop through snips in cache to insert utext}
  row := selrg.lorow;
  while row <> nullsnip do
    begin

    {if we are looking at the blankline, it is going to be filled with data and will no}
    { longer be blank, so set blankline to FALSE so updaterow will not add a row       }
    setsnipptr(rowkind,row);
    handleptr := pointer(ord(rowsnip) + rowsnip^.handoffset);
    if (blankline) and
       (handleptr^.high = blankhandle.high) and
       (handleptr^.low = blankhandle.low) then
      begin
      if utextrestart
      and ((selrg.rkind = acolrg) or (selrg.rkind = aWTBoxRg))
      then exit(pastecache)              {if duplicating in a column or table, don't use blankrow}
      else blankline := FALSE;
      end;

    {loop through columns in range}
    col := selrg.locol;
    ucolcnt := 0;
    while (ucolcnt < ucols) and (col <> nullsnip) do
      begin
      ucolcnt := ucolcnt+1;

      {put universal text into snip}
      ClearingField := FALSE;
10:
      cellvalue(mmwrite,row,col,pointer(readutext.data.addrmember(1)),true,charcnt,lstatus);
      if PCAbort then depart
      else if lstatus <> 0 then
        begin
        if mmtrap1 then writeln(pc,'; cellvalue 1 status : ',lstatus);
        if ClearingField then
          begin
          DBAlert(PasteTechDiff,lstatus);
          depart;
          end
        else PCAbort := PasteAbort(lstatus);
        ClearingField := TRUE;
        charcnt := 0;
        goto 10;
        end;

      {if duplicate then fill the correct columns for this row}
      if duplicate then
        begin
        PasteDup(row,col,ucols,lstatus);
        if lstatus <> 0 then depart;
        end;

      if uterminator = chr(chCR) then EOLflag := TRUE else EOLflag := FALSE;
      if EOLflag and (ucolcnt < ucols) then charcnt := 0
      else
        begin
        {get more universal text}
20:     if readutext.READFIELD(1000,overflow,uterminator,tabtyp) then
          begin
          charcnt := readutext.data.size;
          readutext.data.STOPEDIT;
          if mmtrap2 then
            begin
            write('len : ',charcnt,' ==> ');
            for i := 1 to charcnt do write(readutext.buffer.AT(i):1);
            writeln;
            end;
          end
        else begin
             if duplicate then                {if duplicate, start reading text again}
               begin
               readutext.RESTART;
               utextrestart := TRUE;
               goto 20;
               end;

             depart;
             end;
        end;

      {if last delimiter was CR, then go to next row}
      if EOLflag and (ucolcnt = ucols) then col := nullsnip
      else if col = selrg.hicol then col := nullsnip
           else begin
                getnxtviscol(col);
                if col = pinfsnip then col := nullsnip;
                end;

      end;     {while col <> nullsnip}

    updaterow;
    if UpdRowErr then
      begin
      status :=1;
      exit(pastecache);
      end;

    if row = selrg.hirow then
      begin
      status := 1;
      row := nullsnip;
      end
    else begin
         setsnipptr(rowkind,row);       {get next rowsnip in cache}
         row := rowsnip^.nextsnip;
         end;

    end;  {while row <> nullsnip}

99:

end;      {PasteCache}


{$S lmcolspec }
PROCEDURE PasteCols{PriorCol: IdType};

   CONST PC = ' PasteCols';

   VAR NextCol: IdType;
       Column: IdType;
       I: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,PC,' PriorCol: ',PriorCol:3);
   IF MMTrap1 THEN
      BEGIN
      IF CurTable <> TColSpecs THEN MMFatalErr(LogicErr,PC,'');
      IF NOT ColumnsCut THEN MMFatalErr(LogicErr,PC,'');
      END;

   {Cut the columns out of the list}
   WITH TableData DO CutColSnips(FirstCol,LastCol,CutCol.FirstCol,CutCol.LastCol);

   {Loop through the cut columns and make them visible.}
   Column := CutCol.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^ DO
         BEGIN
         Visible := TRUE;
         Column := NextSnip;
         END;
      END;

   {Insert the columns back into the table list after specified snip}
   WITH TableData DO
      BEGIN
      IF PriorCol = NullSnip THEN       {LM210}
        IF ColumnsDeleted THEN PriorCol := DelCol.LastCol;

      InsertColSnips(FirstCol,LastCol,PriorCol,CutCol.FirstCol,CutCol.LastCol);

      {Loop through the column snips and put the order fields in order}
      ReOrderColumns(FirstCol,ColCount);
      END;

   {Null out the cutcol list. Remember order change for later listform update.}
   ColumnsCut := FALSE;
   ListFormChanged := TRUE;

   {Notify the table manager of the new columns}
   IF PriorCol = NullSnip THEN PriorCol := MInfSnip
   ELSE BEGIN     {LM192}
        {If PriorCol is invisible, find the next previous visible column since the table
        editor would get slightly confused if you gave it a snip which it didn't know about}
        SetSnipPtr(ColKind,PriorCol);
        IF NOT ColSnip^.Visible THEN GetPrvVisCol(PriorCol);
        END;
   TMNewSnips(ColKind,PriorCol,TRUE);
   END;


{$S lmscrap}
procedure PasteDup{row,col : idtype; ucols : integer; var status : integer};

label 10;
const
  pd = 'PasteDup';
var
  colcnt : integer;
  lstatus : integer;
  charcnt : integer;
  savecharcnt : integer;
  PDAbort : boolean;
  ClearingField : boolean;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
  PDAbort := FALSE;
  charcnt := readutext.data.size;
  savecharcnt := charcnt;
  status := 0;

  while (col <> pinfsnip) do       {loop until you reach last column}
    begin
    colcnt := 0;
    while colcnt <> ucols do     {find next column where this duplicate goes}
      begin
      if col = selrg.hicol then
        begin
        col := pinfsnip;
        colcnt := ucols;
        end
      else begin
           getnxtviscol(col);
           colcnt := colcnt+1;
           end;
      end;

    {if not at end of columns, put duplicate here}
    if (col <> pinfsnip) then
      begin
      ClearingField := FALSE;
10:   cellvalue(mmwrite,row,col,pointer(readutext.data.addrmember(1)),true,charcnt,lstatus);
      if PDAbort then
        begin
        status := 1;
        exit(pastedup);
        end
      else if lstatus <> 0 then
        begin
        if mmtrap1 then writeln(pd,'; cellvalue lstatus : ',lstatus);
        if ClearingField then
          begin
          DBAlert(PasteTechDiff,lstatus);
          status := 1;
          exit(pastedup);
          end
        else PDAbort := PasteAbort(lstatus);
        ClearingField := TRUE;
        charcnt := 0;
        goto 10;
        end;

      charcnt := savecharnt;    {restore charcnt in case we cleared a field}
      end;
    end;

end;


{$S lmscrap}
procedure PasteFile{var status : integer; ucols : integer; duplicate : boolean};
{ status : 1-no more universal text (done) or abort  2-end of records in file }
{ 3-lmfetch err  4-getsnipblock err  5-setuprec err                           }

label 10,20,30,99;

const
  pf = 'PasteFile';

var
  lstatus : integer;
  charcnt : integer;
  usererror : integer;
  errbits : array[0..20] of integer;
  errptr : ptrbits;
  handleptr : ^lmhandle;
  dataptr : ptrdata;
  reclen : integer;
  newreclen : integer;
  setsize : integer;
  row,col : idtype;
  overflow : boolean;
  tabtyp : ttabtypes;
  PFAbort : boolean;
  EOLflag : boolean;
  i,ucolcnt : integer;
  ClearingField : boolean;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  if mmtrap1 then writeln(pf);
  status := 0;
  PFAbort := FALSE;
  EOLflag := TRUE;

  {never read utext here cuz pastecache has already done it}
  charcnt := readutext.data.size;

  {quit if there is no universal text}
  if (charcnt = 0) and (uterminator <> chr(chCR)) and (uterminator <> chr(chTAB)) then
    begin
    status := 1;
    exit(pastefile);
    end;

  {find the last row in the table and make it current of scan}
  setsnipptr(rowkind,tabledata.bottomrow);
  handleptr := pointer(ord(rowsnip) + rowsnip^.handoffset);
  errptr := pointer(ord(rowsnip) + rowsnip^.bitoffset);
  lmfetch(lstatus,rowsnip^.errorcode,errptr,scanid,exact,handleptr^,reclen);
  if lstatus <> 0 then
    begin
    if mmtrap1 then writeln(pf,'; lmfetch exact status : ',lstatus);
    DBAlert(PasteTechDiff,lstatus);
    status := 3;
    exit(pastefile);
    end;

  {loop through records in file and add cell data}
  while status = 0 do
    begin

    {fetch the next record}
    lmfetch(lstatus,rowsnip^.errorcode,errptr,scanid,next,handleptr^,reclen);
    if lstatus <> 0 then
      begin
      if mmtrap1 then writeln(pf,'; lmfetch status next : ',lstatus);
      if lstatus = EOS then status := 2
      else begin
           if mmtrap1 then writeln(pf,'; lmfetch exact status : ',lstatus);
           DBAlert(PasteTechDiff,lstatus);
           status := 3;
           end;
      exit(pastefile);
      end;

    {get a snip to put record into}
    setsize := ((tabledata.colcount+15) div 16) * 2;
    getsnipblock(row,reclen+sizeof(rowsniprecord)+setsize+recexpand,lstatus);
    if lstatus <> 0 then
      begin
      if mmtrap1 then writeln(pf,'; getsnipblock status : ',lstatus);
      DBAlert(PasteTechDiff,lstatus);
      status := 4;
      exit(pastefile);
      end;

    {set up the snip and fill with record data}
    initsnipptr(rowkind,row);
    setuprec(rowsnip,row,reclen,setsize,rowsnip^.errorcode,@errbits,lstatus);
    if lstatus <> 0 then
      begin
      if mmtrap1 then writeln(pf,'; setuprec status : ',lstatus);
      DBAlert(PasteTechDiff,lstatus);
      status := 5;
      goto 99;
      end;

    {if we are looking at the blankline, it is going to be filled with data and will no}
    { longer be blank, so set blankline to FALSE so updaterow will not add a row       }
    handleptr := pointer(ord(rowsnip) + rowsnip^.handoffset);
    if (blankline) and
       (handleptr^.high = blankhandle.high) and
       (handleptr^.low = blankhandle.low) then
      begin
      if utextrestart
      and ((selrg.rkind = acolrg) or (selrg.rkind = aWTBoxRg))
      then goto 99      {if duplicating in a column or table, don't use blankline}
      else blankline := FALSE;
      end;

    {loop through columns and insert data}
    ucolcnt := 0;
    col := selrg.locol;
    while (ucolcnt < ucols) and (col <> nullsnip) and (status = 0) do
      begin
      ucolcnt := ucolcnt+1;

      {put universal text into snip}
      ClearingField := FALSE;
10:   cellvalue(mmwrite,row,col,pointer(readutext.data.addrmember(1)),true,charcnt,lstatus);
      if PFAbort then
        begin
        status := 1;
        goto 20;
        end
      else if lstatus <> 0 then
        begin
        if mmtrap1 then writeln(pf,'; cellvalue 1 status : ',lstatus);
        if ClearingField then
          begin
          DBAlert(PasteTechDiff,lstatus);
          status := 1;
          goto 20;
          end
        else PFAbort := PasteAbort(lstatus);
        ClearingField := TRUE;
        charcnt := 0;
        goto 10;
        end;

      {if duplicate then fill the correct columns for this row}
      if duplicate then
        begin
        PasteDup(row,col,ucols,lstatus);
        if lstatus <> 0 then
          begin
          status := 1;
          goto 20;
          end;
        end;

      if uterminator = chr(chCR) then EOLflag := TRUE else EOLflag := FALSE;
      if EOLflag and (ucolcnt < ucols) then charcnt := 0
      else
        begin

        {get more universal text}
30:     if readutext.READFIELD(1000,overflow,uterminator,tabtyp) then
          begin
          charcnt := readutext.data.size;
          readutext.data.STOPEDIT;
          if mmtrap2 then
            begin
            write('len : ',charcnt,' ==> ');
            for i := 1 to charcnt do write(readutext.buffer.AT(i):1);
            writeln;
            end;
          end
        else begin
             if duplicate then                {if duplicate, start reading text again}
               begin
               readutext.RESTART;
               utextrestart := TRUE;
               goto 30;
               end;

             status := 1;
             goto 20;
             end;
        end;

      {if delimiter is CR, then go to next row}
      if EOLflag and (ucolcnt = ucols) then col := nullsnip
      else if col = selrg.hicol then col := nullsnip
           else begin
                getnxtviscol(col);
                if col = pinfsnip then col := nullsnip;
                end;

      end;     {while col <> nullsnip}

20: updaterow;
    if UpdRowErr then status := 1;

99: fresnipblock(row);   {free the temp snip for this record}
    rowchanged := nullsnip;

    end;  {while status = 0}

end;      {PasteFile}



{$S lmscrap}
procedure PasteNew{var status : integer; ucols : integer; duplicate : boolean};
{ status : 1-no more universal text (done) or abort  2-blankrow problem  }
{ 3-getsnipblock err  4-expsnipblock err  5-not enough room for new record  6-lminsert err  7-lmfetch err }

label 10,20,40,99;

const
  pn = 'PasteNew';

var
  lstatus : integer;
  charcnt : integer;
  usererror : integer;
  errbits : array[0..20] of integer;
  reclen : integer;
  template : idtype;
  tempsize : integer;
  tempptr : ptrrowsnip;
  row,col : idtype;
  handleptr : ^lmhandle;
  shandle : lmhandle;
  overflow : boolean;
  tabtyp : ttabtypes;
  byte1ptr : ptrdata;
  byte2ptr : ptrdata;
  dataptr : ptrdata;
  PNAbort : boolean;
  EOLflag : boolean;
  i,ucolcnt : integer;
  ClearingField : boolean;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  if mmtrap1 then writeln(pn);
  status := 0;
  lstatus := 0;
  PNAbort := FALSE;
  EOLflag := TRUE;

  {don't read unless this is the first paste--- proc called}
  if selrg.rkind = arowgrid then
    if readutext.READFIELD(1000,overflow,uterminator,tabtyp) then readutext.data.STOPEDIT;
  charcnt := readutext.data.size;
  if mmtrap2 then
    begin
    write('len : ',charcnt,' ==> ');
    for i := 1 to charcnt do write(readutext.buffer.AT(i):1);
    writeln;
    end;

  {quit if there is no universal text}
  if (charcnt = 0) and (uterminator <> chr(chCR)) and (uterminator <> chr(chTAB)) then
    begin
    status := 1;
    exit(pastenew);
    end;

  {create a snip template to use for holding new record data}
  BlankRow('',FALSE,template,lstatus);
  if lstatus <> 0 then
    begin
    if mmtrap1 then writeln(pn,'; blankrow status : ',lstatus);
    DBAlert(PasteTechDiff,lstatus);
    status := 2;
    exit(pastenew);
    end;

  {if pasting at a rowgrid then make current of scan the priorrow}
  if selrg.rkind = arowgrid then
    begin
    {if pasting new rows at the rowgrid after the blankrow, blankline := FALSE}
    if (selrg.hirow = pinfsnip) then blankline := FALSE;

    nullcr;
    if selrg.lorow = minfsnip then
      begin
      lmfetch(lstatus,usererror,@errbits,scanid,first,shandle,reclen);
      if lstatus = EOS then lstatus := 0;
      end
    else
      begin
      setsnipptr(rowkind,selrg.lorow);
      handleptr := pointer(ord(rowsnip)+rowsnip^.handoffset);
      lmfetch(lstatus,usererror,@errbits,scanid,exact,handleptr^,reclen);
      end;

    if lstatus <> 0 then
      begin
      if mmtrap1 then writeln(pn,'; lmfetch status : ',lstatus);
      DBAlert(PasteTechDiff,lstatus);
      status := 7;
      goto 99;
      end;
    end;

  {get the template snip size}
  SetSnipPtr(rowkind,template);
  tempsize := rowsnip^.recsize;

  {loop until you run out of utext}
  while (status = 0) do
    begin
    {each time you create a new record, get a new snipblock and copy template into it}
    GetSnipBlock(row,tempsize,lstatus);
    if lstatus <> 0 then
      begin
      if mmtrap1 then writeln(pn,'; getsnipblock status : ',lstatus);
      DBAlert(PasteTechDiff,lstatus);
      status := 3;
      goto 99;
      end;

    {copy template into new snip}
    SetSnipPtr(rowkind,template);       {reset pointer to template}
    byte1ptr := pointer(ord(rowsnip));
    InitSnipPtr(rowkind,row);         {set pointer to new row snip}
    byte2ptr := pointer(ord(rowsnip));
    moveleft(byte1ptr^[0],byte2ptr^[0],tempsize);
    rowsnip^.snipid := row;

    {loop through columns and insert data}
    col := selrg.locol;
    ucolcnt := 0;
    while (ucolcnt < ucols) and (col <> nullsnip) do
      begin
      ucolcnt := ucolcnt+1;

      {put universal text into snip}
      ClearingField := FALSE;
10:   cellvalue(mmwrite,row,col,pointer(readutext.data.addrmember(1)),true,charcnt,lstatus);
      if PNAbort then
        begin
        status := 1;
        goto 20;
        end
      else if lstatus <> 0 then
        begin
        if mmtrap1 then writeln(pn,'; cellvalue 1 status : ',lstatus);
        if ClearingField then
          begin
          DBAlert(PasteTechDiff,lstatus);
          status := 1;
          goto 20;
          end
        else PNAbort := PasteAbort(lstatus);
        ClearingField := TRUE;
        charcnt := 0;
        goto 10;
        end;

      {if duplicate then fill the correct columns for this row}
      if duplicate then
        begin
        PasteDup(row,col,ucols,lstatus);
        if lstatus <> 0 then
          begin
          status := 1;
          goto 20;
          end;
        end;

      if uterminator = chr(chCR) then EOLflag := TRUE else EOLflag := FALSE;
      if EOLflag and (ucolcnt < ucols) then charcnt := 0
      else
        begin
        {get more universal text}
        if readutext.READFIELD(1000,overflow,uterminator,tabtyp) then
          begin
          charcnt := readutext.data.size;
          readutext.data.STOPEDIT;
          if mmtrap2 then
            begin
            write('len : ',charcnt,' ==> ');
            for i := 1 to charcnt do write(readutext.buffer.AT(i):1);
            writeln;
            end;
          end
        else begin
             status := 1;
             goto 20;
             end;
        end;

      {if last delimiter was CR, then go to next row}
      if EOLflag and (ucolcnt = ucols) then col := nullsnip
      else if col = selrg.hicol then col := nullsnip
           else begin
                getnxtviscol(col);
                if col = pinfsnip then col := nullsnip;
                end;

      end;     {while col <> nullsnip}

    {insert the new record}
20: SetSnipPtr(rowkind,row);         {reset pointer to row snip}
    dataptr := pointer(ord(rowsnip)+rowsnip^.handoffset);

    {Make sure size is even}
    RecLen := RowSnip^.DBRecSize;
    if ODD(RecLen) then
       begin
       if RowSnip^.FreeBytes <= 0 then
          begin
          ExpSnipBlock(row,RowSnip^.RecSize+RecExpand,lStatus);
          if lStatus <> 0 then
            begin
            if mmtrap1 then writeln(pn,'; expsnipblock status : ',lstatus);
            DBalert(PasteTechDiff,lstatus);
            status := 4;
            goto 40;
            end;

          SetSnipPtr(RowKind,row);
          WITH RowSnip^ DO
             BEGIN
             RecSize := RecSize + RecExpand;
             FreeBytes := FreeBytes + RecExpand;
             END;
          END;
       RecLen := RecLen + 1;
       END;

    {Make sure there is enough slush disc space for posting later}
    IF NOT EnoughDisc(RecLen) THEN
       BEGIN
       if mmtrap1 then writeln(pn,'; NOT EnoughDisc');
       DBAlert(PasteTechDiff,NoRoom);
       Status := 5;
       GOTO 40;
       END;

    {Insert the row in the differential file}
    LMInsert(lStatus,ScanId,dataptr,RecLen);
    if lStatus <> 0 then
      begin
      if mmtrap1 then writeln(pn,'; lminsert status : ',lstatus);
      if lstatus = Handle_Overflow then
        begin
        lstatus := insert2err;
        if CautionAlert(LMAlerts,lstatus) then;
        end
      else DBAlert(PasteTechDiff,lstatus);
      status := 6;
      end
    else ListModified := TRUE;

40: fresnipblock(row);   {free the temp snip for this record}

    end;  {while status = 0}

99:
    fresnipblock(template);   {free the template snip}
    rowchanged := nullsnip;

end;      {PasteNew}


(*
{$S lmlist }
PROCEDURE PasteRows{PriorRow: IdType;};

{   LABEL 500;}

   CONST PR = ' PasteRows ';

   VAR ErrBits: ARRAY[0..MaxIntWdSize] OF INTEGER;
       Status: INTEGER;
       UserError: INTEGER;
       SHandle: LMHandle;
       Len: INTEGER;
       PtrHand: ^LMHandle;
       Row: IdType;
       DataPtr: PtrData;
       NextRow: IdType;
       RecordSize: INTEGER;
       I: INTEGER;
       Trouble: BOOLEAN;
       AlertMsg: INTEGER;
       FirstCopy: IdType;
       LastCopy: IdType;
       NoRowsPasted: BOOLEAN;
       TempHead: IdType;
       TempTail: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

   IF TraceMMgr THEN WriteLn(MxMgr,PR,PriorRow);
{  IF NOT RowsCut THEN MMFatalErr(LogicErr,PR,'');}
   IF MMTrap1 THEN IF CurTable <> TList THEN MMFatalErr(LogicErr,PR,'');
   IF Trace2MMgr  THEN WriteLn('PriorRowId: ',PriorRow);

   if cutrow.firstrow = nullsnip then exit(pasterows);

   NoRowsPasted := TRUE;
   TempHead := NullSnip;
   TempTail := NullSnip;

   {Check scanopen - may have run into trouble}
   IF NOT ScanOpen THEN
      BEGIN
      DBAlert(PasteErr,999);
      Exit(PasteRows);
      END;

   {Do not paste after the blank line}
   IF BlankLine THEN
      BEGIN
      IF (PriorRow = TableData.LastRow) AND (PriorRow <> NullSnip) THEN
         BEGIN
         IF Trace2MMgr  THEN Writeln('Attempt to paste after blank line');
         SetSnipPtr(RowKind,PriorRow);
         PriorRow := RowSnip^.PriorSnip;
         IF Trace2MMgr  THEN WriteLn('New PriorRowId: ',PriorRow);
         END;
      END;

   {Make the previous row current of scan}
   IF PriorRow = NullSnip THEN
      BEGIN
      {Find first}
      IF Trace2MMgr  THEN Writeln('Prior row id is null');
      LMFetch(Status,UserError,@ErrBits,ScanId,First,SHandle,Len);
      IF Status <> EOS THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***',PR,'LMFetch first status: ',Status);
         GOTO 500;
         END;
      END

   ELSE BEGIN
        {Find exact}
        IF Trace2MMgr  THEN Writeln('Prior row id is not null');
        SetSnipPtr(RowKind,PriorRow);
        PtrHand := Pointer(Ord(RowSnip) + RowSnip^.HandOffset);
        LMFetch(Status,UserError,@ErrBits,ScanId,Exact,PtrHand^,Len);
        IF Status <> 0 THEN
           BEGIN
           IF MMTrap1 THEN WriteLn(Bell,'***',PR,'LMFetch exact status: ',Status);
           GOTO 500;
           END;
        END;


   {Loop through the rows and add to the differential file}
   IF Trace2MMgr  THEN Writeln('Adding pasted rows to differential file');
   Row := CutRow.FirstRow;
   WHILE Row <> NullSnip DO
      BEGIN
      {Set pointer to data}
      SetSnipPtr(RowKind,Row);
      DataPtr := Pointer(Ord(RowSnip) + RowSnip^.HandOffset);

      {Make sure size is even}
      RecordSize := RowSnip^.DBRecSize;
      IF ODD(RecordSize) THEN
         BEGIN
         IF RowSnip^.FreeBytes <= 0 THEN
            BEGIN
            ExpSnipBlock(Row,RowSnip^.RecSize+RecExpand,Status);
            IF Status <> 0 THEN GOTO 500; {Status will be either NoRoom or NoMem.}

            SetSnipPtr(RowKind,Row);
            WITH RowSnip^ DO
               BEGIN
               RecSize := RecSize + RecExpand;
               FreeBytes := FreeBytes + RecExpand;
               END;
            END;
         RecordSize := RecordSize + 1;
         END;

      {Make sure there is enough slush disc space for posting later}
      IF NOT EnoughDisc(RecordSize) THEN
         BEGIN
         Status := NoRoom;
         GOTO 500;
         END;

      {Insert the row in the differential file}
      IF Trace2MMgr  THEN WriteLn('Call to LMInsert');
      LMInsert(Status,ScanId,DataPtr,RecordSize);
      IF Trace2MMgr  THEN WRiteln('Return from LMInsert');
      IF Status = NoErr THEN
         BEGIN

         {Get next row}
         SetSnipPtr(RowKind,Row);
         NextRow := RowSnip^.NextSnip;

         {Insert the duplicate into the temporary list of successfully inserted rows. This list is
         kept separate from the main list until the very end, because a call to MakeSpace at this
         point would end up throwing out the new rows.}
         InsertRowSnips(TempHead,TempTail,TempTail,Row,Row);
         NoRowsPasted := FALSE;

         Row := Nextrow;

         END


      ELSE BEGIN
           {Some, if not all, of the rows cannot be inserted in the differential file.}
           IF MMTrap1 THEN WriteLn('***LMInsert Failure - Status: ',Status);

           END;
      END;


500: {If we managed to paste in some rows, fix up the structures}
   IF NOT NoRowsPasted THEN
      BEGIN {Some rows were pasted}
      {Link in the new rows to the main list. This is done at the last minute to prevent
      a call to MakeSpace throwing out the newly added rows.}
      WITH TableData DO InsertRowSnips(TopRow,BottomRow,PriorRow,TempHead,TempTail);

      {Reset the first and last rows in case they have changed}
      WITH TableData DO
         BEGIN
         IF FirstRow <> NullSnip THEN FirstRow := TopRow;
         IF LastRow <> NullSnip THEN LastRow := BottomRow;
         END;

      {reset cutrow structure}
      with cutrow do
        begin
        firstrow := nullsnip;
        lastrow := nullsnip;
        end;

      {Notify the table manager of the change.}
      IF PriorRow = NullSnip THEN PriorRow := MInfSnip;
      TMNewSnips(RowKind,PriorRow,TRUE);

      {Remember the list has changed}
      ListModified := TRUE;
      END;

   {If there was an error, put up an alert. We have to wait until after the structures are fixed up
   and the table editor has been notified via TMNewSnips before putting up the alert, otherwise the
   update region may be scrolled out from under the alert box and the update does not occur properly.}
   IF Status <> 0 THEN
      BEGIN
      {Put up error alert}
      IF Status = Handle_Overflow THEN
         BEGIN
         IF NoRowsPasted THEN AlertMsg := Insert1Err ELSE AlertMsg := Insert2Err;
         IF CautionAlert(LMAlerts,AlertMsg) THEN;
         END
      ELSE DBAlert(PasteErr,Status);
      END;
   END;
*)



{$S lmclosedoc }
PROCEDURE PrepColumns;

   CONST PC = ' PrepColumns ';

   VAR TicName: STRING[10];
       TicNameLen: INTEGER;
       TicEdit: ECStr;
       TicEditLen: INTEGER;
       BlockSize: INTEGER;
       TicId: IdType;
       Source: PtrData;
       Target: PtrData;
       ErrNum: INTEGER;
       Column: IdType;
       NextOffset: INTEGER;
       FldNumber: INTEGER;
       LStatus: INTEGER;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {This procedure prepares a list of column snips for form generation,
   prior to creating a data file. It creates a ticket column and links
   it in as the second column in the list. Then for each column, it fills
   in the field reptype, size, offsets, and options of the fieldinfo part.}
   IF TraceMMgr THEN WriteLn(MxMgr,PC);

   {Create a column spec for the ticket field}
   TicName := 'Ticket#';
   TicNameLen := Length(TicName) + 1;
   NullEditCheck(TicEdit,Tick);
   TicEditLen := Length(TicEdit) + 1;
   BlockSize := SizeOf(ColSnipRecord)
                + TicNameLen
                + TicEditLen
                + ColExpansion;
   GetSnipBlock(TicId,BlockSize,LStatus);

   {Load up the column snip}
   InitSnipPtr(ColKind,TicId);
   WITH ColSnip^ DO
      BEGIN
      RecSize := BlockSize;
      SnipId := TicId;
      SnipType := ColKind;
      NextSnip := NullSnip;
      PriorSnip := NullSnip;
      ListSnip := NullSnip;
      Order := 2;
      Width := ColWidth;
      NewColumn := TRUE;
      FieldNum := 1;
      SortOrder := 0;
      SortDirection := 0;
      Visible := FALSE;
      FreeBytes := ColExpansion;
      END;

   WITH ColSnip^.FieldInfo DO
      BEGIN
      FldSize := SizeOF(DBField)
                 + TicNameLen
                 + TicEditLen;

      {Move in name string}
      Name := SizeOf(DBField);
      Source := @TicName;
      Target := POINTER(Ord(@ColSnip^.FieldInfo) + Name);
      MoveLeft(Source^,Target^,TicNameLen);

      {Now move in edit check}
      {Note - TicNameLen must be even length, so that Display offset is even.}
      Display := Name + TicNameLen;
      Source := @TicEdit;
      Target := POINTER(Ord(@ColSnip^.FieldInfo) + Display);
      MoveLeft(Source^,Target^,TicEditLen);

      {Initialize editcheck array}
      LegalEditCheck(TicEdit,Tick,EditCheck,ErrNum);
      IF MMTrap1 THEN IF ErrNum <> 0 THEN
         BEGIN
         {Since edit checks should already be valid, this is internal error}
         WriteLn(Bell,'***LegalEditCheck status: ',ErrNum);
         END;

      HighVal := FNilVal;
      LowVal := FNilVal;
      DefVal := FNilVal;
      FldType := Tick;
      Options := [];
      RepType := 0;
      OffSet := 0;
      Size := 0;
      END;

   {Link in the ticket field in as the second field in the list}
   WITH TableData DO
      BEGIN
      InsertColSnips(FirstCol,LastCol,FirstCol,TicId,TicId);
      ColCount := ColCount + 1;
      END;


   {For each column, compute the representation type, size, and offsets}
   Column := TableData.FirstCol;
   NextOffSet := 0;
   FldNumber := 0;
   WHILE (Column <> NullSnip)  DO
      BEGIN
      SetSnipPtr(ColKind,Column);

      {Initialize the field numbers and column orders so they are all in order}
      ColSnip^.FieldNum := FldNumber;
      FldNumber := FldNumber + 1;
      ColSnip^.Order := FldNumber;

      {Initialize the representation type,size and alignment for all new fields. Leave this alone
      if it is an old field, because the current edit check may not correspond to the original
      reptype and size.}
      IF ColSnip^.NewColumn THEN WITH ColSnip^.FieldInfo DO
         BEGIN
         GetRepType(LStatus,FldType,EditCheck,RepType,Size);
         IF MMTrap1 THEN IF LStatus <> 0 THEN
            BEGIN
            {This is an internal error which should not happen}
            WriteLn(Bell,'***Invalid field type to GetRepType');
            END;
         GetOptions(FldType,Options);
         END;

      {Now compute the field offset from beginning of record}
      IF Odd(NextOffset) THEN
         BEGIN {Some fields must be word aligned}
         CASE ColSnip^.FieldInfo.RepType OF

            {The following types are word aligned}
            FTypInt2,
            FTypInt4,
            FTypInt8,
            FTypTick,
            FTypVStr: NextOffset := NextOffset + 1;

            {The following types are byte aligned, so no change in offset}
            FTypNull,
            FTypInt1: ;

            {Any other types are not supported by the list manager}
            OTHERWISE IF MMTrap1 THEN MMFatalErr(LogicErr,PC,'');
            END;
         END; {Odd offset}

      {Now set the offset}
      WITH ColSnip^.FieldInfo DO
         BEGIN
         Offset := NextOffset;
         NextOffset := NextOffset + Size;
         END;

      {Loop to the next column}
      Column := ColSnip^.NextSnip;
      END;

   END; {Procedure PrepColumns}




{$S lmres }

FUNCTION PtrToSnip{HeapPtr:TH): IdType};
   VAR Id:idtype;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   PtrToSnip := ORD(HeapPtr) - ORD(SnipZone);
   END;




{$S lmprint }
PROCEDURE PutPrintPrf{PrintInfo: TPrRec};

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' PutPrintPrf ');

   MMPrintPreference := PrintInfo;
   ListFormChanged := TRUE;
   END;




{$S lmprint }
PROCEDURE PutTableFont{FontId: TlFntId;
                       CellW: INTEGER;
                       CellH: INTEGER;
                       VAR Status: INTEGER};

   CONST PTF = ' PutTableFont';

   VAR ColRange: Range;
       Col: IdType;
       I: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,PTF,' CellW: ',CellW,' CellH: ',CellH);
   Status := 0;

   {Make sure there is enough memory to handle the new font}
   IF CellH < MMFontinfo.CellHeight THEN
      BEGIN {font is smaller, so more rows per screen increases mem requirements}
      IF NOT EnoughMemory(ListTable.ColCount,MMFontinfo.CellHeight) THEN
         BEGIN
         Status := FontMemErr;
         Exit(PutTableFont);
         END;
      END;

   {Adjust table to new cell measurements}
   AdjustTableToFont(CellW,CellH);

   {Adjust all of the column widths}
   WITH ColRange DO
      BEGIN
      RKind := AColRg;
      LoRow := MInfSnip;
      HiRow := PInfSnip;
      END;

   Col := TableData.FirstCol;
   WHILE Col <> NullSnip DO
      BEGIN
      WITH ColRange DO
         BEGIN
         LoCol := Col;
         HiCol := Col;
         END;

      SetSnipPtr(ColKind,Col);
      WITH ColSnip^ DO
         BEGIN
         Col := NextSnip;
         SetSnipWidth(ColRange,( (Width*CellW) DIV MMFontinfo.CellWidth ) );
         END;

      END;


   {If this is not the list, transfer the scaling over now so that it will
   be remembered in the event that the user executes 'undo all edits'. Font
   changes are not undone by such an operation, mainly because it would
   work for the spec tables, but not for the list.}
   IF CurTable <> TList THEN
      BEGIN
      Col := ListTable.FirstCol;
      WHILE Col <> NullSnip DO
         BEGIN
         WITH ColRange DO
            BEGIN
            LoCol := Col;
            HiCol := Col;
            END;

         SetSnipPtr(ColKind,Col);
         WITH ColSnip^ DO
            BEGIN
            Col := NextSnip;
            SetSnipWidth(ColRange,((Width*CellW) DIV MMFontinfo.CellWidth));
            END;

         END;

      {Also transfer over the title width changes}
      WITH TableData DO
         BEGIN
         ListTable.ColTitleHeight := ColTitleHeight;
         ListTable.RowHeight := RowHeight;
         ListTable.RowTitleWidth := RowTitleWidth;
         END;

      END;

   {Make special adjustment to row title width if this is colspecs table}
   IF CurTable = TColSpecs THEN
     BEGIN
     if mmtrap2 then writeln('PutTableFont; SizeRowTitle, CellW : ',SizeRowTitle:8,CellW:8);
     TableData.RowTitleWidth := ((SizeRowTitle + (SizeRowTitle div 3)) * CellW);
     END;

   {Remember the font info}
   WITH MMFontinfo DO
      BEGIN
      Font := FontId;
      CellWidth := CellW;
      CellHeight := CellH;
      END;

   {Remember to write this crap out in the datafile}
   ListFormChanged := TRUE;

   {Since the table is about to be redisplayed, get rid of any unnessary
   snips now so that a call to makespace does not occur in the middle of
   the table rebuild.}
   MMCallingMakeSpace := TRUE;
   I := MakeSpace(SnipZone,0);
   MMCallingMakeSpace := FALSE;

   {All done - someone else is responsible for table redisplay}
   END;


{$S lmopendoc }
PROCEDURE ReadListForm{DBScanId: INTEGER;
                       VAR SnipId: IdType;
                       VAR Status: INTEGER};

   {ReadListForm attempts to read the list form out of the data file label
   records. Status will be set to 0 if there were no problems. It is set to
   some non zero value if problems were encountered. A bad status does not
   mean, however, that no list form information was read - it simply means
   that the form may be truncated. The variable SnipId will be set to NullSnip
   if nothing could be read, and will point to the actual form if it managed
   to read something.

   This code is designed to read potentially damaged list forms. It is part
   of the recovery strategy. Don't modify it until you understand the recovery
   strategy and all the procedures which play a part.}

   LABEL 400,500;

   CONST RLF = ' ReadListForm ';

   VAR LStatus: INTEGER;
       ScanId: INTEGER;
       LabelHdr: LabelEntry;
       LabelRecord: ^LabelEntry;
       MoveFrom: PtrData;
       FormSize: INTEGER;
       FormId: IdType;
       FormPtr: PtrData;
       MoveLen: INTEGER;
       BytesLeft: INTEGER;
       NextAvail: INTEGER;
       Sequence: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,RLF);
   SnipId := NullSnip;
   Status := 0;

   {Make sure the list is current}
   IF MMTrap1 THEN IF CurTable <> TList THEN MMFatalErr(LogicErr,RLF,'');

   {Read the first label of type listform into memory}
   LabelHdr.LType := LstFormCode;
   LFetch(LStatus,DBScanId,Approx,1,@LabelHdr);
   IF LStatus <> NoErr THEN
      BEGIN
      IF MMTrap1 THEN WriteLn(Bell,'***',RLF,'LFetch approx status: ',LStatus);
      Status := LStatus + DBErr;
      GOTO 500;
      END;

   {Make sure this is the first record in the sequence}
   LabelRecord := @PScanTable^[DBScanId]^.PtrCos^;
   IF LabelRecord^.Seq <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***First list label not sequence 0');
      Status := BadLForm;
      GOTO 500;
      END;

   {We found the first list form record}
   IF Trace2MMgr  then WriteLn(MxMgr,RLF,'List Form label 0 fetched');

   {Get the size of the form}
   MoveFrom := POINTER(ORD(LabelRecord) + LabelRecord^.VarFld.Offset);
   MoveLeft(MoveFrom^,FormSize,2);

   {Allocate a snip large enough for form}
   {Make sure form is reasonable size. If GetSnipBlock is modified to
   return an error if there is no memory, then this indication should be
   used instead.}
   IF {(FormSize > 2000) OR} (FormSize < LabelRecord^.VarFld.Size)  THEN
      BEGIN
      Status := BadLForm;
      GOTO 500;
      END;
   GetSnipBlock(FormId,FormSize,LStatus);
   InitSnipPtr(ColKind,FormId);
   FormPtr := @ColSnip^;
   SnipId := FormId;

   {Move in the first chunk of form information}
   MoveLen := LabelRecord^.VarFld.Size;
   MoveLeft(MoveFrom^,FormPtr^,MoveLen);

   {If there are more labels, loop to read them all in}
   BytesLeft := FormSize  - MoveLen;
   NextAvail := MoveLen;
   Sequence := 1;
   WHILE BytesLeft > 0 DO
      BEGIN
      {Fetch the next label}
      LFetch(LStatus,DBScanId,Next,0,Nil);
      IF LStatus <> NoErr THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***',RLF,'LFetch next status: ',LStatus);
         Status := LStatus + DBErr;
         GOTO 400;
         END;
      IF Trace2MMgr  then WriteLn(MxMgr,RLF,'Next label fetched');

      {Make sure sequence number is in order}
      LabelRecord := @PScanTable^[DBScanId]^.PtrCos^;
      IF (LabelRecord^.Seq <> Sequence)  THEN
         BEGIN
         IF MMTrap1 THEN WriteLn(Bell,'***',RLF,'Label out of sequence: ',LabelRecord^.Seq);
         Status := BadLForm;
         GOTO 400;
         END;
      Sequence := Sequence + 1;

      {Make sure length is ok}
      MoveLen := LabelRecord^.VarFld.Size;
      IF (MoveLen > BytesLeft) OR (MoveLen < 0) THEN
         BEGIN
         IF MMTrap1 THEN WriteLn('***Bad form length: ',Formsize);
         Status := BadLForm;
400:     FormSize := FormSize - BytesLeft;
         MoveLeft(FormSize,FormPtr^,2); {Update size to what was actually read.}
         GOTO 500;
         END;

      {Move information from label into snip block}
      MoveFrom := POINTER(ORD(LabelRecord) + LabelRecord^.VarFld.Offset);
      MoveLeft(MoveFrom^,FormPtr^[NextAvail],MoveLen);
      BytesLeft := BytesLeft - MoveLen;
      NextAvail := NextAvail + MoveLen;
      END;


500:{Force write of new list form if there were problems.}
   IF Status <> 0 THEN ListFormChanged := TRUE;
   END;




{$S lmres }
PROCEDURE reCalcOffsets{rsnip:ptrrowsnip;
                        colsnipchg: idtype;
                        initoffset:integer;
                        delta:integer};
   VAR  snip: IdType;
        ptrV: ptrVFld;
        roffset: integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,' ReCalcOffsets ');
   {All offsets greater than the field being modified must be adjusted. Those fields which have
   offsets which point at the same location as the field being modified fall into two classes:

   1) Non-zero length fields. Since this is not the same field as the one being modified, it
      implies that the modified field was null and is being added, since otherwise you would have
      two fields pointing to the same location. It is alright for more than one offset to point to
      the same location, so long as only one field is non-zero.

   2) Zero length fields. The offsets of zero length fields must point to a field boundary in the
      record. It makes no difference which field boundary. These offsets should not be adjusted, since
      if you are merely adjusting the modified field, it would cause the pointer to be moved off of
      a field boundary into the middle of the modified field. This would occur when the size of the
      modified field was increased, and was in fact the cause of bug #195 and others which resulted
      in bad record pointers. Not adjusting such pointers when a new field is added does no harm -
      it no longer points to the old field boundary, but it now points to a new field boundary which
      is OK. }

   IF Delta <> 0 THEN
      BEGIN {Only need to adjust offsets if field size changed.}
      snip := TableData.firstcol;
      While snip <> nullsnip do
         BEGIN
         SetSnipPtr(colkind,snip);
         IF VarField(colsnip) then
            BEGIN
            ptrv := POINTER(ORD(rsnip) + rsnip^.data + colsnip^.fieldinfo.offset);
            IF (colsnipchg <> colsnip^.snipid) THEN
               BEGIN
               roffset := ptrv^.offset;
               IF (roffset > initoffset) {All larger offsets must be adjusted}
               OR ((roffset = initoffset) AND (Ptrv^.Size > 0)) {Non null sizes, equal offsets}
               THEN ptrv^.offset := roffset + delta; {Add delta to offset}
               END;
            END; {Variable Field}
         snip := colsnip^.nextsnip;
         END; {Snip <> NullSnip}
      END; {Delta <> 0}
   END;


{$S lmcolspec }
PROCEDURE RecalcSortOrders{ColId: IdType;
                           VAR NewOrder: INTEGER};

   CONST RCSO = ' RecalcSortOrders';

   TYPE OrderChanges = (AddKey,DeleteKey,LowerOrder,HigherOrder,Nop);

   VAR OldOrder: INTEGER;
       OrderCase: OrderChanges;
       KeyCount: INTEGER;
       Column: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,RCSO);
   KeyCount := 0;
   SetSnipPtr(ColKind,ColId);
   OldOrder := ColSnip^.SortOrder;

   {Figure out the case}
   IF (OldOrder <> 0) AND (NewOrder = 0)  THEN OrderCase := DeleteKey
   ELSE IF (OldOrder = 0) AND (NewOrder <> 0) THEN OrderCase := AddKey
   ELSE IF OldOrder < NewOrder THEN OrderCase := HigherOrder
   ELSE IF OldOrder > NewOrder THEN OrderCase := LowerOrder
   ELSE OrderCase := Nop;

   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^ DO
         BEGIN
         CASE OrderCase OF

 DeleteKey: BEGIN
            {All orders greater than OldOrder are decremented by one. OldOrder is
            set to zero}
            IF SortOrder > OldOrder THEN SortOrder := SortOrder - 1
            ELSE IF SortOrder = OldOrder THEN SortOrder := 0;
            END;

    AddKey: BEGIN
            {All orders greater than or equal to neworder are incremented by one.
            The order of the specified column is set to neworder. If neworder is
            larger than the number of sort keys, it is set to the number of sort
            keys.}
            IF SortOrder >= NewOrder THEN SortOrder:= SortOrder + 1
            ELSE IF ColId = Column THEN SortOrder := NewOrder;
            END;

HigherOrder:BEGIN
            {All orders greater than OldOrder and less than or equal to neworder
            are decremented by one. If neworder is larger than the number of sort
            keys, it is set to the number of sort keys.}
            IF (SortOrder > OldOrder) AND (SortOrder <= NewOrder)
            THEN SortOrder := SortOrder - 1
            ELSE IF SortOrder = OldOrder THEN SortOrder := NewOrder;
            END;

LowerOrder: BEGIN
            {All orders greater than or equal to neworder, and less than oldorder
            are incremented by one.}
            IF (SortOrder >= NewOrder) AND (SortOrder < OldOrder)
            THEN SortOrder := SortOrder + 1
            ELSE IF SortOrder = OldOrder THEN SortOrder := NewOrder;
            END;

       Nop: BEGIN
            END;

            END; {Case}
         END;

      IF ColSnip^.SortOrder <> 0 THEN KeyCount := KeyCount + 1;
      Column := ColSnip^.NextSnip;
      END;

   {Make sure that the new order is not greater than the total number of keys}
   IF NewOrder > KeyCount THEN
      BEGIN
      SetSnipPtr(ColKind,ColId);
      ColSnip^.SortOrder := KeyCount;
      NewOrder := KeyCount;
      END;

   {Update the sort key count}
   CSKeys := KeyCount;
   END;



{$S lmrecov }
PROCEDURE RecoverList{LFName: PathName;
                      VAR Status: INTEGER};

   LABEL 50,100;

   CONST LR = ' RecoverList ';

   VAR CurPrefix: PathName;
       NewPrefix: PathName;
       RedundantFile: PathName;
       NullPrefix: PathName;
       SusFile: PathName;
       DifFile: PathName;
       DataFile: E_Name;
       NewFile: E_Name;
       RecFile: E_Name;
       Warnings: elemset;
       I: INTEGER;
       LStatus: INTEGER;
       ErrStatus: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,LR,LFName);

   {Delete the suspend file, if any}
   SusFile := ConCat(LFName,SuspendSuffix);
   IF Trace2MMgr THEN WriteLn('Deleting suspend file: ',SusFile);
   Kill_Secure(LStatus,SusFile,DocPassWord);
  {Kill_Object(LStatus,SusFile);}
   IF MMTrap1 THEN IF LStatus > 0 THEN WriteLn('***SusFile Kill_Object status: ',LStatus);

   {Delete the differential file, if any}
   DifFile := ConCat(LFName,DiffSuffix);
   IF Trace2MMgr THEN WriteLn('Deleting Differential file: ',DifFile);
   Kill_Secure(LStatus,DifFile,DocPassWord);
  {Kill_Object(LStatus,DifFile);}
   IF MMTrap1 THEN IF LStatus > 0 THEN WriteLn('***DifFile Kill_Object status: ',LStatus);


   {Prepare to call the recovery procedure}
   {First set the old and new prefixes}
   CurPrefix := '';
   NewPrefix := '';
   DataFile := LFName;
   FOR I := Length(DataFile) DOWNTO 1 DO
      BEGIN
      IF LFName[I] = '-' THEN
         BEGIN {Set prefix}
         CurPreFix := Copy(LFName,1,I);
         NewPreFix := CurPreFix;
         Delete(DataFile,1,I);
         GOTO 50;
         END;
      END;

50: NewFile := Concat(DataFile,NewSuffix); {Set new file name}
    RecFile := Concat(DataFile,RedunSuffix); {Set recovery file name}


   {Call the recovery procedure}
   IF Trace2MMgr THEN WriteLn('Calling FileRecover.....');
   Sched_Class(ErrStatus,FALSE);
   FileRecover(Status,Warnings,@CurPreFix,@NewPreFix,@DataFile,
   @NewFile,@RecFile,LegalEditCheck,MakeIndex,MarksRevenge,ToolMarketCode);
   Sched_Class(ErrStatus,TRUE);

   {Recovery sets the prefix, so clear it.}
   NullPrefix := '';
   SetPreFix(@NullPrefix);

   {Now check status}
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***FileRecover status: ',Status);
      GOTO 100;
      END;

   {The user is not currently notified of warnings. If it works at all,
   fine - he probably wouldn't know what to do anyway.}

   {Now delete the old file}
   IF Trace2MMGr THEN WriteLn('Deleting old file: ',LFName);
   Kill_Secure(LStatus,LFName,DocPassWord);
  {Kill_Object(Status,LFName);}
   IF Status > 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***Kill_Object status: ',Status);
      GOTO 100;
      END;

   {Rename the new file to the old name}
   NewPreFix := Concat(NewPrefix,NewFile);
   IF Trace2MMgr THEN Writeln('Renaming new file: ',NewPrefix,' to ',DataFile);
   Rename_Secure(Status,NewPrefix,DataFile,DocPassWord);
  {Rename_Entry(Status,NewPrefix,DataFile);}
   IF Status <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn(Bell,'***Rename_Entry status: ',Status);
      GOTO 100;
      END;

   {Delete the old redundant file}
   RedundantFile := ConCat(LFName,RedunSuffix);
   IF Trace2MMgr THEN WriteLn('Deleting old redundant file: ',RedundantFile);
   Kill_Secure(LStatus,RedundantFile,DocPassWord);
  {Kill_Object(LStatus,RedundantFile);}
   IF LStatus > 0 THEN
      BEGIN
      {Note - failure to delete old redundant file not a recovery failure.}
      IF MMTrap1 THEN WriteLn('***Kill_Object status: ',LStatus);
      END;

   {Make a new redundant file}
   IF Trace2MMgr THEN WriteLn('Cloning file: ',LFName,' to ',RedundantFile);
   CloneFile(LStatus,@LFName,@RedundantFile,TRUE);
   IF LStatus <> 0 THEN
      BEGIN
      {Note - failure to clone not a  recovery failure}
      IF MMTrap1 THEN WriteLn('***CloneFile status: ',LStatus);
      END;

   100:END;


{$S lmrestruct }
PROCEDURE ReCreateListFile{VAR Status: INTEGER};

   LABEL 100,200,300,500,600,700;

   CONST RCLF = ' ReCreateListFile ';

   VAR Row: IdType;
       Col: IdType;
       StartRg: Range;
       LStatus: INTEGER;
       Column: IdType;
       NextCol: IdType;
       FormId: IdType;
       FormPtr: PtrData;
       NewFileName: PathName;
       FileEName: E_Name;
       NewScanId: INTEGER;
       OldScanId: INTEGER;
       SourcePtr: PtrData;
       TargetPtr: PtrData;
       BlankPtr: PtrData;
       SBufferId: IdType;
       TBufferId: IdType;
       BlankId: IdType;
       RedundantFile: PathName;
       I: INTEGER;
       NextOffset: INTEGER;
       TargetCol: IdType;
       TVFieldPtr: ^VFld;
       SVFieldPtr: ^VFld;
       FieldSize: INTEGER;
       TFieldPtr: PtrData;
       SFieldPtr: PtrData;
       Offender: INTEGER;
       NewScanOpen: BOOLEAN;
       OldScanOpen: BOOLEAN;
       NewFileCreate: BOOLEAN;
       RecSize: INTEGER;
       NewCols: BOOLEAN;
       TabRec: TableRecord;
       ErrStatus: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF MMTrap1 THEN WriteLn(MxMgr,RCLF);
   NewScanOpen := FALSE;
   OldScanOpen := FALSE;
   FormId := NullSnip;
   SBufferId := NullSnip;
   TBufferId := NullSnip;
   BlankId := NullSnip;
   NewFileCreated := FALSE;

   {Make sure there is at least one old and still visible, or one nonblank new column}
   Column := TableData.FirstCol;
   IF Column = NullSnip THEN GOTO 100; {No columns left, old or new}
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      NextCol := ColSnip^.NextSnip;
      IF (ColSnip^.NewColumn AND CellBlank(MInfSnip,Column))  {New but blank column}
         OR (NOT ColSnip^.Visible) THEN                       {Old but cut column}
         BEGIN
         Column := NextCol;
         IF NextCol = NullSnip THEN
 100:       BEGIN {Nothing left but blank new columns}
            IF MMTrap1 THEN WriteLn('***No old or nonblank new columns are left');
            Status := NoColErr;
            GOTO 600;
            END;
         END
      ELSE Column := NullSnip; {Found either an old remaining or nonblank column, so stop the loop}
      END; {Column <> NullSnip}

   {NOTE!! One columns have been removed from the column list, it is no longer possible to use the
   original column snips to display the colspec table. The column snips must be regenerated and the
   table rebuilt. This is because the removal of a column snip removes the field information necessary
   to maintain the row snip structure.}

   {Remove any cut or deleted columns}
   IF ColumnsCut THEN RelScrap; {This puts cut columns on deleted list}
   IF ColumnsDeleted THEN WITH TableData DO
      BEGIN
      IF Trace2MMgr THEN WriteLn('Cutting out deleted columns');
      CutColSnips(FirstCol,LastCol,DelCol.FirstCol,DelCol.LastCol);
      ReleaseSnips(ColKind,DelCol.FirstCol);
      ColumnsDeleted := FALSE;
      ReOrderColumns(FirstCol,ColCount);
      END;

   {Any new blank columns should now be removed.}
   NewCols := FALSE;
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      NextCol := ColSnip^.NextSnip;
      IF ColSnip^.NewColumn THEN
         BEGIN
         IF CellBlank(MInfSnip,Column) THEN
            BEGIN
            WITH TableData DO
               BEGIN
               IF Trace2MMgr THEN WriteLn('Removing blank column');
               CutColSnips(FirstCol,LastCol,Column,Column);
               FreSnipBlock(Column);
               ColCount := ColCount - 1;
               END;
            END
         ELSE NewCols := TRUE; {Remember there is a nonblank new column}
         END;
      Column := NextCol;
      END;

   {At this point, all new blank columns have been removed. If there are
   any new columns left, they are nonblank and this would indicate that
   the file requires restructuring. Furthermore, any columns which were
   cut have been removed from the colspec column list. The only old columns
   remaining in the list were therefore not cut. If there are the same
   number of old columns left as in the original list (taking the ticket
   field into account) then this also indicates that no restructuring
   would be required.}

   IF NOT NewCols THEN
      BEGIN
      {There are no new columns. Check to see if there are any
      old columns which are missing. If not, there is no need to restructure}
      IF TableData.ColCount = CopyListColumns.ColCount - 1 THEN
         BEGIN
         {All of the old columns are still there. There is still a chance
         that all the user wants to do is to change the default sort order.
         This would be indicated by the first column no longer being field 0.
         However, since the column order could have been changed quite some
         time ago, the user might not really want to do this. If this is
         the case, put up a cautionalert to confirm.

         {Get field number of first column}
         SetSnipPtr(ColKind,TableData.FirstCol); {Must exist and be visible}
         SetSnipPtr(ColKind,ColSnip^.ListSnip); {Must be old column: has list snip}
         IF ColSnip^.FieldNum = 0 THEN
200:        BEGIN
            {Restructuring is not required}

            {Update the list snips from the colspec snips}
            IF TraceMMgr THEN WriteLn('Calling ChangeColSpecs');
            ChangeColSpecs(LStatus);
            {There should be no errors from ChangeColSpecs}
            if mmtrap1 then IF LStatus <> 0 THEN
               WriteLn(Bell,'***',RCLF,'Errors status from changecolspecs: ',LStatus);

            {Get rid of the list copy snips and mark copy gone.}
            WITH CopyListColumns DO
               BEGIN
               ReleaseSnips(ColKind,FirstCol);
               FirstCol := NullSnip; {This flags copy gone}
               END;

            {Turn off redefining flag}
            RedefiningTable := FALSE;

            {Exit}
            Status := 0;
            Exit(ReCreateListFile);
            END;

         {The only change has been the default sort order. Confirm with user.}
         IF (askAlert(LMAlerts,SortConf) = 1) THEN GOTO 200;
         END;

      END; {Not NewCols}


   {Ask user for confirmation to restructure}
   IF NOT CautionAlert(LMAlerts,RestConf) THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('Calling UndoTableEdits');
      UndoTableEdits(Status);
      GOTO 200;
      END;

   {Update the list snips from the colspec snips}
   IF TraceMMgr THEN WriteLn('Calling ChangeColSpecs');
   ChangeColSpecs(LStatus);
   {There should be no errors from ChangeColSpecs}
   IF mmtrap1 then IF LStatus <> 0 THEN
    WriteLn(Bell,'***',RCLF,'Errors status from changecolspecs: ',LStatus);

   {Switch list into foreground}
   SwitchToList;

   {Put up a wait alert}
   WaitAlert(LMAlerts,RestWait);

   {Get rid of the ticket column}
   Column := TableData.FirstCol;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      IF ColSnip^.FieldInfo.FldType = Tick THEN
         BEGIN
         WITH TableData DO
            BEGIN
            CutColSnips(FirstCol,LastCol,Column,Column);
            FreSnipBlock(Column);
            ColCount := ColCount - 1;
            END;
         Column := NullSnip;
         END

      ELSE BEGIN
           Column := ColSnip^.NextSnip;
           IF MMTrap1 THEN IF Column = NullSnip THEN
            WriteLn(Bell,'***Failed to find ticket snip');
           END;
      END;


   {Prepare the column snips for form generation. This involves creating a
   ticket field and linking it in as the second column. Then the field
   representation types, offsets. options, and sizes are filled into the
   fieldinfo record of the column snip.}
   IF TraceMMgr THEN WriteLn('Calling PrepColumns');
   PrepColumns;

   {Create the schema form for the list snips}
   IF TraceMMgr THEN WriteLn('Calling CreateSchemaForm');
   CreateSchemaForm(FormId);
   InitSnipPtr(ColKind,FormId);
   FormPtr := @ColSnip^;

   {Destroy the file if it is already there}
   NewFileName := ConCat(FilePName,NewSuffix);
   IF TraceMMgr THEN WriteLn('Calling Kill_Object on new file name');
   Kill_Secure(LStatus,NewFileName,DocPassWord);
  {Kill_Object(LStatus,NewFileName);}
   IF MMTrap1 THEN IF (LStatus > 0) AND (LStatus <> 894) THEN
   WriteLn(Bell,'***',NewFileName,' Kill_Object status: ',LStatus);

   {Now create the new data file}
   IF TraceMMgr THEN Writeln('Calling MakeFormFile');
   MakeFormFile(LStatus,FormPtr,@NewFileName,TRUE);
   IF LStatus <> 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn('***MakeFormFile status: ',LStatus);
      CASE LStatus OF
         {Check for enough disc space}
         NoRoom,
         {Make_File} 854,855: Status := RestNoDisc;

         {File inconsistency or io errors}
         IOErr, Inconsistent,
         {Make_File,Lookup,Close_Object} 802,835,848,849,
         {Open} 871,
         {Info} 1190,
         {Close_Object} 610: Status := FileErr;

         OTHERWISE
            BEGIN
            {600 range means inconsistent file system}
            IF (LStatus >= 600) AND (LStatus <= 699) THEN Status := FileErr
            {All others are internal}
            ELSE Status := IntErr;
            END;
         END; {Case}

      GOTO 600;
      END; {LStatus <> 0}

   NewFileCreated := TRUE;

   {Release the form used to create the file}
   IF Trace2MMgr THEN WriteLn('Calling FreSnipBlock on form');
   FreSnipBlock(FormId);
   FormId := NullSnip;

   {Open a scan on the New file}
   IF TraceMMgr THEN WriteLn('Calling OpenScan on new file');
   OpenScan(LStatus,@NewFileName,@NewFileName,NewScanId,Update);
   IF LStatus <> 0 THEN
300:  BEGIN
      IF MMTrap1 THEN WriteLn('***File ',NewFileName,' OpenScan status: ',LStatus);

      CASE LStatus OF
         {Errors relating to available memory}
         {Open} 872,947,
         {OpenScan} NoMem: Status := RestNoMem;

         {All other errors are considered to be internal}
         OTHERWISE Status := IntErr;
         END; {Case}

      GOTO 600;
      END; {LStatus <> 0}
   NewScanOpen := TRUE;


   {Open a scan on the old file}
   IF TraceMMgr THEN WriteLn('Calling OpenScan on old file');
   OpenScan(LStatus,@FilePName,@FilePName,OldScanId,ReadOnly);
   IF LStatus <> 0 THEN GOTO 300;
   OldScanOpen := TRUE;


   {Create a block for a blank target record.}
   RecSize := GetRecSize;
   GetSnipBlock(BlankId,RecSize,LStatus);

   {Also create blocks to contain the source and target record buffers.
   These are sufficiently large not to worry about expansion, even if
   the target record grows larger than the max record size.}
   GetSnipBlock(SBufferId,1500,LStatus);
   GetSnipBlock(TBufferId,1500,LStatus);


   {Now initialize the pointers to the blocks. Must wait until after all
   of the allocates so that the blocks will not move.}
   InitSnipPtr(ColKind,BlankId);
   BlankPtr := @ColSnip^;
   BlankRecord(BlankPtr);

   InitSnipPtr(ColKind,SBufferId);
   SourcePtr := @ColSnip^;

   InitSnipPtr(ColKind,TBufferId);
   TargetPtr := @ColSnip^;


   {Position the old scan at the first record}
   IF TraceMMgr THEN WriteLn('Calling EFetch first');
   EFetch(LStatus,OldScanId,First,0,SourcePtr);
   IF LStatus <> EOS THEN
      BEGIN
      if mmtrap1 then WriteLn('***EFetch first status: ',LStatus);
      CASE LStatus OF
         InConsistent,
         IOErr: Status := FileErr;
         OTHERWISE Status := IntErr;
         END;
      GOTO 600;
      END;


   {Loop for each record in the old data file}
   WHILE TRUE DO
      BEGIN
      {Fetch the old record}
      IF Trace2MMgr THEN WriteLn('Calling EFetch next');
      EFetch(LStatus,OldScanId,Next,0,SourcePtr);
      {Check for end of scan, which means last record finished.}
      IF LStatus = EOS THEN GOTO 500;
      IF LStatus <> 0 THEN
         BEGIN
         if mmtrap1 then WriteLn('***EFetch next status: ',LStatus);
         CASE LStatus OF
            InConsistent,
            IOErr: Status := FileErr;
            OTHERWISE Status := IntErr;
            END;
         GOTO 600;
         END;


      {Copy old record into the source buffer}
      IF Trace2MMgr THEN WriteLn('Copying record into source buffer');
      WITH PScanTable^[OldScanId]^ DO
         BEGIN
         MoveLeft(PtrCOS^,SourcePtr^,COSSize);
         END;

      {Copy blank record into the target buffer}
      NextOffSet := RecSize;
      MoveLeft(BlankPtr^,TargetPtr^,RecSize);


      {For each new column, transfer the old data into the new row snip}
      IF Trace2MMgr THEN WriteLn('Transferring source data to target record');
      TargetCol := TableData.FirstCol;
      WHILE TargetCol <> NullSnip DO
         BEGIN
         SetSnipPtr(ColKind,TargetCol);
         NextCol := ColSnip^.NextSnip;
         IF NOT ColSnip^.NewColumn THEN
            BEGIN
            {This column exists in the old file, so transfer over the data.}
            IF VarField(ColSnip) THEN
               BEGIN {Variable field}
               {Set pointer to variable field}
               TVFieldPtr := POINTER(Ord(TargetPtr) + ColSnip^.FieldInfo.Offset);

               {Point to source field}
               SetSnipPtr(ColKind,ColSnip^.MiscId);
               SVFieldPtr := POINTER(Ord(SourcePtr) + ColSnip^.FieldInfo.OffSet);

               {Move field into target}
               FieldSize := SVFieldPtr^.Size;
               MoveLeft(SourcePtr^[SVFieldPtr^.OffSet],TargetPtr^[NextOffset],FieldSize);

               {Update counts and offsets}
               TVFieldPtr^.Offset := NextOffset;
               TVFieldPtr^.Size := FieldSize;
               NextOffset := NextOffset + FieldSize;
               END

            ELSE BEGIN {Fixed field}
                 {Point to target field}
                 TFieldPtr := Pointer(Ord(TargetPtr) + ColSnip^.FieldInfo.Offset);

                 {Point to source field}
                 SetSnipPtr(ColKind,ColSnip^.MiscId);
                 SFieldPtr := POINTER(Ord(SourcePtr) + ColSnip^.FieldInfo.OffSet);
                 FieldSize := ColSnip^.FieldInfo.Size;

                 {Move into target field}
                 MoveLeft(SFieldPtr^,TFieldPtr^,FieldSize);
                 END;

            END;

         TargetCol := NextCol;
         END;

      {For all variable length fields which were not filled in,
      set initial offset to the end of the variable length data.}
      TargetCol := TableData.FirstCol;
      WHILE TargetCol <> NullSnip DO
         BEGIN
         SetSnipPtr(ColKind,TargetCol);
         IF VarField(ColSnip) THEN
            BEGIN
            TVFieldPtr := POINTER(Ord(TargetPtr) + ColSnip^.FieldInfo.Offset);
            IF TVFieldPtr^.Size = 0 THEN TVFieldPtr^.OffSet := NextOffset;
            END;
         TargetCol := ColSnip^.NextSnip;
         END;

      {Make sure that the target record size is not too big}
      IF Odd(NextOffset) THEN NextOffset := NextOffset + 1;
      IF NextOffSet > (MaxDBRecSize - SizeOf(PreAmble)) THEN
         BEGIN {Record size too big}
         {Give the user the option of ignoring the record,
         or cancelling the restructuring operation.}
         IF (askAlert(LMAlerts,RestTooBig) = 1) THEN
            BEGIN
            {User wants to cancel}
            Status := RestTooBig;
            GOTO 700;
            END

         ELSE WaitAlert(LMAlerts,RestWait); {Put wait alert back up}
         END {Record size too big}


      ELSE BEGIN {Record size ok}
           {Insert the record into the new file}
           IF Trace2MMgr THEN WriteLn('Calling EInsert on target file');
           Sched_Class(ErrStatus,FALSE);
           EInsert(LStatus,Offender,NewScanId,TargetPtr,NextOffset,TRUE);
           Sched_Class(ErrStatus,TRUE);
           IF LStatus <> 0 THEN
              BEGIN
              if mmtrap1 then WRiteLn('***EInsert status: ',LStatus);
              CASE LStatus OF
                 IOErr: Status := FileErr;
                 NoRoom: Status := RestNoDisc;
                 OTHERWISE Status := IntErr;
                 END;
              GOTO 600;
              END;
           END; {Record size ok}

      {Go get the next old record}
      END;


500: {Close the scan on the new file}
   IF TraceMMgr THEN WRiteLn('Calling CloseScan on new file');
   CloseScan(LStatus,NewScanId);
   {Failure to close not considered a failure}
   IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn(Bell,'***New file closescan status: ',LStatus);

   {Close the scan on the old file}
   IF TraceMMgr THEN WRiteLn('Calling CloseScan on old file');
   CloseScan(LStatus,OldScanId);
   IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn(Bell,'***Old file closescan status: ',LStatus);

   {Generate a list specific form for the new file}
   IF TraceMMgr THEN WriteLn('Calling GenListForm');
   GenListForm(FormId);

   {Now write the list form out to the new file}
   IF TraceMMgr THEN WriteLn('Calling WritListForm');
   WritListForm(NewFileName,FormId);
   FormId := NullSnip;

   {Don't bother releasing the snips for the blank record, source and target
   buffers, because we are about to call CloseDocument which will get rid of
   the entire heap anyway. Also true of the form snip.}

   {Close old document. Set flags so that we don't go through the overhead
   of writing new schema information, since the files will be deleted anyway.
   Set Curtable to TNone so that CloseDocument will not complain.}
   SchemaChanged := FALSE;
   ListFormChanged := FALSE;
   CurTable := TNone;
   IF TraceMMgr THEN WriteLn('Calling CloseDocument');
   CloseDocument;

   {Now delete all files under the old name. This includes the data file,
   the differential file, the suspend file, and the redundant file.}
   IF TraceMMgr THEN WriteLn('Calling DeleteDocFiles');
   DeleteDocFiles(FilePName);

   {Figure out the entry name for the old file, to use in call to Rename_Entry}
   FileEName := FilePName;
   FOR I := Length(FileEName) DOWNTO 1 DO
      BEGIN
      IF FileEName[I] = '-' THEN
         BEGIN
         Delete(FileEName,1,I);
         I := 0;
         END;
      END;

   {Rename the new file to the old name}
   IF TraceMMgr THEN Writeln('Renaming new file: ',NewFileName,' to ',FileEName);
   Rename_Secure(LStatus,NewFileName,FileEName,DocPassWord);
  {Rename_Entry(LStatus,NewFileName,FileEName);}
   {Ignore an error at this point. If the file won't rename, we are screwed.
   However, we have one more chance, since OpenDocument will look for this
   file if it cannot find the old one.}
   IF MMTrap1 THEN IF Status <> 0 THEN WriteLn(Bell,'***Rename_Entry status: ',LStatus);

   {Make a new redundant file}
   RedundantFile := ConCat(FilePName,RedunSuffix);
   IF TraceMMgr THEN WriteLn('Cloning file: ',FilePName,' to ',RedundantFile);
   CloneFile(LStatus,@FilePName,@RedundantFile,TRUE);
   {Note - failure to clone not a fatal failure}
   IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn('***CloneFile status: ',LStatus);

   {Take down the wait alert}
   EndWaitAlert;

   {All done}
   Status := 0;
   Exit(RecreateListFile);


600: {Put up the error alert}
   IF CautionAlert(LMAlerts,Status) THEN;

700: {Come to this error label if cautionalert already put up}

   {Close down scans if necessary. Don't check for errors}
   IF NewScanOpen THEN
      BEGIN
      CloseScan(LStatus,NewScanId);
      IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn(Bell,'***CloseScan status: ',LStatus);
      END;

   IF OldScanOpen THEN
      BEGIN
      CloseScan(LStatus,OldScanId);
      IF MMTrap1 THEN IF LStatus <> 0 THEN WriteLn(Bell,'***CloseScan status: ',LStatus);
      END;

   {Get rid of the snips if necessary}
   IF FormId <> NullSnip THEN FreSnipBlock(FormId);
   IF TBufferId <> NullSnip THEN FreSnipBlock(TBufferId);
   IF SBufferId <> NullSnip THEN FreSnipBlock(SBufferId);

   {Get rid of new file if necessary}
   IF NewFileCreated THEN
      BEGIN
      Kill_Secure(LStatus,NewFileName,DocPassWord);
     {Kill_Object(LStatus,NewFileName);}
      IF MMTrap1 THEN IF LStatus > 0 THEN WriteLn(Bell,'***Kill_Object status: ',LStatus);
      END;

   {If we have already switched the new snips into the list, switch it back into the background.
   Then use the new snips to load up the colspec table again. This will give a close approximation
   to the state of the add/delete table prior to attempting the restructure.}
   IF CurTable = TList THEN
      BEGIN
      SwitchFromList;
      LoadColSpecs(TabRec);
      END;

   {Rebuild the table again and repaint. This has to be done because the new add/delete table
   is not quite the same as the old, since blank columns have been removed, and all the snipids
   are different.}
   GetSnipId(RowKind,MMFirst,0,Row,Row);
   GetSnipId(ColKind,MMFirst,0,Col,Col);
   SetRg(StartRg,A1CellRg,Row,Col,Row,Col);
   ReBldTbl(StartRg);
   TmShoNewTbl;

   END;




{$S lmlist }
PROCEDURE RelCrgList;

   VAR row: IDType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,' RelCrgList ');
   row := curRgSNip;
   while row <> nullsnip do
      begin
      setsnipPtr(rowkind,row);
      with tabledata do
        begin
        IF row = firstrow then firstrow := nullsnip;
        IF row = lastrow then lastrow := nullsnip;
        end;
      row := rowsnip^.nextsnip;
      fresnipblock(rowsnip^.snipid);
      end;
   CurRgList := False;


   END;

{$S lmres }
PROCEDURE ReleaseColSnips;

   {This procedure releases all column snips on the linked list pointed
   to by TableData.FirstCol. }

   CONST RelCSnip = ' ReleaseColSnips';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Trace}
   IF TraceMMGR then WriteLn(MxMgr,RelCSnip);

   ReleaseSnips(ColKind,TableData.FirstCol);

   {Now initialize the list pointers}
   WITH TableData DO
      BEGIN
      FirstCol := NullSnip;
      LastCol := NullSnip;
      ColCount := 0;
      END;

   END;



{$S lmres }
PROCEDURE ReleaseRowSnips;

   {This procedure releases all row snips on the linked list pointed
   to by TableData.TopRow. }

   CONST RelRSnip = ' ReleaseRowSnips';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Trace}
   IF TraceMMGR then WriteLn(MxMgr,RelRSnip);

   ReleaseSnips(RowKind,TableData.TopRow);

   {Now initialize the list pointers}
   WITH TableData DO
      BEGIN
      TopRow := NullSnip;
      BottomRow := NullSnip;
      FirstRow := NullSnip;
      LastRow := NullSnip;
      END;

   END;



{$S lmres }
PROCEDURE ReleaseSnips{Snip: SnipKind;
                       SnipId: IdType};

   CONST RS = ' ReleaseSnips';

   VAR Next: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,RS);
   CASE Snip OF

      RowKind: WHILE SnipId <> NullSnip DO
                  BEGIN
                  SetSnipPtr(RowKind,SnipId);
                  Next := RowSnip^.NextSnip;
                  FreSnipBlock(SnipId);
                  SnipId := Next;
                  END;

      ColKind: WHILE SnipId <> NullSnip DO
                  BEGIN
                  SetSnipPtr(ColKind,SnipId);
                  Next := ColSnip^.NextSnip;
                  FreSnipBlock(SnipId);
                  SnipId := Next;
                  END;

      END;
   END;


{$S lmres }
PROCEDURE RelScrap;

   CONST RS = ' RelScrap ';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,RS);

   {This procedure currently releases columns in the scrap.}

   {Release any columns. If there are columns and in tcolspecs, this means they are definitly
   to be deleted. Since they must have been cut, they are already invisible.
   Move them to the beginning of the list so that they will not be accessible
   to the user, but will still allow their fields to be updated when the
   rows are modified. Also set pointers to the range of deleted columns.
   This way, if AddCol is called and there are deleted columns, it can
   simply use one of the fields already in the row records.}
   IF (ColumnsCut) and (CurTable = TColspecs) THEN WITH TableData DO
      BEGIN
      {Cut out of their current position}
      CutColSnips(FirstCol,LastCol,CutCol.FirstCol,CutCol.LastCol);

      {Now paste into the front of the column list}
      InsertColSnips(FirstCol,LastCol,NullSnip,CutCol.FirstCol,CutCol.LastCol);

      {Reorder the column snips}
      ReOrderColumns(FirstCol,ColCount);

      {Set pointers to deleted range}
      IF ColumnsDeleted THEN DelCol.FirstCol := CutCol.FirstCol
      ELSE BEGIN
           DelCol := CutCol;
           ColumnsDeleted := TRUE;
           END;

      {Remember that there are no more columns cut in scrap}
      ColumnsCut := FALSE;
      END {With tabledata}
    ELSE ColumnsCut := FALSE;

  END;


{$S lmcolspec }
PROCEDURE ReOrderColumns{VAR FirstCol: IdType;
                         VAR ColCount: INTEGER};

   {This procedure reorders the columns by setting the order field.
   It also sets the column count, since this is no trouble.}

   CONST ROC = ' ReOrderColumns ';

   VAR Column: IdType;
       I: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,ROC);
   Column := FirstCol;
   I := 0;
   WHILE Column <> NullSnip DO
      BEGIN
      SetSnipPtr(ColKind,Column);
      WITH ColSnip^ DO
         BEGIN
         I := I + 1;
         Order := I;
         Column := NextSnip;
         END;
      END;
   ColCount := I;
   END;

(*
{$S lmres2}
{u}
Procedure RgInScrap{(var rg:range)};

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

rg := MMScrapRg;
with rg do
  begin
  if (lorow = minfsnip) or (lorow = pinfsnip)             {change the lorow and locol snipids}
  then Getsnipid(rowkind,mmfirst,0,lorow,lorow);
  if (locol = minfsnip) or (locol = pinfsnip)
  then Getsnipid(colkind,mmfirst,0,locol,locol);
  end;

end;
*)

(*
{$S lmlist }
PROCEDURE RowError{CurRange: Range};

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,'RowError');
      IF (CurRange.rkind = aRowRg ) OR (CurRange.Rkind = a1CellRg) THEN
      BEGIN
      SetSnipPtr(rowkind,CurRange.lorow);
      IF RowSnip^.errorcode = noerr then
         BEGIN
         GetAlert(LMALERTS,ListofErr,@ListTitle);
         PromptString := ListTitle;
         END
      ELSE IF RowSnip^.errorcode = dupl_error then
            GetAlert(LMAlerts,RowDuplicate,@Promptstring)
      ELSE IF RowSnip^.errorcode = just_fyi then
            GetAlert(LMAlerts,AlreadyinList,@Promptstring)
      ELSE IF RowSnip^.errorcode = null_error then
            GetAlert(LMAlerts,Fieldsneeded,@Promptstring)
      END
   ELSE
      BEGIN
      GetAlert(LMALERTS,ListofErr,@ListTitle);
      PromptString := ListTitle;
      END
   END;
*)


{$S lmlist}
PROCEDURE SaveCr;

   {This procedure saves the current range if necessary and releases
   all of the row snips. Called from FindPctRow.}

   {Assumption: the current range, if type row, cell, or rowgrid, is either
   entirely in the cache or entirely on the CurRgList. This is consistent
   with the way MakeSpace and ChkCurRg work.}

   CONST SCR = ' SaveCr';

   VAR CurRg: Range;
       Row: IdType;
       PriorRow: IdType;
       NextRow: IdType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,SCR);

   {If current range not already stored off, then check current range.}
   IF NOT CurRgList THEN WITH CurRg,TableData DO
      BEGIN
      GetCR(CurRg);
      IF Trace2MMgr  THEN
      WRITELN('Current range: LoRow: ',LoRow:3,' HiRow: ',HiRow:3,' LoCol: ',
               LoCol,' HiCol: ',HiCol);

      IF (rkind = aRowRg)
      OR (rkind = a1CellRg)
      OR (rkind = aRectRg)
      OR (rkind = aRowGrid) THEN

         BEGIN {Range needs to be stored off}
         IF RKind = ARowGrid THEN
            BEGIN {In the case of a row grid, the high or low snip may be MInfSnip
            or PInf Snip. Must change these so that only snips are stored.}
            IF (LoRow = MInfSnip) OR (LoRow = NullSnip) THEN LoRow := HiRow;
            IF (HiRow = PInfSnip) OR (HiRow = NullSnip) THEN HiRow := LoRow;
            END;

         {Cut the range out of the row snip list}
         CutRowSnips(TopRow,BottomRow,LoRow,HiRow);
         CurRgSnip := LoRow;
         CurRgList := TRUE;

         END; {Range needs to be stored off}

      END; {IF NOT CurRgList THEN With CurRg,TableData DO);

   {Now get rid of everything else in row memory}
   ReleaseRowSnips;
   END;


{$S lmlist }
PROCEDURE SaveScroll;

   CONST SS = ' SaveScroll';

   VAR  theband : tmband;
        topsnip : idtype;
        LeftSnip: IdType;
        ptrlmhnd : ^lmhandle;
        ScrollValid: BOOLEAN;
        CurPt: Point;
        VisRg: Range;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,SS);

   {get the snip id of the top left snips displayed on the screen}
   {Get point in current view}
   TMCurVwPt(CurPt);
   IF Trace2MMgr THEN WriteLn('H: ',CurPt.H,' V: ',CurPt.V);
   {Get currently visible range}
   VisRgOfView(CurPt,VisRg);
   WITH VisRg DO
      BEGIN
      TopSnip := LoRow;
      LeftSnip := LoCol;
      END;
   IF Trace2MMgr THEN WriteLn('TopSnip: ',TopSnip,' LeftSnip: ',LeftSnip);

   {Save away the horizontal scroll position}
   CASE LeftSnip OF
      PInfSnip,MInfSnip,NullSnip: HScrollId := NullSnip; {Table empty}
      OTHERWISE HScrollId := LeftSnip;
      END;

   {If the top snip equals the first row, then we know to display the list
   from the beginning, rather than try to use the handle of the topsnip,
   which after the updates are posted may change position and not be top
   anymore. Oh.. If the horizontal scroll position is null, which indicates
   an empty table, don't bother with trying to remember a vertical scroll.
   Also check for TopSnip equal to PInf, MInf, or Null which would indicate
   null rows which could result from a failure in the intrinsics.}
   IF (TopSnip = PInfSnip)
   OR (TopSnip = MInfSnip)
   OR (TopSnip = NullSnip)
   OR (TopSnip = TableData.FirstRow)
   OR (HScrollId = NullSnip)
   THEN ScrollValid := FALSE

   ELSE BEGIN {Get the handle and save it.}
        ScrollValid := TRUE;
        setsnipPtr(rowkind,topsnip);
        ptrlmhnd := POINTER(ORD(rowsnip) + rowsnip^.handoffset);
        ListTopHandle := PtrLmHnd^;
        END;

   ListScrollValid := ScrollValid;
   END;



{$S lmcolspec }
PROCEDURE SetFieldAttr{ColId: IdType;
                       Attr: INTEGER;
                       Value: PtrData;
                       Len: INTEGER};

   CONST SFA = ' SetFieldAttr ';

   TYPE ia = ARRAY [0..4] of INTEGER;

   VAR FAttPtr: ^INTEGER;
       TargetPtr: PtrData;
       DeltaSize: INTEGER;
       SourcePtr : PtrData;
       PtrA : ^ia;
       I : integer;
       Moveamt : Integer;
       EvenLen : integer;
       LStatus: INTEGER;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMGR then WriteLn(MxMgr,SFA);

   SetSnipPtr(ColKind,ColId);
   FAttPtr := POINTER(ORD(@ColSnip^.FieldInfo.Name) + (Attr * 2));

   {If the current value is not null, delete it}
   IF FAttPtr^ <> FNilVal THEN DelColAttr(ColSnip,FAttPtr^);

   {make sure it starts on an even boundary}
   EvenLen := Len;
   if ODD(EvenLen) then EvenLen := EvenLen + 1;


   {Get more space in the column snip if necessary}
   IF EvenLen > (colsnip^.freebytes - 1)  then
      BEGIN
      DeltaSize := EvenLen + RecExpand;
      ExpSnipBlock(ColId,colsnip^.recsize + DeltaSize,LStatus);
      SetSnipPtr(colkind,colid);
      WITH ColSnip^ DO
         BEGIN
         RecSize := RecSize + DeltaSize;
         FreeBytes := FreeBytes + DeltaSize;
         END;

      {Reset the pointer to the attribute offset}
      FAttPtr := POINTER(ORD(@ColSnip^.FieldInfo.Name) + (Attr * 2));
      END;

   {Find next non null offset}
   Ptra := @colsnip^.fieldinfo.name;
   IF MMTrap1 THEN FOR I := 0 TO 4 DO
      BEGIN
      IF PtrA^[I] <> FNilVal THEN IF Odd(PtrA^[I])
      THEN WriteLn(Bell,'***',SFA,'Odd offset in DBField: ',ColSnip^.FieldNum,I,PtrA^[I]);
      END;
   I := Attr + 1;
   WHILE (I <= 4) AND (PtrA^[I] = fnilval) DO I := I + 1;
   IF ( I > 4 ) THEN
      BEGIN
      {add the new field onto the end of the record}
      FAttPtr^ := colsnip^.fieldinfo.fldsize;
      TargetPtr := POINTER(ord(@colsnip^.fieldinfo) + FAttPtr^);
      MoveLeft(Value^,TargetPtr^,len);
      END

   ELSE BEGIN
        {Move existing stuff to right and insert new stuff}
        Moveamt := Colsnip^.Fieldinfo.Fldsize -  PtrA^[i];
        Sourceptr := POINTER(ORD(@Colsnip^.fieldinfo) + PtrA^[i]);
        Targetptr := POINTER(ORD(SourcePtr) + evenlen);
        MoveRight(Sourceptr^,TargetPtr^,moveamt);

        PtrA^[attr] := PtrA^[i];
        PtrA^[i] := PtrA^[i] + EvenLen;
        TargetPtr := POINTER(ORD(@Colsnip^.fieldinfo) + PtrA^[attr]);
        MoveLeft(Value^,TargetPtr^,len);
        END;


   colsnip^.freebytes := colsnip^.freebytes - Evenlen;
   colsnip^.fieldinfo.fldsize := colsnip^.fieldinfo.fldsize + Evenlen;
   END;


{$S lmprint }
PROCEDURE SetFontOptions{FOptions: FOptionType};

   CONST SFO = ' SetFontOptions ';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,SFO);

   MMFontInfo.FontOptions := FOptions;
   ListFormChanged := TRUE;
   END;


{$S lmsearch }
procedure setrun{var thisrun:run;
                 fstpos:integer;
                 itsbold:boolean};

   begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' SetRun ');

   With thisrun do
      begin
      lpfst := fstpos;
      font := MMFontinfo.Font.fam;
      if itsbold then face := MMFontinfo.font.seteface + [bold]
      else face := MMFontinfo.font.seteface - [bold];
      end;
   end;



{$S lmres }
PROCEDURE SetSnipPtr{snipType: SnipKind;
                     snipId : IdType};
   {This procedure sets up the RowSnip or ColSnip Ptr in globals and checks snip
    for validity if debugging is on}

   VAR h : TH;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {$IFC MMDEBUG }
   IF MMTrap1 THEN CheckSnipId(sniptype,SnipId);
   {$ENDC }
   h := SnipToPtr(SnipId);
   IF sniptype = colkind then ColSnip := @h^^
   ELSE RowSnip := @h^^;
   END;



{$S lmres  }
PROCEDURE SetSnipWidth{rg:Range; width: integer };

    CONST SWidth = ' SetSnipWidth';

    BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
    IF TraceMMGR then WriteLn(MxMgr,SWidth);

    {Check for various errors}
    IF MMTrap1 THEN IF NOT(rg.rkind IN [aColRg,arowrg]) THEN MMFatalErr(LogicErr,SWidth,'');

    case rg.rkind of


      aColRg: BEGIN
              if mmtrap1 then IF rg.locol <> rg.hicol then MMFatalErr(LogicErr,SWidth,'');
              if rg.locol = minfsnip then
                 begin
                 tabledata.rowtitlewidth := width;
                 end
              ELSE
                 begin
                 SetSnipPtr(colkind,rg.locol);
                 Width := Cmax(mincolwidth,Width);
                 Colsnip^.Width := Cmin(maxcolwidth,Width);
                 ListFormChanged := TRUE;
                 end;
              END;

         aRowRg:
              BEGIN
              IF MMTrap1 THEN IF rg.lorow <> rg.hirow then if mmtrap1 then MMFatalErr(LogicErr,SWidth,'');
              if rg.lorow = minfsnip then tabledata.coltitleheight := width
              else TableData.rowHeight := Width;
              END;

         END;


   END;




{$s lmsearch }
PROCEDURE setupandtriple{tripleindex,lasttriple,lastlasttriple:integer};

   begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' SetUpAndTriple ');

   With ExprHnd^^[TripleIndex] do
      BEGIN
      action := ex_and;
      op1 := lasttriple;
      op2 := LastLastTriple;
      end;
   end;


{$S lmlist }
Procedure setuprec{rsnip:ptrrowsnip; snipid : idtype;len:integer;setsize:integer;
           usererror:integer; errbitptr : ptrdata;var status : integer };

   var  src,dest : ptrdata;


   Begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' SetUpRec ');

   With rsnip^ do
      begin
      freebytes := RecExpand;
      dbrecsize := len;
      recsize := Len + sizeOf(rowsniprecord) + SetSize + RecExpand;
      sniptype := rowkind;
      nextsnip := nullsnip;
      priorsnip := nullsnip;
      rowtitle := FNilVal;
      bitoffset := sizeOF(rowsniprecord);
      errorcode := usererror;
      handoffset := sizeOf(rowsniprecord) + setsize;
      IF Odd(HandOffset) THEN
         BEGIN {Handle must begin on a word boundry}
         HandOffset := HandOffset + 1;
         FreeBytes := FreeBytes - 1;
         END;
      data := HandOffset  + sizeOf(preamble);
      IF errorcode = just_fyi then clearset(errbitptr,setsize);
      end;

   rowsnip^.snipid := snipid;
   src := errbitptr;
   dest := Pointer(ORD(rowsnip) + rowsnip^.bitoffset);
   moveleft(src^,dest^,setsize);
   dest := POINTER(ORD(rowsnip) + rowsnip^.handoffset);
   lmcopy(status,scanid,dest);
   IF MMTrap1 THEN IF Status <> 0 THEN WRiteLn(Bell,'***LMCopy status: ',Status);
   END;


{$S lmsearch }
PROCEDURE setuptriple{  tripleindex : integer;strptr : ptrdata; strlen:integer;
                     itsbold : boolean;
                     listsnip,specsnip,row:idtype;countcomp:integer;VAR foffset,
                     voffset,cumsize,cumvsize, status : integer};
   label 999;

   const sut = 'setuptriple';

   var  oplen:integer;
        len : integer;
        bptr : ptrdata;
        listcolsnip,speccolsnip : ptrcolsnip;
        oldoffset:integer;
        dbfldptr : ptrdbfield;
        vptr : ptrvfld;
        rsize : integer;
        rsizeavail : integer;
        delta : integer;
        realid: integer;
        errnum : INTEGER;
        Rarray : Array [0..maxrun] of run;
        numruns : integer;

   begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,' SetUpTriple ');

   status := 0;
   setsnipPtr(colkind,listsnip);
   listcolsnip := colsnip;
   setsnipptr(colkind,specsnip);
   speccolsnip := colsnip;

   len := strlen;
   bptr := strptr;
   {set up comparison triple}
   With ExprHnd^^[tripleindex -2] do
      BEGIN
      getaction(bptr,len,itsbold,action,oplen,status);
      IF MMTrap1 THEN if status <> 0 then mmfatalerr(logicerr,sut,'getaction');

      len := len - oplen;
      op1 := tripleindex - 1;
      op2 := tripleindex;
      bptr := POINTER(ORD(bptr) + oplen);
      END;

   if Trace2MMgr  then writeln('len,oplen ',len:3,oplen:3);

   {set up field triple}
   With ExprHnd^^[tripleIndex - 1] do
      BEGIN
      action := ex_field;
      realid := pdifftable^[scanid]^.realid;
      fileid := pscantable^[realid]^.onfile;
      fldid := listColSnip^.fieldNum;
      END;

   {set up constant triple}


   With ExprHnd^^[tripleIndex] do
      BEGIN
      action := ex_const;
      with desc do
         Begin
         IF odd(foffset) then foffset := foffset + 1;
         offset := foffset;
         direction := ascending;
         ftype := listcolsnip^.fieldinfo.reptype;
         size := listcolsnip^.fieldinfo.size;
         END;

      if Trace2MMgr  then writeln('foffset, voffset ',foffset:3,voffset:3);

      {construct the constant record -- fixed part}

      {construct a field datastructure for legal and pack }

      oldoffset := listcolsnip^.fieldinfo.offset;
      dbfldptr := @listcolsnip^.fieldinfo;

      {now the correct offset}

      dbfldptr^.offset := desc.offset;


      {initialize the record }
      if (desc.ftype = ftypvstr)  or (desc.ftype = ftypvnull) then
         begin
         vptr := POINTER(ORD(ConstHnd^) + foffset);
         vptr^.offset := voffset;
         vptr^.size := 0;
         end;


      {check for legality}

      legal(dbfldptr,bptr,len,errnum);
      if errnum <> 0 then
         begin
         if Trace2MMgr  then writeln('error from legal: ',errnum:4);
         status := errnum + CvtErr;

         {set hilite bit }
         setsnipptr(rowkind,row);
         bptr := POINTER(ORD(rowsnip) + rowsnip^.bitoffset);
         setbit(bptr,speccolsnip^.fieldnum);

         listcolsnip^.fieldinfo.offset := oldoffset;
         goto 999;
         end;

      {setup for pack call }

      rsize := voffset;
      rsizeavail := cumsize + cumvsize + 2*countcomp;

      pack(0,dbfldptr, bptr, len, consthnd^, rsizeavail, rsize, delta, errnum);

      if Trace2MMgr  then if delta <> len then
          writeln('delta : ', delta:4);
      if errnum <> 0 then
         begin
         if mmtrap1 then writeln('error from pack: ',errnum:4);
         status := errnum;

         {set hilite bit }
         setsnipptr(rowkind,row);
         bptr := POINTER(ORD(rowsnip) + rowsnip^.bitoffset);
         setbit(bptr,speccolsnip^.fieldnum);

         listcolsnip^.fieldinfo.offset := oldoffset;
         goto 999;
         end;


      if (desc.ftype = ftypvstr)  or (desc.ftype = ftypvnull) then
         begin
         ConstSize := ConstSize + len;
         voffset := voffset + len;
         end;

      foffset := foffset + ExprHnd^^[tripleindex].desc.size;
      listcolsnip^.fieldinfo.offset := oldoffset;

      END;

999: end;


{$S lmprint }
PROCEDURE SetUserFont{UFont: TlFntId};

   CONST SUF = ' SetUserFont ';

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,SUF);

   MMFontInfo.DMPFont := UFont;
   ListFormChanged := TRUE;
   END;


{$S lmres2 }
PROCEDURE ShrinkHeap;

   CONST SH = ' ShrinkHeap ';
         MaxAmount = 200000;

   VAR BytesRemoved: LONGINT;
       Status: INTEGER;
       I: INTEGER;
       DeltaMem: LONGINT;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF TraceMMgr THEN WriteLn(MxMgr,SH);
   IF Trace2MMgr THEN WriteLn(SH,'Zone,SegMem,SegDisc: ',ZoneSize,SegMemSize,SegDiscSize);

   {First get rid of anything in the zone which is not necessary}
   MMCallingMakeSpace := TRUE;
   I := MakeSpace(SnipZone,0);
   MMCallingMakeSpace := FALSE;

   {Now ask the storage manager to compact the heap}
   BytesRemoved := CBShrinkHZ(SnipZone,MaxAmount);

   {Remember how big the zone is now}
   ZoneSize := ZoneSize - BytesRemoved;

   {Now that the heap has been shrunk, shrink the memory size of the data segment to the zone size.}
   DeltaMem := ZoneSize - SegMemSize; {This number had better be negative..}
   Size_DataSeg(Status,SegRefNum,DeltaMem,SegMemSize,0,SegDiscSize);
   IF Status > 0 THEN
      BEGIN
      IF MMTrap1 THEN WriteLn(Bell,'***',SH,'Size_DataSeg status: ',Status);
      {Failure to shrink memory size of data seg is not fatal and requires no special action.}
      END;

   IF MMTrap1 THEN WriteLn(SH,'Zone,SegMem,SegDisc: ',ZoneSize,SegMemSize,SegDiscSize,BytesRemoved,DeltaMem);
   END;



{$S lmres  }
FUNCTION SnipLT{Snip: Snipkind;
                 SnipId1: IdType;
                 SnipId2: IdType): BOOLEAN};

    {This function returns TRUE if the snip whose identifier is in Snip1Id is
    before the snip whose identifier is in Snip2Id.}

    CONST SLT = ' SnipLT ';

    VAR   colords1,ColOrdS2 : integer;
          rowOrdS1,RowOrdS2 : lmhandle;
          compar : integer;
          ptrhand : ^lmhandle;


    BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
    IF TraceMMGR then WriteLn(MxMgr,Slt,Ord(Snip):1,' ',SnipId1:3,' ',SnipId2:3);

    {Check the special cases. This function is designed to return without
    error no matter how insensical the arguments. It seems preferable to
    have the table editor behave a little strangly rather than to have
    the list manager process quit with a fatal error.}

    IF SnipId1 = SnipId2 then SnipLT := FALSE
    ELSE IF SnipId1 = mInfSnip Then SnipLT := True
    ELSE IF SnipId2 = pInfSnip Then SnipLT := True
    ELSE IF SnipId1 = pInfSnip Then SnipLT := False
    ELSE IF SnipId2 = mInfSnip Then SnipLT := False

    ELSE IF (SnipId1 = NullSnip)
         OR (SnipId1 < -2)
         OR (SnipId2 = NullSnip)
         OR (SnipId2 < -2) THEN
            BEGIN
            if mmtrap1 then WRITELN(Bell,'***Bad Snips to SnipLT: ', SnipId1, SnipId2);
            SnipLT := FALSE;
            END

    ELSE IF NOT(Snip IN [Colkind,Rowkind]) THEN
            BEGIN
            if mmtrap1 then WriteLn(Bell,'***Invalid snip type to SnipLt');
            SnipLT := FALSE;
            END


    {Determine if the snip is a row or column, and case accordingly}
    ELSE BEGIN
         CASE Snip OF

            Colkind: BEGIN {Order determined by order field}
                     {Now determine if column 1 is before column2}
                     setSnipPtr(snip,snipid1);
                     colOrdS1 := colsnip^.order;
                     setSnipPtr(snip,snipid2);
                     colOrdS2 := colsnip^.order;

                     IF colOrds1 < colOrdS2 then SnipLt := true
                     ELSE snipLt := False;
                     END; {Colkind}


            Rowkind: BEGIN {Order determined by key}
                     setSnipPtr(snip,snipid1);
                     ptrhand := POINTER(ORD(rowsnip) + rowsnip^.handoffset);
                     rowOrdS1 := ptrhand^;
                     setSnipPtr(snip,snipid2);
                     ptrhand := POINTER(ORD(rowsnip) + rowsnip^.handoffset);
                     rowOrdS2 := ptrhand^;
                     compar := comphand(rowOrdS1,rowOrdS2);
                     IF compar = lt then SnipLT := TRUE
                     ELSE snipLT := FALSE;

                     END; {Rowkind}

            END; {CASE Snip}
         END;

    END;




