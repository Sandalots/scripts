
UNIT LMMENUS;
{Copyright 1983,1984, Apple Computer Inc.}



INTERFACE

{$SETC ForOS := TRUE }
{$DECL IsIntrinsic}
{$SETC IsIntrinsic := TRUE}
{$DECL UTProblems}
{$SETC UTProblems := FALSE}
{$DECL WithUObject}
{$SETC WithUObject := FALSE}

{$IFC NOT WithUObject}
    {$SETC LibraryVersion := 30 } { 10 = 1.0 libraries; 13 = 1.3 libraries; 10 = Pepsi, 30 = Spring, etc. }
{$ENDC}

USES
     {$U  unitStd }        UnitStd,
     {$U  unitHz}          UnitHz,
     {$U  Storage}         Storage,
     {$U  QuickDraw}       QuickDraw,
     {$U  Fontmgr}         Fontmgr,
     {$U  dbenv}           dbenv,
     {$U  fedec}           fedec,
     {$U  fld}             fieldEdit,
     {$U  teenv}           teenv,
     {$U  dbdecl1}         dbdecl1,
     {$U  inter}           international,
     {$U  libos/syscall.Obj}     syscall,
     {$U  libos/psyscall.Obj}     psyscall,
     {$U  wm.events.obj}   events,
     {$U  wm.folders.obj}  folders,
     {$U  wm.menus.obj}    menus,
     {$U  alertmgr}        alertmgr,
     {$U  lowlevel.Obj}    lowlevel,
     {$U  pooler.Obj}      pooler,
     {$U  heap.Obj}        heap,
{$IFC PRERELEASE }
     {$U  pstuff.Obj}      pstuff,
{$ENDC }
     {$U  czcompact.Obj}   czcompact,
     {$U  vltree.Obj}      vltree,
     {$U  scan.Obj}        scan,
     {$U  labscan.Obj}     labscan,
     {$U  schema.Obj}      schema,
     {$U  libdb/extnsort.Obj}    Extnsort,
     {$U  apll/lmscan.obj}      lmscan,
     {$U  apll/dbconvert}       dbconvert,
     {$U  wmlstd}          wmlstd,
     {$U  wmlsb  }         wmlsb,
     {$U  wmlgrow}         wmlgrow,
     {$U  wmlcrs}          wmlcrs,
     {$U  pmdecl}          PmDecl,
     {$U  PrStdInfo  }  PrStdInfo,
     {$U  PrPublic}  PrPublic,
     {$U  UUnivText}       UUniversalText,
     {$U  unitFile.obj}    unitFile,
     {$U  unitFmt.obj}     unitFmt,
     {$U  unitCs.obj}      UnitCs,
     {$U  unitFF.obj}      unitFF,
     {$U  apll/matmgr}          lmmat,
{$IFC SAMPCALLS}
     {$U  apll/tracecalls.obj} tracecalls,
{$ENDC}
     {$U  apll/lmprint}         lmPrint,
     {$U  tm}              tm,
     {$U  scrap}           scrap,
     {$U  filercomm}       filercomm,
     {$U  HwInt}           HwInt;

{$setc FEXECDEBUG := MMDEBUG }


CONST

{constants for menus}

      Menufile= 1;


         fmcloseall = 1;
         fmclose   = 2;
         { 3 }
         fmPutBack = 4;
         AcceptAll = 5;
         UndoAll   = 6;
         { 7 }
         mpPrintAsIs = 8;
         mpFormatFor = 9;
         mpPrint = 10;
         mpPrinProg = 11;
         { 12 }
         Recover = 13;


       MenuEdits  = 2;
         Undo  = 1;
         RstOrig = 2;
         { 3 }
         Cut   = 4;
         Copym  = 5;
         PasteM = 6;
         { 7 }
         Clear = 8;
         { 9 }
         Seltbl = 10;

       Menufont = 3;
         mmodern = 1;
         mclassic = 2;
         {3}
         m08x20 = 4;
         m08x15 = 5;
         m10x12 = 6;
         m12x10 = 7;
         {8}
         mactual = 9;
         msmall = 10;
         mmedium = 11;
         mlarge = 12;

       MenuShow = 4;
         mslist = 1;
         {2}
         mscolspecs = 3;
         msorder = 4;
         {5}
         mssearch = 6;
         msselrows = 7;
         mssrchord = 8;
         {9}
         ChangeFile = 10;

       menudtype =  5;
         mdCharacter = 1;
         mdNumber = 2;
         mdMoney = 3;
         mdDate = 4;
         mdTime = 5;
         mdTelephone = 6;
         mdZipCode = 7;
         mdSSN = 8;

       MenuSortOrder =  6;
         msAscend = 1;
         msDescend = 2;

       MenuVisible = 7;
         mvOn = 1;
         mvOff = 2;

       MenuOp = 8;
         moeq = 1;
         molt = 2;
         mole = 3;
         mogt = 4;
         moge = 5;
         mone = 6;
         mothru = 7;

       Menubuzzword = 9;
         mbtype = 1;
         mbscroll = 2;
         mbgrow = 3;
         mbmousedown = 4;
         mbmouseup = 5;
         mbfldract = 6;
         mbfldrdeact = 7;
         mbfldrupdate = 8;
         mbfcopenresumenew = 9;
         mbfcclose = 10;
         mbfccopy = 11;
         mbfcterm = 12;
         mbfcshred = 13;
         mbfcput = 14;
         mbfcnone = 15;
         mbfcsuspend = 16;


      MenuTrace = 10;
         TMmgr = 1;
         TSmgr = 2;
         TTmgr = 3;
         TXTmgr = 4;
         TFmgr = 5;
         TFedits = 6;
         TFexec = 7;
         tlmdebug = 8;
         tmmtrap1 = 9;
         tmmtrap2 = 10;
         tdbconvert = 11;
         tlmprint = 12;
         tmmgr2 = 13;
         TPrintProcs = 14;
         tstorage = 15;

      MenuSFile = 11;
         scrapclall = 1;
         scrapclose = 2;
         {3}
         scrapmonptr = 4;

      MenuSubst = 12;
         msEntire = 1;
         msNew = 2;
         msModified = 3;
         msclose = 4;

      MenuVersion = 13;



      FirstMenu = 1;
      LastMenu = 13;



   MaxMoves = 10;                      {dimension of movespecs array}
                                       {movespecs[10] contains a ctrl - z forever}
   cTitlePnl = 6;
   cHiPnl = 6;



       {Constants for characters used for enter moves}

   chReturn = $0D;  {13}
   chTabkey = $09;
   chBack = $08;    { 8}
   chEscape = 27;   {27}
   chEnter = $03;   { 3}
   chDarrow = $1F;  {$1F}
   chLarrow =  $1C; {$1C}
   chRArrow = $1D;  {$1D}
   chUarrow = $1E;  {$1E}
   chclear = $1B;   {$1B}

   chbell = $07;


   numsusblocks = 2;

   scrapblks = 16;

   LMHeapLdsn = 2;

   schasnil = -1;
   schasList = 1;

   deltadouble = 20;

   lmversion = 1;
   dbcversion = 1;




{$IFC NOT fexecdebug }
   tracing = false;
   printprocs = false;

{$ENDC }


TYPE

    {move key possibilities}
    MoveDir = (mvRight, mvLeft, mvUp, MvDown, MvNewRow, MvNewCol,MvStay,NoMove,
               mvRightPeg, mvLeftPeg);

    ScState = (scEmpty,scField,scList,scNotMine);  {Scrap State}


       {Data Structures for enter moves}

    HoldKey = (nokey,ShiftKey,CmdKey,SpecKey);

    KeyPair = Record

                Key:char;
                keyHeld : holdkey;
              end;

    SusData = Record

                sCurtimeout    : Integer;
                sCurnbrhood    : Rect;
                sCurRange      : Range;
                sActivePnl     : PnlIndex;
                sLastPnl       : PnlIndex;
                sWholeSelected : Boolean;
                sCellError     : Boolean;
                sDtMenuUp      : Boolean;
                sSomenuUp      : Boolean;
                sCvMenuUp      : Boolean;
                sOpMenuUp      : Boolean;
                sRowBand       : tmband;
                scolBand       : tmband;
                sTblPars       : TableRecord;
                sLastshowItem  : integer;
                sTmState       : tmstate;
                sGMTPostTime   : Time_rec;
              END;

   SusDataPtr = ^Susdata;

   ScRecord = Record
                  scraphas : integer;
                  datahnd  : th;
                  openid   : time_Rec;
              END;

   ScrRecPtr = ^Screcord;
   scrRecHnd = ^ScrRecPtr;


VAR

{$IFC fexecdebug }
    tracing:       BOOLEAN;
    PrintProcs:   BOOLEAN;                  {Tracing Flags }

{$ENDC }


                                             {enter move right for lisacalc selects cell}
                                             {while list manager selects contents }
    MoveSpecs: Array [0..Maxmoves] of         {enter move keys and the directions}
                Record                        {they imply}
                   keys : keypair;
                   direction : movedir;
                end;


    PFname : Pathname;     {Physical File name (pathname)}
    MenuStyle : integer;        {typestyle menu style - classic or modern}

    titField:   hndfield;           {selected field}
    picturehdl: picHandle;          {handle of scrappicture}

    mymenus: ARRAY [1..lastmenu] of MenuInfo;

    dtmenuup:  boolean;                      {data type menu up}
    somenuup:  boolean;                      {sort order menu up}
    cvmenuup:  boolean;                      {col vis menu up}
    opmenuup : boolean;                      {search op menu up}

    TrceMenuVis:  BOOLEAN;                   {True when the appropriate menus are }
    BldMenuVis: BOOLEAN;
                                             {Visible                             }
    {$IFC fexecdebug}
    VerMenuVis: Boolean;
    {$ENDC}


    Copyok,
    CutOk,
    UndoOk,
    PasteOk,                                 {hilite booleans for menu items}
    RestoreOk,
    UndoallOk,
    ClearOk,
    SrchOk,
    SelRowOk ,
    ColSpcOk,
    selTblOK,
    RecoverOK,
    ChgFileOK,
    ordentok,
    ordsrchok,
    saveContOk,
    classicOK,
    font20_OK,
    font15_OK : boolean;

    theEvent : EventRec;
    QuitRequest:   BOOLEAN;                   {True when quit menu item selected}

    ActivePnl :   PnlIndex;                   {Contains active panel. set on a }
                                              {Mouse Down}
    LastPnl : PnlIndex;                       {last panel moused down in}
    TitlePnl : PnlIndex;                      {title panel index}

    TitleHeight :integer;                     {height of title panel}
    WavHeight  : integer;                     {height of wide angle view}

    curRange:     Range;                      {Contains the current range}
{u}
    curNbrhood:   rect;                       {Contains the current neighborhood}
                                              {which is passed to getnxtevent}

    curTimeout:    INTEGER;                   {ditto for the current timeout}
    TimeoutTime : longint;

    Check2or3Click:BOOLEAN;                   {True when looking for a dbl or trpl click}
    FndDouble:     BOOLEAN;                   {True when we have Found a Double click}
    FndTriple:     BOOLEAN;                   {True when we have found a Triple click}
    MouseHasMoved: BOOLEAN;                   {True when mse moves after mse dwn}
    LastUpTime : longint;                     {last time mouse went up time dbls}
    seqflag : boolean;                        {true when time-lastdown < dbltriple}
    wholeselected : boolean;                  {true when a whole cell is selected}
    MseDwnErr: Boolean;                       {true when mouse down error occured}


    skipnextmouseup : boolean;                {true if we should skip next mse up}

    Folder:windowptr;                         {the windowptr of the folder}
    sblist:tsblist;                           {the scroll bar list}

    CellError : boolean;                      {true when cell has an error}

    docsopen : integer;                       {counter of open docs 0 or 1}
    FileClosed : Boolean;                     {true when no file is open}
    openrequested : boolean;                  {true when we want to open on activ.}
    opentype: docActionType;                  {parameter to opendoc}


    FldrUpdateOk : boolean;                   {true when tbl edtr structs are valid}


    LMHeapSize : Longint;                     {the heap variables}
    LMDiscSize : Longint;
    LMheaprefnum : integer;

    lastshowitem : integer;                   {last checked item in show menu}
    susDocCalled : boolean;                   {did we call suspend doc? result of}
                                              {fccopy}

    GMTPostTime: Time_rec;                    {when file was last posted}





PROCEDURE AdjPnls(newbotright:point);
PROCEDURE CheckPrintPref(printpreference:TPrRec; var oldfont,newfont:tlfntid;
                         var status:integer);
{$IFC fexecdebug}
Procedure ClrMrkItem(menu:integer;item:integer;Mark:boolean);
{$ENDC }
PROCEDURE ClearScrap(var status : integer);
PROCEDURE CoerceToCell(oldrange:range;var newrange:range);
PROCEDURE CommandKey(key:char;shiftkey,applekey:boolean);
PROCEDURE CreateTitleField;
Procedure DisEnaItem(menu:integer;item:integer;Dim:boolean);
Function  DocConsistent:Boolean;
PROCEDURE DoFilerEvent(event:EventRecord);
Procedure DoFldrUpdate;
Procedure DoKeyedMove (dir : moveDir;hilite: cellseltype);
PROCEDURE DoUpdate(who:windowptr;drawscroll:boolean);
Procedure DrawPnlLines;
PROCEDURE EnterStuff ( VAR Status : Integer);
Procedure ErrSelect(status:integer);
{Procedure ErrTitle;}
PROCEDURE FillTable(table:tabletype;showlast:boolean;
                    Searchit:boolean;Sortit:boolean);
Procedure Fixmenus;
Procedure FixThumb(window:windowptr);
PROCEDURE FlashTitle;
Procedure FlushUpdates( VAR fStatus : Integer);

(*PROCEDURE FntidToItem(fntid:tlfntid; VAR fntitem:integer);*)
PROCEDURE FntidToItem(fntid:tlfntid; VAR StyleItem:integer; var FontItem:integer);

PROCEDURE FontChange(oldfntid,newfntid:tlfntid);
Procedure HiLiteEdits;
Procedure InitMSpecs;
Procedure LLDrawScrap(rgtype:rgkind);
PROCEDURE LoadTable( rowband,colband:tmband; atmstate:tmstate);
Procedure LookAtScrap(var scrapstate:scstate;var lsstatus:integer);
Procedure MakeRgVisible(oldRange,newRange:range);
PROCEDURE MenuCommand(menu, item: INTEGER);
Function  MoveAction (ch : char): moveDir;
FUNCTION  NewRow(Move:Movedir;Crg:range): BOOLEAN ;
FUNCTION  NewRowPt(P:Point; CRg: Range) : BOOLEAN;
Procedure packSusData(hndsusdata:hnddata;offset:integer;curlen:integer;
                      var leninstalled:integer; var newlen:integer);
PROCEDURE PutSusData(VAR hndsusdata:hnddata; var Len:integer);
(*PROCEDURE PreftoFntid(PrintPreference:TPrRec;aDMPfont:tlfntid;
                                             VAR Mappedfont:tlfntid;
                                             VAR flqp: boolean;
                                             VAR propwheel:boolean;
                                             VAR famchanged:boolean;
                                             VAR widchanged:boolean); *)
Procedure redrawFldr(UpdateRgn:rgnHandle; resize:boolean;paint:boolean;
                     drawscroll:boolean);
Procedure redrawScrap(UpdateRgn:rgnHandle;drawscroll:boolean);
procedure rgcompare(var status:integer; var ucols:integer; var utextdup:boolean);
PROCEDURE SaveTable(var rowband,colband:tmband;var atmstate:tmstate);
{PROCEDURE SetMenus;}
PROCEDURE SetScrap(scrapstate : scstate;var ssstatus:integer);
PROCEDURE ShoTitle;
PROCEDURE TEFatalErr(module:str40; proc:str40; msg:str40);
Procedure UnpackSusData(hndsusdata:hnddata;offset:integer);



IMPLEMENTATION

{$R-}

{$IFC MMSYMBOLS}
{$D+}
{$ELSEC }
{$D-}
{$ENDC}


PROCEDURE SetTitleField;FORWARD;
PROCEDURE ActvResume(var Status:integer);External;
FUNCTION  GrowScrap(hz: Thz; bytesNeeded: INTEGER): INTEGER;External;
Procedure OpentheList(opentype:docactiontype;var ostatus : integer);External;


{$I apll/menuprocs.text}


{$S lmscreen}
PROCEDURE AdjPnls{newbotright:point};

   VAR
       deltav : integer;
       r:rect;
       newpnlsize:rect;
       offset : point;
       dvscroll,
       dhscroll : integer;



   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {change panel sizes to refelect folder size, and font size}
   {panels shrink to actual size so they dont paint into scroll bar}
   if PrintProcs then writeln('adjpnls');

      dvscroll := dvsbox-1;
      dhscroll := dhsbox-1;

   {$IFC tedebug}
   if tracing then
      begin
      {print out rects}
      getpnlrect(folderpnl,r);
      writeln('folderpnl');
      prntrect(r);

      getpnlrect(titlepnl ,r);
      writeln('titlepnl ');
      prntrect(r);

      getpnlrect(widepnl,r);
      writeln('widepnl');
      prntrect(r);

      getpnlrect(tblpnl,r);
      writeln('tblpnl');
      prntrect(r);
      end;
   {$ENDC}

   getpnlrect(folderpnl,r);
   chgpnlsize(folderpnl,newbotright.h-dhscroll,newbotright.v-dvscroll);
   getpnlrect(folderpnl,newpnlsize);

   getPnlrect(widepnl,r);
   if (newbotright.v -dvscroll  <  wavheight + 1 ) then
      begin
      if newbotright.v -dvscroll  > 0 then
         begin
         deltav := newbotright.v -dvscroll  ;
         chgpnlsize(widepnl,newbotright.h- dhscroll, deltav);
         end
      else
         begin
         chgpnlsize(widepnl,newbotright.h-dhscroll,0);
         end
      end
   else
      begin
      chgpnlsize(widepnl,newbotright.h-dhscroll,wavheight);
      end;


   setpt(offset,0,wavheight+1);
   movepnl(titlepnl,offset);

   getpnlrect(titlepnl,r);
   if ((newbotright.v - dvscroll)   < (titleheight+ wavheight + 2 )) then
      begin

      if ((newbotright.v -dvscroll)  > wavheight) then
         begin
         deltav := newbotright.v -dvscroll  - (wavheight + 1);
         chgpnlsize(titlepnl,newbotright.h-dhscroll,deltav);
         end
      else
         begin
         chgpnlsize(titlepnl,newbotright.h-dhscroll,0);
         end
      end

   else
      begin
      chgpnlsize(titlepnl,newbotright.h-dhscroll,titleheight);
      end;


   setpt(offset,0,wavheight+titleheight+2);
   movepnl(tblpnl,offset);
   getpnlrect(tblpnl,r);
   chgpnlsize(tblpnl, newbotright.h-dhscroll,(newbotright.v-dvscroll)-
                                      (wavheight+titleheight+2));

   {$IFC tedebug}
   if tracing then
      begin
      {print out rects}
      getpnlrect(folderpnl,r);
      writeln('folderpnl');
      prntrect(r);

      getpnlrect(titlepnl ,r);
      writeln('titlepnl ');
      prntrect(r);

      getpnlrect(widepnl,r);
      writeln('widepnl');
      prntrect(r);

      getpnlrect(tblpnl,r);
      writeln('tblpnl');
      prntrect(r);
      end;
   {$ENDC}
   {tell selection manager about new sizes}
   resizeflds;
   END;


{$S lmfontme}
PROCEDURE CheckPrintPref{printpreference:TPrRec; var oldfont,newfont:tlfntid;
                         var status:integer};
   VAR
       propwheel: boolean;
       olddspfont,
       newdspfont,
       mappedfont:tlfntid;
       famchanged,
       widchanged:boolean;
       flqp: boolean;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if printprocs then writeln('checkprintpref');
   {the printer preference has changed.}
   {return old font and newfont ready for font change}
   {status returns:
                      -2 printfont not in fontoptions
                      -1 dmp specified
                       0 perfect match                }

   with mmfontinfo do
     begin
     IF NOT fileclosed and NOT(printfont in fontoptions) then
        begin
        oldfont := font;
        newfont := font;
        status := -2;
        if tracing then writeln('sml, status',status);
        exit(checkPrintPref);
        end;

     if font.fam <> dmpfont.fam then
        begin
        {change display back to dmp font}
        oldfont := font;
        newfont := dmpfont;
        status := -1;
        if tracing then writeln('dmp, status',status);
        end
     else
        begin
        oldfont := font;
        newfont := font;
        status := 0;
        if tracing then writeln('dmp, status',status);
        end;
     end;

   END;

{$IFC fexecdebug}
{$S lmscreen}
Procedure ClrMrkItem{menu:integer;item:integer;Mark:boolean};
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('clrmrkitem');
   IF Mark then MarkItem(mymenus[menu],item,checkMark)
   ELSE MarkItem(mymenus[menu],item,nomark);
   END;
{$ENDC }



{$S lmscrap}
PROCEDURE ClearScrap{var status:integer};
   Var Prect : rect;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('clearscrap');

   GetPnlRect(ScrapPnl,Prect);
   SetPnlPort(ScrapPnl);
   EraseRect(Prect);
   setscrap(scempty,status);
   END;

{$S lmmain }
PROCEDURE CoerceToCell{oldrange:range,var newrange:range};
   VAR snipid:idtype;
       tabrec:tablerecord;
       newcol:idtype;
       orgkind : rgkind;
       olorow : idtype;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF PrintProcs then writeln('coerceToCell');
   orgkind := oldrange.rkind;
   olorow := oldrange.lorow;

   if (orgkind = aColRg) and tblPars.editColTitle  THEN
      BEGIN
      setRg(newRange, aColHedRg, mInfSnip, oldrange.locol, mInfSnip, oldrange.locol);
      DoSelCR(newRange, curtimeout, selectContents);
      END
   ELSE if ((orgkind = aWTBoxRg) or (orgkind = aColRg)) and NOT tblPars.editColTitle THEN
      BEGIN
      {should be ok since editcoltitle is only true for colspecs}
      {rebldtbl if in the list but not at the top of the list}
      if (curtable = tlist) then
        begin
        switchtable(TRUE,tabrec);
        tmshonewtbl;
        end;

      getsnipid(rowkind,mmfirst,0,snipid,snipid);
      if oldrange.locol = minfsnip then getsnipid(colkind,mmfirst,0,newcol,newcol)
      else newcol := oldrange.locol;

      {just in case there are no rows...}
      if snipid = pinfsnip then snipid := minfsnip;
      setRg(newRange,a1CellRg,snipid,newcol,snipid,newcol);
      DoSelCR(newRange, curtimeout, selectContents);
      END

    Else if (orgkind = aRowRg) and tblPars.editRowTitle  THEN
      BEGIN
      setRg(newRange, aRowHedRg, olorow, mInfSnip, olorow, mInfSnip);
      DoSelCR(newRange, curtimeout, selectContents);

      END
    Else if (orgkind = aRowRg) and NOT tblPars.editRowTitle  THEN
      BEGIN
      getsnipid(colkind,mmfirst,0,snipid,snipid);
      {protect against table with labels only, no cols}
      if snipid = pinfsnip then snipid := minfsnip;
      setRg(newRange, a1CellRg, olorow, snipid, olorow, snipid);
      DoSelCR(newRange, curtimeout, selectContents);

      END
    Else if (OldRange.rkind = aRectRg) THEN
      BEGIN
      {reset range to the first cell of the range}
      with oldrange do
        setRg(newRange, a1CellRg, lorow, locol, lorow,locol);
      DoSelCR(newRange, curtimeout, selectContents);
      END;

   END;


{$S lmmain}
PROCEDURE CommandKey{key:char;shiftkey,applekey:boolean};
   VAR mintime : integer;
       themenu,
       theitem : integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF PrintProcs then writeln('CommandKey');

   if applekey then
      begin
      MenuKey(key,themenu,theitem);
      end
   else if key = chr(chclear) then
      begin
      themenu := menuedits;
      theitem := clear;
      end;

   HiliteMenu(themenu);
   mintime := Time ;
   menucommand(themenu,theitem);
   Repeat until ABS(time - mintime) > 15;
   Hilitemenu(0);

   END;


{$S lminit}
PROCEDURE CreateTitleField;
   VAR
       xrect : rect;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF PrintProcs then writeln('createtitlefield');
   setRect(xrect,0,0,0,0);
   titfield := CreateField(xrect,256,25,center,4,1,1,systext,true);

   END;

{$S lmmain}
Procedure DisEnaItem{menu:integer;item:integer;Dim:boolean};
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('disenaitem');
   IF Dim then DisableItem(mymenus[menu],item)
   ELSE EnableItem(mymenus[menu],item);
   END;


{$S lmfiler}
FUNCTION DocConsistent{:Boolean};
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF PrintProcs then writeln('docconsistent');
   {has enterstuff/ entercell / updaterow been called (matrix manager determined}
   IF NOT CloseOK then
      BEGIN
      DocConsistent := False;
      if tracing then writeln('closeok = false');
      Exit(DocConsistent);
      END
   ELSE if tracing then writeln('closeok = true');;

   IF (curRange.rkind = a1CellRg) AND ((Validcoord(curRange) AND CellChanged) OR
                                        CellError) Then
      BEGIN
      DocConsistent := FALSE;
      if tracing then writeln('doc inconsistent --- cell edited');
      Exit(DocConsistent);
      END;

   IF ((CurRange.rkind = aRowHedRg ) OR (CurRange.rkind = aColHedRg )) AND
      CellChanged THEN
      BEGIN
      DocConsistent := FALSE;
      Exit(DocConsistent);
      END;

   DocConsistent := True;

   END;


{$S  lmfiler}

PROCEDURE DoFilerEvent{event:EventRecord};

   VAR
        theFilerExt:FilerExt;
        status:integer;
        tempstr:str255;
        finfo:fontinfo;
        ferror : integer;
        oldstyleitem:integer;
        oldfontitem:integer;
        copystatus : integer;
        curtblfont : tlfntid;
        sstate : scstate;
        docsize : longint;
        aReply: FReply;
        aReason: FReason;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Process a filer Event}
   if PrintProcs then writeln('dofilerevent');
   GetAddParams(status,Event,thefilerext);
   if tracing then writeln('theflrop: ',ord(thefilerext.theflrop));
   Case thefilerext.theflrop of

      fcResume:

            BEGIN
            if mmtrap1 then
               begin
               writeln('fcresume event');
               end;
            DocPassWord := thefilerext.thepassword;
            if mmtrap2 then writeln('length of password : ',length(docpassword));
            setpasswd(DocPassWord);

            wouldalert(mymenus[menubuzzword],mbfcopen);
            {Ensure we weren't sent an erroneous fcresume}
            IF docsOpen <> 0 THEN
               BEGIN
               if mmtrap1 then Writeln(chr(chbell),'   can''t handle another doc, refusing');
               TellFiler(status,docClosd,noMoreDocs,Event.who);
               if mmtrap1 then if status <> 0 then
                  writeln('TellFiler status: ',status:4);
               exit(doFilerEvent);
               END;


            opentype := mmResume;

            Folder:=Event.who;
            setport(folder);
            setorigin(0,0);


               {Get the file name -- both real pathname (pname) and window title
                                      lfname}

            GetFldrTitle(folder,tempstr);
            Lfname := tempstr;
            IF tracing then WRiteln('Logical filename ' , Lfname );

            Pfname := theFilerExt.thePrefix;

            IF tracing then WRiteln('Pathname from filename ' , Pfname );

            takewindow(Event.who);

            fileclosed := true;
            fldrUpdateOK := false;
            susdoccalled := false;
            {register open request so we will open on next activate}
            {we must be active to field errors, so we must defer open to }
            {activate time}
            openrequested := true;

{u}         if (folder = event.who) and (ImActive) then ActvResume(status);
            if status <> 0 then
              if mmtrap1 then writeln('Bad status from ActvRsum : ',status);

            {docsopen incremented here so we can refuse if we get a fcresume}
            {prior to an activate}
            docsopen := docsopen + 1;

            END;

      fcClose:
            BEGIN
            wouldalert(mymenus[menubuzzword],mbfcclose);
            IF MMTRAP1 THEN WRITELN('fcClose event..');
            IF fileclosed and not openrequested then
               BEGIN
               {file already closed }
               if tracing then writeln('file already closed');
               if tracing then if event.who <> folder then
                          writeln('event.who <> folder');
               TellFiler(status,docClosd,allOK,Folder);
               if mmtrap1 then if status <> 0 then
                  writeln('TellFiler status: ',status:4);
               END
            ELSE IF fileclosed and openrequested then
               BEGIN

               if tracing then writeln('fileclosed - open requested');

               IF susDocCalled then
                  BEGIN
                  {this case happens following a copy which we perform}
                  {since we are suspended, we must refuse the close}
{u}            {  OpenRequested := false;
                  docsopen := docsopen - 1;
                  checkitem(mymenus[menushow],lastshowitem,false); }
                  TellFiler(status,docnotClosd,dirtydoc,Folder);
                  if mmtrap1 then if status <> 0 then
                     writeln('TellFiler status: ',status:4);

                  END
               ELSE
                  BEGIN
                  {this case also occurs after multiple pull, close, dragicon}
                  {in which case all is well}
                  TellFiler(status,docClosd,allOK,Folder);
                  if mmtrap1 then if status <> 0 then
                     writeln('TellFiler status: ',status:4);
                  docsOpen := docsOpen - 1;   { can now accept another document }
                  END;
               END
            ELSE if not fileclosed and NOT DocConsistent then
               begin
               {file is open but inconsistent}
               if tracing then if event.who <> folder then
                          writeln('event.who <> folder');
               TellFiler(status,docnotClosd,dirtyDoc,Folder);
               if mmtrap1 then if status <> 0 then
                  writeln('TellFiler status: ',status:4);
               end
            ELSE if not fileclosed and DocConsistent then
               BEGIN
               curtblfont := mmfontinfo.DMPfont;
               CloseDocument;
               fileclosed := true;
               fldrUpdateOK := false;

               if  fmfontmetrics(curtblfont,finfo,ferror) then ;
               if mmtrap1 then if ferror <> 0 then
                     writeln('bad call to fmfontmetrics status',ferror);

               FntIDToItem(curtblfont,oldstyleitem,oldfontitem);
               checkitem(mymenus[menufont],menustyle,false);
               checkitem(mymenus[menufont],oldfontitem,false);
               checkitem(mymenus[menushow],lastshowitem,false);
               docsOpen := docsOpen - 1;   { can now accept another document }
               susdoccalled := false;

               if tracing then if event.who <> folder then
                          writeln('event.who <> folder');
               TellFiler(status,docClosd,allOK,Folder);
               if mmtrap1 then if status <> 0 then
                  writeln('TellFiler status: ',status:4);
               END
            ELSE
               if mmtrap1 then writeln('dofiler event shouldnt get here');

            END;



      fcShred,
      fcSuspend:
            BEGIN
            wouldalert(mymenus[menubuzzword],mbfcsuspend);
            IF MMTRAP1 THEN WRITELN('fcsuspend/fcshred event..');
            if not fileclosed then
               begin

               curtblfont := mmfontinfo.DMPfont;

               SuspendDocument;
               fileclosed := true;
               fldrUpdateOK := false;
               docsOpen := docsOpen - 1;   { can now accept another document }

               if fmfontmetrics(curtblfont,finfo,ferror) then ;
               if mmtrap1 then if ferror <> 0 then
                     writeln('bad call to fmfontmetrics',ferror);

               FntIDToItem(curtblfont,oldstyleitem,oldfontitem);
               checkitem(mymenus[menufont],menustyle,false);
               checkitem(mymenus[menufont],oldfontitem,false);
               checkitem(mymenus[menushow],lastshowitem,false);

               end
            ELSE if fileclosed and openrequested then
               BEGIN
               {a copy just occurred.  we are suspended, but filer thinks we
                are open}
               OpenRequested := false;
               docsopen := docsopen - 1;
               checkitem(mymenus[menushow],lastshowitem,false);
               END;
            TellFiler(status,docClosd,allOK,Folder);
            if mmtrap1 then if status <> 0 then
               writeln('TellFiler status: ',status:4);
            END;


      fcCopy:
            BEGIN
            if MMTRAP1 THEN WRITELN('fcCopy event..');
            wouldalert(mymenus[menubuzzword],mbfccopy);

            {the test for fileclosed and openrequested and susdoccalled
             is a test for a situation after a fccopy event}

            if not fileclosed or (fileclosed and openrequested and
                                  (susdoccalled)) then
               begin
               if not fileclosed then
                  BEGIN
                  curtblfont := mmfontinfo.DMPfont;
                  SuspendDocument;
                  susDocCalled := true;
                  fileclosed := true;
                  fldrUpdateOK := false;

                  docsopen := docsopen - 1;

                  if fmfontmetrics(curtblfont,finfo,ferror) then ;
                  if mmtrap1 then if ferror <> 0 then
                        writeln('bad call to fmfontmetrics',ferror);

                  FntIDToItem(curtblfont,oldstyleitem,oldfontitem);
                  checkitem(mymenus[menufont],menustyle,false);
                  checkitem(mymenus[menufont],oldfontitem,false);

                  {file suspended now}
                  END
               ELSE if (fileclosed and openrequested and
                                  (susdoccalled)) then
                  BEGIN
                  END;
               END;

            { document is either closed or suspended... now copy it.

            {now copy the document}
            UNBIND_DATASEG(status,lmheaprefnum);
            if mmtrap1 then if status <> 0 then
               writeln('bad return from unbind_dataseg ',status:5);

            CopyDoc(CopyStatus,Pfname,thefilerext.thePrefix,LMHeapLDSN,
                    fcDocCopy,docsize);


            case copystatus of
               0:
                  begin
                  aReply := docXfered;
                  aReason := allOK;
                  end;
               fceoutofdiscSpace:
                  begin
                  aReply := docnotXfered;
                  aReason := noDiskSpace;
                  end;
               fcecantread:
                  begin
                  aReply := docnotXfered;
                  aReason := CantRead;
                  end;
               fcecantwrite:
                  begin
                  aReply := docnotXfered;
                  aReason := cantWrite;
                  end;
               fceNoMemory:
                  begin
                  aReply := docnotXfered;
                  aReason := noMemory;
                  end;
               fceAborted:
                  begin
                  aReply := docnotXfered;
                  aReason := aUserAbort;
                  end;

               OtherWise
                  begin
                  aReply := docnotXfered;
                  aReason := internalError;
                  end;
               END; {case}
            TellFiler(status,aReply,aReason,Folder);
            if mmtrap1 then if status <> 0 then
               writeln('TellFiler status: ',status:4);

            BIND_DATASEG(status,lmheaprefnum);
            if mmtrap1 then if status <> 0 then
               writeln('bad return from bind_dataseg ',status:5);

            {set it up so it will open it up the next activate}
            OpenRequested := true;
            docsopen := docsopen + 1;
            Opentype := mmresume;


            {docclosed on bad opendoc status handled by openthelist}

            END;

      fcput:
            BEGIN
            if MMTRAP1 THEN WRITELN('fcPut event..');
            wouldalert(mymenus[menubuzzword],mbfccopy);


            {the test for fileclosed and openrequested and susdoccalled
             is a test for a situation after a fccopy event}

            if not fileclosed or (fileclosed and openrequested and
                                  (susdoccalled)) then
               begin
               if not fileclosed then
                  BEGIN

                  curtblfont := mmfontinfo.DMPfont;
                  SuspendDocument;
                  susDocCalled := false;
                  fileclosed := true;
                  fldrUpdateOK := false;

                  docsOpen := docsOpen - 1;   { can now accept another document }


                  if fmfontmetrics(curtblfont,finfo,ferror) then ;
                  if mmtrap1 then if ferror <> 0 then
                        writeln('bad call to fmfontmetrics',ferror);

                  FntIdtoItem(curtblfont,oldstyleitem,oldfontitem);
                  checkitem(mymenus[menufont],menustyle,false);
                  checkitem(mymenus[menufont],oldfontitem,false);

                  {file suspended now}
                  END
               ELSE if (fileclosed and openrequested and
                                  (susdoccalled)) then
                  BEGIN
                  {copy preceeded this}
                  OpenRequested := false;
                  susdoccalled := false;
                  END;
               END;

            {doc is now suspended or closed... now copy it}

            {now copy the document}
            UNBIND_DATASEG(status,lmheaprefnum);
            if mmtrap1 then if status <> 0 then
               writeln('bad return from unbind_dataseg ',status:5);

            CopyDoc(CopyStatus,Pfname,thefilerext.thePrefix,LMHeapLDSN,
                    fcDocCopy,docsize);

            case copystatus of
               0:
                  begin
                  aReply := docXfered;
                  aReason := allOK;
                  end;
               fceoutofdiscSpace:
                  begin
                  aReply := docnotXfered;
                  aReason := noDiskSpace;
                  end;
               fcecantread:
                  begin
                  aReply := docnotXfered;
                  aReason := CantRead;
                  end;
               fcecantwrite:
                  begin
                  aReply := docnotXfered;
                  aReason := cantWrite;
                  end;
               fceNoMemory:
                  begin
                  aReply := docnotXfered;
                  aReason := noMemory;
                  end;
               fceAborted:
                  begin
                  aReply := docnotXfered;
                  aReason := aUserAbort;
                  end;

               OtherWise
                  begin
                  aReply := docnotXfered;
                  aReason := internalError;
                  end;
               END; {case}
            TellFiler(status,aReply,aReason,Folder);
            if mmtrap1 then if status <> 0 then
               writeln('TellFiler status: ',status:4);

            BIND_DATASEG(status,lmheaprefnum);
            if mmtrap1 then if status <> 0 then
               writeln('bad return from bind_dataseg ',status:5);


            END;
      fcnone:
            BEGIN
            if mmtrap1 then writeln('fcnone received');
            if mmtrap1 then Writeln('   can''t handle another doc, refusing');
            TellFiler(status,docClosd,noMoreDocs,Event.who);
            if mmtrap1 then if status <> 0 then
               writeln('TellFiler status: ',status:4);
            END;

      fcTerminate:
            BEGIN
            if tracing then IF MMTRAP1 THEN WRITELN('fcTerminate event..');
            if mmtrap1 then if not fileclosed then
               writeln(chr(chbell),'******terminate but not closed ***');
            wouldalert(mymenus[menubuzzword],mbfcterm);
            QuitRequest := true;
            END;

      fcDfClose:
            BEGIN
            TellFiler(status,dfNotClosed,internalError,Event.who);
            if mmtrap1 then if status <> 0 then
               writeln('TellFiler status: ',status:4);
            END;
      END; {case}

   END;

{$S   lmscreen}
Procedure DoFldrUpdate;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {routine called by matrix manager at selected places}
   DoUpdate(folder,true);
   end;

{$S lmmain}
Procedure DoKeyedMove {dir : moveDir;hilite: cellseltype};
   {-------------------------------------------------------------------------}
   {move the selection and current range to the cell indicated by movdir.    }
   {Assumes last cell(if any) has been entered successfully and rg fb removed}
   {-------------------------------------------------------------------------}
   VAR OldRange, newRange: Range;
       MMDir : MCType;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('dokeyedmove');
   OldRange := CurRange;
   Case dir of
      MvRight    : MMDir := MMRight;
      MvLeft     : MMDir := MMLeft;
      MvDown     : MMDir := MMDown;
      MvUp       : MMDir := MMup;
      MvNewRow   : MMDir := MMBegOfRow;
      MvRightPeg : MMDir := MMRightPeg;
      MvLeftPeg  : MMDir := MMLeftPeg;
      MvStay     : NewRange := OldRange;
      END;
   if dir <> MvStay then NextCell(MMDir,OldRange,NewRange);
   curRange := NewRange;
   makergvisible(OldRange, curRange);
   DoSelCR(curRange, curTimeout,selectcell);
   END;



{$S   lmscreen}
PROCEDURE DoUpdate{who:windowptr;drawscroll:boolean};
   VAR
      updatergn : rgnhandle;
      rh,rv:rect;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {handle an update event}
   if PrintProcs then writeln('doupdate');
   setPort(who);
   setOrigin(0,0);


   BeginUpdate(who);
   if not emptyrgn(who^.visrgn) then
      BEGIN
      if who = folder then redrawfldr(who^.visrgn,false,true,drawscroll)
      else if who = scrapfolder then
         begin
         redrawscrap(who^.visrgn,true);
         end
      else ;
      END;
   EndUpdate(who);
   END;



{$S  lmscreen}
Procedure DrawPnlLines;
   VAR frect:rect;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF PrintProcs then writeln('drawpnllines');
   Pennormal;
   GetPnlRect(FolderPnl,frect);
   WITH frect do
      BEGIN
      eraseWav;
      SetPnlPort(FolderPnl);
      pennormal;
      MoveTo(0,wavheight);
      LineTo(right-1,wavheight);
      MoveTo(0,titleheight+wavheight+1);
      LineTo(right-1,wavheight+titleheight+1);
      END;
   END;


{$S lmmain}
PROCEDURE EnterStuff { VAR Status : Integer};
   Label 100;

   var crgkind : rgkind;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {enter a cells value}
   if PrintProcs then Writeln('enterstuff');
   {$IFC tedebug}
   IF tracing then prntrg('curRange',currange);
   {$ENDC}
   status := 0;
   IF tracing then
       begin
       writeln('validcoord',validcoord(curRange),'cellchanged', cellchanged);
       end;

   crgkind := currange.rkind;
   IF crgkind = a1CellRg THEN
      BEGIN
      IF tracing then
          begin
          writeln('validcoord',validcoord(curRange),'cellchanged', cellchanged);
          end;
      IF (Validcoord(curRange) AND CellChanged) OR CellError Then
         BEGIN
         EnterSelection(status);
         if status<>0 then goto 100;
         if CellError then
            BEGIN
            {restore error message};
            Promptstring := ListTitle;
            shoTitle;
            CellError := FALSE;
            END;
         IF creatingtable or redefining then
            BEGIN
            IF (CurRange.lorow = typerow) then
               begin
               ShoNewWid(colkind,CurRange.locol,CurRange.locol);
               fixthumb(folder);
               end;
            END;

         END
      ELSE
         BEGIN
         DumpSel;
         NullCr;
         NewRgImg(curRange);
         END;
      END
   ELSE IF ((crgkind = aRowHedRg ) OR (crgkind = aColHedRg ))  THEN
      BEGIN
      IF  CellChanged then
         BEGIN

         EnterSelection(status);
         IF status <> ok then
            begin
            if mmtrap1 then writeln('enterselection status : ',status);
            GOTO 100;
            end;

         if CellError then
            BEGIN
            {restore error message};
            Promptstring := ListTitle;
            shoTitle;
            CellError := FALSE;
            END;

         IF crgkind = aColHedRg then
            BEGIN
            IF creatingtable  or redefining then
               begin
               ShoNewWid(colkind,CurRange.locol,CurRange.locol);
               fixthumb(folder);
               end;
            ENd;

         END
      ELSE
         BEGIN
         DumpSel;
         NewRgImg(curRange);
         END;
      END;
   if CellError then
      BEGIN
      {restore error message};
      Promptstring := ListTitle;
      shoTitle;
      CellError := FALSE;
      END;
100:
   END;

{$S lmerror}
Procedure ErrSelect{status:integer};

   VAR
       errfile:TAlertFile;
       Errnum : INTEGER;
       editstring : str40;
       FmtString : str40;
       TruncString : str40;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('errselect. status : ',status:5);
   MMErrFile(status,errfile,errnum);
   if errfile = dbcalerts then
      BEGIN
      GetAlert(DBCALERTS,errnum,@PromptString);
      getEchk(curRange.locol,editstring);
      if curtable <> tcolspecs then
         begin
         GetAlert(LMALERTS,FmtIsString,@FmtString);
         TruncString := Copy(FmtString,1,cmin(length(FmtString),40));
         Promptstring := Concat(PromptString,TruncString,' ',editstring);
         end;
      END
   ELSE
      BEGIN
      GetAlert(LMALERTS,errnum,@PromptString);
      END;

   if mmtrap1 then if length(promptstring) = 0 then
     writeln('Null string from getalert. errnum = ', errnum:5);

   shotitle;
   FlashTitle;

   ReSelCR(CurTimeout,PutCaretAtEnd);
   CellError := TRUE;
   END;

(*
{$S lminit}
PROCEDURE ErrTitle;
   VAR rg:range;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   IF PrintProcs then writeln('errTitle');
   IF ErrorList then
      BEGIN
      GetCr(rg);
      RowError(rg);
      shotitle;
      END;
   END;
*)

{$S lmnewtab}
PROCEDURE FillTable{table:tabletype;showlast:boolean;
                    Searchit:boolean;Sortit:boolean};
   VAR
       row,
       col : idtype;
       startRg: Range;        {Initial range for building the table}
       r:rect;




   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {load up the table editor with data}
   if PrintProcs then writeln('filltable');
   CASE table of
      tlist:
         BEGIN
         NullCR;
         NullSel;

         {Load up the list}

         if tracing then writeln('before loadlist');
         LoadList(TblPars,showLast,Searchit,Sortit);
         if tracing then writeln('after  loadlist');

         (*
         IF ErrorList then
            begin
            GetAlert(LmAlerts,ListofErr,@ListTitle);
            PromptString := ListTitle;
            end;
         *)

         shotitle;

         {Get the starting range}
         Getcurpossnip(row,col);

         SetRg(startRg,a1CellRg,Row,Col,Row,Col);
         if tracing then writeln('before rebldtbl');
         ReBldTbl(startRg);
         if tracing then writeln('before tmshonewtbl');
         tmShoNewTbl;

         NullSel;
         NullCr;
         curtimeout := dflttimeout;
         ActivePnl := TblPnl;
         GetCr(curRange);
         FixMenus;
         FixThumb(folder);

         END;
      tSearch:
         BEGIN
         LoadSearch(TblPars);

         NullCR;
         NullSel;
         GetCr(curRange);
         shotitle;
         GetCurPosSnip(Row,Col);
         SetRg(startRg,a1CellRg,Row,Col,Row,Col);
         ReBldTbl(startRg);
         tmShoNewTbl;
         curtimeout := dflttimeout;

         ActivePnl := TblPnl;
         FixMenus;

         FixThumb(folder);
         END;

      tColSpecs:
         BEGIN
         LoadColSpecs(TblPars);

         NullCR;
         NullSel;
         GetCr(curRange);
         shotitle;
         GetCurPosSnip(Row,Col);
         SetRg(startRg,a1CellRg,Row,Col,Row,Col);
         ReBldTbl(startRg);
         tmShoNewTbl;
         IF CreatingTable THEN
            BEGIN
            SetRg(CurRange,aColHedRg,minfSnip,startrg.locol,minfSnip,startrg.locol);

            ActivePnl := TblPnl;
            LastPnl := NullPnl;
            DoSelCR(CurRAnge,CurTimeout,selectContents);
            FixThumb(folder);

            END
         ELSE
            BEGIN
            curtimeout := dflttimeout;
            fixthumb(folder);
            END;

         LastPnl := ActivePnl;
         ActivePnl := TblPnl;
         Fixmenus;
         END;
      otherwise if mmtrap1 then writeln(chr(chbell),'filltable no current table');
      END;{case}
   fldrUpdateok := true;

   {since we just drew the table, validate that part of the table}
   getpnlrect(tblpnl,r);
   adjrect(tblpnl,r);
   setport(folder);
   setorigin(0,0);
   validrect(r);

   END;

{$S lmmain}
Procedure FixMenus;
   VAR
      menuchanged : boolean;
      CInfo: CellRecord;
   begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {add or delete menus as appropriate}
   if PrintProcs then writeln('fixmenus');
   MenuChanged := FALSE;
   IF curtable = tcolspecs then
      begin
      IF tracing then
         begin
         writeln('kind ',ord(currange.rkind),'lorow ',CurRange.lorow:4);
         writeln('typerow,sortrow,visiblerow',typerow:4,sortrow:4,visiblerow:4);
         writeln('curtable ', ord(curtable));
         end;

      IF curRange.rkind = a1CellRg then
         begin
         IF CurRange.lorow = typerow then
            begin
            CellInfo(cRecord,mmread,CurRange.lorow,CurRange.locol,CInfo);
            if somenuup then
               begin
               deletemenu( menusortorder);
               somenuup := false;
               MenuChanged := TRUE;
               end
            ELSE if cvmenuup then
               begin
               deletemenu( menuvisible);
               cvmenuup := false;
               MenuChanged := TRUE;
               end;
            IF NOT dtmenuup   and NOT Cinfo.protected then
               begin
               insertmenu(mymenus[menudtype],0);
               dtmenuup := true;
               MenuChanged := TRUE;
               end
            ELSE if dtmenuup and Cinfo.protected then
               begin
               deletemenu( menudtype);
               dtmenuup := false;
               MenuChanged := TRUE;
               end;
            if opmenuup then
               begin
               deletemenu( menuop);
               opmenuup := false;
               MenuChanged := TRUE;
               end;
            end
         ELSE IF CurRange.lorow = sortrow then
            begin
            if dtmenuup then
               begin
               deletemenu( menudtype);
               dtmenuup := false;
               MenuChanged := TRUE;
               end
            ELSE if cvmenuup then
               begin
               deletemenu( menuvisible);
               cvmenuup := false;
               MenuChanged := TRUE;
               end;
            IF NOT somenuup  then
               begin
               insertmenu(mymenus[menusortorder],0);
               somenuup := true;
               MenuChanged := TRUE;
               end;
            if opmenuup then
               begin
               deletemenu( menuop);
               opmenuup := false;
               MenuChanged := TRUE;
               end;
            end
         ELSE IF CurRange.lorow = Visiblerow then
            begin
            if somenuup then
               begin
               deletemenu( menusortorder);
               somenuup := false;
               MenuChanged := TRUE;
               end
            ELSE if dtmenuup then
               begin
               deletemenu( menudtype);
               dtmenuup := false;
               MenuChanged := TRUE;
               end;
            IF NOT cvmenuup then
               begin
               insertmenu(mymenus[menuvisible],0);
               cvmenuup := true;
               MenuChanged := TRUE;
               end;
            if opmenuup then
               begin
               deletemenu( menuop);
               opmenuup := false;
               MenuChanged := TRUE;
               end;
            end
         ELSE
            begin
            if somenuup then
               begin
               deletemenu( menusortorder);
               somenuup := false;
               MenuChanged := TRUE;
               end
            ELSE if dtmenuup then
               begin
               deletemenu( menudtype);
               dtmenuup := false;
               MenuChanged := TRUE;
               end
            ELSE if cvmenuup then
               begin
               deletemenu( menuvisible);
               cvmenuup := false;
               MenuChanged := TRUE;
               end;
            if opmenuup then
               begin
               deletemenu( menuop);
               opmenuup := false;
               MenuChanged := TRUE;
               end;
            end;
         end {a1cellrg}
      ELSE  {curtable = tcolspecs but not a1cellrg}
         begin

         if somenuup then
            begin
            deletemenu( menusortorder);
            somenuup := false;
            MenuChanged := TRUE;
            end
         ELSE if dtmenuup then
            begin
            deletemenu( menudtype);
            dtmenuup := false;
            MenuChanged := TRUE;
            end
         ELSE if cvmenuup then
            begin
            deletemenu( menuvisible);
            cvmenuup := false;
            MenuChanged := TRUE;
            end
         ELSE if opmenuup then
            begin
            deletemenu( menuop);
            opmenuup := false;
            MenuChanged := TRUE;
            end;
         end;
      end   {curtable = tcolspecs}
   ELSE IF curTable = tSearch then
      begin
      IF CurRange.rkind = a1CellRg then
         BEGIN
         IF NOT opmenuup then
            begin
            insertmenu(mymenus[menuop],0);
            opmenuup := true;
            MenuChanged := TRUE;
            end;
         END
      ELSE
         BEGIN
         if opmenuup then
            begin
            deletemenu( menuop);
            opmenuup := false;
            MenuChanged := TRUE;
            end;
         END; {not a1CellRg}
      if somenuup then
         begin
         deletemenu( menusortorder);
         somenuup := false;
         MenuChanged := TRUE;
         end
      ELSE if dtmenuup then
         begin
         deletemenu( menudtype);
         dtmenuup := false;
         MenuChanged := TRUE;
         end
      ELSE if cvmenuup then
         begin
         deletemenu( menuvisible);
         cvmenuup := false;
         MenuChanged := TRUE;
         end;
      end {curtable = tsearch}
   ELSE
      begin
      if somenuup then
         begin
         deletemenu( menusortorder);
         somenuup := false;
         MenuChanged := TRUE;
         end
      ELSE if dtmenuup then
         begin
         deletemenu( menudtype);
         dtmenuup := false;
         MenuChanged := TRUE;
         end
      ELSE if cvmenuup then
         begin
         deletemenu( menuvisible);
         cvmenuup := false;
         MenuChanged := TRUE;
         end
      ELSE if opmenuup then
         begin
         deletemenu( menuop);
         opmenuup := false;
         MenuChanged := TRUE;
         end;

      end; {curtable <> search <> colspecs}

   if  (curRange.rkind <> aWTBoxRg) then
      begin

      end;

   IF MenuChanged then DrawMenuBar;

   end;

{$S  lmnewtab}
Procedure FixThumb{window:windowptr};

   VAR hsbh,hsbv  : thsb;
       pcth,pctv  : integer;
       oldpcth, oldpctv : integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('fixthumb');


   {move thumb there }
   hsbh := hsbfirst(sblist);
   if tyvhofsb(hsbh) = h then
      begin
      hsbv := hsbnext(hsbh);
      end
   else
      begin
      {switch it to right named one }
      hsbv := hsbh;
      hsbh := hsbnext(hsbv);
      end;

   oldpcth := cThumbPos(hsbh);
   oldpctv := cThumbPos(hsbv);
   if tracing then writeln('old pcts h,v  ',oldpcth:4,oldpctv:4);

   CalcThumb(TRUE,PctH);
   CalcThumb(FALSE,PctV);
   if tracing then writeln('new pcts h,v  ',pcth:4,pctv:4);

   if  (pcth <> oldpcth) or (pctv <> oldpctv) then
      begin
      setport(window);
      setorigin(0,0);
      pennormal;
      rectrgn(window^.cliprgn,window^.portrect);
      if pctv <> oldpctv then
         begin
         setupmvthumb(hsbv);
         movethumb(pctv);
         end;

      if pcth <> oldpcth then
         begin
         setupmvthumb(hsbh);
         movethumb(pcth);
         end;
      end;

   if tracing then writeln('exiting  fixthumb');

   END;

{$S lmerror}
PROCEDURE FlashTitle;
   VAR
       r : rect;
       i:integer;
       lasttime : integer;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {beep and flash the title panel }
   IF PrintProcs then writeln('flashTitle');
   IF cautionalert(lmalerts,beepit) then ;
   GetPnlRect(titlePnl,r);
   SetPnlPort(TitlePnl);
   For i := 1 to 3 do
      begin
      Invertrect(r);
      lasttime := time;

      repeat
         begin
         end;
      until abs(time - lasttime)>12;
      end;

   END;

{$S lmnewtab}
Procedure FlushUpdates{ VAR fStatus : Integer};
   Label 100;
   var sstate : scstate;
       status : integer;
       badrow : idtype;
       badcol : idtype;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {enter the current cell ; update the row ; call writelist or appropriate routine}
   if PrintProcs then writeln('flushupdates');
   EnterStuff(fstatus);
   IF fstatus <> 0 then
      BEGIN
      ErrSelect(fstatus);
      GOTO 100;
      END;
   IF CurTable = TList THEN
      BEGIN
      UpdateRow;
      {since we are going to load a new table, we wont update thumb}
      IF curRgList then RelcRgList;
      END;
   NullCR;

   IF curTable = tColSpecs then
      BEGIN
      NullCR;
      NullSel;
      GetCr(CurRange);
      FixMenus;
      IF CreatingTable THEN
         BEGIN
         if columnscut then clearscrap(status);
         CreateListFile(@PFname,fStatus);
         IF fStatus <> 0 THEN GOTO 100;
         END

      ELSE IF ReDefining THEN
         BEGIN
         if columnscut then clearscrap(status);

         reCreateListFile(fStatus);
         IF fStatus <> 0 THEN
            BEGIN
            FixThumb(folder);
            GOTO 100;
            END;

         END

      ELSE
         BEGIN
         ChangeColSpecs(fStatus);
         IF fStatus <> 0 THEN GOTO 100;
         END;
      END

   ELSE IF curTable = tSearch then
      BEGIN
      NullCR;
      NullSel;
      GetCr(CurRange);
      FixMenus;
      ChangeSrch(fstatus,badrow,badcol);
      if fstatus <> 0 then
         begin
         if mmtrap1 then writeln('changesearch error ');
         with currange do
           begin
           rkind := a1cellrg;
           lorow := badrow;
           hirow := badrow;
           locol := badcol;
           hicol := badcol;
           end;
         setcr(currange);
         doselcr(currange,curtimeout,putcaretatend);
         errselect(fstatus);
         goto 100;
         end;

      END

   ELSE IF CurTable = TList THEN
      BEGIN
      GetCr(CurRange);
{u} { if ColumnsCut or RowsCut then ClearScrap(status);}
      WriteList(fStatus);
      IF fStatus <> 0 THEN GOTO 100;

      END;
   fSTatus := 0;
   fldrUpdateOK := false;

   {save time of last post}
   Get_Time(status,GMTPostTime);
   if mmtrap1 then if status<> 0 then writeln('get_time status',status);


100:
   if Tracing then writeln('Flushupdates status',fstatus);
   END;


{$S lmfontme}
PROCEDURE FontChange{oldfntid,newfntid:tlfntid};
   VAR
      status : integer;
      finfo : fontinfo;
      oldh:integer;
      sysfntid : tlfntid;
      r:rect;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {change the displayed table font from old to new}
   if PrintProcs then writeln('fontchange');
   {uncheck old first get fontid then figure out which item then uncheck}

   if tracing then
      begin
      writeln('old fam ',oldfntid.fam, 'old dev ',oldfntid.dev);
      writeln('new fam ',newfntid.fam, 'new dev ',newfntid.dev);
      end;

   if oldfntid.fam = newfntid.fam then exit(fontchange);

   if fmfontmetrics(oldfntid,finfo,status) then ;
   if mmtrap1 then if status <> 0 then
      writeln('fmfontmetrics old fntid returns ',status);
   oldh := finfo.widmax+1;

   if fmfontmetrics(newfntid,finfo, status) then;

   if mmtrap1 then if status <> 0 then
       writeln('fmfontmetrics newfntid returns ',status);

   With finfo do
   PutTableFont(newfntid,widmax+1,ascent+descent+leading,status);

   if status <> 0 then
      begin
      {couldn't put font because insufficient memory}

      if Cautionalert(lmalerts,fontmemerr) then ;

      {fix up panels and col widths etc}
      if  fmfontmetrics(oldfntid,finfo,status) then ;
      if mmtrap1 then if status <> 0 then writeln('fmfontmetrics returs',status);
      end
   ELSE
      BEGIN
      END;

   {fix panels here }
   with finfo do
   wavheight := ascent+descent+leading+4;

   with sysfntid do
      begin
      fam := systext;
      seteface := [];
      dev := devscreen;
      end;

   if fmfontmetrics(sysfntid,finfo,status) then;
   if mmtrap1 then if status <> 0 then
        writeln('fmfontmetrics returns  ',status);

   with finfo do
   titleheight := ascent+descent+leading+4;


   adjPnls(folder^.portrect.botright);
   drawPnlLines;
   shotitle;

   {tell selection mgr about new font for current cell}
   changecellfont;

   tmresize;
   if (curRange.rkind = a1cellrg) OR (CurRange.rkind=aColhedRg) OR
      (curRange.rkind = aRowHedRg)  then redrawsel(true);
   restorergfb(curtimeout);
   tmredoviews;

   {since we just drew the table, validate that part of the table}
   getpnlrect(tblpnl,r);
   adjrect(tblpnl,r);
   setport(folder);
   setorigin(0,0);
   validrect(r);
   END;


{$S lmscreen }
PROCEDURE FntidToItem{fntid:tlfntid; VAR StyleItem, FontItem:integer};
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {take a fontid and return the menu items for checking it corresponds to}
   if PrintProcs then writeln('fntidtoitem');

   case fntid.fam of

      p20tile:
         BEGIN
         styleitem := mmodern;
         fontitem := m08x20;
         END;

      p15tile:
         BEGIN
         styleitem := mmodern;
         fontitem := m08x15;
         END;

      p12tile:
         BEGIN
         styleitem := mmodern;
         fontitem := m10x12;
         END;

      p10tile:
         BEGIN
         styleitem := mmodern;
         fontitem := m12x10;
         END;

      p12cent:
         BEGIN
         styleitem := mclassic;
         fontitem := m10x12;
         END;

      p10cent:
         BEGIN
         styleitem := mclassic;
         fontitem := m12x10;
         END;

      otherwise
         BEGIN
         styleitem := mmodern;
         fontitem := m10x12;
         END;

      end;{case}

   END;


{$S lmmain}
Procedure HiliteEdits;
   VAR
       sstate : scstate;
       status:integer;
       styleitem:integer;
       fontitem:integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {gray or ungray the menu items appropriately}
   if PrintProcs then writeln('hiliteEdits');
   CopyOk := TRUE;
   CutOK := TRUE;
   UndoOk := TRUE;
   PasteOK := TRUE;
   RestoreOK := TRUE;
   UndoAllOK := TRUE;
   ClearOK := TRUE;
   SrchOK := True;
   SelRowOk := TRUE;
   SelTblOK := TRUE;
   ordentok := true;
   ordsrchok := true;
   ColSpcOK := TRUE;
   RecoverOk := TRUE;
   ChgFileOk := TRUE;
   SaveContOk := TRUE;                                              {#178}
(*
   {font menu hilites}
   classicok := TRUE;
   font20_OK := TRUE;
   font15_OK := TRUE;

   {find out what is currently selected}
   fntidtoitem(mmfontinfo.DMPfont,styleitem,fontitem);
   if styleitem = mclassic then
     begin
     font20_OK := FALSE;
     font15_OK := FALSE;
     end
   else if (fontitem = m08x20) or (fontitem = m08x15) then classicOK := FALSE;
*)
   if CreatingTable or Redefining then
      begin
      SrchOK := False;
      SelRowOK := False;
      ordsrchok := false;
      ordentok := false;
      ColSpcOk := False;
      RecoverOk := False;
      ChgFileOk := FALSE;
      SaveContOk := FALSE;                                   {#178}
      end;


   lookatscrap(sstate,status);

   if status = 0 then
      begin
      if columnscut and NOT ((creatingtable or redefining) or (curtable = tlist)) then
         BEGIN
         cutOk := false;
         copyOk := false;
         END;

      if (sstate = scempty) or (SState = scNotMine) then pasteok := FALSE;
      end
   else
      begin
      cutok := false;
      copyok := false;
      pasteok := false;
      end;

   case curRange.rkind of

      anullrg:
         BEGIN
         CopyOk := FALSE;
         CutOK := FALSE;
         UndoOk := FALSE;
         PasteOK := FALSE;
         RestoreOK := FALSE;
         ClearOK := FALSE;
         END;

      aColHedRg,
      aRowHedRg:
         BEGIN
         if (curtable = tcolspecs)  and (currange.rkind = acolhedrg) then
            begin
            if (sstate <> scfield) then pasteok := false;
            end
         else
            begin
{u}         CopyOK := FALSE;
            CutOK := FALSE;
            PasteOK := FALSE;
            UndoOK := FALSE;
            RestoreOK := FALSE;
            ClearOK := FALSE;
            end;

         END;

      a1cellRg:
         BEGIN
         if (curtable = tcolspecs ) and (curRange.lorow = typerow) and NOT
             (creatingTable or redefining) then
            begin
            CutOK := FALSE;
            UndoOk := FALSE;
            PasteOK := FALSE;
            RestoreOK := FALSE;
            ClearOK := FALSE;
            end;
         END;

{u}   aRectRg:
         BEGIN
            UndoOk := FALSE;
            RestoreOK := FALSE;
         END;

      aRowRg:
         BEGIN
         if (curtable = tlist)  then
            begin
            UndoOk := FALSE;
            RestoreOK := FALSE;
            end
         else if curtable = tcolspecs then
            begin
            CopyOk := FALSE;
            CutOK := FALSE;
            UndoOk := FALSE;
            PasteOK := FALSE;
            RestoreOK := FALSE;
            if (curRange.lorow = curRange.hirow) and (CurRange.lorow = sortrow) then
               ClearOk := true
            else  ClearOk := FALSE;
            end
         else if curtable = tsearch then
            begin
            CopyOk := FALSE;
            CutOK := FALSE;
            UndoOk := FALSE;
            PasteOK := FALSE;
            RestoreOK := FALSE;
            end
         else
            begin
            CopyOk := FALSE;
            CutOK := FALSE;
            UndoOk := FALSE;
            PasteOK := FALSE;
            RestoreOK := FALSE;
            ClearOk := FALSE;
            end;

         END;

      aColRg:
         BEGIN
         if (curTable = tcolspecs)  then
            begin
            CopyOk := FALSE;
            UndoOk := FALSE;
            PasteOK := FALSE;
            RestoreOK := FALSE;
            ClearOK := FALSE;
            end
         else
            begin
{u}         CopyOk := {FALSE} TRUE;
            CutOK := FALSE;
            UndoOk := FALSE;
{u}       { PasteOK := FALSE; }
            RestoreOK := FALSE;
{u}       { ClearOK := FALSE;}
            end;
         END;

      aRowGrid,
      aColGrid:
         BEGIN
         CopyOk := FALSE;
         CutOK := FALSE;
         UndoOk := FALSE;
         RestoreOK := FALSE;
         ClearOK := FALSE;
         if (CurRange.rkind = aColGrid) and NOT ColumnsCut then pasteok := false;
         END;


      aWTBoxRg:
         BEGIN
         if (curtable = tsearch) or (curtable = tcolspecs) then
            begin
            CopyOk := FALSE;
            UndoOk := FALSE;
            PasteOK := FALSE;
            RestoreOK := FALSE;
            CutOK := FALSE;
            if curTable = tcolspecs then clearok := false;
            end
         else
            begin
            UndoOk := FALSE;
            RestoreOK := FALSE;
            end;
         END;

      END; {case}
(*
   DisEnaItem(menufont,mclassic  ,not classicok   );
   DisEnaItem(menufont,m08x20  ,not font20_OK    );
   DisEnaItem(menufont,m08x15    , not font15_OK  );
*)
   DisEnaItem(menuedits,clear  ,not clearok   );
   DisEnaItem(menuedits,copym  ,not copyok    );
   DisEnaItem(menuedits,cut    , not cutok  );
   DisEnaItem(menuedits,pastem ,not pasteok    );
   DisEnaItem(menuedits,rstorig,not restoreok );
   DisEnaItem(menuedits,seltbl,not seltblok );
   DisEnaItem(menuedits,undo   ,not undook  );
   DisEnaItem(menufile,undoall,not undoallok     );
   DisEnaItem(menushow   ,mssearch,not srchok   );
   DisEnaItem(menushow   ,msselrows,not selrowok   );
   DisEnaItem(menushow   ,mssrchord,not ordsrchok   );
   DisEnaItem(menushow   ,msorder,not ordentok   );
   DisEnaItem(menushow   ,mscolspecs,not colspcok   );
   DisEnaItem(menushow   ,ChangeFile,not ChgFileOk   );
   DisEnaItem(menufile,recover,not recoverok   );
   DisEnaItem(menufile,AcceptAll,not SaveContOk   );                {#178}

   END;


{$S lminit}
Procedure InitMSpecs;
   {-------------------------------------------------------------------------}
   {Initialize move specifications                                           }
   {                                                                         }
   {-------------------------------------------------------------------------}
   VAR i : integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('initmspecs');
   With MoveSpecs[0] do
      BEGIN
      keys.key := CHR(chTabkey);
      keys.keyheld := noKey;
      direction := Mvright;
      END;
   With MoveSpecs[1] do
      BEGIN
      keys.key := CHR(chReturn);
      keys.keyheld := noKey;
      direction := MvNewRow;
      END;
   With MoveSpecs[2] do
      BEGIN
      keys.key := CHR(chTabkey);
      keys.keyheld := ShiftKey;
      direction := MvLeft;
      END;
   With MoveSpecs[3] do
      BEGIN
      keys.key := CHR(chReturn);
      keys.keyheld := ShiftKey;
      direction := MvNewRow;
      END;
   With MoveSpecs[4] do
      BEGIN
      keys.key := CHR(chEnter );
      keys.keyheld := noKey;
      direction := MvStay;
      END;
   With MoveSpecs[5] do
      BEGIN
      keys.key := CHR(chLArrow );
      keys.keyheld := noKey;
      direction := MvLeftPeg;
      END;
   With MoveSpecs[6] do
      BEGIN
      keys.key := CHR(chRArrow );
      keys.keyheld := noKey;
      direction := MvRightPeg;
      END;
   With MoveSpecs[7] do
      BEGIN
      keys.key := CHR(chUArrow );
      keys.keyheld := noKey;
      direction := MvUp;
      END;
   With MoveSpecs[8] do
      BEGIN
      keys.key := CHR(chDarrow );
      keys.keyheld := noKey;
      direction := MvDown;
      END;
   For I := 9 to maxMoves do
      With MoveSpecs[i] do
         BEGIN
         keys.key := 'z';
         keys.keyheld := cmdKey;
         direction := noMove;
         END;
   END;


{$S lmscrap}
Procedure LLDrawScrap{rgtype:rgkind};
label 99;

const
  DS = 'LLDrawScrap';

var
  row : idType;
  col : idType;
  rowband : tmband;
  colband : tmband;
  atmstate : tmstate;
  startrg : range;
  r : rect;
  bigrect : rect;
  scrapport : rect;
  temphz : thz;
  sstat : integer;
  scraptype : scstate;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  sstat := 0;
  if mmtrap1 then writeln(ds);

  {By this time, setscrap has been called and the old scrap data/picture erased; picturehdl is NIL}
  { and the new Scrapdata is there.  Get ready to put a QD picture in the scrap data segment      }
  StartPutScrap(sstat);
  if sstat <> 0 then
     begin
     if mmtrap1 then writeln('LLDrawScrap; startputscrap error ',sstat);
     exit(LLDrawScrap);
     end;

  setrect(bigrect,0,0,720,364);         {define a rectangle of maximum size}

  setport(scrapfolder);                 {set port to scrap and set origin to zero}

  {have QuickDraw use the scrap heap for picture}
  TempHZ := theheap;
  theheap := hzofscrap;

  {start recording picture}
  PictureHdl := OpenPicture(bigrect);   {start recording picture}

  setorigin(0,0);                                 {set origin to zero}
  cliprect(scrapfolder^.portrect);                {have scrap cliprgn sized to scrap portrect}

  {change panel size to bigrect}
  chgpnlsize(scrappnl,bigrect.right-dhsbox+1,bigrect.bottom-dvsbox+1);
  setpnlport(scrappnl);
  getpnlrect(scrappnl,r);               {clear scrap panel}
  eraserect(r);

  savetable(rowband,colband,atmstate);          {save TE table information}

  if rgtype = arectrg then LoadCut_RectRg(Tblpars)              {load scrap data}
  else if (rgtype = arowrg) or (rgtype = aWTBoxRg) then LoadCutRows(Tblpars)
       else if rgtype = acolrg then LoadCutCols(Tblpars);

  TblPnl:= cScrapPnl;                           {set panel port to scrap panel}
  SetPnlPort(tblPnl); {really the scrap}
  GetSnipId(rowkind,MMfirst,0,Row,Row);         {get upper left cell of range}
  GetSnipId(colkind,MMfirst,0,Col,Col);
  SetRg(startRg,a1CellRg,Row,Col,Row,Col);
  {$IFC tedebug}
  IF tracing then prntrg('startrg',startrg);
  {$ENDC}

  ReBldTbl(StartRg);                            {rebuild table and display}
  tmShoNewTbl;
  if rgtype = arectrg then Un_LoadCutRectRg(Tblpars)            {unload scrap stuff}
  else if (rgtype = arowrg) or (rgtype = aWTBoxRg) then UnLoad_CutRows(Tblpars)
       else if rgtype = acolrg then UnLoadCutCols(Tblpars);

  TblPnl := cTblPnl;
  SetPnlPort(tblPnl);{back to table}            {set panel port back to table}
  loadtable(rowband,colband,atmstate);          {restore TE structures}

 {restorergfb(curtimeout);}

  setport(folder);
  setorigin(0,0);

  setport(scrapfolder);
  {stop recording picture}
  ClosePicture;

  {restore the heap}
  theheap := tempHZ;

  {if picture generated was bigger than 32K, don't draw it}
  if picturehdl^^.picsize < 0 then
    begin
    if cautionalert(lmalerts,noscrappic) then ;
    {done with scrap data segment}
    EndPutScrap(sstat);
    if sstat <> 0 then if mmtrap1 then writeln('LLDrawScrap; endputscrap 1 error ',sstat);
    end
  else
    begin

    {done with scrap data segment}
    EndPutScrap(sstat);
    if sstat <> 0 then
       begin
       if mmtrap1 then writeln('LLDrawScrap; endputscrap error ',sstat);
       goto 99;
       end;

    setport(scrapfolder);               {set port to scrap and set origin to zero}
    scrapport := scrapfolder^.portrect;
    cliprect(scrapport);                  {have scrap cliprgn sized to scrap portrect}

    {change panel size to scrap cliprgn}
    chgpnlsize(scrappnl,bigrect.right-dhsbox+1,bigrect.bottom-dvsbox+1);
    setpnlport(scrappnl);
    getpnlrect(scrappnl,r);               {clear scrap panel}
    eraserect(r);

    {Bind scrap data segment to display picture from it}
    StartPutScrap(sstat);
    if sstat <> 0 then
       begin
       if mmtrap1 then writeln('LLDrawScrap; startPutscrap 2 error ',sstat);
       end
    else
      begin
      tempHZ := theheap;
      theheap := hzofscrap;

      DrawPicture(picturehdl,picturehdl^^.picframe);

      theheap := tempHZ;
      EndPutScrap(sstat);
      if sstat <> 0 then
        begin
        if mmtrap1 then writeln('LLDrawScrap; EndPutscrap error ',sstat);
        end;

      end;
    end;      {picsize < 0}
99:
  hideSborder(scrapport);                         {hidescrollbars on scrapfolder portrect}
  setport(folder);
  setorigin(0,0);

end;


{$S lmnewtab}
PROCEDURE LoadTable{ rowband,colband:tmband;atmstate:tmstate};
   var aband : tmband;

   Begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {load up table editor data structures from a saved version}
   if tracing then writeln('loadtable');
   tmNewpars;
   tmloadbands;

   tmloadnextband(rowband);

   tmloadnextband(colband);

   aband.tmbloid := nullsnip;
   tmloadnextband(aband);

   tmloadstate(atmstate);

   end;


{$S lmmain}
Procedure LookAtScrap{var scrapstate:scstate;var lsstatus:integer};

   VAR
      scrapwhich : scraptype;
      scrapwhat  : th;
      scraphnd : scrrechnd;
      status : integer;
      contents : TB;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {examine the scrap}
   lsstatus := 0;
   if PrintProcs then writeln('lookatscrap');

   GetScrap(scrapwhich,scrapwhat);
   scraphnd := pointer(ord(scrapwhat));

   if not fileclosed and (scrapwhich <> scraplist)  then
      begin
      {release stuff}
      if tracing then writeln('releasing scrap - clobbered');
      relscrap;
      end;

   case scrapwhich of

       ScrapFE: scrapstate := scfield;
       ScrapList: scrapstate := sclist;
       ScrapNil:
             BEGIN
             {check for existence of univ text; no app specific text}
             getCsScrap(contents);
             if contents > 0 then scrapstate := sclist
             else scrapstate := scempty;
             END;
       otherwise
             begin
             getCsScrap(contents);
             if contents > 0 then scrapstate := sclist
             else scrapstate := scNotMine;
             end;

       END;

   if tracing then writeln(' lookatscrap returns ',ord(scrapstate));

   end;


(*
{$S lmmain}
Procedure LookAtScrap{var scrapstate:scstate;var lsstatus:integer};
   VAR
      scrapwhich : scraptype;
      scrapwhat  : th;
      scraphnd : scrrechnd;
      status:integer;
      contents : TB;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {examine the scrap}
   if PrintProcs then writeln('lookatscrap');

   GetScrap(scrapwhich,scrapwhat);
   scraphnd := pointer(ord(scrapwhat));

   if not fileclosed and (scrapwhich <> scraplist)  then
      begin
      {release stuff}
      if mmtrap1 then writeln('releasing scrap - clobbered');
      relscrap;
      end;


   case scrapwhich of

       ScrapFE: scrapstate := scfield;
       ScrapNil:
             BEGIN
             {check for existence of univ text; no app specific text}
             getCsScrap(contents);
             if contents > 0 then scrapstate := scField
             else scrapstate := scempty;
             END;
       scrapList:
             BEGIN
             StartGetScrap(status);
             if status <> 0 then
                begin
                if mmtrap1 then writeln('startgetscrap error ',status);
                lsstatus:= status;
                scrapstate := scnotmine;
                exit(lookatscrap);
                end;

             if scraphnd^^.scraphas = schasrows then scrapstate := scrows

             ELSE if scraphnd^^.scraphas = schascols then scrapstate := sccols

             ELSE if scraphnd^^.scraphas = schasrectrg then scrapstate := screctrg

             ELSE if mmtrap1 then writeln('lookatscrap unknown list scrap');

             EndGetScrap(status);
             if status<> 0 then
                begin
                if mmtrap1 then writeln('endgetscrap error ',status);
                lsstatus := status;
                scrapstate := scnotmine;
                exit(lookatscrap);
                end;
             END;
       otherwise
             begin
             getCsScrap(contents);
             if contents>0 then scrapstate := scfield
             else scrapstate := scNotMine;
             end;


       END;

   if tracing then writeln(' lookatscrap returns ',ord(scrapstate));
   lsstatus := 0;

   end;
*)


{$S lmmain}
Procedure MakeRgVisible{oldRange,newRange:range};

   VAR  rowband,colband :tmband;
        atmstate: tmstate;
        skind : selkind;
        P:point;
        nrgkind:rgkind;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {ensure newrange is on the screen}
   if PrintProcs then writeln('makergvisible');
   tmcurvwpt(p);
   nrgkind := currange.rkind;

   if (((nrgkind = a1CellRg) and
       NOT (snipAllInBand(rowkind,p.v,newrange.lorow) AND
           snipAllInBand(colkind,p.h,newrange.locol))) OR

      (((nrgkind = aRowRg) or (nrgkind = aRowhedRg)) and
       NOT (snipallInBand(rowkind,p.v,newrange.lorow))) OR

      (((nrgkind = aColRg) or (nrgkind = aColhedRg)) and
       NOT (snipallInBand(colkind,p.h,newrange.locol)))) then
      BEGIN
      if tracing then
         begin
         writeln('*** currg not visible  - curvwpt :',p.h:4,p.v:4);
         {$IFC tedebug}
         prntrg('newrange',newrange);
         {$ENDC}
         writeln('row in band: ',snipallinband(rowkind,p.v,newrange.lorow),
                 'col in band: ',snipallinband(colkind,p.h,newrange.locol));
         end;


      IF curRgList then
         begin
         savetable(rowband,colband,atmstate);
         LoadCr;

         rowband.tmbloid := newRange.lorow;
         loadtable(rowband,colband,atmstate);


         getselkind(skind);
         if (skind = a1CellSl) or (skind = arowrgsl) or (skind = acolrgsl) then
                 tmsetrgfb(newRange,Tblpars.marquee)
         else tmsetrgfb(newRange,false);
         scrolling := true;
         shonewrg(oldrange,newrange,nearj);
         scrolling := false;
         tmshonewtbl;
         fixthumb(folder);
         end

      else
         begin
         scrolling := true;
         shonewrg(oldrange,newrange,nearj);
         scrolling := false;
         FixThumb(Folder);
         end;
      END;
   END;

{$S lmmain}
PROCEDURE MenuCommand{menu, item: INTEGER};
  {-----------------------------------------------------------------------}
  {           This procedure implements the semantics associated with     }
  {             a particular menu item.                                   }
  {-----------------------------------------------------------------------}

  BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
  if PrintProcs then writeln('menucommand');
  IF item <> 0 then
     BEGIN
     wouldAlert(mymenus[menu],item);

     CASE menu OF


       menuFile:      FileMenu(item);

       MenuEdits:     EditMenu(item);

       {$IFC fexecdebug }

       MenuTrace:     TraceMenu(item);

       {$ENDC }

       MenuShow:      ShowMenu(item);

       MenuSortOrder: SortMenu(item);

       MenuVisible:   ColVisMenu(item);

       MenuDType:     DTypeMenu(item);

       MenuOP :       OpMenu(item);


       MenuFont :     FontMenu(item);

       MenuSfile:     ScrapMenu(item);


       END;
     END;

  hilitemenu(0);{unhilite down inverted menu }
  (*drawmenubar;*)

  {residency stuff}

  ldtmgr;

  END;

{$S lmmain}
Function MoveAction {ch : char}{:Movedir};
   {-------------------------------------------------------------------------}
   {Inspect the last key pair typed in and return the direction it implies   }
   {If not a move key return nomove. Ch is a dummy so its clear its a fcn    }
   {-------------------------------------------------------------------------}
   VAR
        i : integer;
        keyheld : holdkey;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('moveaction');
   MoveAction := nomove;
   if theEvent.shiftkey  THEN keyHeld := shiftkey
   else if theEvent.applekey then keyheld := cmdkey
   else if theEvent.codekey Then keyHeld := specKey
   else KeyHeld := nokey;

   i := 0;
   while i < maxmoves do
     begin
     If (theEvent.Ascii = moveSpecs[i].keys.key  ) AND
        (keyheld  = moveSpecs[i].keys.keyheld  )
            Then MoveAction := moveSpecs[i].direction;
     i := i+1;
     end;
   END;

{$S lmmain}
FUNCTION NewRow{Move:Movedir;Crg:range): BOOLEAN} ;
   VAR
       firstc,lastc: idtype;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {does move move into a new row?}
   if PrintProcs then writeln('newrow');
   IF CreatingTable  or Redefining then NewRow := False
   ELSE IF MOVE = MvRight then
      BEGIN
      GetSnipId(colkind,MMNext,0,Crg.locol,lastc);
      IF lastc = PInfSnip then NewRow := True
      ELSE NewRow := FALSE;
      END
   ELSE IF Move = MvLeft then
      BEGIN
      GetSnipId(colkind,MMPrior,0,Crg.locol,firstc);
      IF firstc = MinfSnip then newRow := True
      ELSE NewRow := FALSE;
      END
   ELSE IF Move in  [MvNewRow,MvUp,MvDown] then NewRow := TRUE
   ELSE NewRow := FALSE;
   END;


{$S  lmmain}
FUNCTION NewRowPt{P:Point; CRg: Range) : BOOLEAN};
   VAR
       Tpart : TblPart;
       R1,R2 : Rect;
       NRg : Range;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {does mouse down move into a new row?}
   if PrintProcs then writeln('newrowpt');
   IF CreatingTable or Redefining then NewRowPT := False
   ELSE
      BEGIN
      FindTblPt(P,Tpart,NRg,R1,R2);
      IF (NRg.rkind <> a1CellRg) OR (NRg.lorow <> CRg.lorow) then NewRowPt := TRUE
      ELSE NewRowPt := FALSE;
      END;
   END;

{$S lmfiler }
Procedure packSusData{hndsusdata:hnddata;offset:integer;curlen:integer;
                       var leninstalled:integer; var newlen:integer};

   VAR sdp : susdataPtr;
       rowband,
       colband : tmband;
       atmstate:tmstate;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {construct suspend information}
   if PrintProcs then writeln('packsusdata');

   lenInstalled := sizeOF(susdata);
   {make space for this stuff}
   IF (curlen-offset)< lenInstalled then
      BEGIN
      {expand handle}
      ChangeSizeH(hzFromH(POINTER(ORD(hndsusdata))),POINTER(ORD(hndsusdata)),
                  curlen+LenInstalled);
      newlen := curlen + lenInstalled;
      END
   ELSE newlen := curlen;
   savetable(rowband,colband,atmstate);
   sdp := Pointer(ord(hndsusdata^)+offset);
   With sdp^ do
      BEGIN
      sCurtimeout    := CurTimeout;
      sCurnbrhood    := CurNbrhood;
      sCurRange      := CurRange;
      sActivePnl     := ActivePnl;
      sLastPnl       := LastPnl;
      sWholeSelected := WholeSelected;
      sCellError     := CellError;
      sDtMenuUp      := DtMenuUp;
      sSoMenuUp      := SoMenuUp;
      sCvMenuUp      := CvMenuUp;
      sOpMenuUp      := OpMenuUp;
      sRowBand       := RowBand;
      scolBand       := ColBand;
      sTblPars       := Tblpars;
      sLastshowitem  := lastshowitem;
      sTmState       := atmstate;
      sGMTPostTime   := GMTPostTime;
      END;

   END;

(*
{$S lmfontme}
PROCEDURE PreftoFntid{PrintPreference:TprPrf;aDMPfont:tlfntid;
                                             VAR Mappedfont:tlfntid;
                                             VAR flqp: boolean;
                                             VAR propwheel:boolean;
                                             VAR famchanged:boolean;
                                             VAR widchanged:boolean};
   VAR
       olddspfont,
       newdspfont:tlfntid;
       status : integer;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {map a print preference to a long font id}
   if Printprocs then writeln('preftofntid');

   {if dot matrix printer DMP font is the font}
   {also, only if 'same as printer' is checked do we do anything with the
    table font}

   PrTyper(printpreference,flqp,propwheel);

   IF NOT flqp then
      BEGIN
      MappedFont := aDMPfont;
      famchanged := false;
      widchanged := false;
      propwheel := false;
      if tracing then writeln('not an lqp');
      exit(PreftoFntid);
      END;

   {
   IF NOT fileclosed and NOT(printfont in mmfontinfo.fontoptions) then
      BEGIN
      MappedFont := aDMPFONT;
      famchanged := false;
      widchanged := false;
      if tracing then writeln('not printfont');
      exit(PreftoFntid);
      END;
    }



   IF propwheel then
      BEGIN
      MappedFont := aDMPFONT;
      famchanged := false;
      widchanged := false;
      Prsubfont(printpreference,false);
      PutPrintPref(PrintPreference);
      if tracing then writeln('propwheel');
      exit(PreftoFntid);
      END
   ELSE
      BEGIN
      {LQP and not proportional only wheel}
      {if it matches in fam and width -- perfect}
      {if it doesn't match return famchanged or widchanged along with
        the fontid of substituted font as returned from prprftolfntid}

      if tracing then writeln('lqp and not proportional');
      Prsubfont(printpreference,true);
      PutPrintPref(PrintPreference);
      PrLfntid(printpreference,admpfont.fam,[],mappedfont);
      if tracing then writeln(' ->fam = ',mappedfont.fam, 'dev = ',mappedfont.dev);

      FMMapFont(mappedfont,status);
      if tracing then
         begin
         writeln('<-fam = ',mappedfont.fam, 'dev = ',mappedfont.dev);
         if status <> 0 then writeln('fmmapfont returns ',status);
         end;

      mappedfont.dev := devScreen;

      if admpfont.fam = mappedfont.fam then
         begin
         famchanged := false;
         widchanged := false;
         end
      else
         begin
         case admpfont.fam of
            p15tile,
            p12tile,
            p10tile:  case mappedfont.fam of
                         p15tile,
                         p12tile,
                         p10tile:
                            begin
                            widchanged := true;
                            famchanged := false;
                            end;
                         otherwise
                            begin
                            widchanged := true;
                            famchanged := true;
                            end;
                         end;

            p12cent:  begin
                      if (mappedfont.fam = p12tile) then widchanged := false
                      else widchanged := true;
                      famchanged := true;
                      end;


            p10cent:  begin
                      if (mappedfont.fam = p10tile) then widchanged := false
                      else widchanged := true;
                      famchanged := true;
                      end;
            end;
         end;
      END;
   if tracing then writeln('famchanged, widchanged ',famchanged, widchanged);
   END;
*)

{$S lmfiler}
PROCEDURE PutSusData{VAR hndsusdata:hnddata; var Len:integer};
   type  ia = Array[0..0] of INTEGER;
         pia = ^ia;

   var
      offset:integer;
      leninstalled : integer;
      poffset : pia;
      i:integer;
      curlen: Integer;
      newlen: integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {construct all suspend data}{called by matrix manager }
   if PrintProcs then writeln('putsusdata');
   {allocate the handle with space for offset records}
   i := 0;
   Len := numsusblocks*sizeOF(INTEGER);
   hndsusdata := POINTER(ORD(hallocate(theHeap,len)));

   {allocate space for the record}

   offset:= len;
   curlen := len;
   poffset := POINTER(ORD(hndsusdata^));
   poffset^[i] := offset;

   packsusdata(hndsusdata,offset,curlen,leninstalled, newlen);

   i := i + 1;
   len := len + leninstalled;
   offset := len;
   curlen := newlen;
   poffset := POINTER(ORD(hndsusdata^));
   poffset^[i] := offset;

   packSmgr(hndsusdata,offset,curlen,leninstalled,newlen);
   len := len + leninstalled;
   offset := len;
   curlen := newlen;


   END;


{$S  lmscreen }
Procedure redrawFldr{UpdateRgn:rgnHandle; resize:boolean;paint:boolean;drawscroll:
                      boolean};

   VAR resrgn:rgnhandle;
       frect:rect;
       hsbv,hsbh:thsb;
       r,rh,rv : rect;
       newh,newv : integer;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {redraw the folder based upon the parameters}
   {relevant globals are fldrupdateok which is false if structures are invalid
    and fileclosed which is true when the file is not open}
   if PrintProcs then writeln('redrawfldr. updateok = ',fldrupdateok);
   if not fileclosed then
      BEGIN
      if tracing then
         BEGIN
         if (activefolder <> folder)  then
              writeln('Active folder <> folder')
         else writeln('activefolder = folder');
         END;

      resrgn := newrgn;
      drawPnllines;

      {title panel}

      SetPort(folder);
      SetOrigin(0,0);

      IF SectPnl(TitlePnl,folder,UpdateRgn,resrgn) or resize then
         BEGIN
         ShoTitle;
         IF cellerror then
            BEGIN
            GetPnlRect(titlePnl,r);
            SetPnlPort(TitlePnl);
            InvertRect(r);
            END;
         END;

      {calculate update regions for each panel}

      {$IFC tedebug}
      if tracing then
         begin
         writeln('updatergn bbox');
         prntrect(updatergn^^.rgnbbox);
         end;
      {$ENDC}



      {table panel}

      if fldrupdateok then
         begin

         SetOrigin(0,0);
         IF SectPnl(TblPnl,folder ,UpdateRgn,resrgn) or resize then
            IF not resize then
               begin
               if paint then
                  begin
                  shoTbl(resrgn);
                  end;
               end
            ELSE
               begin
               tmresize;
               restorergfb(curtimeout);
               if paint then tmshonewtbl;
               end;
         end;


      {wide panel}

      {Always redrawWav Since drawpnllines erases it}

      IF (CurRange.rkind = a1CellRg) or (CurRange.rkind = aColHedRg) OR
         (CurRange.rkind = aRowHedRg) then
         begin
         redrawSel(true);
         curTimeout := 0;
         end;

      disposergn(resrgn);
      END
   ELSE
      BEGIN
      if tracing then writeln('update, file is closed -- susdoccalled',
                              susdoccalled);
      SetPort(folder);
      setorigin (0,0);
      frect := folder^.portrect;
      frect.right := frect.right-dhsbox+1;
      frect.bottom := frect.bottom - dvsbox +1;
      cliprect(frect);
      eraserect(frect);
      if openrequested and not susdoccalled then
         begin
         { file is closed, which happens 1 after multiple pull, 2 after crash
           so tell user how to get image}
         insetrect(frect,10,10);
         drawalert(lmalerts,acttosee,frect);
         end
      else
         begin
         end;
      END;

   if (activefolder = folder) and drawscroll then
      begin
      setport(folder);
      setorigin(0,0);
      flushrects(rh,rv);
      hsbh := hsbfirst(sblist);
      hsbv := hsbnext(hsbh);
      setsbrect(hsbv,rv);
      setsbrect(hsbh, rh);
      if fldrupdateok then
         begin
         calcthumb(false,newv);
         calcthumb(true,newh);
         end
      else
         begin
         (*
         newv := 0;
         newh := 0;
         *)
         newv := cthumbpos(hsbv);
         newh := cthumbpos(hsbh);
         end;

      setthumb(hsbh,newh);
      setthumb(hsbv,newv);


      RectRgn(folder^.cliprgn,folder^.portrect);
      paintsb(hsbH);
      paintsb(hsbV);
      PaintGrow;
      end
   else
      begin
      setport(folder);
      setorigin(0,0);
      RectRgn(folder^.cliprgn,folder^.portrect);
      HideSborder(folder^.portrect);
      end;

   END;

{$S  lmscreen}
Procedure redrawScrap{UpdateRgn:rgnHandle;drawscroll:boolean};
   VAR r : rect;
       hsbv,hsbh:thsb;
       rh,rv : rect;
       err:integer;
       sstate:scstate;
       status:integer;
       sstat:integer;
       temphz:thz;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   sstat := 0;
   status := 0;

   if PrintProcs then writeln('redrawscrap');
   if (activefolder = scrapfolder) and drawscroll then
      begin
      setport(scrapfolder);
      setorigin(0,0);
      flushrects(rh,rv);
      hsbh := hsbfirst(sblist);
      hsbv := hsbnext(hsbh);
      setsbrect(hsbv,rv);
      setsbrect(hsbh, rh);


      RectRgn(scrapfolder^.cliprgn,scrapfolder^.portrect);
      paintsb(hsbH);
      paintsb(hsbV);
      PaintGrow;
      end
   else
      begin
      setport(scrapfolder);
      setorigin(0,0);
      RectRgn(scrapfolder^.cliprgn,scrapfolder^.portrect);
      HideSborder(scrapfolder^.portrect);
      end;

   {clear it for now}

   chgpnlsize(scrappnl,scrapfolder^.portrect.right-dhsbox+1,
                             scrapfolder^.portrect.bottom-dvsbox+1);
   setpnlport(scrappnl );
   getpnlrect(scrappnl ,r);
   eraserect(r);

   lookatscrap(sstate,status);
   if status = 0 then
      begin
        if sstate = scfield then
          begin
          drawscrap(err);
          if mmtrap1 then if err<>0 then writeln('drawscrap error ',err:4);
          end
        else if (sstate = sclist) and (picturehdl <> nil) then
          begin
          StartPutScrap(sstat);
          if sstat <> 0 then
            begin
            if mmtrap1 then writeln('RedrawScrap; startPutscrap error ',sstat);
            end
          else
            begin
            {if picture generated was bigger than 32K, don't draw it}
            if picturehdl^^.picsize < 0 then
              begin
              {if cautionalert(lmalerts,noscrappic) then ;}
              EndPutScrap(sstat);
              if sstat <> 0 then
                 if mmtrap1 then writeln('RedrawScrap; EndPutscrap error ',sstat);
              end
            else
              begin
              temphz := theheap;
              theheap := hzofscrap;
              DrawPicture(picturehdl,picturehdl^^.picframe);

              theheap := temphz;
              EndPutScrap(sstat);
              if sstat <> 0 then
                 if mmtrap1 then writeln('RedrawScrap; EndPutscrap error ',sstat);

              end;
            end;
          end
        else if mmtrap1 then writeln('picturehdl = NIL');
      end;

   END;

{$S lmscrap}
procedure rgcompare{var status:integer; var ucols:integer; var utextdup:boolean};

const
  rc = 'RgCompare';

var
  urows : integer;
  utabs : integer;
  utabstops : integer;
  srgkind : rgkind;
  llrows : integer;
  llcols : integer;
  rowdup : boolean;
  coldup : boolean;

begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  if mmtrap1 then writeln(rc);
  srgkind := selrg.rkind;
  status := 0;

  {what's universal text got?}
  readutext.SCANTABLE(urows,utabs,utabstops);
  if utabs > utabstops then UCols := utabs else UCols := utabstops;

  if mmtrap1 then writeln(rc,'scantable : ',urows:8,utabs:8,utabstops:8);
  if (urows = 0) or (ucols = 0) then
    begin
    status := 1;
    exit(rgcompare);
    end;

  if (srgkind = arectrg) or (srgkind = arowrg) then
    begin
    if selrg.hirow = pinfsnip then rowdup := FALSE    {if in lastrow, row range matches}
    else
      begin
      llrows := LLCountSnips(rowkind,currange);
      if ((llrows mod urows) <> 0) then
        begin
        if mmtrap1 then writeln(rc,'*** Row NO MATCH ***');
        status := 1;
        exit(rgcompare);
        end
      else if ((llrows div urows) = 1) then RowDup := FALSE
           else RowDup := TRUE;
      end;
    end
  else if (srgkind = a1cellrg) or (srgkind = arowgrid) then rowdup := FALSE
       else rowdup := TRUE;     {srgkind = acolrg/awtboxrg}

  llcols := LLCountSnips(colkind,currange);
  if srgkind = a1cellrg then               {if pasteing into a1cellrg, then never duplicate    }
    begin                                  { and if the selection range is wider than the scrap}
    if llcols < ucols then                 { range do paste                                    }
      begin
      status := 1;
      exit(rgcompare);
      end;
    ColDup := FALSE;
    end
  else
    begin
    if ((llcols mod ucols) <> 0)
    or ((srgkind = arowgrid) and ((llcols div ucols) <> 1)) then
      begin
      if mmtrap1 then writeln(rc,'*** Column NO MATCH ***');
      status := 1;
      exit(rgcompare);
      end
    else if ((llcols div ucols) = 1) then ColDup := FALSE
         else ColDup := TRUE;
    end;

  if mmtrap1 then writeln(rc,'; rowdup : ',rowdup,'  coldup : ',coldup);
  if (rowdup or coldup) then utextdup := TRUE else utextdup := FALSE;
end;


{$S lmnewtab}
PROCEDURE SaveTable{var rowband,colband:tmband;var atmstate:tmstate};
   var aband : tmband;

   Begin
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {Save the state of the table editor}
   if PrintProcs then writeln('saveTable');
   tmsavebands;

   tmsavenextband(aband);
   if aband.tmbkind = rowkind then rowband := aband
   else colband := aband;

   tmsavenextband(aband);
   if aband.tmbkind = rowkind then rowband := aband
   else colband := aband;

   tmsavestate(atmstate);
   end;

{$S lmscrap}
PROCEDURE SetScrap{scrapstate : scstate;var ssstatus:integer};

   VAR
      scrhnd : scrrechnd;
      tempstr : str255;
      ptrstr : ptrdata;
      rowsfromfile : hnddata;
      state:scstate;
      Status:integer;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   ssstatus := 0;

   {write out stuff to scrap}
   if PrintProcs then writeln('setscrap');
   InheritScrap(FALSE);
   EraseScrapData(status);
   if status <> 0 then
      begin
      if mmtrap1 then writeln('erasescrapdata error ',status);
      ssstatus := status;
      exit(setscrap);
      end;
   PictureHdl := NIL;

   StartPutScrap(status);
   if status <> 0 then
      begin
      if mmtrap1 then writeln('startputscrap error ',status);
      ssstatus := status;
      exit(setscrap);
      end;

   {check to see if there is enough memory/disk space to generate a scrap picture}
   if scrapstate = sclist then
     begin
     scrhnd := POINTER(ORD(Hallocate(hzofScrap,32762)));
     if ord(scrhnd) = ord(hnil) then
       begin
       ssstatus := noroom;
       if mmtrap1 then writeln('setscrap; not enough room for scrap picture');
       EndPutScrap(status);
       exit(setscrap);
       end
     else FreeH(hzofscrap,pointer(ord(scrhnd)));
     end;

   scrhnd := POINTER(ORD(Hallocate(hzofScrap,sizeOF(screcord))));
   if ord(scrhnd) = ord(hnil) then
     begin
     ssstatus := noroom;
     EndPutScrap(status);
     exit(setscrap);
     end;

   case scrapstate of

      scEmpty:
          BEGIN
          with scrhnd^^ do
            begin
            scraphas := schasnil;
            datahnd := POINTER(ORD(-1));
            Get_Time(status,openid);
            end;

          PutScrap(ScrapNil,POINTER(ORD(scrHnd)),status);
          if status <> 0 then
             begin
             if mmtrap1 then writeln('putscrap',status);
             ssstatus := status;
             endputscrap(status);
             exit(setscrap);
             end;

          END;

      sclist:
          BEGIN
          rowsfromfile := POINTER(ORD(hallocate(hzofscrap,length(pfname)+1)));
          ptrstr := @pfname;
          moveleft(ptrstr^,rowsfromfile^^,length(pfname)+1);

          with scrhnd^^ do
            begin
            scraphas:= schaslist;
            datahnd := POINTER(ORD(rowsfromfile));
            openid := DocScrapId;
            end;

          PutScrap(ScrapList,POINTER(ORD(scrHnd)),status);
          if status <> 0 then
             begin
             if mmtrap1 then writeln('Putscrap error ',status);
             ssstatus := status;
             endputscrap(status);
             exit(setscrap);
             end;

          MMScrapRg := CurRange;
          if tracing then with mmscraprg do
            writeln('==> mmscraprg locol/hicol lorow/hirow : ',locol:4,hicol:4,lorow:4,hirow:4);

          if curtable = tlist then
            begin
            GenUniversal(status);
            if status <> 0 then ssstatus := 1;
            end;

          END;

      scField:
          BEGIN
          {do nothing -- field editor takes care of this}
          END;

      END;
   EndPutScrap(status);
   if status <> 0 then
      begin
      if mmtrap1 then writeln('endputscrap error ',status);
      ssstatus := status;
      exit(setscrap);
      end;
   if tracing then writeln(' scrap set to ',ord(scrapstate));
   END;

{$S lmscreen}
PROCEDURE SetTitleField;
      {-------------------------------------------------------------------------}
      { Set up field record for field editing routines. Also set up editrow     }
      { and editcol to the row and col being edited                             }
      {-------------------------------------------------------------------------}

   VAR
          I : integer;
          xrect: rect;
          titlerect:rect;


   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
      if PrintProcs then Writeln('SetTitleField');
      GetPnlRect(TitlePnl,titlerect);
      with titfield^^ do
         begin
         maxlen := maxString;
         curlen := ORD(PromptString[0]);

         end;
      i := 1;
      while i <= titfield^^.curlen do
        begin
        titfield^^.curvalue^^[i-1] := ORD(Promptstring[i]);
        i := i+1;
        end;
      setRect(xrect,0,0,titlerect.botright.h-titlerect.topleft.h, titleheight);
      SetFCoords(titField,nil,xrect);

   END;


{$S lmscreen}
PROCEDURE ShoTitle;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {draw the title panel}
   if PrintProcs then writeln('shotitle');
   setTitleField;
   SetPnlPort(TitlePnl);
   DrawField(titField,nil,true,true);
   END;
{$S lminit}
PROCEDURE TEFatalErr{module:str40; proc:str40; msg:str40};
   {-------------------------------------------------------------------------}
   {Implementation error detected.  write out error msg then quit.           }
   {                                                                         }
   {-------------------------------------------------------------------------}
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   MMFatalErr(0,module,proc);
   END;


{$S lmfiler}
Procedure UnpackSusData{hndsusdata:hnddata;offset:integer};

   VAR sdp : susdataPtr;
       rowband,
       colband : tmband;
       atmstate : tmstate;
   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {restore suspended state}
   if PrintProcs then writeln('unpacksusdata');
   sdp := Pointer(ord(hndsusdata^)+offset);
   With sdp^ do
      BEGIN
      Curtimeout    := sCurTimeout;
      Curnbrhood    := sCurNbrhood;
      CurRange      := sCurRange;
      ActivePnl     := sActivePnl;
      LastPnl       := sLastPnl;
      WholeSelected := sWholeSelected;
      CellError     := sCellError;
      DtMenuUp      := sDtMenuUp;
      SoMenuUp      := sSoMenuUp;
      CvMenuUp      := sCvMenuUp;
      OpMenuUp      := sOpMenuUp;
      RowBand       := sRowBand;
      colBand       := sColBand;
      Tblpars       := sTblpars;
      lastshowitem  := sLastShowItem;
      atmstate      := stmstate;
      GMTPostTime   := sGMTPostTime;
      END;

   loadtable(rowband,colband,atmstate);

   END;

(*
{$S  lmscreen}
Procedure UpdRowColScrap;

   VAR
      RowBand,
      ColBand : tmband;
      Row,
      Col : Idtype;
      StartRg : Range;
      atmstate : tmstate;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {draw image ofscrap when it has rows or cols}
   if PrintProcs then writeln('updrowcolscrap');

   savetable(rowband,colband,atmstate);

   if rowscut then LoadCutRows(Tblpars)
   else if columnscut then LoadCutCols(Tblpars)
        else if rectrgcut then LoadCut_RectRg(Tblpars);

   {Switch to Scrap}
   tblpnl := cScrapPnl;

   SetPnlPort(tblPnl);{really the scrap}
   GetSnipId(rowkind,MMfirst,0,Row,Row);
   GetSnipId(colkind,MMfirst,0,Col,Col);
   SetRg(startRg,a1CellRg,Row,Col,Row,Col);
   {$IFC tedebug}
   IF tracing then prntrg('startrg',startrg);
   {$ENDC}
   ReBldTbl(startRg);
   tmShoNewTbl;

   {Switch back to table}
   tblPnl := cTblPnl;

   if rowscut then UnLoad_CutRows(Tblpars)
   else if columnscut then UnLoadCutCols(Tblpars)
        else if rectrgcut then Un_LoadCutRectRg(Tblpars);

   SetPnlPort(tblPnl);{back to table}
   loadTable(rowband,colband,atmstate);
   restorergfb(curtimeout);

   {restore origin for folder -- necessary for pictures to work properly}
   SetPort(folder);
   SetOrigin(0,0);

   END;
*)

{$S lminit}

end.{unit menus}

