{$S lmmain}
PROCEDURE ActvResume(var Status:integer);

LABEL 999;

VAR tempstr:str255;
    tempstr2:str255;
    hsbv,hsbh:thsb;
    rh,rv : rect;
    P : point;
    i : integer;
    pct : integer;

BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

  status := 0;
  if mmtrap1 then writeln('ActvResume procedure');

  wouldalert(mymenus[menubuzzword],mbfldract);
  refuseDeactivate := TRUE;

  with theEvent do
    begin

    IF openrequested and (who <> scrapfolder) then
       begin
       OpenTheList(opentype,status);
       if status <> 0 then
          begin
          {docclosed on bad opendoc status handled by openthelist}
          openrequested := false;
          goto 999;
          end;

       openrequested := false;
       end;

    {this needs to follow openthelist because opendoc
     restores the suspended file's lname so this is bullet proofing,
     no need to store lfname in suspend data}
    GetFldrTitle(folder,tempstr);
    Lfname := tempstr;

    if mmtrap1 then write('scrollbars ');
    setport(who);
    setorigin(0,0);

    hsbh := hsbfirst(sblist);
    hsbv := hsbnext(hsbh);
    if (who = folder) and not fileclosed then
       begin
       setsbicons(hsbv,[iconarwa, iconarwb, iconthumb,iconPagA,iconPagB]);
       setsbicons(hsbh,[iconarwa, iconarwb, iconthumb,iconPagA,iconPagB]);
       CalcThumb(FALSE,Pct);
       setThumb(hsbv,pct);
       CalcThumb(TRUE,Pct);
       setthumb(hsbh,Pct);
       end
    else
       begin
       setsbicons(hsbv,[]);
       setsbicons(hsbh,[]);
       end;

    flushrects(rh,rv);
    setsbrect(hsbv,rv);
    setsbrect(hsbh, rh);
    if mmtrap1 then writeln('*');


    if mmtrap1 then write('activate&update');
    lastpnl := activepnl;
    if (who = folder) and not fileclosed then activepnl := tblpnl
    else if who = scrapfolder then activepnl := scrappnl
    else if who = dialogfolder then activepnl := dialogpnl;
    if ((who = folder) or (who = scrapfolder)) and not fileclosed then
       begin
       if who = folder then
          begin
          doupdate(folder,false);
          tmfact(true);

          doselact(true);
          setport(who);
          setorigin(0,0);
          p := who^.portrect.botright;
          end
       else if who = scrapfolder then
          begin
          {since ownership changes scrappnl might not be current}
          with scrapfolder^.portrect do
            chgpnlsize(scrappnl,right-dhsbox+1,bottom-dvsbox+1);

          end;
       end;
    if mmtrap1 then writeln('*');
    if mmtrap1 then write('menus');
    if activepnl <> nullpnl then setpnlport(activepnl);
    if who = folder then
       BEGIN
       ClearMenuBar;
       I := firstmenu;
       while I <= Menushow do
          begin
          InsertMenu(mymenus[I],0);
          I := I + 1;
          end;
       IF somenuup then InsertMenu(mymenus[menusortorder],0);
       if dtmenuup then InsertMenu(mymenus[menudtype],0);
       if cvmenuup then InsertMenu(mymenus[menuvisible],0);
       if opmenuup then InsertMenu(mymenus[menuop],0);
       if trcemenuvis then InsertMenu(mymenus[menutrace],0);
       getitem(mymenus[menusubst],msclose,@tempstr);
       tempstr := concat(tempstr,' "',lfname,'"');
       setitem(mymenus[menufile],fmclose,@tempstr);
       END
    else if who = scrapfolder then
       BEGIN
       Insertmenu(mymenus[menusfile],0);
       getfldrtitle(scrapfolder,tempstr2);
       getitem(mymenus[menusubst],msclose,@tempstr);
       tempstr := concat(tempstr,' "',tempstr2,'"');
       setitem(mymenus[menusfile],scrapclose,@tempstr);
       END;
    if mmtrap1 then writeln('*');

    if mmtrap1 then write('draw menus and scroll bars');
    DrawMenuBar;

    setport(who);
    setorigin(0,0);
    RectRgn(who^.cliprgn,who^.portrect);
    if tracing then writeln('before paintsb');
    paintsb(hsbH);
    paintsb(hsbV);
    PaintGrow;
    if mmtrap1 then writeln('*');

    if mmtrap1 then writeln('activate processing complete');

    end;

999:
end;    {ActvResume}



{$S lmmain}
Function checkgrow:boolean;
       VAR
       oldpnlrgn,
       newpnlrgn : rgnHandle;
       newpnlsize,
       oldpnlsize : rect;
       oldbotright : point;
       hsbv,hsbh:thsb;
       sbpoint:point;
       rh,rv : rect;
       updateneeded:boolean;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   {handle folder grows/shrinks}
   if PrintProcs then writeln('checkgrow');
   updateneeded := true;
   with theEvent do
      BEGIN
      setport(who);
      setorigin(0,0);
      if FgrowHit(where) then

         BEGIN
         wouldalert(mymenus[menubuzzword],mbgrow);
         checkgrow := true;
         Dragframe(where,TRUE,sbpoint);
         {if making folder smaller, then we dont need to update screen}
         if (who^.portrect.right > sbpoint.h) and
            (who^.portrect.bottom > sbpoint.v) then updateneeded := false;
         {compute new foldersize}
         oldbotright := who^.portrect.botright;
         if ( who = folder)  then
            begin
            getpnlrect(folderpnl,oldpnlsize);
            foldersize(who,cmax(sbpoint.h,0),
                           cmax(sbpoint.v,0),false);
            end

         else if (who = scrapfolder)  then
            begin
            getpnlrect(scrappnl,oldpnlsize);
            foldersize(who,sbpoint.h,sbpoint.v,false);


            end;

         {get the real size from the window manager}
         sbpoint := who^.portrect.botright;

         if who = folder then
            begin
            adjpnls(sbpoint);
            end
         else if who = scrapfolder then
            begin
            with scrapfolder^.portrect do
              chgpnlsize(scrappnl,right-dhsbox+1,bottom-dvsbox+1);
            getpnlrect(scrappnl,newpnlsize);
            end;
         flushrects(rh,rv);
         hsbh := hsbfirst(sblist);
         hsbv := hsbnext(hsbh);

         setsbrect(hsbh, rh);
         setsbrect(hsbv,rv);

         RectRgn(who^.cliprgn,who^.portrect);
         paintsb(hsbh);
         paintsb(hsbv);
         paintgrow;
         setorigin(0,0);
         if who = folder then setpnlport(folderpnl)
         else if who = scrapfolder then setpnlport(scrappnl);
         oldpnlrgn:= newrgn;
         newpnlrgn := newrgn;
         rectrgn(oldpnlrgn,oldpnlsize);
         rectrgn(newpnlrgn,newpnlsize);
         diffrgn(oldpnlrgn,newpnlrgn,oldpnlrgn);
         if (who = folder)  then redrawfldr(oldpnlrgn,true,updateneeded,true)
         else if (who = scrapfolder) and updateneeded then redrawscrap(oldpnlrgn,true);
         disposergn(oldpnlrgn);
         disposergn(newpnlrgn);
         skipnextmouseup:= true;
         END
      ELSE checkgrow := false;
      END;{with}

   END;

{$S  lmmain}
Function checkScroll: Boolean;

    VAR
        hsbhit : thsb;
        iconhit : tIcon;
        horiz : boolean;
        newthumbpos : integer;
        r : rect;
        newpos : integer;
        rowband,colband : tmband;
        atmstate : tmstate;
        didmove:boolean;
        direction : scrolldir;
        curpt,
        curmousept:point;
        SnipId: IdType;


    BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
    if PrintProcs then writeln('checkscroll');
    With theEvent do
       BEGIN

       if fsbhit(sblist,where,hsbhit,iconhit) and (who = folder) then
          BEGIN
          wouldalert(mymenus[menubuzzword],mbscroll);
          checkscroll := true;
          {handle case of dismissing an alert by scrolling}
          DoUpdate(folder,true);
          {mouse down in scroll bar}
          case iconhit of

            iconskewer:;
            iconThumb:
                begin
                setport(who);
                setorigin(0,0);
                rectrgn(who^.cliprgn,who^.portrect);
                DragThumb(hsbhit,where,newthumbpos);
                if tyvhofsb(hsbhit) = h then
                   begin
                   TMCurVwPt(CurPt);
                   scrband(colkind,curpt.h,jmpscroll,scrollfwd,newthumbpos,didmove);
                   CalcThumb(TRUE,newthumbpos);
                   setport(who);
                   setorigin(0,0);
                   rectrgn(who^.cliprgn,who^.portrect);
                   SetUpMvThumb(hsbhit);
                   PenNormal;
                   MoveThumb(newthumbpos);
                   end
                else
                   begin
                   TMCurVwPt(CurPt);
                   savetable(rowband,colband,atmstate);
                   fldrupdateok := false;
                   getsnipid(rowkind,mmfraction,newthumbpos,SnipId,SnipId);
                   {note: this call releases row snips and brings in the
                    row associated with the pct  }
                   {the tbl editor scrband routine must NOT be used because
                    the currange may be off the screen}

                   WITH RowBand DO
                      BEGIN
                      TMBLoId := SnipId;
                      rowband.tmbhidep := 0;
                      END;
                   loadtable(rowband,colband,atmstate);

                   WHILE (GrayOfBand(RowKind,CurPt.V) > 750)
                   AND (SnipId <> MInfSnip) DO
                      BEGIN
                      GetSnipId(RowKind,MMPrior,0,SnipId,SnipId);
                      IF SnipId <> MInfSnip THEN
                         BEGIN
                         RowBand.TMBLoId := SnipId;
                         LoadTable(RowBand,ColBand,atmstate);
                         END;
                      END;

                   restorergfb(curtimeout);
                   tmshonewtbl;
                   fldrupdateok := true;

                   setport(who);
                   setorigin(0,0);
                   rectrgn(who^.cliprgn,who^.portrect);
                   SetUpMvThumb(hsbhit);
                   PenNormal;
                   CalcThumb(FALSE,newthumbpos);
                   MoveThumb(newthumbpos);


                   end;

                end;
            iconArwa,
            iconArwb:
                BEGIN
                IF iconhit = iconarwb then direction := scrollfwd
                ELSE direction := scrollbak;

                setport(who);
                setorigin (0,0);
                rectrgn(who^.cliprgn,who^.portrect);
                PaintArw(hsbHit,iconHit,TRUE);
                if hsbhit = hsbfirst(sblist) then horiz := true
                else horiz := false;
                tmcurvwpt(curpt);

                getpnlrect(tblpnl,r);
                if horiz then
                   begin
                   if direction = scrollbak then curmousept.h := r.left+1
                   else curmousept.h := r.right-1;
                   end
                else
                   begin
                   if direction = scrollbak then curmousept.v := r.top+1
                   else curmousept.v := r.bottom-1;
                   end;
                Repeat
                   begin

                   if horiz then
                      begin {Horizontal scrolling}
                      scrband(colkind,curpt.h,incrscroll,direction,
                                   curmousept.h,didmove);
                      end

                   else
                      begin {Vertical scrolling}
                      scrolling := true;
                      scrband(rowkind,curpt.v,incrscroll,direction,
                                   curmousept.v,didmove);
                      end;

                   {get new thumb pos}
                   setport(who);
                   setorigin(0,0);
                   rectrgn(who^.cliprgn,who^.portrect);
                   pennormal;
                   calcthumb(horiz,newpos);
                   setupmvthumb(hsbhit);
                   movethumb(newpos);

                   end;
                Until Not StillDown;
                if scrolling then scrolling := false;
                setport(who);
                setorigin(0,0);
                rectrgn(who^.cliprgn,who^.portrect);
                PaintArw(hsbhit,iconhit, false);
                END;


            iconPaga,
            iconPagb:
                BEGIN
                tmcurvwpt(curpt);

                IF iconhit = iconpagb then direction := scrollfwd
                ELSE direction := scrollbak;

                setport(who);
                setorigin (0,0);
                rectrgn(who^.cliprgn,who^.portrect);
                PaintArw(hsbHit,iconHit,TRUE);

                if hsbhit = hsbfirst(sblist) then horiz := true
                else horiz := false;
                tmcurvwpt(curpt);

                Repeat
                   BEGIN
                   if horiz then
                      begin
                      scrband(colkind,curpt.h,pagescroll,direction,0,didmove);
                      end

                   else
                      begin
                         scrolling := true;
                         scrband(rowkind,curpt.v,pagescroll,direction,0,didmove);
                      end;
                  {get new thumb pos}
                  setport(who);
                  setorigin(0,0);
                  rectrgn(who^.cliprgn,who^.portrect);
                  pennormal;
                  calcthumb(horiz,newpos);
                  setupmvthumb(hsbhit);
                  movethumb(newpos);

                  END;

                Until Not StillDown;
                if scrolling then scrolling := false;
                setport(who);
                setorigin(0,0);
                rectrgn(who^.cliprgn,who^.portrect);
                PaintArw(hsbhit,iconhit, false);
                END;

            end;{case}
         skipnextmouseup := true;

         END
      ELSE checkScroll := false;
      getCr(CurRange); {may have been changed by matrix mgr in event of error}
      END;{With}
   END;



{$S lmmain}

PROCEDURE mousedown(var mouserel:point);
   var
       pnloffset:point;
       r : rect;
       OldRange: Range;
       menuindex, itemindex : integer;
       mdownpt : point;
       relpt : point;
       status : integer;
       thispnl : pnlindex;

   BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}
   if PrintProcs then writeln('mousedown');
   With theEvent do
      BEGIN
      IF tracing THEN WRITE('MouseDown event..');
      IF who = menufolder then
         BEGIN
         IF tracing THEN WRITELN('Menu event..');
         HiliteEdits; {make sure menus are grayed properly}
         MenuSelect(where, MenuIndex, ItemIndex );     {process menu command}

         {process menu command}
         MenuCommand(MenuIndex, ItemIndex);
         END
      ELSE
         BEGIN


         {Check for growbox hit and stuff}
         if CheckGrow then begin end

         {check scroll hit }

         else if CheckScroll then begin end

         else if not fileclosed then
            begin
            wouldalert(mymenus[menubuzzword],mbmousedown);
            ThisPnl := ptInPnl(theEvent.who,theEvent.where,cHiPnl  );
            if ThisPnl = nullpnl then exit(mousedown);
            if thispnl = activePnl then
               begin
               if lastpnl <> activepnl then lastpnl := activepnl;
               end
            else
               begin
               {mouse down in new pnl so don't look for doubles or triples}
               LastPnl := ActivePnl;
               activepnl := thispnl;
               Check2or3Click := FALSE;
               FndDouble := False;
               FndTriple := False;
               END;


            AdjToPnl(ActivePnl,theEvent.where,mouserel);   {relocate to panel}
            SetPnlPort(ActivePnl);

            if tracing then writeln('mouse down in panel ',activepnl);
            MouseHasMoved := False;
            if tracing then
               begin

               writeln('mouserel' , mouserel.h:4,mouserel.v:4);
               writeln('curnbrhood');
               {$IFC tedebug}
               prntrect(curnbrhood);
               {$ENDC}
               writeln('check2or3',check2or3Click);
               end;

            if when - LastUpTime < clickdelay then seqflag := true
            Else seqflag := false;
            IF SeqFlag AND Check2or3Click and ((CurRange.rkind = a1CellRg) or
            (CurRange.rkind = aRowHedRg) or(CurRange.rkind = aColHedRg)) then
               BEGIN  {Found a double or triple }
               IF tracing THEN WRITE('in sequence..');
               IF NOT (FndDouble OR FndTriple) then
                  BEGIN  {Double click found }
                  FndDouble := TRUE;
                  IF tracing THEN WRITE('Double Click ');
                  END
               ELSE
                  BEGIN  {Triple click found }
                  FndDouble := FALSE;
                  FndTriple := TRUE;
                  IF tracing THEN WRITE ('Triple Click');
                  END;
               END;
            IF tracing THEN WRITELN;
              CASE ActivePnl of

                  cTblPnl:
                        BEGIN

                        {if mouse went dwn in a range different from the current one }
                        {Then enter new data from current cell.}

                        IF NOT PtIn1cRg(mouserel, curRange)  THEN
                           BEGIN
                           EnterStuff(status);
                           IF status = 0 THEN
                              BEGIN
                              IF NewRowPt(mouserel,curRange) then
                                 Begin
                                 UpdateRow;
                                 FixThumb(folder);
                                 End;

                              {perform the selection}
                              NullCr;
                              IF curRgList then RelcRgList;

                              MseDwnErr := False;


                              selnewcell(mouserel,selectcell,curnbrhood,curtimeout);
                              wholeselected := true;

                              oldrange := curRange;
                              getcr(currange);
                              {translate neighborhood back to folder coords}

                              adjrect(TblPnl, curNbrhood);
                              (*ErrTitle;*)
                              END
                           ELSE
                              BEGIN

                              {Error condition -- some problem entering data}

                              MseDwnErr := TRUE ;
                              ErrSelect(status);
                              END;

                           {new context, stop looking for doubles or triples }
                           FndDouble := False;
                           FndTriple := False;
                           END
                        ELSE
                           BEGIN
                           msedwnerr := false;
                           IF FndDouble THEN
                              BEGIN
                              {perform word selection}
                              NewWSel(mouserel,TblPnl,curNbrhood,curtimeout);

                              {translate neighborhood back to folder coords}

                              adjrect(TblPnl, curNbrhood);
                              if tracing then
                                 begin
                                 writeln('after newwsel');
                                 {$IFC tedebug}
                                 writeln('curNbrhood');
                                 prntrect(curNbrhood);
                                 {$ENDC}
                                 end;

                              END
                           ELSE IF FndTriple THEN
                              BEGIN
                              SelAllTxt(curTimeout);
                              NewRgimg(CurRange);
                              END
                           ELSE
                              BEGIN

                              {perform the selection}

                              DoTblSel(mouserel,curNbrhood,curTimeout);
                              wholeselected := FALSE;
                              if CellError then
                                 BEGIN
                                 {restore error message};
                                 Promptstring := ListTitle;
                                 shoTitle;
                                 CellError := FALSE;
                                 END;

                              oldrange := currange;
                              getcr(currange);
                              {translate neighborhood back to folder coords}

                              adjrect(TblPnl, curNbrhood);
                              (*ErrTitle;*)
                              {$IFC tedebug}
                              if tracing then
                                 BEGIN
                                 writeln('curnbrhood:');
                                 prntrect(curnbrhood);
                                 END;
                              {$ENDC}
                              END;
                           END;
                        IF NOT ( (CurRange.rkind =  anullRg) OR
                                 (CurRange.rkind =  aRowGrid ) OR
                                 (CurRange.rkind =  aColGrid) OR
                                 (CurRange.rkind =  aWTBoxRg ))THEN
                           begin
                           MakeRgVisible(OldRange,CurRange);
                           end;

                        END;

                  cWidePnl:
                        BEGIN
                        IF Tracing then writeln('mouse down in wide angle view');

                        msedwnerr := false;
                        IF FndDouble THEN
                           BEGIN
                           NewWSel(mouserel,WidePnl,curNbrhood,curtimeout);

                              {translate neighborhood back to folder coords}

                           adjrect(WidePnl, curNbrhood);
                           END
                        ELSE IF FndTriple THEN
                           BEGIN
                           SelAllTxt(curTimeout);
                           NewRgimg(CurRange);
                           END
                        ELSE
                           BEGIN
                           DoWavSel(MouseRel,curNbrhood,CurTimeout);
                           wholeselected := false;

                           if CellError then
                              BEGIN
                              {restore error message};
                              Promptstring := ListTitle;
                              shoTitle;
                              CellError := FALSE;
                              END;

                              {translate neighborhood back to folder coords}

                           AdjRect(WidePnl,curNbrhood);
                           END;
                        END;
                  cTitlePnl:
                        BEGIN
                        IF Tracing then writeln('mouse down in Title Panel');
                        IF (LastPnl = TblPnl ) OR (LastPnl = WidePnl) then
                           BEGIN
                           EnterStuff(status);
                           IF status = 0 THEN
                              BEGIN
                              MseDwnErr := False;
                              NullCr;
                              nullsel;
                              GetCr(CurRange);
                              IF curRgList then RelcRgList;
                              curTimeout := dfltTimeout;

                              END
                           ELSE
                              BEGIN

                              {Error condition -- some problem entering data}

                              MseDwnErr := TRUE;
                              ErrSelect(status);
                              ActivePnl := LastPnl;
                              END;
                           END;

                        IF FndDouble THEN
                           BEGIN
                           END
                        ELSE IF FndTriple THEN
                           BEGIN
                           END
                        ELSE
                           BEGIN
                           END;
                        END;
                  cDialogPnl:
                        BEGIN
                        IF Tracing then writeln('mouse down in dialogPanel');
                        END;
                  otherwise
                        begin
                        if mmtrap1 then
                           writeln('ignoring mouse down in panel ', activepnl);
                        end;

                  END;
               Fixmenus;

               {disable triple click drag}

               if msedwnerr  or fndTriple then
                  BEGIN
                  while stilldown do
                     begin
                     end;
                  exit(mousedown);
                  END;

               {wait to ignore small mouse moves during double/triple}
               while stilldown and (Abs(time-when) < deltadouble) do
                  BEGIN
                  END;

               IF NOT stilldown then exit(mousedown); {mouse went up before delta}

               {mouse still down so must be a mouse move}
               While StillDown do
                  BEGIN
                  setPnlPort(activePnl);
                  GetMouse(mdownpt);
                  relpt := mdownpt;
                  getpnlrect(activepnl,r);
                  with r,relpt do
                     begin
                     if h < left then h := left;
                     if v < top then v := top;
                     if h > right then h := right;
                     if v > bottom then v := bottom;
                     end;
                  r:= curNbrhood;
                  getpnloffset(activepnl,pnloffset);
                  offsetrect(r,-pnloffset.h,-pnloffset.v);
                  if ptInRect(relpt,r) then
                     BEGIN
                     if tracing then writeln('relpt in r');
                     END
                  ELSE
                     BEGIN
                     IF tracing THEN WRITELN('MouseMoved event');
                     if tracing then
                        BEGIN
                        writeln('relpt: ',relpt.h:4,relpt.v:4);
                        {$IFC tedebug}
                        writeln('r:');
                        prntrect(r);
                        writeln('curnbrhood:');
                        prntrect(curnbrhood);
                        {$ENDC}
                        END;
                     MouseHasMoved := True;
                     CASE ActivePnl of

                        cTblPnl:
                              BEGIN
                              NewNbh(relpt ,curNbrhood,curTimeout);
                              if tracing then writeln('newnbh called');

                                 {translate neighborhood back to folder coords}

                              adjrect(TblPnl, curNbrhood);
                              GetCR(CurRange);
                              END;

                        cWidePnl:
                              BEGIN
                              NewNbhWav(relpt ,curNbrhood,curTimeout);

                                 {translate neighborhood back to folder coords}

                              adjrect(widePnl,curNbrhood);
                              END;

                        otherwise
                              BEGIN
                              if mmtrap1 then
                                 writeln('ignoring mousemoved for panel',activepnl);
                              END;

                        END;

                     END;

                  END;


               END;
            END;
         END;
      END;


{$S lmmain}
Procedure processevent;

{------------------------------------------------------------------------}
{                           GetEventLoop                                 }
{------------------------------------------------------------------------}
LABEL 999;


VAR
    Status:        INTEGER;             {temporary used for return codes from proced.}
    mouserel: Point;
    updatergn: rgnHandle;
    r:rect;
    hsbv,hsbh:thsb;
    sstate : scstate;
    validselection: boolean;
    snipid:idtype;
    crgkind : rgkind;

BEGIN
{$IFC SAMPCALLS}  ALogCall;  {$ENDC}

if PrintProcs then writeln('ProcessEvent');

IF tracing then
  begin
  (*
  {$IFC tedebug}
  writeln('curNbrhood');
  prntrect(curNbrhood);
  writeln(' where:  ',theEvent.where.h:4, theEvent.where.v:4);
  PrntPort;
  prntclip;
  writeln('visrgn');
  prntrect(tracing,theEvent.who^.visrgn^^.rgnbbox);
  writeln('port bounds');
  prntrect(theEvent.who^.portbits.bounds);
  {$ENDC }
  *)
  end;






  if tracing then
     begin
     writeln('Processing the Event      --------------------------------------');
     {$IFC tedebug}
     writeln('curNbrhood');
     prntrect(curNbrhood);
     {$ENDC}

     (*
     writeln('Event: ',theEvent.what:3);
     writeln('Panel is ', ActivePnl);
     writeln('mouserel', mouserel.h, mouserel.v);
     {$IFC tedebug}
     prntport;
     prntclip;
     writeln('visrgn');
     prntrect(theEvent.who^.visrgn^^.rgnbbox);
     writeln('port bounds');
     prntrect(theEvent.who^.portbits.bounds);
     prntRg('curRange: ',curRange);
     {$ENDC}
     *)
     end;


  WITH theEvent DO
    BEGIN
    CASE what   OF


      ButtonUp:
            BEGIN
            wouldalert(mymenus[menubuzzword],mbmouseup);
            IF (who = menufolder) or (who = scrapfolder) or skipnextmouseup then
               BEGIN
               if skipnextmouseup then skipnextmouseup := false;
               END
            ELSE
               BEGIN
               IF tracing THEN WRITELN('MouseUp event..');
               CASE ActivePnl of

                cWidePnl,
                cTblPnl:
                   BEGIN
                   AdjToPnl(ActivePnl,where,mouserel);   {relocate to panel}
                   MseUp(mouserel,curtimeout); {finish up selection}
                   if curRange.rkind = aColGrid then fixthumb(folder);
                   END;
                cTitlePnl:
                   BEGIN
                   END;
                cDialogPnl:
                   BEGIN
                   ActivePnl := LastPnl;
                   LastPnl := DialogPnl;
                   END;
                otherwise
                   begin
                   if tracing then
                      writeln('ignoring mouse up in panel ',activepnl:3);
                   end;

                END; {case}

               IF MouseHasMoved OR wholeselected  THEN
                  BEGIN
                  Check2or3Click := false;
                  fndDouble := false;
                  fndTriple := false;
                  curNbrhood := dfltnbrhood;
                  END
               ELSE
                  Check2or3Click := TRUE;   {Must look for possible double or }
                                            {Triple clicks                    }

              LastUpTime := when;
              END;

           END;

      ButtonDown:
            BEGIN
            mousedown(mouserel);
            if tracing then
               begin
               writeln('After mousedown');
               {$IFC tedebug}
               writeln('curNbrhood');
               prntrect(curNbrhood);
               {$ENDC}
               end;
            END;


      Keydown:
            BEGIN
            IF tracing THEN WRITELN('Key event..', ascii);
            wouldalert(mymenus[menubuzzword],mbtype);

            {command ! puts up trace menu}
            {command + halts to test crashes}
            {command % puts up version menu}

            {$IFC fexecdebug }
            IF applekey and (ascii = '1') then
               BEGIN
               TrceMenuVis := Not TrceMenuVis;
               IF TrceMenuVis then insertmenu(mymenus[MenuTrace],0)
               ELSE deletemenu(MenuTrace);
               DrawMenubar;

               ClrMrkItem (MenuTrace,tmmgr,traceMMgr);
               ClrMrkItem (MenuTrace,tmmgr2,trace2MMgr);
               ClrMrkItem (MenuTrace,tlmprint,tracelmprint);
               ClrMrkItem (MenuTrace,tdbconvert,dbctest);
               ClrMrkItem (MenuTrace,tsmgr,tracesmgr);
               ClrMrkItem (MenuTrace,ttmgr,tracetmgr);
               ClrMrkItem (MenuTrace,txtmgr,tracextmgr);
               ClrMrkItem (MenuTrace,tfmgr,traceFmgr);
               ClrMrkItem (MenuTrace,tfedits,fldtest);
               ClrMrkItem (MenuTrace,tfexec,tracing);
               {$IFC preRelease}
               ClrMrkItem (MenuTrace,tlmdebug,lmdebug);
               {$ENDC }
               ClrMrkItem (MenuTrace,tmmtrap1,mmtrap1);
               ClrMrkItem (MenuTrace,tmmtrap2,mmtrap2);
               END;


            IF applekey and (ascii = '+') then halt;
            IF applekey and (ascii = '%') then
               begin
               verMenuVis := Not verMenuVis;
               IF verMenuVis then insertmenu(mymenus[Menuversion],0)
               ELSE deletemenu(Menuversion);
               DrawmenuBar;
               end;

            {$ENDC }

            {$IFC SAMPCALLS}
            IF applekey and (ascii = 'T') then
              BEGIN
              AResetTrace(TRUE);
              AStartCallLog;
              END
            ELSE IF applekey and (ascii = 'Q') then
              BEGIN
              AStopCallLog;
              AListCalls;
              END;
            {$ENDC}

            IF (applekey or (ascii = chr(chclear))) AND
               NOT (applekey and (ascii = chr(chback)))
               AND ((ActivePnl = cTblPnl) OR (ActivePnl = cWidePnl)) then
                  BEGIN
                  HiliteEdits;
                  Commandkey(ascii,shiftkey,applekey);
                  END
            else
               begin
               crgkind := currange.rkind;
               CASE ActivePnl of

                  cTblPnl:
                        BEGIN
                        validselection := (crgkind = a1CellRg)  OR
                           (crgkind = aRowRg) OR
                           (crgkind = aWTBoxRg) OR
                           (crgkind = aRectRg) OR
                           (crgkind = aColRg)   OR
                           ((crgkind = aColhedRg) AND (CurTable = tColspecs));
                        IF validselection and (crgkind = aRowRg) then
                           begin
                           {protect against a table with row handles only}
                           getsnipid(colkind,mmfirst,0,snipid,snipid);
                           if snipid = pinfsnip then validselection := false;
                           end;
                        IF validselection THEN
                           BEGIN
                           MakeRgVisible(CurRange,CurRange);
                           IF MoveAction(ascii) <> noMove THEN
                              BEGIN

                              {Then enter new data from current cell.}
                              EnterStuff(status);

                             {IF (status = 0) AND (crgkind in [a1Cellrg,
                                           aRowHedrg,aColHedrg,aColRg,aRowRg]) THEN}
                              IF (status = 0) AND (validselection OR (crgkind = aRowHedRg)) THEN
                                 BEGIN
                                 IF NewRow (MoveAction(ascii),CurRange) then
                                    BEGIN
                                    UpdateRow;
                                    FixThumb(folder);
                                    End;

                                 NullCr;

                                 IF curRgList then RelcRgList;
                                 CoerceToCell(CurRange,CurRange);
                                 DoKeyedMove(MoveAction(ascii),selectContents);
                                 END
                              ELSE
                                 BEGIN
                                 ErrSelect(status);
                                 END;
                              END {move key}

                           ELSE
                              BEGIN


                              {insert key typed into fields        }


                              if CellError then
                                 BEGIN
                                 {restore error message};
                                 Promptstring := ListTitle;
                                 shoTitle;
                                 CellError := FALSE;
                                 END;
                              CoerceToCell(CurRange,CurRange);
                              InKey(ascii,shiftkey,applekey,(curtable=tsearch),
                                    curTimeout,status);
                              IF (Status <> OK) and (status <> InvalidEdit) THEN
                                 BEGIN
                                 errselect(status+feerr);
                                 END;
                              END;{ not a move key }
                           END {valid range}
                        ELSE
                           BEGIN
                           if cautionalert(lmalerts,badkeyinp) then ;
                           END; {inappropriate range}

                        END;
                  cWidePnl:
                        BEGIN
                        validselection := (crgkind = a1CellRg)  OR
                                          (crgkind = aRowRg) OR
                                          (crgkind = aRectRg) OR
                                          (crgkind = aWTBoxRg) OR
                                          (((crgkind = aColRg) OR
                                            (crgkind = aColhedRg)) AND
                                           (CurTable = tColspecs));
                        IF validselection and (crgkind = aRowRg) then
                           begin
                           {protect against a table with row handles only}
                           getsnipid(colkind,mmfirst,0,snipid,snipid);
                           if snipid = pinfsnip then validselection := false;
                           end;
                        IF validselection THEN

                           BEGIN
                           MakeRgVisible(CurRange,CurRange);
                           IF MoveAction(ascii) <> noMove THEN
                              BEGIN

                              {Then enter new data from current cell.}

                              EnterStuff(status);

                             {IF (status = 0) AND (curRange.rkind in [a1Cellrg,
                                           aRowHedrg,aColHedrg]) THEN}
                              IF (status = 0) AND ((crgkind = a1cellrg) OR
                                                  (crgkind = aRowHedrg) OR
                                                  (crgkind = aColHedrg)) THEN
                                 BEGIN
                                 IF NewRow (MoveAction(ascii),CurRange) then
                                    BEGIN
                                    UpdateRow;
                                    FixThumb(folder);
                                    END;
                                 NullCr;
                                 IF curRgList then RelcRgList;
                                 CoerceToCell(CurRange,CurRange);
                                 DoKeyedMove(MoveAction(ascii),selectContents);
                                 END
                              ELSE
                                 BEGIN
                                 ErrSelect(status);
                                 END;
                              END

                           ELSE
                              BEGIN
                                 {insert key typed into fields        }

                              if CellError then
                                 BEGIN
                                 {restore error message};
                                 Promptstring := ListTitle;
                                 shoTitle;
                                 CellError:= FALSE;
                                 END;
                              CoerceToCell(CurRange,CurRange);
                              InKey(ascii,shiftkey,applekey,(curtable=tsearch),
                                    curTimeout,status);
                              if (status <> 0) and (status <> InvalidEdit) then
                                 begin
                                 errselect(status+feerr);
                                 end;
                              END;
                           END {valid range}
                        ELSE
                           BEGIN
                           if cautionalert(lmalerts,badkeyinp) then ;
                           END;{not a valid range}
                        END;

                  Otherwise
                        BEGIN

                        if cautionalert(lmalerts,badkeyinp) then ;
                        END;


                  END;{case}


               GetCr(CurRange);

               Fixmenus;
               END;
            END;

      FolderUpdate:
            BEGIN
            IF MMTRAP1 THEN
               begin
               WRITE('Update event..');
               IF who = folder then  writeln(' LM folder')
               ELSE if who = scrapfolder then  writeln (' Scrap folder');
               end;

            wouldalert(mymenus[menubuzzword],mbfldrupdate);

            doupdate(who,true);
            END;


      FolderActivate:
            BEGIN
            IF MMTRAP1 THEN
               begin
               WRITE('Activate event..');
               IF who = folder then  writeln(' LM folder')
               ELSE if who = scrapfolder then  writeln (' Scrap folder');
               end;

            TakeControl(theEvent,false,false);

            ActvResume(status);
            if status <> 0 then goto 999;

            END;

      FolderDeactivate:
            BEGIN
            IF MMTRAP1 THEN
               begin
               WRITE('Deactivate event..');
               IF who = folder then writeln(' LM folder')
               ELSE if who = scrapfolder then writeln (' Scrap folder');
               end;
            if (who = folder) and not fileclosed then shrinkHeap;
            if tracing then writeln ('lastpnl', lastpnl:3);
            wouldalert(mymenus[menubuzzword],mbfldrdeact);
            refuseDeactivate := FALSE;

            {process deactivate}
            setport(who);
            setorigin(0,0);

            {clean up scrap}

            if  (scrapProcess = My_Id) then
               begin
               lookatscrap(sstate,status);
               if status = 0 then
               case sstate of

                  scfield:
                      BEGIN
                      {scrap already ok}
                      FeTerminate;
                      END;
                  sclist:
                      BEGIN
                      if ColumnsCut then
                        begin
                        UnPasteCols;
                        ClearScrap(status);
                        end;
                      END;
                  scempty:
                      BEGIN
                      {scrap already ok}
                      END;

                  scnotmine: {if it ain't mine don't touch it};

               end; {case}

               if (sstate <> scnotmine)  then
                  begin
                  {draw picture  }
                  updatergn := newrgn;
                  setport(scrapfolder);
                  setorigin(0,0);
                  rectrgn(updatergn,scrapfolder^.portrect);
                  WMOpenPicture(scrapfolder);
                  redrawscrap(updatergn,false);
                  WMClosePicture;
                  disposergn(updatergn);
                  end;
               end;
            if (who = folder) or (who = scrapfolder) then
               begin

               if (who = folder) and not fileclosed then
                  begin

                  tmfact(false);
                  doselact(false);
                  setport(who);
                  setorigin(0,0);
                  getpnlrect(folderpnl,r);
                  end
               else if who = scrapfolder then
                  begin
                  end;


               setport(who);
               setorigin(0,0);
               hsbh := hsbfirst(sblist);
               hsbv := hsbnext(hsbh);
               rectrgn(who^.cliprgn,who^.portrect);
               HideSBorder(who^.portrect);

               ClearMenuBar;
               end;


            if not fileclosed then
               begin
               if mmtrap1 then write('picture stuff');

               if who = folder then
                  begin
                  updatergn := newrgn;
                  setport(who);
                  setorigin(0,0);
                  rectrgn(updatergn,who^.portrect);
                  WMOpenPicture(folder);
                  redrawfldr(updatergn,false,true,false);
                  WMClosePicture;
                  disposergn(updatergn);
                  end;
               if mmtrap1 then writeln('*');
               end
            else
               begin
               if who = folder then
                  begin
                  wmkillpicture(folder);
                  end;
               end;

            { pass on the torch to the new active folder }

            GiveControl(theEvent);

            END;

      FolderMoved:
            BEGIN
            IF tracing THEN WRITELN('folder move event');
            END;


      filerEvent:
            BEGIN
            DoFilerEvent(theEvent);
            END;

      nilEvent:
            BEGIN
            IF MMTRAP1 THEN WRITELN('Non event..');
            END;

      AbortEvent:
            BEGIN
            IF MMTRAP1 THEN WRITELN('AbortEvent..');
            END;

      OTHERWISE
            BEGIN
            if mmtrap1 then writeln(' unknown event = ',ord(what));
            END;

      END;
    END;

999:
END; {ProcessEvent}

ÿ