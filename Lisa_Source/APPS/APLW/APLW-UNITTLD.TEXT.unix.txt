{$I APLW/COMPFLAGS }                                            {gdf 1/16/84}
{$R-}

UNIT UnitTld;

(* Copyright 1982, 1984, Apple Computer Inc. *)

{ gdf  3/12/84 -- TydyTld default now TyxyHiDotMx  }
{ gdf  2/24/84 -- insert trace calls for segmentation  }
{ gdf 2/22/84  -- fix tyxytld-edevdotmx & fHiRes sets tyxyHidotmx }
{ gdf 2/14/84  -- fix tyxytld-edevHdotmx }
{ gdf 2/10/84  -- replace devfromics with FillInLFntId }
{ gdf  2/8/84  -- get dev from prrec in DevFromIcs }
{ gdf  2/2/84  -- use info from new print record: page size, etc. }
{ gdf  1/23/84 -- fix printing defaults for screen only  }
{ gdf  1/16/84 -- printing compile flag & include COMPFLAGS added }
{ tjm  4/06/83 -- ichLstTld = 280 }
{ tjm  3/30/83 -- Clip margins to DptPaperSize }
{ tjm  3/29/83 -- tyxyCs in DvBaseLine }
{ tjm  3/28/83 -- New underlining trailing blanks logic }
{ crc  3/22/83 -- LpPrvVis: Don't call SetLpd with lp = -1 ! (WP264)}
{ crc  3/04/83 -- LpOfPt: If rec is above pane (and therefore consolidated),
                  return lpLim of rec - bug WP 204 }
{ tjm  3/01/83 -- nesting problem in FGenInsChTld - bug WP 231 }
{ tjm  3/01/83 -- clean up underlining in GenImg - bug WP 192 }
{ tjm  1/25/83 -- add rce param to FGenInsChTld }
{ crc  1/24/83 -- LpOfPt: extra white space before word assiciated with preceeding
                  seperator (dx calculation when ich = rgichWdFst[iwd+1]) }
{ crc  1/21/83 -- LpOfPt: guarantees ich < atld.ichLim }
{ tjm  1/11/83 -- InsChTld => FGenInsChTld }
{ crc 11/15/82 -- Uses changes, ocrb no longer exported by font manager }
{ jrm 11/15/82 -- set acrd.arec.strec.fSelectable := TRUE in GenCrd }
{ crc 10/21/82 -- LpOfPt modified to take fWord flag which affects result }
{ jrm  9/24/82 -- cleaned up spurious underlining of c.r.s; removed Break(22) }
{ crc  8/10/82 -- Removed decl of famLst; DevFromIcs yields devScreen }
{ jrm  6/29/82 -- USES changes: LisaGraf => QuickDraw; moved USES UnitFile }
{ crc  6/03/82 -- DevFromIcs & TyxyTld now support hi res dot matrix }
{ crc  6/02/82 -- Conditional compilation }
{ crc 05/21/82 -- tyxyTld replaced by the function TyxyTld,
                  devPrint by DevFromIcs. }
{ crc 05/11/82 -- InitFntd removed }
{ crc 04/19/82 -- added decl of devPrint, set by UnitPrt, used by GenCrdTld }
{ crc 04/06/82 -- integration with new font manager }
{ bas 03/08/82 -- eliminate tyxyArec now that arec has a tyxy }
{ bas 03/05/82 -- move ConvertTyxy and argptInch to UnitRec }
{ bas 02/22/82 -- underlining 1 below baseline; tab fill 1 above }
{ tjm 02/10/82 -- IF -> WHILE in DhWidFromIchs }
{ bas 01/27/82 -- dot matrix printing }
{ bas 01/13/82 -- USES for new wm }
{ bas 12/10/81 -- integration with font manager }
{ edited by dsy 10/29/81 }
{ edits --  1) tyxyTld defined; used so can start with tyxyScrn. }

INTERFACE

USES
    {$IFC sampcalls}                                               {gdf 2/24/84}
       {$U aplw/tracecalls.obj} tracecalls,
    {$ENDC}
    {$U Obj:UnitStd.obj} UnitStd,
    {$IFC fOS}
       {$U LibOS/Syscall.Obj }   Syscall,
    {$ELSEC}
       {$U Obj:OSStub.Obj }    Syscall,
    {$ENDC}
    {$U Obj:UnitHz.obj} UnitHz,
    {$U Obj:UnitFile.obj} UnitFile,
    {$U Obj:Storage.Obj } Storage,
    {$U Obj:QuickDraw.obj} QuickDraw,
    {$U Obj:FontMgr.Obj  } FontMgr,
    {$U Obj:Wm.Events.Obj  } Events,
    {$U Obj:Wm.Folders.Obj } Folders,
    {$U Obj:WmlStd     }    WmlStd,
    {$U Obj:WmlCrs     }    WmlCrs,
    {$U Obj:PmDecl       } PmDecl,
     {$IFC fPrintOld}                                               {gdf 1/16/84}
        {$U Obj:PrStd.Obj }     PrStd,
        {$U Obj:PrFile.Obj }    PrFile,
        {$U Obj:PrProcs.Obj }   PrProcs,
        {$U Obj:PrMgrUtil.Obj } PrMgrUtil,
        {$U Obj:PrMgr.Obj }     PrMgr,
     {$ELSEC}
        {$U Obj:PrStdInfo.Obj } PrStdInfo,
        {$U Obj:PrPublic.Obj }  PrPublic,
     {$ENDC}                                                        {gdf 1/16/84}
    {$U Obj:UnitFmt.obj} UnitFmt,
    {$U Obj:UnitCs.obj} UnitCs,
    {$U Obj:UnitFf.Obj} UnitFf,
    {$U Obj:WM.Menus.Obj } Menus,
    {$U Obj:AlertMgr.Obj } AlertMgr,
    {$U ApLW/Queue.obj} Queue,
    {$U ApLW/UnitBox.obj} UnitBox,
    {$U ApLW/UnitRec.obj} UnitRec,
    {$U ApLW/UnitOver.obj} UnitOver;

CONST
    {$IFC NOT fDbgOk} fTstTld = FALSE; {$ENDC}
    chFormFeed = 12;
    chPeriod = 46;
    chComma = 44;
    chIpg = 31;
    ichNil = -1;
    ipgNil = -1;
    dhMinMarg = 8;
    dhFromRtPageEdge = 8;
    dhMaxSlant = 16;             { this is the maximium a character might hang out
                                 of its bounding box because of italic (!)
                                 or bold (?)}
    ccrdDft = 4;

TYPE TTyloc = (tylocLstSib, tylocFather);
    TAcrd = RECORD
          arec:    TArec;
          tyloc:   TTyloc;
          ptOrigTopLft: TPt;
          icsSon:  TB;
          tyxy:    TTyxy;
          ointSon: TC;
          orec:    TC;    { orec is always non-Con & orec.tyxy = arec.tyxy }
          iimgp:   TC;
          icrd:   TB;
          END;
    TCrd = ^TAcrd;

    TAtld = RECORD
          fParSt: TF;
          iwdLim: TC;
          ichLim: TC;
          ibTreLim: TC;
          dyBase: TY;
          xLftMarg:   TX; {Used only by tycsFig?}
          xRtMarg:    TX;
          END;
    TTld = ^TAtld;

    TTych = (tychDft, tychSp, tychTab, tychCr, tychFormFeed, tychPeriod,
             tychComma, tychIpg);

    TAtre = RECORD      {BEWARE - FastGen knows some offsets to fields}
          cb:     TC;
          cbPrv:  TC;
          dlpFst:  TLp;
          ichFst: TC;
          ipgCur: TC;
          tyfill: TTyfill;
          dySuper: TC;
          arce:   TArce;
          END;
    TTre = ^TAtre;

    TTyHilight = (tyHiNil, tyHiInvert, tyHiBox);

    { Needed by sel and dsp for page numberts }
    TLppg = PACKED RECORD ipg: 0..9000; ptpg: 0..3; ich: TC; END;
    TLpOrLppg = RECORD
          CASE TF OF
          TRUE:   (lp:    TLp);
          FALSE:  (lppg:  TLppg);
          END;

VAR
    {$IFC fDbgOk} fTstTld: TF; {$ENDC}
    argacrd: ARRAY [0..ccrdDft] OF TAcrd;
    argcrd:  ARRAY [0..ccrdDft] OF TCrd;
    crdStd: TCrd;
    atld:   TAtld;
    mpichdx: TRgx;
    rgichWdFst: TRgc;
    rgichSepFst: TRgc;
    rgoxWdFst: TRgx;
    cbGrptre: TC;
    grptre: TTre;
    achadTld: TAchad;

    ipgCur: TC;

    argifnt: ARRAY [0..famLst] OF TB;

{$ifc fDbgOk}
PROCEDURE PxTld;
{$endc}
PROCEDURE InitTld     (hz: THz);
FUNCTION  HOfLp       (lp: TLp; crd: TCrd): TC;
FUNCTION  LpOfPt      (orecCon: TC; ptScrn: TPt; VAR iwd: TC; VAR orec: TC;
                       fWord: TF): TLp;
PROCEDURE LpOfIch     (ich: TC; VAR lp:TLp);
FUNCTION  IchFromLp   (lp: TLp): TC;
PROCEDURE GenCrdTld   (crd: TCrd; ics: TB; lpFst: TLp; tyxyArec: TTyxy);
PROCEDURE GenCrd      (crd: TCrd; ics: TB; lpFst: TLp; tyxyArec: TTyxy);
PROCEDURE GenImgTld   (crd: TCrd);
PROCEDURE GenImg      (crd: TCrd);
PROCEDURE HilightCrd  (crd: TCrd; oint: TC; tyHi: TTyHilight; fShow: TF);
PROCEDURE HilightTld  (crd: TCrd; oint: TC; tyHi: TTyHilight; fShow: TF);
PROCEDURE CToSp       (c: TC; VAR sp: TSp);
FUNCTION  TyxyTld     (ics: TB): TTyxy;
FUNCTION  FRceFidelity (ics: TB; rce: TRce): TF;
FUNCTION  FGenInsChTld(ich: TC; ch: TCh; arce: TArce) : TF;
FUNCTION  LpPrvVis    (ics: TB; lp: TLp) : TLp;
PROCEDURE DptPaperSize (ics: TB; tyxyDst: TTyxy; {OUT} VAR dpt: TPt);


IMPLEMENTATION

{$IFC fSymOK }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

CONST cchSeqTld = 80;
    ichLstTld = 280;
    dxtbStd = 8;
    cchTstLst = 10;

TYPE TSpName = STRING[30];

VAR cbOvhAtre:      TB;
    ichLimTld: TC;
    argtych: ARRAY [0..255] OF TTych;
    hzTld: THz;
    xOrYDummy: TCd;
    prprfDflt: TprRec;                          {2/10/84 gdf}

{$S LWCom3}
{------------------------------------------------------}
PROCEDURE DptPaperSize {(ics: TB; tyxyDst: TTYxy; (*OUT*) VAR dpt: TPt)};
{------------------------------------------------------}
CONST
  dptPerInch = 6;
VAR
  hcs:  THcs;
  edev: TEDev;
  pgSize: TPgSize;

{$IFC fPrintOld}                                                    {gdf 1/16/84}

  prstl: TPrStl;

{$ELSEC}                                                            {gdf 1/16/84}

  prRec: TPrRec;                                                    {gdf 2/2/84 }

{$ENDC}                                                             {gdf 1/16/84}

  {prinfo: TPrInfo;}  {this was already gone before my time, gdf 1/16/84}

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcs := POINTER(ORD(rghcs^[ics]));

{$IFC fPrintOld}                                                    {gdf 1/16/84}

CASE hcs^^.tycs OF
tycsEd,
tycsRuler,
tycsPg:    BEGIN
           edev := hcs^^.prprf.edev;
           prstl := hcs^^.prprf.rgstl[edev];
           CASE prstl.adev.edev OF
             edevDotMx,
             edevHDotMx: IF prstl.adev.fPortrait THEN
                            pgSize := prstl.pgSize
                         ELSE
                            BEGIN
                            pgSize.cWidth := prstl.pgSize.cHeight;
                            pgSize.cHeight := prstl.pgSize.cWidth;
                            END;
           OTHERWISE     pgSize := prstl.pgSize;
           END;
           { PrMetrics(hcs^^.prprf, prinfo);
             dpt.h := (prinfo.rPaper.right * dptPerInch) DIV prinfo.hRes;
             dpt.v := (prinfo.rPaper.bottom * dptPerInch) DIV prinfo.vRes;
           }
           END;
OTHERWISE BEGIN
           PrStlDefault(prstl, edevScreen);
           pgSize := prstl.pgSize;
           END;
END {CASE};
dpt.h := pgSize.cWidth; dpt.v := pgSize.cHeight;
ConvertTyxy(dpt.h, dpt.v, tyxyPgFract, tyxyDst);

{$ELSEC}                                                            {gdf 1/16/84}

CASE hcs^^.tycs OF                                                  {gdf 2/2/84}
tycsEd,
tycsRuler,
tycsPg:    BEGIN
           prRec := hcs^^.prprf;
           (** don't need edev anymore???  edev := prRec.PrInfo.Adev.edev; **)
           pgSize := prRec.PrInfo.PgSize;
           (******************************************** removed, gdf 3/12/84
           IF pgSize.PrintDirect <> pgSize.PaperDirect THEN BEGIN
                pgsize.Width := prRec.PrInfo.PgSize.Height;
                pgsize.Height := prRec.PrInfo.PgSize.Width;
                END;
           *** new PrintShop already handles the flip???      gdf 3/12/84 ***)
           END;
OTHERWISE  BEGIN {Not a printable stream... Is it the scrap, maybe??? gdf 2/2/84}
           (*************************************
           PrStlDefault(prRec,edevScreen);  {This proc is gone now.   gdf 2/2/84}
                                            {Hmmm, what did it do???  gdf 2/2/84}
                                            {What about prPrfDefault? gdf 2/2/84}
           pgSize:=prRec.prInfo.pgSize;     {Oh, well, try this???    gdf 2/2/84}
           *************************************)
           {Safe bet: Default to screen metrics ???                   gdf 2/2/84}
           pgSize.Width := 1020;  { 8.5 x 120 }                      {gdf 2/2/84}
           pgSize.Height := 1320;  { 11 x 120 }                      {gdf 2/2/84}
           END;
END;  {CASE}

(*******************
The following was a temporary fix,
only for screen imaging for dot mx portrait.
Now use info from pgSize instead.
dpt.h := 1320;  { 11 x 120 }
dpt.v := 1020;  { 8.5 x 120 }
removed 2/2/84, by gdf
********************)

dpt.h := pgSize.Width;                                              {gdf 2/2/84}
dpt.v := pgSize.Height;                                             {gdf 2/2/84}
ConvertTyxy(dpt.h, dpt.v, tyxyPgFract, tyxyDst);

{$ENDC}                                                             {gdf 1/16/84}
END {DptPaperSize};


{$S LWMenu}
{--------------------------------------------}
FUNCTION LpPrvVis { (ics: TB; lp: TLp) : TLp };
{--------------------------------------------}
LABEL 6;
VAR tyset: TTyset;
    achadVis: TAchad;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH tyset DO BEGIN fRce := TRUE; fRpe := FALSE; fParBnds := FALSE; END;
WHILE lp > 0 DO
  BEGIN
  lp := lp - 1;
  achadVis.rgch := NIL;
  SetLpd(lpdStd, ics, lp, tyset, achadVis);
  IF NOT lpdStd^.rce^.fVan THEN GOTO 6;
  END;
lp := -1; {no previous visible character}
6:
LpPrvVis := lp;
END;

{$S LWPage}
{---------------------------------}
PROCEDURE CToSp{c: TC; VAR sp: TSp};
{---------------------------------}
VAR
ich: TC;
PROCEDURE GenDigits(c1: TC);
    VAR
    digit: TC;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    DivMod(c1, 10, c1, digit);
    IF c1 > 0 THEN GenDigits(c1);
    ich := ich + 1;
    sp[ich] := CHR(digit + ORD('0'));
    END;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
ich := 0;
GenDigits(c);
sp[0] := CHR(ich);
END;



{$ifc fDbgOk}
{$S LWDebug}
{-------------------------}
PROCEDURE PxTre(tre: TTre);
{-------------------------}
VAR ibTre: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
ibTre := ORD(tre) - ORD(grptre);
WITH tre^ DO
    BEGIN
    WRITELN('tre: ', ORD(tre), ', ibTre:', ibTre:4,
          '; cb:', cb:3, '; cbPrv:', cbPrv:3,
          'ichFst:', ichFst:3, '; dlpFst:', dlpFst);
    IF tre^.cb <> 0 THEN
         BEGIN
         WRITELN('  ipgCur:', ipgCur,
           '; tyfill:', ORD(tyfill):2,
           '; dySuper:', ORD(dySuper):2);
         WRITE('  '); PxArce(arce);
         END;
    END;
END;

{--------------}
PROCEDURE PxCrd(crd: TCrd);
{--------------}
LABEL 77;
VAR iwd: TC; ich: TC; oxT: TX; tre: TTre; ibTre: TC; pint: TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WRITELN('Crd: ', ORD(crd), ', icrd: ', crd^.icrd:3, ', icsSon: ', crd^.icsSon:4);
WITH crd^.arec DO
    BEGIN
    PxInt(ointDep);
    WRITELN('  dlpLim: ', dlpLim:5, '; arec.tyxy: ', ORD(tyxy), '; r: [',
              r.left:5, r.top:5, r.right:5, r.bottom:5, ']');
    END;
WRITELN('   tyloc:', ORD(crdStd^.tyloc):2, '; tyxy:', ORD(crd^.tyxy):2,
  '; fKeep:', crd^.arec.strec.fKeep, '; fParSt:', crd^.arec.strec.fParSt);
WRITELN('   ptOrigTopLft: [', crd^.ptOrigTopLft.h:5, ', ',
  crd^.ptOrigTopLft.v:5, ']');
IF crd^.icsSon <> icsNil THEN
     BEGIN
     { PxInt(crd^.ointSon); }
     PxCrd(argcrd[crd^.icrd + 1]);
     END;
pint := POINTER(ORD(lldInt) + crd^.arec.ointDep);
IF (rghcs^[pint^.ics]^^.tycs <> tycsPg) AND FTextIcs(pint^.ics) THEN
    BEGIN
    WITH atld DO
          BEGIN
          WRITELN(' ichLim:', ichLim:4, '; iwdLim:', iwdLim:3,
                 '; ibTreLim:', ibTreLim:4, '; dyBase:', dyBase:3);
          oxT := 0;
          FOR iwd := 0 TO iwdLim - 1 DO
               BEGIN
               WRITELN(' iwd:', iwd:3, '; ichWd:', rgichWdFst^[iwd]:4,
                 '; ichSep:',
                 rgichSepFst^[iwd]:4, '; oxWdFst:', rgoxWdFst^[iwd]:4);
               IF rgoxWdFst^[iwd] <> oxT THEN
                 WRITELN('ERROR: oxWdFst (', rgoxWdFst^[iwd],
                     ') <> SUM(dx''s) (', oxT, ')');
               WRITE('                   ich:', ich:4, ';        "');
               FOR ich := rgichWdFst^[iwd] TO rgichWdFst^[iwd+1]-1 DO
                 CASE achadTld.rgch^[ich] OF
                     chSp:      WRITE('_');
                     chIpg:      WRITE('<ipg>');
                     chTab:     WRITE('<tab>');
                     chCr:      WRITE('<cr>');
                     OTHERWISE  WRITE(CHR(achadTld.rgch^[ich]));
                     END;
               WRITELN('"');
               WRITE('                   dx''s: ');
               FOR ich := rgichWdFst^[iwd] TO rgichWdFst^[iwd+1]-1 DO
                 BEGIN
                 WRITE(mpichdx^[ich]:3);
                 oxT := oxT + mpichdx^[ich];
                 END;
               WRITELN;
               END;
          END;
    ibTre := 0;
    WHILE TRUE DO
          BEGIN
          tre := POINTER(ORD(grptre) + ibTre);
          PxTre(tre);
          IF ibTre = atld.ibTreLim THEN GOTO 77;
          ibTre := ibTre + tre^.cb;
          END;
77:
    WRITELN(' ichFstWdLim: ', rgichWdFst^[atld.iwdLim],
          ' oxFstWdLim: ', rgoxWdFst^[atld.iwdLim]);
    achadTld.ichFst := 0; achadTld.ichLim := atld.ichLim;
    PxAchad(achadTld);
    END;
END;

{--------------}
PROCEDURE PxTld;
{--------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
PxCrd(crdStd);
END;
{$endc}

{$S LWCom3}
{$ifc fInkJet}
{--------------------------------}
FUNCTION TyxyTld {(ics: TB):TTyxy};
{--------------------------------}
LABEL 4;
VAR
  hcs: THcs;
  tyxy: TTyxy;
  ptInch: TPt;
  tyxyOrB: RECORD
          CASE TF OF
          TRUE:   (tyxy: TTyxy);
          FALSE:  (b: TB);
          END;

BEGIN
hcs := POINTER(ORD(rghcs^[ics]));
tyxy := hcs^^.tyxy;
WITH hcs^^.prprf.prInfo DO
  BEGIN
  ptInch.h := hRes;
  ptInch.v := vRes;
  END;
IF (tyxy = tyxyNil)
  OR (ptInch.h <> argptInch[tyxy].h) OR (ptInch.v <> argptInch[tyxy].v) THEN
     BEGIN
     FOR tyxy := tyxyScrn TO tyxyLst DO
          BEGIN
          WITH argptInch[tyxy] DO
            IF (h = ptInch.h) AND (v = ptInch.v) THEN
               BEGIN
               hcs^^.tyxy := tyxy;
               GOTO 4;
               END;
          END;
     tyxyOrB.b := ORD(tyxyLst) + 1;
     argptInch[tyxyOrB.tyxy] := ptInch;
     hcs^^.tyxy := tyxyOrB.tyxy;
     IF (tyxyOrB.tyxy) <> tyxyNil THEN
          tyxyLst := tyxyOrB.tyxy;
     END;
4:
TyxyTld := hcs^^.tyxy;
END {TyxyTld};

{$elsec} {not fInkJet}
{--------------------------------}
FUNCTION TyxyTld {(ics: TB):TTyxy};
{--------------------------------}
VAR
  hcs: THcs;
  edev: TEDev;
  fPortrait: TF;
  fHRes: TF;                                                        {gdf 2/2/84}

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}

hcs := POINTER(ORD(rghcs^[ics]));
IF (hcs^^.tycs=tycsEd) OR (hcs^^.tycs=tycsPg) THEN BEGIN
    edev := hcs^^.prprf.prInfo.adev.edev;                           {gdf 2/2/84}
    IF fTstTld THEN BEGIN
       WRITELN('TyxyTld edev: ', ord(edev));                { gdf 2/13/84 }
       fHres := hcs^^.prprf.prInfo.adev.fHiRes;               { gdf 2/2/84}
       WRITELN('TyxyTld fHires: ', fHRes);                  { gdf 2/13/84 }
       fPortrait := hcs^^.prprf.prInfo.adev.fPortrait;        { gdf 2/2/84}
       WRITELN('TyxyTld fPortrait: ', fPortrait);           { gdf 2/13/84 }
    END; {if fTstTld}
    CASE edev OF
    edevTyper: TyxyTld := tyxyIp;
    edevDotMx: BEGIN
               fPortrait := (hcs^^.prprf.prInfo.PgSize.PrintDirect = Portrait);
               fHRes := hcs^^.prprf.prInfo.adev.fHiRes;             {gdf 2/22/84}
               IF NOT fHRes THEN                                   {gdf 2/22/84}
                  IF fPortrait THEN
                         TyxyTld := tyxyDotMx
                    ELSE TyxyTld := tyxyLDotMx
               ELSE
                  IF fPortrait THEN
                         TyxyTld := tyxyHiDotMx
                    ELSE TyxyTld := tyxyLHiDotMx;
               END;
    edevHdotmx: BEGIN                                         { tjm/gdf 2/14/84 }
               fPortrait := (hcs^^.prprf.prInfo.PgSize.PrintDirect = Portrait);
               IF fPortrait THEN
                         TyxyTld := tyxyHiDotMx
                    ELSE TyxyTld := tyxyLHiDotMx;
               END;
    OTHERWISE  (*** Before we ever get here, should we give
                       an alert about an unsupported device???  gdf 2/2/84 ***)
               TyxyTld := TyxyHiDotMx;     { formerly:  tyxyDotMx    gdf 3/12/84}
    END {CASE}
END
ELSE TyxyTld := TyxyHiDotMx;               { formerly:  tyxyScrn     gdf 3/12/84}

{note: defaults should agree with printshop default, now HiDotMx     gdf 3/12/84}

END {TyxyTld};
{$endc} {fInkJet}

(******************************* DevFromIcs replaced by FillInLFntId 2/10/84 gdf
{---------------------------------}
FUNCTION DevFromIcs (ics: TB):TDev;
{---------------------------------}
VAR
  hcs:  THcs;
  edev: TEDev;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcs := POINTER(ORD(rghcs^[ics]));
IF (hcs^^.tycs=tycsEd) OR (hcs^^.tycs=tycsPg) THEN

{$IFC fPrintOld}                                                    {gdf 1/16/84}
     DevFromIcs := PrDev(hcs^^.prprf)
{$ELSEC}
     DevFromIcs := hcs^^.prprf.prInfo.adev.dev     {??? see dc}     {gdf 2/8/84 }
{$ENDC}

ELSE BEGIN
     {break(918);}
     DevFromIcs := devScreen;
     END;

END; {DevFromIcs}
****************************************replaced by FillInLFntId 2/10/84 gdf ***)



{---------------------------------}              {FillInLFntId new, gdf 2/10/84 }
PROCEDURE FillInLFntId (ics: TB; fam: TFam; seteFace: style; var lfntid: Tlfntid);
{---------------------------------}
VAR
  hcs:  THcs;
  edev: TEDev;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcs := POINTER(ORD(rghcs^[ics]));
IF (hcs^^.tycs=tycsEd) OR (hcs^^.tycs=tycsPg) THEN
     PrLFntId(hcs^^.prprf, fam, seteface, lfntid)

ELSE BEGIN
     {break(918);}
     PrLFntId(prprfDflt, fam, seteface, lfntid)
     END;

     IF fTstTld THEN
        WRITELN('FillInLFntId edev: ', ord(lfntid.edev));     { gdf 2/13/84 }
END; {FillInLFntId}

{$S LWStyle}
{---------------------------------}
FUNCTION FRceFidelity {ics: TB, rce: TRce): TF};
{---------------------------------}
VAR lfntid: TLfntid;
    lfntidT: TLfntid;
    finfo: FontInfo;
    cError: TC;
    seteface: style;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
seteface := [];
IF rce^.fBold      THEN seteface := seteface + [bold];
IF rce^.fItalic    THEN seteface := seteface + [italic];
FillInLFntId (ics, argfam[rce^.ifnt], seteFace, lfntid);      {gdf 2/10/84 }
lfntidT := lfntid;
IF {NOT} FMFontMetrics(lfntid, finfo, cError) THEN BEGIN END;
FRceFidelity := (lfntid.fam = lfntidT.fam) AND
                (lfntid.seteface = lfntidT.seteface);
END; {FRceFidelity}



{------------------------------------------------------------}
PROCEDURE CallGenCrd(crd: TCrd; ics: TB; lpFst: TLp; tyxyArec: TTyxy; proc: TProc);
EXTERNAL;

{$S LWCommand}
PROCEDURE GenCrd { (crd: TCrd, ics: TB; lpFst: TLp; tyxyArec: TTyxy) };
{------------------------------------------------------------}
VAR pint: TPint;
    dxWid: TX;
    dyHt:  TY;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
pint := POINTER(ORD(lldInt)+crd^.arec.ointDep);
WITH crd^.arec.r DO BEGIN
    dyHt := bottom - top;
    IF (pint^.ics = ics) AND (pint^.lpFst = lpFst) AND pint^.fValid
      AND (crd^.arec.tyxy = tyxyArec) THEN
         BEGIN
         dxWid   := right - left;
         topLeft := crd^.ptOrigTopLft;
         right   := left + dxWid;
         bottom  := top + dyHt;
         END
    ELSE BEGIN
         top := 0;
         bottom := dyHt;
         crd^.icsSon := icsNil;
         crd^.orec := orecNil;
         crd^.arec.foPrnt := foNil;
         crd^.arec.strec.fKeep := FALSE;
         crd^.arec.strec.fSelectable := TRUE;
         crd^.arec.strec.fParSt := FALSE;
         CallGenCrd(crd, ics, lpFst, tyxyArec, rghcs^[ics]^^.cspd.argproc[iprocCrd]);
         crd^.ptOrigTopLft := topLeft;
         END;
    END;
{$ifc fDbgOk}
IF fTstTld THEN PxCrd(crd);
{$endc}
END;

 {====================}
 {$I aplw/GenCrdTld.Text }
 {====================}

{$S LWCommand}
{-----------------------------------}
FUNCTION IchFromLp { (lp: TLp) : TC };
{-----------------------------------}
LABEL   12;
VAR tre, trePrv:  TTre;
    ichLim, ichT:   TC;
    pint:   TPint;
    dlpTld:    TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstTld THEN WRITE('IchFromLp(', lp, ')');
tre := grptre;
pint := POINTER(ORD(lldInt) + crdStd^.arec.ointDep);
dlpTld := lp - pint^.lpFst;
WHILE TRUE DO
    BEGIN
    trePrv := tre;
    {$ifc fDbgOk}
    IF fTstTld THEN PxTre(tre);
    {$endc}
    tre := POINTER(ORD(tre) + tre^.cb);
    ichLim := tre^.ichFst;
    IF tre^.cb = 0 THEN GOTO 12;
    IF dlpTld < tre^.dlpFst THEN GOTO 12;
    END;
12:
{$ifc fDbgOk}
IF fTstTld THEN PxTre(trePrv);
{$endc}
 { Can't select an lp-gap between ich's }
IF trePrv^.ichFst + (dlpTld - trePrv^.dlpFst) > ichLim
   THEN ichT := ichLim
   ELSE ichT := trePrv^.ichFst + (dlpTld - trePrv^.dlpFst);
          { IF ichT < 0 THEN Break(22); }
IchFromLp := CMax(ichT, 0);
END;

{$S LWInsert}
PROCEDURE SetTreCharStyle(tre: TTre);
{ old print...  VAR tyfc: TSeteface;}
VAR tyfc: Style;  {new print}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tyfc := [];  { Normal face }
IF tre^.arce.fBold   THEN tyfc := tyfc + [bold];
IF tre^.arce.fItalic THEN tyfc := tyfc + [italic];
TextFont(argfam[tre^.arce.ifnt]);
TextFace(tyfc);
END; {SetTreCharStyle}

FUNCTION TreFromIch(ich: TC) : TTre;
VAR tre: TTre;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tre := grptre;
WHILE (ich < tre^.ichFst) AND (tre^.cb <> 0) DO
    BEGIN
    tre := POINTER(ORD(tre) + tre^.cb);
    END;
TreFromIch := tre;
END;

{$S LWType}
FUNCTION DvBaseLine(crd: TCrd) : TC;
VAR tre: TTre;
    lfntid: TLfntid;
    dvBase: TY;
    dyAboveBase: TC;
    cbSuper: TC;
    finfo: FontInfo;
    cError: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tre := grptre;
dvBase := 0;
WHILE (tre^.cb <> 0) DO
     BEGIN
     IF NOT tre^.arce.fVan THEN
          BEGIN
          WITH lfntid, tre^ DO BEGIN
            fam := argfam[arce.ifnt];
            seteface := [];
            IF arce.fBold      THEN seteface := seteface + [bold];
            IF arce.fItalic    THEN seteface := seteface + [italic];
            dev := devScreen;
            END;
          IF NOT FmFontMetrics(lfntid, finfo, cError) THEN Break(1600);
          cbSuper := tre^.dySuper;
          ConvertTyxy(xOrYDummy, cbSuper, crd^.tyxy, tyxyScrn);
          dyAboveBase := finfo.ascent;
          IF cbSuper > 0 THEN dyAboveBase := dyAboveBase + cbSuper;
          { What about dyLine?
          IF cbSuper > 0 THEN dyAboveBase := dyAboveBase + CMax(cbSuper,
          dyLine);
          }
          dvBase := CMax(dyAboveBase, dvBase);
          END;
     tre := POINTER(ORD(tre) + tre^.cb);
     END;
DvBaseLine := dvBase;
END;

{$S LWInsert}
{------------------------------------------}
FUNCTION DhWidFromIchs(ichFst: TC; ichLim: TC): TC;
{------------------------------------------}
 { Returns x position at left of lp, relative to rec. }
VAR ich: TC;
    dh: TC;
    tre: TTre;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tre := TreFromIch(ichFst);
dh := 0;
FOR ich := ichFst TO ichLim - 1 DO
    BEGIN
    WHILE tre^.ichFst <= ich DO
          BEGIN
          SetTreCharStyle(tre);
          tre := POINTER(ORD(tre) + tre^.cb);
          END;
    dh := dh + CharWidth(CHR(achadTld.rgch^[ich]));
    END;
DhWidFromIchs := dh;
END;

{ ----------------------------------------------------------------------------
}
{  HOfLp positions for the screen, using the rgox* arrays to find the nearest
}
{  word and then the display widths to position within the word.  Hence, it is
}
{  only valuable for use with the display - especially selection.
}
{ ----------------------------------------------------------------------------
}


{$S LWCommand}
{------------------------------------------}
FUNCTION HOfLp { (lp: TLp; crd: TCrd): TC };
{------------------------------------------}
 { Returns x position at left of lp. }
VAR ich, ichT, dh, dx, iwd: TC; pint: TPint; lpLimRec: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstTld THEN WRITELN(' HOfLp - lp: ', lp);
pint := POINTER(ORD(lldInt) + crd^.arec.ointDep);
lpLimRec := pint^.lpFst + crd^.arec.dlpLim;
IF crd^.arec.tyxy = crd^.tyxy THEN
     BEGIN
     dx := crd^.arec.r.left;
     dh := 0;
     END
ELSE BEGIN
     dx := 0;
     dh := crd^.arec.r.left;
     IF crd^.arec.tyxy <> tyxyScrn THEN { Can this happen? }
          ConvertTyxy(dh, xOrYDummy, crd^.arec.tyxy, tyxyScrn);
     END;
IF lp <= pint^.lpFst THEN
     BEGIN
     dx := dx + rgoxWdFst^[0];
     END
{ dhMaxSlant makes this optimization incorrect
ELSE IF lp >= lpLimRec THEN
     BEGIN
     dx := 0;
     dh := crd^.arec.r.right;
     ConvertTyxy(dh, xOrYDummy, crd^.arec.tyxy, tyxyScrn);
     END
}
ELSE BEGIN
     IF lp >= lpLimRec THEN
          BEGIN
          ich := atld.ichLim;
          iwd := atld.iwdLim - 1;
          END
     ELSE BEGIN
          ich := IchFromLp(lp);
          iwd := IBinSearch(rgichWdFst, atld.iwdLim-1, ich);
          END;
     IF ich > rgichSepFst^[iwd] THEN
          BEGIN
          dx := dx + rgoxWdFst^[iwd + 1];
          FOR ichT := rgichWdFst^[iwd + 1] - 1 DOWNTO ich DO
              dx := dx - mpichdx^[ichT];
          END
     ELSE BEGIN
          dx := dx + rgoxWdFst^[iwd];
          dh := dh + DhWidFromIchs(rgichWdFst^[iwd], ich);
          END;
     END;
ConvertTyxy(dx, xOrYDummy, crd^.tyxy, tyxyScrn);
HOfLp := dh + dx;
IF fTstTld THEN WRITELN('  dh:',dh, ', ich: ', ich, ', iwd: ', iwd);
END;

{$S LWInsert}
{------------------------------------------}
PROCEDURE LpOfIch { (ich: TC; VAR lp: TLp) };
{------------------------------------------}
 { Assumes GenCrdTld has been called for the line in question. }
VAR dch: TC;
    tre: TTre;
    pint: TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tre := grptre;
REPEAT
   tre := POINTER(ORD(tre) + tre^.cb);
UNTIL (tre^.ichFst > ich) OR (tre^.cb = 0);
tre := POINTER(ORD(tre) - tre^.cbPrv);
pint := POINTER(ORD(lldInt) + crdStd^.arec.ointDep);
lp := pint^.lpFst + tre^.dlpFst;
dch := ich - tre^.ichFst;
lp := lp + dch;
IF fTstTld THEN WRITELN('LpOfIch - ich:',ich,', lp: ', lp);
END;

{-------------------------------------------------------------------------------}
FUNCTION LpOfPt {(orecCon: TC; ptScrn: TPt; VAR iwd: TC; VAR orec: TC; fWord:TF): TLp};
{-------------------------------------------------------------------------------}
 { Given the pt in the orecCon, returns the lp, orec and iwd. }
 { Assumes pt is in screen coordinates. }
LABEL 100, 200;
VAR ox, oxT, ich, iwdT, dxTopLft, dx, dhToggle, dhWd, dhLim, dhCh: TC;
    dxToggle, dxWd: TC;
    rec: TRec; pint: TPint; lp: TLp; rRec: TR;
    tre: TTre;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstTld THEN WRITELN('LpOfPt');
rec := POINTER(ORD(dsp) + orecCon);
orec := OrecOfPt(rec^.orecSon, TRUE, ptScrn, TRUE);
IF orec = orecNil THEN
     lp := lpNil
ELSE BEGIN
     rec := POINTER(ORD(dsp) + orec);
     IF rec^.orecSon = orecNil THEN
         BEGIN
         pint := POINTER(ORD(lldInt) + rec^.ointDep);
         IF FTextIcs(pint^.ics) THEN
              BEGIN
              rec := POINTER(ORD(dsp) + orec);
              IF rec^.r.bottom <= 0 THEN
                  BEGIN
                  pint := POINTER(ORD(lldInt) + rec^.ointDep);
                  lp := LpMaxP(0, LpPrvVis(pint^.ics, pint^.lpFst + rec^.dlpLim));
                  END
              ELSE
                  BEGIN
                  pint := POINTER(ORD(lldInt) + rec^.ointDep);
                  GenCrd(crdStd, pint^.ics, pint^.lpFst, rec^.tyxy);
                  rec := POINTER(ORD(dsp) + orec);
                  ConvertRTyxy(rec^.r, rRec, rec^.tyxy, tyxyScrn);

                  ich := 0;
                  iwd := 0;
                  IF (ptScrn.h >= rRec.right) OR (ptScrn.v >= rRec.bottom) THEN
                       BEGIN         { last character/word }
                       IF fTstTld THEN WRITELN('Right of line.');
                       ich := atld.ichLim - 1;
                       iwd := atld.iwdLim - 1;
                       END
                  ELSE IF ptScrn.h < rRec.left  THEN
                       BEGIN         { first character/word }
                       IF fTstTld THEN WRITELN('Left of line.');
                       END
                  ELSE BEGIN          { loop through words }
                       ox := ptScrn.h - rRec.left;
                       ConvertTyxy(ox, xOrYDummy, tyxyScrn, crdStd^.tyxy);
                       iwd := atld.iwdLim - 1;
                       FOR iwdT := 0 TO atld.iwdLim - 1 DO
                            IF rgoxWdFst^[iwdT + 1] > ox THEN
                                 BEGIN iwd := iwdT; GOTO 100; END;
    100:
                       IF fTstTld THEN WRITELN(' iwd: ',iwd);
                        { from beginning of word, find the character - using screen
                        widths }
                       ich := rgichWdFst^[iwd];
                       dhWd := rgoxWdFst^[iwd];
                       ConvertTyxy(dhWd, xOrYDummy, crdStd^.tyxy, tyxyScrn);
                       dhLim := (ptScrn.h - rRec.left);
                       tre := TreFromIch(ich);
                       WHILE (ich < rgichSepFst^[iwd]) DO
                            BEGIN
                            WHILE tre^.ichFst <= ich DO
                                  BEGIN
                                  SetTreCharStyle(tre);
                                  tre := POINTER(ORD(tre) + tre^.cb);
                                  END;
                            dhCh := CharWidth(CHR(achadTld.rgch^[ich]));
                            IF fWord THEN
                                 dhToggle := 0
                            ELSE dhToggle := WShRt(dhCh, 1);
                            dhWd := dhWd + dhCh;
                            IF dhWd - dhToggle >= dhLim THEN GOTO 200;
                            ich := ich + 1;
                            END;
                       dxWd := dhWd;
                       ConvertTyxy(dxWd, xOrYDummy, tyxyScrn, crdStd^.tyxy);
                       WHILE (ich < rgichWdFst^[iwd + 1]) DO
                            BEGIN
                            IF ich = rgichWdFst^[iwd + 1] - 1 THEN
                                 dx := rgoxWdFst^[iwd + 1] - dxWd
                            ELSE
                                 dx := mpichdx^[ich];
                            IF fWord THEN
                                 dxToggle := 0
                            ELSE dxToggle := WShRt(dx, 1);
                            dxWd := dxWd + dx;
                            IF dxWd - dxToggle >= ox THEN GOTO 200;
                            ich := ich + 1;
                            END;
    200:
                       { dx := mpichdx^[ich];
                       oxT := rgoxWdFst^[iwd] + dx;
                       IF NOT fWord THEN dxToggle := WShRt(dx, 1)
                       ELSE dxToggle := 0;
                       WHILE (ich < atld.ichLim) AND (oxT - dxToggle < ox) DO
                            BEGIN
                            ich := ich + 1;
                            dx := mpichdx^[ich];
                            oxT := oxT + dx;
                            IF NOT fWord THEN dxToggle := WShRt(dx, 1);
                            END;
                        }
                        END;
                  ich := CMin(ich, atld.ichLim-1);
                  LpOfIch(ich, lp);
                  IF fTstTld THEN WRITELN('LpOfPt --> ich:',ich,', lp:', lp);
                  END;
              END
         ELSE lp := lpNil;
         END
     ELSE lp := LpOfPt(rec^.orecSon, ptScrn, iwd, orec, fWord);
     END;
LpOfPt := lp;
END;

{---------------------------------------------------------}
PROCEDURE CallHilight(crd: TCrd; oint: TC; tyHi: TTyHilight; fShow: TF; proc:
TProc);
                                                                  EXTERNAL;
{$S LWCommand}
PROCEDURE HilightCrd { (crd: TCrd; oint: TC; tyHi: TTyHilight; fShow: TF };
{---------------------------------------------------------}
VAR pint, pintHi: TPint;
    proc:   TProc;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstTld THEN WRITELN('HilightCrd(', ORD(crd));
pintHi := POINTER(ORD(lldInt) + oint);
pint := POINTER(ORD(lldInt) + crd^.arec.ointDep);
IF (pint^.ics = pintHi^.ics) AND pint^.fValid AND (pintHi^.lpFst <> lpNil) THEN
    BEGIN
    IF (pintHi^.lpLim >= pint^.lpFst) AND
    (pintHi^.lpFst < (pint^.lpFst + crd^.arec.dlpLim)) THEN
          BEGIN
          proc := rghcs^[pint^.ics]^^.cspd.argproc[iprocHilight];
          IF proc <> POINTER(procNil) THEN
               CallHilight(crd, oint, tyHi, fShow, proc);
          END;
    END;
END;

{---------------------------------------------------------}
PROCEDURE HilightTld { (crd: TCrd; oint: TC; tyHi: TTyHilight; fShow: TF };
{---------------------------------------------------------}
 { Hilights that part of selection which intersects orec. }
 { Assumes GenCrdTld has just been called for this rec }
VAR pboxPane: TPbox; pintHi: TPint; r: TR; dxT: TX;
    pint: TPint; lpLimRec: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstTld THEN WRITELN('HilightTld(', ORD(crd));
ConvertRTyxy(crd^.arec.r, r, crd^.arec.tyxy, tyxyScrn);
pint := POINTER(ORD(lldInt) + crd^.arec.ointDep);
lpLimRec := pint^.lpFst + crd^.arec.dlpLim;
pintHi := POINTER(ORD(lldInt) + oint);
r.right := CMin(r.right, HOfLp(pintHi^.lpLim, crd));
pintHi := POINTER(ORD(lldInt) + oint);
IF pintHi^.lpFst = pintHi^.lpLim THEN
     r.left := r.right-dhCaret
ELSE r.left := HOfLp(pintHi^.lpFst, crd);
IF FClipR(r, crd^.orec) THEN IF tyHi = tyHiInvert THEN InvertRect(r);
END;


PROCEDURE CallGenImg(crd: TCrd; proc: TProc);  EXTERNAL;

{$S LWCom1}
{------------------------------}
PROCEDURE GenImg { (crd: TCrd) };
{------------------------------}
VAR pint:   TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
pint := POINTER(ORD(lldInt) + crd^.arec.ointDep);
CallGenImg(crd, rghcs^[pint^.ics]^^.cspd.argimgp[crd^.iimgp]);
END;


PROCEDURE FastGen (rgoxWdFst:  TRgx; argptInch:  TP;  tyxyScrn:  TTyxy; MoveTo:TP;
                   NextTre:  TP; atld:  TAtld; rgichWdFst:  TRgc; achadTld:
                   TAchad;
                   rgichSepFst:  TRgc; CToSp:  TP; DrawText:  TP; mpichdx:
                   TRgx;
                   DrawString:  TP; GenTabImg:  TP; fReqBrk: TF);
EXTERNAL;

{---------------------------------}
PROCEDURE GenImgTld { (crd: TCrd) };
{---------------------------------}
LABEL 99;
VAR
   { !!! BEWARE:  the order of the following is crucial to  FastGen !!! }
    treCur: TTre;
    dyBaseCur: TC; cchTre: TC; ich: TC; hLeftArec: TX;
    iwd: TC;
    tyxy: TTyxy;
    spIpg: TSp;
   { !!! the above decls cannot be changed without changing FastGen !!! }

    r: TR;
    treNxt: TTre;
    dyBaseline: TC;
    x, xFstUl: TC;
    ichT, cchWd, cchSep, cchDraw: TC;
    fUl: TF;
    dxTb: TC;
    ichFstSep, ichLimSep: TC;
    ptPen: TPt;
    rec: TRec;
    hRtArec: TX;
    fReqBrk: TF;
    ichUl: TC;
    cch: TC;
    crdSon: TCrd;
    dptOffset: TPt;

    PROCEDURE GenTabImg(ichFstSep: TC; dchSep: TC);
    VAR ichTb: TC; ichT: TC;

        PROCEDURE DoDotHyph (ch: CHAR);
        VAR ich2, i: TC; xStart: TX; xCur: TX; cchTb, dxCh: TC;
        BEGIN
        {$IFC sampcalls}  ALogCall;  {$ENDC}
        dxCh := CharWidth(ch) + 2;
        IF fTstTld THEN
             WRITELN('char: ', ch, ', dxCh:', dxCh:5, '; dxTb:', dxTb:5);
         { Find where the start of tab is. }
        xCur := rgoxWdFst^[iwd] + 2;
        FOR ich2 := rgichWdFst^[iwd] TO ichTb - 1 DO
            xCur := xCur + mpichdx^[ich2];
        ConvertTyxy(xCur, xOrYDummy, tyxy, tyxyScrn);
        xCur := xCur + hLeftArec;
        xStart := ((xCur DIV dxCh) + 1) * dxCh;
        MoveTo(xStart, dyBaseLine);
         { Set up the width of the tab. }
        dxTb := dxTb - 3 - (xStart - xCur);
        cchTb := dxTb DIV dxCh;
        FOR i := 1 TO cchTb DO BEGIN DrawChar(ch); Move(2, 0); END;
        END; { DoDotHyph }

    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    IF fTstTld THEN
       WRITELN('GenTabImg: tyfill:', ORD(treCur^.tyfill):3,
                       ';  ich:', ichFstSep:4, '; dchSep:', dchSep:3);
    FOR ichTb := ichFstSep TO ichFstSep + dchSep - 1 DO
        IF achadTld.rgch^[ichTb] = chTab THEN
            BEGIN
            IF fTstTld THEN WRITELN('ichTb:', ichTb:4);
             { Generate the image... }
            dxTb := mpichdx^[ichTb];
            ConvertTyxy(dxtb, xOrYDummy, tyxy, tyxyScrn);
            CASE treCur^.tyfill OF
               tyfillDots: DoDotHyph('.');
               tyfillHyph: DoDotHyph('-');
               tyfillUL:   BEGIN
                           { put pen in right place. }
                           x := rgoxWdFst^[iwd + 1];
                           FOR ichT := rgichWdFst^[iwd + 1] - 1 DOWNTO ichTb DO
                                x := x - mpichdx^[ichT];
                           ConvertTyxy(x, xOrYDummy, tyxy, tyxyScrn);
                           MoveTo(x + hLeftArec + 2, dyBaseline + 1);
                           Line(dxtb - 4, 0); Move(0, dyBaseCur - dyBaseLine -1);
                           END;
               OTHERWISE   Break(98);
               END;
            END;
    END; { GenTabImg }

    PROCEDURE SetTreStyle;
    VAR ptPen: TPt; cbSuper: TC; dyBaseOld: TC;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    { Set the style for a new tre. }
    {$ifc fDbgOk}
    IF fTstTld THEN BEGIN WRITE('SetStyle: '); PxTre(treCur); END;
    {$endc}
    IF treCur^.arce.fUnderline THEN
         BEGIN
         IF NOT fUl THEN
              BEGIN
              GetPen(ptPen);
              xFstUl := ptPen.h;
              fUl := TRUE;
              ichUl := ich;
              END;
         END
    ELSE IF fUl THEN
         BEGIN
          { Draw the underline, ending here. }
         GetPen(ptPen);
         MoveTo(xFstUl, dyBaseline+1);
         IF xFstUl <> ptPen.h THEN LineTo(ptPen.h-1, dyBaseline+1);
         MoveTo(ptPen.h, ptPen.v);
         fUl := FALSE;
         END;

    SetTreCharStyle(treCur);

    cbSuper := treCur^.dySuper;
    ConvertTyxy(xOrYDummy, cbSuper, tyxy, tyxyScrn);
    dyBaseOld := dyBaseCur;
    dyBaseCur := dyBaseline - cbSuper;
     { Adjust the vertical line from the old. }
    Move(0, dyBaseCur - dyBaseOld);
    END;

    PROCEDURE NextTre;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    treCur := treNxt;
    treNxt := POINTER(ORD(treCur) + treCur^.cb);
    IF treCur^.cb <> 0 THEN
        BEGIN
        WHILE treCur^.arce.fVan DO
            BEGIN
            treCur := treNxt;
            treNxt := POINTER(ORD(treCur) + treCur^.cb);
            END;
        ich := treCur^.ichFst;
        cchTre := treNxt^.ichFst - ich;
        SetTreStyle;
        END;
    END;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstTld THEN BEGIN WRITELN('GenImageTld'); END;
ConvertRTyxy(crd^.arec.r, r, crd^.arec.tyxy, tyxyScrn);
IF NOT FClipR(r, crd^.orec) THEN GOTO 99;
IF fTstTld THEN FrameRect(r);
hLeftArec := r.left;
tyxy := crd^.tyxy;

IF crd^.icsSon = icsNil THEN
     BEGIN
     { This is part of the code needed to adjust for screen words which are
     significantly longer than the target output device.
     In high-res, the "cure" is worse than the disease.
     I ripped some code out of fastgen to deal with it.

     dhBeginLstWd := (r.right - hLeftArec)
                          - DhWidFromIchs(rgichWdFst^[atld.iwdLim - 1], atld.ichLim);
     }

      { Set the baseline and underline parameters. }
     { dyBaseline := atld.dyBase;
     ConvertTyxy(xOrYDummy, dyBaseline, tyxy, tyxyScrn);
     }
     dyBaseline := DvBaseLine(crd);
     dyBaseline := r.top + dyBaseline;
     dyBaseCur := dyBaseline;
     MoveTo(hLeftArec, dyBaseCur);
     fUl := FALSE;
     fReqBrk := achadTld.rgch^[atld.ichLim - 1] = chCr;
     ich := 0;

     treCur := grpTre;
     treNxt := POINTER(ORD(treCur) + treCur^.cb);
     IF treCur^.arce.fVan THEN
         NextTre
     ELSE BEGIN
         cchTre := treNxt^.ichFst;
         SetTreStyle;
         END;

        (************************************************************************
      { Print the characters, a word at a time. }
     FOR iwd := 0 TO atld.iwdLim - 1 DO
         BEGIN
         { Do the x-positioning only at the beginning of words. }
         x := rgoxWdFst^[iwd];
         ConvertTyxy(x, xOrYDummy, tyxy, tyxyScrn);
         { IF iwd = (atld.iwdLim - 1) THEN
              x := dhBeginLstWd
         ELSE BEGIN
              x := rgoxWdFst^[iwd];
              ConvertTyxy(x, xOrYDummy, tyxy, tyxyScrn);
              END;
         }
         IF fTstTld THEN WRITELN('GenImg - MoveTo(', x:4, ',', dyBaseCur:3, ')');
         MoveTo(x + hLeftArec, dyBaseCur);

         ich := rgichWdFst^[iwd];

         cchWd := rgichSepFst^[iwd] - ich;
         WHILE cchWd > 0 DO         { Process the word, using tre's as neccesary. }
               BEGIN
               cchDraw := CMin(cchTre, cchWd);
               IF (treCur^.ipgCur = ipgNil) OR (achadTld.rgch^[ich] <> chIpg) THEN
                    BEGIN
                    DrawText(POINTER(ORD(achadTld.rgch)), ich, cchDraw);
                    END
               ELSE BEGIN
                    CToSp(treCur^.ipgCur + 1, spIpg);
                    DrawString(spIpg);
                    cchDraw := 1;
                    END;
               ich := ich + cchDraw;
               cchWd := cchWd - cchDraw;                   { Chars left in word.   }
               IF cchTre = cchDraw
                    THEN NextTre                           { New style in word.    }
                    ELSE cchTre := cchTre - cchDraw;       { Chars left in tre.    }
               END;

         cchSep := rgichWdFst^[iwd + 1] - ich;
         { Do simple test for 99.99% of cases: }
         IF (cchTre > cchSep) AND (treCur^.tyfill = tyfillNil) THEN
               cchTre := cchTre - cchSep
         ELSE BEGIN
               WHILE cchSep > 0 DO        { Process the sep, using tre's as
               neccesary. }
                    BEGIN
                    cchDraw := CMin(cchTre, cchSep);
                    IF treCur^.tyfill <> tyfillNil THEN GenTabImg(ich, cchDraw);
                    ich := ich + cchDraw;
                    cchSep := cchSep - cchDraw;               { Chars left in sep. }
                    IF (cchTre = cchDraw) THEN
                      BEGIN
                      IF (iwd <> atld.iwdLim - 1) OR fReqBrk THEN
                           BEGIN
                           { If fUl, put pen in right place. }
                           x := rgoxWdFst^[iwd + 1];
                           FOR ichT := rgichWdFst^[iwd + 1] - 1 DOWNTO ich DO
                                 x := x - mpichdx^[ichT];
                           ConvertTyxy(x, xOrYDummy, tyxy, tyxyScrn);
                           MoveTo(x + hLeftArec, dyBaseCur);
                           END;
                      NextTre;
                      END
                    ELSE cchTre := cchTre - cchDraw;            { Chars left in tre.}
                    END;
               END;

         IF fTstTld THEN WRITELN('Next word.');
         END;
     **************************************************************************)
     {(****}
              FastGen (rgoxWdFst, @argptInch, tyxyScrn, @MoveTo, @NextTre, atld,
                       rgichWdFst, achadTld, rgichSepFst, @CToSp, @DrawText,
                       mpichdx, @DrawString, @GenTabImg, fReqBrk);
     {****)}

     {IF line ends in CR then do not suppress underlining of trailing sep's }
     IF fReqBrk AND fUl AND (ichUl < (atld.ichLim - 1)) THEN
          BEGIN
          x := rgoxWdFst^[atld.iwdLim] - mpichdx^[atld.ichLim - 1];
          ConvertTyxy(x, xOrYDummy, tyxy, tyxyScrn);
          MoveTo(x + hLeftArec, dyBaseCur);
          END;
     GetPen(ptPen);
     IF fUl THEN
         BEGIN
         (* check to see if the stuff to underline has any physical
           width, i.e. isn't, for instance, a carriage return *)
         IF ptPen.h <> xFstUl THEN
            BEGIN
            Move(-1, dyBaseline-dyBaseCur+1);
            LineTo(xFstUl, dyBaseline+1);
            Move(0,-1);  { back to dyBaseline };
            END;
         END;
     hRtArec := ptPen.h + dhMaxSlant;
     IF hRtArec > r.right THEN
          BEGIN
          ConvertTyxy(hRtArec, xOrYDummy, tyxyScrn, crd^.arec.tyxy);
          crd^.arec.r.right := hRtArec;
          rec := POINTER(ORD(dsp) + crd^.orec);
          IF rec^.tyxy <> crd^.arec.tyxy THEN
               BEGIN
               hRtArec := ptPen.h;
               ConvertTyxy(hRtArec, xOrYDummy, tyxyScrn, rec^.tyxy);
               END;
          rec := POINTER(ORD(dsp) + crd^.orec);
          rec^.r.right := hRtArec;
          END;
     END
ELSE BEGIN
     crdSon := argcrd[crd^.icrd + 1];
     crdSon^.iimgp := crd^.iimgp;
     crdSon^.orec := crd^.orec;
     {crdSon^.arec.r.topLeft := crdSon^.ptOrigTopLft
                                 + (crd^.ptOrigTopLft - crd^.arec.r.topLeft);
      crdSon^.arec.r.botRight := offset to maintain width and height
     }
     dptOffset := crd^.arec.r.topLeft;
     SubPt(crd^.ptOrigTopLft, dptOffset);
     AddPt(crdSon^.ptOrigTopLft, dptOffset);
     SubPt(crdSon^.arec.r.topLeft, dptOffset);
     OffsetRect(crdSon^.arec.r, dptOffSet.h, dptOffset.v);
     GenImg(crdSon);
     END;
99:
END;

{$S LWType}
FUNCTION FEqRces(rce1: TRce; rce2: TRce) : TF;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH rce1^ DO
  BEGIN
  IF fVan THEN
       FEqRces := rce2^.fVan
  ELSE FEqRces := (fBold = rce2^.fBold) AND (fItalic = rce2^.fItalic)
         AND (fUnderline = rce2^.fUnderline) AND (ifnt = rce2^.ifnt)
         AND (fKeep = rce2^.fKeep) AND (fOutline = rce2^.fOutline)
         AND (fShadow = rce2^.fShadow) AND (cbSuperscript = rce2^.cbSuperscript);
  END;
END;

{$S LWType}
FUNCTION FGenInsChTld{ich: TC; ch: TCh; arce: TArce) : TF};
LABEL 111;
VAR
rgch: TRgch;
dxCh: TC; dhCh: TC;
ibTre: TC;
tre: TTre;
iwd: TC;
pint: TPint;
rec: TRec;
chPrv: TCh;
fSeperator, fFirstInc, fNewWd: TF;
treNxt, treNew, trePrv: TTre;
cbAdd: TC;
cbNewTre: TC;
dlpT: TLp;
lfntid: TLfntid;
lfntidT: TLfntid;
finfo: FontInfo;
cError: TC;
seteFace: style;


{$S LWDialog}
PROCEDURE InsTre;
     BEGIN
     {$IFC sampcalls}  ALogCall;  {$ENDC}
     IF fTstTld THEN WRITELN('InsTre - ');
     IF (NOT FEqRces(@arce, @tre^.arce))
       AND ((atld.ibTreLim + cbAdd + cbOvhAtre) <= cbGrptre) THEN
          BEGIN
          {$ifc fDbgOk}
          IF fTstTld THEN
               BEGIN
               WRITELN('ibTre: ', ibTre, ', ibTreLim: ', atld.ibTreLim,
                 ', cbAdd: ', cbAdd, ', cbNewTre: ', cbNewTre);
               WRITE('      tre: '); PxTre(tre);
               WRITE('      treNew: '); PxTre(treNew);
               END;
          {$endc}
          MoveOvRgch(POINTER(ORD(treNew) + cbNewTre),
            POINTER(ORD(tre)), atld.ibTreLim + cbOvhAtre - ibTre);
          ibTre := ibTre + cbAdd;
          atld.ibTreLim := atld.ibTreLim + cbAdd;
          tre := POINTER(ORD(treNew) + cbNewTre);

          WITH treNew^ DO
             BEGIN
             ichFst := ich;
             dlpFst := tre^.dlpFst + (ich - tre^.ichFst);
             cb := cbNewTre;
             cbPrv := tre^.cbPrv;
             tre^.cbPrv := cbNewTre;
             tyfill := tyfillNil;
             ipgCur := ipgNil;
             END;
          MoveRgch(@treNew^.arce, @arce, arce.cb);
          IF treNew^.arce.ifnt > ifntLst THEN treNew^.arce.ifnt := ifntLst;

          tre^.ichFst := ich + 1;
          tre^.dlpFst := treNew^.dlpFst + 1;
          END;
     END;

{$S LWType}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstTld THEN WRITELN('FGenInsChTld(', ich, ', ', ch, ')');
IF (atld.ichLim < (ichLstTld + 1)) AND (ich <= atld.ichLim) THEN
     BEGIN
     seteface := [];
     IF arce.fBold      THEN seteface := seteface + [bold];
     IF arce.fItalic    THEN seteface := seteface + [italic];
     pint := POINTER(ORD(lldInt) + crdStd^.arec.ointDep);
     FillInLFntId (pint^.ics, argfam[arce.ifnt], seteFace, lfntid);
                            { replacement for devfromics, gdf 2/10/84}
     lfntidT := lfntid;
     IF {NOT} FmFontMetrics(lfntid, finfo, cError) THEN BEGIN END;
     IF lfntid.fam <> lfntidT.fam THEN
          BEGIN
          arce.ifnt := argifnt[lfntid.fam];
          END;
     arce.fItalic := italic IN lfntid.seteface;

     rgch := achadTld.rgch;
     MoveOvRgch(@rgch^[ich + 1], @rgch^[ich], atld.ichLim - ich);
     rgch^[ich] := ch;
     atld.ichLim := atld.ichLim + 1;

     dhCh := CharWidth(CHR(ch));
     dxCh := dhCh;
     ConvertTyxy(dxCh, xOrYDummy, tyxyScrn, crdStd^.tyxy);
     mpichdx^[ich] := dxCh;

     ibTre := 0;
     tre := grptre;
     cbNewTre := cbOvhAtre + arce.cb;
     WHILE TRUE DO
         BEGIN
         {$ifc fDbgOk}
         IF fTstTld THEN BEGIN WRITE('Loop - '); PxTre(tre); END;
         {$endc}
         IF tre^.cb <> 0 THEN
              BEGIN
              IF tre^.ichFst < ich THEN
                   BEGIN
                   treNxt := POINTER(ORD(tre) + tre^.cb);
                   IF (treNxt^.ichFst > ich) AND (treNxt^.cb <> 0) THEN
                        BEGIN
{ Add 2 new atre's
  one for the new rce, one for the second half of the current one}
                        treNew := POINTER(ORD(tre) + tre^.cb);
                        cbAdd := cbNewTre + tre^.cb;
                        InsTre;
                        END;
                   END
              ELSE IF tre^.ichFst = ich THEN
                   BEGIN
                   trePrv := POINTER(ORD(tre) - tre^.cbPrv);
                   IF (ibTre > 0) AND FEqRces(@arce, @trePrv^.arce) THEN
                        BEGIN
                        tre^.ichFst := tre^.ichFst + 1;
                        dlpT := trePrv^.dlpFst + (ich - trePrv^.ichFst);
                        IF dlpT = tre^.dlpFst THEN
                             tre^.dlpFst := tre^.dlpFst + 1;
                        END
                   ELSE BEGIN
                        treNew := tre;
                        cbAdd := cbNewTre;
                        InsTre;
                        END;
                   END
              ELSE IF tre^.ichFst > ich THEN
                   BEGIN
                   tre^.ichFst := tre^.ichFst + 1;
                   tre^.dlpFst := tre^.dlpFst + 1;
                   END;
              END
         ELSE IF tre^.ichFst > ich THEN
              BEGIN
              tre^.ichFst := tre^.ichFst + 1;
              tre^.dlpFst := tre^.dlpFst + 1;
              END;
         IF ibTre = atld.ibTreLim THEN GOTO 111;
         ibTre := ibTre + tre^.cb;
         tre := POINTER(ORD(grptre) + ibTre);
         END;
111:
     crdStd^.arec.dlpLim := crdStd^.arec.dlpLim + 1;
     pint := POINTER(ORD(lldInt) + crdStd^.arec.ointDep);
     pint^.lpLim := pint^.lpLim + 1;
     pint^.fValid := FALSE;

     fSeperator := (ORD(ch) = chCr) OR (ORD(ch) = chTab) OR (ORD(ch) = chSp);
     fFirstInc := TRUE; fNewWd := FALSE;
     FOR iwd := 0 TO atld.iwdLim DO
         BEGIN
         IF rgichWdFst^[iwd] > ich THEN
              BEGIN
              IF fFirstInc THEN fNewWd := (NOT fSeperator);
              fFirstInc := FALSE;
              rgichWdFst^[iwd] := rgichWdFst^[iwd] + 1;
              rgoxWdFst^[iwd] := rgoxWdFst^[iwd] + dxCh;
              rgichSepFst^[iwd] := rgichSepFst^[iwd] + 1;
              END
         ELSE IF rgichSepFst^[iwd] >= ich THEN
              BEGIN
              fFirstInc := FALSE;
              rgichSepFst^[iwd] := rgichSepFst^[iwd] + 1;
              END;
         END;

     dxCh := dhCh;
     ConvertTyxy(dxCh, xOrYDummy, tyxyScrn, crdStd^.arec.tyxy);
     crdStd^.arec.r.right := crdStd^.arec.r.right + dxCh;
     rec := POINTER(ORD(dsp) + crdStd^.orec);
     rec^.r.right := rec^.r.right + dxCh;
     IF fSeperator THEN
          FGenInsChTld := TRUE
     ELSE FGenInsChTld := fNewWd;
     END
ELSE FGenInsChTld := TRUE;
{$ifc fDbgOk}
IF fTstTld THEN PxTld;
{$endc}
END;

{$S LWCreate}
{------------------------------}
PROCEDURE InitTld { (hz: THZ) };
{------------------------------}
CONST cStrDecLen = 1;
VAR cbH, ch,i,c, fam:   TC;
    cch: TC;
    strDecimal: STRING[cStrDecLen];
    icrd: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstTld THEN WRITELN('InitTld');
hzTld := hz;
FOR icrd := 0 TO ccrdDft-1 DO
     BEGIN
     argcrd[icrd] := @argacrd[icrd];
     argcrd[icrd]^.icrd := icrd;
     argcrd[icrd]^.arec := arecStd;
     END;
crdStd := argcrd[0];
ipgCur := ipgNil;

ichLimTld := ichLstTld + 1;
AllocBk(hzTld, @achadTld.rgch, ichLimTld, tybkStd);
cbH := ichLimTld * SIZEOF(c);
AllocBk(hzTld, @mpichdx, cbH, tybkStd);
cbH := ((ichLimTld DIV 2) + 5) * SIZEOF(c); { + 5 for good luck }
AllocBk(hzTld, @rgichWdFst, cbH, tybkStd);
AllocBk(hzTld, @rgichSepFst, cbH, tybkStd);
AllocBk(hzTld, @rgoxWdFst, cbH, tybkStd);
cbGrptre := SIZEOF(grptre^) * 50;
cbOvhAtre := SIZEOF(grptre^)-SIZEOF(arceStd);
AllocBk(hzTld, @grptre, cbGrptre, tybkStd);

FOR ch := 0 TO 255 DO argtych[ch] := tychDft;
argtych[chCr] := tychCr; argtych[chSp] := tychSp; argtych[chTab] := tychTab;
argtych[chPeriod] := tychPeriod;
argtych[chComma] := tychComma;
argtych[chFormFeed] := tychFormFeed;
argtych[chIpg] := tychIpg;

xOrYDummy := 0;

FOR fam := 0 TO famLst DO argifnt[fam] := 0;
argifnt[tile12] := 0;
argifnt[p10tile] := 1;
argifnt[p12tile] := 2;
argifnt[tile18] := 3;
argifnt[tile24] := 4;
argifnt[cent12] := 5;
argifnt[cent18] := 6;
argifnt[cent24] := 7;
argifnt[boldface] := 8;
argifnt[p10cent] := 9;
argifnt[p12cent] := 10;
argifnt[elite] := 11;
argifnt[courier] := 12;
{argifnt[ocrb] := 13;}
argifnt[p15tile] := 14;

prPrfDefault (prprfDflt);       {2/10/84 gdf}

END;


END.




