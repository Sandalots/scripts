{$I APLW/COMPFLAGS }                                            {gdf 1/16/84}
{$R-}

UNIT UnitDsp;

(* Copyright 1983, 1984, Apple Computer Inc. *)

{ gdf  2/27/84 -- insert trace calls for segmentation  }
{ gdf  1/16/84 -- printing compile flag & include COMPFLAGS added }
{ crc  4/19/83 -- ScrollOrec: Fix for OrecOfPt yielding orecNil when scrolling
                  above header }
{ crc  4/15/83 -- ScrollOrec: Exit instead of calling Break(16) }
{ crc  4/14/83 -- TytermUpdateRec: EraseRect code pulled out of
                  "IF oboxPane <> oboxNil" statement so it is always executed
                  before GenImg }
{ crc  3/18/83 -- TytermUpdateRec: Don't save sons until lpFst > lpCur;
                  call GetPort before transferring off-screen image }
{ jrm  3/14/83 -- in TytermUpdateRec: set pbox^.fUpdate := FALSE  }
{ crc  3/11/83 -- cbBmpT changed from 2000 to 4000 to reduce flicker with large
                  fonts or triple spaced lines }
{ tjm  3/07/83 -- SetFRecDep: leaves fSelectable alone }
{ crc  3/01/83 -- Conditions on GenDefer for re-used recs; dlpLim computation
                  for coalescing with orecFixed }
{ crc  2/28/83 -- Abandon orecFixed at every keep; new orecFixed when keep ends }
{ tjm  2/25/83 -- call GenDefer when reusing orecOld if fImged = FALSE }
{ crc  2/08/83 -- SetFRecDep: sets fSelectable to NOT fRecDep argument }
{ crc  2/04/83 -- SetFRecDep takes fRecDep flag; tytermUpdateRec sets flag in
                  reuse old rec code }
{ crc  2/03/83 -- TytermUpdateRec: Cleanup sets fSelectable False for fRecDeps }
{ crc  2/02/83 -- TytermUpdateRec: Add rects when consolidating orecFixed }
{ crc  2/01/83 -- ValidateDsp: compute fLayoutPage }
{ crc  1/07/83 -- TytermUpdateRec: created SetFRecDep; modified logic for
                  tytermBeforeThisRec to include lp's of rec in intDep of
                  page. }
{ crc  1/06/83 -- TytermUpdateRec takes fLayoutPage parameter }
{ crc  1/04/83 -- TytermUpdateRec: copies strec.fformfeed from recNew when
                  consolidating recs above window }
{ jrm  6/29/82 -- USES changes: LisaGraf => QuickDraw; moved USES UnitFile }
{ crc  6/02/82 -- Conditional compilation }
{ crc 05/21/82 -- configSizePaperIn6ths replaced by function DptPaperSize,
                  tyxyTld by function TyxyTld }
{ crc 04/06/82 -- integration with new font manager }
{ bas 03/09/82 -- rec's have tyxy's, update TytermUpdateRec }
{ bas 03/05/82 -- make sure recNew is inited }
{ tjm 02/22/82 -- reorganize UpdateRec }
{ bas 02/12/82 -- new lisaprint uses }
{ bas 01/13/82 -- integration with lisaprint (USES + configSizePaperIn6ths);
  USES for new wm }
{ bas 12/10/81 -- integration with font manager }
{ edited by dsy 8/17/81 }

INTERFACE

USES
     {$IFC sampcalls}                                               {gdf 2/24/84}
        {$U aplw/tracecalls.obj} tracecalls,
     {$ENDC}
     {$U Obj:UnitStd.Obj  } UnitStd,
     {$U LibOS/Syscall.Obj }   Syscall,
     {$U Obj:UnitHz.Obj   } UnitHz,
     {$U Obj:UnitFile.Obj } UnitFile,
     {$U Obj:Storage.Obj  } Storage,
     {$U Obj:QuickDraw.Obj } QuickDraw,
     {$U Obj:FontMgr.Obj  } FontMgr,
     {$U Obj:Wm.Events.Obj  } Events,
     {$U Obj:Wm.Folders.Obj } Folders,
     {$U Obj:WmlStd       } WmlStd,
     {$U Obj:WmlCrs       } WmlCrs,
     {$U Obj:PmDecl       } PmDecl,
     {$IFC fPrintOld}                                               {gdf 1/16/84}
        {$U Obj:PrStd.Obj }     PrStd,
        {$U Obj:PrFile.Obj }    PrFile,
        {$U Obj:PrProcs.Obj }   PrProcs,
        {$U Obj:PrMgrUtil.Obj } PrMgrUtil,
        {$U Obj:PrMgr.Obj }     PrMgr,
     {$ELSEC}
        {$U Obj:PrStdInfo.Obj } PrStdInfo,
        {$U Obj:PrPublic.Obj }  PrPublic,
     {$ENDC}                                                        {gdf 1/16/84}
     {$U Obj:UnitFmt.Obj  } UnitFmt,
     {$U Obj:UnitCs.Obj   } UnitCs,
     {$U Obj:UnitFf.Obj   } UnitFf,
     {$U Obj:WM.Menus.Obj } Menus,
     {$U Obj:AlertMgr.Obj } AlertMgr,
     {$U ApLW/Queue.Obj    } Queue,
     {$U ApLW/UnitBox.Obj  } UnitBox,
     {$U ApLW/UnitRec.Obj  } UnitRec,
     {$U ApLW/UnitOver.Obj } UnitOver,
     {$U ApLW/UnitTld.Obj  } UnitTld,
     {$U ApLW/UnitPrt.Obj  } UnitPrt;

{$IFC NOT fDbgOk}
CONST
    fTstDsp = FALSE;
{$ENDC}

TYPE TTysel = (tyselPt, tyselWd, tyselPar);

TSel = RECORD
       oint: TC;
       ointAnchor: TC;
       tysel: TTysel;
       tyHilight: TTyHilight;
       fShowing: TF;
       END;

VAR
    ptMax: TPt;
    ptZero: TPt;
    {$IFC fDbgOk} fTstDsp: TF; {$ENDC}
    selCur: TSel;
{ This proc is necessary to subvert the dependency order }
    procFEosLppg: TProc;    {This will be init'd by InitPg - uugghh!!}

FUNCTION  TytermUpdateRec    (orecUpdate: TC; iimgp: TC; fLayoutPage: TF): TTyterm;
PROCEDURE ValidateDsp;
PROCEDURE ScrollOrec         (oboxPane: TC; dptRtDown: TPt; fNoScrollEos: TF);
PROCEDURE InitDsp            (hz: THz);
FUNCTION  FInSet             (elmt: TW; elmtSet: TW) : TF;
FUNCTION  IpgCurFromOrecCon  (orecCon: TC) : TC;
PROCEDURE NormalizeOrecCon(orecCon: TC);
PROCEDURE UpdateOrec(orec: TC; iimgp: TC; fHilight: TF);
PROCEDURE GenOrec(orec: TC; iimgp: TC);

IMPLEMENTATION

{$IFC fSymOK }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

CONST cpgMore = 10;
      cbBmpT = 4000;
      mskNot15 = -16;
      crecWidowLookAhead = 2;
      crecOrphanLookAhead = 2;
      itrLstWidowOrphan = 15;  {Number of elements in the widow/orphan truth table}

TYPE TTydone = (tydoneNil, tydoneBeforeThisRec, tydoneAfterThisRec);
     TTywo = (tywoNil, tywoFwdBoth, tywoFwdOne);   { Widow/Orphan control actions }

VAR hzDsp: THz;
    aportT: TAport;
    argbBmp: ARRAY [0..cbBmpT] OF TB;
    hrgnTGlobal: THrgn;
    xOrYDummy: TCd;
    ampitrtywo: ARRAY [0..itrLstWidowOrphan] OF TTywo;

FUNCTION FInSet; EXTERNAL;
{ This asm routine is necessary to subvert the dependency order }
{ The correct solution is to add FEosLp as stream proc }
FUNCTION  FCallEosLpPg(ics: TB; lp: TLp; proc: TProc) : TF; EXTERNAL;

{$S LWCom1}
FUNCTION TyxyOfObox(obox: TC): TTyxy;
VAR
pbox: TPbox;
recCon: TRec;
orecCon: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF obox = oboxNil THEN
     TyxyOfObox := tyxyScrn
ELSE BEGIN
     pbox := PboxFromObox(obox);
     orecCon := pbox^.refCon;
     recCon := POINTER(ORD(dsp)+orecCon);
     TyxyOfObox := recCon^.tyxy;
     END;
END;

{$S LWCommand}
{--------------------------------------------------}
FUNCTION IpgCurFromOrecCon{orecCon: TC) : TC};
{--------------------------------------------------}
VAR
recCon: TRec;
rec:    TRec;
lpOrLppg: TLpOrLppg;
pint:   TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IpgCurFromOrecCon := ipgNil;

recCon := POINTER(ORD(dsp)+orecCon);
IF NOT recCon^.foPrnt.fObox THEN
     BEGIN
     rec := POINTER(ORD(dsp)+recCon^.foPrnt.o);
     pint := POINTER(ORD(lldInt)+rec^.ointDep);
     IF rghcs^[pint^.ics]^^.tycs = tycsPg THEN
          BEGIN
          lpOrLppg.lp := pint^.lpFst;
          IpgCurFromOrecCon := lpOrLppg.lppg.ipg;
          END;
     END;
END;


{-----------------------------------------------------------------------------}
PROCEDURE GenOrec{orec: TC; iimgp: TC};
{-----------------------------------------------------------------------------}
VAR
rec:       TRec;
ptCur:     TPt;
pint:      TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
rec := POINTER(ORD(dsp)+orec);
ptCur := rec^.r.topLeft;
pint := POINTER(ORD(lldInt)+rec^.ointDep);
GenCrd(crdStd, pint^.ics, pint^.lpFst, rec^.tyxy);
 { move crdStd^.arec.r to ptCur }
WITH crdStd^.arec DO
     OffsetRect(r, ptCur.h  - r.left, ptCur.v - r.top);
crdStd^.orec := orec;
crdStd^.iimgp := iimgp;
END;

{$S LWType}
{-----------------------------------------------------------------------------}
PROCEDURE Update1Orec(orec: TC; iimgp: TC; fHilight: TF;
                      hrgnNotErased: THrgn; oboxPane: TC);
{-----------------------------------------------------------------------------}
VAR
portScreen: TPort;
rec:       TRec;
tyxy, tyxyImg:      TTyxy;
ptT:       TPt;
rT:        TR;
pint:      TPint;
pintSel:   TPint;
cdT:       TCd;
ointDep:   TC;
xOrYDummy: TC;
portT:     TPort;
vNxt:      TC;
pbox:      TPbox;
orecSib:   TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tyxyImg := TyxyOfObox(oboxPane);
rec := POINTER(ORD(dsp)+orec);
ointDep := rec^.ointDep;
tyxy := rec^.tyxy;
orecSib := rec^.orecSib;
vNxt := rec^.r.bottom;
GetPort(portScreen);
IF crdStd^.arec.dlpLim <> 0 THEN         { NOT End of class. }
     BEGIN
      { Let's generate a new image }
     IF (vNxt > 0) AND (oboxPane <> oboxNil) THEN
          BEGIN
          IF orecSib <> orecNil THEN
               BEGIN
               rec := POINTER(ORD(dsp)+orecSib);
               IF (rec^.r.topLeft.v < vNxt) THEN
                    BEGIN
                    Setpt(ptT, rec^.r.left, vNxt);
                    MoveRecs(orecSib, ptT, rec^.tyxy);
                    END;
               END;
          rec := POINTER(ORD(dsp)+orec);
          ConvertRTyxy(rec^.r, rT, tyxy, tyxyImg);
          rT.left := rT.left - dhCaret;
          rT.right := rT.right + dhMaxSlant;
          cdT := vNxt;
          ConvertTyxy(xOrYDummy, cdT, tyxy, tyxyImg);
          pint := POINTER(ORD(lldInt)+ointDep);
          IF (hrgnNotErased^^.rgnBBox.top <> hrgnNotErased^^.rgnBBox.bottom)
            AND (hrgnNotErased^^.rgnBBox.botRight.v >= cdT)
            AND (rghcs^[pint^.ics]^^.tycs <> tycsPg) THEN
               BEGIN
               pbox := PboxFromObox(oboxPane);
               WITH aportT.portBits DO
                    BEGIN
                    SetRect(bounds, 0, 0, rT.right - rT.left, rT.bottom -
                    rT.top);
                    rowBytes := 2 * ((bounds.right + 15) DIV 16);
                    IF (ORD4(rowBytes) * bounds.bottom) <= cbBmpT THEN
                         BEGIN
                         SetPort(@aportT);
                         MovePortTo(0, 0);
                         PortSize(bounds.right - bounds.left,
                                  bounds.bottom - bounds.top);
                         SetOrigin(rT.left, rT.top);
                         RectRgn(aportT.visRgn, aportT.portRect);
                         EraseRect(aportT.portRect);
                         RectRgn(hrgnTGlobal, rT);
                         DiffRgn(hrgnNotErased, hrgnTGlobal, hrgnNotErased);
                         END;
                    END;
               END;
          END;
     GetPort(portT);
     IF portT <> @aportT THEN
          BEGIN
          EraseRgn(hrgnNotErased);
          hrgnNotErased^^.rgnBBox.topLeft := hrgnNotErased^^.rgnBBox.botRight;
          END;
     GenImg(crdStd);
     IF (oboxPane <> oboxNil) THEN
          BEGIN
          pintSel := POINTER(ORD(lldInt)+selCur.oint);
          pint := POINTER(ORD(lldInt)+ointDep);
          IF fHilight AND (pint^.ics = pintSel^.ics) AND selCur.fShowing THEN
               HilightCrd(crdStd, selCur.oint, selCur.tyHilight, TRUE);
          GetPort(portT);
          IF portT = @aportT THEN
               BEGIN
               SetPort(portScreen);
               CopyBits(aportT.portBits, portScreen^.portBits, rT, rT, 0,
                 NIL);
               END;
          END;
     END;

IF hrgnNotErased^^.rgnBBox.top <> hrgnNotErased^^.rgnBBox.bottom THEN
     BEGIN
     EraseRgn(hrgnNotErased);
     WITH hrgnNotErased^^.rgnBBox DO topLeft := botRight;
     END;
END;

{-----------------------------------------------------------------------------}
PROCEDURE UpdateOrec{orec: TC; iimgp: TC; fHilight: TF};
{-----------------------------------------------------------------------------}
VAR
hrgnNotErased: THrgn;
oboxPane:  TC;
rec:       TRec;
rT:        TR;
pint:      TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
rec := POINTER(ORD(dsp)+orec);
pint := POINTER(ORD(lldInt) + rec^.ointDep);
IF NOT (rec^.strec.fValid AND pint^.fValid) THEN
     BEGIN
     oboxPane := OboxVisOrec(orec);
     rec := POINTER(ORD(dsp)+orec);
     ConvertRTyxy(rec^.r, rT, rec^.tyxy, TyxyOfObox(oboxPane));
     rT.left := rT.left - dhCaret;
     rT.right := rT.right + dhMaxSlant;
     hrgnNotErased := NewRgn;
     RectRgn(hrgnNotErased, rT);
     IF crdStd^.arec.dlpLim <> 0 THEN         { NOT End of class. }
          BEGIN
          rec := POINTER(ORD(dsp)+orec);
          rec^.r := crdStd^.arec.r;
          rec^.dlpLim := crdStd^.arec.dlpLim;
          END;
     Update1Orec(orec, iimgp, fHilight, hrgnNotErased, oboxPane);
     DisposeRgn(hrgnNotErased);
     END;
END;


(* PROCEDURE EraseAndFreeOrecCon(VAR orecCon: TC);
VAR
rec: TRec;
recCon: TRec;
orec: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
recCon := POINTER(ORD(dsp) + orecCon);
orec := recCon^.orecSon;
recCon^.orecSon := orecNil;
WHILE orec <> orecNil DO
     BEGIN
     rec := POINTER(ORD(dsp) + orec);
     IF rec^.strec.fImged THEN EraseOrec(orec);
     orec := OrecSibFree(orec);
     END;
orecCon := OrecSibFree(orecCon);
END;
*)

{$S LWMisc}
{-------------------------------------------------------------------------------}
PROCEDURE ControlWidowOrphan(VAR orecLayoutDefer: TC; orecLst: TC;
                             crecWdDefer: TC; crecOrDefer: TC);
{-------------------------------------------------------------------------------}
{ An itr is an index into a truth table; in this case the truth table formed
  by the fParSt flags of the defered orec's }
VAR itr: TC;
    rec, recLayoutDefer:      TRec;
    i: TC;
    orec, orecLimLayout: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
itr := 0; orec := orecLayoutDefer;
FOR i := 1 TO crecWdDefer DO
     BEGIN
     itr := itr * 2;
     rec := POINTER(ORD(dsp)+orec);
     IF rec^.strec.fParSt THEN
          itr := itr + 1;
     orec := rec^.orecSib;
     END;
orecLimLayout := orec;
FOR i := 1 TO CMin(crecOrDefer, crecOrphanLookAhead) DO
     BEGIN
     itr := itr * 2;
     rec := POINTER(ORD(dsp)+orec);
     IF rec^.strec.fParSt THEN
          itr := itr + 1;
     orec := rec^.orecSib;
     END;
IF (orecLst <> orecNil) AND (crecOrDefer < crecOrphanLookAhead) THEN
     BEGIN
     itr := itr * 2;
     rec := POINTER(ORD(dsp)+orecLst);
     IF rec^.strec.fParSt THEN
          itr := itr + 1;
     crecOrDefer := crecOrDefer + 1;
     END;
FOR i := (crecOrDefer + 1) TO crecOrphanLookAhead DO
     itr := (itr * 2) + 1;
CASE ampitrtywo[itr] OF
  tywoNil:     {leave both on this page}
       orecLayoutDefer := orecLimLayout;
  tywoFwdBoth: {carry forward both to next page}
       BEGIN END;
  tywoFwdOne:  {carry forward one to next page}
       BEGIN
       IF crecWdDefer = 2 THEN
            BEGIN
            recLayoutDefer := POINTER(ORD(dsp)+orecLayoutDefer);
            orecLayoutDefer := recLayoutDefer^.orecSib;
            END;
       END;
  END;
END;

{-------------------------------------------------------------------------------}
FUNCTION CrecSuffix(orec: TC) : TC;
{-------------------------------------------------------------------------------}
VAR crec: TC;
    rec: TRec;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
crec := 0;
WHILE orec <> orecNil DO
     BEGIN
     crec := crec + 1;
     rec := POINTER(ORD(dsp)+orec);
     orec := rec^.orecSib;
     END;
CrecSuffix := crec;
END;

{$S LWCommand}
{-------------------------------------------------------------------------------}
FUNCTION TytermUpdateRec {(orecUpdate: TC; iimgp: TC; fLayoutPage: TF): TTyterm };
{-------------------------------------------------------------------------------}
 { note: orecUpdate is always an orecCon }
LABEL   20, 10, 40, 100;
VAR tyxyUpdate, tyxyObox: TTyxy; ics, icsSel: TB; hcs: THcs;
    setfixed:  TSetfixed;  pbox: TPBox; oboxPane: TC;
    recOld, recNew, rec, recUpdate: TRec;
    orecOld, orecT, orecOverlapOldDefer, orecOldSave: TC;
    orecPrvLayoutDefer, orecLayoutDefer, orecKeepDefer, orecNew: TC;
    orecPrvT, orecFixed: TC;
    lpCur, lpLim, lpFst:  TLp;
    ptCur, ptNxt, dptWHPane, ptT: TPt;
    pint, pintSon, pintOld: TPint; ointT, ointParent: TC;
    fRtMostRec, fFind: TF;
    dxWidMac:       TX;
    foPrnt: TFo;
    tyterm: TTyterm; tydone: TTydone;
    rT: TR; cdT: TCd;
    portScreen, portT: TPort;
    hrgnTClip: THrgn; hrgnClipSave: THrgn;
    hrgnNotErased: THrgn;
    crecLayoutDefer: TC;
    crecLookAhead: TC;
    crecWdDefer: TC;
    orecLimLayout: TC;
    fCspg: TF;

{$S LWCom1}
PROCEDURE GenDefer(VAR orecDefer: TC; orecLimDefer: TC; orecLim2: TC);
    VAR orecT1: TC;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
     { if orecLimDefer is before orecDefer then do nothing }
    IF fTstDsp THEN
         WRITELN('GenDefer(', orecDefer, ', ', orecLimDefer, ')');
    orecT1 := orecDefer;
    WHILE (orecT1 <> orecNil) AND (orecT1 <> orecLimDefer) DO
         BEGIN
         rec := POINTER(ORD(dsp)+orecT1);
         orecT1 := rec^.orecSib;
         END;
    IF orecT1 = orecLimDefer THEN
         BEGIN
         WHILE (orecDefer <> orecLimDefer) AND (orecDefer <> orecLim2) DO
              BEGIN
              rec := POINTER(ORD(dsp)+orecDefer);
              {$ifc fDbgOk}
              IF fTstDsp THEN
                    BEGIN WRITE('orecDefer: '); PxOrec(orecDefer); END;
              {$endc}
              orecT1 := rec^.orecSib;
              IF (NOT rec^.strec.fImged) AND (NOT rec^.strec.fRecDep) THEN
                   BEGIN
                   rec^.strec.fImged := TRUE;
                   GenOrec(orecDefer, iimgp);
                   Update1Orec(orecDefer, iimgp, TRUE, hrgnNotErased, oboxPane);
                   (* ptT := rec^.r.topLeft;
                   ConvertTyxy(ptT.h, ptT.v, rec^.tyxy, tyxyUpdate);
                   pint := POINTER(ORD(lldInt)+rec^.ointDep);
                   GenCrd(crdStd, ics, pint^.lpFst, tyxyUpdate);
                    { move crdStd^.arec.r to ptT }
                   WITH crdStd^.arec DO
                        OffsetRect(r, ptT.h  - r.left, ptT.v - r.top);
                   crdStd^.orec := orecDefer;
                   crdStd^.iimgp := iimgp;
                   GenImg(crdStd);
                   IF (ics = icsSel) AND selCur.fShowing THEN
                        HilightCrd(crdStd, selCur.oint, selCur.tyHilight, TRUE);
                   *)
                   END;
              orecDefer := orecT1;
              END;
         END;
    orecDefer := orecNil;
    END; {GenDefer}

{$S LWType}
PROCEDURE SetFRecDep(orec: TC; fRecDep: TF);
    VAR rec: TRec;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    rec := POINTER(ORD(dsp)+orec);
    IF fRecDep AND rec^.strec.fImged THEN
         BEGIN
         rec^.strec.fImged := FALSE;
         EraseOrec(orec);
         END;
    rec^.strec.fRecDep := fRecDep;
    END; {SetFRecDep}

{$S LWCom1}
PROCEDURE Cleanup;      {Needed to make it compile}
    VAR orecLst, vBot: TC;
        orecSib: TC;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    IF fTstDsp THEN WRITELN('Cleanup');
    WHILE orecOld <> orecNil DO
         BEGIN
         rec := POINTER(ORD(dsp) + orecOld);
         IF rec^.strec.fImged THEN EraseOrec(orecOld);
         orecOld := OrecSibFree(orecOld);
         END;
    GenDefer(orecOverlapOldDefer, orecLayoutDefer, orecNil);
    rec := POINTER(ORD(dsp) + orecUpdate);
    IF (orecLayoutDefer = rec^.orecSon) THEN
         BEGIN
         GenDefer(orecLayoutDefer, orecNil, orecLimLayout);
         orecLayoutDefer := orecLimLayout;
         IF (orecLayoutDefer <> orecNil) AND (tyterm = tytermEos) THEN
              tyterm := tytermLayoutDone;
         END
    ELSE IF (tyterm = tytermEos) THEN
         BEGIN
         IF crecWdDefer > 0 THEN
              BEGIN
              ControlWidowOrphan(orecLayoutDefer, orecNil,
                                 crecWdDefer, crecLayoutDefer - crecWdDefer);
              GenDefer(orecPrvLayoutDefer, orecNil, orecLayoutDefer);
              tyterm := tytermLayoutDone;
              END
         ELSE GenDefer(orecLayoutDefer, orecNil, orecNil);
         END;
    IF hrgnNotErased^^.rgnBBox.top <> hrgnNotErased^^.rgnBBox.bottom THEN
         EraseRgn(hrgnNotErased);
    rec := POINTER(ORD(dsp) + orecUpdate);
    IF (orecNew = orecNil) THEN
         BEGIN
         lpLim := lpFst;
         vBot := rec^.r.top;
         orecLst := orecUpdate;
         END
    ELSE BEGIN
         orecLst := orecNew;
         rec := POINTER(ORD(dsp)+orecLst);
         pint := POINTER(ORD(lldInt)+rec^.ointDep);
         lpLim := pint^.lpLim;
         vBot := rec^.r.bottom;
         ConvertTyxy(xOrYDummy, vBot, rec^.tyxy, tyxyUpdate);
         END;
    IF fTstDsp THEN
         WRITELN('orecLst: ', orecLst, ', lpLim: ', lpLim, ', vBot: ', vBot);
    rec := POINTER(ORD(dsp)+orecLst);
    IF orecLst = orecUpdate THEN
         rec^.orecSon := orecNil
    ELSE rec^.orecSib := orecNil;
    WHILE orecLayoutDefer <> orecNil DO
         BEGIN
         SetFRecDep(orecLayoutDefer, TRUE);
         rec := POINTER(ORD(dsp)+orecLayoutDefer);
         orecLayoutDefer := rec^.orecSib;
         END;
    rec := POINTER(ORD(dsp)+orecUpdate);
    rec^.tyterm := tyterm;
    IF NOT FInSet(fixedR, setfixed) THEN
         SetPt(rec^.r.botRight, rec^.r.left + dxWidMac, vBot);
    ointT := OintMark(rec^.ointDep, ics, lpFst, lpLim, TRUE, ointParent);
    rec^.strec.fValid := TRUE;
    END;

FUNCTION TydoneLayout(orec: TC) : TTydone;
    LABEL 8;    { GOTO 8 = EXIT(TydoneLayout) }
    VAR rec:      TRec;
        recLayoutDefer:      TRec;
        recUpdate:      TRec;
        fRtMostRec:     TF;
        tydone:     TTydone;
        pint: TPint;
        ptT1: TPt;
        lpOrLppg: TLpOrLppg;
        orecT, orecSonUpdate: TC;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    IF fTstDsp THEN WRITELN('TydoneLayout - orec: ', orec, ', orecUpdate: ',
         orecUpdate);
    recUpdate := POINTER(ORD(dsp)+orecUpdate);

    rec := POINTER(ORD(dsp)+orec);
    fRtMostRec := TRUE;             {for columnar paragraphs, etc.}
    tydone := tydoneNil;
    ptNxt.v := rec^.r.bottom;
    ptNxt.h := recUpdate^.r.left;
    ConvertTyxy(xOrYDummy, ptNxt.v, rec^.tyxy, tyxyUpdate);
    rec := POINTER(ORD(dsp)+orec);
    pint := POINTER(ORD(lldInt)+rec^.ointDep);
    IF rghcs^[pint^.ics]^^.tycs = tycsPg THEN
         BEGIN
         lpOrLppg.lp := pint^.lpFst;
         IF lpOrLppg.lppg.ptpg = 0 THEN
              { This is the only place I go to the stream for a valid rec }
              { I wish it wasn't necessary but... }
              IF FCallEosLppg(pint^.ics, lpOrLppg.lp, procFEosLppg) THEN
                   BEGIN
                   tydone := tydoneBeforeThisRec;
                   GOTO 8;
                   END;
         END;
    IF fLayoutPage THEN
         BEGIN
         IF rec^.strec.fFormFeed THEN
              BEGIN
              IF crecWdDefer > 0 THEN
                   BEGIN
                   ControlWidowOrphan(orecLayoutDefer, orec,
                                      crecWdDefer, crecLayoutDefer - crecWdDefer);
                   END
              ELSE BEGIN
                   orecLayoutDefer := orecNil;
                   crecLayoutDefer := 0;
                   END;
              tydone := tydoneAfterThisRec;
              GOTO 8;
              END
         ELSE BEGIN
              IF rec^.strec.fKeep THEN
                   BEGIN
                   IF (crecWdDefer = 0)  {ignore if we're looking for orphans}
                     AND (orecKeepDefer = orecNil) THEN
                        orecKeepDefer := orec;
                   END
              ELSE BEGIN
                   IF orecKeepDefer <> orecNil THEN
                        BEGIN
                        orecLayoutDefer := orec;
                        crecLayoutDefer := 0;
                        orecKeepDefer := orecNil;
                        END;
                   END;
              END;
         END;
    recUpdate := POINTER(ORD(dsp)+orecUpdate);
    orecSonUpdate := recUpdate^.orecSon;
    IF FInSet(fixedR, recUpdate^.strec.setfixed) THEN
       IF (lpCur > lpFst)       {Don't terminate on empty layout}
         AND (ptNxt.v >= recUpdate^.r.bottom) AND (fRtMostRec) THEN
          BEGIN
          {is ptNxt correct??}
          IF (orecKeepDefer <> orecNil) THEN
               BEGIN
               IF (orecKeepDefer <> orecSonUpdate) THEN
                    BEGIN
                    crecWdDefer := crecLayoutDefer;
                    crecLookAhead := crecLayoutDefer + crecOrphanLookAhead;
                    orecLimLayout := orecKeepDefer;
                    IF orecKeepDefer <> orec THEN
                         crecLayoutDefer := crecLayoutDefer + CrecSuffix(orecKeepDefer);
                    orecKeepDefer := orecNil;
                    END
               ELSE BEGIN
                    tydone := tydoneBeforeThisRec;
                    orecLimLayout := orec;
                    GOTO 8;
                    END;
               END;
          IF fTstDsp THEN
               BEGIN
               WRITELN('orecKeepDefer: ', orecKeepDefer:4,
                       'orecLimLayout: ', orecLimLayout:4,
                       'crecLayoutDefer: ', crecLayoutDefer:4,
                       'crecWdDefer: ', crecWdDefer:4);
               END;
          IF crecLayoutDefer = 0 THEN
               BEGIN
               tydone := tydoneBeforeThisRec;
               GOTO 8;
               END
          ELSE BEGIN
               IF crecWdDefer = 0 THEN
                    BEGIN
                    crecWdDefer := crecLayoutDefer;
                    crecLookAhead := crecLayoutDefer + crecOrphanLookAhead;
                    orecLimLayout := orec;
                    END
               ELSE BEGIN
                    IF crecLayoutDefer >= (crecLookAhead - 1) THEN
                         BEGIN
                         ControlWidowOrphan(orecLayoutDefer, orec, crecWdDefer,
                                            crecLayoutDefer - crecWdDefer);
                         tydone := tydoneBeforeThisRec;
                         GOTO 8;
                         END;
                    END;
               END;
          END;
    IF fLayoutPage THEN
         BEGIN
         IF crecLayoutDefer = crecLookAhead THEN
              BEGIN
              IF orecKeepDefer = orecNil THEN
                   BEGIN
                   recLayoutDefer := POINTER(ORD(dsp)+orecLayoutDefer);
                   orecLayoutDefer := recLayoutDefer^.orecSib;
                   END;
              END
         ELSE BEGIN
              IF orecLayoutDefer = orecNil THEN
                   BEGIN
                   IF orecKeepDefer = orecNil THEN
                        BEGIN
                        orecLayoutDefer := orec;
                        crecLayoutDefer := 1;
                        END;
                   END
              ELSE BEGIN
                   IF orecKeepDefer = orecNil THEN
                        crecLayoutDefer := crecLayoutDefer + 1;
                   END;
              END;
         END;

8:  { EXIT }
    IF fTstDsp THEN
         BEGIN
         WRITELN('TydoneLayout - ptNxt: (', ptNxt.h:4, ',', ptNxt.v:4,
         ');  tydone: ', ORD(tydone));
         END;
    TydoneLayout := tydone;
    END;

{$S LWCommand}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
pint := POINTER(ORD(lldInt)+selCur.oint);
icsSel := pint^.ics;
IF fTstDsp THEN WRITELN('TytermUpdateRec(', orecUpdate, ')');
foPrnt.fObox := FALSE; foPrnt.o := orecUpdate;
recUpdate := POINTER(ORD(dsp)+orecUpdate);
tyxyUpdate := recUpdate^.tyxy;
 { we'll always keep crdStd^.arec in tyxyUpdate }
pint := POINTER(ORD(lldInt)+recUpdate^.ointDep);
ics := pint^.ics;
ointParent := pint^.ointParent;
IF recUpdate^.strec.fValid AND pint^.fValid THEN
     BEGIN
     tyterm := recUpdate^.tyterm;
     GOTO 20;         {EXIT}
     END;

{$ifc fDbgOk}
IF fTstDsp THEN BEGIN WRITELN('orecUpdate - '); PxOrec(orecUpdate); END;
{$endc}

fCspg := rghcs^[ics]^^.tycs = tycsPg;
ipgCur := IpgCurFromOrecCon(orecUpdate);
recUpdate^.strec.fValid := TRUE;
hcs := rghcs^[ics];
ptCur := recUpdate^.r.topLeft;
setfixed := recUpdate^.strec.setfixed;
lpFst := pint^.lpFst;
IF FInSet(fixedLpLim, setfixed) THEN lpLim := pint^.lpLim;
orecNew := orecNil;
orecFixed := orecNil;
orecOverlapOldDefer := orecNil;
orecLayoutDefer := orecNil;
orecLimLayout := orecNil;
orecKeepDefer := orecNil;
orecPrvT := orecUpdate;
orecOld := recUpdate^.orecSon;
crecLookAhead := crecWidowLookAhead;
crecWdDefer := 0;
crecLayoutDefer := 0;
 { note: (orecUpdate is a con-type) => (orecUpdate's tyxy) = (son's tyxy) }

IF NOT FInSet(fixedLpFst, setfixed) THEN
     BEGIN
     fFind := (orecOld = orecNil);
     IF NOT fFind THEN
          BEGIN
          rec := POINTER(ORD(dsp)+orecOld);
          fFind := (rec^.ointDep = ointNil);
          IF NOT fFind THEN
               BEGIN
               pint := POINTER(ORD(lldInt)+rec^.ointDep);
               fFind := (NOT pint^.fValid) OR (lpFst <> pint^.lpFst);
               END;
          END;
     IF fFind THEN FindLpFixed(ics, lpFst, lpFst);
     END;
lpCur := lpFst;

oboxPane := OboxVisOrec(orecUpdate);
IF oboxPane <> oboxNil THEN
   BEGIN
   pbox := PboxFromObox(oboxPane);
   IF pbox^.refCon = orecUpdate THEN pbox^.fUpdate := FALSE;
   END;
GetPort(portScreen);
fRtMostRec := TRUE;
hrgnClipSave := POINTER(ORD(hNil));
tyxyObox := TyxyOfObox(oboxPane);
IF oboxPane = oboxNil THEN
     BEGIN
     dptWHPane := ptMax;
     IF iimgp = iimgpScrn THEN
          BEGIN
          hrgnTClip := NewRgn;             { retain old clip rgn in case of
          recursion }
          SetRectRgn(hrgnTClip, 0,0,0,0);  { no garbaging the screen }
          hrgnClipSave := thePort^.clipRgn;
          thePort^.clipRgn := hrgnTClip;
          END;
     END
ELSE BEGIN
     pbox := PboxFromObox(oboxPane);
     WITH pbox^.r DO SetPt(dptWHPane, right - left, bottom - top);
     ConvertTyxy(dptWHPane.h, dptWHPane.v, tyxyObox, tyxyUpdate);
     END;
{ note dptWHPane is botRight of pane in box-relative tyxyUpdate coordinates }
dxWidMac := 0;

hrgnNotErased := NewRgn;
SetRectRgn(hrgnNotErased, 0,0,0,0); { anything s.t. topLeft = botRight }

{BEWARE DANGLING POINTERS!!! - rec's, int's, etc.}
WHILE TRUE DO
     BEGIN
     IF fTstDsp THEN WRITELN('ptCur: (', ptCur.h, ',', ptCur.v, ')');

     orecPrvLayoutDefer := orecLayoutDefer;
     IF (orecLayoutDefer = orecNil) THEN
          BEGIN
          IF (ptCur.v >= dptWHPane.v) AND (fRtMostRec) THEN
               BEGIN tyterm := tytermOutOfWw; GOTO 10; END;
          END
     ELSE BEGIN
          rec := POINTER(ORD(dsp)+orecLayoutDefer);
          IF (rec^.r.top >= dptWHPane.v) AND (fRtMostRec) THEN
               BEGIN tyterm := tytermOutOfWw; GOTO 10; END;
          END;
     IF FInSet(fixedLpLim, setfixed) THEN IF lpCur >= lpLim THEN
          BEGIN tyterm := tytermLayoutDone; GOTO 10; END;

      { see if we can re-use orecOld }
      { Free any obviously useless old recs and erase the screen space }
     orecOldSave := orecNil;
     WHILE (orecOld <> orecNil) DO
          BEGIN
          recOld := POINTER(ORD(dsp)+orecOld);
          pintOld := POINTER(ORD(lldInt)+recOld^.ointDep);
          IF recOld^.strec.fValid AND pintOld^.fValid
            AND (ics = pintOld^.ics) THEN
               BEGIN
               IF (pintOld^.lpFst = lpCur) THEN
                    BEGIN
                    IF (recOld^.r.topLeft.v <> ptCur.v) THEN
                         BEGIN
                         IF hrgnNotErased^^.rgnBBox.top
                           <> hrgnNotErased^^.rgnBBox.bottom THEN
                              BEGIN
                              EraseRgn(hrgnNotErased);
                              hrgnNotErased^^.rgnBBox.topLeft :=
                                hrgnNotErased^^.rgnBBox.botRight;
                              END;
                         Setpt(ptT, recOld^.r.left, ptCur.v);
                         MoveRecs(orecOld, ptT, tyxyUpdate);
                         END;
                    IF orecOverlapOldDefer <> orecNil THEN
                         GenDefer(orecOverlapOldDefer, orecLayoutDefer, orecNil);
                    recOld := POINTER(ORD(dsp)+orecOld);
                     { MoveRecs may have invalidated so test again to make sure }
                    IF recOld^.strec.fValid THEN
                         BEGIN
                          {Reuse old rec}
                         tydone := TydoneLayout(orecOld);
                         SetFRecDep(orecOld, tydone = tydoneBeforeThisRec);
                         orecNew := orecOld;
                         recOld := POINTER(ORD(dsp)+orecOld);
                         orecOld := recOld^.orecSib;
                         recOld^.orecSib := orecNil;
                         orecT := orecNew; {make a copy because GenDefer sets to nil }
                         IF    (NOT recOld^.strec.fImged)
                           AND (NOT recOld^.strec.fRecDep)
                           AND (ptNxt.v > 0)
                           AND (tydone <> tydoneBeforeThisRec)
                           AND (orecLayoutDefer = orecNil)
                         THEN GenDefer(orecT, orecNil, orecNil);
                         GOTO 100;
                         END;
                    END
               ELSE IF (pintOld^.lpFst > lpCur) THEN
                    GOTO 40;
               END;
          IF hrgnNotErased^^.rgnBBox.top <> hrgnNotErased^^.rgnBBox.bottom THEN
               BEGIN
               EraseRgn(hrgnNotErased);
               hrgnNotErased^^.rgnBBox.topLeft := hrgnNotErased^^.rgnBBox.botRight;
               END;
          IF (recOld^.orecSon <> orecNil)
            AND (ics = pintOld^.ics) AND (pintOld^.lpFst >= lpCur) THEN
               BEGIN
               IF pintOld^.lpFst = lpCur THEN
                   BEGIN
                   orecOldSave := orecOld;
                   orecOld := recOld^.orecSib;
                   recOld^.orecSib := orecNil;
                   END;
               GOTO 40;
               END
          ELSE BEGIN
               IF recOld^.strec.fImged THEN
                   BEGIN
                   ConvertRTyxy(recOld^.r, rT, tyxyUpdate, tyxyObox);
                   rT.left := rT.left - dhCaret;
                   RectRgn(hrgnNotErased, rT);
                   END;
               orecOld := OrecSibFree(orecOld);
               END;
          END;

40:
      { Nope, couldn't re-use.  Generate new rec. }
     IF fTstDsp THEN WRITELN('Generate New Rec');
     GenCrd(crdStd, ics, lpCur, tyxyUpdate);
     IF crdStd^.arec.dlpLim = 0 THEN         { End of class. }
          BEGIN
          tyterm := tytermEos;
          IF (orecOldSave <> orecNil) THEN
               BEGIN
               EraseOrec(orecOldSave);
               orecOldSave := OrecSibFree(orecOldSave);
               END;
          GOTO 10;
          END;
     OffsetRect(crdStd^.arec.r, ptCur.h, ptCur.v);
     crdStd^.iimgp := iimgp;
     pint := POINTER(ORD(lldInt)+crdStd^.arec.ointDep);
     ointT := OintMark(ointNil, ics, pint^.lpFst, pint^.lpLim, TRUE, ointNil);
     crdStd^.orec := OrecAlloc;
     recNew := POINTER(ORD(dsp)+crdStd^.orec);
     recNew^ := crdStd^.arec;
     recNew^.ointDep := ointT;
     recNew^.foPrnt := foPrnt;

     tydone := TydoneLayout(crdStd^.orec);
     orecNew := crdStd^.orec;
     IF tydone = tydoneBeforeThisRec THEN SetFRecDep(orecNew, TRUE);
     recNew := POINTER(ORD(dsp)+orecNew);

      { Let's generate a new image }
     IF (ptNxt.v > 0) AND (tydone <> tydoneBeforeThisRec) THEN
          BEGIN
          IF orecOld <> orecNil THEN
               BEGIN
               rec := POINTER(ORD(dsp)+orecOld);
               IF (rec^.r.topLeft.v < ptNxt.v) THEN
                    BEGIN
                    IF orecOverlapOldDefer = orecNil THEN
                         orecOverlapOldDefer := orecNew;
                    GOTO 100;
                    END;
               END;
          IF orecLayoutDefer = orecNil THEN
               BEGIN
               recNew^.strec.fImged := TRUE;
               IF oboxPane <> oboxNil THEN
                    BEGIN
                    ConvertRTyxy(recNew^.r, rT, recNew^.tyxy, tyxyObox);
                    rT.left := rT.left - dhCaret;
                    rT.right := rT.right + dhMaxSlant;
                    cdT := ptNxt.v;
                    ConvertTyxy(xOrYDummy, cdT, tyxyUpdate, tyxyObox);
                    IF (hrgnNotErased^^.rgnBBox.top <>
                    hrgnNotErased^^.rgnBBox.bottom)
                      AND (hrgnNotErased^^.rgnBBox.botRight.v >= cdT)
                      AND (NOT fCspg) THEN
                         BEGIN
                         pbox := PboxFromObox(oboxPane);
                         WITH aportT.portBits DO
                              BEGIN
                              SetRect(bounds, 0, 0, rT.right - rT.left, rT.bottom -
                                      rT.top);
                              rowBytes := 2 * ((bounds.right + 15) DIV 16);
                              IF (ORD4(rowBytes) * bounds.bottom) <= cbBmpT THEN
                                   BEGIN
                                   SetPort(@aportT);
                                   MovePortTo(0, 0);
                                   PortSize(bounds.right - bounds.left,
                                   bounds.bottom -
                                   bounds.top);
                                   SetOrigin(rT.left, rT.top);
                                   RectRgn(aportT.visRgn, aportT.portRect);
                                   EraseRect(aportT.portRect);
                                   RectRgn(hrgnTGlobal, rT);
                                   DiffRgn(hrgnNotErased, hrgnTGlobal, hrgnNotErased);
                                   END;
                              END;
                         END;
                    END;
               GetPort(portT);
               IF portT <> @aportT THEN
                    BEGIN
                    EraseRgn(hrgnNotErased);
                    WITH hrgnNotErased^^.rgnBBox DO topLeft := botRight;
                    END;
               IF (orecOldSave <> orecNil) THEN
                    BEGIN
                    recOld := POINTER(ORD(dsp)+orecOldSave);
                    recNew^.orecSon := recOld^.orecSon;
                    rec := POINTER(ORD(dsp)+recOld^.orecSon);
                    rec^.foPrnt.o := crdStd^.orec;
                    recOld^.orecSon := orecNil;
                    orecOldSave := OrecSibFree(orecOldSave);
                    END;
               GenImg(crdStd);
               IF (oboxPane <> oboxNil) THEN
                    BEGIN
                    IF (ics = icsSel) AND selCur.fShowing THEN
                         HilightCrd(crdStd, selCur.oint, selCur.tyHilight, TRUE);
                    GetPort(portT);
                    IF portT = @aportT THEN
                         BEGIN
                         SetPort(portScreen);
                         CopyBits(aportT.portBits, portScreen^.portBits, rT, rT, 0,
                         NIL);
                         END;
                    END;
               END;
          {All pointers invalid!!!}
          END;
          {GOTO 100;}

100: { Common part for old and new rec's. }
     IF (orecOldSave <> orecNil) THEN
          BEGIN
          EraseOrec(orecOldSave);
          orecOldSave := OrecSibFree(orecOldSave);
          END;
     {$ifc fDbgOk}
     IF fTstDsp THEN
          BEGIN
          WRITELN('Loop 100 - orecOld:', orecOld:4, '; -Fixed:',
          orecFixed:4, '; -Prv:', orecPrvT:4);
          WRITELN('             -OverlapOldDefer:',
          orecOverlapOldDefer:4, '; LayoutDefer: ', orecLayoutDefer:4,
          '; KeepDefer: ', orecKeepDefer:4);
          WRITE(' orecNew - '); PxOrec(orecNew);
          END;
     {$endc}
     { This will be elaborated when we implement columnar paragraghs, etc. }
     { We will want to position: absolute, move down, move right, }
     { push y location and move down, move to popped y location}
     recNew := POINTER(ORD(dsp)+orecNew);
     recNew^.strec.fValid := TRUE;
     lpCur := lpCur+recNew^.dlpLim;
     dxWidMac := CMax(dxWidMac, recNew^.r.right - ptCur.h);
     IF (ptNxt.v <= 0) AND (orecFixed <> orecNil)
        AND (orecLayoutDefer = orecNil) AND (NOT recNew^.strec.fRecDep) THEN
          BEGIN
          rec := POINTER(ORD(dsp)+orecFixed);
          WITH rec^ DO
               BEGIN
               pint := POINTER(ORD(lldInt) + recNew^.ointDep);
               ointDep:= OintMark(ointDep, ics, lpNil, pint^.lpLim, TRUE, ointNil);
               AddRs(recNew^.r, rec^.r);
               strec.fformfeed := recNew^.strec.fformfeed;  {retain formfeed flag}
               pint := POINTER(ORD(lldInt) + ointDep);
               dlpLim := lpCur - pint^.lpFst;
               END;
          IF fTstDsp THEN WRITE('orecNew (10) ');
          orecT := OrecSibFree(orecNew);
          orecNew := orecFixed;
          END
     ELSE BEGIN
          rec := POINTER(ORD(dsp)+orecPrvT);
          IF orecPrvT = orecUpdate THEN
               rec^.orecSon := orecNew
          ELSE rec^.orecSib := orecNew;
          IF (orecFixed = orecNil) AND (orecLayoutDefer = orecNil) THEN
               orecFixed := orecNew;
          IF orecKeepDefer <> orecNil THEN
               orecFixed := orecNil;
          orecPrvT := orecNew;
          END;
     ptCur := ptNxt;

     IF (orecPrvLayoutDefer <> orecNil)
       AND (orecPrvLayoutDefer <> orecLayoutDefer) THEN
          GenDefer(orecPrvLayoutDefer, orecOverlapDefer, orecLayoutDefer);

     IF (tydone = tydoneAfterThisRec) OR (tydone = tydoneBeforeThisRec) THEN
          BEGIN tyterm := tytermLayoutDone; GOTO 10; END;
     END; { big loop }

10:
Cleanup;
DisposeRgn(hrgnNotErased);
IF ORD(hrgnClipSave) <> ORD(hNil) THEN
     BEGIN
     thePort^.clipRgn := hrgnClipSave;
     DisposeRgn(hrgnTClip);
     END;
{$ifc fDbgOk}
IF fTstDsp THEN BEGIN WRITELN('orecUpdate - '); PxOrec(orecUpdate); END;
{$endc}
20:  { EXIT }
TytermUpdateRec := tyterm;
IF fTstDsp THEN
     BEGIN
     WRITE('TytermUpdateRec returning tyterm');
     CASE tyterm OF
     tytermEos:        WRITELN('Eos.');
     tytermOutOfWw:    WRITELN('OutOfWw.');
     tytermLayoutDone: WRITELN('LayoutDone.');
     OTHERWISE              WRITELN('**UNKNOWN**');
     END;
     END;
END; { TytermUpdateRec }


{--------------------}
PROCEDURE ValidateDsp;
{--------------------}
VAR orecCon: TC; recCon: TRec; tyterm: TTyterm;
    fLayoutPage: TF; recPrnt: TRec; pint: TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
orecCon := dsp^.orecConRoot;
WHILE orecCon <> orecNil DO
    BEGIN
    recCon := POINTER(ORD(dsp)+orecCon);
    fLayoutPage := NOT recCon^.foPrnt.fObox;
    IF fLayoutPage THEN
        BEGIN
        recPrnt := POINTER(ORD(dsp)+recCon^.foPrnt.o);
        pint := POINTER(ORD(lldInt)+recPrnt^.ointDep);
        fLayoutPage := rghcs^[pint^.ics]^^.tycs = tycsPg;
        END;
    tyterm := TytermUpdateRec(orecCon, {tyxyScrn,} iimgpScrn, fLayoutPage);
    recCon := POINTER(ORD(dsp)+orecCon);
    orecCon := recCon^.orecNxtCon;
    END;
END;

{$S LWPreview}
{--------------------------------------}
PROCEDURE NormalizeOrecCon{orecCon: TC};
{--------------------------------------}
LABEL 2;
VAR
ptCur: TPt;
lpFst, lpLst, lpFstVis: TLp;
orecScroll: TC;
tyterm: TTyterm;
rec, recScroll: TRec;
pint: TPint;
ics: TB;
tyxyCon: TTyxy;
orecSon: TC;
orec: TC;
rT: TR;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
rec := POINTER(ORD(dsp)+orecCon);
tyxyCon := rec^.tyxy;
ptCur := rec^.r.topLeft;
pint := POINTER(ORD(lldInt)+rec^.ointDep);
ics := pint^.ics;
lpFstVis := pint^.lpFst;
orecSon := rec^.orecSon;
IF orecSon <> orecNil THEN
     BEGIN
     rec := POINTER(ORD(dsp)+orecSon);
     pint := POINTER(ORD(lldInt)+rec^.ointDep);
     pint^.fValid := FALSE;
     END;
FindLpFixed(ics, lpFstVis, lpFst);
IF lpFstVis > lpFst THEN
     BEGIN
     orecScroll := Orec1Alloc(ics, lpFst, lpFstVis, ptZero, ptZero,
                              tyxyCon, fixedLpLim, FALSE, foNil);
     tyterm := TytermUpdateRec(orecScroll, iimgpScrn, FALSE);
     recScroll := POINTER(ORD(dsp)+orecScroll);
     orec := OrecOfLp(recScroll^.orecSon, ics, lpFstVis, TRUE);
     recScroll := POINTER(ORD(dsp)+orecScroll);
     IF orec = orecNil THEN
          ptCur.v := ptCur.v - (recScroll^.r.bottom - recScroll^.r.top)
     ELSE BEGIN
          rec := POINTER(ORD(dsp)+orec);
          ConvertRTyxy(rec^.r, rT, rec^.tyxy, tyxyCon);
          ptCur.v := ptCur.v - (rT.top - recScroll^.r.top);
          END;
     orecScroll := OrecSibFree(orecScroll);
     END;
WHILE ptCur.v > 0 DO
     BEGIN
     IF lpFst = 0 THEN
          BEGIN
          ptCur.v := 0;
          GOTO 2;
          END;
     lpLst := lpFst-1;
     orecScroll := Orec1Alloc(ics, lpLst, lpFst, ptZero, ptZero,
                              tyxyCon, fixedLpLim, FALSE, foNil);
     { UpdateRec will call FindLpFixed. }
     tyterm := TytermUpdateRec(orecScroll, iimgpScrn, FALSE);
     rec := POINTER(ORD(dsp)+orecScroll);
     ptCur.v := ptCur.v - (rec^.r.bottom - rec^.r.top);
     pint := POINTER(ORD(lldInt)+rec^.ointDep);
     lpFst := pint^.lpFst;
     orecScroll := OrecSibFree(orecScroll);
     END;
2:
rec := POINTER(ORD(dsp)+orecCon);
{ move rec^.r to ptCur }
OffsetRect(rec^.r, ptCur.h - rec^.r.left, ptCur.v - rec^.r.top);
pint := POINTER(ORD(lldInt)+rec^.ointDep);
pint^.lpFst := lpFst;
END;

{------------------------------------------------------------------------}
PROCEDURE ScrollOrec { (oboxPane: TC; dptRtDown: TPt; fNoScrollEos: TF) };
{------------------------------------------------------------------------}
{ assumes dptRtDown is tyxyScrn }
LABEL   12, 122;
VAR pboxPane: TPbox; rec: TRec; pint: TPint;
    orecSon, orecScroll, orecCon, orec: TC;
    ptCur, ptFst, ptPgWidHt, dptT: TPt;
    lpFst, lpLst:  TLp; ics: TB; tyterm: TTyterm; hWidPane: TC;
    tyxyRec: TTyxy;
    orecDummy: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstDsp THEN WRITELN('ScrollOrec [', dptRtDown.h, dptRtDown.v, ']');
pboxPane := PboxFromObox(oboxPane);
orecCon := pboxPane^.refCon;
hWidPane := pboxPane^.r.right - pboxPane^.r.left;
WHILE orecCon <> orecNil DO
     BEGIN
     rec := POINTER(ORD(dsp)+orecCon);
     dptT := dptRtDown;
     tyxyRec := rec^.tyxy;
     ConvertTyxy(dptT.h, dptT.v, tyxyScrn, tyxyRec);
     ptFst := rec^.r.topLeft;
     orecSon := rec^.orecSon;
     ptCur := ptFst;
     pint := POINTER(ORD(lldInt)+rec^.ointDep);
     ics := pint^.ics;
     { pint^.fValid := FALSE; }
     lpFst := pint^.lpFst;
     IF (dptT.v <> 0) THEN
          BEGIN
          IF NOT rec^.strec.fScrollV THEN GOTO 12;
          IF dptT.v > 0 THEN
               BEGIN
               ptCur.v := ptCur.v+dptT.v;
               { ptCur.h := ptCur.h+dptT.h; }
               WHILE ptCur.v > 0 DO
                    BEGIN
                    IF lpFst = 0 THEN
                         BEGIN
                         dptT.v := dptT.v-ptCur.v;
                         ptCur.v := 0;
                         GOTO 122;
                         END;
                    lpLst := lpFst-1;
                    orecScroll := Orec1Alloc(ics, lpLst, lpFst, ptZero, ptZero,
                                             tyxyRec, fixedLpLim, FALSE, foNil);
                    { UpdateRec will call FindLpFixed. }
                    tyterm := TytermUpdateRec(orecScroll, iimgpScrn, FALSE);
                    rec := POINTER(ORD(dsp)+orecScroll);
                    ptCur.v := ptCur.v - (rec^.r.bottom - rec^.r.top);
                    pint := POINTER(ORD(lldInt)+rec^.ointDep);
                    lpFst := pint^.lpFst;
                    orec := OrecSibFree(orecScroll);
                    END;
122:
               END
          ELSE IF dptT.v < 0 THEN
               BEGIN
               IF (rec^.tyterm = tytermEos) AND fNoScrollEos THEN GOTO 12;
               ptCur.v := -dptT.v;
               orec := OrecOfPt(orecSon, TRUE, ptCur, FALSE);
               IF orec = orecNil THEN orec := orecSon; {FindLpFixed is unnecessary}
               rec := POINTER(ORD(dsp)+orec);
               pint := POINTER(ORD(lldInt)+rec^.ointDep);
               FindLpFixed(ics, pint^.lpFst, lpFst);
               orec := OrecOfLp(orecSon, ics, lpFst, FALSE);
               IF orec = orecNil THEN EXIT (ScrollOrec);  {was Break(16)}
               rec := POINTER(ORD(dsp)+orec);
               ptCur.v := rec^.r.top + dptT.v;
               END;
          END
     ELSE IF (dptT.h <> 0) THEN
          BEGIN
          IF NOT rec^.strec.fScrollH THEN GOTO 12;
          DptPaperSize(IcsConFromPane(oboxPane, orecDummy),
                       tyxyRec, {OUT} ptPgWidHt);
          ptCur.h := CMin(0, CMax(hWidPane - ptPgWidHt.h, ptCur.h+dptT.h));
          END;
     oboxPane := OboxVisOrec(orecCon);
     ptFst.v := ptFst.v+dptT.v;
     ptFst.h := ptCur.h;
     MoveRecs(orecCon, ptFst, tyxyRec);
     rec := POINTER(ORD(dsp)+orecCon);
     { move rec^.r to ptCur }
     OffsetRect(rec^.r, ptCur.h - rec^.r.left, ptCur.v - rec^.r.top);
     pint := POINTER(ORD(lldInt)+rec^.ointDep);
     pint^.lpFst := lpFst;
12:
     rec := POINTER(ORD(dsp)+orecCon);
     orecCon := rec^.orecSib;
     END;
 { ValidateDsp; }
END; {ScrollOrec }


{$S LWCreate}
PROCEDURE InitDsp{hz: THz};
VAR
portT: TPort;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
ptMax.h := MAXINT; ptMax.v := MAXINT;
ptZero.h := 0;  ptZero.v := 0;
hzDsp := hz;
GetPort(portT);
OpenPort(@aportT);
SetPort(portT);
WITH aportT DO
     BEGIN
     portBits.baseAddr := @argbBmp;
     END;
hrgnTGlobal := NewRgn;
xOrYDummy := 0;

ampitrtywo[0]  := tywoNil;       ampitrtywo[1]  := tywoFwdOne;
ampitrtywo[2]  := tywoNil;       ampitrtywo[3]  := tywoNil;
ampitrtywo[4]  := tywoFwdOne;    ampitrtywo[5]  := tywoFwdOne;
ampitrtywo[6]  := tywoFwdOne;    ampitrtywo[7]  := tywoFwdOne;
ampitrtywo[8]  := tywoNil;       ampitrtywo[9]  := tywoFwdBoth;
ampitrtywo[10] := tywoNil;       ampitrtywo[11] := tywoNil;
ampitrtywo[12] := tywoFwdBoth;   ampitrtywo[13] := tywoFwdBoth;
ampitrtywo[14] := tywoFwdOne;    ampitrtywo[15] := tywoNil;
END;


END.






ÿ