{$I APLW/COMPFLAGS }                                            {gdf 1/16/84}
{$R-}

UNIT UnitRuler;

(* Copyright 1983, 1984, Apple Computer Inc. *)

{ gdf  2/27/84 -- insert trace calls for segmentation  }
{ gdf  1/16/84 -- printing compile flag & include COMPFLAGS added }
{ tjm  4/06/83  --  RemoveKid(fSaveKid) - (WP 258) }
{ crc  3/18/83 -- SetRulerClip: Call SectRgnVis instead of no-op fClipR;
                  DrawIrmMoving: fix to drawing all tabs;
                  ApplyRuler: Allow setting (i.e. changing) tab on top of another }
{ crc  3/17/83 -- Pass min & max parameters to VhNearestMark;
                  DrawIrmMoving: Draw all tabs since they are now so close }
{ crc  3/16/83 -- DrawIrmMoving: Draw tabs in reverse of direction of movement }
{ crc  3/15/83 -- MoveRm: Added routine CalcONear; uses dxMinTab from UnitFf;
                  ApplyRuler: Check for existing tab within dxMinTab }
{ crc  2/25/83 -- MovingRm: Stop if ruler mark dragged outside ruler's pane }
{ crc  1/24/83 -- ApplyRuler, DrawIrmMoving: allow tabs to leftmost of left &
                  first margin.
                  DrawIrmMoving: right margin stops at rightmost tab or left or
                  first margin; either left or first margin must remain to left of
                  first tab. }
{ crc  1/06/83 -- pass fLayoutPage parm to TytermUpdateRec }
{ crc  1/05/83 -- ApplyRuler: allow tab stop to be set at right margin }
{ crc  1/04/83 -- DrawIrmMoving: allow tabs to be dragged to right margin and
                  right margin to be dragged to rightmost tab }
{ crc 12/21/82 -- ApplyRuler calls vhNearestMark to set, clear, and fill tabs }
{ crc 12/20/82 -- ApplyRuler: clear or fill tab only on exact x-coord match }
{ crc 12/10/82 -- SelToRuler: removed early exit if orec = orecNil }
{ crc 12/03/82 -- ApplyRuler won't set tab stops outside margins }
{ crc 12/01/82 -- GenCrdRuler extends rect of page ruler by 1 in vertical direction
                  so FrameRect, EraseRect include last pixel. Requires change to
                  DrawMarks. }
{ crc 11/10/82 -- fix to fix of MoveRm }
{ crc 11/08/82 -- fixed MoveRm to display page icons correctly on button down }
{ crc 11/03/82 -- DrawIrmMoving modified to ensure VhNearestMark does't round
                  below minimum or above maximum value;  GenImgRuler does not
                  pass inset rec to DrawRuler; MovedRm fixed so dragging T icon
                  does not affect location of bottom of body; fixed DrawIrmMoving
                  to set pt even if margin icon doesn't move}
{ jrm 6/29/82  --  USES changes: LisaGraf => QuickDraw; moved USES UnitFile }
{ crc 6/02/82 -- Conditional compilation }
{ crc 5/27/82 -- added routine AdjustRulerPrprf }
{ crc 5/21/82 -- configSizePaperIn6ths replaced by function DptPaperSize }
{ crc 4/06/82 -- integration with new font manager }
{ bas 3/15/82 -- orec tyxy, pglp tyxy update }
{ bas 2/24/82 --  lisaprint uses }
{ tjm 2/01/82 --  metric problems, etc. }
{ bas 1/13/82 --  integration with lisaprint (USES + configSizePaperIn6ths);
    USES for new wm }
{ bas 12/10/81  --  integration with font manager }
{ DoParFop removes kid. }


INTERFACE

USES
     {$IFC sampcalls}                                               {gdf 2/24/84}
        {$U aplw/tracecalls.obj} tracecalls,
     {$ENDC}
     {$U Obj:UnitStd.Obj }   UnitStd,
     {$U Obj:UnitHz.Obj }    UnitHz,
     {$U LibOS/Syscall.Obj }   Syscall,
     {$U Obj:UnitFile.Obj }  UnitFile,
     {$U Obj:Storage.Obj }   Storage,
     {$U Obj:QuickDraw.Obj }  QuickDraw,
     {$U Obj:FontMgr.Obj }   FontMgr,
     {$U Obj:PmDecl       }  PmDecl,
     {$IFC fPrintOld}                                               {gdf 1/16/84}
        {$U Obj:PrStd.Obj }     PrStd,
     {$ELSEC}
        {$U Obj:PrStdInfo.Obj } PrStdInfo,
          (* {$U Obj:PrPublic.Obj }  PrPublic,  unneeded ? *)
     {$ENDC}                                                        {gdf 1/16/84}
     {$U Obj:UnitFmt.Obj }   UnitFmt,
     {$U Obj:UnitCs.Obj }    UnitCs,
     {$U Obj:UnitFf.Obj     } UnitFf,
     {$U Obj:Wm.Events.Obj  } Events,
     {$U Obj:Wm.Folders.Obj } Folders,
     {$U Obj:WmlStd     }    WmlStd,
     {$U Obj:WM.Menus.Obj }  Menus,
     {$U Obj:AlertMgr.Obj }  AlertMgr,
     {$U ApLW/Queue.Obj }     Queue,
     {$U ApLW/UnitBox.Obj }   UnitBox,
     {$U ApLW/UnitRec.Obj }   UnitRec,
     {$U ApLW/UnitOver.Obj }  UnitOver,
     {$U ApLW/UnitTld.Obj }   UnitTld,
     {$U ApLW/UnitPrt.Obj }   UnitPrt,
     {$U ApLW/UnitEd.Obj }    UnitEd,
     {$U ApLW/UnitEdit.Obj }  UnitEdit,
     {$U ApLW/UnitKid.Obj }   UnitKid,
     {$U ApLW/UnitDsp.Obj }   UnitDsp,
     {$U ApLW/UnitSel.Obj }   UnitSel,
     {$U ApLW/UnitPg.Obj }    UnitPg;

{$IFC NOT fDbgOk}
CONST
     fTstRuler = FALSE;
{$ENDC}

TYPE TRat = RECORD c: TC; num: TC; denom: TC; END;

VAR
 tyrluDefault, tyrluCurrent: TTyRlU;


{$IFC fDbgOk}
 fTstRuler: TF;
{$ENDC}

 { Ruler class functions. }
FUNCTION  IcsRulerCreate   (oboxPane: TC; fHoriz: TF; hz: THz) : TB;
PROCEDURE FreeRulerIcs     (ics: TB);
PROCEDURE GenCrdRuler      (crd: TCrd; ics: TB; lp: TLp; tyxy: TTyxy);
PROCEDURE GenImgRuler      (crd: TCrd);

 { Ruler mouse functions. }
PROCEDURE MoveRm           (pt: TPt; icsRuler: TB);
PROCEDURE MovingRm         (pt: TPt; icsRuler: TB; oboxPane: TC);
PROCEDURE MovedRm          (ointSel: TC; icsRuler: TB);

 { Ruler contents functions. }
PROCEDURE SelToRuler       (icsRuler: TB; orecClip: TC; fTrackPt, fRestore: TF);
PROCEDURE FindLpRulerFixed (ics: TB; lp: TLp; VAR lpFixed: TLp);
PROCEDURE ApplyRuler       (ifld: TC; sval: TC; fDecimalComma: TF; icsRuler: TB);
PROCEDURE DoParFop         (ifld: TC; sval: TW; pval: TPc);
FUNCTION  FSetRulers       (tyrlu: TTyRlU): TF;

{$IFC fPrintOld}                                                    {gdf 1/16/84}

PROCEDURE AdjustRulerPrprf (ics: TB; prprf: TPrprf);

{$ELSEC}                                                            {gdf 1/16/84}

PROCEDURE AdjustRulerPrprf (ics: TB; prprf: TPrRec);  { ??? }

{$ENDC}                                                             {gdf 1/16/84}


PROCEDURE PxHcsruler       (hcs: THcs);
PROCEDURE InitRuler        (hz: THz);

FUNCTION  IcsPgOfIcsRuler  (icsRuler: TB): TB;
PROCEDURE VerifyMarginRuler(icsRuler: TB);

PROCEDURE SetTyRlu         (ics: TB; tyrlu: TTyRlU);
PROCEDURE GetTyRlu         (ics: TB; VAR tyrlu: TTyrlu);

IMPLEMENTATION

{$IFC fSymOK }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

CONST       {oxRules      = 0; allows ruler marks to hang over}
      oyBotRuler   = 16 (* displacement from top of ruler of the tab marks *);
      oyTopRmFMarg = 23 (*            "              of the 'first line' mark *);
      oyTopRmMarg  = 35 (*            "              of the 'left' and 'right' marks *);
      dyHtRulMargScrn  = 49 (* height of margin/tabs ruler *);

      dxWidPageRulerScrn = 60;
      oxRightRuler       = 26;

      xferReplace = 0;
      xferOr      = 1;
      xferErase   = 3;

      irmPt      = 0;
      irmFMarg   = 1;
      irmLMarg   = 2;
      irmRMarg   = 3;
      irmBotFst  = 1;
      irmMargFst = 2;
      irmTabFst  = 4;
      irmNil     = -1;
      irmPgFst   = 1;
      irmHdr     = 1;
      irmTop     = 2;
      irmBot     = 3;
      irmFtr     = 4;
      irmMaxPg   = 5;

      dyUnderSelFst = 20;
      dhRmStd       = 18;
      dvRmStd       = 15;
      vPt           = 1;
      dhMinDistance = 8;

      imarkMax = 4;

TYPE TTyCsr = (tyCsrPt, tyCsrLMarg, tyCsrRMarg, tyCsrFMarg, tyCsrLTab, tyCsrRTab,
               tyCsrCTab, tyCsrDPTab, tyCsrDCTab, tyCsrTop, tyCsrBot, tyCsrHdr,
               tyCsrFtr);

 TTyRuler = (tyRulMargTab, tyRulPage);

 TRm = RECORD
         ptHot:  TPt;
         tyCsr:  TTyCsr;
         END;

 TArgrm = ARRAY [0..0] OF TRm;
 TRgrm = ^TArgrm;

 TCsruler = RECORD
         cs:             TCs;
         orecCon:        TC;
         oboxPane:       TC;
         tyrlu:          TTyRlU;
         irmLim:         TC;
         tyRuler:        TTyRuler;
         ointParMargins: TC;       { margins ruler only }
         dptWidHt:       TPt;
         icsPg:          TB;
         argrm:          TArgrm;
         END;
 TPcsruler = ^TCsruler;
 THcsruler = ^TPcsRuler;

 TMarkd = RECORD
         ratUnitsPerInch: TRat;
         imarkMac:        TC;
         argcmarkPerUnit: ARRAY [0..imarkMax] OF TC;
         argvhWidHt:      ARRAY [0..imarkMax] OF TC;
         END;

 TPropOfTyCsr = RECORD
                   ch: CHAR;
                   ptHotDiff: TPt;
                END;

VAR rRmStd (* r for dhRmStd by dvRmStd *): TR;
    bmRmSave: BitMap;
    csrSave: ARRAY[0..63] OF TB (* big enough for dhRmStd by dvRmStd *);
    argPropOfTyCsr: ARRAY [TTyCsr] OF TPropOfTyCsr;
    irmMoving: TC;
    orecMoving: TC;
    argn: TArgn;
    ptOffScreen:  TPt;
    xOrigMoving: TX;
    argmarkd:  ARRAY [TTyRlU] OF TMarkd;

{====================}
{$I ApLW/GrafInRul.Text }
{====================}

{$S LWDebug}
{$ifc fDbgOk}
{----------------------}
PROCEDURE PxRm(rm: TRm);
{----------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH rm DO
    WRITELN('ptHot: [', ptHot.h, ptHot.v, ']; tyCsr: ', ORD(tyCsr));
END;
{$endc}

{----------------------------------}
PROCEDURE PxHcsruler { (hcs: THcs) };
{----------------------------------}
VAR hcsruler:   THcsruler;
 irm:        TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$ifc fDbgOk}
hcsruler := POINTER(ORD(hcs));
WITH hcsruler^^ DO
   BEGIN
   WRITELN('orecCon: ', orecCon, ', oboxPane: ', oboxPane, ', tyRlU: ',
            ORD(tyRlU));
   WRITELN('irmLim: ', irmLim, ', tyRuler: ', ORD(tyRuler),
           ', dptWidHt: [', dptWidHt.h, dptWidHt.v, ']');
   FOR irm := 0 TO irmLim - 1 DO PxRm(argrm[irm]);
   END;
{$endc}
END;

{$S LWMisc}
{-------------------------------------------}
PROCEDURE SetTyRlu {(ics: TB; tyrlu: TTyRlU)};
{-------------------------------------------}
VAR icsEd: TB;
    hcspg: THcsPg;
    hcsed: THcsEd;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
   IF ics <> icsNil THEN
      BEGIN
      IF rghcs^[ics]^^.tycs = tycsPg THEN
         BEGIN
         hcspg := POINTER(ORD(rghcs^[ics]));
         icsEd := hcspg^^.pgd.icsBody;
         END
      ELSE icsEd := ics;
      hcsed := POINTER(ORD(rghcs^[icsEd]));
      hcsed^^.tyrlu := tyrlu;
      END;
END;

{$S LWActive}
{-----------------------------------------------}
PROCEDURE GetTyRlu {(ics: TB; VAR tyrlu: TTyrlu)};
{-----------------------------------------------}
VAR icsEd: TB;
    hcspg: THcspg;
    hcsed: THcsEd;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
   IF ics <> icsNil THEN
      BEGIN
      IF rghcs^[ics]^^.tycs = tycsPg THEN
         BEGIN
         hcspg := POINTER(ORD(rghcs^[ics]));
         icsEd := hcspg^^.pgd.icsBody;
         END
      ELSE icsEd := ics;
      hcsed := POINTER(ORD(rghcs^[icsEd]));
      tyrlu := hcsed^^.tyrlu;
      END;
END;

{$S LWMisc}
{$IFC fPrintOld}                                                    {gdf 1/16/84}
{---------------------------------------------------}
PROCEDURE AdjustRulerPrprf {(ics: TB; prprf: TPrprf)};
{---------------------------------------------------}
{$ELSEC}                                                            {gdf 1/16/84}
{---------------------------------------------------}
PROCEDURE AdjustRulerPrprf {(ics: TB; prprf: TPrRec)};  {???}
{---------------------------------------------------}
{$ENDC}                                                             {gdf 1/16/84}

VAR
  hcsruler: THcsruler;
  dpt: TPt;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcsruler := POINTER(ORD(rghcs^[ics]));
IF hcsruler^^.cs.tycs = tycsRuler THEN BEGIN
    hcsruler^^.cs.prprf := prprf;
    DptPaperSize(ics, tyxyScrn, {OUT} dpt);
    IF hcsruler^^.tyRuler = tyRulMargTab THEN
         SetPt(hcsruler^^.dptWidHt, dpt.h, dyHtRulMargScrn)
    ELSE SetPt(hcsruler^^.dptWidHt, dxWidPageRulerScrn, dpt.v);
    END;
END; {AdjustRulerPrprf}


{$S LWMargin}
{-----------------------------------}
PROCEDURE SetRulerClip(orecClip: TC);
{-----------------------------------}
VAR r: TR; rec: TRec; oboxPane: TC; f: TF;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
oboxPane := OboxVisOrec(orecClip);
rec := POINTER(ORD(dsp) + orecClip);
WITH rec^.r DO SetRect(r, left+1, top+1, right-1, bottom-1);
SectRgnVis(r);
END;

{$S LWMisc}
{--------------------------------------------}
FUNCTION  FSetRulers { (tyrlu: TTyRlU): TF };
{--------------------------------------------}
VAR ics: TB; hcsruler: THcsruler; rec: TRec; orec: TC; tyterm: TTyterm;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
FSetRulers := FALSE;
IF tyrluCurrent <> tyrlu THEN
    BEGIN
    IF fTstRuler THEN WRITE('FSetRulers trying...');
    FOR ics := 0 TO icsMac - 1 DO
    IF rghcs^[ics] <> POINTER(ORD(hNil)) THEN
    IF rghcs^[ics]^^.tycs = tycsRuler THEN
        BEGIN
        FSetRulers := TRUE;
        hcsruler := POINTER(ORD(rghcs^[ics]));
        hcsruler^^.tyrlu := tyrlu;
        rec := POINTER(ORD(dsp) + hcsruler^^.orecCon);
        rec^.strec.fValid := FALSE;
        orec := rec^.orecSon;
        WHILE orec <> orecNil DO
            BEGIN
            rec := POINTER(ORD(dsp) + orec);
            rec^.strec.fValid := FALSE;
            orec := rec^.orecSib;
            END;
        tyterm := TytermUpdateRec(hcsRuler^^.orecCon, iimgpScrn, FALSE);
        END;
    tyrluCurrent := tyrlu;
    END;
IF fTstRuler THEN WRITELN;
END;

{$S LWPreview}
{--------------------------------------------}
FUNCTION  IcsPgOfIcsRuler { (icsRuler: TB): TB };
{--------------------------------------------}
VAR hcsruler: THcsruler;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcsruler := POINTER(ORD(rghcs^[icsRuler]));
IF hcsruler^^.tyRuler = tyRulPage THEN
     IcsPgOfIcsRuler := hcsruler^^.icsPg
ELSE IcsPgOfIcsRuler := icsNil;
END;


{$S LWMargin}
{-------------------------------------------------------------------------------}
PROCEDURE SelToRuler { (icsRuler: TB; orecClip: TC; fTrackPt: TF; fRestore: TF) };
{-------------------------------------------------------------------------------}
VAR itb: TC; irm, irmLim: TC; rmT: TRm; rgrm: TRgrm; pintPar, pintSel: TPint;
    orec: TC; achadNil: TAChad; ptHotNew: TPt; hcsRuler: THcsruler;
    dx: TX; fDoIt: TF; ointPar: TC; tyset: TTyset;
    ptPgWidHt: TPt;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstRuler THEN WRITELN('SelToRuler');
hcsruler := POINTER(ORD(rghcs^[icsRuler]));
IF orecClip = orecNil THEN orecClip := hcsruler^^.orecCon;
SetRulerClip(orecClip);
dx := DxSel(hcsruler^^.oboxPane, orec);
IF orec = orecNil THEN dx := 0;  {arbitrary value}

IF (fTrackPt) OR (hcsruler^^.argrm[irmPt].ptHot.h = ptOffScreen.h)
   THEN Setpt(ptHotNew, dx, vPt)
   ELSE ptHotNew := hcsruler^^.argrm[irmPt].ptHot;
IF NOT fRestore THEN hcsruler^^.argrm[irmPt].ptHot := ptOffScreen;
DrawRm(irmPt, ptHotNew, hcsruler, orecClip);

ointPar := hcsruler^^.ointParMargins;
fDoIt := TRUE;
pintSel := POINTER(ORD(lldInt)+selCur.oint);
IF ointPar <> ointNil THEN
    BEGIN
    pintPar := POINTER(ORD(lldInt)+ointPar);
    fDoIt := NOT (pintPar^.fValid AND (pintPar^.ics = pintSel^.ics)
                 AND (pintPar^.lpFst <= pintSel^.lpFst)
                 AND (pintSel^.lpFst < pintPar^.lpLim));
    END;

DptPaperSize(pintSel^.ics, tyxyScrn, {OUT} ptPgWidHt);

pintSel := POINTER(ORD(lldInt)+selCur.oint);
WITH achadNil DO BEGIN rgch := NIL; ichFst := 0; ichLim := MAXINT; END;
tyset := tysetRpe; tyset.fParBnds := TRUE;
SetLpd(lpdStd, pintSel^.ics, pintSel^.lpFst, tyset, achadNil);
hcsruler^^.ointParMargins := OintMark(ointPar, lpdStd^.ics,
                        lpdStd^.lpFstPar, lpdStd^.lpLimPar, TRUE, ointNil);
irmLim := irmTabFst;
IF lpdStd^.rpe^.itbLim > 0 THEN irmLim := lpdStd^.rpe^.itbLim + irmTabFst;
IF fDoIt OR (irmLim <> hcsruler^^.irmLim) THEN
    WITH lpdStd^.rpe^ DO
        BEGIN
        xRt := CMin(xRt, ptPgWidHt.h - dhFromRtPgEdge);
        xLftFst := CMin(xLftFst, xRt - dhMinMarg);
        xLftBody := CMin(xLftBody, xRt - dhMinMarg);
        rgrm := @hcsruler^^.argrm;
         { Are the bitmaps under the points valid? }
        IF fRestore THEN
            FOR irm := 1 TO hcsruler^^.irmLim-1 DO
                DrawRm(irm, ptOffScreen, hcsruler, orecClip)
        ELSE
            FOR irm := 1 TO hcsruler^^.irmLim-1 DO
                rgrm^[irm].ptHot := ptOffScreen;
        IF irmLim > hcsruler^^.irmLim THEN
            ChangeSizeH(hcsruler^^.cs.hz, POINTER(ORD(hcsruler)),
                        SIZEOF(TCsruler) + irmLim*SizeOf(TRm));
        rgrm := @hcsruler^^.argrm;
        hcsruler^^.irmLim := irmLim;
        rmT.ptHot := ptOffScreen;

        SetPt(ptHotNew, xLftBody, oyTopRmMarg);
        rmT.tyCsr := tyCsrLMarg;
        rgrm^[irmLMarg] := rmT;
        DrawRm(irmLMarg, ptHotNew, hcsruler, orecClip);

        ptHotNew.h := xRt;
        rmT.tyCsr := tyCsrRMarg;
        rgrm^[irmRMarg] := rmT;
        DrawRm(irmRMarg, ptHotNew, hcsruler, orecClip);

        SetPt(ptHotNew, xLftFst, oyTopRmFMarg);
        rmT.tyCsr := tyCsrFMarg;
        rgrm^[irmFMarg] := rmT;
        DrawRm(irmFMarg, ptHotNew, hcsruler, orecClip);

        FOR itb := 0 TO itbLim-1 DO
           BEGIN
           SetPt(ptHotNew, argtbd[itb].x, oyBotRuler);
           CASE argtbd[itb].quad OF
              quadL: rmT.tyCsr := tyCsrLTab;
              quadR: rmT.tyCsr := tyCsrRTab;
              quadC: rmT.tyCsr := tyCsrCTab;
              quadJ: IF argtbd[itb].fDecimalComma THEN rmT.tyCsr := tyCsrDCTab
                                                  ELSE rmT.tyCsr := tyCsrDPTab;
              END;
           rgrm^[itb + irmTabFst] := rmT;
           DrawRm(itb + irmTabFst, ptHotNew, hcsruler, orecClip);
           END;
        END;
END; {SelToRuler}


{$S LWInsert}
PROCEDURE VerifyMarginRuler{icsRuler: TB};
VAR
pintSel, pintPar: TPint;
hcsruler: THcsruler;
ointPar: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF icsRuler <> icsNil THEN
     BEGIN
     hcsruler := POINTER(ORD(rghcs^[icsRuler]));
     pintSel := POINTER(ORD(lldInt)+selCur.oint);
     ointPar := hcsruler^^.ointParMargins;
     IF ointPar <> ointNil THEN
         BEGIN
         pintPar := POINTER(ORD(lldInt)+ointPar);
         IF NOT (pintPar^.fValid AND (pintPar^.ics = pintSel^.ics)
                      AND (pintPar^.lpFst <= pintSel^.lpFst)
                      AND (pintSel^.lpFst < pintPar^.lpLim)) THEN
              SelToRuler(icsRuler, orecNil, FALSE, TRUE);
         END;
    END;
END;


{$S LWPreview}
{------------------------------------------------------}
PROCEDURE PgdToRuler(hcsruler: THcsruler; orecClip: TC);
{------------------------------------------------------}
VAR rmT: TRm; rgrm: TRgrm; rec: TRec; lpOrLppg: TLpOrLppg;
 pint: TPint; ptHotNew: TPt; hcspg: THcspg; pglp: TPglp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcspg := POINTER(ORD(rghcs^[hcsruler^^.icsPg]));
{$ifc fDbgOk}
IF fTstRuler THEN WITH hcspg^^.pgd.pglp DO
    BEGIN WRITELN('PgdToRuler'); PxCs(hcsruler^^.icsPg); END;
{$endc}
rgrm := @hcsruler^^.argrm;
ConvertIcsPglpTyxy(hcsruler^^.icsPg, pglp, tyxyScrn);
WITH pglp DO
    BEGIN
    SetPt(ptHotNew, oxRightRuler, yTopHdr);
    rmT.tyCsr := tyCsrHdr;
    rgrm^[irmHdr] := rmT;
    IF fTstRuler THEN WRITELN('ptHotNew: [', ptHotNew.h, ptHotNew.v, ']');
    DrawRm(irmHdr, ptHotNew, hcsruler, orecClip);
    ptHotNew.v := ptHotNew.v + dyHdr;
    rmT.tyCsr := tyCsrTop;
    rgrm^[irmTop] := rmT;
    IF fTstRuler THEN WRITELN('ptHotNew: [', ptHotNew.h, ptHotNew.v, ']');
    DrawRm(irmTop, ptHotNew, hcsruler, orecClip);
    ptHotNew.v := ptHotNew.v + dyBotBody;
    rmT.tyCsr := tyCsrBot;
    rgrm^[irmBot] := rmT;
    DrawRm(irmBot, ptHotNew, hcsruler, orecClip);
    ptHotNew.v := ptHotNew.v + dyHtBody - dyBotBody;
    rmT.tyCsr := tyCsrFtr;
    rgrm^[irmFtr] := rmT;
    DrawRm(irmFtr, ptHotNew, hcsruler, orecClip);
    END;
END;

{$S LWMScroll}
{----------------------------------}
PROCEDURE FreeRulerIcs { (ics: TB) };
{----------------------------------}
LABEL 500;
VAR pboxPane: TPbox; orecCon, orecNxtCon, orecFstCon: TC;
 recCon: TRec; hcsruler: THcsruler;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstRuler THEN WRITELN('FreeRulerIcs(', ics, ')');
hcsruler := POINTER(ORD(rghcs^[ics]));
VisObox(hcsruler^^.oboxPane);
orecCon := hcsruler^^.orecCon;
InvalidOrec(orecCon);
EraseOrec(orecCon);
orecNxtCon := OrecSibFree(orecCon);
pboxPane := PboxFromObox(hcsruler^^.oboxPane);
orecFstCon := pboxPane^.refCon;
IF orecFstCon = orecCon THEN
     pboxPane^.refCon := orecNxtCon
ELSE WHILE TRUE DO
     BEGIN
     recCon := POINTER(ORD(dsp) + orecFstCon);
     IF recCon^.orecSib = orecCon THEN
         BEGIN recCon^.orecSib := orecNxtCon; GOTO 500; END;
     orecFstCon := recCon^.orecSib;
     IF orecFstCon = orecNil THEN Break(689);
     END;
500:
FreeBk(hcsruler^^.cs.hz, POINTER(ORD(hcsruler)), tybkStd);
rghcs^[ics] := POINTER(ORD(hNil));
END;

{------------------------------------------------------------------}
FUNCTION IcsRulerCreate { (oboxPane: TC; fHoriz: TF; hz: THz) : TB };
{------------------------------------------------------------------}
LABEL 100, 999;
VAR rec, recRuler: TRec; orec, orecConFst: TC; pboxPane: TPbox;
    ptTopLft, ptBotRtPane, ptSize: TPt; dx: TCd; r: TR;
    pint: TPint; achadNil: TAChad; hcspg: THcspg; ics: TB;
    hcsruler: THcsruler; lpFst: TLp; rmT: TRm;
    tyRuler: TTyruler; tyterm: TTyterm;
    dpt: TPt; orecDummy: TC; xOrYDummy: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstRuler THEN WRITELN('IcsRulerCreate');
 { Remove a ruler of this type already up. }
IF fHoriz THEN tyRuler := tyRulMargTab ELSE tyRuler := tyRulPage;
FOR ics := 0 TO icsMac - 1 DO
    IF rghcs^[ics] <> POINTER(ORD(hNil)) THEN
    IF rghcs^[ics]^^.tycs = tycsRuler THEN
        BEGIN
        hcsruler := POINTER(ORD(rghcs^[ics]));
        IF hcsruler^^.tyRuler = tyRuler THEN
            BEGIN FreeRulerIcs(ics); GOTO 100; END;
        END;
100:
pboxPane := PboxFromObox(oboxPane);
ptSize := pboxPane^.r.botRight;
SubPt(pboxPane^.r.topLeft, ptSize);
orecConFst := pboxPane^.refCon;
 { Bypass the other ruler, if necessary. }
rec := POINTER(ORD(dsp) + orecConFst);
pint := POINTER(ORD(lldInt) + rec^.ointDep);
IF rghcs^[pint^.ics]^^.tycs = tycsRuler THEN
     BEGIN
     orec := rec^.orecSib;
     IF orec = orecNil THEN Break(688);
     rec := POINTER(ORD(dsp) + orec);
     END
ELSE orec := orecConFst;

 { Are all the requirements fulfilled? }
IcsRulerCreate := icsNil;
pint := POINTER(ORD(lldInt) + rec^.ointDep);
IF fHoriz THEN
     BEGIN
     pint := POINTER(ORD(lldInt) + selCur.oint);
     IF rghcs^[pint^.ics]^^.tycs <> tycsEd THEN GOTO 999;
     END
ELSE BEGIN
     pint := POINTER(ORD(lldInt) + rec^.ointDep);
     IF rghcs^[pint^.ics]^^.tycs <> tycsPg THEN GOTO 999;
     END;

ptTopLft := rec^.r.topLeft;
ics := IcsCreate(tycsRuler, SIZEOF(TCsruler) + irmMaxPg*SizeOf(TRm), hz);
WITH rghcs^[ics]^^.cspd DO
    BEGIN
    argproc[iprocSeqLpd]       := POINTER(procNil);
    argproc[iprocFindLpFixed]  := @FindLpRulerFixed;
    argproc[iprocCrd]          := @GenCrdRuler;
    argproc[iprocFreeIcs]      := @FreeRulerIcs;
    argproc[iprocFSelLpBounds] := POINTER(procNil);
    argproc[iprocPxHcs]        := @PxHcsruler;
    argproc[iprocHilight]      := POINTER(procNil);
    argimgp[iimgpScrn]         := @GenImgRuler;
    END;
hcsruler := POINTER(ORD(rghcs^[ics]));
hcsruler^^.oboxPane := oboxPane;
hcsruler^^.tyrlu := tyrluCurrent;
hcsruler^^.tyRuler := tyRuler;
rec := POINTER(ORD(dsp) + orec);
DptPaperSize(IcsConFromPane(oboxPane,orecDummy), tyxyScrn, {OUT} dpt);
IF fHoriz THEN
    BEGIN
    SetPt(hcsruler^^.dptWidHt, dpt.h, dyHtRulMargScrn);
     { Get the orec; the dx is a dummy. }
    dx := DxSel(oboxPane, orec);
    IF orec = orecNil THEN ptTopLft.v := 0
    ELSE BEGIN
         rec := POINTER(ORD(dsp) + orec);
         ptTopLft.v := rec^.r.bottom;
         ConvertTyxy(xOrYDummy, ptTopLft.v, rec^.tyxy, tyxyScrn);
         END;
    ptTopLft.v := CMax(0, CMin(ptTopLft.v + dyUnderSelFst,
                               ptSize.v - hcsruler^^.dptWidHt.v));
    rmT.ptHot := ptOffScreen;
    rmT.tyCsr := tyCsrPt;
    hcsruler^^.argrm[irmPt] := rmT;
    hcsruler^^.irmLim := 1;
    hcsruler^^.ointParMargins := ointNil;
    lpFst := 0;
    END
ELSE BEGIN
    SetPt(hcsruler^^.dptWidHt, dxWidPageRulerScrn, dpt.v);
    ptTopLft.h := CMax(0, ptSize.h - hcsruler^^.dptWidHt.h);
    pint := POINTER(ORD(lldInt)+rec^.ointDep);
    hcsruler^^.irmLim := irmMaxPg;
    hcsruler^^.icsPg := pint^.ics;
    lpFst := pint^.lpFst;
    hcspg := POINTER(ORD(rghcs^[pint^.ics]));
    END;
hcsruler^^.orecCon := OrecCreateWindow(ics, lpFst, ptTopLft, oboxPane);
recRuler := POINTER(ORD(dsp) + hcsruler^^.orecCon);
recRuler^.strec.fScrollH := fHoriz;
recRuler^.strec.fScrollV := NOT fHoriz;
pboxPane := PboxFromObox(oboxPane);
ptBotRtPane := pboxPane^.r.botRight;
recRuler^.orecSib := pboxPane^.refCon;
pboxPane^.refCon := hcsruler^^.orecCon;
 { Erase where the ruler will go. }
(* -----
r.topLeft := recRuler^.r.topLeft;
GenCrd(ics, 0, tyxyScrn);
WITH r DO
 BEGIN
 IF fHoriz THEN
 BEGIN
 right := ptBotRtPane.h;
 bottom := top + (acrd.arec.r.bottom - acrd.arec.r.top);
 END
 ELSE BEGIN
 right := left + (acrd.arec.r.right - acrd.arec.r.left);
 bottom := ptBotRtPane.v;
 END;
 END;
VisObox(oboxPane);
EraseRect(r);
--- *)
tyterm := TytermUpdateRec(hcsruler^^.orecCon, iimgpScrn, FALSE);
{ rec := POINTER(ORD(dsp) + hcsruler^^.orecCon); }
IcsRulerCreate := ics;
{$ifc fDbgOk}
IF fTstRuler THEN
     BEGIN
     WRITELN('IcsRulerCreate : ', ics);
     PxHcsruler(POINTER(ORD(hcsruler)));
     END;
{$endc}
999:
END;


{$S LWStyle}
{----------------------------------------------------}
PROCEDURE DoParFop { (ifld: TC; sval: TW; pval: TPc) };
{----------------------------------------------------}
LABEL 999;
VAR achad: TAchad; lpFst, lpLim: TLp;
 ics: TB; pint: TPint; fCaret: TF;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF selCur.oint = ointNil THEN GOTO 999;
pint := POINTER(ORD(lldInt) + selCur.oint);
lpLim := pint^.lpLim;
ics := pint^.ics;
fCaret := (pint^.lpFst = lpLim);
IF fCaret THEN RemoveKid(TRUE);
achad.rgch := NIL; achad.ichFst := 0; achad.ichLim := 1;
SetLpd(lpdStd, ics, pint^.lpFst, tysetBnds, achad);
lpFst := lpdStd^.lpFstPar;
IF lpLim > lpdStd^.lpLimPar THEN
    BEGIN
    achad.rgch := NIL; achad.ichFst := 0; achad.ichLim := 1;
    SetLpd(lpdStd, ics, lpLim - 1, tysetBnds, achad);
    END;
lpLim := lpdStd^.lpLimPar;
ApplyFopEd(ics, lpFst, lpLim, ifld, sval, pval);
IF NOT fCaret THEN IF rghcs^[ics]^^.tycs = tycsEd
    THEN LSetSel(ics, lpFst, lpLim);
999:
END;


{$S LWMargin}
{----------------------------------------------------------------------------}
PROCEDURE ApplyRuler { (ifld: TC; sval: TC; fDecimalComma: TF; icsRuler: TB) };
{----------------------------------------------------------------------------}
LABEL 77,88,99;
VAR hcsruler: THcsruler;
    tabVal: RECORD x, xOrig: TX; END;
    svalT: RECORD CASE BOOLEAN OF TRUE: (sval: 0..3); FALSE: (quad: TQuad); END;
    tbd: TTbd;
    itb: TC; irm: TC;
    ratT: TRat; cmarkMac:   TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcsruler := POINTER(ORD(rghcs^[icsRuler]));
tabVal.x := hcsruler^^.argrm[irmPt].ptHot.h;
WITH argmarkd[hcsruler^^.tyrlu] DO
    cmarkMac := argcmarkPerUnit[imarkMac - 1];
tabVal.x := VhNearestMark(tabVal.x, 0, MAXINT, hcsruler^^.tyrlu,
                          cmarkMac, tyvhH, ratT);
CASE ifld OF
   ifldXtb:    BEGIN
               IF (tabVal.x > hcsruler^^.argrm[irmRMarg].ptHot.h) OR
                  (tabVal.x < CMin(hcsruler^^.argrm[irmFMarg].ptHot.h,
                                hcsruler^^.argrm[irmLMarg].ptHot.h))
                  THEN GOTO 99;
               FOR irm := irmTabFst TO hcsruler^^.irmLim-1 DO
                   {Allow redefinition of existing tab but prohibit placement of
                    new tab within dxMinTab of any existing tab }
                   IF (tabVal.x > (hcsruler^^.argrm[irm].ptHot.h-dxMinTab)) AND
                      (tabVal.x < (hcsruler^^.argrm[irm].ptHot.h+dxMinTab)) AND
                      (tabVal.x <> hcsruler^^.argrm[irm].ptHot.h)
                   THEN GOTO 99;
               tbd.x := tabVal.x;
               svalT.sval := sval;
               tbd.quad := svalT.quad;
               tbd.fDecimalComma := fDecimalComma;
               tbd.tyfill := tyfillNil;
               DoParFop(ifldXtb, 0, @tbd);
               GOTO 99;
               END;
   ifldMovTb:  BEGIN
               IF hcsruler^^.argrm[irmMoving].ptHot.h = xOrigMoving
                   THEN GOTO 99;
               tabVal.xOrig := xOrigMoving;
               END;
   ifldFilTb,
   ifldClrTb:  BEGIN
               FOR itb := irmTabFst TO hcsruler^^.irmLim-1 DO
                   IF hcsruler^^.argrm[itb].ptHot.h = tabVal.x THEN GOTO 77;
               GOTO 88;  {Not on tab stop; exit}
               77:
               END;
   END;
IF fTstRuler THEN WRITELN('tabVal: x:', tabVal.x:4, '; -.xOrig:', tabVal.xOrig:4);
DoParFop(ifld, sval, @tabval);
99:
IF ifld IN [ ifldXtb, ifldMovTb, ifldClrTb, ifldFilTb ] THEN
    SelToRuler(icsRuler, orecNil, FALSE, TRUE);
88:
END; {ApplyRuler}


{$S LWMScroll}
{---------------------------------------------------}
PROCEDURE FindLpRulerFixed { (ics, lp, VAR lpFixed) };
{---------------------------------------------------}
VAR hcsruler:   THcsruler;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcsruler := POINTER(ORD(rghcs^[ics]));
IF hcsruler^^.tyRuler = tyrulMargTab THEN lpFixed := 0
ELSE  FindLpPgFixed(ics, lp, lpFixed);
END;

{---------------------------------------}
PROCEDURE GenCrdRuler { (crd: TCrd; ics, lp, tyxy) };
{---------------------------------------}
VAR hcsruler: THcsruler; lpLim: TLp; lpOrLppg: TLpOrLppg;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstRuler THEN WRITELN('GenCrdRuler.');
crd^.arec.strec.setfixed := fixedR+fixedLpFst;
crd^.arec.tyxy := tyxyScrn;
crd^.tyxy := tyxyScrn;
hcsruler := POINTER(ORD(rghcs^[ics]));

{ move crd^.arec.r to (0,0) }
IF hcsruler^^.tyRuler = tyrulMargTab THEN
     BEGIN
     WITH hcsruler^^.dptWidHt DO SetRect(crd^.arec.r, 0, 0, h, v);
     lp := CMin(lp, 1);
     lpLim := CMin(lp+1, 1);
     END
ELSE BEGIN
     WITH hcsruler^^.dptWidHt DO SetRect(crd^.arec.r, 0, 0, h, v+1);
     lpOrLppg.lp := lp;
     IF NOT FEosLpPg(hcsruler^^.icsPg, lp) THEN
         BEGIN
         lpOrLppg.lppg.ipg := lpOrLppg.lppg.ipg + 1;
         lpOrLppg.lppg.ptpg := 0; lpOrLppg.lppg.ich := 0;
         END;
     lpLim := lpOrLppg.lp;
     END;
crd^.arec.dlpLim := lpLim-lp;
crd^.tyloc := tylocLstSib;
crd^.arec.ointDep := OintMark(crd^.arec.ointDep, ics, lp, lpLim, TRUE, ointNil);
END;

{-----------------------------------}
PROCEDURE GenImgRuler { (crd: TCrd) };
{-----------------------------------}
VAR hcsruler: THcsruler; pint: TPint; orec: TC; rec: TRec;
    r,rInset: TR; f: TF;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
pint := POINTER(ORD(lldInt) + crd^.arec.ointDep);
hcsruler := POINTER(ORD(rghcs^[pint^.ics]));
orec := crd^.orec;
IF fTstRuler THEN
     WRITELN('GenImgRuler - crd^.orec:', orec:4);
IF FClipOrec(orec) THEN
     BEGIN
     TextFont(p15tile);  TextFace([]);
     rec := POINTER(ORD(dsp)+orec);
     r := crd^.arec.r; { ConvertRTyxy(rec^.r, r, rec^.tyxy, tyxyScrn); }
     EraseRect(r); FrameRect(r);
     rInset := r; InsetRect(rInset, 1, 1);
     f := FClipR(rInset, orec);
     {$ifc fDbgOk}
     IF fTstRuler THEN PxR('rRuler: ', r);
     {$endc}
     CASE hcsruler^^.tyRuler OF
       tyRulMargTab:
          BEGIN
          DrawRuler(hcsruler, r);
          rec := POINTER(ORD(dsp) + orec);
          pint := POINTER(ORD(lldInt) + rec^.ointDep);
          hcsruler^^.irmLim := 1;
          SelToRuler(pint^.ics, orec, FALSE, FALSE);
          END;
       tyRulPage:
          BEGIN
          DrawRuler(hcsruler, r);
          PgdToRuler(hcsruler, orec);
          END;
       END;
     END;
END;


{$S LWMargin}
{----------------------------------------------------}
PROCEDURE DrawIrmMoving(hcsruler: THcsruler; pt: TPt);
{----------------------------------------------------}
VAR rec: TRec; ptHotNew: TPt; orec: TC; rm: TRm;
    rgrm: TRgrm; tyRuler: TTyRuler;
    dxMin, dxMac, dyMin, dyMac: TCd;
    ratT: TRat; cmarkMac:   TC;
    irm: TC; dh: TX;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tyRuler := hcsruler^^.tyRuler;
rgrm := @hcsruler^^.argrm;
WITH argmarkd[hcsruler^^.tyrlu] DO
    cmarkMac := argcmarkPerUnit[imarkMac - 1];
CASE tyRuler OF
 tyRulMarTab:
      BEGIN
      CASE irmMoving OF
        irmPt:
             BEGIN
             dxMac := hcsruler^^.dptWidHt.h;
             dxMin := 0;
             END;
        irmRMarg:
             BEGIN
             dxMac := hcsruler^^.dptWidHt.h;
             dxMin := CMax(rgrm^[irmLMarg].ptHot.h, rgrm^[irmFMarg].ptHot.h)
                      + dhRmStd;
             IF irmTabFst < hcsruler^^.irmLim THEN
                  dxMin := CMax(dxMin, rgrm^[hcsruler^^.irmLim - 1].ptHot.h);
             END;
        irmLMarg, irmFMarg:
             BEGIN
             IF irmTabFst < hcsruler^^.irmLim THEN
                  CASE irmMoving OF
                  irmLMarg: IF rgrm^[irmFMarg].ptHot.h <= rgrm^[irmTabFst].ptHot.h
                            THEN dxMac := rgrm^[irmRMarg].ptHot.h - dhRmStd
                            ELSE dxMac := rgrm^[irmTabFst].ptHot.h;
                  irmFMarg: IF rgrm^[irmLMarg].ptHot.h <= rgrm^[irmTabFst].ptHot.h
                            THEN dxMac := rgrm^[irmRMarg].ptHot.h - dhRmStd
                            ELSE dxMac := rgrm^[irmTabFst].ptHot.h;
                  END
             ELSE dxMac := rgrm^[irmRMarg].ptHot.h - dhRmStd;
             dxMin := 0;
             END;
        OTHERWISE
             BEGIN
             IF irmMoving  = irmTabFst THEN
                  dxMin := CMin(rgrm^[irmLMarg].ptHot.h, rgrm^[irmFMarg].ptHot.h)
             ELSE dxMin := rgrm^[irmMoving-1].ptHot.h + dxMinTab;
             dxMac := rgrm^[irmMoving].ptHot.h - 0
               + (rgrm^[irmRMarg].ptHot.h - rgrm^[hcsruler^^.irmLim - 1].ptHot.h);
             END;
        END;
      pt.h := VhNearestMark(pt.h, dxMin, dxMac, hcsruler^^.tyrlu,
                            cmarkMac, tyvhH, ratT);
      pt.v := hcsruler^^.argrm[irmMoving].ptHot.v;
      END;
 tyRulPage:
      BEGIN
      IF irmMoving > irmHdr THEN
          dyMin := rgrm^[irmMoving - 1].ptHot.v + dhMinDistance
      ELSE dyMin := 0;
      IF irmMoving < irmFtr THEN
          dyMac := rgrm^[irmMoving + 1].ptHot.v - dhMinDistance
      ELSE dyMac := hcsruler^^.dptWidHt.v;
      pt.v := VhNearestMark(pt.v, dyMin, dyMac, hcsruler^^.tyrlu,
                            cmarkMac, tyvhV, ratT);
      pt.h := hcsruler^^.argrm[irmMoving].ptHot.h;
      END;
  END;
SetRulerClip(hcsruler^^.orecCon);
rec := POINTER(ORD(dsp) + hcsruler^^.orecCon);
orec := rec^.orecSon;
ptHotNew := pt;
rm := rgrm^[irmMoving];
dh := ptHotNew.h - rm.ptHot.h;
IF (ptHotNew.h <> rm.ptHot.h) OR (ptHotNew.v <> rm.ptHot.v) THEN
    WHILE orec <> orecNil DO
       BEGIN
       hcsruler^^.argrm[irmMoving] := rm;
       IF (tyRuler = tyRulMarg) AND (irmMoving <> irmPt) THEN
           BEGIN
           IF irmMoving >= irmTabFst THEN
                {Moving a tab}
                BEGIN
                IF ptHotNew.h > rm.ptHot.h THEN
                     {Moving to the right, draw tabs from right to left}
                     BEGIN
                     FOR irm := hcsruler^^.irmLim - 1 DOWNTO irmMoving + 1 DO
                          BEGIN
                          pt := hcsruler^^.argrm[irm].ptHot;
                          pt.h := pt.h + dh;
                          DrawRm(irm, pt, hcsruler, orec);
                          END;
                     DrawRm(irmMoving, ptHotNew, hcsruler, orec);
                     FOR irm := irmMoving - 1 DOWNTO irmTabFst DO
                          DrawRm(irm, hcsruler^^.argrm[irm].ptHot, hcsruler, orec);
                     END
                ELSE
                     {Moving to the left, draw tabs left to rignt}
                     BEGIN
                     FOR irm := irmTabFst TO irmMoving - 1 DO
                          DrawRm(irm, hcsruler^^.argrm[irm].ptHot, hcsruler, orec);
                     DrawRm(irmMoving, ptHotNew, hcsruler, orec);
                     FOR irm := irmMoving+1 TO hcsruler^^.irmLim - 1 DO
                          BEGIN
                          pt := hcsruler^^.argrm[irm].ptHot;
                          pt.h := pt.h + dh;
                          DrawRm(irm, pt, hcsruler, orec);
                          END;
                     END;
                END
           ELSE
               {Moving a margin}
               DrawRm(irmMoving, ptHotNew, hcsruler, orec);
           ptHotNew.v := vPt; DrawRm(irmPt, ptHotNew, hcsruler, orec);
           END
       ELSE
           {Moving the point or page ruler icon}
           DrawRm(irmMoving, ptHotNew, hcsruler, orec);
       rec := POINTER(ORD(dsp) + orec);
       orec := rec^.orecSib;
       END;
{The point must track the margin icons}
rm := rgrm^[irmPt];
IF (tyRuler = tyRulMarg) AND (ptHotNew.h <> rm.ptHot.h) AND (irmMoving <> irmPt)
THEN BEGIN
     ptHotNew.v := vPt;
     DrawRm(irmPt, ptHotNew, hcsruler, orec);
     END;
END;

{------------------------------------------}
PROCEDURE MoveRm { (pt: TPt; icsRuler: TB) };
{------------------------------------------}
 { pt is a tyxyScrn }
VAR orec, orecMin: TC; rec: TRec; oMin: TC; irm, irmMin: TC;
    rT: TR; bm: BitMap; hcsruler: THcsruler;
    ptHotNew, ptT: TPt; tyRuler: TTyRuler;
    oNear: TC;

    PROCEDURE CalcONear;
    VAR cmarkPerUnit: TC;
    BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
    hcsruler := POINTER(ORD(rghcs^[icsRuler]));
    WITH argmarkd[hcsruler^^.tyrlu] DO
        cmarkPerUnit := (ratUnitsPerInch.num * argcmarkPerUnit[imarkMac-1])
                        DIV ratUnitsPerInch.denom;
    oNear := argptInch[tyxyScrn].h DIV (cmarkPerUnit * 2);
    END; {CalcONear}

    PROCEDURE MinDiff(cBase, c, irm: TC; orec: TC);
    VAR o: TC;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    IF fTstRuler THEN WRITELN('MinDiff - cBase:',cbase,',c:',c:3,',irm:',irm:2);
    o := ABS(cBase - c);
    IF (o < oMin) AND (o < oNear) THEN
         BEGIN oMin := o; irmMin := irm; orecMin := orec; END;
    END;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
hcsruler := POINTER(ORD(rghcs^[icsRuler]));
rec := POINTER(ORD(dsp) + hcsruler^^.orecCon);
oMin := MAXINT;
irmMin := irmNil;
tyRuler := hcsruler^^.tyRuler;
CalcONear;
CASE tyRuler OF
  tyRulMarTab:
     BEGIN
     orec := rec^.orecSon;
     SubPt(rec^.r.topLeft, pt);
     IF pt.v < oyBotRuler THEN
          BEGIN irmMin := irmPt; orecMin := orec; END
     ELSE IF pt.v < oyTopRmFMarg THEN
          FOR irm := irmTabFst TO hcsruler^^.irmLim-1
               DO MinDiff(pt.h, hcsruler^^.argrm[irm].ptHot.h, irm, orec)
     ELSE IF pt.v < oyTopRmMarg THEN
          MinDiff(pt.h, hcsruler^^.argrm[irmFMarg].ptHot.h, irmFMarg, orec)
     ELSE FOR irm := irmMargFst TO irmTabFst-1
          DO MinDiff(pt.h, hcsruler^^.argrm[irm].ptHot.h, irm, orec);
     END;
  tyRulPage:
     BEGIN
     orec := rec^.orecSon;
     IF orec = orecNil THEN Break(687);
     WHILE orec <> orecNil DO
         BEGIN
         rec := POINTER(ORD(dsp) + orec);
         ptT := pt;
         SubPt(rec^.r.topLeft, ptT);
         FOR irm := irmPgFst TO irmMaxPg-1 DO
              MinDiff(ptT.v, hcsruler^^.argrm[irm].ptHot.v, irm, orec);
        orec := rec^.orecSib;
        END;
     {make pt rec relative}
     rec := POINTER(ORD(dsp) + orecMin);
     SubPt(rec^.r.topLeft, pt);
     END;
  END; { case }
irmMoving := irmMin;
IF irmMoving <> irmNil THEN
     BEGIN
     orecMoving := orecMin;
     xOrigMoving := hcsruler^^.argrm[irmMoving].ptHot.h;
     DrawIrmMoving(hcsruler, pt);
     END;
IF fTstRuler THEN WRITELN('irmMoving:',irmMoving);
END;

{----------------------------------------------------------}
PROCEDURE MovingRm { (pt: TPt; icsRuler: TB; oboxPane: TC) };
{----------------------------------------------------------}
 { pt is a tyxyScrn }
VAR rec: TRec; hcsruler: THcsruler;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF irmMoving = irmNil THEN MoveRm(pt, icsRuler);
IF irmMoving <> irmNil THEN
    BEGIN
    hcsruler := POINTER(ORD(rghcs^[icsRuler]));
    { rec := POINTER(ORD(dsp) + hcsruler^^.orecCon); }
    { move only if mouse still in ruler's pane }
    IF oboxPane = OboxOfOrec(hcsruler^^.orecCon) THEN
        BEGIN
        rec := POINTER(ORD(dsp) + orecMoving);
        SubPt(rec^.r.topLeft, pt);
        DrawIrmMoving(hcsruler, pt);
        END;
    END;
END;

{-----------------------------------------------}
PROCEDURE MovedRm { (ointSel: TC; icsRuler: TB) };
{-----------------------------------------------}
VAR sval, ifld: TC; orec, orecCon: TC; pint: TPint; pbox: TPbox;
    rec: TRec; dy, vHot, hDummy: TCd;
    hcsedBody: THcsed; hcspg: THcspg; hcsruler: THcsruler;
    icsBody, icsPg: TB;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF irmMoving <> irmNil THEN
    BEGIN
    hcsruler := POINTER(ORD(rghcs^[icsRuler]));
    IF hcsruler^^.tyRuler = tyRulMargTab THEN
         BEGIN
         IF irmMoving <> irmPt THEN
             BEGIN
             sval := 0;
             CASE irmMoving OF
               irmFMarg: ifld := ifldXLFst;
               irmLMarg: ifld := ifldXLBody;
               irmRMarg: ifld := ifldXRt;
               OTHERWISE ifld := ifldMovTb;
               END;
             ApplyRuler(ifld, sval, FALSE, icsRuler);
             END;
         END
    ELSE IF hcsruler^^.tyRuler = tyRulPage THEN
         BEGIN
         pbox := PboxFromObox(hcsruler^^.oboxPane);
         orecCon := pbox^.refCon;
         rec := POINTER(ORD(dsp) + orecCon);
         WHILE rec^.orecSib <> orecNil DO
             BEGIN
             orecCon := rec^.orecSib;
             rec := POINTER(ORD(dsp) + orecCon);
             END;
         pint := POINTER(ORD(lldInt) + rec^.ointDep);
         icsPg := pint^.ics;
         hcspg := POINTER(ORD(rghcs^[icsPg]));
         IF hcspg^^.cs.tycs <> tycsPg THEN Break(33);
         vHot := hcsruler^^.argrm[irmMoving].ptHot.v;
         WITH hcspg^^.pgd.pglp DO
             BEGIN
             ConvertTyxy(hDummy, vHot, tyxyScrn, tyxy);
             CASE irmMoving OF
               irmHdr:
                  BEGIN
                  dy := vHot - yTopHdr;
                  yTopHdr := yTopHdr + dy;
                  dyHdr := dyHdr - dy;
                  END;
               irmTop:
                  BEGIN
                  dy := vHot - (yTopHdr + dyHdr);
                  dyHdr := dyHdr + dy;
                  dyHtBody := dyHtBody - dy;
                  dyBotBody := dyBotBody - dy;
                  END;
               irmBot:
                  BEGIN
                  dy := vHot - (yTopHdr + dyHdr + dyBotBody);
                  dyBotBody := dyBotBody + dy;
                  END;
               irmFtr:
                  BEGIN
                  dy := vHot - (yTopHdr + dyHdr + dyHtBody);
                  dyHtBody := dyHtBody + dy;
                  END;
               END;
             END;
         AdjustLps(icsPg, 0, lpMax, 0);
         icsBody := hcspg^^.pgd.icsBody;
         hcsedBody := POINTER(ORD(rghcs^[icsBody]));
         IF hcsedBody^^.cs.tycs = tycsEd THEN
              hcsedBody^^.pglp := hcspg^^.pgd.pglp;
         AdjustLps(icsBody, 0, lpMax, 0);   { This will re-establish
                                              page boundaries }
         END;
    END;
END;

{$S LWCreate}
{------------------}
PROCEDURE InitRuler;
{------------------}
VAR tyCsrT: TTyCsr;
    strRlU: STRING[1];
    chRlU: TCh;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
GetAlert(Wpalerts, 101, @strRlU);
chRlU := ORD(strRlU[1]);
IF chRlU = ORD('E') THEN tyrluDefault := tyrluEnglish
   ELSE IF chRlU = ORD('M') THEN tyrluDefault := tyrluMetric
      ELSE Break(670);

tyrluCurrent := tyrluDefault;
SetRect(rRmStd, 0, 0, dhRmStd, dvRmStd);
bmRmSave.bounds := rRmStd;
bmRmSave.rowBytes := 4;
bmRmSave.baseAddr := @csrSave;
ptOffScreen.h := MAXINT; ptOffScreen.v := MAXINT;
{$ifc fDbgOk}
IF fTstRuler THEN PxBm('bmRmStd',bmRmSave);
{$endc}

WITH argmarkd[tyrluEnglish] DO
 BEGIN
 ratUnitsPerInch.c := 0; ratUnitsPerInch.num := 1; ratUnitsPerInch.denom := 1;
 imarkMac := 4;
 argcmarkPerUnit[0] := 1; argvhWidHt[0] := 13;
 argcmarkPerUnit[1] := 2; argvhWidHt[1] := 7;
 argcmarkPerUnit[2] := 4; argvhWidHt[2] := 4;
 argcmarkPerUnit[3] := 8; argvhWidHt[3] := 2;
 END;
WITH argmarkd[tyrluMetric] DO
 BEGIN
 ratUnitsPerInch.c := 0; ratUnitsPerInch.num := 254; ratUnitsPerInch.denom :=
 100;
 imarkMac := 2;
 argcmarkPerUnit[0] := 1; argvhWidHt[0] := 13;
 argcmarkPerUnit[1] := 5; argvhWidHt[1] := 4;
 END;

argPropOftyCsr[tyCsrPt].ch         := CHR(160);
argPropOftyCsr[tyCsrLMarg].ch      := CHR(151);
argPropOftyCsr[tyCsrRMarg].ch      := CHR(152);
argPropOftyCsr[tyCsrFMarg].ch      := CHR(150);
argPropOftyCsr[tyCsrLTab].ch       := CHR(162);
argPropOftyCsr[tyCsrRTab].ch       := CHR(164);
argPropOftyCsr[tyCsrCTab].ch       := CHR(163);
argPropOftyCsr[tyCsrDPTab].ch      := CHR(165);
argPropOftyCsr[tyCsrDCTab].ch      := CHR(166);
argPropOftyCsr[tyCsrTop].ch        := CHR(154);
argPropOftyCsr[tyCsrBot].ch        := CHR(155);
argPropOftyCsr[tyCsrHdr].ch        := CHR(153);
argPropOftyCsr[tyCsrFtr].ch        := CHR(156);

FOR tyCsrT := tyCsrPt TO tyCsrFtr DO
   BEGIN
   argPropOfTyCsr[tyCsrT].ptHotDiff.h := 0 ;
   argPropOfTyCsr[tyCsrT].ptHotDiff.v := 0 ;
   END;

argPropOftyCsr[tyCsrPt].ptHotDiff.h         := 11;
argPropOftyCsr[tyCsrRMarg].ptHotDiff.h      := 23;
argPropOftyCsr[tyCsrLTab].ptHotDiff.h       := 11;
argPropOftyCsr[tyCsrRTab].ptHotDiff.h       := 11;
argPropOftyCsr[tyCsrCTab].ptHotDiff.h       := 11;
argPropOftyCsr[tyCsrDPTab].ptHotDiff.h      := 11;
argPropOftyCsr[tyCsrDCTab].ptHotDiff.h      := 11;
argPropOftyCsr[tyCsrBot].ptHotDiff.v        := 15;
argPropOftyCsr[tyCsrFtr].ptHotDiff.v        := 15;

END (* InitRuler *);

END.




ÿ