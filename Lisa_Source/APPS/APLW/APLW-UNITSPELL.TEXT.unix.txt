{$I APLW/COMPFLAGS }                                            {gdf 1/16/84}
{$R-}

UNIT UnitSpell;

(* Copyright 1983, 1984, Apple Computer Inc. *)

{ gdf  3/1/84 -- insert trace calls for segmentation  }

INTERFACE

USES
     {$IFC sampcalls}                                               {gdf 2/24/84}
        {$U aplw/tracecalls.obj} tracecalls,
     {$ENDC}
     {$U Obj:UnitStd.Obj  }  UnitStd,
     {$U Obj:UnitHz.Obj   }  UnitHz,
     {$U LibOS/Syscall.Obj }   Syscall,
     {$U Obj:UnitFile.Obj }  UnitFile,
     {$U Obj:Storage.Obj  }  Storage,
     {$U Obj:QuickDraw.Obj }  QuickDraw,
     {$U Obj:FontMgr.Obj  }  FontMgr,
     {$U Obj:PmDecl       }  PmDecl,
     {$IFC fPrintOld}                                               {gdf 1/16/84}
        {$U Obj:PrStd.Obj }     PrStd,
     {$ELSEC}
        {$U Obj:PrStdInfo.Obj } PrStdInfo,
          (* {$U Obj:PrPublic.Obj }  PrPublic,  unneeded ? *)
     {$ENDC}                                                        {gdf 1/16/84}
     {$U Obj:UnitFmt.Obj  }  UnitFmt,
     {$U Obj:UnitCs.Obj   }  UnitCs,
     {$U Obj:UnitFf.Obj   }  UnitFf,
     {$U Obj:Wm.Events.Obj } Events,
     {$U Obj:Wm.Folders.Obj} Folders,
     {$U Obj:Wm.Menus.Obj }  Menus,
     {$U Obj:WmlStd       }  WmlStd,
     {$U Obj:Filercomm    }  Filercomm,
     {$U Obj:AlertMgr.Obj }  AlertMgr,
     {$U IntrLib.Obj      }  International,
     {$u hwInt.obj }              hwInt,
     {$U ApLW/Queue.Obj    }  Queue,
     {$U ApLW/UnitBox.Obj  }  UnitBox,
     {$U ApLW/BoxScid.Obj }  BoxScid,
     {$U ApLW/UnitFolder.Obj}  UnitFolder,
     {$U ApLW/UnitRec.Obj  }  UnitRec,
     {$U ApLW/UnitOver.Obj }  UnitOver,
     {$U ApLW/UnitTld.Obj  }  UnitTld,
     {$U ApLW/UnitUs.Obj   }  UnitUs,
     {$U ApLW/UnitEd.Obj   }  UnitEd,
     {$U ApLW/UnitEdit.Obj }  UnitEdit,
     {$U ApLW/UnitFm.Obj   }  UnitFm,
     {$U ApLW/UnitKid.Obj  }  UnitKid,
     {$U ApLW/UnitDsp.Obj  }  UnitDsp,
     {$U ApLW/UnitSel.Obj  }  UnitSel,
     {$U ApLW/UnitRuler.Obj}  UnitRuler,
     {$U ApLW/UnitScrap.Obj}  UnitScrap,
     {$U ApLW/UnitCom.Obj  }  UnitCom,
     {$U ApLW/Dmgr.Obj     }  Dmgr,
     {$U ApLW/UnitLDialog.Obj}  UnitLDialog,
     {$u aplw/sp/spelling.obj }    spelling,
     {$u aplw/sp/verify.obj }      SpVerify,
     {$u aplw/sp/correct.obj }     SpCorrect,
     {$U ApLW/EventMgr.Obj }  EventMgr;

CONST
{$IFC NOT fDbgOk}
   fTstSpell = FALSE; {Debug flag}
   fTstHeap = FALSE; {Debug flag}
   fTime = false; {ditto}
{$ENDC}
   butnOK = 2;       {Buttons in the dialog box(es)}
   butnShowMore = 3;
   butnReplace = 4;
   butnRNext = 5;
   butnHide = 6;


VAR
  {$IFC fDbgOk} fTstSpell: TF; {$ENDC}
  {$IFC fDbgOk} fTstHeap: TF; {$ENDC}
  fMoreToQ: TF;  {TRUE iff there are more events to be queued up}

PROCEDURE DoSpellImid (imid: TC; orecActive: TC);
PROCEDURE EndGuessDbox (butnItm: Integer);
PROCEDURE NQMore;
PROCEDURE SetHzSpell (hz: Thz);
PROCEDURE UndoPutDict(fUndoUndo: TF);
PROCEDURE UndoRmvDict(fUndoUndo: TF);

IMPLEMENTATION


{$IFC fSymOK }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }
{$R-}

CONST
nameOfUserDictionaryFile = '{t1}userDict.data';
guessesMax = 12;  {Max. no. of guesses in dialog box}
oneColGuessesMax = 6; {Max. no. of guesses if only one column in dialog box}
cChCol1Narrow = 20;  {If no guess in the first column has more than cChCol1Narrow
                      characters, then there is room for a second column.}
cCkBGuess = 1; {Count of check box groups for the Guesses dialog box}
cCkBPlain = 1; {Count of check box groups for the Plain dialog box}
btnsLim = 5; {Buttons defined in phrase file range from 0 to btnsLim}
ichMaxSpell = 127; {achadSpell's buffer for characters ranges from 0..ichMaxSpell}
maxDStrLen = 49;   {max length of a word to display in the dialog box
                    (before possible period added)
                     NOTE: maxDStrLen must be greater then maxWordLength,
                     defined in sp/spelling, and less then maxCharsStr
                     defined in dmgr.}
maxParamLen = 40;  {Max. length of a param for ParamAlert}
spLsdn = 9;        {FIX LATER.  Data segment for Personal Dictionary.}
retCancel = 1;     {Index of the Cancel button for the Ask Alerts}
chRealHyphen = 208;{Ascii for a real hyphen char: <OPTION> <MINUS>}
chSpace = 32;      {Ascii for <SPACE>}
chBs = 8;          {Ascii for <BACKSPACE>}
waitTime = 8000;   {How many milliseconds to wait until putting up a wait alert
                    for Find Misspelling}


(*
TYPE
*)

VAR
spellInitialized: TF;      {TRUE after startSpelling has been called succesfully.}
hzSpell: THz;              {The hz for the Spelling Checker}
orecToScroll: TC;          {The orec that should be scrolled to show a new
                            selection}
curHCkForm: TCkFormHnd;    {The current ckForm that is showing, if any.}
HGuessCkForm: TCkFormHnd;  {The check form for the Guesses dialog box}
HShowMore: TCkBoxHnd;      {Description of the set of buttons for Guesses
                            dialog box that includes the Show More button}
HJustHide: TCkBoxHnd;      {Description of the set of buttons for Guesses
                            dialog box that includes just the Hide button}
curHBtnGrp: TCkBoxHnd;     {The set of buttons currently attached to HGuessCkForm}
HMReturn: TSpReturn;       {Return code from H-M's spelling routines}
newWord: TSpWord;          {The latest word that we are checking or correcting}
guessNum: integer;         {The number of the next guess that the spelling checker
                            will make for the current word.}
pintSel: TPint;            {Pointer to interval for selection}
achadSpell: TAchad;        {achad used for finding words}
aRgChSpell: ARRAY [0..ichMaxSpell] of TCh;  {Part of achadSpell}
tyset: TTyset;             {tyset used for setlpd's and seqlpd's}
curMaxGuesses: integer;    {Max no. of guesses that will fit in the dialog box
                            that is up now.}
rightOfWideCol: integer;   {Right boundary of hit boxes for first column in
                            dialog box when it's wide.}
rightOfNarrowCol: integer; {Right boundary of hit boxes for first column in
                            dialog box when it's narrow.}
cDboxes: TC;               {No. of dialog boxes that we've produced to show all
                            of the guesses for this word.}
byteNum: LongInt;          {Location of the next word to get from the Personal
                            Dictionary to write to the document.}
retStr: string[2];         {String that contains the character <RETURN>}
PRetStr: TStrPtr;          {Pointer to retStr}
HRetStr: TStrHnd;          {Handle to retStr}
tabStr: string[2];         {String that contains the character <TAB>}
PTabStr: TStrPtr;          {Pointer to tabStr}
HTabStr: TStrHnd;          {Handle to tabStr}
spaceStr: string[2];       {String that contains the character <SPACE>}
PSpaceStr: TStrPtr;        {Pointer to spaceStr}
HSpaceStr: TStrHnd;        {Handle to spaceStr}
backStr: string[2];        {String that contains the character <BACKSPACE>}
PBackStr: TStrPtr;         {Pointer to backStr}
HBackStr: TStrHnd;         {Handle to backStr}
paramStr: TParamAlert;     {string passed as parameter to ParamAlert}
hyphenStr: string[1];      {string with a single char hyphen in it}
fAbortCmd: TF;             {TRUE iff user typed APPLE-period}
fWaitAlertUp: TF;          {TRUE iff a wait alert is up now}
beginTime: Milliseconds;   {Time when interruptible command began}
wInfo: WindowInfo;         {Param for GetWindInfo - to determine if an alert is up}
lastLpFstWd,
lastLpLimWd: TLp;          {lp's for the last word selected by Suggest Corrections}
lastString: TParamAlert;   {Last word selected by Suggest Corrections}
fSetTabs: TF;              {True iff NQMore still needs to set the tabs before
                            enqueuing more characters.}
{$IFC fDbgOk}
mTime: Microseconds;       {TEMPORARY for timing}
fTime: TF;                 {TEMPORARY for timing}
{$ENDC}


{$ifc fDbgOk}
{$S LWUSpell}
{$elsec}
{$S LWSpell}
{$endc}

{-------------------------------------------------}
PROCEDURE ReplacSpaces(chad:TChad);
{-------------------------------------------------}
{Scan chad^.rgch^ from ichFst to ichLim, replacing any non-breaking spaces
 with regular spaces.  (Because spelling treats the two spaces alike but
 double-click and line-layout don't).}
CONST
   noBrkSpace = -54;
VAR
   scanIch: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH chad^ DO
   BEGIN
   IF FALSE THEN writeln('ReplacSpaces: ichFst = ', ichFst, ' and ichLim = ',
                             ichLim);
   FOR scanIch := ichFst TO ichLim-1 DO
      IF (rgch^[scanIch] = noBrkSpace) THEN
         BEGIN
         rgch^[scanIch] := chSpace;
         IF FALSE THEN writeln('Non-breaking space found at ich = ',
                                   scanIch)
         END;
   END;
END;



{-----------------------------------------}
FUNCTION SLpFstPWd (ics: TB; lp: TLp) : TLp;
{-----------------------------------------}
{Exactly the same as LpFstPWd in UnitKid EXCEPT that non-breaking spaces are
 treated just like regular spaces here.}
LABEL
   1;
CONST
   fBackward=TRUE;  fForward=FALSE;
   ichLeft=0;  ichThis=1;  ichRight=2;
VAR
   lpLeft,lpThis,lpRight: TLp;
   achad: TAchad;
   argch: ARRAY[ichLeft..ichRight] OF TCh;
   ich: TC;
BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   achad.rgch := @argch;
   {Characters that don't exist act as blanks}
   FOR ich:=ichLeft TO ichRight DO argch[ich] := ORD(' ');

   {Get the character at the insertion point}
   achad.ichFst := ichRight;  achad.ichLim := achad.ichFst+1;
   lpRight  := LpVisAdjacent(ics, lp-1, fForward, achad);

   {Get the character to the LEFT of the insertion point}
   achad.ichFst := ichThis;  achad.ichLim := achad.ichFst+1;
   lpThis  := LpVisAdjacent(ics, lp, fBackward, achad);

   {Get the second character to the LEFT of the insertion point}
   achad.ichFst := ichLeft;  achad.ichLim := achad.ichFst+1;
   lpLeft  := LpVisAdjacent(ics, lpThis, fBackward, achad);

   {find first qualifying position to left of selection}
   WHILE lpLeft < lpThis DO
      BEGIN
      achad.ichFst := ichLeft;  achad.ichLim := ichRight+1;
      ReplacSpaces(@achad);
      IF FQualifies(@achad, ichThis) THEN GOTO 1;
      achad.rgch^[ichRight] := achad.rgch^[ichThis];
      lpRight := lpThis;
      achad.rgch^[ichThis]  := achad.rgch^[ichLeft];
      lpThis  := lpLeft;
      achad.rgch^[ichLeft]  := ORD(' ');
      {Get the next character to the LEFT}
      achad.ichFst := ichLeft;  achad.ichLim := achad.ichFst+1;
      lpLeft  := LpVisAdjacent(ics, lpLeft, fBackward, achad);
      END;
1:
   REPEAT {find beginning of word}
      achad.rgch^[ichRight] := achad.rgch^[ichThis];
      lpRight := lpThis;
      achad.rgch^[ichThis]  := achad.rgch^[ichLeft];
      lpThis  := lpLeft;
      achad.rgch^[ichLeft]  := ORD(' ');
      {Get the next character to the LEFT}
      achad.ichFst := ichLeft;  achad.ichLim := achad.ichFst+1;
      lpLeft  := LpVisAdjacent(ics, lpLeft, fBackward, achad);
      achad.ichFst := ichLeft;  achad.ichLim := ichRight+1;
      ReplacSpaces(@achad);
   UNTIL NOT FQualifies(@achad, ichThis);

   SLpFstPWd := LpRight;
END; {SLpFstPWd}



{-------------------------------------------------}
PROCEDURE GetNxtWd(lpd: TLpd; chad:TChad; VAR ichInWd: TC;
                       VAR lpFstWd, lpLimWd: TLp; HStrWd: TStrHnd);
{-------------------------------------------------}
{ichInWd is a location within chad^.rgch.  Find the word that follows ichInWd and
 return its limiting lp's in lpFstWd and lpLimWd.  Also, make the word into
 a string and put it (or its first maxDStrLen chars) into HStrWd^^. IchInWd
 must precede and/or follow a separator on entry to this routine.
 This routine might do one or more SeqLpd's into lpd and chad.
 Before returning, it will set ichInWd to the ich within
 the latest chad that corresponds to lpLimWd.  This routine does assume that at
 least the char at ichInWd is in chad^ and that it was "read" on the last SetLpd
 or SeqLpd.  All fields of chad and lpd must be correct.  If there
 are no more words in the stream, this routine returns lpLimWd = 0.
 }
 LABEL 30;
 VAR
    ichFstWd, ichLimWd, ichOfWd: TC;
    j, cCh: TC;
    ichFstSeq: ARRAY[0..ichMaxSpell] OF TC; {ichFst for this seqLpd}
    lpFstSeq:  ARRAY[0..ichMaxSpell] OF TLP;{the lp for ichFst for this seqLpd}
    cSeqs: TC;                              {the no. of seqLpds done}
    fDone, fLastChar, fStartAgain, fFstTimeThru: TF;
    lpWord: TLp;


    PROCEDURE MoreSeqLpd (lpStart: TLp; var fStartedOver: TF);
    {Read more characters into chad, beginning where we left off in chad^.rgch^.
     If we run out of room in the aRgch array, then start reading again at
     lpStart into the beginning of aRgch, reset ichFst and the ich/lp mapping
     data structures, and set fStartedOver to TRUE.}
    VAR
       answer: string[3];
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    fStartedOver := FALSE;
    WITH chad^, lpd^ DO
       BEGIN
       IF (ichLim < ichMaxSpell) THEN
           ichFst := ichLim {Continue reading from and to where we left off}
       ELSE
          BEGIN {Start reading from lpStart into beginning of achad}
          ichFst := 0;
          lpLim := lpStart;
          cSeqs := -1;
          fStartedOver := TRUE;
          END;
       END;
    {Seq until we get a non-vanished or empty result}
    REPEAT
       BEGIN
       chad^.ichLim := ichMaxSpell;
       SeqLpd(lpd, chad^);
       END
    UNTIL (NOT lpd^.rce^.fvan) OR (lpd^.lp = lpd^.lpLim);
    IF (lpd^.lp <> lpd^.lpLim) THEN
       BEGIN
       ReplacSpaces(chad);
       cSeqs := cSeqs + 1;
       ichFstSeq[cSeqs] := chad^.ichFst;
       lpFstSeq[cSeqs] := lpd^.lp;
       END;
    END;

    FUNCTION LpFromIch(theIch: TC): TLp;
    {Return the lp corresponding to theIch}
    VAR
       found: TF;
       j: TC;
       theLp: TLp;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    found := FALSE;
    j := 0;
    WHILE NOT found AND (j < cSeqs) DO
       BEGIN
       IF (theIch < ichFstSeq[j+1]) THEN found := TRUE
                                    ELSE j := j+1;
       END;
    theLp := theIch - ichFstSeq[j] + lpFstSeq[j];
    lpFromIch := theLp;
    END;

    FUNCTION fInWd(var theIch: TC; var fEOS: TF; ichStart: TC;
                   fOkToStartOver: TF; var fHitChadEnd: TF): TF;
    {Return TRUE iff the character at theIch within chad^ is within a word, i.e.,
     FQualifies is TRUE.  If no chars follow theIch in the stream, fInWd will
     set fEOS to TRUE.  This function might have to call MoreSeqLpd.  If
     MoreSeqLpd has to start over reading the chars because it hit the end of
     the chad and if fOkToStartOver is TRUE, fInWd will start at ichStart and will
     reset ichFst and the ich/lp mapping data structures, set theIch to 0, set
     fHitChadEnd to TRUE, and return FALSE.  If fOkToStartOver is FALSE, fInWd
     will do nothing but set fHitChadEnd to TRUE.}
    LABEL 10;
    VAR
       fNonSep: TF;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    fHitChadEnd := FALSE;
    fEOS := FALSE;
    IF (chad^.ichLim = theIch + 1) THEN
       BEGIN
       IF ftstSpell THEN
          BEGIN
          writeln('fInWd: has to call MoreSeqLpd');
          writeln('       theIch is ', theIch);
          writeln('       the char is ', CHR(chad^.rgch^[theIch]));
          END;
       MoreSeqLpd(LpFromIch(ichStart), fHitChadEnd);
       IF fHitChadEnd THEN
          BEGIN
          theIch := 0;
          fNonSep := FALSE;
          GOTO 10;
          END;
       fEOS := (lpdStd^.lp = lpdStd^.lpLim);
       IF ftstSpell THEN IF fEOS THEN writeln('fInWd: fEOS is TRUE');
       END;
    chad^.ichFst := ichFstSeq[0];
    fNonSep := FQualifies(chad, theIch);
10:
    fInWd := fNonSep;
    END;


BEGIN {GetNxtWd}
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH lpd^, chad^ DO
   BEGIN
   fFstTimeThru := TRUE;
   cSeqs := 0;
   ichFstSeq[cSeqs] := ichFst;
   lpFstSeq[cSeqs] := lp;
   END;
30:
WHILE NOT FInWd(ichInWd, fLastChar, ichInWd, TRUE, fStartAgain) DO
   BEGIN {Now we have to find the beginning of the next word.
          Search until we find a non-separator character.}
   IF NOT fStartAgain THEN ichInWd := ichInWd+1;
   IF fLastChar THEN
      BEGIN   {No more characters in the stream, so no more words.}
      lpLimWd := 0;
      EXIT(GetNxtWd);
      END;
   END;

{At this point, ichInWd is the beginning of a word.}
ichFstWd := ichInWd;
lpFstWd := lpFromIch(ichFstWd);
IF ftstSpell THEN writeln('GetNxtWd: ichFstWd is ', ichFstWd);

{Now search until we find a separator character.}
ichInWd := ichFstWd + 1;
fDone := fLastChar;
WHILE NOT fDone AND FInWd(ichInWd, fLastChar, ichFstWd, fFstTimeThru,
                          fStartAgain) DO
   BEGIN
   ichInWd := ichInWd+1;
   fDone := fLastChar;   {True if no more characters in the stream}
   END;
 IF fStartAgain THEN IF fFstTimeThru THEN
    BEGIN {We have to start over because we hit the end of the chad}
    fFstTimeThru := FALSE;
    IF ftstSpell THEN
       writeln('GetNxtWd: Setting fFstTimeThru to FALSE and starting over.');
    GOTO 30;
    END;

ichLimWd := ichInWd;
lpLimWd := lpFromIch(ichLimWd);
IF ftstSpell THEN writeln('          ichLimWd is ', ichLimWd);

{Now put the word into a string}
cCh := ichLimWd - ichFstWd;
IF (cCh > maxDStrLen) THEN cCh := maxDStrLen;
HStrWd^^[0] := CHR(cCh);
FOR j := 1 TO cCh DO HStrWd^^[j] := CHR(chad^.rgch^[ichFstWd +j-1]);

{Set ichInWd to next character following this word}
ichInWd := ichLimWd;
chad^.ichFst := ichFstSeq[cSeqs];
IF (ichInWd >= chad^.ichLim) THEN
   BEGIN
   chad^.ichLim := ichMaxSpell;
   lpWord := lpFromIch(ichInWd);
   MoreSeqLpd(lpWord, fStartAgain);
   ichInWd := 0;
   END;
END;



{$S LWGuess}
{-------------------------------------------------}
PROCEDURE EnQFindNext;
{-------------------------------------------------}
{Set up an event to simulate the choice of the &Find Next menu item}
VAR
   evDsc: TEvDsc;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH evDsc DO
   BEGIN
   tyev := tyevCmd;
   obox := oboxNil;
   imtd := imtdSpelling;
   imid := imidAndFind;
   fMouseButton := FALSE;
   END;
EnqueueLotus(bdsp^.pq^, @evDsc);
END;


{-------------------------------------------------}
PROCEDURE ChgBtns (HBtnGrp: TCkBoxHnd);
{-------------------------------------------------}
{Make sure that the particular group of buttons whose ckBox description is in
 HBtnGrp is currently attached to HGuessCkForm.}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$R-}
If (curHBtnGrp <> HBtnGrp) THEN
   BEGIN
   HGuessCkForm^^.ckBoxLst[0] := HBtnGrp;
   curHBtnGrp := HBtnGrp;
   END;
END;


{-------------------------------------------------}
PROCEDURE PutGuessDbox(HCkForm: TCkFormHnd; ckBoxWithChg: Integer);
{-------------------------------------------------}
{Put up the dialog box described by HCkForm.  Assume that all of the fields in
 HCkForm are already set up (except for the curCkItm field for the buttons).
 If necessary, remove any existing dialog box first.  Assume that there are
 two ckBox'es.  The tyDbox we are putting up is tyGuesses.  Also, enable the
 Paste Guesses menu item.  If the guesses dialog box is already up and if
 ckBoxWithChg is 0 or greater, then just redraw that particular check box.}
VAR
   tyDbox: TTyDbox;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$R-}
{Make sure that no button is pushed}
HCkForm^^.ckBoxLst[0]^^.curCkItm := -1;
{Is the dialog box up now?}
tyDbox := FWhatsUp;
{Set up the dialog box if it isn't already up}
{Is the dialog box up now?}
tyDbox := FWhatsUp;
{Set up the dialog box if it isn't already up}
IF (tyDbox <> tyGuesses) THEN
   RmvAnyDbox;  {Remove any other type of dialog box that may be up}
IF (tyDbox <> tyGuesses) OR (HCkForm <> curHCkForm) THEN
    BEGIN
    SetDBox(Pointer(Ord(HCkForm)), NIL, @GetCkHit, @TrkCkBoxMse,
            @RestoreCkForm, @EndGuessDbox);
    LCreateDBox(HCkForm^^.vCkForm, TyGuesses);
    SetDPort;
    ShowCkForm(HCkForm);
    curHCkForm := HCkForm;
    EnableItem(argMenu[imtdSpell], imidPGuess);
    IF ftstSpell THEN writeln('*****PasteGuess menu item enabled');
    END
ELSE
    BEGIN
    IF ftstSpell THEN writeln('The particular dialog box is already up.');
    SetDPort;
    IF (ckBoxWithChg >= 0) THEN ShowJust1CkBox(HCkForm, ckBoxWithChg)
    ELSE ShowCkForm(HCkForm);
    END;
END;


{$S LWSpFind}

{-------------------------------------------------}
PROCEDURE ClrGuesses;
{-------------------------------------------------}
{If a guesses dialog box is up and showing guesses, then remove it and disable
 the "Paste Guess" menu item.  Otherwise, do nothing.}
VAR
   tyDbox: TTyDbox;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tyDbox := FWhatsUp;
IF (tyDbox = tyGuesses) THEN
   BEGIN
   LRmvDBox;
   DisableItem(argMenu[imtdSpell], imidPGuess);
   IF ftstSpell THEN writeln('*****PasteGuess menu item disabled');
   END;
END;


{$S LWSpInit}

{----------------------}
FUNCTION DoHMInit: TF;
{----------------------}
{Init Houghton-Mifflin's spelling software.  If something goes wrong, give an
 appropriate alert and return FALSE.}
LABEL 100;
VAR
   foundDictName: PathName;
   dictName: TParamAlert;
   fZapDict: TF;
   optionStr: Str255;
   optionAlert: Integer;
   msgAlert: Integer;
   strStart, strLen: Integer;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WaitAlert(WPAlerts, 71);
{Init H-M's spelling routines}
fZapDict := FALSE;
100:
HMReturn := SpInitialize (spLotusPrefix, nameOfUserDictionaryFile,
                          foundDictName, spLsdn, fZapDict);
strStart := pos('}', foundDictName) + 1;
strLen := length(foundDictName)-length('dict.data')-strStart + 1;
dictName := copy(foundDictName, strStart, strLen);
IF ftstSpell THEN writeln('SpInitialize found the Main Dictionary in ',
                           foundDictName);
IF ftstSpell THEN writeln('--->', dictName);
IF (HMReturn <> ok) THEN
   BEGIN
   {$ifc fDbgOk}
   writeln(CHR(7)); {Beeeep}
   writeln('Why did SpInitialize return ',ShowReturn (ord(HMReturn))^, '?');
   {$endc}
   EndWaitAlert;
   CASE spStatus OF
      uninitialized:  IF ftstSpell THEN writeln('uninitialized');
      noSegment:  IF ftstSpell THEN writeln('noSegment');
      noUserDictionary:  IF ftstSpell THEN writeln('noUserDictionary');
      noMainDictionary: StopAlert(WPAlerts, 92);
      oldUserDictionary, badUserDictionary, oldMainDictionary, badMaindictionary:
         BEGIN
            case spStatus of
             oldUserDictionary, oldMainDictionary: optionAlert := 501; {outdated}
             otherwise                             optionAlert := 500; {damaged}
            end;
            GetAlert (WPAlerts, optionAlert, @optionStr);
            ParamAlert(optionStr, '', '');
            case spStatus of
             oldUserDictionary, badUserDictionary:
                   IF CautionAlert(WPAlerts, 93) THEN BEGIN
                     fZapDict := TRUE;
                     GOTO 100;
                   END;
             otherwise StopAlert(WPAlerts, 94);
            end;
         END;
      END;
   DoHMInit := FALSE;
   END
ELSE
   BEGIN
   ParamAlert(dictName, '', '');
   WaitAlert(WPAlerts, 72);
   DoHMInit := TRUE;
   EndWaitAlert;
   END;
END;


{$S LWDebug}
{-------------------------------------------------}
PROCEDURE BadReturn(theReturn: TSpReturn; routineName: TParamAlert);
{-------------------------------------------------}
{One of the Houghton-Mifflin routines (other than SpInitialize) has returned
 theReturn, which is notInitialized, illegalString, masterError, unableToLoad,
 or userMemoryFull.  Give the appropriate alert and debugging response.}
VAR
   tempReturn: TSpReturn;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$IFC  fDbgOk}
IF (theReturn <> notInitialized) THEN writeln(CHR(7));
writeln('Why did ', routineName, ' return ', ShowReturn (ord(theReturn))^, '?');
{$ENDC}
CASE theReturn OF
   notInitialized:
      BEGIN
      IF (AskAlert(WPAlerts, 91) <> retCancel) THEN
         BEGIN
         tempReturn := SpTerminate(cleanUp);
         {$IFC  fDbgOk}
         IF ftstSpell THEN IF (tempReturn <> ok) THEN
            writeln(CHR(7), 'Why did SpTerminate return',
                    ShowReturn (ord(tempReturn))^, '?');
         {$ENDC}
         IF DoHMInit THEN BEGIN END;
         END;
      END;
   masterError:
      BEGIN
      StopAlert (WPAlerts, 95);
      END;
   unableToLoad:
      BEGIN
      StopAlert (WPAlerts, 96);
      END;
   illegalString:
      BEGIN
      END;
   userMemoryFull:
      BEGIN
      StopAlert (WPAlerts, 97);
      END;
   END;
END;

{$ifc fDbgOk}
{$S LWUSpell}
{$elsec}
{$S LWSpell}
{$endc}


{$S LWGuess}

{-------------------------------------------------}
FUNCTION SetUpGuesses: BOOLEAN;
{-------------------------------------------------}
{Attach strings for guesses to the check boxes in the Guesses dialog box
 in preparation for showing the dialog box.  Assume that all fields for the
 dialog box are set up except for the number of check boxes to show and their
 strings.  Set up for the "Show More" or "Just Hide" buttons.  Set curCkItm.
 Start with guess number guessNum.  On return, guessNum will be the no. for the
 next guess that the spelling checker will make.  Return FALSE iff there are no
 more guesses.  The current selected word is in newWord.}
VAR
   fLast, fFirst: TF;
   theWord: TSpWord;
   pStr: ^TSpLetters;
   hStr: TStrHnd;
   fStartingNew: TF;
   origNumCkItm: TB;

   {-------------------------------------------------}
   PROCEDURE SetColWidth(rightOfCol: integer);
   {-------------------------------------------------}
   {Change the right boundary of the hit boxes for the ckItms in the first
    column of the Guesses dialog box to rightOfCol.}
   VAR
      i: integer;
   BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   WITH HGuessCkForm^^.ckBoxLst[1]^^ DO
      FOR i := 1 TO oneColGuessesMax DO
         ckItmLst[i]^^.hitBox.right := rightOfCol;
   END;


BEGIN {SetUpGuesses}
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH HGuessCkForm^^.ckBoxLst[1]^^ DO
   BEGIN
   fStartingNew := FALSE;
   origNumCkItm := numCkItm;  {Remember the original number of guesses}
   {If the dialog box is empty or already full, start a new one.}
   IF (numCkItm = curMaxGuesses) THEN numCkItm := 0;
   IF (numCkItm = 0) THEN
      BEGIN
      fStartingNew := TRUE; {Remember that we're starting a new dialog box}
      curMaxGuesses := GuessesMax;
      SetColWidth(rightOfWideCol);
      END;
   fLast := FALSE;  {Last word in this group?}
   fFirst := TRUE;  {First word in this group?}
   END;
REPEAT
   HMReturn := CorrectWord(theWord, guessNum, fLast);
   IF (HMReturn <> LimitExceeded) AND (HMReturn <> WordExists) AND
      (HMReturn <> ok) THEN
      BEGIN
      BadReturn(HMReturn, 'SetUpGuesses:CorrectWord');
      SetUpGuesses := FALSE;
      Exit(SetUpGuesses);
      END;
   {$ifc fDbgOk}
   IF ftstSpell THEN
      BEGIN
      writeln('CorrectWord was called for ', newWord.word, '?');
      writeln('CorrectWord returned HMReturn = ', ShowReturn (ord(HMReturn))^);
      IF (HMReturn = WordExists) OR (HMReturn = ok) THEN
         writeln('   Guess no. ', guessNum, ' is ', theWord.word);
      IF fLast THEN writeln('   fLast is TRUE.')
               ELSE writeln('   fLast is FALSE.');
      END;
   {$endc}
   guessNum := guessNum + 1;
   IF (HMReturn = WordExists) OR (HMReturn = ok) THEN
      BEGIN
      WITH HGuessCkForm^^.ckBoxLst[1]^^ DO
         BEGIN
         numCkItm := numCkItm + 1;
         hStr := ckItmLst[numCkItm]^^.iTitle;
         pStr := POINTER(ORD(hStr^));
         pStr^ := theWord.word;
         IF ftstSpell THEN writeln('Adding word no. ', numCkItm);
         IF ftstSpell THEN writeln('Length of ', theWord.word, ' is ',
                                   LENGTH(theWord.word));

         IF fFirst THEN
            BEGIN   {Check the first word in this group}
            curCkItm := numCkItm;
            fFirst := FALSE;
            END;
         IF fStartingNew THEN
            BEGIN
            fStartingNew := FALSE;
            cDboxes := cDboxes + 1;
            END;
         IF (numCkItm <= oneColGuessesMax) AND
            (LENGTH(theWord.word) > cChCol1Narrow) THEN
            BEGIN
            curMaxGuesses := oneColGuessesMax;
            IF ftstSpell THEN writeln('Lowering curMaxGuesses to ',
                                      curMaxGuesses);
            END
         ELSE IF (numCkItm = oneColGuessesMax + 1) THEN
            SetColWidth(rightOfNarrowCol);
         END;
      IF ftstSpell THEN WITH HGuessCkForm^^.ckBoxLst[1]^^ DO
         BEGIN
         writeln('After assignment to iTitle:');
         writeln('   check item no. ', numCkItm);
         writeln('   is ', ckItmLst[numCkItm]^^.iTitle^^);
         END;
      END;
   UNTIL fLast OR ((HMReturn <> WordExists) AND (HMReturn <> ok))
               OR (HGuessCkForm^^.ckBoxLst[1]^^.numCkItm = curMaxGuesses);
IF (HMReturn <> WordExists) AND (HMReturn <> ok) THEN
   BEGIN {Didn't find any more guesses}
   SetUpGuesses := FALSE;
   WITH HGuessCkForm^^.ckBoxLst[1]^^ DO
   IF (origNumCkItm > 0) THEN numCkItm := origNumCkItm {The dialog box was full
                                                         on entry to this
                                                         routine.   Don't
                                                         change anything.}
   ELSE IF (numCkItm = 0) THEN ChgBtns(HJustHide);     {There are no guesses
                                                        for this word.}
   END
ELSE
   BEGIN
   SetUpGuesses := TRUE;  {There are more guesses to show.}
   ChgBtns(HShowMore);
   END;
END;


{-------------------------------------------------}
FUNCTION SetFirstGuesses(fFstTime: TF): TF;
{-------------------------------------------------}
{Attach strings for the FIRST set of guesses to the check boxes in the Guesses
 dialog box in preparation for showing the dialog box.  Assume that all fields
 for the dialog box are set up except for the number of check boxes to show and
 their strings.  Set up for either the "Show More" or the "Just Hide" buttons.
 We will start with guess number 1.  Return FALSE iff there are no more guesses.
 If fFstTime is TRUE, then this is the first time around for generating and
 showing guesses for the current word; if FALSE, then we're just showing the
 guesses from the beginning again.}
VAR
   fLast: TF;
   theWord: TSpWord;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fFstTime THEN
   BEGIN
   HMReturn := InitCorrectWord(newWord.word);
   {$ifc fDbgOk}
   IF ftstSpell THEN
      writeln('   InitCorrectWord returned HMReturn = ', ShowReturn (ord(HMReturn))^);
   {$endc}
   IF (HMReturn <> ok) THEN
      BEGIN
      BadReturn(HMReturn, 'SetFirstGuesses:InitCorrectWord');
      IF ftstSpell THEN
         writeln('InitCorrectWord was called for ', newWord.word, '?');
      SetFirstGuesses := FALSE;
      Exit(SetFirstGuesses);
      END;
   END;
cDboxes := 0;
guessNum := 1;
HGuessCkForm^^.ckBoxLst[1]^^.numCkItm := 0;
SetFirstGuesses := SetUpGuesses;
END;



{-------------------------------------------------}
PROCEDURE PutNoGuessMsg(wordStr: TParamAlert; fRelated: TF);
{-------------------------------------------------}
{State in an alert box that there are no guesses - or related words if fRelated
 is TRUE - for the word in wordStr. Make sure that the dialog box is removed.}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
ClrGuesses;
ParamAlert(wordStr, '', '');
IF NOT fRelated THEN NoteAlert(WPAlerts, 60)
ELSE NoteAlert(WPAlerts, 81);
END;


{$S LWSpFind}

{-------------------------------------------------}
PROCEDURE InitToFindWd;
{-------------------------------------------------}
{Setup achadSpell, tyset, and pintSel for the setLpd (or whatever) to find
 a word.}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tyset := tysetStd;
tyset.fRpe := FALSE;
WITH achadSpell DO
   BEGIN
   rgch := @aRgChSpell;
   ichFst := 0;
   ichLim := ichMaxSpell;
   END;
pintSel := POINTER(ORD(lldInt)+selCur.oint);
RemoveKid(FALSE);
END;



{-------------------------------------------------}
FUNCTION fWdTooLong(HWord: TStrHnd; lpFstWd, lpLimWd: TLp): TF;
{-------------------------------------------------}
{If the word in HWord^^ is too long for the spelling checker to check, then
 select it (from lpFstWd to lpLimWd), scroll it into view, take down the
 guesses dialog box, put up a note alert stating that the word (truncated
 and shown with "..." at the end) is too long, and return TRUE.
 Otherwise, return FALSE.}
VAR
   wdLen: integer;
   prevLpFst, prevLpLim: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
wdLen := ORD(HWord^^[0]);
IF wdLen > maxWordLength
THEN
   BEGIN {The word we found is too long to check}
   ClrGuesses;
   prevLpFst := pintSel^.lpFst;
   prevLpLim := pintSel^.lpLim;
   LSetSel(pintSel^.ics, lpFstWd, lpLimWd);  {Make this word the new
                                              selection}
   Chronicle(pintSel^.ics, lpFstWd, lpLimWd,
             pintSel^.ics, prevLpFst, prevLpLim, hopSelect);
   IntInWindow(selCur.oint, orecToScroll);
   IF (wdLen > maxParamLen) THEN HWord^^[0] := CHR(maxParamLen);
   HWord^^[maxParamLen] := '.';
   HWord^^[maxParamLen-1] := '.';
   HWord^^[maxParamLen-2] := '.';
   paramStr := HWord^^;
   ParamAlert(paramStr, '', '');
   NoteAlert(WPAlerts, 58);
   fWdTooLong := TRUE;
   END
ELSE fWdTooLong := FALSE;
END;


{$S LWSpell}

{-------------------------------------------------}
FUNCTION FPeriodAfter(lpEnd: TLp; theIcs: TB; VAR lpPeriod: TLp): TF;
{-------------------------------------------------}
{Return TRUE iff the next non-vanished character at (or after) lpEnd is a period.
 theIcs is the stream.  Also, if there is a period, set lpPeriod to the lp after
 the period.  WARNING: This leaves ichFst = 0 and the char at lpEnd in achadSpell.}
VAR
   fIsAPeriod: TF;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
InitToFindWd;
REPEAT SetLpd(lpdStd, theIcs, lpEnd, tyset, achadSpell)
   UNTIL (NOT lpdStd^.rce^.fvan) OR (lpdStd^.lp = lpdStd^.lpLim);
ReplacSpaces(@achadSpell);
IF (lpdStd^.lp = lpdStd^.lpLim) THEN fIsAPeriod := FALSE
ELSE fIsAPeriod := (achadSpell.rgch^[achadSpell.ichFst] = chPeriod);
IF fIsAPeriod THEN lpPeriod := lpdStd^.lp+1
ELSE lpPeriod := lpdStd^.lp;
FPeriodAfter := fIsAPeriod;
END;



{-------------------------------------------------}
PROCEDURE MinusToHyphen(VAR aWord: TSpLetters);
{-------------------------------------------------}
{Change all minus signs within aWord to hyphens.}
VAR
   j: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
j := POS('-',aWord);
WHILE (j<>0) DO
   BEGIN
   aWord[j] := CHR(chRealHyphen);
   j := POS('-',aWord);
   END;
END;


{$ifc fDbgOk}
{$S LWUSpell}
{$elsec}
{$S LWSpFind}
{$endc}

{-------------------------------------------------}
FUNCTION HMVerify(HWord: TStrHnd; fPeriod: TF): TSpReturn;
{-------------------------------------------------}
{Verify the word at HWord^^ using the Houghton-Mifflin routines, and return
 the associated return code.  Assume that HWord^^ has no more than maxWordLength
 chars.  If fPeriod is TRUE, then try the word with a period appended to the end.
 If the word is hyphenated, then test each of the pieces first.  If the individual
 pieces don't all verify, then try the whole thing and return its TSpReturn.
 Before doing anything, replace any minus signs within the string with hyphens.}
VAR
   theReturn: TSpReturn;
   theWord: TSpWord;
   partWord: TSpLetters;
   i, j: TC;
   fCheckWhole, fPeriodAdded: TF;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH newWord DO  {Set up newWord for H-M's verify routine}
   BEGIN
   word := HWord^^;
   IF fPeriod THEN
      BEGIN
      word := Concat(word, '.');
      fPeriodAdded := TRUE;
      END
   ELSE fPeriodAdded := FALSE;
   theWord := newWord;
   fCheckWhole := TRUE;
   MinusToHyphen(word);
   j := POS(hyphenStr,word);
   IF (j <> 0) THEN
      BEGIN
      IF ftstSpell THEN writeln('  -Hyphen(s) in this word.');
      partWord := word;
      REPEAT
         theWord.word := partWord;
         IF (j <> 0) THEN
            BEGIN
            DELETE(theWord.word, j, LENGTH(theWord.word)-j+1);
            DELETE(partWord, 1, j);
            END
         ELSE partWord := '';
         j := POS(hyphenStr,partWord);
         IF ftstSpell THEN
            writeln('   -About to call VerifyWord with word = ', theWord.word);
         theReturn := VerifyWord(theWord);
         {$ifc fDbgOk}
         IF ftstSpell THEN
            writeln('   -VerifyWord returned HMReturn = ',
                    ShowReturn (ord(theReturn))^);
         IF ftstSpell THEN writeln;
         {$endc}
      UNTIL (LENGTH(partWord) =0) OR (theReturn<>ok);
      IF (theReturn = ok) THEN fCheckWhole := FALSE
      ELSE theWord.word := word;
      END;
   IF fCheckWhole THEN
      BEGIN
      IF ftstSpell THEN
         BEGIN
         writeln('About to call VerifyWord with word = ', theWord.word);
         IF fPeriodAdded THEN writeln('Length of word is ', LENGTH(theWord.word));
         END;
      theReturn := VerifyWord(theWord);
      {$ifc fDbgOk}
      IF ftstSpell THEN
        writeln('   VerifyWord returned HMReturn = ', ShowReturn (ord(theReturn))^);
      IF ftstSpell THEN writeln;
      {$endc}
      END;
   HMVerify := theReturn;
   END;
END;


{$S LWSpell}

{-------------------------------------------------}
FUNCTION FGetThisWd(theLp: TLp;  theLimLp: TLp; var theStrH: TStrHnd;
                    var lpBegin: TLp; var lpEnd: TLp; var limIch: TC): TF;
{-------------------------------------------------}
{The current selection goes from theLp to theLimLp.  Find the word indicated by
 this selection and put its string into theStrH^^ and its bounding lp's
 into lpBegin and lpEnd.  Assume that the lp's are in the stream with the current
 selection.  Return TRUE iff a word was found.  If FALSE, the var
 params will be meaningless.  Assume that InitToFindWd was called prior to
 calling this function.  limIch returns the limiting ich of the word within
 achadSpell (for use in subsequent calls to GetNxtWd to obtain succeeding words).}
LABEL 50;
TYPE
   TCase = (QQ, QN, NQ, NN);
VAR
   lpStart, lpBegin2, lpEnd2, lpPeriod: TLp;
   theCase: TCase;
   theStrH2: TStrHnd;
   theStrP2: TStrPtr;
   theStr2: StrChars;
   fAtBeginning, fMakeSecond: TF;


   FUNCTION GetCase(lp1End, lp1Period, lp2Begin: TLp): TCase;
   {Determine "where" theLp is.  Does it lie between two separators or in the
    middle of a word or at the beginning or end.  Classify it according to the
    chars surrounding it:
    Q/Q, N/Q, Q/N, and N/N, where Q means the char qualifies for inclusion in a
    word and N means that it doesn't.  lp1End is the limiting boundary of the
    first word, excluding a possible period, and lp1Period is the limiting
    boundary of the first word, including a possible period, and lp2Begin is the
    beginning of the second word.
    The beginning of word1 < theLp <= the beginning of word2.}
   VAR
      prvLp: TLp;
   BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   IF (theLp < lp1End) THEN GetCase := QQ           {inside a word}
   ELSE IF (theLp = lp1End) OR (theLp = lp1Period)
      THEN GetCase := QN                            {end of a word}
   ELSE IF (theLp < lp2Begin) THEN GetCase := NN    {between words}
   ELSE GetCase := NQ;                              {before a word}
   END;



BEGIN {fGetThisWd}
{$IFC sampcalls}  ALogCall;  {$ENDC}
theStrP2 := @theStr2;
theStrH2 := @theStrP2;
WITH achadSpell DO
   BEGIN
   {Now make the first attempt at getting the right word.}
   lpStart := SLpFstPWd(pintSel^.ics, theLp); {Finds the beginning of the
                                                       word preceeding theLp.}
   IF (lpStart = -1) THEN
      BEGIN  {There were no words preceeding lpLim}
      fAtBeginning := TRUE;
      lpStart := 0;
      IF ftstSpell THEN writeln('FGetThisWd: theLp is at the beginning.');
      END
   ELSE fAtBeginning := FALSE;

   ichLim := ichMaxSpell;
   ichFst := 0;
   REPEAT SetLpd(lpdStd, pintSel^.ics, lpStart, tyset, achadSpell)
      UNTIL (NOT lpdStd^.rce^.fvan) or (lpdStd^.lp = lpdStd^.lpLim);
   IF (lpdStd^.lp = lpdStd^.lpLim) THEN GOTO 50; {No non-vanished characters in
                                                  stream}
   ReplacSpaces(@achadSpell);
   limIch := achadSpell.ichFst;

   IF fAtBeginning THEN {The first word is empty}
      BEGIN
      lpPeriod := -1;
      lpEnd := -1;
      theStrH^^ := '';
      END
   ELSE
      BEGIN
      GetNxtWd(lpdStd, @achadSpell, limIch, lpBegin, lpEnd, theStrH);{Get the word}
      If NOT FPeriodAfter(lpEnd, pintSel^.ics, lpPeriod) THEN lpPeriod := lpEnd;
      END;
   IF ftstSpell THEN writeln('FGetThisWd: First word is ', theStrH^^);
   limIch := 0;

   {Now get the succeeding word.  If the selection does include a word, it will be
    either the one we just got or the one we're going to get.}
    GetNxtWd(lpdStd, @achadSpell, limIch, lpBegin2, lpEnd2, theStrH2);
    IF ftstSpell THEN writeln('            Second word is ', theStrH2^^);


   {The word we want to return may be the first one we got or the next one.  To
    determine what to do, we need to look first at the two characters surrounding
    theLp.  Determine which of four cases we're dealing with.}
   theCase := GetCase(lpEnd, lpPeriod, lpBegin2);
   IF ftstSpell THEN
      BEGIN
      IF (theCase = QQ) THEN writeln('Case QQ')
      ELSE IF (theCase = QN) THEN writeln('Case QN')
      ELSE IF (theCase = NQ) THEN writeln('Case NQ')
      ELSE writeln('Case NN');
      END;

   {Now we'll determine which of the two words, if either, to return.}
   fMakeSecond := FALSE;
   CASE theCase OF
   QQ: BEGIN END;  {The first word is the one that we want.}
   NQ: fMakeSecond := TRUE; {The second word is the one that we want.}
   QN: BEGIN
       IF (theLp = theLimLp) THEN {We found the right word the first time.}
       ELSE
          BEGIN {The second word is it iff the selection extends into it.}
          IF (theLimLp <= lpBegin2) THEN GOTO 50 {The selection doesn't include
                                                  a word.}
          ELSE fMakeSecond := TRUE;
          END;
       END;
   NN:
       BEGIN {The second word is it iff the selection extends into it.}
       IF (theLimLp <= lpBegin2) THEN GOTO 50 {The selection doesn't include
                                               a word.}
       ELSE fMakeSecond := TRUE;
       END;
   END;
   IF fMakeSecond THEN
      BEGIN
      IF (lpEnd2 = 0) THEN GOTO 50;  {There is no second word.}
      {Make it the second word:}
      lpBegin := lpBegin2;
      lpEnd := lpEnd2;
      theStrH^^ := theStrH2^^;
      END
   ELSE
      BEGIN
      IF (lpEnd = -1) THEN GOTO 50;  {There is no word in this stream.}
      {Make it the first word:}
      ichFst := 0;
      ichLim := ichMaxSpell;
      REPEAT
         SetLpd(lpdStd, pintSel^.ics, lpBegin2, tyset, achadSpell)
         UNTIL (NOT lpdStd^.rce^.fvan) or (lpdStd^.lp = lpdStd^.lpLim);
      ReplacSpaces(@achadSpell);
      limIch := 0;
      END;

   FGetThisWd := TRUE;
   EXIT(FGetThisWd);

50:{No more words in the stream or the selection doesn't include a word.}
   FGetThisWd := FALSE;
   END;
END;



{$S LWGuess}

{-------------------------------------------------}
PROCEDURE ShowMore(butnItm: Integer);
{-------------------------------------------------}
{Give the appropriate response to the pushing of the Show More button.
 If butnItm is non-negative, then this proc was invoked by the pushing of
 the button whose check item index is butnItm.}
VAR
   fAreMore, fUpdatePending: TF;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$ifc fDbgOk}
IF fTime THEN mTime := microTimer;
{$endc}
fUpdatePending := FALSE;
fAreMore := SetUpGuesses;
IF NOT fAreMore THEN
   BEGIN  {No more guesses can be generated}
   IF (cDboxes > 1) THEN
      BEGIN  {We have generated more than one dialog box full of guesses}
      IF (AskAlert(WPAlerts, 65) <> retCancel) THEN
         BEGIN {Show the guesses again from the beginning.}
         fAreMore := SetFirstGuesses(FALSE);
         fUpdatePending := TRUE; {Removal of the AskAlert will generate an update
                                  that will do the equivalent of PutGuessDbox}
         END;
      END
   ELSE NoteAlert(WPAlerts, 66); {All guesses fit in the one dialog box.}
   END;
SetDPort;
IF (butnItm >= 0) THEN PushButn(butnItm - 1,FALSE);
IF fAreMore AND NOT fUpdatePending THEN PutGuessDbox(HGuessCkForm, 1);
{$ifc fDbgOk}
IF fTime THEN
   BEGIN
   mTime := MicroTimer - 135 - mTime;
   writeln('Show More took ', mTime, ' usec.');
   END;
{$endc}
END;


{-------------------------------------------------}
PROCEDURE SuggestCorrections;
{-------------------------------------------------}
{Implement the Suggest Corrections menu command.}
Label 100;
VAR
   lpFstWd, lpLimWd, lpLimPeriod: TLp;
   fAreGuesses, fShowGuesses, fVerifies: TF;
   endIch: TC;
   wordWOPeriod: TSpLetters;

   FUNCTION FContinuation: TF;
   {Determine whether the user wishes to continue the dialog in the
    currently displayed dialog box or to begin a new one.  Continue iff
    the dialog box is up and the word we just extracted is exactly the same as
    the current selection and the one for which we put up the dialog box in
    the first place.  If a continuation is warranted, do the appropriate
    actions (move the check or, if necessary, "Show More", then return TRUE.
    Otherwise, just return FALSE.}
   LABEL 15;
   VAR
      tyDbox: TTyDbox;
   BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   tyDbox := FWhatsUp;
   IF (tyDbox <> tyGuesses) THEN GOTO 15;
   IF (lpFstWd <> lastLpFstWd) THEN GOTO 15;
   IF (lpLimWd <> lastLpLimWd) THEN GOTO 15;
   IF (lpFstWd <> pintSel^.lpFst) THEN GOTO 15;
   IF (lpLimWd <> pintSel^.lpLim) THEN GOTO 15;
   WITH HGuessCkForm^^.ckBoxLst[1]^^ DO
      BEGIN
      IF (ckItmLst[0]^^.iTitle^^ <> lastString) THEN GOTO 15;
      IF (numCkItm > curCkItm) THEN
         BEGIN
         SetDPort;
         ChgCkItm(HGuessCkForm^^.ckBoxLst[1], curCkItm + 1);
         END
      ELSE ShowMore(-1);
      END;
   FContinuation := TRUE;
   Exit (FContinuation);

   15: FContinuation := FALSE;
   END;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$ifc fDbgOk}
IF fTime THEN mTime := microTimer;
{$endc}
InitToFindWd;
IF FGetThisWd(pintSel^.lpFst, pintSel^.lpLim,
              HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^.iTitle,
              lpFstWd, lpLimWd, endIch)
THEN
   BEGIN
   IF FContinuation THEN Exit(SuggestCorrections);
   WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
      IF fWdTooLong(iTitle, lpFstWd, lpLimWd) THEN GOTO 100;
   WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
      HMReturn := HMVerify(iTitle, FALSE);
   IF (HMReturn <> OK) THEN
      BEGIN {See if a period follows the word.
             If so, test the word with the period}
      IF FPeriodAfter(lpLimWd, pintSel^.ics, lpLimPeriod) THEN
         BEGIN
         wordWOPeriod := newWord.word;
         WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
            HMReturn := HMVerify(iTitle, TRUE);
         IF (HMReturn = ok) THEN
            BEGIN
            WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
               iTitle^^ := Concat(iTitle^^, '.');
            IF ftstSpell THEN WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
               writeln('Period added in SuggestCorrections: ', iTitle^^);
            lpLimWd := lpLimPeriod;
            END
         ELSE newWord.word := wordWOPeriod;
         END;
      END;
   IF (HMReturn <> ok) AND (HMReturn <> WordExists) AND (HMReturn <> NotFound) THEN
      BEGIN
      BadReturn(HMReturn, 'SuggestCorrections:VerifyWord');
      GOTO 100;
      END;
   fShowGuesses := TRUE;
   fVerifies := (HMReturn = Ok);
   WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
      paramStr := iTitle^^;
   IF fVerifies THEN
      BEGIN
      ClrGuesses;
      ParamAlert(paramStr, '', '');
      IF (AskAlert(WPAlerts, 63) = retCancel) THEN fShowGuesses := FALSE;
      END;
   IF fShowGuesses THEN
      BEGIN
      IF ftstSpell THEN writeln;
      LSetSel(pintSel^.ics, lpFstWd, lpLimWd);  {Make this word the new selection}
      lastLpFstWd := lpFstWd;  {Remember this new selection and its string}
      lastLpLimWd := lpLimWd;
      lastString := paramStr;
      (* fix later
      SetPort(ActiveFolder);
      SetOrigin(0, 0);
      *)
      IntInWindow(selCur.oint, orecToScroll);
      fAreGuesses := SetFirstGuesses(TRUE);
      IF fAreGuesses THEN PutGuessDbox(HGuessCkForm, 1)
      ELSE PutNoGuessMsg(paramStr, fVerifies);
      END;
   END
ELSE
   BEGIN      {Selection not in a word}
   NoteAlert(WPAlerts, 62);
   END;
{$ifc fDbgOk}
IF fTime THEN
   BEGIN
   mTime := MicroTimer - 135 - mTime;
   writeln('Suggest Corrections took ', mTime, ' usec.');
   END;
{$endc}
100: InitChronicle;  {Suggest Corrections is not undo-able, so make sure that
                      nothing was chronicled for it.}
END;


{$S LWSpFind}

{-------------------------------------------------}
PROCEDURE FindNext;
{-------------------------------------------------}
{Find the next misspelling and select it.}
LABEL 100, 200;
VAR
   lpFstWd, lpLimWd, lpLimPeriod, prevLpFst, prevLpLim, lpStart: TLp;
   fAreGuesses, fAtBeginning: TF;
   ichInWd: TC;
   wordWOPeriod: TSpLetters;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$R-}
ClrGuesses;
beginTime := Timer;
fWaitAlertUp := FALSE;
InitToFindWd;
lpStart := SLpFstPWd(pintSel^.ics, pintSel^.lpLim); {Finds the beginning of the
                                                    word preceeding the one that
                                                    we want.}
IF (lpStart = -1) THEN
   BEGIN  {There were no words preceeding lpLim}
   fAtBeginning := TRUE;
   lpStart := 0;
   END;
REPEAT SetLpd(lpdStd, pintSel^.ics, lpStart, tyset, achadSpell)
   UNTIL (NOT lpdStd^.rce^.fvan) or (lpdStd^.lp = lpdStd^.lpLim);
IF (lpdStd^.lp = lpdStd^.lpLim) THEN GOTO 100; {No non-vanished characters in
                                                stream}
ReplacSpaces(@achadSpell);
ichInWd := achadSpell.ichFst;
WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
IF NOT fAtBeginning THEN GetNxtWd(lpdStd, @achadSpell, ichInWd, lpFstWd,
                                  lpLimWd, iTitle);  {Get the preceeding word}
REPEAT
   BEGIN
   {$ifc fDbgOk}
   IF fTime THEN mTime := microTimer;
   {$endc}
   WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
      GetNxtWd(lpdStd, @achadSpell, ichInWd, lpFstWd,
               lpLimWd, iTitle);      {Find the next word and put its string into
                                       iTitle and its bounding lp's into lpFstWd
                                       and lpLimWd}
   IF (lpLimWd = 0) THEN GOTO 100;   {True if there are no more words in stream}
   WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
      IF fWdTooLong(iTitle, lpFstWd, lpLimWd) THEN GOTO 200;
   {$ifc fDbgOk}
   IF fTime THEN
      BEGIN
      mTime := MicroTimer - 135 - mTime;
      writeln('Find Misspelling took ', mTime,
              ' usec. to find the next word for verification.');
      END;
   {$endc}
   WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
      HMReturn := HMVerify(iTitle, FALSE);
   IF (HMReturn = NotFound) OR (HMReturn = WordExists) THEN
      BEGIN {See if a period follows the word.
             If so, test the word with the period}
      IF ftstSpell THEN
         BEGIN
         {$ifc fDbgOk}
         WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
            writeln(iTitle^^, ' did not verify.  It returned ',
                    ShowReturn (ord(HMReturn))^);
         {$endc}
         END;
      IF FPeriodAfter(lpLimWd, pintSel^.ics, lpLimPeriod) THEN
         BEGIN
         wordWOPeriod := newWord.word;
         WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
            HMReturn := HMVerify(iTitle, TRUE);
         IF (HMReturn = ok) THEN
         WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
            BEGIN
            iTitle^^ := Concat(iTitle^^, '.');
            IF ftstSpell THEN writeln(iTitle^^, ' [with the period] does verify.');
            lpLimWd := lpLimPeriod;
            END
         ELSE newWord.word := wordWOPeriod;
         END;
      ichInWd := 0;
      END;
   END;
fAbortCmd := Abort;
IF NOT fWaitAlertUp THEN IF ((Timer - 135 - beginTime) > waitTime) THEN
   BEGIN {If no other alert is up, put up the wait alert}
   GetWindInfo(alertFolder, wInfo);
   IF NOT wInfo.visible THEN
      BEGIN
      WaitAlert(WPAlerts, 74);
      fWaitAlertUp := TRUE;
      END;
   END;
UNTIL (HMReturn <> Ok) OR fAbortCmd;
IF (HMReturn <> Ok) AND (HMReturn <> WordExists) AND (HMReturn <> NotFound) THEN
   BEGIN
   BadReturn(HMReturn, 'FindNext:VerifyWord');
   GOTO 200;
   END;
IF fWaitAlertUp THEN EndWaitAlert;
IF fAbortCmd THEN
   BEGIN
   NoteAlert(WPAlerts, 73);
   GOTO 200;
   END;
IF ftstSpell THEN writeln;
prevLpFst := pintSel^.lpFst;
prevLpLim := pintSel^.lpLim;
LSetSel(pintSel^.ics, lpFstWd, lpLimWd);  {Make this word the new selection}
Chronicle(pintSel^.ics, lpFstWd, lpLimWd,
          pintSel^.ics, prevLpFst, prevLpLim, hopSelect);
IntInWindow(selCur.oint, orecToScroll);
GOTO 200;

100:
NoteAlert(WPAlerts, 57);

200:
HMReturn := SpTerminate(unbindSegment);
IF (HMReturn <> Ok) THEN BadReturn(HMReturn, 'FindNext:SpTerminate');
END;




{$S LWGuess}

{-------------------------------------------------}
PROCEDURE PasteString(HStr: TStrHnd);
{-------------------------------------------------}
{Replace the currently selected text with the string whose handle is HStr.
 This routine pretends that the characters in the string were typed in, and
 simulates a series of key events to get everything to happen.  If the current
 selection is followed by a period and the string ends in a period, then don't
 insert the last period.}
VAR
   evDsc: TEvDsc;
   i, cCh: TC;
   lpPeriod: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH evDsc DO
   BEGIN
   tyev := tyevInChar;
   fAlphaKey := FALSE;
   fShiftKey := FALSE;
   fAppleKey := FALSE;
   fCodeKey := FALSE;
   fRepeatKey := FALSE;
   fMouseButton := FALSE;
   obox := oboxNil;
   cCh := ORD(HStr^^[0]);
   FOR i := 1 TO cCh DO
      BEGIN
      ch := HStr^^[i];
      IF (i=cCh) AND (ORD(ch) = chPeriod) THEN
         BEGIN
         InitToFindWd;
         IF fPeriodAfter(pintSel^.lpLim, pintSel^.ics, lpPeriod) THEN
            BEGIN
            IF ftstSpell THEN writeln('Not inserting last period in guess.');
            EXIT(PasteString);
            END
         ELSE IF ftstSpell THEN writeln('Inserting last period in guess.');
         END;
      EnqueueLotus(bdsp^.pq^, @evDsc);
      END;
   END;
END (* PasteString *);


{-------------------------------------------------}
PROCEDURE PasteGuess(fAndFind: TF; fWasBtn: TF);
{-------------------------------------------------}
{The user has pushed the "Paste Guess" or the "Paste & Find" button in the
 Suggest Corrections dialog box, or has chosen the "Paste Guess" menu item.
 If fAndFind is TRUE, it was "Paste & Find".  Paste the guess that is checked,
 remove the dialog box, and, if fAndFind, cause the Find Next to happen.  fWasBtn
 is TRUE iff a button was pushed.}
BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   BEGIN
   WITH HGuessCkForm^^.ckBoxLst[1]^^ DO
      PasteString(Pointer(Ord(ckItmLst[curCkItm]^^.iTitle)));
   SetDPort;
   IF fWasBtn THEN
      BEGIN
      IF NOT FAndFind THEN PushButn(butnReplace - 1,FALSE)
      ELSE PushButn(butnRNext - 1,FALSE);
      END;
   ClrGuesses;
   IF fAndFind THEN EnQFindNext;
   END;
END;

{-------------------------------------------------}
PROCEDURE EndGuessDbox {(butnItm: Integer)};
{-------------------------------------------------}
{A button was pushed.  butnItm is the index of the corresponding check item.}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$R-}
CASE butnItm OF
   butnReplace:  PasteGuess(FALSE, TRUE);
   butnRNext:    PasteGuess(TRUE, TRUE);
   butnHide:     ClrGuesses;
   butnShowMore: ShowMore(butnShowMore);
   END;
END;


{$S LWMiscSpell}
{----------------------}
PROCEDURE ClrDict;
{----------------------}
{Implement the Clear Dictionary command}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF CautionAlert(WPAlerts, 70) THEN
   BEGIN
   HMReturn := ZapUser;
   InitChronicle;  {Clear Dictionary is not undo-able, so make sure that
                    nothing was chronicled for it.}
   IF (HMReturn <> Ok) THEN BadReturn(HMReturn, 'ClrDict: ZapUser');
   END;
END;


{$S LWDebug}
{$ifc fDbgOk}

PROCEDURE PxTabs;
{Print out the current tab settings and the left margin.  WARNING: This routine
 does a setLpd with achadSpell and lpdStd, and it sets tyset.fRpe to TRUE.}
VAR
   iTab: TW;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF ftstSpell THEN
   BEGIN
   InitToFindWd;
   tyset.fRpe := TRUE;
   SetLpd(lpdStd, pintSel^.ics, pintSel^.lpFst, tyset, achadSpell);
   WITH lpdStd^.rpe^ DO
      BEGIN
      writeln('Left margin is at ', xLftFst, '.');
      IF (itbLim <= 0) THEN writeln('There are no tabs.')
      ELSE
         BEGIN
         writeln('The number of tabs is ', itbLim, '.');
         FOR iTab := 0 TO itbLim - 1 DO
            WITH argtbd[iTab] DO BEGIN
            writeln('There is a tab at ', x, '.');
            END;
         writeln;
         END;
      END;
   END;
END;
{$endc}



{$S LWMiscSpell}

{----------------------}
PROCEDURE NQMore;
{----------------------}
{Get more words from the Personal Dictionary and enqueue another set of chars.
 Set fMoreToQ to TRUE iff there will still be more words to come after these
 are assimilated.  If the global variable fSetTabs is TRUE, begin by setting
 the tab stops for the dictionary output.}
CONST
   cWordsMax = 3; {No. of words to queue up in one call to this routine}
   cLineMax = 3;  {No. of words to put on a line}
   tabSpacing = 200;
VAR
   spWord: TSpWord;
   cWordsNow: TC;
   cWordsLine: TC;
   HStr: TStrHnd;
   PStr: TStrPtr;
   tbd: TTbd;

   PROCEDURE DoSetTabs;
   {Set the tabs for the current selection to the standard ones for dictionary
    output.}
   VAR
      iTab: TW;
   BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   {$ifc fDbgOk}
   IF ftstSpell THEN BEGIN writeln('Before clearing tabs,'); PxTabs; END;
   {$endc}
   InitToFindWd;
   tyset.fRpe := TRUE;
   SetLpd(lpdStd, pintSel^.ics, pintSel^.lpFst, tyset, achadSpell);
   WITH lpdStd^.rpe^, tbd DO
      BEGIN
      {First clear any tabs that are set}
      FOR iTab := 0 TO itbLim - 1 DO
         DoParFop(ifldClrTab, 0, @argtbd[iTab]);
      {$ifc fDbgOk}
      IF ftstSpell THEN BEGIN writeln('After clearing tabs,'); PxTabs; END;
      {$endc}
      {Now set the two standard tab stops}
      quad := quadL;
      tyfill := tyfillNil;
      x := xLftFst + tabSpacing;
      DoParFop(ifldXtb, 0, @tbd);
      x := x + tabSpacing;
      DoParFop(ifldXtb, 0, @tbd);
      {$ifc fDbgOk}
      IF ftstSpell THEN BEGIN writeln('After setting tabs,'); PxTabs; END;
      {$endc}
      END;
   END;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fSetTabs THEN
   BEGIN
   DoSetTabs;
   fSetTabs := FALSE;
   END;
cWordsNow := 0;
cWordsLine := 0;
REPEAT
   BEGIN
   HMReturn := GetUserWord(spWord, byteNum);
   fAbortCmd := Abort;
   IF (HMReturn = Ok) AND NOT fAbortCmd THEN
      BEGIN
      IF ftstSpell THEN writeln(spWord.word);
      cWordsNow := cWordsNow + 1;
      cWordsLine := cWordsLine + 1;
      IF (cWordsLine = cLineMax) THEN cWordsLine := 0;
      PStr := @spWord.word;
      HStr := @PStr;
      PasteString(HStr);
      IF (cWordsLine = 0) THEN PasteString(HRetStr)
      ELSE PasteString(HTabStr);
      END;
   END
UNTIL (HMReturn <> Ok) OR (cWordsNow >= cWordsMax) OR fAbortCmd;
IF (HMReturn <> Ok) OR fAbortCmd THEN IF fWaitAlertUp THEN EndWaitAlert;
IF fAbortCmd THEN
   BEGIN
   fMoreToQ := FALSE;
   NoteAlert(WPAlerts, 77);
   EXIT(NQMore);
   END;
IF (HMReturn = Ok) THEN fMoreToQ := TRUE
ELSE IF (HMReturn = LimitExceeded) THEN
   BEGIN
   IF (cWordsLine > 0) THEN PasteString(HRetStr);
   fMoreToQ := FALSE;
   END
ELSE
   BEGIN
   BadReturn(HMReturn, 'NQMore:GetUserWord');
   fMoreToQ := FALSE;
   END;
InitChronicle; {Make sure that Write Dictionary is not perceived to be undoable.}
END;



{----------------------}
PROCEDURE WriteDict;
{----------------------}
{Handle Write Dictionary to Document command.}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$ifc fDbgOk}
IF ftstSpell THEN
   BEGIN
   writeln('Before inserting <SPACE><BACKSPACE>,');
   PxTabs;
   END;
{$endc}
GetWindInfo(alertFolder, wInfo);
IF NOT wInfo.visible THEN
   BEGIN
   WaitAlert(WPAlerts, 78);
   fWaitAlertUp := TRUE;
   END
ELSE fWaitAlertUp := FALSE;
PasteString(HSpaceStr);{Enqueue a tyevInChar event with a <SPACE>}
PasteString(HBackStr);{Enqueue a tyevInChar event with a <BACKSPACE>}
fSetTabs := TRUE;
fMoreToQ := TRUE;   {After UnitLotus has inserted the <RETURN> it will call NQMore}
byteNum := userStartByte;
END;



{----------------------}
PROCEDURE PutInDict(fPut: TF);
{----------------------}
{If fPut is TRUE, handle the Put In Dictionary command: put all words within
 the selection into the Personal Dictionary.  If fPut is FALSE, handle the
 Remove From Dictionary command: remove all words within the selection from the
 Personal Dictionary.}
LABEL 100;
VAR
   limLp: TLp;
   lpFstWd, lpLimWd: TLp;
   fDone, fFstWd: TF;
   theIch: TC;
   spWord: TSpWord;
   cWords: integer;
   wdLen: integer;
   lpLimPeriod: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
beginTime := Timer;
fWaitAlertUp := FALSE;
InitToFindWd;
   BEGIN
   limLp := pintSel^.lpLim;
   fDone := FALSE;
   fFstWd := TRUE;
   spWord.hyphens := emptyMask;
   IF FGetThisWd(pintSel^.lpFst, pintSel^.lpLim,
                 HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^.iTitle,
                 lpFstWd, lpLimWd, theIch)
   THEN IF (lpFstWd < limLp) THEN
   REPEAT
      BEGIN
      WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
         BEGIN
         wdLen := ORD(iTitle^^[0]);
         IF (wdLen > maxWordLength) THEN iTitle^^[0] := chr(maxWordLength);
         spWord.word := iTitle^^;
         END;
      fAbortCmd := Abort;
      IF NOT fAbortCmd THEN
         BEGIN
         MinusToHyphen(spWord.word);
         IF fPut THEN
            BEGIN
            IF FPeriodAfter(lpLimWd, pintSel^.ics, lpLimPeriod) THEN
               spWord.word := Concat(spWord.word, '.');
            theIch := 0;
            IF ftstSpell THEN writeln(spWord.word);
            HMReturn := AddUserWord(spWord, fFstWd, cWords);
            fFstWd := FALSE;
            IF (HMReturn = LimitExceeded) THEN
               NoteAlert(WPAlerts, 83) {Dictionary full}
            ELSE IF (HMReturn <> Ok) AND (HMReturn <> WordExists) THEN
               BEGIN
               BadReturn(HMReturn, 'PutInDict:AddUserWord');
               IF ftstSpell THEN
                  writeln('AddUserWord was called for ', spWord.word);
               GOTO 100;
               END
            END
         ELSE
            BEGIN
            HMReturn := DelUserWord(spword, fFstWd, cWords);
            fFstWd := FALSE;
            {$ifc fDbgOk}
            IF ftstSpell THEN writeln(spWord.word);
            IF ftstSpell THEN writeln('DelUserWord returned ',
                                      ShowReturn (ord(HMReturn))^);
            {$endc};
            IF (HMReturn <> Ok) AND (HMReturn <> NotFound) THEN
               BEGIN
               BadReturn(HMReturn, 'PutInDict:DelUserWord');
               IF ftstSpell THEN
                  writeln('DelUserWord was called for ', spWord.word);
               GOTO 100;
               END;
            END;
         END;
      fDone := (lpLimWd >= limLp) OR fAbortCmd; {Done if this word ends at or
                                                 beyond the end of the selection,
                                                 or if we've been aborted.}
      IF NOT fDone THEN
         BEGIN
         WITH HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[0]^^ DO
         GetNxtWd(lpdStd, @achadSpell, theIch, lpFstWd,
                   lpLimWd, iTitle);  {Find the next word and put its string into
                                       iTitle and its bounding lp's into lpFstWd
                                       and lpLimWd}
         IF (lpLimWd = 0) OR (lpFstWd >= limLp) THEN fDone := TRUE;{True if
                                                                    there are no
                                                                    more words
                                                                    in stream}
         IF NOT fWaitAlertUp THEN IF ((Timer - 135 - beginTime) > waitTime) THEN
            BEGIN {If no other alert is up, put up the wait alert}
            GetWindInfo(alertFolder, wInfo);
            IF NOT wInfo.visible THEN
               BEGIN
               IF fPut THEN WaitAlert(WPAlerts, 76)
               ELSE WaitAlert(WPAlerts, 85);
               fWaitAlertUp := TRUE;
               END;
            END;
         END;
      END
   UNTIL fDone;
   IF fWaitAlertUp THEN EndWaitAlert;
   InitChronicle; {Ensure that nothing has been chronicled yet}
   IF fAbortCmd THEN
      BEGIN
      IF NOT fFstWd THEN HMReturn := UndoUserWord(fPut, cWords);
      IF (HMReturn <> Ok) AND (HMReturn <> WordExists) THEN
         BEGIN
         BadReturn(HMReturn, 'PutInDict:UndoUserWord');
         GOTO 100;
         END;
      IF fPut THEN NoteAlert(WPAlerts, 75)
      ELSE NoteAlert(WPAlerts, 84);
      END
   ELSE IF NOT fFstWd THEN
      BEGIN
      IF fPut THEN Chronicle(icsNil, 0, 0, icsNil, 0, 0, hopPutDict)
      ELSE Chronicle(icsNil, 0, 0, icsNil, 0, 0, hopRmvDict);
      END;
   END;
100:
HMReturn := SpTerminate(unbindSegment);
IF (HMReturn <> Ok) THEN BadReturn(HMReturn, 'PutInDict:SpTerminate');
END;


{----------------------}
PROCEDURE UndoPutDict{(fUndoUndo: TF)};
{----------------------}
{The user has chosen "Undo" of "Put in Dictionary".  If fUndoUndo is TRUE, then
 this is an undo of an undo of "Put in Dictionary".}
 VAR
    cWords: integer;
 BEGIN
 {$IFC sampcalls}  ALogCall;  {$ENDC}
 HMReturn := UndoUserWord(NOT fUndoUndo, cWords);
 IF (HMReturn <> Ok) AND (HMReturn <> WordExists) THEN
    BEGIN
    BadReturn(HMReturn, 'UndoPutDict:UndoUserWord');
    Exit(UndoPutDict);
    END;
 IF fUndoUndo THEN NoteAlert(WPAlerts, 87)
 ELSE NoteAlert(WPAlerts, 88);
 END;


{----------------------}
PROCEDURE UndoRmvDict{(fUndoUndo: TF)};
{----------------------}
{The user has chosen "Undo" of "Remove from Dictionary".  If fUndoUndo is TRUE,
 then this is an undo of an undo of "Remove from Dictionary".}
 VAR
    cWords: integer;
 BEGIN
 {$IFC sampcalls}  ALogCall;  {$ENDC}
 HMReturn := UndoUserWord(fUndoUndo, cWords);
 IF (HMReturn <> Ok) AND (HMReturn <> WordExists) THEN
    BEGIN
    BadReturn(HMReturn, 'UndoRmvDict:UndoUserWord');
    Exit(UndoRmvDict);
    END;
 IF fUndoUndo THEN NoteAlert(WPAlerts, 89)
 ELSE NoteAlert(WPAlerts, 90);
 END;


{$S LWCreate}
{----------------------}
PROCEDURE SetHzSpell {(hz: Thz)};
{----------------------}
{Remember the hz for the Spelling Checker and mark that the Spelling Checker
 has not yet been initialized.  Disable the "Paste & Guess" menu item.}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF ftstSpell THEN writeln('UnitSpell:SetHzSpell called');
spellInitialized := FALSE;
hzSpell := hz;
theDBox.isOpen := FALSE;
fMoreToQ := FALSE;
DisableItem(argMenu[imtdSpell], imidPGuess);
IF ftstSpell THEN writeln('*****PasteGuess menu item disabled');
{$IFC fDbgOk}
testSpell := false;
TestInit;
{$ENDC}
END;


{$S LWSpInit}

{----------------------}
FUNCTION startSpelling: TF;
{----------------------}
(*Init Houghton-Mifflin's spelling software.  If something goes wrong, give an
 appropriate alert and return FALSE.  If all goes well, read in all dialog box
 check forms from {T1}Dbox.text, set up some constant strings for later use,
 and return TRUE.*)
CONST
    chTab = 9;
    chRet = 13;
VAR spDbox:  TSp;
    filDbox: TEXT;
    formSize, i: Integer;
    HCkBox: TCkBoxHnd;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$IFC fDbgOk}
fTime := FALSE; {TEMPORARY for timing}
{$ENDC}
{Init H-M's spelling routines}
startSpelling := DoHMInit;
{Set up all Dialog Box Info}
InitDmgr(btnsLim);
spDbox := CONCAT(spLotusPrefix, '{T1}DBOX.TEXT');
RESET(filDbox, spDbox);
IF IOResult <> 0 THEN Break(1530);
{Read in the check form info for the spelling dialog boxes}
SetDPort;
{The "Guesses" dialog box:}
formSize := SizeOf(TCkFormInfo) + CCkBGuess * SizeOf(TCkBoxPtr);
HGuessCkForm := Pointer(Ord(HAllocate(hzSpell, formSize)));
FOR i := 0 to CCkBGuess DO
   BEGIN
   ReadCkBox(filDbox, HCkBox, TRUE);
   HGuessCkForm^^.ckBoxLst[i] := HCkBox;
   END;
{ReadCkBox initialized DrawProc and HitTstFunc for all ckBox-es, assuming
 that they were check boxes, not buttons.  Set the procs for the buttons.}
WITH HGuessCkForm^^.ckBoxLst[0]^^ DO
   BEGIN
   DrawProc := @ShowCkBtn;
   HitTstFunc := @CkBtnHit;
   END;
HShowMore := HGuessCkForm^^.ckBoxLst[0];
HGuessCkForm^^.numCkBox := CCkBGuess;
CkFormHeight(HGuessCkForm);
{Remember the right boundaries of the hit boxes for the first column of guesses
 in the Guesses dialog box.}
rightOfWideCol := HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[1]^^.hitBox.right;
rightOfNarrowCol :=
   HGuessCkForm^^.ckBoxLst[1]^^.ckItmLst[oneColGuessesMax + 1]^^.hitBox.left - 5;
curHBtnGrp := HShowMore;
{The "Just Hide" set of buttons:}
ReadCkBox(filDbox, HJustHide, TRUE);
WITH HJustHide^^ DO
   BEGIN
   DrawProc := @ShowCkBtn;
   HitTstFunc := @CkBtnHit;
   END;
CLOSE(filDbox);
{Set up some constant strings for use later...}
RetStr[0] := chr(1);
RetStr[1] := chr(chRet);
PRetStr := POINTER(ORD(@RetStr));
HRetStr := @PRetStr;
TabStr[0] := chr(1);
TabStr[1] := chr(chTab);
PTabStr := POINTER(ORD(@TabStr));
HTabStr := @PTabStr;
SpaceStr[0] := chr(1);
SpaceStr[1] := chr(chSpace);
PSpaceStr := POINTER(ORD(@SpaceStr));
HSpaceStr := @PSpaceStr;
BackStr[0] := chr(1);
BackStr[1] := chr(chBs);
PBackStr := POINTER(ORD(@BackStr));
HBackStr := @PBackStr;
hyphenStr[0] := chr(1);
hyphenStr[1] := chr(chRealHyphen);
END;

{$S LWSpFind}
{-------------------------------------------------}
PROCEDURE DoSpellImid {(imid: TC; orecActive: TC)};
{-------------------------------------------------}
{$IFC fDbgOk}
VAR
   answer: string[4]; {TEMP for debugging}
   fDone: Boolean;    {TEMP for debugging}
   ch:    string[1];  {TEMP for debugging}
   newLp: TLp;        {TEMP for debugging}
{$ENDC}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$IFC fDbgOk}
IF (imid <> imidDbug) THEN
   BEGIN
{$ENDC}
   IF NOT spellInitialized THEN spellInitialized := startSpelling;
   IF NOT spellInitialized THEN EXIT(DoSpellImid);
{$IFC fDbgOk}
   END;
{$ENDC}
{Is the search dialog box up now?
 If so, remove it now so that the selection will revert back to the
 active document}
IF (FWhatsUp <> tyGuesses) THEN RmvAnyDbox;

orecToScroll := orecActive;
CASE imid OF
  imidFMisspell,
  imidAndFind:
     BEGIN
     FindNext;
     END;
  imidSuggest:
     BEGIN
     SuggestCorrections;
     END;
  imidPGuess:
     BEGIN
     PasteGuess(FALSE, FALSE);
     END;
  imidPut:
     BEGIN
     ClrGuesses;
     PutInDict(TRUE);
     END;
  imidRmv:
     BEGIN
     ClrGuesses;
     PutInDict(FALSE);
     END;
  imidWriteDict:
     BEGIN
     ClrGuesses;
     WriteDict;
     END;
  imidClrDict:
     BEGIN
     ClrGuesses;
     ClrDict;
     END;
{$IFC fDbgOk}
  imidDbug:
     BEGIN
     SetTestOptions;
     IF ftstSpell THEN
        BEGIN
        write('Turn off spelling test flag? Y or N: ');
        readln(answer);
        IF (answer = 'y') OR (answer = 'Y') THEN ftstSpell := FALSE;
        END;
     write('Turn timing "on" or "off"?');
     readln(answer);
     IF (answer = 'on') OR (answer = 'ON') OR (answer = 'On')
        THEN fTime := TRUE
        ELSE fTime := FALSE;
     write('Try SLpFstPWd? Y or N: ');
     readln(answer);
     IF (answer = 'y') OR (answer = 'Y') THEN
        BEGIN
        InitToFindWd;
        newLp := SLpFstPWd(pintSel^.ics, pintSel^.lpFst);
        writeln('SLpFstPWd(', ORD(pintSel^.lpFst), ') is ', ORD(newLp));
        LSetSel(pintSel^.ics, newLp, newLp);
        END;

(*
     write('Get character codes? Y or N: ');
     readln(answer);
     IF (answer = 'y') OR (answer = 'Y') THEN
        BEGIN
        writeln('This program gives the Ascii char codes for the keyboard');
        writeln(' characters');
        writeln(' that you type.  When you are all done, just type <CR>.');
        writeln;
        fDone := FALSE;
        REPEAT
           write('Type one keyboard character, followed by <CR>:');
           readln(ch);
           IF (ch='') THEN fDone := TRUE
           ELSE writeln('ORD(',ch,') = ', ORD(ch[1]));
           writeln;
        UNTIL fDone;
        writeln('chHyphen is ', chHyphen);
        END;
*)
     END;
     {$ENDC}
 END (* CASE *);
END (* DoSpellImid *);

END.
