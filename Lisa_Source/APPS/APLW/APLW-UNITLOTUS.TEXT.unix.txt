{$I APLW/COMPFLAGS }                                            {gdf 1/16/84}
{$R-}

UNIT UnitLotus;

(* Copyright 1983, 1984, Apple Computer Inc. *)

{ med   6884 added ValidateDsp in Show Page Ruler for short ruler bug}
{ med  3-29-84 -- fedited (dirty bit)}
{ med  3-19-84 -- combine Print and Print_As_Is}
{ gdf   3/1/84 -- insert trace calls for segmentation (using Janis' version) }
{ gdf   2/1/84 -- fix printing }
{ gdf  1/23/84 -- fix printing defaults for screen only  }
{ gdf  1/16/84 -- printing compile flag & include COMPFLAGS added }
{ crc  4/18/83 -- StopAlert if error while restoring previous version }
{ tjm  4/18/83  --  Alert #29 }
{ crc  4/15/83 -- RestardDocument & RevertNew: copy thru LENGTH of title only }
{ tjm  4/06/83  --  RemoveKid(fSaveKid) - (WP 258) }
{ tjm  3/31/83 -- in DoMenuCommand - check for cssAbsMax }
{ tjm  3/29/83 -- in DoScNew - check for orecNil }
{ tjm  3/24/83 -- in DoScNew (WP 235) }
{ tjm  3/24/83 -- FAdjFront in DoScResize (WP 263) }
{ tjm  3/14/83 -- Export SuspendDocument }
{ crc  3/11/83 -- Added cErrDocTooNew for OpenDocument }
{ tjm  3/09/83 -- Call FreePrompt from imidPutBack }
{ crc  3/09/83 -- Error writelns in SuspendDoc & RestartDoc only if fDbgOk true;
                  Immediate IntInWindow for tyevDwn }
{ crc  3/04/83 -- HandleLotusEvent: set fForceSelInWw on tyevDwn;
                  ScrollScid: repaint thumb only if percentage changes }
{ crc  3/01/83 -- DoMenuCommand: Str255 parm to ParmAlert }
{ crc  2/22/83 -- HandleLotusEvent: call MoveRm for dbl & triple clicks (WP212) }
{ crc  2/22/83 -- DoMenuCommand & SetOrecIns: set orecConDwn from OrecConFromIcs
                  instead of from orecConFst field of icsSel (WP208) }
{ crc  2/09/83 -- HandleLotusEvent: tyevScroll & tyevPScroll: fix to alert box
                  dismissal by scrolling }
{ crc  2/08/83 -- Document name parmameter to alerts }
{ crc  1/17/83 -- Combined logic for tyevDwn, tyevDblClick & tyevTripleClick }
{ crc  1/11/83 -- Alerts on errors from print manager }
{ crc  1/06/83 -- moved part of seg Lotus into SegLot1 }
{ jrm 12/16/82 -- added RemoveKid call to SelectAll }
{ crc 12/13/82 -- added StripExtension(path) to imidRevert in DoMenuCommand }
{ crc 12/10/82 -- RevertToOrig sets prprf & part of pglp of icsEd }
{ crc 11/29/82 -- imidRevert in DoMenuCommand fixed for tycsPg IcsActive }
{ crc 11/15/82 -- Streamlined filer protocols }
{ crc 11/11/82 -- tyevDfClose modified to handle scrap properly }
{ crc 11/11/82 -- Time of last version in Revert to Previous }
{ jrm 11/10/82 -- added InitChronicle call before MovedRm call}
{ jrm 11/ 3/82 -- called DisplaySubImtd(imtdNil) for tyevPaneKill }
{ jrm 10/15/82 -- moved imtdPrv, imidPrv to UnitCom }
{ crc 10/12/82 -- Printing in Progress...; UpdateThumbs checks current pos }
{ crc 10/04/82 -- Revert-to-previous-version gets last saved/put-back version }
{ crc  9/30/82 -- Fix to UpdateThumbs; Save & Continue writes perm file }
{ crc  9/29/82 -- ThumbOboxPct calls LpLstCr instead of LpMacEd }
{ crc  9/27/82 -- UpdateThumbs called in idle case of HandleLotusEvent }
{ crc  9/24/82 -- added tyevDShred }
{ jrm  9/22/82 -- added FreePrompt calls to Print and Printer Pref action }
{ crc  9/17/82 -- IcsConFromPane(...) ==> IcsEdFromPane(...) in SuspendDocument
                  and HandleLotusEvent; imidSelectAll doesn't call IcsActive;
                  tyevDPut }
{ crc  9/17/82 -- HzLotus initially 12288 bytes.
{ bas  9/13/82 -- fix thumb for DoScNew, DoScResize }
{ jrm  9/ 7/82 -- added fPaintPane parameter to OboxOpenWindow and OpenDocument
}
{ jrm  8/30/82 -- added auto scroll to tyevMove }
{ jrm  8/25/82 -- reset orecConDwn for tyevMove }
{ crc  8/23/82 -- fix to imidSavAndCont; 'DOC' extension no longer appended
                  to pathnames }
{ crc  8/20/82 -- imidSavAndCont added to DoMenuCommand; Suspend & Resume
                  abort on errors.
{ crc  8/18/82 -- fix to call TakeWindow when opening monitor-resident document
}
{ crc  8/17/82 -- fixed RevertToOrig; UnitFile error codes and addt'l parms }
{ jrm  8/10/82 -- tyevDOpen => tyevResume }
{ crc  8/10/82 -- Added parm to InitAlerts }
{ jrm  8/10/82 -- changed CaretDelay to caretOnTime, caretOffTime ( rather like
                  our old ctickOnCaret and ctickOffCaret........ ) }
{ crc  8/ 4/82 -- Error codes from UnitFile }
{ jrm  8/ 4/82 -- RevertToOrig }
{ jrm  8/ 3/82 -- moved more stuff to LotusMisc }
{ bas  7/20/82 -- no fUpdate parm to FreeObox }
{ jrm  7/ 2/82 -- replaced ctickOnCaret, ctickOffCaret by caretDelay; removed
trayMenu
                  reference; fixed print refs }
{ crc  6/30/82 -- Added parameters to InitAlerts and ReadAlerts; cAlertVersion
}
{ crc  6/30/82 -- Cleaned up after MacMillan (again!) }
{ jrm  6/29/82  --  USES changes: LisaGraf => QuickDraw; moved USES UnitFile }
{ jrm  6/30/82 -- moved some stuff to LotusMisc }
{ crc  6/08/82 -- tyevDClose and tyevDOpen }
{ jrm  6/ 4/82 -- added InitFfForLotus }
{ crc  6/02/82 -- Conditional compilation }
{ crc  6/01/82 -- Calls InitSrch }
{ crc  5/27/82 -- (UN)Preview now removes page ruler sub-menu }
{ jrm  5/26/82 -- removed prcsMine and prcs references }
{ crc  5/21/82 -- integration with Print Manager; moved IcsConFromPane to
                  UnitRec; tyxyTld => TyxyTld(ics); copy prprf in preview }
{ crc  5/12/82 -- renamed InitScrap as InitLScrap; inserted TakeWindow }
{ crc  5/10/82 -- keeping original file accessible after put-back }
{ crc  4/06/82 -- integration with new font manager }
{ crc  3/26/82 -- alert mgr integration}
{ bas  3/19/82 -- orec tyxy }
{ jrm  3/16/82 -- filer stub integration }
{ bas  3/16/82 -- DoScResize }
{ bas  2/25/82 -- tyevUpdate }
{ bas  2/12/82 -- lisaprint }
{ bas  2/02/82 -- tyxyIP -> tyxyTld }
{ jrm  1/28/82 -- integration with new menumgr }
{ bas 01/22/82 -- upgrade to new boxmgr, unitfolder }
{ bas 01/13/82 -- new Print for lisaprint; integrate with new WM }
{ bas 12/10/81 -- integration with font manager }
{ Last edit: ORD4(cBlk) used in OpenDocument. }


INTERFACE

USES
    {$IFC sampcalls}                                               {gdf 2/24/84}
       {$U aplw/tracecalls.obj} tracecalls,
    {$ENDC}
    {$U Obj:UnitStd.Obj }    UnitStd,
    {$U LibOS/Syscall.Obj }   Syscall,
    {$U Obj:UnitHz.Obj }     UnitHz,
    {$U Obj:UnitFile.Obj }   UnitFile,
    {$U Obj:Storage.Obj }    Storage,
    {$U Obj:QuickDraw.Obj }  QuickDraw,
    {$U Obj:FontMgr.Obj  }   FontMgr,
    {$U Obj:Wm.Events.Obj  } Events,
    {$U Obj:Wm.Folders.Obj } Folders,
    {$U Obj:Wm.Menus.Obj }   Menus,
    {$U Obj:WmlStd     }     WmlStd,
    {$U Obj:WmlCrs     }     WmlCrs,
    {$U Obj:PmDecl       }   PmDecl,
     {$IFC fPrintOld}                                               {gdf 1/16/84}
        {$U Obj:PrStd.Obj }     PrStd,
        {$U Obj:PrFile.Obj }    PrFile,
        {$U Obj:PrProcs.Obj }   PrProcs,
        {$U Obj:PrMgrUtil.Obj } PrMgrUtil,
        {$U Obj:PrMgr.Obj }     PrMgr,
     {$ELSEC}
        {$U Obj:PrStdInfo.Obj } PrStdInfo,
        {$U Obj:PrPublic.Obj }  PrPublic,
     {$ENDC}                                                        {gdf 1/16/84}
    {$U Obj:Filercomm.Obj }  Filercomm,
    {$U Obj:UnitFmt.Obj }    UnitFmt,
    {$U Obj:UnitCs.Obj }     UnitCs,
    {$U Obj:UnitFf.Obj }     UnitFf,
    {$U Obj:Scrap.Obj }      Scrap,
    {$U Obj:AlertMgr }       AlertMgr,
    {$u hwInt.obj }              hwInt,
    {$U ApLW/Queue.Obj }      Queue,
    {$U ApLW/UnitBox.Obj }    UnitBox,
    {$U ApLW/UnitUs.Obj }     UnitUs,
    {$U ApLW/UnitUf.Obj }     UnitUf,
    {$U ApLW/UnitEd.Obj }     UnitEd,
    {$U ApLW/UnitEdit.Obj }   UnitEdit,
    {$U ApLW/UnitFm.Obj }     UnitFm,
    {$U ApLW/UnitKid.Obj }    UnitKid,
    {$U ApLW/UnitRec.Obj }    UnitRec,
    {$U ApLW/UnitOver.Obj }   UnitOver,
    {$U ApLW/UnitTld.Obj }    UnitTld,
    {$U ApLW/UnitFigAtom.Obj }     UnitFigAtom,
    {$U ApLW/UnitFigImage.Obj }     UnitFigImage,
    {$U ApLW/UnitDsp.Obj }    UnitDsp,
    {$U ApLW/UnitSel.Obj }    UnitSel,
    {$U ApLW/UnitScrap.Obj }  UnitScrap,
    {$U ApLW/UnitRuler.Obj }  UnitRuler,
    {$U ApLW/UnitPg.Obj }     UnitPg,
    {$U ApLW/UnitPrt.Obj }    UnitPrt,
    {$U ApLW/UnitCom.Obj }    UnitCom,
    {$U ApLW/UnitSrch.Obj }   UnitSrch,
    {$U ApLW/BoxScid.Obj }    BoxScid,
    {$U ApLW/UnitFolder.Obj } UnitFolder,
    {$U ApLW/UnitLDialog.Obj } UnitLDialog,
    {$U ApLW/Dmgr.Obj }       Dmgr,
    {$u aplw/sp/spelling.obj }    spelling,
    {$u aplw/sp/verify.obj }      SpVerify,
    {$U ApLW/UnitSpell.Obj }  UnitSpell,
    {$U ApLW/EventMgr.Obj }   EventMgr;

{$setc fEdSuspend = false}

{$IFC NOT fDbgOk}
CONST
    fTstLotus = FALSE;
{$ENDC}

{$IFC fDbgOk}
VAR
   fTstLotus: TF;
{$ENDC}

PROCEDURE Undo(fUndoUndo: TF);
PROCEDURE InitLotus;
PROCEDURE LInitAlert;
PROCEDURE OpenDocument(VAR cError: TC; spTitle: TSp; path: Pathname;
                       window: TWindow; fPaintPane: TF; fCreate: TF;
                       password: E_name);
PROCEDURE HandleLotusEvent
          (VAR evDsc: TEvDsc; VAR actArea: TActArea; VAR ctickTimeout: TC);

PROCEDURE SuspendDocument(VAR cError, oboxTab: TC; fTemp: TF);
FUNCTION IcsBodyOfIcs(ics: TB): TB;

IMPLEMENTATION

{$IFC fSymOK }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

CONST dxScroll = 16;
     dyScroll = 10;
     cAlertVersion = 2;
     ctickFstTimeout = 10;
     cErrDocTooNew = 5000;
     cErrDocEmpty = 5001;

     chBackspace  =  8;
     chClear      = 27;
     chEnter      =  3;

VAR hzLotus: THz;
    icsCr, icsDwn: TB;
    aport: TAport;
    orecConDwn:    TC;
    fPrvTimeout: TF;
    fUndoLst: TF;
    fForceSelInWw: TF;
    orecIns: TC;
    ichIns: TC;
    fGenOrec: TF;

(*$I ApLW/LOTUSMISC.TEXT *)


{$S LWMisc}
{---------------------------}
PROCEDURE SelectAll(ics: TB);
{---------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
   IF ics <> icsNil THEN
      BEGIN
      RemoveKid(TRUE);
      LSetSel(ics, 0, LpMacEd(ics));
      END;
END;

{$S LWEdited}
{--------------------------------}
PROCEDURE FreeOOfIcs(icsCon: TB);
{--------------------------------}
VAR orecCon, orecSib: TC;
    rec: TRec;
    pint: TPint;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
orecCon := dsp^.orecConRoot;
WHILE orecCon <> orecNil DO
   BEGIN
   rec := POINTER(ORD(dsp) + orecCon);
   pint := POINTER(ORD(lldInt) + rec^.ointDep);
   IF pint^.ics = icsCon THEN
      BEGIN
      IF rec^.foPrnt.fObox THEN FreeObox(rec^.foPrnt.o);
      orecSib := OrecSibFree(orecCon);
      IF orecSib <> orecNil THEN Break(1603); (* if there are any sibs, I
           haven't cleaned up enough in DiscardFolder *)
      END;
   orecCon := rec^.orecNxtCon;
   END;
END (* FreeOOfIcs *);

{------------------------------------}
PROCEDURE DiscardFolder(oboxTab: TC);
{------------------------------------}
VAR pbox, pboxTab, pboxFstPane: TPbox;
    oboxFstPane: TC;
    oboxNxtTab: TC;
    obox: TC;
    oboxNxt: TC;
    orecCon: TC;
    ics: TB;
    rec: TRec;
    pint: TPint;
    icsCon: TB;
    window: TWindow;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
oboxNxtTab := OboxNxtFolder(oboxTab);

   (* discard any ruler *)

DisplayFstSubImtd(imtdNil);

   (* get out of preview *)

pboxTab := PboxFromObox(oboxTab);
window := pboxTab^.window;
oboxFstPane := pboxTab^.oboxNxt;
Preview(oboxFstPane, FALSE);

   (* discard the selection... I assume that oboxTab = oboxActive and that
      the selection must be in this folder... *)

LSetSel(icsNil, 0, 0);

   (* free boxes, recs, and the cs *)

pboxFstPane := PboxFromObox(oboxFstPane);
rec := POINTER(ORD(dsp) + pboxFstPane^.refCon);
pint := POINTER(ORD(lldInt) + rec^.ointDep);
icsCon := pint^.ics;
FreeOOfIcs(icsCon);
FreeIcs(icsCon);
obox := oboxTab;
WHILE obox <> oboxNxtTab DO
     BEGIN
     pbox := PboxFromObox(obox);
     oboxNxt := pbox^.oboxNxt;
     FreeObox(obox);
     obox := oboxNxt;
     END;
IF FidOfWindow(window) <> oboxNil THEN Break(1601);

END (* DiscardFolder *);

{--------------------------------------------}
PROCEDURE KillDoc(cError: TC; path: Pathname; password: E_name);
{--------------------------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
KillFile(cError, path, password);
KillFile(cError, CONCAT(path, '.Figures'), password);
END;

{$S LWOpen}
{--------------------------------------------}
PROCEDURE RenameDoc(cError: TC; pathOld: Pathname; enameNew, password: E_name);
{--------------------------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
RenameFile(cError, pathOld, enameNew, password);
RenameFile(cError, CONCAT(pathOld, '.Figures'), CONCAT(enameNew, '.Figures'),
           password);
END;


{$S LWSave}
{-------------------------------}
PROCEDURE RevertNew(oboxTab: TC);
{-------------------------------}
VAR
   pboxTab: TPbox;
   spTitle: TSp;
   path:    Pathname;
   password:    E_name;
   window:  TWindow;
   cError:  TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
   pboxTab := PboxFromObox(oboxTab);
   spTitle := CONCAT(pboxTab^.hspTitle^^);  {only LENGTH(hspTitle^^) chars exist!}
   PathOfOboxTab(oboxTab, path, password);
   StripExtension(path);
   window := pboxTab^.window;
   DiscardFolder(oboxTab);
   OpenDocument(cError, spTitle, path, window, TRUE (* paint the pane *), FALSE, password);
   MakeFolderActive(FidOfWindow(window), FALSE);
END; {RevertNew}

{-----------------------------------}
PROCEDURE RevertToOrig(oboxTab: TC);
{-----------------------------------}
VAR icsEd, icsSource, icsHdr, icsFtr: TB;
    pcsed: TPcsed;
    ffleader: TFfLeader;

{$IFC fPrintOld}                                                    {gdf 1/16/84}

    prprf: TPrprf;

{$ELSEC}                                                            {gdf 1/16/84}

    prprf: TPrRec;

{$ENDC}                                                             {gdf 1/16/84}

    lpHdrFst, lpFtrFst, lpFstSource, lpLimSource: TLp;
    pbox: TPbox;
    path: String255;
    password:    E_name;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
   IF IcsActive <>  icsNil THEN
      BEGIN
        (* discard any ruler *)
      RemoveKid(TRUE);
      DisplayFstSubImtd(imtdNil);

        (* get out of preview *)
      pbox := PboxFromObox(oboxActive);
      Preview(pbox^.oboxNxt, FALSE);

        (* start over with the original file contents *)
      icsEd := IcsActive;
      OrigPathOfIcsEd(icsEd, path, password);
      IF POS('TEMP', path) > 0 THEN RevertNew(oboxTab)
      ELSE BEGIN
          pcsed := POINTER(ORD(rghcs^[icsEd]^));
          icsSource := pcsed^.icsOrig;
          icsHdr := pcsEd^.pglp.icsHdr;
          icsFtr := pcsEd^.pglp.icsFtr;
          IF rghcs^[icsSource]^^.tycs = tycsFf THEN
             BEGIN
             GetLeaderOfIcsFf(icsSource, ffleader);
             pcsed := POINTER(ORD(rghcs^[icsEd]^));
             WITH pcsed^.pglp DO BEGIN {restore all but icsHdr, icsFtr}
                yTopHdr   := ffleader.pglp.yTopHdr;
                dyHdr     := ffleader.pglp.dyHdr;
                dyHtBody  := ffleader.pglp.dyHtBody;
                dyBotBody := ffleader.pglp.dyBotBody;
                tyxy      := ffleader.pglp.tyxy;
                END;  {whew!}
             IF ffleader.tyrlu IN [tyrluEnglish, tyrluMetric] THEN
                pcsed^.tyrlu := ffleader.tyrlu ELSE pcsed^.tyrlu := tyrluDefault;
             tyrluCurrent := pcsed^.tyrlu;
             PrPrfDefault(prprf);
             IF ffleader.password = pwFf THEN
                IF ffleader.version >= ffVerPrPrf THEN
                   BEGIN
                   prprf := ffleader.prprf;
                   IF NOT FPrPrfValid(prprf) THEN

{$IFC fPrintOld}                                                    {gdf 1/16/84}

                                             PrPrfFix(prprf);

{$ELSEC}                                                            {gdf 1/16/84}

{Question: Should we do a note alert here ???}
{Print format in document not compatible with attached printer(s) ???}

                                             PrPrfDefault(prprf);

{$ENDC}                                                             {gdf 1/16/84}

                  END;
             pcsed^.cs.prprf := prprf;
             rghcs^[icsHdr]^^.prprf := prprf;
             rghcs^[icsFtr]^^.prprf := prprf;
             lpHdrFst := ffleader.lpHdrFst;
             lpFtrFst := ffleader.lpFtrFst;
             lpFstSource := ffleader.lpTxtFst;
             lpLimSource := LpMacFf(icsSource);
             Replace(icsHdr, 0, LpMacEd(icsHdr), icsSource, lpHdrFst, lpFtrFst);
             Replace(icsFtr, 0, LpMacEd(icsFtr), icsSource, lpFtrFst,
             lpFstSource);
             IF LpMacEd(icsHdr) = 0 THEN Replace(icsHdr, 0, 0, icsCr, 0, 1);
             IF LpMacEd(icsFtr) = 0 THEN Replace(icsFtr, 0, 0, icsCr, 0, 1);
             END
          ELSE (* tycsSource had better be tycsUf *)
             BEGIN
             lpFstSource := 0;
             lpLimSource := LpMacUf(icsSource);
             Replace(icsHdr, 0, LpMacEd(icsHdr), icsCr, 0, 1);
             Replace(icsFtr, 0, LpMacEd(icsFtr), icsCr, 0, 1);
             END;
          Replace(icsEd, 0, LpMacEd(icsEd), icsSource, lpFstSource,
          lpLimSource);
          END;

      (* discard the selection *)
      LSetSel(icsActive, 0, 0);

      END;
   END (* RevertToOrig *);


{$S LWMisc}
{--------------------------}
PROCEDURE InsertCh(ch: TCh);
{--------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF selCur.oint <> ointNil THEN
    BEGIN
    InsChKid(ch);
    END;
END;

{$S LWOpen}
{------------------------------------------------------------}
PROCEDURE SuspendDocument{VAR cError, oboxTab: TC; fTemp: TF};
{------------------------------------------------------------}
VAR oboxPane: TC;
  orecCon: TC;
  ics: TB;
  path255: String255;
  path: Pathname;
  password:    E_name;
  cErrorIgnore: TC;
  volname: Pathname;
  ename:   E_name;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
  oboxPane := OboxFstOnSc(ScidFstFromFid(oboxTab, tyvhV));
  ics := IcsEdFromPane(oboxPane, orecCon);
  OrigPathOfIcsEd(ics, path255, password);
  path := path255;
  StripExtension(path);
  KillDoc(cError, CONCAT(path, 'NEW'), password);

  IF fTstLotus THEN WRITELN (CHR(7),'!!!!! SuspendDocument FEdited: ', FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))));
  {$ifc fEdSuspend}
  IF FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))) THEN BEGIN
  {$endc}
      (* WaitAlert (WPAlerts, 40); *)
      WriteAnyFolder(cError, ics, oboxTab, CONCAT(path, 'NEW'), password);
      IF cError <= 0 THEN BEGIN
          SplitPathname(path, volname, ename);
          KillDoc(cErrorIgnore, CONCAT(path, 'TEMP'), password);
          IF fTemp THEN RenameDoc(cErrorIgnore, CONCAT(path, 'NEW'), CONCAT(ename, 'TEMP'), password)
          ELSE {not fTemp, so} BEGIN
              KillDoc(cErrorIgnore, CONCAT(path, ''), password);
              RenameDoc(cErrorIgnore, CONCAT(path, 'NEW'), CONCAT(ename, ''), password);
              END;
          DiscardFolder(oboxTab);
      END ELSE {cError > 0, so} BEGIN
          KillDoc(cErrorIgnore, CONCAT(path, 'NEW'), password);
          {$IFC fDbgOk}
          WRITELN('SuspendDocument cError = ', cError);
          {$ENDC}
        END;
     {$ifc fEdSuspend}
     END ELSE {not FEdited, so} BEGIN
      (* WaitAlert (WPAlerts, 41); *)
      IF fTemp THEN RenameDoc(cErrorIgnore, CONCAT(path, ''), CONCAT(ename, 'TEMP'), password);
      DiscardFolder(oboxTab);
    END;
    {$endc}
  (* EndWaitAlert; *)
END;  {SuspendDocument}

{----------------------------------------------------------------}
PROCEDURE RestartDocument(VAR cError: TC; oboxTab: TC; fTemp: TF);
{----------------------------------------------------------------}
VAR pboxTab: TPbox;
  spTitle: TSp;
  path:    Pathname;
  password:    E_name;
  window:  TWindow;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
  {Get the document title, pathname, and window}
  pboxTab := PboxFromObox(oboxTab);
  spTitle := CONCAT(pboxTab^.hspTitle^^);  {only LENGTH(hspTitle^^) chars exist!}
  PathOfOboxTab(oboxTab, path, password);
  StripExtension(path);
  window := pboxTab^.window;
  SuspendDocument(cError, oboxTab, fTemp);
  IF fTemp THEN path := CONCAT(path,'TEMP');
  IF cError <= 0 THEN
      OpenDocument(cError, spTitle, path, window, TRUE (* paint the pane *), FALSE, password)
{$IFC fDbgOk}
  ELSE
      WRITELN('RestartDocument cError = ', cError);
{$ELSEC}
  ;
{$ENDC}

END;  {RestartDocument}


{$S LWCommand}
{---------------------}
PROCEDURE UpdateThumbs;
{---------------------}
VAR
  scid: TScid;
  obox: TC;
  cPctNew: TC;
  cPctCur: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF oboxActive <> oboxNil THEN BEGIN
    scid := ScidFstFromFid(oboxActive, tyvhV);
    WHILE scid <> scidNil DO BEGIN
        obox := OboxFstOnSc(scid);
        cPctNew := CPctThumbObox(obox);
        IF cPctNew <> cPctNil THEN
            BEGIN
            cPctCur := CLThumbPos(scid);
            IF ABS(cPctNew-cPctCur) > 1 THEN
                BEGIN
                VisObox(obox);
                SetLThumb(scid, cPctNew);
                END;
            END;
        scid := ScidNxtFromScid(scid);
        END;
    END;
END;  {UpdateThumbs}

{$S LWPreview}
{--------------------------------------------}
PROCEDURE ThumbOboxPct(oboxPane: TC; cPct: TC);
{--------------------------------------------}
CONST
    cPctThreshhold = 75;
VAR pboxPane: TPbox;
    cPctWas: TC;
    lpPct, lpPctEd: TLp;
    pint: TPint;
    recCon: TRec;
    orecCon: TC;
    orecConDoc: TC;
    icsEd, ics: TB;
    hcspg: THcspg;
    hcs: THcs;
    ipg: TC;
    lpOrLppg: TLpOrLppg;
    tycs:       TTycs;
    vTop: TC;
    lpMac: TLp;
    ptHtPane: TPt;
    orecScroll: TC;
    vTopLast: TC;
    lpFstLast: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstLotus THEN WRITELN('ThumbOboxPct(', oboxPane, ', ', cPct, ')');
cPctWas := CPctThumbObox(oboxPane);
IF cPct <> cPctWas THEN
     BEGIN
     ics := IcsConFromPane(oboxPane, orecCon);
     hcs := rghcs^[ics];
     tycs := hcs^^.tycs;
     IF cPct = 0 THEN
          lpPct := 0
     ELSE BEGIN
          IF tycs = tycsPg THEN
                BEGIN
                hcspg := POINTER(ORD(hcs));
                icsEd := hcspg^^.pgd.icsBody;
                END
          ELSE BEGIN
                IF hcs^^.tycs <> tycsEd THEN Break(82);
                icsEd := ics;
                END;
          lpMac := LpMacEd(icsEd);
          lpPctEd := (cPct * lpMac) DIV 100;
          { FindLpFixed(icsEd, lpPctEd, lpPctEd); }
          IF tycs = tycsPg THEN
               BEGIN
               lpPct := LpPgOfLpEd(ics, icsEd, lpPctEd);
               IF cPct > cPctThreshhold {arbitrary threshhold } THEN
                    BEGIN
                    lpOrLppg.lp := LpPgOfLpEd(ics, icsEd, lpMac);
                    lpOrLppg.lppg.ipg := lpOrLppg.lppg.ipg + 1;
                    lpOrLppg.lppg.ptpg := 0;
                    lpOrLppg.lppg.ich := 0;
                    lpMac := lpOrLppg.lp;
                    END;
               END
          ELSE BEGIN
               lpPct := lpPctEd;
               END;
          END (* ELSE *);
     IF cPct > cPctThreshhold {arbitrary threshhold } THEN
          BEGIN
          { find the furthest you will scroll }
          pboxPane := POINTER(ORD(bdsp)+oboxPane);
          ptHtPane.h := 0; ptHtPane.v := pboxPane^.r.bottom - pboxPane^.r.top;
          recCon := POINTER(ORD(dsp)+orecCon);
          orecScroll := Orec1Alloc(ics, lpMac, lpMac, ptHtPane, ptHtPane,
                              recCon^.tyxy, fixedLpLim, FALSE, foNil);
          NormalizeOrecCon(orecScroll);
          recCon := POINTER(ORD(dsp)+orecScroll);
          pint := POINTER(ORD(lldInt) + recCon^.ointDep);
          vTopLast := recCon^.r.top;
          lpFstLast := pint^.lpFst;
          orecScroll := OrecSibFree(orecScroll);
          END
     ELSE lpFstLast := lpMax;
     recCon := POINTER(ORD(dsp)+orecCon);
     pint := POINTER(ORD(lldInt) + recCon^.ointDep);
     IF lpFstLast < lpPct THEN
          BEGIN
          recCon^.r.top := vTopLast;
          pint^.lpFst := lpFstLast;
          END
     ELSE BEGIN
          recCon^.r.top := 0;
          pint^.lpFst := lpPct;
          NormalizeOrecCon(orecCon);
          END;
     InvalidOrec(orecCon);
     recCon := POINTER(ORD(dsp)+orecCon);
     pint := POINTER(ORD(lldInt) + recCon^.ointDep);
     lpPct := pint^.lpFst;
     vTop := recCon^.r.top;
     orecConDoc := orecCon;
     pboxPane := POINTER(ORD(bdsp)+oboxPane);
     orecCon := pboxPane^.refCon;
     WHILE orecCon <> orecConDoc DO
          BEGIN
          recCon := POINTER(ORD(dsp)+orecCon);
          IF recCon^.strec.fScrollV  THEN
               BEGIN
               recCon^.r.top := vTop;
               pint := POINTER(ORD(lldInt) + recCon^.ointDep);
               pint^.lpFst := lpPct;
               InvalidOrec(orecCon);
               END;
          orecCon := recCon^.orecSib;
          END;
     END;
IF fTstLotus THEN WRITELN('lpPct: ', lpPct);
END;

{$S LWSplit}
{------------------------------------------}
PROCEDURE DoScNew (scidOld, scidNew: TScid);
{------------------------------------------}
VAR ics: TB; cPct: TC;
    recConOld, recSplit, recNew, recNewFst: TRec;
    orecConOld, orecSplit, orecNew, orecNewFst: TC;
    lpFixed: TLp;
    pint, pintOld: TPint;
    oboxPOld, oboxPNew: TC;
    pboxPOld, pboxPNew: TPbox;
    tyvh: TTyvh; ptSplit: TPt; ptTopLeft: TPt;
    orecCon: TC; recCon: TRec;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tyvh := TyvhOfSc(scidOld);
oboxPOld := OboxFstOnSc(scidOld);
oboxPNew := OboxFstOnSc(scidNew);
 { go down both scroll chains in parallel }
WHILE oboxPOld <> oboxNil DO BEGIN
    ics := IcsConFromPane(oboxPOld, orecConOld);
    pboxPNew := PboxFromObox(oboxPNew);
    { get an orec for the new pane. since oboxPNew <> oboxNil, the
    obox returned is same passed. }
    oboxPNew := OboxOpenWindow(ics, pboxPNew^.window, 'NEWPANE', oboxPNew,
                                TRUE (* paint the pane *));
    pboxPNew := PboxFromObox(oboxPNew);
    pboxPOld := PboxFromObox(oboxPOld);
    orecCon := pboxPOld^.refCon;
    orecNew := pboxPNew^.refCon;
    recNew := POINTER(ORD(dsp) + orecNew);
    { find new's origin relative to old's origin }
    ptSplit := pboxPNew^.r.topLeft; SubPt(pboxPOld^.r.topLeft, ptSplit);
    recConOld := POINTER(ORD(dsp) + orecConOld);
    IF tyvh = tyvhV THEN BEGIN
        orecSplit := OrecOfPt(recConOld^.orecSon, TRUE, ptSplit, FALSE);
        IF orecSplit = orecNil THEN
             BEGIN
             ptTopLeft := recConOld^.r.topLeft;
             pintOld := POINTER(ORD(lldInt) + recConOld^.ointDep);
             lpFixed := pintOld^.lpFst;
             END
        ELSE BEGIN
             recSplit := POINTER(ORD(dsp) + orecSplit);
             pint := POINTER(ORD(lldInt) + recSplit^.ointDep);
             FindLpFixed(ics, pint^.lpFst, lpFixed);
             orecNewFst := OrecOfLp(recConOld^.orecSon, ics, lpFixed, FALSE);
             recNewFst := POINTER(ORD(dsp) + orecNewFst);
             recConOld := POINTER(ORD(dsp) + orecConOld);
             SetPt(ptTopLeft, recConOld^.r.left,
                   recNewFst^.r.top - ptSplit.v);
             END;
        recNew := POINTER(ORD(dsp) + orecNew);
        recNew^.r.topLeft := ptTopLeft;
        pint := POINTER(ORD(lldInt) + recNew^.ointDep);
        pint^.lpFst := lpFixed;
        END
    ELSE BEGIN
        SetPt(recNew^.r.topLeft, recConOld^.r.left - ptSplit.h,
        recConOld^.r.top);
        pintOld := POINTER(ORD(lldInt) + recConOld^.ointDep);
        pint := POINTER(ORD(lldInt) + recNew^.ointDep);
        pint^. lpFst := pintOld^.lpFst;
        END;
    WHILE orecCon <> orecNil DO
         BEGIN
         InvalidOrec(orecCon);
         recCon := POINTER(ORD(dsp)+orecCon);
         orecCon := recCon^.orecSib;
         END;
    InvalidOrec(orecNew);
    oboxPOld := OboxNxtOnSc(oboxPOld, tyvh);
    oboxPNew := OboxNxtOnSc(oboxPNew, tyvh);
    END;
ValidateDsp;
cPct := CPctThumbObox(OboxFstOnSc(scidNew));
IF cPct <> cPctNil THEN SetLThumb(scidNew, cPct);
END; { DoScNew }

{$S LWResize}
{---------------------------------------------------------------}
PROCEDURE DoScResize(scid: TScid; dcdAdjust: TCd; fAdjFront: TF);
{---------------------------------------------------------------}
VAR oboxPane: TC; pbox: TPbox; rec, recCon: TRec; tyvh: TTyvh;
    ptT: TPt; rB: TR; cPct: TC; orecCon: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstBox THEN WRITELN ('DoScResize scid: ', scid, ', dcdAdjust: ', dcdAdjust,
    ', fAdjFront? ', fAdjFront);
oboxPane := OboxFstOnSc(scid);
tyvh := TyvhOfSc(scid);
WHILE oboxPane <> oboxNil DO BEGIN
    pbox := PboxFromObox(oboxPane);
    rec := POINTER(ORD(dsp) + pbox^.refCon);
    {$ifc fDbgOk}
    IF fTstBox THEN BEGIN
          WRITELN('  Resizing obox ', oboxPane);
          PxR(' original size', rec^.r);
          END;
    {$endc}
     orecCon := pbox^.refCon;
     WHILE orecCon <> orecNil DO
          BEGIN
          InvalidOrec(orecCon);
          recCon := POINTER(ORD(dsp)+orecCon);
          IF fAdjFront AND (((tyvh = tyvhV) AND recCon^.strec.fScrollV)
            OR ((tyvh = tyvhH) AND recCon^.strec.fScrollH)) THEN
                BEGIN
                { adjust the topLeft corner }
                recCon^.r.topLeft.vh[tyvh] := recCon^.r.topLeft.vh[tyvh]
                                                - dcdAdjust;
                IF tyvh = tyvhV THEN
                     BEGIN
                     NormalizeOrecCon(orecCon);
                     { SetPt(ptT, 0, -dcdAdjust);
                       ScrollOrec(oboxPane, ptT, TRUE);
                     }
                     END
                END;
          recCon := POINTER(ORD(dsp)+orecCon);
          orecCon := recCon^.orecSib;
          END;
    oboxPane := OboxNxtOnSc(oboxPane, tyvh);
    END;
{ cPct := CPctThumbObox(OboxFstOnSc(scid));
IF cPct <> cPctNil THEN SetLThumb(scid, cPct);
}
END;

{$S LWPreview}
{--------------------------------------------}
PROCEDURE ScrollScid(scid: TC; ptScroll: TPt);
{--------------------------------------------}
VAR oboxPane, oboxHeadPane: TC;
    tyvh: TTyvh;
    cPct: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstBox THEN
    WRITELN('ScrollScid scid: ', scid, ', ptScroll: ', ptScroll.h, ptScroll.v);
oboxHeadPane := oboxFstOnSc(scid);
tyvh := TyvhOfScid(scid);
oboxPane := oboxHeadPane;
WHILE oboxPane <> oboxNil DO
    BEGIN
    ScrollOrec(oboxPane, ptScroll, TRUE);
    oboxPane := OboxNxtOnSc(oboxPane, tyvh);
    END;
 (* d *)
{$ifc fDbgOk}
IF fTstBox THEN PxClip;
{$endc}
ValidateDsp;
cPct := CPctThumbObox(oboxHeadPane);
IF fTstBox THEN WRITELN('CPctThumbObox: ', cPct);
IF (cPct <> cPctNil) AND (cPct <> CLThumbPos(scid)) THEN SetLThumb(scid, cPct);
END;

{-----------------------------------------}
PROCEDURE DoScroll(scid: TScid; dir: TDir);
{-----------------------------------------}
VAR ptT: TPt;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
ptT.h := 0; ptT.v := 0;
CASE dir OF
   dirDwn:    ptT.v := -dyScroll;
   dirUp:     ptT.v :=  dyScroll;
   dirLft:    ptT.h :=  dxScroll;
   dirRt:     ptT.h := -dxScroll;
   END;
ScrollScid(scid, ptT);
END;

{------------------------------------------}
PROCEDURE DoPScroll(scid: TScid; dir: TDir);
{------------------------------------------}
VAR oboxHeadPane: TC;
    ptT: TPt;
    pbox: TPbox;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF TyvhOfSc(scid) <> tyvhV THEN Break(86);
oboxHeadPane := OboxFstOnSc(scid);
pbox := PboxFromObox(oboxHeadPane);
ptT.h := 0;
ptT.v := pbox^.r.bottom - pbox^.r.top - dyScroll;
CASE dir OF
    dirDwn:    ptT.v := -ptT.v;
    dirUp:     BEGIN END;
    OTHERWISE  Break(86);
    END;
ScrollScid(scid, ptT);
END;

{-------------------------------------------------}
PROCEDURE DoThumb(scid: TScid; cPct: TC);
{-------------------------------------------------}
VAR oboxPane, oboxHeadPane: TC; tyvh: TTyvh; cPctNew: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
oboxHeadPane := OboxFstOnSc(scid);
tyvh := TyvhOfSc(scid);
oboxPane := oboxHeadPane;
WHILE oboxPane <> oboxNil DO BEGIN
    VisObox(oboxPane);
    ThumbOboxPct(oboxPane, cPct);
    oboxPane := OboxNxtOnSc(oboxPane, tyvh);
    END;
ValidateDsp;
cPctNew := CPctThumbObox(oboxHeadPane);
IF cPctNew <> cPctNil THEN SetLThumb(scid, cPctNew);
END;  {DoThumb}


{$S LWPut}
{------------------------}
PROCEDURE PutBackDocument;
{------------------------}
VAR
   oboxTab,oboxPane: TC;
   orecCon: TC;
   pbox: TPBox;
   ics: TB;
   window: TWindow;
   path,volname: Pathname;
   password:    E_name;
   ename: E_Name;
   cError,cErrorWrite: TC;
   spTitle: TParamAlert;
   str255Title: Str255;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
    oboxTab := oboxActive;
    oboxPane := OboxFstOnSc(ScidFstFromFid(oboxTab, tyvhV));
    ics := IcsEdFromPane(oboxPane, orecCon);
    pbox := PboxFromObox(oboxTab);
    window := pbox^.window;
    PathOfOboxTab(oboxTab, path, password);
    StripExtension(path);
    SplitPathname(path, volname, ename);
    KillDoc(cError, CONCAT(path, 'NEW'), password); {Probably unnecessary}

    IF fTstLotus THEN WRITELN (CHR(7),'!!! PutBackDocument FEdited: ', FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))));

    IF FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))) THEN BEGIN
         WaitAlert (WPAlerts, 40);
         WriteAnyFolder(cErrorWrite, ics, oboxTab, CONCAT(path, 'NEW'), password);
         IF cErrorWrite <=0 THEN BEGIN
             { Simulate a call to MakeFDeactivated(oboxActive) without enqueueing a
               tyevDeactivated event.  Sorry for the mess, but A3 is due NOW.
               crc 11/19/82
             }
             HiLiteTab(window, FALSE);
             RemoveScrollBoxes(oboxActive);
             oboxActive := oboxNil;

             KillDoc(cError, path, password);
             RenameDoc(cError, CONCAT(path, 'NEW'), ename, password);
             KillDoc(cError, CONCAT(path, 'TEMP'), password);
             DiscardFolder(oboxTab);
             ReleaseStreams;
             EndWaitAlert;
             TellFiler(cError, docClosd, docPutBack, window);
             END
         ELSE BEGIN
             KillDoc(cError, CONCAT(path, 'NEW'), password);
             GetFldrTitle(activeFolder, str255Title);
             spTitle := CONCAT(str255Title);
             ParamAlert(spTitle, '', '');
             StopAlert(WPAlerts, 14);
             (* TellFiler(cError, docNotXfered, FReasonWhy(cErrorWrite),
                       evDsc.windowCurr); *)
             END;
    END ELSE {not FEdited, so} BEGIN
             WaitAlert(WPAlerts, 41);
             HiLiteTab(window, FALSE);
             RemoveScrollBoxes(oboxActive);
             oboxActive := oboxNil;
             DiscardFolder(oboxTab);
             ReleaseStreams;
             EndWaitAlert;
             TellFiler(cError, docClosd, docPutBack, window);
    END;
END;  {PutBackDocument}


{$S LWCommand}
PROCEDURE VerifyOrecConDwn(ics: TB);
VAR recCon: TRec;
    pint: TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF orecConDwn = orecNil THEN
     orecConDwn := OrecConFromIcs(ics)
ELSE BEGIN
     recCon := POINTER(ORD(dsp) + orecConDwn);
     pint := POINTER(ORD(lldInt) + recCon^.ointDep);
     IF (NOT recCon^.strec.fRecCon) OR (pint^.ics <> ics) THEN
          orecConDwn := OrecConFromIcs(ics);
     END;
END;


{$S LWUndo}
{--------------------------------}
PROCEDURE Undo { (fUndoUndo: TF) };
{--------------------------------}
VAR hileCur, hileLimT: THile;
    lpLim0T, lpLim1T, lpLim2T: TLp;
    pint: TPint;
    lpFstPint, lpLimPint: TLp;
    cDummy: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstEdit THEN WRITELN('Undo.');
RemoveKid(TRUE); ShowSel(selCur, tyshowOff);
IF ORD(hileLim) = ORD(hileMax) THEN
     BEGIN
     StopAlert(WPAlerts, 9);
     END
ELSE BEGIN
     IF fUndoUndo THEN
          BEGIN
          hileLimT := hileLim;
          hileCur := @arghile;
          END
     ELSE BEGIN
          hileLimT := @arghile;
          hileCur := hileLim;
          END;
     WHILE hileCur <> hileLimT DO
          BEGIN
          IF NOT fUndoUndo THEN hileCur := POINTER(ORD(hileCur) -
          SIZEOF(TAhile));
          {$ifc fDbgOk}
          IF fTstEdit THEN PxHile(hileCur);
          {$endc}
          WITH hileCur^ DO
               BEGIN
                { Replacing THROUGH documents replaces a different number of }
                { lp's in each direction (trust me). }
               IF lpLim1 = lpNil THEN lpLim1T := LpMacEd(ics1) ELSE lpLim1T :=
               lpLim1;
               IF lpLim2 = lpNil THEN lpLim2T := LpMacEd(ics2) ELSE lpLim2T :=
               lpLim2;
               CASE hop OF
                hopReplace,hopRplWord:
                    BEGIN
                    IF fUndoUndo
                         THEN Replace(ics2, lpFst2, lpLim2T, ics1, lpFst1,
                         lpLim1T)
                         ELSE Replace(ics1, lpFst1, lpLim1T, ics2, lpFst2,
                         lpLim2T);
                    END;
                hopSwitch:  { and jump... }
                    BEGIN
                    IF fUndoUndo THEN
                         BEGIN
                          { How many get switched is different: }
                         lpLim0T := lpLim2T;
                         IF lpLim2 <> lpNil THEN lpLim2T := lpFst2 + (lpLim1T -
                         lpFst1);
                         IF lpLim1 <> lpNil THEN lpLim1T := lpFst1 + (lpLim0T -
                         lpFst2);
                         END;
                    Replace(icsUndo2, 0, 0, ics1, lpFst1, lpLim1T);
                    Replace(ics1, lpFst1, lpLim1T, ics2, lpFst2, lpLim2T);
                    Replace(ics2, lpFst2, lpLim2T, icsUndo2, 0, (lpLim1T -
                    lpFst1));
                    Replace(icsUndo2, 0, (lpLim1T - lpFst1), icsNil, 0, 0);
                    IF icsMarginRuler <> icsNil THEN
                         SelToRuler(icsMarginRuler, orecNil, FALSE, TRUE);
                    END;
                hopInsert:
                    BEGIN
                    IF fUndoUndo THEN
                         Replace(ics2, lpFst2, lpFst2, ics1, lpFst1, lpLim1T)
                    ELSE BEGIN
                         Replace(ics1, lpFst1, lpLim1T, ics2, lpFst2, lpLim2T);
                         Replace(ics2, lpFst2, lpLim2T, icsNil, 0, 0);
                         END;
                    END;
                hopMove,hopMovWord:
                    BEGIN
                    IF fUndoUndo THEN
                         BEGIN
                         Replace(ics2, lpFst2, lpLim2T, ics1, lpFst1, lpLim1T);
                         Replace(ics1, lpFst1, lpLim1T, icsNil, 0, 0);
                         END
                    ELSE Replace(ics1, lpFst1, lpFst1, ics2, lpFst2, lpLim2T);
                    END;
                hopSelect:
                    BEGIN
                    IF fUndoUndo
                         THEN LSetSel(ics1, lpFst1, lpLim1T)
                         ELSE LSetSel(ics2, lpFst2, lpLim2T);
                    END;
                hopPutDict:
                    BEGIN
                    UndoPutDict(fUndoUndo);
                    END;
                hopRmvDict:
                    BEGIN
                    UndoRmvDict(fUndoUndo);
                    END;
                OTHERWISE
                    BEGIN Break(22); END;
                END (* CASE *);
               IF fUndoUndo AND (ics2=icsScrap) THEN
                   {Replaying cut/copy to scrap}
                   CASE hop OF
                    hopRplWord,hopMovWord: fScrapWord := TRUE;
                    hopReplace,hopMove:    fScrapWord := FALSE;
                    {Never hopInsert into scrap, never hopSelect the scrap
                     and never hopSwitch the scrap}
                   END;
               IF NOT fUndoUndo AND (ics1=icsScrap) THEN
                   {Restoring scrap from undo buffer or, unnecessarily,
                    "restoring" scrap from paste}
                   CASE hop OF
                    hopRplWord,hopMovWord: fScrapWord := TRUE;
                    hopReplace,hopMove:    fScrapWord := FALSE;
                    {Ignore hopInsert which "restores" scrap from paste};
                   END;
               END (* WITH *);
          IF fUndoUndo THEN hileCur := POINTER(ORD(hileCur) + SIZEOF(TAhile));
          END (* WHILE *);
     IF (imtdPrv = imtdEdit) AND ((imidPrv = imidCut) OR (imidPrv = imidCopy))
        THEN UndoInheritScrap(cDummy);
     END (* ELSE *);
 { Cleanup all at once: }
ShowSel(selCur, tyshowOn);
{$ifc fDbgOk}
IF fTstCom THEN PxCs(icsUndo);
{$endc}
END;

{$S LWCommand}
{---------------------------------------------------------}
PROCEDURE DoMenuCommand(imtd, imid: TC);
{---------------------------------------------------------}
LABEL 999;
VAR f: TF;
    spPrmt: TSp;
    ich: TC;
    oboxSel: TC;
    lpFst:      TLp;
    lpLim:      TLp;
    pint:       TPint;
    icsSel,icsEd: TB;
    hcspg: THcspg;
    hcsedSel: THcsed;
    orecConSel: TC;
    icsPg:  TB;
    val: TC;
    achad: TAchad;
    recCon: TRec;
    fSignificant: TF;  {Command affects undo ability}

    prprf:   TPrRec;
    myPrMode: PrMenuSuppress;

    fNewStl: TF;
    cError:  TC;
    window:  TWindow;
    oboxTab: TC;
    pboxTab: TPbox;
    fsinfo:  fs_info;
    path:    Pathname;
    password:    E_name;
    path255: String255;
    stringWhen,spTitle: TParamAlert;
    str255Title: Str255;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
 { WE NEED MULTIPLE SELECTIONS!!! }
icsSel := IcsActive;
IF (icsSel = icsNil) OR (selCur.oint = ointNil) THEN
     BEGIN
     StopAlert(WPAlerts, 29);
     GOTO 999;
     END;
VerifyOrecConDwn(icsSel);
oboxSel := OboxOfOrec(orecConDwn);

IF fTstLotus THEN WRITELN('DoMenuCommand -- oboxSel:', oboxSel:4,
                                   '; orecConDwn:', orecConDwn:4);
hcsedSel := POINTER(ORD(rghcs^[icsSel]));
IF (imtd <> imtdFile) AND (hcsedSel^^.cs.tycs = tycsEd) THEN
  IF (hcsedSel^^.issMac >= cssAbsMax) THEN
     BEGIN
     StopAlert(WPAlerts, 25);
     GOTO 999;
     END;
fSignificant := TRUE;
VisObox(oboxSel);
IF ((imtd <> imtdEdit) OR (imid <> imidUndo))
AND ((imtd <> imtdSpelling) OR (imid <> imidAndFind)) THEN InitChronicle;
IF ftstCur THEN writeln('imtd is ', imtd, ' and imid is ', imid);

CASE imtd OF
imtdFile: BEGIN
  RmvAnyDbox;
  CASE imid OF
   imidPrPrf: BEGIN
                IF fTstLotus THEN WRITELN('Calling PrPrfDlg');
                DisplayFstSubImtd(imtdNil); {take down rulers}
                prprf := rghcs^[IcsActive]^^.prprf;

                PrPrfDlg(prprf, fNewStl, FALSE {don't suppress page size});
                IF fNewStl THEN NewPrprf(IcsActive, prprf);
              END;
   imidPrint, imidAsIsPrint:    {combined 3-19-84 med}
              BEGIN
                prprf := rghcs^[IcsActive]^^.prprf;
                        {now, for the new print paradigm -- gdf 1/23/84}
                IF imid = imidPrint THEN myPrMode := ePrNormal
                ELSE myPrMode := ePrDialogSuppress;
                IF FPrInsDlg(prprf, fNewStl, myPrMode) THEN BEGIN
                   IF fNewStl THEN NewPrprf(IcsActive, prprf);
                   Print(prprf, oboxSel);
                END
                ELSE IF fNewStl THEN NewPrprf(IcsActive, prprf);
              END;

   imidPrBgdDlg:  PrBgdDlg;
   imidRevert: BEGIN
                 IF rghcs^[IcsActive]^^.tycs = tycsPg THEN
                    BEGIN
                    hcspg := POINTER(ORD(rghcs^[IcsActive]));
                    icsEd := hcspg^^.pgd.icsBody;
                    END
                 ELSE icsEd := IcsActive;
                 OrigPathOfIcsEd(icsEd, path255, password);
                 path := path255;
                 StripExtension(path);
                 LOOKUP(cError, path, fsinfo);
                 IF cError > 0 THEN
                     StopAlert(WPAlerts, 30)
                 ELSE BEGIN
                     DTAlert(WPAlerts, fsinfo.dtm, stringWhen);
                     GetFldrTitle(activeFolder, str255Title);
                     ParamAlert(stringWhen, str255Title, '');
                     IF CautionAlert(WPAlerts, 10) THEN
                         RevertToOrig(oboxActive);
                     END;
               END;
   imidSavAndCont:
           BEGIN
              oboxTab := oboxActive;
             IF FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))) THEN BEGIN
              WaitAlert (WPAlerts, 40);
              oboxActive := oboxNil;
              pboxTab := PboxFromObox(oboxTab);
              window := pboxTab^.window;
              RestartDocument(cError, oboxTab, FALSE); {FEdited in SuspendDocument in RestartDocument}
              MakeFolderActive(FidOfWindow(window), FALSE);
              IF cError > 0 THEN
                  BEGIN
                  GetFldrTitle(activeFolder, str255Title);
                  spTitle := CONCAT(str255Title);
                  ParamAlert(spTitle, '', '');
                  StopAlert(WPAlerts, 8);
                  END;
              ReleaseStreams;
              EndWaitAlert;
             END ELSE {not FEdited, so} NoteAlert (WPAlerts, 42);
           END;
    imidPutBack: BEGIN
                 LotusPutScrap;
                 PutBackDocument;
              END;
        END;
    END;
imtdEdit:     CASE imid OF
                imidCut:         CutCopy(TRUE);
                imidCopy:        CutCopy(FALSE);
                imidPaste:       Paste;
                imidUndo:        BEGIN
                                 IF @arghile = hileLim THEN
                                      BEGIN
                                      IF imtdPrv > 0 THEN
                                           BEGIN
                                           WouldAlert(argMenu[imtdPrv],imidPrv);
                                           StopAlert(WPAlerts, 5);
                                           END
                                      ELSE StopAlert(WPAlerts, 6);
                                      END
                                 ELSE Undo(fUndoLst);
                                 fSignificant := FALSE;
                                 END;
                imidSelectAll:   SelectAll(IcsEdFromPane(oboxSel,orecConDwn));
                END;
 imtdFind:       BEGIN
                 DoFindImid(imid, orecConDwn);
                 IF imid = imidClearPrompt THEN fSignificant := FALSE;
                 END;
 imtdType:       DoTypeImid(imid);
 { imtdFont:       BEGIN
                 DoFontImid(imid);
                 IF imid = imidFDone THEN fSignificant := FALSE;
                 END;
 }
 imtdPar:        BEGIN
                 DoParImid(imid, oboxSel);
                 END;
 imtdMargTab:     DoMarginImid(imid);
 imtdPRuler:   CASE imid OF
                imidPREnglish: f := FSetRulers(tyrluEnglish);
                imidPRMetric:  f := FSetRulers(tyrluMetric);
                END;
 imtdPage:     CASE imid OF
                imidPreview:     Preview(oboxSel, TRUE);
                imidNoPreview:     Preview(oboxSel, FALSE);
                imidPageRuler:
                     BEGIN
                     IF NOT FPreviewObox(oboxSel, orecConSel, icsPg) THEN BEGIN
                       Preview(oboxSel, TRUE);
                       ValidateDsp; {med: added for short ruler bug}
                     END;
                     icsPageRuler := IcsRulerCreate(oboxSel, FALSE, hzLotus);
                     hcspg := POINTER(ORD(rghcs^[IcsPgOfIcsRuler(icsPageRuler)]));
                     hcspg^^.pgd.icsPageRuler := icsPageRuler;
                     DisplayFstSubImtd(imtdPRuler);
                     END;
                imidNoPageRuler:
                     BEGIN
                     IF icsPageRuler <> icsNil THEN
                          BEGIN
                          RemovePageRuler;
                          { HiLiteMenu(0); }
                          DisplaySubImtd(imtdNil); {remove page ruler menu}
                          { IF imid = imidPRDone THEN fSignificant := FALSE; }
                          END;
                     END;
                imidFormFeed:
                     BEGIN
                     InsertCh(chFormFeed);
                     END;
                imidIpg:
                     BEGIN
                     InsertCh(chIpg);
                     END;
                imidKeep, imidNoKeep:
                     BEGIN
                     IF selCur.oint <> ointNil THEN
                       BEGIN
                       pint := POINTER(ORD(lldInt) + selCur.oint);
                       icsSel := pint^.ics;
                       lpFst := pint^.lpFst;
                       lpLim := pint^.lpLim;
                       val := ORD(imid = imidKeep);
                       IF lpFst = lpLim THEN
                             ApplyKidFop(selCur.oint, ifldKeep, val, @val)
                       ELSE ApplyFopEd(icsSel, lpFst, lpLim, ifldKeep, val,
                       @val);
                       END;
                     END;
               END;
 imtdSpelling:
               BEGIN
               DoSpellImid(imid, orecConDwn);
               IF (imid = imidAndFind) THEN fSignificant := FALSE;
               END;
 imtdInvisible:
               CASE imid OF
               imidGuess: EndGuessDbox(butnReplace);
               imidGNext: EndGuessDbox(butnRNext);
               END;
 OTHERWISE Break(1511);
 END (* CASE *);
IF (imtd = imtdEdit) AND (imid = imidUndo)
    THEN fUndoLst := NOT fUndoLst
    ELSE fUndoLst := FALSE;
ValidateDsp;
999:
HiLiteMenu(0);
fForceSelInWw := fForceSelInWw OR FShowSel(imtd, imid);
IF fSignificant THEN
  BEGIN
  imtdPrv := imtd;
  imidPrv := imid;
  END;
END;  {DoMenuCommand}


{$S LWCommand}
PROCEDURE SetOrecIns(icsSel: TB; lpFst: TLp);
VAR pint:       TPint;
    recCon:    TRec;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
VerifyOrecConDwn(icsSel);
orecIns := OrecOfLp(orecConDwn, icsSel, lpFst, TRUE);
IF (orecIns <> orecNil) AND (orecIns <> orecConDwn) THEN
     BEGIN
     GenOrec(orecIns, iimgpScrn);
     fGenOrec := FALSE;
     ichIns := IchFromLp(lpFst);
     END
ELSE orecIns := orecNil;
END;


{$S LWType}
PROCEDURE QuickUpdate(fHilight: TF);
VAR lpFst:      TLp;
    pint:       TPint;
    icsSel:     TB;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF selCur.oint <> ointNil THEN
     BEGIN
     pint := POINTER(ORD(lldInt)+selCur.oint);
     icsSel := pint^.ics;
     lpFst := pint^.lpFst;
     END
ELSE icsSel := icsNil;
IF (orecIns <> orecNil) THEN
     BEGIN
     pint := POINTER(ORD(lldInt) + crdStd^.arec.ointDep);
     IF (pint^.ics = icsSel)
       AND (pint^.lpFst <= lpFst) AND (lpFst < pint^.lpLim) THEN
          BEGIN
          IF fGenOrec THEN
               BEGIN
               GenOrec(orecIns, iimgpScrn);
               END;
          UpdateOrec(orecIns, iimgpScrn, fHilight);
          END
     ELSE BEGIN
          ValidateDsp;
          IF icsSel <> icsNil THEN SetOrecIns(icsSel, lpFst);
          END;
     END
ELSE BEGIN
     ValidateDsp;
     IF icsSel <> icsNil THEN SetOrecIns(icsSel, lpFst);
     END;
fGenOrec := FALSE;
END;

{-------------------------}
PROCEDURE HandleTyevKey(VAR evDsc: TEvDsc);
{-------------------------}
LABEL 5, 6, 7;
VAR lpFst:      TLp;
    lpLim:      TLp;
    pint:       TPint;
    icsSel:     TB;
    fSeperator: TF;
    event: EventRecord;
    pintSel:  TPint;
    lpFstSel: TLp;
    lpLimSel: TLp;
    lfp:      TLfp;
    lpT: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WHILE TRUE DO
     BEGIN
     fUndoLst := FALSE;
     IF (selCur.oint <> ointNil) AND (activeFolder <> scrapFolder) THEN
          BEGIN
          ObscureCursor;
          pint := POINTER(ORD(lldInt)+selCur.oint);
          icsSel := pint^.ics;
          lpFst := pint^.lpFst;
          fSeperator := FALSE;
          {$ifc fDbgOk}
          IF fTstLotus THEN
               BEGIN
               PxEvDsc(evDsc);
               WRITELN('ORD(evDsc.ch): ', ORD(evDsc.ch));
               END;
          {$endc}
          IF (evDsc.ch = CHR(chBackspace)) OR (evDsc.ch = CHR (chClear)) THEN
               BEGIN
               IF evDsc.fShiftKey THEN
                    LForwardspace(evDsc.fAppleKey)
               ELSE LBackspace   (evDsc.fAppleKey);
               fGenOrec := TRUE;
               { ValidateDsp; }
               END
          ELSE IF (evDsc.ch = CHR(chEnter)) THEN
               BEGIN
               orecIns := orecNil;
               IF icsPrmt <> icsNil THEN
                     BEGIN
                     IF fTstLotus THEN WRITELN('icsPrmt:', icsPrmt:3);
                     icsSel := icsPrmt;
                     pintSel := POINTER(ORD(lldInt) + selCur.oint);
                     IF fTstLotus THEN WRITELN('icsSel :', pintSel^.ics:3,
                                              'lpFstSel :', pintSel^.lpFst);
                     IF pintSel^.ics = icsPrmt THEN
                           BEGIN
                           lfp.lp := pintSel^.lpFst;
                           IF evDsc.fShiftKey
                                 THEN lfp.lfld := CMax(0, lfp.lfld - 4)
                                 ELSE lfp.lfld := lfp.lfld + 4;
                           IF IcsEdLfld(icsPrmt, lfp.lfld) = icsNil THEN
                                 lfp.lfld := 0;
                           END
                     ELSE lfp.lfld := 0;
                     IF fTstLotus THEN WRITELN('lfld:', lfp.lfld:4);
                     lfp.ich := 0;
                     lfp.lfld := (lfp.lfld - (lfp.lfld MOD 4)) + iprtVal;
                     IF FSelLpBounds(lfp.lp, icsSel, lpFstSel, lpLimSel,
                                     lpT, lpT) THEN
                           LSetSel(icsSel, lpFstSel, lpLimSel);
                     END;
               END
          ELSE BEGIN
               InsChKid(ORD(evDsc.ch));
               IF (orecIns <> orecNil) THEN
                    BEGIN
                    fGenOrec := fGenOrec OR
                                  FGenInsChTld(ichIns, ORD(evDsc.ch), arceKid);
                    ichIns := ichIns + 1;
                    fSeperator := (ORD(evDsc.ch) = chCr)
                      OR (ORD(evDsc.ch) = chTab) OR (ORD(evDsc.ch) = chSp);
                    END;
               IF (evDsc.tyev = tyevKey) AND (icsSel <> icsPrmt) THEN
                    BEGIN
                    imtdPrv := imtdBuzz;
                    imidPrv := imidKeyInput;
                    END;
               END;
          IF evDsc.fRepeatKey THEN QuickUpdate(fSeperator);
          fForceSelInWw := TRUE;
          END;
     IF NOT PeekEvent(event) THEN
          GOTO 5
     ELSE IF event.what <> keyDown THEN
          GOTO 5
     ELSE IF event.appleKey THEN
          GOTO 5
     ELSE BEGIN
          GetEvent(event);
          evDsc.ch := event.ascii;
          evDsc.fAlphaKey := event.alphaKey; evDsc.fShiftKey := event.shiftKey;
          evDsc.fAppleKey := event.appleKey; evDsc.fCodeKey := event.codeKey;
          evDsc.fRepeatKey := event.repeatKey;
          GOTO 6;
          END;

5:   (* No key events queued up in the event mgr.  Are there any in our queue? *)
     IF NOT FPeekQueue(q, @evDsc) THEN
         BEGIN
         IF fMoreToQ THEN
            BEGIN  {No more in queue, but more to queue up via NQMore}
            QuickUpdate(fSeperator);
            NQMore;
            GOTO 5;
            END
         ELSE GOTO 7;
         END
     ELSE IF (evDsc.tyev <> tyevKey) AND (evDsc.tyev <> tyevInChar) THEN
         GOTO 7
     ELSE IF evDsc.fAppleKey THEN
         GOTO 7
     ELSE BEGIN
         IF FDequeue(q, @evDsc) THEN BEGIN END;
         END;
6:
     END (* WHILE TRUE *);

7:   (* No more keys queued up *)
IF NOT evDsc.fRepeatKey THEN QuickUpdate(fSeperator);
END;


{$S LWCommand}
{-------------------------}
PROCEDURE HandleLotusEvent {(VAR evDsc: TEvDsc; VAR actArea: TActArea; VAR ctickTimeout: TC)};
{-------------------------}
VAR ptT: TPt;
    oboxPane, oboxTab: TC;
    orecScrap: TC;
    lpFst:      TLp;
    lpLim:      TLp;
    pint:       TPint;
    icsSel:     TB;
    pbox, pboxPane:   TPbox;
    orecCon:    TC;
    recCon:    TRec;
    dyPScroll: TC;
    pintSel:  TPint;
    lpFstSel: TLp;
    lpLimSel: TLp;
    lfp:      TLfp;
    ointSel: TC;
    cError: TC;
    sp: TSp;
    path,
    pathOld,
    volname: Pathname;
    password,
    passOld,
    ename: E_Name;
    refInfo: Fs_Info;
    fUCSD: TF;
    fSeperator: TF;
    iDot: TC;
    ics: TB;
    filnamCurr: Str255;
    cErrorWrite: TC;
    orecSib: TC;
    recIns: TRec;
    HMReturn: TSpReturn;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$ifc fDbgOk}
IF fTstLotus THEN BEGIN WRITELN('Lotus event:'); PxEvDsc(evDsc); END;
{$endc}
oboxPane := evDsc.obox;
        (*              testing obox
        Write ('obox: ', oboxPane : 1);
        if oboxPane = oboxMenu then Write (', oboxMenu');
        if oboxPane = oboxActive then Write (', oboxActive');
        if oboxPane = oboxNil then Write (', oboxNil');
        if oboxPane = oboxScrap then Write (', oboxScrap');
        Write ('; tyev: ');
        PxTyEv (evdsc.tyev);
        writeln;
        *)
SetPort(@aport);
IF (oboxPane <> oboxNil) AND (oboxPane <> oboxMenu) THEN VisObox(oboxPane);
ptT := evDsc.r.topLeft;
ctickTimeout := 0;
IF (                 (evDsc.tyev = tyevTimeout)
                  OR ((evDsc.tyev = tyevMove) AND (NOT evDsc.fMouseButton))
                  )
 AND (activeFolder <> scrapFolder) THEN
    BEGIN
    IF selCur.oint <> ointNil THEN
         BEGIN
         pint := POINTER(ORD(lldInt)+selCur.oint);
         icsSel := pint^.ics;
         lpFst := pint^.lpFst;
         lpLim := pint^.lpLim;
         END
    ELSE icsSel := icsNil;
    IF fPrvTimeout THEN
          BEGIN
          ValidateDsp;
          IF fForceSelInWw THEN
               BEGIN
               VerifyOrecConDwn(icsSel);
               IntInWindow(selCur.oint, orecConDwn);
               fForceSelInWindow := FALSE;
               END;
          { Now is a good time to ensure the thumb is properly placed }
          UpdateThumbs;
          IF (icsSel <> icsNil) AND (lpFst = lpLim) THEN
               BEGIN
               ShowSel(selCur, tyshowToggle);
               SetOrecIns(icsSel, lpFst);
               END
          ELSE orecIns := orecNil;
          IF selCur.fShowing THEN
               ctickTimeout := caretOnTime (* was ctickOnCaret *)
          ELSE ctickTimeout := caretOffTime (* was ctickOffCaret *);
          END
     ELSE BEGIN
          { QuickUpdate(FALSE); }
          ctickTimeout := ctickFstTimeout;
          VerifyMarginRuler(icsMarginRuler);
          END;
    fPrvTimeout := TRUE;
    END
ELSE BEGIN
     fPrvTimeout := FALSE;
     { interacts badly with type ahead/validation of screen during ShowSel
     IF selCur.oint <> ointNil THEN ShowSel(selCur, tyshowOn);
     }
     IF (evDsc.tyev = tyevKey) OR (evDsc.tyev = tyevInChar) THEN
          HandleTyevKey(evDsc)
     ELSE BEGIN
          orecIns := orecNil;
          CASE evDsc.tyev OF
          tyevDwn,
          tyevDblClick,
          tyevTripleClick:
                BEGIN
                IF oboxPane <> oboxScrap THEN
                     BEGIN
                     IF evDsc.tyev = tyevDwn THEN RemoveKid(FALSE);
                     IF ( evDsc.windowCurr = dialogFolder) and (fDboxIsOpen) THEN
                        BEGIN
                        IF ftstSpell THEN writeln('Mouse down in the dialog box');
                        SetDPort;
                        DboxPrcsProc(eventPrev)
                        END
                     ELSE
                        BEGIN
                        pboxPane := PboxFromObox(oboxPane);
                        orecConDwn := pboxPane^.refCon;
                        orecConDwn := OrecOfPt(orecConDwn, TRUE, ptT, FALSE);
                        recCon := POINTER(ORD(dsp) + orecConDwn);
                        pint := POINTER(ORD(lldInt) + recCon^.ointDep);
                        icsDwn := pint^.ics;
                        IF rghcs^[icsDwn]^^.tycs = tycsRuler THEN
                          MoveRm(ptT, icsDwn)
                        ELSE
                          CASE evDsc.tyev OF
                          tyevDwn: BEGIN
                                   IF evDsc.fShiftKey THEN
                                     LGrowSel(ptT, orecConDwn)
                                   ELSE BEGIN
                                     LSelect(ptT, tyselPt, orecConDwn);
                                     IntInWindow(selCur.oint, orecConDwn);
                                     fForceSelInWindow := FALSE;
                                     IF icsMarginRuler <> icsNil THEN
                                       SelToRuler(icsMarginRuler, orecNil, TRUE, TRUE);
                                     END;
                                   END;
                          tyevDblClick:    LSelect(ptT, tyselWd, orecConDwn);
                          tyevTripleClick: LSelect(ptT, tyselPar, orecConDwn);
                          END;
                        END;
                   END;
                END;
          tyevMove:
                BEGIN
                IF evDsc.fMouseButton THEN
                     BEGIN
                     IF (oboxPane <> oboxScrap) AND (icsDwn <> icsNil) THEN
                       BEGIN
                       pboxPane := PboxFromObox(oboxPane);
                       orecConDwn := pboxPane^.refCon;
                       orecConDwn := OrecOfPt(orecConDwn, TRUE, ptT, FALSE);
                       IF rghcs^[icsDwn]^^.tycs = tycsRuler THEN
                             BEGIN
                              MovingRm(ptT, icsDwn, oboxPane);
                             END
                       ELSE BEGIN
                             IF evDsc.fAutoScroll THEN DoScroll(evDsc.scid,
                             evDsc.dir);
                             LGrowSel(ptT, orecConDwn);
                            END;
                       END;
                     END;
                END;
          tyevUp:
                BEGIN
                IF (oboxPane <> oboxScrap) AND (icsDwn <> icsNil) THEN
                     BEGIN
                     IF rghcs^[icsDwn]^^.tycs = tycsRuler THEN
                          BEGIN
                          InitChronicle;
                          MovedRm(selCur.oint, icsDwn);
                          END
                     ELSE ObscureCursor;
                     END;
                icsDwn := icsNil;
                END;
          tyevUpdate:
                BEGIN
                IF ( evDsc.obox = oboxDbox) THEN BEGIN END
                ELSE
                   BEGIN
                   pboxPane := PboxFromObox(oboxPane);
                   WITH evDsc.r DO
                        IF (left <> right) OR (top <> bottom) THEN
                          InvalidR(evDsc.r, tyxyScrn, pboxPane^.refCon);
                   ValidateDsp;
                   END;
                END;
          tyevDeactivated:
                BEGIN
                oboxPane := OboxFstOnSc(ScidFstFromFid(evDsc.fid, tyvhV));

                IF fTstLotus THEN WRITELN (CHR(7),'!!! tyevDeactivated');

                IF oboxPane <> oboxScrap THEN
                     BEGIN
                     RmvAnyDbox;
                     DisplayFstSubImtd(imtdNil);
                     pboxPane := PboxFromObox(oboxPane);
                     orecConDwn := pboxPane^.refCon;
                     recCon := POINTER(ORD(dsp) + orecConDwn);
                     pint := POINTER(ORD(lldInt)+selCur.oint);
                     recCon^.ointSel := OintMark(recCon^.ointSel, pint^.ics,
                     pint^.lpFst,
                       pint^.lpLim, TRUE, ointNil);
                     ShowSel(selCur, tyshowOff); (* make this tyshowLightGray
                     some
                     day *)
                     ValidateDsp;
                     END;
                 pbox := POINTER(ORD(bdsp) + oboxPane);
                 SetPort(pbox^.window);
                 DrawLotusPicture(pbox^.window);  (* draw a 'picture' for
                                                     the window manager *)
                 InitChronicle; (* don't want to Undo actions  *)
                 imtdPrv := 0;  (* on inactive windows *)
                 SetStdCursor(icrsHidden);
                 HMReturn := SpTerminate(closeFile);
                 {$ifc fDbgOk}
                 IF ftstSpelling THEN IF (HMReturn <> Ok) THEN
                    BEGIN
                    ParamAlert(ShowReturn (ord (HMReturn))^, '', '');
                    NoteAlert(WPAlerts, 80);
                    END;
                 {$endc}
                END;
          tyevActivated:
                BEGIN

                IF fTstLotus THEN WRITELN (CHR(7),'!!! tyevActivated');

                oboxPane := OboxFstOnSc(ScidFstFromFid(evDsc.fid, tyvhV));
                DrawInitialMenu(oboxPane = oboxScrap);
                GetTyRlu(icsActive, tyrluCurrent); (* set tyrluCurrent to
                            ruler unit type of active document *)
                IF oboxPane <> oboxScrap THEN
                     BEGIN
                     DisplayFstSubImtd(imtdNil);
                     pboxPane := PboxFromObox(oboxPane);
                     orecConDwn := pboxPane^.refCon;
                     recCon := POINTER(ORD(dsp) + orecConDwn);
                     ointSel := recCon^.ointSel;
                     IF ointSel = ointNil THEN
                       BEGIN
                       pint := POINTER(ORD(lldInt) + recCon^.ointDep);
                       LSetSel(pint^.ics, 0, 0);
                       END
                     ELSE BEGIN
                       pint := POINTER(ORD(lldInt) + ointSel);
                       icsSel := pint^.ics;
                       LSetSel(icsSel, pint^.lpFst, pint^.lpLim);
                       FreeInt(icsSel, ointSel);
                       recCon^.ointSel := ointNil;
                       END;
                     END;
                END;
          tyevScroll:
                BEGIN
                DoFolderUpdate(evDsc.windowCur);
                DoScroll(evDsc.scid, evDsc.dir);
                END;
          tyevThumb:
                DoThumb(evDsc.scid, evDsc.cPct);
          tyevPScroll:
                BEGIN
                DoFolderUpdate(evDsc.windowCur);
                DoPScroll(evDsc.scid, evDsc.dir);
                END;
          tyevCmd:
                DoMenuCommand(evDsc.imtd, evDsc.imid);
          tyevScNew:
                DoScNew(evDsc.scidOld, evDsc.scid);
          tyevPaneKill:
                BEGIN
                orecCon := evDsc.refCon;
                WHILE orecCon <> orecNil DO
                     BEGIN
                     recCon := POINTER(ORD(dsp) + orecCon);
                     pint := POINTER(ORD(lldInt) + recCon^.ointDep);
                     ics := pint^.ics;
                     { this test should not be necessary - ruler stream needs
                     work
                     }
                     IF (ics = icsPageRuler) THEN
                          BEGIN
                          orecSib := recCon^.orecSib;
                          RemovePageRuler;
                          DisplaySubImtd(imtdNil);
                          END
                     ELSE IF (ics = icsMarginRuler) THEN
                          BEGIN
                          orecSib := recCon^.orecSib;
                          FreeIcs(ics);
                          icsMarginRuler := icsNil;
                          DisplaySubImtd(imtdNil);
                          END
                     ELSE orecSib := OrecSibFree(orecCon);
                     orecCon := orecSib;
                     END;
                orecConDwn := orecNil;
                END;
          tyevScResize:
                DoScResize(evDsc.scid, evDsc.dcdAdjust, evDsc.fAdjFront);
          tyevDClose:
                BEGIN
                oboxTab := FidOfWindow(evDsc.windowCurr);
                oboxPane := OboxFstOnSc(ScidFstFromFid(oboxTab, tyvhV));
                ics := IcsEdFromPane(oboxPane, orecCon);

                IF fTstLotus THEN WRITELN (CHR(7),'!!! tyevDClose FEdited: ',
                                           FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))));

                IF FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))) THEN BEGIN
                     (* WaitAlert (WPAlerts, 40); *)
                     pbox := PboxFromObox(oboxTab);
                     PathOfOboxTab(oboxTab,path,password);
                     StripExtension(path);
                     KillDoc(cError, CONCAT(path, 'NEW'), password);
                                   {Shouldn't be necessary, but just in case...}
                     WriteAnyFolder(cErrorWrite, ics, oboxTab,
                                    CONCAT(path, 'NEW'), password);
                     IF cErrorWrite <=0 THEN BEGIN
                         KillDoc(cError, path, password);
                         SplitPathname(path, volname, ename);
                         RenameDoc(cError, CONCAT(path, 'NEW'), ename, password);
                         KillDoc(cError, CONCAT(path, 'TEMP'), password);
                         DiscardFolder(oboxTab);
                         ReleaseStreams;
                         TellFiler(cError, docClosd, allOK, evDsc.windowCurr);
                         END
                     ELSE BEGIN
                         KillDoc(cError, CONCAT(path, 'NEW'), password);
                         TellFiler(cError, docNotClosed, FReasonWhy(cErrorWrite), evDsc.windowCurr);
                         END;
                  END ELSE {not FEdited, so} BEGIN
                         (* WaitAlert (WPAlerts, 41); *)
                         DiscardFolder(oboxTab);
                         ReleaseStreams;
                         TellFiler(cError, docClosd, allOK, evDsc.windowCurr);
                  END;
                  (* EndWaitAlert; *)
                END;

          tyevDPut:
                BEGIN
                oboxTab := FidOfWindow(evDsc.windowCurr);
                oboxPane := OboxFstOnSc(ScidFstFromFid(oboxTab, tyvhV));
                ics := IcsEdFromPane(oboxPane, orecCon);

                IF fTstLotus THEN WRITELN (CHR(7),'!!! tyevDPut FEdited: ',
                                           FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))));

                pbox := PboxFromObox(oboxTab);
                PathOfOboxTab(oboxTab, pathOld, passOld);
                path := pathGlobal;
                password := passGlobal;
                KillDoc(cError, CONCAT(path, 'NEW'), password);
                {Probably unnecessary, but safe}
                WriteAnyFolder(cErrorWrite, ics, oboxTab,
                               CONCAT(path, 'NEW'), password);
                IF cErrorWrite <=0 THEN BEGIN
                    KillDoc(cError, path, password);
                    SplitPathname(path, volname, ename);
                    RenameDoc(cError, CONCAT(path, 'NEW'), ename, password);
                    KillDoc(cError, CONCAT(path, 'TEMP'), password);
                    StripExtension(pathOld);
                    KillDoc(cError, pathOld, passOld);
                    KillDoc(cError, CONCAT(pathOld, 'NEW'), passOld);
                    KillDoc(cError, CONCAT(pathOld, 'TEMP'), passOld);
                    DiscardFolder(oboxTab);
                    ReleaseStreams;
                    TellFiler(cError, docXfered, allOK, evDsc.windowCurr);
                    END
                ELSE BEGIN
                    KillDoc(cError, CONCAT(path, 'NEW'), password);
                    TellFiler(cError, docNotXfered, FReasonWhy(cErrorWrite),
                              evDsc.windowCurr);
                    END;
                END;

          tyevDCopy:
                BEGIN
                oboxTab := FidOfWindow(evDsc.windowCurr);
                oboxPane := OboxFstOnSc(ScidFstFromFid(oboxTab, tyvhV));
                ics := IcsEdFromPane(oboxPane, orecCOn);

                IF fTstLotus THEN WRITELN (CHR(7),'!!! tyevDCopy FEdited: ',
                                           FEdited (IcsBodyOfIcs (IcsOfObox (oboxTab))));

                path := pathGlobal;
                password := passGlobal;
                StripExtension(path);
                WriteAnyFolder(cError, ics, oboxTab, path, password);
                IF cError <= 0 THEN
                    TellFiler(cError, docXfered, allOK, evDsc.windowCurr)
                ELSE
                    TellFiler(cError, docNotXfered, FReasonWhy(cError),
                    evDsc.windowCurr);
                END;


          tyevDShred,
          tyevSuspend:
                BEGIN

                IF fTstLotus THEN WRITELN (CHR(7),'!!! tyevSuspend, tyevDShred');

                oboxTab := FidOfWindow(evDsc.windowCurr);
                SuspendDocument(cError, oboxTab, TRUE);
                ReleaseStreams;
                IF (cError <= 0) OR (evDsc.tyev = tyevDShred) THEN
                    TellFiler(cError, docClosd, allOK, evDsc.windowCurr)
                ELSE TellFiler(cError, docNotClosed, FReasonWhy(cError), evDsc.windowCurr);
                END;


          tyevResume:
                BEGIN

                IF fTstLotus THEN WRITELN (CHR(7),'!!! tyevResume');

                GetFldrTitle(evDsc.windowCurr, filnamCurr);
                IF FMonitorFile(filnamCurr) THEN BEGIN
                    OpenDocument(cError, filnamCurr, filnamCurr, evDsc.windowCurr, TRUE, FALSE, '');
                    TakeWindow(evDsc.windowCurr);
                    (* TellFiler(cError, docOpened, allOK, evDsc.windowCurr); *)
                    END
                ELSE BEGIN
                    path := pathGlobal;
                    password := passGlobal;
                    OpenDocument(cError, filnamCurr, CONCAT(path,'TEMP'), evDsc.windowCurr,
                                 TRUE, FALSE, password);
                    IF cError = 948 {not in catalog} THEN
                        OpenDocument(cError, filnamCurr, path, evDsc.windowCurr, TRUE, TRUE, password);
                    IF cError <= 0 THEN BEGIN
                        TakeWindow(evDsc.windowCurr);
                        (* TellFiler(cError, docOpened, allOK,
                        evDsc.windowCurr);
                        *)
                        END
                    ELSE
                        TellFiler(cError, docClosd, FReasonWhy(cError),
                        evDsc.windowCurr);
                    END;
                fForceSelInWw := TRUE;
                END;


          tyevDfClose:
                BEGIN
                { Write all streams referencing portions of the file refnum }
                IF fTstLotus THEN BEGIN
                        INFO (cError, evDsc.cRefnum, refInfo);
                        WRITELN (CHR(7),'!!! tyevDfClose refnum: ', evDsc.cRefnum : 1, ', ', refInfo.name);
                END;
                FOR ics := 0 TO icsMac-1 DO BEGIN
                    IF rghcs^[ics] <> POINTER(ORD(hNil)) THEN
                        CASE rghcs^[ics]^^.tycs OF
                          tycsPg,
                          tycsEd:
                            IF FUsesRefnum(ics, evDsc.cRefnum) THEN BEGIN
                                 IF fTstLotus THEN
                                    WRITELN('ics', ics, ' references disk file');
                                 oboxTab := OboxTabOfIcs(ics);
                                 IF oboxTab = OboxFldr(oboxScrap) THEN
                                    BEGIN
                                    LotusPutScrap;  LotusGetScrap;
                                    END
                                 ELSE IF oboxTab <> oboxNil
                                    THEN RestartDocument(cError, oboxTab,
                                    TRUE)
                                 ELSE IF ics = icsUndo
                                    THEN InitChronicle
                                    ELSE RestartIcs(ics);
                                 END;
                        END;
                   END;
                ReleaseStreams;
                TellFiler(cError, dfClosed, allOK, evDsc.windowCurr);
                END;
          END (* CASE *);
     END;
END (* IF *);
END (* HandleLotusEvent *);


{$S LWCreate}
{-----------------------------------}
FUNCTION InitLHeap(cbHz: TC): THz;
{-----------------------------------}
VAR logIpnLim: TC;
    pLim:   TP;
    ipMac:  TC;
    pBase:  TP;
    pFst:   TP;
    hz:     THz;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
logIpnLim := 1;
ipMac := 50;
pBase := POINTER(ORD(PRegGlobals)-20000); {This should be a pointer
                                         to the lowest global!!!}
pFst := PAllocCb(cbHz);
pLim := POINTER(ORD(pFst)+cbHz);
IF fTstLotus THEN
   BEGIN
   WRITELN('InitLHeap - pFst: ', ORD(pFst), ', pLim: ', ORD(pLim),
          ', pBase: ', ORD(pBase), ', ipMac: ', ipMac);
   END;
hz := HzInit(pFst, pLim, pBase, ipMac, logIpnLim, @CbMoreLotusGrowSeg,
  @FilCbOfN, @FilFSwapInN, @FilSwapOutN);
    IF fTstHzScramble THEN
       BEGIN
       hz^.fScramble := TRUE;
       hz^.fCheck := TRUE;
       END;
InitLHeap := hz;
END;

{$S LWMisc}
{--------------------}
PROCEDURE FailedAlert;
{--------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
StopAlert(WPAlerts, 2);
END;

{$S LWCreate}
{-------------------}
PROCEDURE LInitAlert;
{-------------------}
VAR (* refNum: TC; *)
        cError: Integer;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
(* old style alerts
InitAlerts(5, 2300, theHeap, nil, @FailedAlert);
IF alertError > 0 THEN FailedDuringInit(internalError);
OpenPhraseFile(refNum, CONCAT(spLotusPrefix, '{T1}')) ;
IF alertError > 0 THEN FailedDuringInit(internalError);
WPAlerts := ReadAlerts(refNum, cAlertVersion);
IF alertError > 0 THEN FailedDuringInit(internalError);
*)
InitMP (theHeap, concat(spLotusPrefix, '{T1}'), @FailedAlert,
        cAlertVersion, @argMenu [imtdScrap], WPAlerts, cError);
IF cError > 0 THEN FailedDuringInit (internalError);
END; {LInitAlert}

{------------------}
PROCEDURE InitLotus;
{------------------}
VAR rPane: TR; spT: TSp; scid: TScid;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
OpenPort(@aport);
IF fTstLotus THEN WRITELN('InitLotus');
fUndoLst := FALSE;
fForceSelInWw := FALSE;
icsDwn := icsNil;

hzLotus := InitLHeap(12288) (* this must be a multiple of 512 *);
InitRuler(hzLotus);
InitSel;
InitDsp(hzLotus);
{InitJournal(NOT fReplay);}
InitKid(hzLotus);
InitFfForLotus;

InitLScrap(hzLotus);
oboxScrap := OboxOpenWindow(icsScrap, scrapFolder, '', oboxNil,
                            FALSE (* don't paint the pane *));
scid := ScidFromObox(oboxScrap, tyvhH);
SetLSbIcons(scid, []);
scid := ScidFromObox(oboxScrap, tyvhV);
SetLSbIcons(scid, []);

InitCom(hzLotus);
InitLDialog;
SetHzSpell(hzLotus);  {Communicate the hz to the Spelling Checker}
icsFind := icsNil;
icsPageRuler := icsNil;
orecConDwn := orecNil;
spT := ' ';
spT[1] := CHR(chCr);
icsCr := IcsUsCreate(spT, hzLotus);
InitUndo(hzLotus);
InitSrch;

imtdPrv := 0;  {No last menu command}
imidPrv := 0;
fGenOrec := FALSE;
END;

END.


