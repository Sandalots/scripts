{$I APLW/COMPFLAGS }                                            {gdf 1/16/84}
{$R-}

UNIT EventMgr;

(* Copyright 1983, 1984, Apple Computer Inc. *)

{ gdf  2/29/84 -- put in Janis' stuff: tyevInChar  }
{ gdf  2/28/84 -- complete procedure tracing & fTraceCalls  }
{ gdf  2/24/84 -- insert trace calls for segmentation  }
{ med  2/23/84 -- made imtdScrap the first element of argMenu  }
{ gdf  1/23/84 -- fix printing defaults for screen only  }
{ gdf  1/16/84 -- printing compile flag & include COMPFLAGS added }
{ tjm  1/12/84 -- changes for spring filer (with gdf)}
{ crc  4/19/83 -- DrawLotusPicture: magic to fix(?) split pane picture problem }
{ crc  3/11/83 -- NewPrprf: Call AdjustLps on body, header & footer }
{ tjm  3/09/83 -- Call ScidFromObox at 777: (WP 234) }
{ crc  2/22/83 -- DrawLotusPicture: set rBBox from thePort^.portRect }
{ crc  2/15/83 -- Throw away keyDown events for clear & arrow keys }
{ crc  2/14/83 -- DispatchEvent now recognizes tyevDShred }
{ crc  2/10/83 -- Guts of folderUpdate now procedure DoFolderUpdate }
{ crc  2/09/83 -- GetWwEvent: set evDsc.windowCurr on buttonDown for use by
                  HandleLotusEvent in tyevScroll & tyevPScroll }
{ crc 11/29/82 -- NewPrprf sets header & footer of ed-type streams }
{ jrm 11/23/82 -- kill picture on Activate, draw picture on any Deactivate }
{ crc 11/15/82 -- No parm to InitPrt; PAllocCb limits ldsn to 11;
                  calls BindUTDSeg; streamlined filer protocols; InitWmlCrs }
{ crc 11/05/82 -- More rearrangement of menu items }
{ jrm 10/15/82 -- added RecScrapToOboxScrap call }
{ crc 10/12/82 -- cbHzLily increased to 10K }
{ crc 10/07/82 -- Rearrange menu items }
{ crc  9/24/82 -- fcNone & fcShred }
{ crc  9/17/82 -- reduced cbHzLily; HeapFull retired; ipPoolMac down to 50;
                  fcPut generates tyevDPut }
{ crc  9/01/82 -- PAllocCb allocates named, disk-resident data segments }
{ jrm  8/30/82 -- auto scrolling }
{ jrm  8/23/82 -- fixed dragging through split panes: removed rActive, etc. }
{ bas  8/20/82 -- sb border for folder update }
{ jrm  8/10/82 -- 5.2 release stuff... new ldsn values, tyevDOpen => tyevResume,
                  tyevDfClose, tyevResume, etc. }
{ bas  7/29/82 -- cursors }
{ bas  7/28/82 -- folder update rework }
{ crc  7/27/82 -- NewPrprf now updates prprf of paginated documents correctly;
                  uses UnitPg }
{ jrm  7/23/82 -- fixed oboxDwn bug }
{ bas  7/20/82 -- no folder size change on de-/activation; no call to getsymbols }
{ jrm  7/19/82 -- added FixRectsOf(scrapFolder) call }
{ jrm  7/ 6/82 -- added FailedDuringInit; renamed and rearranged imids }
{ jrm  7/ 1/82 -- commented out references to trayMenu and trayCommand;
                  changed doubleTime to clickDelay; discarded AbortEvent;
                  new parameters to TakeControl }
{ jrm  7/ 1/82 -- set oboxDwn to oboxNil if a Filer event is seen }
{ jrm  6/29/82 -- USES changes: LisaGraf => QuickDraw; moved USES UnitFile }
{ crc  6/17/82 -- Added IcsOfObox }
{ jrm  6/ 4/82 -- Removed argfam initialization and InitCs, InitFmt calls }
{ crc  6/02/82 -- Conditional compilation }
{ crc  5/28/82 -- Argfont initialization expanded }
{ crc  5/27/82 -- Modified NewPrprt to call AdjustRulerPrprf, USES UnitRuler }
{ jrm  5/26/82 -- removed FidCreateFolder call for Scrap; removed prcsMine;
                  removed .prcs reference when setting the cursor }
{ crc  5/26/82 -- IcsActive & prcsMine moved in from UnitCom }
{ crc  5/25/82 -- print manager integration; added global vars icsPageRuler
                  and icsMarginRuler from UnitCom; created NewPrprf }
{ jrm  5/25/82 -- interprocess Scrap }
{ crc  4/02/82 -- integration with new font manager }
{ bas  3/19/82 -- add tyxy parm to InvalidR }
{ jrm  3/16/82 -- filer stub integration }
{ bas  2/25/82 -- smart folderUpdate }
{ jrm  2/11/82 -- Filer stub follies }
{ bas  2/12/82 -- lisaprint uses }
{ jrm  2/ 3/82 -- yet another O.S. conversion... }
{ jrm  1/28/82 -- integration with new menumgr }
{ bas 01/26/82 -- wm lib-style upgrade }

INTERFACE

USES
    {$IFC sampcalls}                                               {gdf 2/24/84}
       {$U aplw/tracecalls.obj} tracecalls,
    {$ENDC}
    {$U Obj:Unitstd    } UnitStd,
    {$U LibOS/Syscall } Syscall,
    {$U Obj:UnitHz     } UnitHz,
    {$U Obj:UnitFile   } UnitFile,
    {$U Obj:Storage    } Storage,
    {$U Obj:QuickDraw  } QuickDraw,
    {$U Obj:FontMgr    } FontMgr,
    {$U Obj:WM.Events  } Events,
    {$U Obj:WM.Folders } Folders,
    {$U Obj:WM.Menus   } Menus,
    {$U Obj:WmlStd     } WmlStd,
    {$U Obj:WmlCrs     } WmlCrs,
    {$U Obj:Filercomm  } Filercomm,
    {$U Obj:PmDecl     } PmDecl,
     {$IFC fPrintOld}                                               {gdf 1/16/84}
        {$U Obj:PrStd.Obj }     PrStd,
        {$U Obj:PrFile.Obj }    PrFile,
        {$U Obj:PrProcs.Obj }   PrProcs,
        {$U Obj:PrMgrUtil.Obj } PrMgrUtil,
        {$U Obj:PrMgr.Obj }     PrMgr,
     {$ELSEC}
        {$U Obj:PrStdInfo.Obj } PrStdInfo,
        {$U Obj:PrPublic.Obj }  PrPublic,
     {$ENDC}                                                        {gdf 1/16/84}
    {$U Obj:UnitFmt    } UnitFmt,
    {$U Obj:UnitCs     } UnitCs,
    {$U Obj:UnitFf     } UnitFf,
    {$U Obj:Scrap      } Scrap,
    {$U Obj:AlertMgr   } AlertMgr,
    {$U ApLW/Queue      } Queue,
    {$U ApLW/UnitBox    } UnitBox,
    {$U ApLW/BoxScid    } BoxScid,
    {$U ApLW/UnitRec    } UnitRec,
    {$U ApLW/UnitOver   } UnitOver,
    {$U ApLW/UnitTld    } UnitTld,
    {$U ApLW/UnitUf     } UnitUf,
    {$U ApLW/UnitEd     } UnitEd,
    {$U ApLW/UnitDsp    } UnitDsp,
    {$U ApLW/UnitPg     } UnitPg,
    {$U ApLW/UnitRuler  } UnitRuler,
    {$U ApLW/UnitScrap  } UnitScrap,
    {$U ApLW/UnitPrt    } UnitPrt,
    {$U ApLW/UnitFolder } UnitFolder,
    {$U ApLW/BoxMgr     } BoxMgr,
    {$U ApLW/Dmgr       } DMgr;

CONST
    {$IFC NOT fDbgOk} fTstEvh = FALSE; fTstHzScramble = FALSE; {$ENDC}
     myTest = False;

     ldsnPrint = 1; (* LDSN for the print manager *)

     imtdScrap = 1;
     imtdFst = 2;
     imtdLst=12;

     imtdFile = 2;
        imidClsAll      =  1;
        imidClose       =  2;
        imidNil1        =  3;
        imidPutBack     =  4;
        imidSavAndCont  =  5;
        imidRevert      =  6;
        imidNil2        =  7; {what is this for & where did it come from?-->'<--}
        imidAsIsPrint   =  8;
        imidPrPrf       =  9;
        imidPrint       = 10;
        imidPrBgdDlg    = 11;
        {$IFC fDbgOk}
        imidNil3        = 12;
        imidQuit        = 13;
        {$endc}
     imtdInvisible = 12;
        imidGuess = 1;
        imidGNext = 2;

VAR
   {$IFC fDbgOk} fTstEvh: TF; fTstHzScramble: TF; {$ENDC}
   {$IFC sampcalls}                                               {gdf 2/24/84}
      fTraceCalls: TF;
   {$ENDC}
   q: TQ;
   hzLily: THz;
   ldsnCurr: TC;
   fToldToDie: TF;
   fCbMoreFailed: TF;
   icsMarginRuler: TB;
   icsPageRuler:   TB;
   eventPrev: EventRecord;
   fcPrev:    FilerOp;   {tjm 1/12/84 - changes for spring filer}
   pathGlobal: Pathname; (* replaces evDsc.spPathname *)
   passGlobal: E_name;
   argMenu: ARRAY [imtdScrap..imtdLst] OF MenuInfo;
   myObox: TC;

PROCEDURE  InitLily;
PROCEDURE  InitEvMgr;
PROCEDURE  GetNextEvent     (VAR evDsc: TEvDsc; actArea: TActArea; ctickTimeout: TC);
FUNCTION   PAllocCb         (cbAlloc: TL): TP;
{FUNCTION   HeapFull         (hz: THz; cbNeeded: TC): TC;}
FUNCTION   PRegGlobal:      TP;

{$IFC fPrintOld}                                                    {gdf 1/16/84}

PROCEDURE  NewPrprf         (ics: TB; prprf: TPrprf);

{$ELSEC}                                                            {gdf 1/16/84}

PROCEDURE  NewPrprf         (ics: TB; prprf: TPrRec);  {???}

{$ENDC}                                                             {gdf 1/16/84}

FUNCTION   IcsActive:       TB;
FUNCTION   IcsOfObox        (obox: TC): TB;
PROCEDURE  DrawLotusPicture (wdw: TWindow);
PROCEDURE  DoFolderUpdate   (window: TWindow);
FUNCTION   CbMoreLotusGrowSeg(hz: THz; cbNeed: TC) : TC;

IMPLEMENTATION


{$IFC fSymOK }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

CONST lScrollInterval = 10 (* 0.1 seconds - time interval, in  100 hz units,
                             between successive line scroll events *);
     lPScrollInterval = 50 (* 0.5 seconds - time interval, in 100 hz units,
                             between successive page scroll events *);
     chLeftArrow  = 28;
     chRightArrow = 29;
     chUpArrow    = 30;
     chDownArrow  = 31;

     chBackspace  =  8;
     chClear      = 27;
     chEnter      =  3;

TYPE TAbsEvd = RECORD
           tyev:   TTyev;
           ch:     CHAR;
           pt:     TPt;
           fButton:    TF;
           window: TWindow;
           END;


VAR
(*  oboxDwn: TC; moved to queue *)
(* rActive: TR; *)
   fEnabling, fGNEReturn: Boolean;
   lLastUp: LONGINT (* time in hundredths of a second of the last Up *);
   lLastScroll: LONGINT (* time when the last line scroll event was sent *);
   lLastPScroll: LONGINT (* time when the last page scroll event was sent *);
   fAlpha, fShift, fApple, fCode: TF; fRepeat: TF;
   fDwnWasDbl: TF (* TRUE iff last mouse down was a double- or triple-click *);
   timeStart: LongInt;

PROCEDURE SetDPort; EXTERNAL;

FUNCTION PRegGlobal; EXTERNAL;

{$S LWStyle}
{----------------------------------------------------------}
FUNCTION CbMoreLotusGrowSeg (* hz: THz; cbNeed: TC) : TC *);
{----------------------------------------------------------}
CONST
    cbIncrement = 2048;    {Must be power of 2}
VAR errnum  : integer;
    refnum : integer;
    cbMem  : longint;
    cbDisk  : longint;
    cbNeedDisk: TC;
    dsinfo: DsInfoRec;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF cbNeed < (MAXINT - cbIncrement) THEN
     cbNeed := WAnd(cbNeed + cbIncrement - 1, WNot(cbIncrement - 1));

Info_Address(errnum, ORD(hz), refnum);
IF errnum = 0 THEN
     BEGIN
     Info_DataSeg(errnum, refnum, dsinfo);
     IF errnum = 0 THEN
          BEGIN
          IF dsinfo.Disc_Size = 0 THEN
               cbNeedDisk := 0
          ELSE cbNeedDisk := cbNeed;
          Size_DataSeg(errnum, refnum, cbNeed, cbMem, cbNeedDisk, cbDisk);
          END;
     END;
IF errNum = 309 THEN
       BEGIN
       Size_DataSeg(errnum, refnum, cbNeed, cbMem, 0, cbDisk);
       fCbMoreFailed := TRUE;
       StopAlert(WPAlerts, 26);
       END;
IF errNum <> 0 THEN
       BEGIN
       StopAlert(WPAlerts, 22);
       KillLotus;
       END;
CbMoreLotusGrowSeg := (cbMem - dsinfo.Mem_Size);
(*$IFC fDbgOk *)
IF fTstHz THEN
     WRITELN('CbMoreLotusGrowSeg: cbNeed: ',cbNeed:1,', cbMem: ', cbMem:1,
               ', cbDisk: ', cbDisk:1);
(*$ENDC *)
END;


{$S LWCreate}
{----------------------------------------------------------}
FUNCTION PAllocCb (* (cbAlloc: TL): TP *);
{----------------------------------------------------------}

{$IFC fOS}

   VAR cErrnum: TC;
      cRefnum: TC;
      lSegptr: LONGINT;
      sSegname: pathname;
      dsinfo: DsInfoRec;
      lNewMemSize, lNewDiscSize: LONGINT;
      freasonWhy: FReason;

  BEGIN
     {$IFC sampcalls}  ALogCall;  {$ENDC}
     IF fTstEvh THEN WRITELN('OS version of PAllocCb');
     IF (cbAlloc MOD 512) <> 0 THEN Break(1002);
     ldsnCurr := ldsnCurr + 1;
     IF ldsnCurr > 11 THEN Break(1000);
  (* this version creates named, disc-resident segments... *)
     sSegname := 'X ';
     sSegname[1] := CHR(ORD('@') + ldsnCurr);
     OPEN_DATASEG(cErrnum, sSegname, cRefnum, lSegptr, ldsnCurr);
     IF fTstEvh THEN WRITELN('OPEN_DATASEG returned; cErrnum = ', cErrnum);
     IF cErrnum <> 0 THEN { dataseg did not already exist }
        BEGIN
        IF fTstEvh THEN WRITELN('about to make a new dataseg...');
        MAKE_DATASEG(cErrnum, sSegname, cbAlloc, cbAlloc,
                     cRefnum, lSegptr, ldsnCurr, ds_private);
        IF cErrnum <> 0 THEN
           BEGIN
           IF cErrnum = 309 THEN freasonWhy := noDiskSpace ELSE
           IF cErrnum = 315 THEN freasonWhy := noMemory ELSE
              freasonWhy := internalError;
           FailedDuringInit(freasonWhy);
           END;
        END
     ELSE { dataseg opened successfully ... is it the right size ? }
        BEGIN
        INFO_DATASEG(cErrnum, cRefnum, dsinfo);
        IF cErrnum <> 0 THEN
           BEGIN
           IF fTstEvh THEN WRITELN('In PAllocate: INFO_DATASEG error #', cErrnum : 1);
           Break(1001);
           END;
        IF dsinfo.mem_size <> cbAlloc THEN { must resize the dataseg }
           BEGIN
           IF fTstEvh THEN WRITELN('about to resize an old dataseg...');
           SIZE_DATASEG(cErrnum, cRefnum, cbAlloc - dsinfo.mem_size,
                        lNewMemSize, 0, lNewDiscSize);
           IF cErrnum <> 0 THEN
              BEGIN
              IF cErrnum = 309 THEN freasonWhy := noDiskSpace ELSE
              IF cErrnum = 315 THEN freasonWhy := noMemory ELSE
                 freasonWhy := internalError;
              FailedDuringInit(freasonWhy);
              END;
           END
        ELSE IF fTstEvh THEN WRITELN('old dataseg was the right size...');
        END;

  (* ...and this version creates 'memory-only' segments.
     IF fTstEvh THEN WRITELN('about to make a new dataseg...');
     sSegname := 'X ';
     sSegname[1] := CHR(ORD('@') + ldsnCurr);
     MAKE_DATASEG(cErrnum, sSegname, cbAlloc, 0, cRefnum, lSegptr,
                                                  ldsnCurr, ds_private);
     IF cErrnum <> 0 THEN
        BEGIN
        WRITELN('In PAllocate: MAKE_DATASEG error #', cErrnum : 1);
        Break(1001);
        END;
  *)
     PAllocCb := POINTER(lSegptr);
     IF fTstEvh THEN WRITELN('PAllocate about to return: ',lSegptr : 1);
  END;

{$ELSEC}

  VAR p: TP;

  BEGIN
     IF fTstEvh THEN WRITELN ('Monitor version of PAllocCb');
     NEW(p);
     PAllocCb := p;
     p := POINTER(ORD(p) + cbAlloc);
     RELEASE(p);
  END;

{$ENDC}


{$S LWDebug}
{$ifc fDbgOk}
PROCEDURE PxEvent(event: EventRecord);

   PROCEDURE InterpretWindow(window: TWindow);
      BEGIN
      {$IFC sampcalls}  ALogCall;  {$ENDC}
      IF window = activeFolder THEN WRITE(' (active)');
      IF window = filerFolder THEN WRITE(' (filer)');
      IF window = menuFolder THEN WRITE(' (menu)');
      IF window = scrapFolder THEN WRITE(' (scrap)');
      IF window = dialogFolder THEN WRITE(' (dialog)');
      END;

BEGIN
  {$IFC sampcalls}  ALogCall;  {$ENDC}
  WITH event DO
     BEGIN
     WRITE('PxEvent: .who= ', ORD(who));
     InterpretWindow(who);
     WRITE('.what= ');
     CASE what OF
        nilEvent          : WRITE ('nilEvent');
        buttonDown        : WRITE ('buttonDown');
        buttonUp          : WRITE ('buttonUp');
        keyDown           : WRITE ('keyDown');
        folderActivate    : WRITE ('folderActivate');
        folderDeactivate  : WRITE ('folderDeactivate');
        folderUpdate      : WRITE ('folderUpdate');
      { folderOpen        : WRITE ('folderOpen');  }
      { folderClose       : WRITE ('folderClose'); }
        folderMoved       : WRITE ('folderMoved');
        filerEvent        : WRITE ('filerEvent');
        abortEvent        : WRITE ('abortEvent');
        diedEvent         : WRITE ('diedEvent');
        private1          : WRITE ('private1');
        private2          : WRITE ('private2');
        private3          : WRITE ('private3');
        OTHERWISE BEGIN WRITE ('ORD(what) = ', ORD(what)); Break(1508); END;
     END (* CASE *);
     WRITE(' .where [h, v]= [', where.h : 1, ', ', where.v : 1, ']');
     WRITE(' .when= ', when : 1);
     WRITE(' .why= ', why : 1);
     WRITELN;
     WRITE(' .shift= ', shiftKey : 1);
     WRITE(' .alpha= ', alphaKey : 1);
     WRITE(' .code= ', codeKey : 1);
     WRITE(' .apple= ', appleKey : 1);
     WRITE(' .keyCap= ', keyCap : 1);
     WRITE(' .ascii= "', ascii, '"');
     WRITE(' .fromFolder= ', ORD(fromFolder) : 1);
     InterpretWindow(fromFolder);
     WRITE(' .fromProcess= ', fromProcess : 1);
     WRITE(' .userData= ', userData : 1);
     WRITELN;
     END (* WITH *);
END;
{$endc}
{
FUNCTION HeapFull (* (hz: THz; cbNeeded: TC): TC *);
BEGIN

WRITELN('Oh-oh! Heap full! And only ', cbNeeded : 1, ' bytes are needed.');
PxHz(hz);

Break(999);
END;
}

{$S LWCommand}
PROCEDURE EvDscFromAbsEvd(absEvd: TAbsEvd; VAR evDsc: TEvDsc; fEvDscReady: TF);
LABEL 666, 777, 999;
VAR tyevNew: TTyev;
    rActive: TR;
    oboxCurr: TC;
    pboxCurr, pboxDwn: TPbox;
    windowDwn: TWindow;
    tyvh: TTyvh;
    ptLocal: TPt;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstEvh THEN WRITELN('EvDscFromAbsEvd called.');
IF NOT fEvDscReady THEN tyevNew := absEvd.tyev ELSE tyevNew := evDsc.tyev;
IF tyevNew IN [tyevDwn, tyevDblClick, tyevTripleClick]
  THEN oboxDwn := OboxFromPt(absEvd.pt, absEvd.window)
  ELSE IF tyevNew IN [tyevActivated, tyevDeactivated, tyevAbort, tyevDfClose,
                tyevSuspend, tyevResume, tyevDClose, tyevDCopy, tyevDTerminate,
                tyevDPut]
       THEN oboxDwn := oboxNil;
IF NOT fEvDscReady THEN
BEGIN
    WITH evDsc DO
    BEGIN
      tyev := absEvd.tyev;
      ch := absEvd.ch;
      fAlphaKey := fAlpha; fShiftKey := fShift;
      fAppleKey := fApple; fCodeKey := fCode; fRepeatKey := fRepeat;
      fMouseButton := absEvd.fButton;
      obox := oboxDwn;
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox1: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
      fAutoScroll := FALSE;
    END (* WITH *);
    IF oboxDwn <> oboxNil THEN
    BEGIN
     pboxDwn := POINTER(ORD(bdsp) + oboxDwn);
     windowDwn := pboxDwn^.window;
     IF (absEvd.tyev <> tyevMove)
        OR (NOT absEvd.fButton)
        OR (pboxDwn^.tybox IN [tyboxGrow, tyboxScroll])
        THEN GOTO 666; (* ELSE we must look for dragging across split pane
                          boundaries or for auto-scrolling *)
     oboxCurr := OboxFromPt(absEvd.pt, absEvd.window);
     IF oboxCurr = oboxDwn THEN GOTO 666;
     IF (oboxCurr = oboxNil) OR (absEvd.window <> windowDwn) THEN GOTO 777;
     pboxCurr := POINTER(ORD(bdsp) + oboxCurr);
     IF pboxCurr^.tybox <> tyboxPane THEN GOTO 777;
     evDsc.obox := oboxCurr; (* we are dragging into a split pane *)
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox2: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;

     rActive := pboxCurr^.r;
     GOTO 999;

  666: rActive := pboxDwn^.r;
     GOTO 999;

777: rActive := pboxDwn^.r; (* check for auto-scrolling *)
     ptLocal := absEvd.pt; (* check that we are not over a split pane skewer *)
     AddPt(windowDwn^.portBits.bounds.topLeft, ptLocal);
     IF (pboxDwn^.tybox = tyboxPane)
        AND NOT PtInRect(ptLocal, windowDwn^.portRect) THEN
          BEGIN
          IF absEvd.pt.v <= rActive.top THEN
               BEGIN evDsc.dir := dirUp; tyvh := tyvhV; END
          ELSE IF absEvd.pt.v >= rActive.bottom THEN
               BEGIN evDsc.dir := dirDwn; tyvh := tyvhV; END
          ELSE BEGIN
               tyvh := tyvhH;
               IF absEvd.pt.h <= rActive.left THEN evDsc.dir := dirLft
               ELSE evDsc.dir := dirRt;
               END;
          evDsc.scid := ScidFromObox(oboxDwn, tyvh);
          evDsc.fAutoScroll := TRUE;
          END;

999: evDsc.r.topLeft := absEvd.pt;
    SubPt(rActive.topLeft, evDsc.r.topLeft) (* make the event point box-relative *);
    END (* IF oboxDwn <> oboxNil *);
   IF evDsc.tyev = tyevUp THEN oboxDwn := oboxNil;
END (* IF NOT fEvDscReady *);

END (* EvDscFromAbsEvd *);

{
     PROCEDURE NewRectActive(absEvd: TAbsEvd);
     VAR pbox: TPbox; obox, oboxLftTab: TC;
     BEGIN
      IF fTstEvh THEN WRITELN('NewRectActive -- absEvd.pt: [', absEvd.pt.h : 1, ','
                                                absEvd.pt.v : 1, ']');
     obox := OboxFromPt(absEvd.pt, absEvd.window);
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox3: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
     IF obox  <> oboxNil THEN
         BEGIN
         pbox := PboxFromObox(obox);
         rActive := pbox^.r;
         END
      ELSE
         SetRect(rActive, 0, 0, 1, 1);
     IF fTstEvh THEN PxR('rActive:  ',rActive);
     END;  (* NewRectActive *)
}



{$S LWPrint}
{$IFC fPrintOld}                                                    {gdf 1/16/84}
{-------------------------------------------}
PROCEDURE SetPrprf (ics: TB; prprf: TPrprf);
{-------------------------------------------}
{$ELSEC}                                                            {gdf 1/16/84}
{-------------------------------------------}
PROCEDURE SetPrprf (ics: TB; prprf: TPrRec);   {???}
{-------------------------------------------}
{$ENDC}                                                             {gdf 1/16/84}

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
rghcs^[ics]^^.prprf := prprf;
END;



{$IFC fPrintOld}                                                    {gdf 1/16/84}
{-------------------------------------------}
PROCEDURE NewPrprf {(ics: TB; prprf: TPrprf)};
{-------------------------------------------}
{$ELSEC}                                                            {gdf 1/16/84}
{-------------------------------------------}
PROCEDURE NewPrprf {(ics: TB; prprf: TPrRec)};   {???}
{-------------------------------------------}

{$ENDC}                                                             {gdf 1/16/84}

{ The printer preference has been changed: redisplay the document;
  modify the prprf field of the argument stream and, if it is a paginated
  document, its body, header and footer streams; and modify the prprf field
  of the margin & page rulers if they are up. }
VAR hcspg: THcspg;
  hcsed: THcsed;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
AdjustLps(ics,0,lpMax,0);
SetPrprf(ics, prprf);
CASE rghcs^[ics]^^.tycs OF
  tycsPg:  BEGIN
           hcspg := POINTER(ORD(rghcs^[ics]));
           SetPrprf(hcspg^^.pgd.icsBody, prprf);
           SetPrprf(hcspg^^.pgd.pglp.icsHdr, prprf);
           SetPrprf(hcspg^^.pgd.pglp.icsFtr, prprf);
           AdjustLps(hcspg^^.pgd.icsBody,0,lpMax,0);
           AdjustLps(hcspg^^.pgd.pglp.icsHdr,0,lpMax,0);
           AdjustLps(hcspg^^.pgd.pglp.icsFtr,0,lpMax,0);
           END;
  tycsEd:  BEGIN
           hcsed := POINTER(ORD(rghcs^[ics]));
           SetPrprf(hcsed^^.pglp.icsHdr, prprf);
           SetPrprf(hcsed^^.pglp.icsFtr, prprf);
           AdjustLps(hcsed^^.pglp.icsHdr,0,lpMax,0);
           AdjustLps(hcsed^^.pglp.icsFtr,0,lpMax,0);
           END;
END;
IF icsPageRuler <> icsNil THEN BEGIN
    AdjustRulerPrprf(icsPageRuler, prprf);
    AdjustLps(icsPageRuler,0,lpMax,0);
    END;
IF icsMarginRuler <> icsNil THEN BEGIN
    AdjustRulerPrprf(icsMarginRuler, prprf);
    AdjustLps(icsMarginRuler,0,lpMax,0);
    END;
END;


{$S LWStyle}
{----------------------------------}
FUNCTION IcsOfObox {(obox: TC): TB };
{----------------------------------}
VAR pbox: TPbox; orecCon: TC; recCon: TRec; pint: TPint;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF obox = oboxNil THEN
     IcsOfObox := icsNil
ELSE BEGIN
     pbox := PboxFromObox(obox);
     WHILE pbox^.tybox <> tyboxPane DO pbox := PboxFromObox(pbox^.oboxNxt);
     orecCon := pbox^.refCon;
     recCon := POINTER(ORD(dsp) + orecCon);
     WHILE recCon^.orecSib <> orecNil DO
          BEGIN
          orecCon := recCon^.orecSib;
          recCon := POINTER(ORD(dsp) + orecCon);
          END;
     pint := POINTER(ORD(lldInt) + recCon^.ointDep);
     IcsOfObox := pint^.ics;
     END;
END; {IcsOfObox}


{-------------------------}
FUNCTION IcsActive { : TB };
{-------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF (oboxActive = oboxNil) OR (oboxActive = oboxScrap) THEN
     IcsActive := icsNil
ELSE
    IcsActive := IcsOfObox(oboxActive);
END; {IcsActive}


{$S LWPreview}
{----------------------------------------}
PROCEDURE DoFolderUpdate {window: TWindow};
{----------------------------------------}
VAR
  pbox: TPbox;
  fSbox: TF;
  rT,rF,rBBox: TR;
  obox,oboxLim,oboxTab: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF ( window = dialogFolder) and (fDboxIsOpen) THEN
   BEGIN
   BeginUpdate( window);
   SetDPort;
   DboxRstProc;
   EndUpdate( window);
   IF ftstDmgr THEN writeln('Called DboxRstProc from EventMgr: DoFolderUpdate');
   END
ELSE
   BEGIN
   SetPort(window);
   BeginUpdate(window);                { set VisRgn for update }
   IF NOT EmptyRgn(window^.visrgn) THEN
       BEGIN
       BegGlobal;                          { globalize }
       rBBox := window^.visRgn^^.rgnBBox;
       oboxTab := FidOfWindow(window);     { obox of tab }
       IF oboxTab <> oboxNil THEN
       BEGIN
         pbox := POINTER(ORD(bdsp) + oboxTab);
         fSbox := pbox^.fSbox;
         rT := thePort^.portRect;
         IF NOT fSbox THEN
             SetRect(rT, rT.left-1, rT.top-1, rT.right - dhScroll + 2,
                         rT.bottom - dvScroll + 2);
         ClipRect(rT);
         IF NOT fSbox THEN FrameRect(rT); { repaint inner border }
         obox := pbox^.oboxNxt;           { start with 1st pane }
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox4: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
         oboxLim := OboxNxtFldr(obox);
         WHILE obox <> oboxLim DO BEGIN
             pbox := POINTER(ORD(bdsp)+obox);
             rT := rBBox;
             IF SectRect(pbox^.r, rT, rT) THEN
                 IF (pbox^.tybox=tyboxPane) THEN
                     BEGIN
                      { reframe affected pane }
                     rF := pbox^.r; InsetRect(rF, -1, -1);
                     FrameRect(rF);
                     WITH pbox^.r DO OffsetRect(rT, -left, -top);
                     IF pbox^.refCon <> 0 THEN
                         BEGIN
                         pbox^.fUpdate := FALSE; (* no need to paint
                                                    it twice *)
                         InvalidR(rT, tyxyScrn, pbox^.refCon);
                         END
                     END
                 ELSE IF fSbox THEN PaintBox(obox);
             obox := pbox^.oboxNxt;
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox5: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
             END;
       END (* IF *);
       EndGlobal;
       { ValidateDsp; } {This was moved beyond the EndUpdate because the ruler
                         reads the screen bits in order
                         to remember the bits under some icons - viz. rmPt }
       END;
   EndUpdate(window);
   ValidateDsp;
   END;
END; {DoFolderUpdate}


{$S LWCommand}
PROCEDURE DispatchEvent(VAR evDsc: TEvDsc; VAR actArea:TActArea; ctickTimeout: TC);

LABEL 666;
VAR pbox: TPbox;
   rBoxRel: TR;
   event: EventRecord;

{$S LWActive}
   PROCEDURE CallFiler(imtd, imid: TC);
   BEGIN
      {$IFC sampcalls}  ALogCall;  {$ENDC}
      CASE imid OF
          imidClsAll:      DoFilingCmd(cmdClosAll);
          imidClose:       DoFilingCmd(cmdClose);
          END (* CASE *);
      END (* CallFiler *);

{$S LWCommand}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$ifc fDbgOk}
IF fTstEvh THEN
  BEGIN
  WRITELN('DispatchEvent: ');
  PxEvDsc(evDsc);
  END;
{$endc}

CASE evDsc.tyev OF
  tyevKey,
  tyevInChar:
      IF fApple AND (evDsc.ch <> CHR(chBackspace)) THEN BEGIN
           WITH evDsc DO BEGIN
               InsertMenu(argMenu[imtdInvisible], 0); {Temporarily insert the
                                                       invisible menu so that
                                                       MenuKey will work}
               MenuKey(ch, imtd, imid);
               IF fTstEvh THEN
                   writeln('MenuKey: imtd=',imtd : 1, ' imid=',imid : 1);
               IF (imtd<>0) and (imid<>0) THEN BEGIN
                   IF (imtd <> imtdInvisible) THEN HiLiteMenu(imtd);
                   evDsc.tyev := tyevCmd;
                   fGNEReturn := TRUE;
                   END;
               DeleteMenu(argMenu[imtdInvisible].menuId);
               END;
           END
      ELSE fGNEReturn := TRUE;
  tyevTimeout, tyevAbort:
      fGNEReturn := TRUE;
  tyevActivated, tyevDeactivated, tyevScNew, tyevScResize,
  tyevScKill, tyevPaneKill, tyevEnd:
      fGNEReturn := TRUE;
  tyevResume, tyevDClose, tyevDCopy, tyevDTerminate,
  tyevDfClose, tyevSuspend, tyevDPut, tyevDShred:
      fGNEReturn := TRUE;
  tyevCmd:
      fGNEReturn := TRUE;
  OTHERWISE
      IF (evDsc.tyev <> tyevUpdate) AND (evDsc.obox = oboxNil) THEN
         (* don't do anything; don't return from GetNextEvent *)
      ELSE BEGIN
         pbox := PboxFromObox(evDsc.obox);
         CASE pbox^.tybox OF
            tyboxGrow, tyboxScroll: BEGIN
                 HandleBoxEvent(evDsc, actArea);
                 CASE evDsc.tyev OF
                    tyevScroll: IF (Time - lLastScroll > lScrollInterval) THEN
                        BEGIN
                        fGNEReturn := TRUE;
                        lLastScroll := Time;
                        END;
                    tyevPScroll: IF (Time - lLastPScroll > lPScrollInterval) THEN
                        BEGIN
                        fGNEReturn := TRUE;
                        lLastPScroll := Time;
                        END;
                    tyevThumb (* , tyevGrow *): fGNEReturn := TRUE;
                    END;
                 END;
            tyboxMenu:
                 WITH evDsc DO
                   IF (tyev=tyevDwn) OR (tyev=tyevDblClick) OR
                      (tyev=tyevTripleClick) THEN BEGIN
                     IF fTstEvh THEN write('MenuSelect:');
                     MenuSelect(r.topLeft, imtd, imid);
                     IF fTstEvh THEN writeln(' imtd=',imtd : 1, ' imid=',imid : 1);

                   (*    discard the Up which selected the menu item, and any keys
                         typed while the menu was popped *)
                     WHILE TRUE DO BEGIN
                        IF NOT PeekEvent(event) THEN GOTO 666;
                        IF event.what = keyDown THEN GetEvent(event)
                        ELSE
                           BEGIN
                           IF event.what = buttonUp THEN GetEvent(event);
                           GOTO 666;
                           END;
                     END (* WHILE *);
              666:
                     IF imtd * imid = 0 THEN HiLiteMenu(0)
                     ELSE IF ((imtd = imtdFile) OR (imtd = imtdScrap)) AND
                            (imid IN [imidClsAll, imidClose]) THEN
                         CallFiler(imtd, imid)
                     ELSE BEGIN
                         evDsc.tyev := tyevCmd;
                         fGNEReturn := TRUE;
                         END;
                  END;
            tyboxPane: IF (evDsc.tyev = tyevMove) AND evDsc.fAutoScroll THEN
                           BEGIN
                           IF (Time - lLastScroll > lScrollInterval) THEN
                               BEGIN
                               fGNEReturn := TRUE;
                               lLastScroll := Time;
                               END
                           END
                        ELSE fGNEReturn := TRUE;
            END;
         END (* ELSE *);
END (* CASE evDsc.tyev*);
END; { DispatchEvent }


{$S LWActive}
PROCEDURE DrawLotusPicture(* wdw: TWindow *);
VAR rT, rF, rBBox: TR;
    pbox: TPbox;
    obox, oboxLim, oboxTab: TC;
BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   SetOrigin(0,0);  {Put port in consistent state for WMOpenPicture (?)}
   WMOpenPicture(wdw);
   oboxTab := FidOfWindow(wdw);     { obox of tab }
   BegGlobal;                       { globalize }
   rBBox := thePort^.portRect;
   pbox := POINTER(ORD(bdsp) + oboxTab);
   rT := thePort^.portRect;
   SetRect(rT, rT.left-1, rT.top-1, rT.right - dhScroll + 2,
                 rT.bottom - dvScroll + 2);
   ClipRect(rT);
   FrameRect(rT); { repaint inner border }
   obox := pbox^.oboxNxt;           { start with 1st pane }
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox6: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
   oboxLim := OboxNxtFldr(obox);
   WHILE obox <> oboxLim DO BEGIN
     pbox := POINTER(ORD(bdsp)+obox);
     rT := rBBox;
     IF SectRect(pbox^.r, rT, rT) THEN
         IF (pbox^.tybox=tyboxPane) THEN
             BEGIN
              { reframe affected pane }
             rF := pbox^.r; InsetRect(rF, -1, -1);
             FrameRect(rF);
             WITH pbox^.r DO OffsetRect(rT, -left, -top);
             IF pbox^.refCon <> 0 THEN
                 BEGIN
                 pbox^.fUpdate := FALSE; (* no need to paint
                                            it twice *)
                 InvalidR(rT, tyxyScrn, pbox^.refCon);
                 END
             END;
     obox := pbox^.oboxNxt;
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox7: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
     END (* WHILE *);
   EndGlobal;
   ValidateDsp;
   SetOrigin(0,0);
   WMClosePicture;
END (* DrawLotusPicture *);



PROCEDURE SomeActivateCode(event: EventRecord);  {tjm 1/12/84 - changes for spring filer}
VAR

{$IFC fPrintOld}                                                    {gdf 1/16/84}

    prprf:   TPrprf;

{$ELSEC}                                                            {gdf 1/16/84}

    prprf:   TPrRec;   { ??? }

{$ENDC}                                                             {gdf 1/16/84}

    fNewStl: TF;
    cError: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WmKillPicture(event.who);
FixRectsOf(scrapFolder); { move and resize .rects of
                           scrapFolder's boxes }

MakeFolderActive(FidOfWindow(event.who), FALSE);
   { don't deactivate the former oboxActive }

prprf := rghcs^[IcsActive]^^.prprf;

{$IFC fPrintOld}                                                    {gdf 1/16/84}

IF FPrArbRqd(prprf) THEN BEGIN
    PrArbDlg(cError, prprf, fNewStl);
    IF fNewStl THEN NewPrprf(IcsActive,prprf);
    END;

{$ELSEC}                                                            {gdf 1/16/84}

{now, for the new print paradigm -- gdf 1/23/84}
IF NOT (FPrPrfValid(prprf)) THEN BEGIN
    (* dump this garbage-- md 4/23/84
        PrPrfDlg(prprf, fNewStl, TRUE {page size suppress});
        IF fNewStl THEN NewPrprf(IcsActive,prprf);
    *)
    PrPrfDefault (prprf);
    NewPrprf(IcsActive,prprf);
    END;

{$ENDC}                                                             {gdf 1/16/84}


IF My_ID <> event.fromProcess THEN
  BEGIN
    LotusGetScrap;
    IF scrapProcess <> My_ID THEN RecScrapToOboxScrap(FALSE);
       (* don't want to update the scrap display until we
          get around to doing a Cut or Copy *)
  END;
END;  {SomeActivateCode}



{$S LWCommand}
PROCEDURE GetWwEvent(VAR evDsc:TEvDsc; actArea: TActArea; ctickTimeout: TC);
LABEL 100;
VAR obox: TC;
   tyevNew: TTyev;
   absEvd: TAbsEvd;
   ptAbs: TPt; ch: Char;
   fUpPending: TF;
   pbox: TPbox;
   port, portT: TPort;
   fEvDscReady: TF;
   fScan: TF;
   ptRel:      TPt;
   tybox:      TTybox;
   timeT:      TL;
   event, eventMsg: EventRecord;
   width, height: TC;
   toFolder: WindowPtr;
   toProcess: LongInt;
   rDialog: TR;
   cError: TC;
   filerParams: FilerExt;
   wdw: TWindow; rT: TR; oboxTab: TC; ptLocal: TPt;
   fButton: TF;

{$IFC fPrintOld}                                                    {gdf 1/16/84}

   prprf:   TPrprf;

{$ELSEC}                                                            {gdf 1/16/84}

   prprf:   TPrRec;  { ??? }


{$ENDC}                                                             {gdf 1/16/84}

   fNewStl: TF;
   pboxDwn: TPbox;
   orecCon: TC; recCon: TRec; pint: TPint;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
tyevNew := tyevNull;
fEvDscReady := FALSE;

REPEAT
  {tjm 1/12/84 - changes for spring filer}
  IF (eventPrev.what = filerEvent) AND (fcPrev = fcResume)
    AND (eventPrev.who = activeFolder) THEN
       SomeActivateCode(eventPrev);
   (* Have any of the previously processed window manager events *)
   (* queued up further events ? *)
  IF FDequeue(q, @evDsc) THEN
     BEGIN
     {$ifc fDbgOk}
     IF fTstQue THEN BEGIN WRITE('Dequeued: '); PxEvDsc(evDsc); END;
     {$endc}
     tyevNew := evDsc.tyev;
     fApple := evDsc.fAppleKey;
     fEvDscReady := TRUE; (* no need to convert absEvDsc to evDsc *)
     END;

  fButton := StillDown;

  SetPort(bdsp^.port);  (* Initialize ptAbs to current mouse location *)
  GetMouse(ptAbs);

   (* if no internally generated events are queued, *)
   (* look for window manager events *)
  IF tyevNew = tyevNull THEN
  BEGIN
        IF (eventPrev.what = folderDeactivate) THEN GiveControl(eventPrev);
        IF EventAvail OR (NOT ImActive) OR (eventPrev.what = folderDeactivate) THEN
        BEGIN
                     IF fTstEvh THEN
                  WRITE('calling GetEvent, ');
           GetEvent(event);
           {$ifc fDbgOk}
           IF fTstEvh THEN
             BEGIN WRITE('GetEvent returned:'); PxEvent(event); END;
           {$endc}

           eventPrev := event;
           IF event.who = filerFolder THEN Break(1521);

           IF event.who <> NIL THEN
              BEGIN
              SetPort(event.who);

              fAlpha := event.alphaKey;
              fShift := event.shiftKey;
              fApple := event.appleKey;
              fCode  := event.codeKey;
              fRepeat  := event.repeatKey;

              ptAbs := event.where;
              SubPt(event.who^.portBits.bounds.topLeft, ptAbs); (* make ptAbs
                                                   in global coordinates *);
              IF event.what <> filerEvent THEN
                 AdjustRectsOf(event.who); (* adjust the .r fields of all boxes
                       of window .who to reflect any recent folder moving... *)
              END  (* IF *);
           CASE event.what OF

                buttonDown:
                   BEGIN
                      IF event.when - lLastUp <= clickDelay THEN
                            IF fDwnWasDbl THEN
                                  tyevNew := tyevTripleClick
                            ELSE
                               BEGIN
                                  tyevNew := tyevDblClick;
                                  fDwnWasDbl := TRUE;
                               END
                      ELSE
                         BEGIN
                            tyevNew := tyevDwn;
                            fDwnWasDbl := FALSE;
                         END;
                      evDsc.windowCurr := event.who;
                   END;

                buttonUp:
                   BEGIN
                      tyevNew := tyevUp;
                      lLastUp := event.when;
                   END;

                keyDown:
                   IF NOT fButton THEN (* throw away repeat keys typed while mouse
                                          button is Down *)
                      BEGIN
                         {$IFC sampcalls}                         {gdf 2/24/84}
                         {check for option-shift-1, 2, 7, 8 for logging}
                         IF fCode THEN
                         CASE (event.ascii) OF
                         CHR (193): {start tracing/data seg: option-1}
                            BEGIN
                            AResetTrace(TRUE);
                            AStartCallLog;
                            fTraceCalls := TRUE;
                            event.ascii := chr(chLeftArrow);  {throw it away}
                            END;

                         CHR (170): {stop tracing/data seg: option-2}
                            BEGIN
                            AStopCallLog;
                            AListCalls;
                            fTraceCalls := FALSE;
                            event.ascii := chr(chLeftArrow);  {throw it away}
                            END;

                         CHR (163): {start tracing/alt screen: option-3}
                            BEGIN
                            AResetTrace(TRUE);
                            AStartCallLog;
                            fTraceCalls := TRUE;
                            ASetCallTrace(TRUE);
                            event.ascii := chr(chLeftArrow);  {throw it away}
                            END;

                         CHR (162): {stop tracing/alt screen: option-4}
                            BEGIN
                            AStopCallLog;
                            ASetCallTrace(FALSE);
                            fTraceCalls := FALSE;
                            event.ascii := chr(chLeftArrow);  {throw it away}
                            END;
                         END; {CASE}
                        {$ENDC}                                    {gdf 2/24/84}

                         IF event.ascii IN [chr(chLeftArrow), chr(chRightArrow),
                                            chr(chUpArrow), chr(chDownArrow)]
                         THEN { throw away these keys }
                         ELSE BEGIN
                              tyevNew := tyevKey;
                              ch := event.ascii;
                              END;
                      END;

                folderActivate:
                   BEGIN
                      { make the world safe for Lotus }
                     TakeControl(event, FALSE, FALSE); { don't save menus;
                                                          don't save dialogue }
                     SomeActivateCode(event);  {tjm 1/12/84 - changes for spring filer}
                     tyevNew := tyevInternalRepeat;
                  END;

                folderDeactivate:
                    BEGIN
                    IF My_ID <> event.fromProcess THEN
                       BEGIN
                       IF (scrapProcess = My_ID) AND (event.who <> scrapFolder)
                           THEN
                              BEGIN
                              GetPort(portT);
                              SetPort(scrapFolder);
                              DrawLotusPicture(scrapFolder);
                              SetPort(portT);
                              END;
                       LotusPutScrap;
                       END;
                    MakeFDeactivated(oboxActive);
                    tyevNew := tyevInternalRepeat;

                    END (* folderDeactivate *);

                folderUpdate:
                    BEGIN
                    DoFolderUpdate(event.who);
                    END;

                 {
                 folderOpen:
                    BEGIN
                       evDsc.tyev := tyevOpen;
                       evDsc.fid := FidOfWindow(event.who);
                       evDsc.obox := oboxNil (* don't call VisObox *);
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox8: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
                       tyevNew := evDsc.tyev;
                       fEvDscReady := TRUE; (* no need to convert
                                                absEvDsc to evDsc *)
                    END;
                 } {4/2/82 crc}

                 {
                 folderClose:
                    BEGIN
                       tyevNew := tyevInternalRepeat;
                    END; (* discard for now... *)
                 } {4/2/82 crc}

                 folderMoved:
                    BEGIN
                       tyevNew := tyevInternalRepeat;
                    END; (* discard for now... *)

                 filerEvent:
                    BEGIN
                       GetAddParams(cError, event, filerParams);
                       WITH filerParams DO BEGIN
                          pathGlobal := thePrefix;
                          passGlobal := thePassword;
                          fcPrev := theFlrOp;
                          {tjm 1/12/84 - changes for spring filer}
                       END;
                       CASE filerParams.theFlrOp OF

                       fcResume:
                          BEGIN
                              (* get the monitor-compatible, i.e. user-typed
                                 name, not the Filer's internal name *)
                             evDsc.windowCurr := event.who;
                             evDsc.obox := oboxNil (* don't call VisObox *);
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox9: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
                             evDsc.tyev := tyevResume;
                             tyevNew := evDsc.tyev;
                             fEvDscReady := TRUE; (* no need to convert
                                                     absEvDsc to evDsc *)
                          END;

                       fcClose,
                       fcSuspend,
                       fcPut,
                       fcShred:
                          BEGIN
                             oboxTab := FidOfWindow(event.who);
                             IF oboxTab = oboxNil THEN Break(1601) ELSE
                             IF oboxActive <> oboxNil THEN
                                IF oboxTab = oboxActive
                                   THEN RemoveScrollBoxes(oboxTab)
                                   ELSE Break(1600);
                             evDsc.windowCurr := event.who;
                             evDsc.obox := oboxNil (* don't call VisObox *);
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox10: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
                             CASE filerParams.theFlrOp OF
                             fcSuspend:  evDsc.tyev := tyevSuspend;
                             fcClose:    evDsc.tyev := tyevDClose;
                             fcPut:      evDsc.tyev := tyevDPut;
                             fcShred:    evDsc.tyev := tyevDShred;
                             END;
                             tyevNew := evDsc.tyev;
                             fEvDscReady := TRUE; (* no need to convert
                                                     absEvDsc to evDsc *)
                          END;

                       fcDfClose:
                          BEGIN
                             evDsc.cRefnum := filerParams.theDF;
                             evDsc.obox := oboxNil (* don't call VisObox *);
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox11: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
                             evDsc.tyev := tyevDfClose;
                             tyevNew := evDsc.tyev;
                             fEvDscReady := TRUE; (* no need to convert
                                                     absEvDsc to evDsc *)
                          END;

                       fcCopy:
                          BEGIN
                             oboxTab := FidOfWindow(event.who);
                             IF oboxTab = oboxNil THEN Break(1601);
                             evDsc.windowCurr := event.who;
                             evDsc.obox := oboxNil (* don't call VisObox *);
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox12: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
                             evDsc.tyev := tyevDCopy;
                             tyevNew := evDsc.tyev;
                             fEvDscReady := TRUE; (* no need to convert
                                                     absEvDsc to evDsc *)
                          END;

                       fcNone: BEGIN
                                  TellFiler(cError, docClosd, noMoreDocs,
                                          event.who);
                               END;

                       fcTerminate: fToldToDie := TRUE;

                       OTHERWISE Break(1523);
                       END (* CASE *);
                    END (* filerEvent *);

                 abortEvent:
                    BEGIN
                       tyevNew := tyevInternalRepeat;
                    END; (* discard for now... *)

                 OTHERWISE
                    Break(1500);

            END (* CASE *);
         END (* IF EventAvail *)

      ELSE (* no event available; set ptAbs and check for a tyevMove *)
        BEGIN
                 IF fTstEvh THEN
                 WRITELN('.......... EventAvail returned FALSE.');
           SetPort(bdsp^.port);
           GetMouse(ptAbs);
           IF fButton AND (oboxDwn <> oboxNil) THEN
              BEGIN
                ptRel := ptAbs;
                pboxDwn := POINTER(ORD(bdsp) + oboxDwn);
                SubPt(pboxDwn^.r.topLeft, ptRel)
                            (* make the event point box-relative *);
                IF fButton AND
                   (actArea.fInRect <> PtInRect(ptRel, actArea.rAct)) THEN
                   tyevNew := tyevMove;
              END;
           IF tyevNew <> tyevMove THEN LetOthersRun;
        END;

     {(** GetPort(port); **)}
  {$ifc fDbgOk}
  IF fTstEvh THEN BEGIN
     WRITELN('GetWwEvent1 - tyev: ');
     PxTyEv (tyevNew);
     END;
  {$endc}

  END (*IF tyevNew = tyevNull *);

  IF (NOT fButton) AND (activeFolder <> Nil) THEN
     BEGIN
     ptLocal := ptAbs;
     WITH dialogFolder^.portBits.bounds DO Addpt(topLeft, ptLocal);
     IF PtInRgn(ptLocal, dialogFolder^.visRgn) THEN
         BEGIN
         wdw := dialogFolder;
         IF fDboxIsOpen THEN  {Is it a check box type of dialog box?}
            BEGIN
            SetPort(DialogFolder);
            DboxTrkProc(ptLocal, timeStart + CtickTimeout);
            GOTO 100;
            END;
         END
     ELSE BEGIN
         wdw := activeFolder;
         ptLocal := ptAbs;
         WITH wdw^.portBits.bounds DO Addpt(topLeft, ptLocal);
         END;
     rT := wdw^.portRect;
     Subpt(dptScroll, rT.botRight);
     IF (FidOfWindow(wdw) <> oboxNil)    { it's one of ours }
         AND PtInRect(ptLocal, rT) AND (wdw <> scrapFolder) THEN
            BEGIN
            obox := OboxFromPt(ptAbs, wdw);
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox13: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
            IF obox = oboxNil THEN SetStdCursor(icrsInactive)
            ELSE BEGIN
                 pbox := POINTER(ORD(bdsp) + obox);
                 ptLocal := ptAbs;
                 SubPt(pbox^.r.topleft, ptLocal);
                 orecCon := pbox^.refCon;
                 IF (orecCon > 0) AND (orecCon <> orecNil) THEN
                    BEGIN
                    orecCon := OrecOfPt(orecCon, TRUE, ptLocal, FALSE);
                    recCon := POINTER(ORD(dsp) + orecCon);
                    pint := POINTER(ORD(lldInt) + recCon^.ointDep);
                    IF rghcs^[pint^.ics]^^.tycs = tycsRuler
                       THEN SetStdCursor(icrsInactive)
                       ELSE SetStdCursor(icrsXIBeam);
                    END;
                 END;
            END
     ELSE
         SetStdCursor(icrsInactive);
     END { IF };
100:
  {$ifc fDbgOk}
  IF fTstEvh THEN BEGIN
     WRITE('GetWwEvent2 - tyev: ');
     PxTyEv (tyevNew);
     WRITELN (' fEnabling: ', fEnabling : 1);
     END;
  {$endc}

  (* next, scan the box list front to back to see if any updates are pending...*)
  IF tyevNew = tyevNull THEN
     BEGIN
        obox := bdsp^.oboxRoot;
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox13: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
        fScan := TRUE;
        WHILE fScan DO
           IF obox = oboxNil THEN fScan := FALSE
              ELSE
                 BEGIN
                    pbox := PboxFromObox(obox);
                    IF pbox^.fUpdate THEN fScan := FALSE ELSE
                       obox := pbox^.oboxNxt;
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox14: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
                 END;
        IF obox <> oboxNil THEN
           BEGIN
              pbox^.fUpdate := FALSE;
              evDsc.tyev := tyevUpdate;
              evDsc.obox := obox;
      if myTest then if theEvDsc.obox <> myObox then begin
        writeln ('--new obox15: ', theEvDsc.obox);
        myObox := theEvDsc.obox;
      end;
              SetRect(evDsc.r, 0, 0, pbox^.r.right - pbox^.r.left,
                                        pbox^.r.bottom - pbox^.r.top);
                 (* for now, update the entire box... we may add a field to a box
                 to
                    indicate more precise updating *)
               tyevNew := evDsc.tyev;
               fEvDscReady := TRUE; (* no need to convert absEvDsc to evDsc *)
            END;
      END;

{
   (* next, if nothing has happened yet, then indicate that the mouse button
      is still up... *)
   IF (tyevNew = tyevNull) AND (oboxDwn <> oboxNil) THEN
       BEGIN
       ptRel := ptAbs;
       pboxDwn := POINTER(ORD(bdsp) + oboxDwn);
       SubPt(pboxDwn^.r.topLeft, ptRel)
                         (* make the event point box-relative *);
       IF (* PtInRect(ptAbs, rActive) AND *)
         (actArea.fInRect <> PtInRect(ptRel, actArea.rAct)) THEN
            tyevNew := tyevMove;
       END;
}

   IF tyevNew = tyevNull THEN
       BEGIN
       IF (oboxDwn <> oboxNil) THEN
            BEGIN
            pbox := PboxFromObox(oboxDwn);
            tybox := pbox^.tybox;
            END
       ELSE tybox := tyboxNil;
       IF (NOT fButton) OR (tybox = tyboxPane) THEN
            BEGIN
            timeT := Time;
            IF (timeT - timeStart > ctickTimeout) THEN
                 BEGIN (* timeout *)
                 tyevNew := tyevTimeout;
                 IF fTstEvh THEN
                      WRITELN('Timeout Value: ', timeT - timeStart : 1,
                        ', ctickTimout: ', ctickTimeout : 1);
                 END;
            END;
       END;

   IF tyevNew = tyevInternalRepeat THEN tyevNew := tyevNull;

   IF fTstEvh THEN
        WRITELN('UpdateEvd: [',ptAbs.h : 1,';',ptAbs.v : 1,'] "',ch,'"(',ORD(ch),')');
   absEvd.ch := ch;
   absEvd.pt := ptAbs;
   absEvd.tyev := tyevNew;
   absEvd.fButton := fButton;
   IF tyevNew IN [tyevMove, tyevTimeout] THEN
      BEGIN
      ptLocal := absEvd.pt;
      AddPt(dialogFolder^.portBits.bounds.topLeft, ptLocal);
      IF PtInRect(ptLocal, dialogFolder^.portRect)
         THEN absEvd.window := dialogFolder
         ELSE absEvd.window := activeFolder;
      END
   ELSE absEvd.window := event.who;

   {   IF ((tyevNew = tyevDwn) OR (tyevNew = tyevDblClick) OR
           (tyevNew = tyevTripleClick)) THEN
          BEGIN
          NewRectActive(absEvd);
             (**
                (* don't do anything rash: active folder updates have to happen *)
               IF fEnabling THEN absEvd.tyev := tyevNull;
             **)
          END;
   }

UNTIL absEvd.tyev <> tyevNull (* end of REPEAT *);

EvDscFromAbsEvd(absEvd, evDsc, fEvDscReady);

END;  { GetWwEvent }


{$S LWCreate}
PROCEDURE InitEvMgr;

VAR i: TC;

BEGIN

{$IFC sampcalls}  ALogCall;  {$ENDC}
lLastUp := 0 (* long time since last Up... *);
fDwnWasDbl := FALSE (* no double-clicks yet *);
lLastScroll := 0 (* no line scroll events sent recently *);
lLastPScroll := 0 (* no page scroll events sent recently *);
oboxDwn := oboxNil;
(* SetRect(rActive, 0, 0, 1, 1); *)           { no active region yet }
fEnabling := FALSE;                        { not 'activating' click }
fAlpha := FALSE; fShift := FALSE;
fApple := FALSE; fCode := FALSE; fRepeat := FALSE;
fToldToDie := FALSE;
eventPrev.what := nilEvent;


END (* InitEvMgr *);

{-----------------}
PROCEDURE InitLily;
{-----------------}

CONST cbHzLily = 10240 (* must be a multiple of 512 *);

VAR pFst, pLim: TP;
   fid: TFid;
   rMenu: TR;
   segname: Pathname;
   cErrnum, cRefnum: TC;
   lSegptr: TL;
   cError: TC;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
                 IF fTstEvh THEN WRITELN('Beginning InitLily...............');
fCbMoreFailed := FALSE;
pFst := PAllocCb(cbHzLily);   IF fTstEvh THEN WRITELN('heap space allocated.');
pLim := POINTER(ORD(pFst) + cbHzLily);
(* 5/18/82 crc ipPoolMac increased from 50 to 200 to workaround PrMgrInit bug *)
(* 9/14/82 crc ...back to 50 *)
hzLily := HzInit(pFst, pLim, POINTER(ORD(PRegGlobal)-20000),
          50, 5, @CbMoreLotusGrowSeg, @FilCbOfN, @FilFSwapInN, @FilSwapOutN);
            IF fTstHzScramble THEN
               BEGIN
               hzLily^.fScramble := TRUE;
               hzLily^.fCheck := TRUE;
               END;
            IF fTstEvh THEN WRITELN('Heap initialized.');
{$IFC NOT fOS }
     InitStub;
{$ENDC }

InitPrt;                IF fTstEvh THEN WRITELN('Prt initialized.');
InitCursor;
InitWmlCrs(cError);
                        IF fTstEvh THEN IF cError<>0 THEN
                           WRITELN('InitWmlCrs returns error ', cError);

TextFont(tile12);  TextFace([]);

InitQueue(q, hzLily);           IF fTstEvh THEN WRITELN('Queue initialized.');
InitBoxMgr(hzLily, 25, @q);     IF fTstEvh THEN WRITELN('BoxMgr initialized.');
SetRect(rMenu, 0, 0, 720, 15);
oboxMenu := OboxAlloc(rMenu, tyboxMenu, 0, bdsp^.oboxRoot, menuFolder);
InitEvMgr;                      IF fTstEvh THEN WRITELN('EvMgr initialized.');
InitRec(hzLily, 40);            IF fTstEvh THEN WRITELN('Rec initialized.');
InitTld(hzLily);                IF fTstEvh THEN WRITELN('Tld initialized.');
END (* InitLily *);


{$S LWCommand}
PROCEDURE GetNextEvent (* VAR evDsc: TEvDsc; actArea: TActArea; ctickTimeout: TC
*);

BEGIN
  {$IFC sampcalls}  ALogCall;  {$ENDC}
  timeStart := Time (* record the time of the GNE call *);
  IF fTstEvh THEN WRITELN('GetNextEvent called.');
  fGNEReturn := FALSE;
  REPEAT
     {$ifc fDbgOk}
     IF fTstEvh THEN
          BEGIN
          WRITE('actArea.fInRect: ', actArea.fInRect : 1);
          WRITE('timeStart: ', timeStart : 1);
          PxR('actArea.rAct:  ',actArea.rAct);
          END;
     {$endc}
     GetWwEvent(evDsc, actArea, ctickTimeout);
     DispatchEvent(evDsc, actArea, ctickTimeout);
  UNTIL fGNEReturn;
  {$ifc fDbgOk}
  IF fTstEvh THEN
       BEGIN
       WRITELN('GetNextEvent returning...');
       PxEvDsc(evDsc);
       END;
  {$endc}
END; (* GetNextEvent *)

END.

