{ ============================================================================ }
{                             L o t u s M i s c                                }
{                                                                              }
{                    an include file included in UnitLotus                     }
{                                                                              }
{ ============================================================================ }

(* Copyright 1983, 1984, Apple Computer Inc. *)

{ med  4- 3-84 -- Added PrSpoolAbort }
{ med  3-22-84 -- Added parm to PrDocStart }
{ gdf  2/29/84 -- insert trace calls for segmentation (into Mark's version) }
{ gdf  2/7/84 -- Added ldsnPrint parm to PrDocStart }
{ gdf  2/1/84  -- new print loop }
{ gdf  1/16/84 -- new print stuff for spring 1984 release }
{ crc  4/14/83 -- Print: CautioinAlert if document not within rPrintable; PxBitMap
                  & other debugging aids }
{ tjm  3/31/83 -- OpenDocument: Dangling reference to pLeader }
{ crc  2/28/83 -- OpenDocument: Added call to RemoveScrollBoxes }
{ crc  2/10/83 -- Print: call DoFolderUpdate before PrBgdDlg }
{ crc  2/09/83 -- OpenDocument: Alert if doc version is newer than ffversion }
{ crc  2/08/83 -- Print: additional lables & go codes; always call ValidateDsp
                  before calling PrBgdDlg }
{ crc  1/11/83 -- Changes to Print loop }
{ crc  1/06/83 -- pass fLayoutPage parm to TytermUpdateRec;  call FEosLpPg in
                  print loop to detect eos before calling PrNextBand }
{ crc 12/16/82 -- Procedure CreateFile wrote to write Lotus file out of thin air.
                  New arg fCreate to OpenDocument indicates if CreateFile should
                  be called if file does not exist. }
{ crc 11/29/82 -- OpenDocument sets prprf of header & footer }
{ crc 11/17/82 -- Calls PrPrfFix if old preference }
{ crc 11/11/82 -- Fix to RestartIcs; OpenDocument changed to get printer
                  preference from formatted file }
{ crc 11/01/82 -- Fixed bug in Print preventing orecConPrt from being freed when
                  printing is aborted }
{ crc 10/15/82 -- fixed Print to insure PrNextBand always matched by PrDumpBand }
{ crc  9/17/82 -- added IcsEdFromPane to replace calls to IcsConFromPane }
{ jrm  9/ 7/82 -- added fPaintPane parameter to OboxOpenWindow and OpenDocument }
{ crc  8/25/82 -- debugging stuff in OboxTabOfIcs }
{ crc  8/24/82 -- Replaced PrTxFont, PrTxFace with TextFont, TextFace;
                  WriteFolder now always closes ifil; fixed FUsesRefnum }
{ crc  8/23/82 -- Added routine StripExtension }
{ crc  8/17/82 -- Error codes from UnitFile & addt'l parms }
{ crc  8/10/82 -- Added ldsnPrint parm to PrDocStart }
{ crc  8/ 4/82 -- Error codes from UnitFile; always print in background }
{ jrm  8/ 3/82 -- moved in more stuff from UnitLotus }
{ bas  7/20/82 -- page flip icons }
{ jrm  6/30/82 -- moved in some stuff from UnitLotus }
{ crc  6/17/82 -- OpenDocument sets icsOrig field of icsEd to icsDoc }
{ crc  6/16/82 -- Added procedure PathOfOboxTab }
{ crc  6/10/82 -- Added pathname parameter to OpenDocument; added SplitPathname }
{ crc  5/27/82 -- MarkStreams now handles tycsFm streams }
{ jrm  5/26/82 -- Removed prcsMine reference }
{ crc  5/21/82 -- temporary initialization of prprf on document open }
{ bas  3/18/82 -- set pglp.tyxy from ffleader if bad in OpenDocument }



{$S LWScroll}

{---------------------------------}
FUNCTION IcsBodyOfIcs{ics: TB): TB};
{---------------------------------}
VAR hcspg: THcspg;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
   IF ics <> icsNil THEN
      BEGIN
      IF rghcs^[ics]^^.tycs = tycsPg THEN
         BEGIN
         hcspg := POINTER(ORD(rghcs^[ics]));
         IcsBodyOfIcs := hcspg^^.pgd.icsBody;
         END
      ELSE IcsBodyOfIcs := ics;
      END
   ELSE IcsBodyOfIcs := icsNil;
END;


{----------------------------------------------------------}
FUNCTION IcsEdFromPane (oboxPane: TC; VAR orecCon: TC) : TB;
{----------------------------------------------------------}
VAR ics: TB;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
ics := IcsConFromPane(oboxPane,orecCon);
IcsEdFromPane := IcsBodyOfIcs(ics);
END;


{$S LWPage}
{---------------------------------------------------------------------------------}
FUNCTION IcsPgPreviewObox(oboxPane: TC; VAR orecCon: TC; VAR fWasPreview: TF) : TB;
{---------------------------------------------------------------------------------}
VAR pgd:    TPgd;
    icsPg:  TB;
    hcsed: THcsed;
    orecDummmy: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstLotus THEN WRITELN('IcsPgPreviewObox -- oboxPane:', oboxPane:4);
fWasPreview := FPreviewObox(oboxPane, orecCon, icsPg);
IF NOT fWasPreview THEN
    BEGIN
    { icsPg is not really the page stream - yet }
    pgd.icsBody := icsPg;
    hcsed := POINTER(ORD(rghcs^[icsPg]));
    IF hcsed^^.cs.tycs <> tycsEd THEN Break(80);
    pgd.pglp := hcsed^^.pglp;
    icsPg := IcsPgCreate(10, pgd, hzLotus);
    rghcs^[icsPg]^^.orecConFst := orecCon;
    rghcs^[icsPg]^^.prprf := rghcs^[IcsEdFromPane(oboxPane,orecDummy)]^^.prprf;
    END;
IcsPgPreviewObox := icsPg;
END;

{$ifc fDbgOk}
PROCEDURE PxBitMap;
LABEL 10;
VAR
    cRow,cByte,oByte,cRow1,cRow2,c,c2,cLstRow: TC;
    pByte: TP;
    argch: ARRAY[0..79] OF CHAR;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
cLstRow := thePort^.portBits.bounds.bottom - thePort^.portBits.bounds.top;

{Is entire bitmap empty?}
FOR cByte := 0 TO cLstRow*thePort^.portBits.rowBytes DO BEGIN;
    pByte := POINTER(ORD(thePort^.portBits.baseAddr)+cByte);
    IF pByte^ <> 0 THEN GOTO 10;
    END;
WRITELN('Empty bit map');
EXIT(PxBitMap);

10:
WRITE(' ');
FOR cByte:=0 TO CMin(79, thePort^.portBits.rowBytes) DO WRITE('-');
WRITELN;

cRow1 := 0;
WHILE cRow1 < cLstRow DO
    BEGIN
    WRITE('|');
    FOR c := 0 TO 79 DO argch[c] := ' ';
    FOR cRow2 := 0 TO 7 DO
        BEGIN
        FOR cByte:=0 TO CMin(80, thePort^.portBits.rowBytes) DO
            BEGIN
            oByte := ((cRow1+cRow2)*thePort^.portBits.rowBytes)+cByte;
            pByte := POINTER(ORD(thePort^.portBits.baseAddr)+oByte);
            IF pByte^ <> 0 THEN argch[cByte] :='*';
            END;
        END;
    c2 := 79;
    WHILE argch[c2] = ' ' DO c2 := c2-1;
    FOR c := 0 TO c2 DO WRITE(argch[c]);
    WRITELN;
    cRow1 := cRow1+8;
    END;

WRITE(' ');
FOR cByte:=0 TO CMin(79, thePort^.portBits.rowBytes) DO WRITE('-');
WRITELN;
END;  {PxBitMap}
{$endc}


{$S LWPrint}
{$IFC fPrintOld}                                                    {gdf 2/1/84}
{--------------------------------------------}
PROCEDURE Print (prins: TPrins; oboxPane: TC);
{--------------------------------------------}
LABEL 1,2,3,4,5,7,8;
{$ELSEC}                                                            {gdf 2/1/84}
{--------------------------------------------}
PROCEDURE Print (prins: TprRec; oboxPane: TC);
{--------------------------------------------}
{$ENDC}                                                             {gdf 2/1/84}
VAR orecCon, orec, orecConPrt: TC;
    recCon, recConPt: TRec;
    tyterm: TTyterm;
    icsBody, icsPg: TB;
    ptMax, ptZero: TPt;
    pint: TPint;
    lpOrLppg: TLpOrLppg;
    fWasPreview: TF;
    rBand: TR;
    ch: CHAR;
    fShowing: TF;
    cError: TC;
    prinfo: TPrInfo;
    fCheckPaper,fAbortOffPaper: TF;
    pbox: TPbox;
    oboxPrt: TC;

{$IFC fPrintOld}                                                    {gdf 2/1/84}


BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{ turn off display of selection for printing }
fShowing := selCur.fShowing;
IF fShowing THEN ShowSel(selCur, tyshowOff);

icsPg := IcsPgPreviewObox(oboxPane, orecCon, fWasPreview);
IF fTstLotus THEN WRITELN('Print icsPg:', icsPg:3);
PrMetrics(rghcs^[icsPg]^^.prprf, prinfo);
rPrintable := prinfo.rPrintable;
{$ifc fDbgOk}
IF fTstPrt THEN PxR('rPrintable:', rPrintable);
{$endc}
fCheckPaper := TRUE;
fAbortOffPaper := FALSE;
fOffPaper := FALSE;
{IF fTstPrt THEN WRITELN('thePort is at ', ORD(thePort));}

ptZero.h := 0; ptZero.v := 0; ptMax.h := MAXINT; ptMax.v := MAXINT;
orecConPrt := Orec1Alloc(icsPg, 0, 0, ptZero, ptMax, TyxyTld(icsPg),
                         fixedLpFst + fixedR + fixedLpLim, TRUE, foNil);

oboxPrt := OboxAlloc(rPrintable, tyboxPane, orecConPrt, oboxNil, NIL);

 { the only pane is the head of both scroll chains }
pbox := POINTER(ORD(bdsp) + oboxPrt);
WITH pbox^ DO BEGIN
    rgfScHead[tyvhH]  := TRUE;   rgfScHead[tyvhV]  := TRUE;
    rgoboxLink[tyvhH] := oboxNil;  rgoboxLink[tyvhV] := oboxNil;
    END;
recCon := POINTER(ORD(dsp) + orecConPrt);
recCon^.foPrnt.fObox := TRUE; recCon^.foPrnt.o := oboxPrt;

1:
PrDocStart(cError, prins, ldsnPrint, TRUE);
CASE PrCheckErr(cError) OF
    prGoDocStart:   BEGIN PrSetSpool(prins, FALSE); GOTO 1; END;
    prGoDocEnd:     GOTO 5;
    prGoExit:       GOTO 3;
    prGoCont:       ;
OTHERWISE Break(1430);
END;
IF fTstPrt THEN WRITELN('Printer opened');

IF prins.prstl.adev.edev = edevTyper
    THEN BEGIN
        TextFont(p10tile);
        TextFace([]);
        END
    ELSE BEGIN
        TextFont(tile12);
        TextFace([]);
        END;
IF fTstPrt THEN WRITELN('Printer font set.');

lpOrLppg.lp := 0;
REPEAT
     recConPt := POINTER(ORD(dsp) + orecConPrt);
     orec := recConPt^.orecSon;
     WHILE orec <> orecNil DO orec := OrecSibFree(orec);
     recConPt^.strec.fValid := FALSE;
     recConPt^.orecSon := orecNil;
     pint := POINTER(ORD(lldInt) + recConPt^.ointDep);
     pint^.lpFst := lpOrLppg.lp;
     lpOrLppg.lppg.ipg := lpOrLppg.lppg.ipg + 1;
     pint^.lpLim := lpOrLppg.lp;
8:{?}PrStartPage(cError);
     CASE PrCheckError(cError) OF
         prGoDocStart:   BEGIN PrSetSpool(prins, FALSE); GOTO 1; END;
         prGoStartPage:  GOTO 8;
         prGoEndPage:    GOTO 2;
         prGoDocEnd:     GOTO 5;
         prGoExit:       GOTO 3;
         prGoCont:       ;
     OTHERWISE Break(1431);
     END;
     tyterm := tytermLayoutDone;  { initial throw-away value, <> tytermEos }
     WHILE (tyterm <> tytermEos) DO BEGIN
         IF  NOT PrNextBand(rBand) THEN GOTO 4; {end-of-page}
         {$ifc fDbgOk}
         IF fTstPrt THEN PxR('PrNextBand', rBand);
         {$endc}
         {IF fTstPrt THEN
             BEGIN
             GetPort(pport);
             WRITELN('Port at ', ORD(pport));
             PxR('Clip rgn bbox:', pport^.clipRgn^^.rgnBBox);
             PxR('Vis  rgn bbox:', pport^.visRgn^^.rgnBBox);
             PxR('portRect:     ', pport^.portRect);
             WRITELN('Clip rgn size:', pport^.clipRgn^^.rgnSize);
             WRITELN('Vis  rgn size:', pport^.visRgn^^.rgnSize);
             END;
         }
         pbox := POINTER(ORD(bdsp) + oboxPrt);
         pbox^.window := thePort;
         Inv(orecConPrt, rBand, TyxyTld(icsPg), TRUE);
         tyterm := TytermUpdateRec(orecConPrt, iimgpQume, FALSE);
         IF fTstPrt THEN
             BEGIN
             WRITELN('TytermUpdateRec = ', ORD(tyterm));
             IF tyterm = tytermEos THEN WRITELN('tyterm = EOS');
             END;
         {IF fTstPrt THEN
             BEGIN
             GetPort(pport);
             WRITELN('Port at ', ORD(pport));
             PxR('Clip rgn bbox:', pport^.clipRgn^^.rgnBBox);
             PxR('Vis  rgn bbox:', pport^.visRgn^^.rgnBBox);
             PxR('portRect:     ', pport^.portRect);
             WRITELN('Clip rgn size:', pport^.clipRgn^^.rgnSize);
             WRITELN('Vis  rgn size:', pport^.visRgn^^.rgnSize);
             PxBitMap;
             END;
         }
7:       PrDumpBand(cError);
         IF fTstPrt THEN WRITELN('PrDumpBand');
         IF fCheckPaper AND fOffPaper THEN BEGIN;
             IF CautionAlert(WPAlerts, 28) THEN
                  fCheckPaper := FALSE
             ELSE BEGIN;
                  fAbortOffPaper := TRUE;
                  PrCleanup;
                  GOTO 3;
                  END;
             END;
         CASE PrCheckErr(cError) OF
             prGoDocStart:   BEGIN PrSetSpool(prins, FALSE); GOTO 1; END;
             prGoStartPage:  GOTO 8;
             prGoEndPage:    GOTO 2;  {"will not occur here"--usually reliable source}
             prGoDumpBand:   GOTO 7;
             prGoDocEnd:     GOTO 5;
             prGoExit:       GOTO 3;
             prGoCont:       ;
         OTHERWISE Break(1432);
         END;
         END;
4:
     IF fTstPrt THEN WRITELN('End Page');

2:
      { won't get eos until after have ejected last page, so don't eject another if
      eos }
     IF tyterm <> tytermEos THEN BEGIN
         PrEndPage(cError);
         CASE PrCheckErr(cError) OF
             prGoDocStart:   BEGIN PrSetSpool(prins, FALSE); GOTO 1; END;
             prGoStartPage:  GOTO 8;
             prGoEndPage:    GOTO 2;  {"will not occur here"--usually reliable source}
             prGoDocEnd:     GOTO 5;
             prGoExit:       GOTO 3;
             prGoCont:       ;
         OTHERWISE Break(1433);
         END;
         END;
UNTIL (tyterm = tytermEos) OR FEosLpPg(icsPg,lpOrlppg.lp) OR (fAbortOffPaper);

5:  {prGoDocEnd: skip all remaining pages in document }
PrDocEnd(cError);
CASE PrCheckErr(cError) OF
    prGoDocStart:   BEGIN PrSetSpool(prins, FALSE); GOTO 1; END;
    prGoEndPage:    GOTO 2;  {"will not occur here"--usually reliable source}
    prGoDocEnd:     GOTO 5;
    prGoExit:       GOTO 3;
    prGoCont:       ;
OTHERWISE Break(1434);
END;

{$ELSEC}                                                            {gdf 2/1/84}

{ This code was inspected by Tom Malloy on 2 Feb 84--gdf }
{ Note: It should also be checked with David Casseres??? }


  PrPort: TPrPort;

BEGIN
{ turn off display of selection for printing }
{$IFC sampcalls}  ALogCall;  {$ENDC}
fPrinting := true;
fShowing := selCur.fShowing;
IF fShowing THEN ShowSel(selCur, tyshowOff);

icsPg := IcsPgPreviewObox(oboxPane, orecCon, fWasPreview);
IF fTstLotus THEN WRITELN('Print icsPg:', icsPg:3);
prinfo:=rghcs^[icsPg]^^.prprf.prInfo;
rPrintable := prinfo.rPrintable;
{$ifc fDbgOk}
IF fTstPrt THEN PxR('rPrintable:', rPrintable);
{$endc}
fCheckPaper := TRUE;
fAbortOffPaper := FALSE;
fOffPaper := FALSE;
{IF fTstPrt THEN WRITELN('thePort is at ', ORD(thePort));}

ptZero.h := 0; ptZero.v := 0; ptMax.h := MAXINT; ptMax.v := MAXINT;
orecConPrt := Orec1Alloc(icsPg, 0, 0, ptZero, ptMax, TyxyTld(icsPg),
                         fixedLpFst + fixedR + fixedLpLim, TRUE, foNil);

oboxPrt := OboxAlloc(rPrintable, tyboxPane, orecConPrt, oboxNil, NIL);

{ the only pane is the head of both scroll chains }
pbox := POINTER(ORD(bdsp) + oboxPrt);
WITH pbox^ DO BEGIN
    rgfScHead[tyvhH]  := TRUE;   rgfScHead[tyvhV]  := TRUE;
    rgoboxLink[tyvhH] := oboxNil;  rgoboxLink[tyvhV] := oboxNil;
    END;
recCon := POINTER(ORD(dsp) + orecConPrt);
recCon^.foPrnt.fObox := TRUE; recCon^.foPrnt.o := oboxPrt;

        { Why do this?  To init QD port maybe????????????????????????????????? }
        IF prins.prInfo.adev.edev = edevTyper THEN BEGIN
           TextFont(p10tile);
           TextFace([]);
        END
        ELSE BEGIN
           TextFont(tile12);
           TextFace([]);
        END;
        IF fTstPrt THEN WRITELN('Printer font set.');

lpOrLppg.lp := 0;

IF PrDocStart(prins, prport, ldsnPrint, TRUE) THEN       {gdf 2/7/84}
REPEAT
     { get ready for a page }
     recConPt := POINTER(ORD(dsp) + orecConPrt);
     orec := recConPt^.orecSon;
     WHILE orec <> orecNil DO orec := OrecSibFree(orec);
     recConPt^.strec.fValid := FALSE;
     recConPt^.orecSon := orecNil;
     pint := POINTER(ORD(lldInt) + recConPt^.ointDep);
     pint^.lpFst := lpOrLppg.lp;
     lpOrLppg.lppg.ipg := lpOrLppg.lppg.ipg + 1;
     pint^.lpLim := lpOrLppg.lp;

     IF PrPageStart(prins, prport) THEN BEGIN
        pbox := POINTER(ORD(bdsp) + oboxPrt);
        pbox^.window := thePort;
        {create page image}
        tyterm := TytermUpdateRec(orecConPrt, iimgpQume, FALSE);
        IF fCheckPaper AND fOffPaper THEN BEGIN  {image is off paper}
           IF CautionAlert(WPAlerts, 28) THEN    {can we do alert now?????????}
              fCheckPaper := FALSE
              ELSE BEGIN
                   fAbortOffPaper := TRUE;
                   PrSpoolAbort;
              END;
        END;
     END;
UNTIL PrPageEnd(prins, prport)
        (*** OR (tyterm = tytermEos) unnecessary, sez tjm 2/2/84 ***)
        OR FEosLpPg(icsPg,lpOrlppg.lp)
        OR (fAbortOffPaper);

{skip all remaining pages in document }
PrDocEnd(prins, prport);

{$ENDC}                                                             {gdf 2/1/84}

FreeObox(oboxPrt);
orecConPrt := OrecSibFree(orecConPrt);
IF NOT fWasPreview THEN
     BEGIN
      { Should this be here? }
     (* No!!
        IF acrd.arec.ointDep <> ointNil THEN
          BEGIN
          pint := POINTER(ORD(lldInt) + acrd.arec.ointDep);
          IF pint^.ics = icsPg THEN
               BEGIN
               FreeInt(icsPg, acrd.arec.ointDep);
               acrd.arec.ointDep := ointNil;
               END;
          END;
     *)
     FreeIcs(icsPg);
     END;

{ turn display of selection back on }
IF fShowing THEN BEGIN ShowSel(selCur, tyshowOn); ValidateDsp; END;
fPrinting := false;
pbox := PboxFromObox(oboxPane);
DoFolderUpdate(pbox^.window);
(* PrBgdDlg;{gdf 2/2/84} {removed--med 3-13} *)

IF fTstLotus THEN WRITELN('Print finished.');
END;


{$S LWSave}
{--------------------------------------------------------------------------------}
FUNCTION OboxOpenWindow(ics: TB; window: TWindow; spTitle: TSp;
                        oboxPane: TC; fPaintPane: TF): TC;
{--------------------------------------------------------------------------------}
CONST
    hLeftPaneStd = 75;   {3/4 inch}
VAR orecCon: TC;
    recCon: TRec;
    ptCon: TPt;
    pboxPane: TPbox;
    fid: TFid;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstLotus THEN WRITELN('OboxOpenWindow:', spTitle);
ptCon.h := -hLeftPaneStd; ptCon.v := 0;
orecCon := OrecCreateWindow(ics, 0, ptCon, oboxNil);
IF oboxPane = oboxNil THEN BEGIN
    fid := FidCreateFolder(window, orecCon, spTitle, fPaintPane);
    oboxPane := OboxFstOnSc(ScidFstFromFid(fid, tyvhH));
    pboxPane := PboxFromObox(oboxPane);
    END
ELSE BEGIN
    pboxPane := PboxFromObox(oboxPane);
    pboxPane^.refCon := orecCon;
    END;
recCon := POINTER(ORD(dsp) + orecCon);
recCon^.foPrnt.fObox := TRUE; recCon^.foPrnt.o := oboxPane;
recCon^.r.botRight := pboxPane^.r.botRight;
OboxOpenWindow := oboxPane;
{$ifc fDbgOk}
IF fTstLotus THEN PxOrec(orecCon);
{$endc}
END;

{$S LWOpen}
{-------------------------------------------------------------}
PROCEDURE WriteFolder(VAR cError: TC; ics: TB; path: Pathname; password: E_name);
{-------------------------------------------------------------}
VAR ifil: TC;
    hcspg: THcspg;
    hcsed: THcsed;
    cErrorIgnore: TC;
    icsFig: TB; ifilFig: TB;
    pathFig: Pathname;
    pglp: TPglp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
ifil := IFilOpen(cError, path, cbPgFf, [dRead, dWrite, Append], hzLotus, password);
IF fTstLotus THEN WRITELN('WriteFolder -- ifil:', ifil:3);
IF cError <= 0 THEN
    BEGIN
    pathFig := CONCAT(path, '.Figures');
    icsFig := IcsFigCreate(cError, pathFig, [dRead, dWrite, Append], hzLotus, password);
    IF cError <= 0 THEN
         BEGIN
         ifilFig := IfilOfFig(icsFig);
         IF rghcs^[ics]^^.tycs = tycsPg THEN
             BEGIN
             hcspg := POINTER(ORD(rghcs^[ics]));
             ics := hcspg^^.pgd.icsBody;
             END;
         IF rghcs^[ics]^^.tycs <> tycsEd THEN Break(84);
         hcsed := POINTER(ORD(rghcs^[ics]));
         {$ifc fInkJet}
         ConvertPglpTyxy(hcsed^^.pglp, pglp, tyxyScrn);
         WriteIcsFf(ics, pglp, hcsed^^.tyrlu, ifil, ifilFig, hzLotus);
         {$elsec}
         WriteIcsFf(ics, hcsed^^.pglp, hcsed^^.tyrlu, ifil, ifilFig, hzLotus);
         {$endc}
         IF fTstLotus THEN WRITELN('WriteFolder -- ifil written.');
         CleanIfil(cError, hzLotus, ifil, FALSE);
         IF cError <= 0 THEN CleanIfil(cError, hzLotus, ifilFig, FALSE);
         FreeIcs(icsFig);
         END;
    CloseIfil(cErrorIgnore, ifil);
    END;
END;

{----------------------------------------------------}
PROCEDURE CreateFile (VAR cError: TC; path: Pathname; password: E_name);
{----------------------------------------------------}
VAR icsEd, icsHdr, icsFtr: TB;
    pglp: TPglp;

{$IFC fPrintOld}                                                    {gdf 1/16/84}

    prprf: TPrprf;

{$ELSEC}                                                            {gdf 1/16/84}

    prprf: TPrRec;

{$ENDC}                                                             {gdf 1/16/84}

    hcsed: THcsEd;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
icsHdr := IcsEdCreate(5, pglpStd, TRUE, hzLotus);
icsFtr := IcsEdCreate(5, pglpStd, TRUE, hzLotus);
Replace(icsHdr, 0, 0, icsCr, 0, 1);
Replace(icsFtr, 0, 0, icsCr, 0, 1);
pglp := pglpStd;
pglp.icsHdr := icsHdr; pglp.icsFtr := icsFtr;
icsEd := IcsEdCreate(10, pglp, TRUE, hzLotus);
PrPrfDefault(prprf);
rghcs^[icsEd]^^.prprf := prprf;
rghcs^[icsHdr]^^.prprf := prprf;
rghcs^[icsFtr]^^.prprf := prprf;
hcsed := POINTER(ORD(rghcs^[icsEd]));
hcsed^^.tyrlu := tyrluDefault;
Replace(icsEd, 0, 0, icsCr, 0, 1);
WriteFolder(cError, icsEd, path, password);
FreeIcs(icsHdr);  FreeIcs(icsFtr);  FreeIcs(icsEd);
END; {CreateFile}


{$S LWSave}
{------------------------------------------------------------------------------------}
PROCEDURE OpenDocument { (VAR cError: TC; spTitle: TSp; path: Pathname;
                          window: TWindow; fPaintPane: TF; fCreate: TF,
                          password: E_name) };
{------------------------------------------------------------------------------------}
LABEL 99;
VAR icsDoc, icsEd, icsHdr, icsFtr: TB;
    pglp: TPglp; oboxPane: TC; rPane: TR; ifil: TC;
    ffleader: TFfleader; pLeader: ^TFfLeader;
    tycs: TTyCs; lpFst, lpLim: TLp; fid: TFid; tyvh: TTyvh; scid: TScid;
    ichOfLp: TC; rgch: TRgch;
    pcsed: TPcsed;
    cErrorIgnore: TC;
    icsFig: TB; pathFig: Pathname;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstLotus THEN WRITELN('OpenDocument');
ifil := IFilOpen(cError, path, cbPgff, [dRead], hzLotus, password);
IF fTstLotus THEN WRITELN('IFilOpen cError: ', cError);
IF (cError = 948) AND fCreate THEN {file does not exist}
    BEGIN
    CreateFile(cError, path, password);
    IF cError <= 0 THEN BEGIN
        ifil := IFilOpen(cError, path, cbPgff, [dRead], hzLotus, password);
        IF fTstLotus THEN WRITELN('IFilOpen2 cError: ', cError);
    END
    ELSE GOTO 99
    END;
IF cError > 0 THEN {some other error in opening file}
    GOTO 99;

pLeader := POINTER(ORD(PMapN(hzLotus, NFromIfilIb(ifil, 0))));
IF pLeader = NIL THEN
     BEGIN
     { CleanIfil will set cError to correct value }
     CleanIfil(cError, hzLotus, ifil, TRUE);
     cError := cErrDocEmpty;
     CloseIfil(cErrorIgnore, ifil);
     GOTO 99;
     END;
ffleader := pLeader^;
IF fTstLotus THEN WRITELN(' pLeader:', ORD(pLeader));
IF ffleader.password = pwFf THEN
    BEGIN
    IF ffleader.version > ffVersion THEN
        BEGIN
        CleanIfil(cError, hzLotus, ifil, TRUE);
        CloseIfil(cError, ifil);
        cError := cErrDocTooNew;
        GOTO 99;
        END;

    icsHdr := IcsEdCreate(5, pglpStd, TRUE, hzLotus);
    icsFtr := IcsEdCreate(5, pglpStd, TRUE, hzLotus);
    pathFig := CONCAT(path, '.Figures');
    icsFig := IcsFigCreate(cErrorIgnore, pathFig, [dRead], hzLotus, password);

    icsDoc := IcsFfCreate(ifil, icsFig, hzLotus, ffleader);
    pglp := ffleader.pglp;
    IF NOT (pglp.tyxy IN [tyxyScrn, tyxyIP, tyxyDotMx]) THEN BEGIN
         IF fTstLotus THEN WRITELN('** Bad pglp.tyxy in file leader, set to pglpStd.tyxy **');
         pglp.tyxy := pglpStd.tyxy;
         END;
    lpFst := ffleader.lpTxtFst;
    lpLim := LpMacFf(icsDoc);
    tycs := tycsFf;
    Replace(icsHdr, 0, 0, icsDoc, ffleader.lpHdrFst, ffleader.lpFtrFst);
    Replace(icsFtr, 0, 0, icsDoc, ffleader.lpFtrFst, ffleader.lpTxtFst);
    END
ELSE BEGIN
    CleanIfil(cError, hzLotus, ifil, TRUE);
    CloseIfil(cError, ifil);

    {try fix to UCSD files}
    icsHdr := IcsEdCreate(5, pglpStd, TRUE, hzLotus);
    icsFtr := IcsEdCreate(5, pglpStd, TRUE, hzLotus);
    pathFig := CONCAT(path, '.Figures');
    icsFig := IcsFigCreate(cErrorIgnore, pathFig, [dRead], hzLotus, password);
    {end of fix}

    ifil := IFilOpen(cError, path, cchPgUf, [dRead], hzLotus, password);
    lpFst := 0;
    tycs := tycsUf;
    icsDoc := IcsUfCreate(ifil, hzLotus);
    pglp := pglpStd;
    lpLim := LpMacUf(icsDoc);
    PrPrfDefault(ffleader.prprf);
    ffleader.tyrlu := tyrluDefault;
    END;
IF fTstLotus THEN WRITELN(' icsDoc created');
pglp.icsHdr := icsHdr;
pglp.icsFtr := icsFtr;
IF LpMacEd(icsHdr) = 0 THEN Replace(icsHdr, 0, 0, icsCr, 0, 1);
IF LpMacEd(icsFtr) = 0 THEN Replace(icsFtr, 0, 0, icsCr, 0, 1);
icsEd := IcsEdCreate(10, pglp, TRUE, hzLotus);

pcsed := POINTER(ORD(rghcs^[icsEd]^));
pcsed^.icsOrig := icsDoc;

IF ffleader.password = pwFf THEN IF ffleader.version >= ffVerPrPrf THEN
   BEGIN
   IF NOT FPrPrfValid(ffleader.prprf)

{$IFC fPrintOld}                                                    {gdf 1/16/84}

           THEN PrPrfFix(ffleader.prprf);

{$ELSEC}                                                            {gdf 1/16/84}

           {Should this be PrPrfDlg ???????????????????????????????? gdf 2/2/84 }
           {--dialog to ask about printer & paper ?????????????????? gdf 2/2/84 }
           {Or, should there be a note alert: ?????????????????????? gdf 2/2/84 }
           {--doc format not compatible with printers ?????????????? gdf 2/2/84 }
           {--doc format not compatible with version ??????????????? gdf 2/2/84 }
           {Or, did leader version check handle this case already ?? gdf 2/2/84 }

           THEN PrPrfDefault(ffleader.prprf);  { ??????????????????? gdf 2/2/84 }

{$ENDC}                                                             {gdf 1/16/84}

   END;
rghcs^[icsEd]^^.prprf := ffleader.prprf;
rghcs^[icsHdr]^^.prprf := ffleader.prprf;
rghcs^[icsFtr]^^.prprf := ffleader.prprf;
pcsed := POINTER(ORD(rghcs^[icsEd]^));
IF ffleader.tyrlu IN [tyrluEnglish, tyrluMetric] THEN
   pcsed^.tyrlu := ffleader.tyrlu ELSE pcsed^.tyrlu := tyrluDefault;
Replace(icsEd, 0, 0, icsDoc, lpFst, lpLim);

{Common to pre-existing and newly created files}
 (* SetRect(rPane, 16, 45, 690, 280); *)
oboxPane := OboxOpenWindow(icsEd, window, spTitle, oboxNil, fPaintPane);
 { allow splits; set scroll for arrows in all directions, thumb on vertical only }
scid := ScidFromObox(oboxPane, tyvhH);
fid := FidFromScid(scid);
SetLSbIcons(scid, [iconArwA, iconArwB, iconSkewer]);
scid := ScidFromObox(oboxPane, tyvhV);
SetLSbIcons(scid, [iconArwA, iconArwB, iconPagA, iconPagB, iconSkewer, iconThumb]);
SetLThumb(scid, 0);
SetPort(window);
RemoveScrollBoxes(FidOfWindow(window));
99:
IF fTstLotus THEN WRITELN('Exiting OpenDocument, cError: ', cError);
END;

{$S LWEdited}
{------------------------------------------------------}
PROCEDURE OrigPathOfIcsEd(ics: TB; VAR path: String255; VAR password: e_name);
{------------------------------------------------------}
VAR hcsed: THcsed;
  icsOrig: TB;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
  hcsed := POINTER(ORD(rghcs^[ics]));
  icsOrig := hcsed^^.icsOrig;
  CASE rghcs^[icsOrig]^^.tycs OF
    tycsFf:  PathOfIfil(IfilOfFf(icsOrig), path, password);
    tycsUf:  PathOfIfil(IfilOfUf(icsOrig), path, password);
  OTHERWISE  Break(863);
  END;
END;  {OrigPathOfIcsEd}

{--------------------------------------------------------}
PROCEDURE PathOfOboxTab (oboxTab: TC; VAR path: Pathname; VAR password: e_name);
{--------------------------------------------------------}
VAR
   ics: TC;
   hcspg: THCspg;
   path255: String255; {Yech!}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
path255 := '';
ics := IcsOfObox(oboxTab);
IF ics = icsNil THEN break(1622)
ELSE BEGIN
   IF rghcs^[ics]^^.tycs = tycsPg THEN BEGIN
      hcspg := POINTER(ORD(rghcs^[ics]));
      ics := hcspg^^.pgd.icsBody;
      END;
   OrigPathOfIcsEd(ics, path255, password);
   END;
path := path255;
END;  {PathOfOboxTab}


{--------------------------------}
FUNCTION OboxTabOfIcs(ics: TB):TC;
{--------------------------------}
LABEL 99;
VAR oboxTab: TC;
  oboxPane: TC;
  orecCon: TC;
  pbox: TPbox;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
  oboxTab := bdsp^.oboxRoot;
  WHILE oboxTab <> oboxNil DO BEGIN
      pbox := PboxFromObox(oboxTab);
      IF pbox^.tybox = tyboxTab THEN BEGIN
          oboxPane := OboxFstOnSc(ScidFstFromFid(oboxTab, tyvhV));
          IF IcsEdFromPane(oboxPane, orecCon) = ics THEN GOTO 99;
          END;
      oboxTab := pbox^.oboxNxt;
      END;
  99:
  OboxTabOfIcs := oboxTab;
END;  {OboxTabOfIcs}


{$S LWOpen}
{---------------------------------------}
FUNCTION FUCSDFile(filname: Pathname):TF;
{---------------------------------------}
VAR iDot: TC;
  sp: TSp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
FUCSDFile := FALSE;
{ iDot := Pos('.', filname);
  IF iDot<>0 THEN
     BEGIN
     sp := Copy(filname, iDot+1, Length(filname)-iDot);
     MakeSpUpper(sp);
     IF sp = 'TEXT' THEN FUCSDFile := TRUE;
     END;
}
END;  {FUCSDFile}


{-----------------------------------------------------------------------------}
PROCEDURE WriteAnyFolder(VAR cError: TC; ics: TB; oboxTab: TC;
                         path: Pathname; password: E_name);
{-----------------------------------------------------------------------------}
VAR fUCSD: TF;
    filnamCurr: Str255;
    pboxTab: TPBox;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
  {Note: filnamCurr is the document name, not the filer-defined path name}
  pboxTab := PboxFromObox(oboxTab);
  IF fTstLotus THEN WRITELN('WriteAnyFolder-- oboxTab =', oboxTab, ' pboxtab =',
                            ORD(pboxTab), ' window =', ORD(pboxTab^.window));
  GetFldrTitle(pboxTab^.window, filnamCurr);
  fUCSD := fUCSDFile(filnamCurr);
  IF FMonitorFile(filnamCurr) THEN
     IF fUCSD THEN
        WriteUCSDFolder(cError, ics, filnamCurr)
     ELSE
        WriteFolder(cError, ics, filnamCurr, password)
  ELSE
     IF fUCSD THEN
        WriteUCSDFolder(cError, ics, path)
     ELSE
        WriteFolder(cError, ics, path, password);
END;  {WriteAnyFolder}


{$S LWMisc}
{---------------------------------}
PROCEDURE RestartIcs(icsEd: TB);
{---------------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
  {For now, just release the whole stream.}
  IF rghcs^[icsEd]^^.tycs = tycsEd
     THEN Replace(icsEd, 0, LpMacEd(icsEd), icsNil, 0, 0)
     ELSE Break(505);
END;  {RestartIcs}


{$S LWMisc}
{--------------------------------------}
FUNCTION FReasonWhy(cError: TC):FReason;
{--------------------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
  CASE cError OF
    { Open }
    872, 947:        FReasonWhy := noDiskSpace;
    871, 948:        FReasonWhy := cantRead;

    { Write_data }
    811, 961, 962, 963, 964, 965, 967, 1198:
                     FReasonWhy := internalError;
    802:             FReasonWhy := cantWrite;
    848, 882:        FReasonWhy := noDiskSpace;
    1181:            FReasonWhy := noMemory;
    835, 849, 884, 1190:
                     FReasonWhy := cantWrite;

    { Read_data }
    955, 956, 957, 881, 883:
                     FReasonWhy := internalError;
    959:             FReasonWhy := noMemory;

    { Make_file }
    890, 921, 922:   FReasonWhy := internalError;
    854, 855:        FReasonWhy := noDiskSpace;

    { OpenDocument }
    cErrDocTooNew:   FReasonWhy := newerDoc;
    1294:            FReasonWhy := wrongPassword;

    { Rename_entry }
    { Kill_object }
    { Close_object }
    OTHERWISE  FReasonWhy := internalError;
  END;
END;  {FReasonWhy}


{$S LWEdited}
{-----------------------------}
PROCEDURE MarkStream (ics: TB);
{-----------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF ics<>icsNil THEN IF ORD(rghcs^[ics])<>ORD(hNil) THEN
  BEGIN
  rghcs^[ics]^^.cRef := 1;
  IF fTstLotus THEN WRITE('<', ics:3, '>');
  END
ELSE
  IF fTstLotus THEN WRITE(ics:3);
END; {MarkStream}


{--------------------------------}
PROCEDURE MarkSubStreams(ics: TB);
{--------------------------------}
{Mark all file-type streams referenced by Ed-, Pg-, and Fm-type streams}
VAR icsSon: TB;
    hcsed:  THcsed;
    hcspg:  THcspg;
    hcsfm:  THcsfm;
    iss:    TC;
    lfld:   TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstLotus THEN WRITE ('MarkSubStreams, ics =', ics:3);
IF ics<>icsNil THEN
    IF ORD(rghcs^[ics]) <> ORD(hNil) THEN
        CASE rghcs^[ics]^^.tycs OF
        tycsEd:
            BEGIN
                hcsed := POINTER(ORD(rghcs^[ics]));
                IF fTstLotus THEN WRITE (', tycsEd, issMac is ', hcsed^^.issMac:3);
                FOR iss:=0 TO hcsed^^.issMac-1 DO
                    IF NOT hcsed^^.argss[iss].fVan THEN
                       MarkStream(hcsed^^.argss[iss].icsSon);
                END;
        tycsPg:
            BEGIN
                hcspg := POINTER(ORD(rghcs^[ics]));
                IF fTstLotus THEN WRITE(', tycsPg');
                icsSon := hcspg^^.pgd.icsBody;
                MarkStream(icsSon);
            END;
        tycsFm:
            BEGIN
                hcsfm := POINTER(ORD(rghcs^[ics]));
                IF fTstLotus THEN WRITE(', tycsFm, icsPlate =', hcsfm^^.icsPlate:3);
                MarkStream(hcsfm^^.icsPlate);
                IF fTstLotus THEN WRITE(', lfldMac =', hcsfm^^.lfldMac:3);
                FOR lfld := 0 TO (hcsfm^^.lfldMac DIV 4)-1 DO
                    MarkStream(hcsfm^^.argffld[lfld].icsVal);
            END;
        END; {CASE}
        IF fTstLotus THEN WRITELN;
END; {MarkSubStreams}


{-----------------------}
PROCEDURE ReleaseStreams;
{-----------------------}
VAR prcsCur:  TL;
    ics: TB;
    hcs: THcs;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{Unmark all streams}
FOR ics:=0 TO icsMac-1 DO
    IF ORD(rghcs^[ics]) <> ORD(hNil) THEN rghcs^[ics]^^.cRef := 0;

{Mark streams referenced by Ed-, Pg-, and Fm-type streams}
FOR ics:=0 TO icsMac-1 DO MarkSubStreams(ics);

{Release unmarked file-type (Ff or Uf) and Us-type streams}
prcsCur := My_Id;
IF fTstLotus THEN WRITELN('prcsCur: ', ORD(prcsCur));
FOR ics:=0 TO icsMac-1 DO BEGIN
    IF fTstLotus THEN WRITELN('Checking ics: ', ics,
                              ', mpicsprcs ^[ics]: ', mpicsprcs ^[ics]);
    {$ifc fDbgOk}
    IF fTstLotus THEN PxCs(ics);
    {$endc}
    hcs := POINTER(ORD(rghcs^[ics]));
    IF ORD(hcs) <> ORD(hNil) THEN
        CASE hcs^^.tycs OF
        tycsFf,
        tycsUf:
            IF (hcs^^.cRef=0) AND (mpicsprcs ^[ics] = prcsCur) THEN
                 BEGIN
                 {$ifc fDbgOk}
                 IF fTstLotus THEN WRITELN('Freeing ics: ', ics,
                                     ', mpicsprcs ^[ics]: ', mpicsprcs ^[ics]);
                 IF fTstLotus THEN PxCs(ics);
                 {$endc}
                 FreeIcs(ics);
                 END;
        END;
     END;
 END; {ReleaseStreams}


{-------------------------------------------------------------------------------------}
PROCEDURE SplitPathname({VAR} path: Pathname; VAR volname: Pathname; VAR ename: E_Name);
{-------------------------------------------------------------------------------------}
LABEL 10;
VAR i: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
FOR i := LENGTH(path) DOWNTO 1 DO
    IF path[i]='-' THEN GOTO 10;
i := 0;
10:
volname := COPY(path, 1, i);
ename   := COPY(path, i+1, LENGTH(path)-i);
END;  {SplitPathname}


{-------------------------------------------}
PROCEDURE StripExtension(VAR path: Pathname);
{-------------------------------------------}
VAR i: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
FOR i := LENGTH(path) DOWNTO 1 DO
    IF path[i]='}' THEN BEGIN
        DELETE(path, i+1, LENGTH(path)-i);
        EXIT(StripExtension);
        END;
END;  {StripExtension}


{$S LWMisc}
{-------------------------------------------}
FUNCTION FUsesRefnum(ics: TC; refnum: TC):TF;
{-------------------------------------------}
LABEL 99, 88;
VAR
  hcsed: THcsed;
  hcspg: THcspg;
  hcsfm: THcsfm;
  icsSon: TB;
  iss:   TC;
  lfld:  TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF ics = icsNil THEN
    FUsesRefnum := FALSE
ELSE
    CASE rghcs^[ics]^^.tycs OF
    tycsEd:  BEGIN
             FUsesRefnum := TRUE;
             hcsed := POINTER(ORD(rghcs^[ics]));
             FOR iss := 0 TO hcsed^^.issMac-1 DO
                 IF hcsed^^.argss[iss].fVan = FALSE THEN BEGIN
                     icsSon := hcsed^^.argss[iss].icsSon;
                     IF FUsesRefnum(icsSon, refnum) THEN GOTO 99;
                     END;
             IF FUsesRefnum(hcsed^^.pglp.icsHdr, refnum) THEN GOTO 99;
             IF FUsesRefnum(hcsed^^.pglp.icsFtr, refnum) THEN GOTO 99;
             FUsesRefnum := FALSE;
             99:
             END;
    tycsFf:  BEGIN
             IF RefnumOfIfil(IfilOfFf(ics)) = Refnum
             THEN FUsesRefnum := TRUE
             ELSE FUsesRefnum := FALSE;
             END;
    tycsUf:  BEGIN
             IF RefnumOfIfil(IfilOfUf(ics)) = Refnum
             THEN FUsesRefnum := TRUE
             ELSE FUsesRefnum := FALSE;
             END;
    tycsUs:  FUsesRefnum := FALSE;
    tycsFm:  BEGIN
             FUsesRefnum := TRUE;
             hcsfm := POINTER(ORD(rghcs^[ics]));
             FOR lfld := 0 TO hcsfm^^.lfldMac-1 DO BEGIN
                 icsSon := hcsfm^^.argffld[lfld].icsVal;
                 IF FUsesRefnum(icsSon, refnum) THEN GOTO 88;
                 END;
             FUsesRefnum := FALSE;
             88:
             END;
    tycsPg:  BEGIN
             hcspg := POINTER(ORD(rghcs^[ics]));
             FUsesRefnum := FUsesRefnum(hcspg^^.pgd.icsBody, refnum);
             END;
    OTHERWISE Break(830);
    END;  {CASE}
END;  {FUsesRefnum}

{$S LWCreate}
{------------------------}
PROCEDURE InitFfForLotus;
{------------------------}
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH cspdFf DO
    BEGIN
    argproc[iprocCrd]          := @GenCrdTld;
    argproc[iprocHilight]      := @HilightTld;
    argimgp[iimgpScrn]         := @GenImgTld;
    argimgp[iimgpQume]         := @PrtImgTld;
    END;
WITH cspdFig DO
    BEGIN
    argproc[iprocCrd]          := @GenCrdFig;
    argproc[iprocHilight]      := @HilightTld;
    argimgp[iimgpScrn]         := @GenImgFig;
    argimgp[iimgpQume]         := @GenImgFig;
    END;
END;

{$S LWScroll}
{-----------------------------------------------}
PROCEDURE Preview(oboxPane: TC; fSetPreview: TF);
{-----------------------------------------------}
LABEL 99;
VAR orecCon, orec:     TC;
    recCon:     TRec;
    ics, icsPg, icsT:   TB;
    ointDummy:      TC;
    fWasPreview: TF;
    hcspg: THcspg;
    pint: TPint;
    hcsed: THcsed;
    scid: TScid;
    obox: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF (fSetPreview <> FPreviewObox(oboxPane, orecCon, icsPg)) THEN
     BEGIN
     icsPg := IcsPgPreviewObox(oboxPane, orecCon, fWasPreview);
     IF (fSetPreview = FALSE) THEN
          BEGIN
          IF (icsPageRuler <> icsNil) THEN
               DisplayFstSubImtd(imtdNil);
          hcspg := POINTER(ORD(rghcs^[icsPg]));
          ics := hcspg^^.pgd.icsBody;
          END
     ELSE ics := icsPg;
     scid := ScidFstFromFid(FidFromScid(ScidFromObox(oboxPane, tyvhV)), tyvhV);
     WHILE scid <> scidNil DO
          BEGIN
          obox := OboxFstOnScid(scid);
          WHILE obox <> oboxNil DO
               BEGIN
               icsT := IcsConFromPane(obox, orecCon);
               IF fSetPreview = FALSE THEN
                    BEGIN
                    { Remove all references to icsPg. }
                    IF obox <> OboxVisOrec(orecCon) THEN Break(87);
                    recCon := POINTER(ORD(dsp)+orecCon);
                    FreeInt(icsPg, recCon^.ointDep);
                    recCon := POINTER(ORD(dsp)+orecCon);
                    orec := recCon^.orecSon;
                    recCon^.orecSon := orecNil;
                    WHILE orec <> orecNil DO
                          BEGIN
                          EraseOrec(orec);
                          orec := OrecSibFree(orec);
                          END;
                    { Should this be here? }
                    (* No!!
                      IF acrd.arec.ointDep <> ointNil THEN
                          BEGIN
                          pint := POINTER(ORD(lldInt) + acrd.arec.ointDep);
                          IF pint^.ics = icsPg THEN
                               BEGIN
                               FreeInt(icsPg, acrd.arec.ointDep);
                               acrd.arec.ointDep := ointNil;
                               END;
                          END;
                    *)
                    END;
               recCon := POINTER(ORD(dsp)+orecCon);
               recCon^.strec.fValid := FALSE;
               { move recCon^.r to 0,0 }
               WITH recCon^ DO OffsetRect(r, 0, -r.top) ;
               recCon^.ointDep := OintMark(ointNil, ics, 0, 0, FALSE, ointNil);
               obox := OboxNxtOnSc(obox, tyvhV);
               END;
          scid := ScidNxtFromScid(scid);
          END;
     IF fSetPreview = FALSE THEN
          BEGIN
          hcsed := POINTER(ORD(rghcs^[ics]));
          hcsed^^.pglp := hcspg^^.pgd.pglp;
          hcsed^^.cs.prprf := hcspg^^.cs.prprf;
          FreeIcs(icsPg);
          END;
     END;
99:
END;



ÿ