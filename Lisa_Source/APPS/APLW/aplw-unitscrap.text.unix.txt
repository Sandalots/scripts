{$I APLW/COMPFLAGS }                                            {gdf 1/16/84}
{$R-}

UNIT UnitScrap;

(* Copyright 1983, 1984, Apple Computer Inc. *)

{ gdf  2/27/84 -- insert trace calls for segmentation  }
{ med  2-20/84 -- password protection }
{ gdf  1/16/84  -- printing compile flag & include COMPFLAGS added }
{ tjm  5/03/83  --  WP 299 - ConvertRTyxy and ptpgHdr }
{ crc  4/28/83  --  IgnoreSpaces: strip trailing space if no leading space }
{ tjm  4/06/83  --  RemoveKid(fSaveKid) - (WP 258) }
{ tjm  3/10/83  --  Tweek IntInWindow - fOrecConOk}
{ tjm  3/10/83  --  Tweek horizontal scrolling in IntInWindow }
{ crc  3/02/83  --  Pass lp to OrecConOfOboxIcsLp }
{ crc  2/15/83  --  CPctThumbObox: switched THEN & ELSE clauses in block after
                    "IF icsPg <> icsNil THEN" }
{ crc  2/10/83  --  CPctThumbObox: compute fLayoutPage }
{ crc  1/06/83  --  CPctThumbObox: pass fLayoutPage parm to TytermUpdateRec }
{ crc 10/29/82  --  intelligent cut and paste; added FSelWord, InsertSpaces and
                    IgnoreSpaces, modified OintCut, CutCopy, PasteFrom }
{ jrm 10/20/82  --  fixes to interprocess scrap }
{ jrm 10/15/82  --  moved InheritScrap call (again) }
{ jrm 10/15/82  --  added RecScrapToOboxScrap }
{ tjm  9/ 9/82  --  check for tytermEos in IntInWindow }
{ jrm  9/ 7/82  --  check for icsNil in ReadScrap }
{ jrm  8/ 6/82  --  moved InheritScrap call}
{ jrm  6/29/82  --  USES changes: LisaGraf => QuickDraw; moved USES UnitFile }
{ jrm  5/25/82  --  interprocess Scrap }
{ crc 05/25/82  --  USES PrStd added }
{ crc  5/12/82  --  renamed InitScrap as InitLScrap }
{ crc 04/06/82  --  integration with new font manager }
{ bas 01/13/82  --  USES for new wm }
{ bas 12/10/81  --  integration with font manager }

INTERFACE

USES
    {$IFC sampcalls}                                               {gdf 2/24/84}
       {$U aplw/tracecalls.obj} tracecalls,
    {$ENDC}
    {$U Obj:UnitStd.Obj    } UnitStd,
    {$U Obj:UnitHz.Obj     } UnitHz,
    {$U LibOS/Syscall.Obj }   Syscall,
    {$U Obj:UnitFile.Obj   } UnitFile,
    {$U Obj:Storage.Obj    } Storage,
    {$U Obj:QuickDraw.Obj  } QuickDraw,
    {$U Obj:FontMgr.Obj    } FontMgr,
    {$U Obj:Wm.Events.Obj  } Events,
    {$U Obj:Wm.Folders.Obj } Folders,
    {$U Obj:Wm.Menus.Obj   } Menus,
    {$U Obj:WmlStd         } WmlStd,
    {$U Obj:WmlCrs     } WmlCrs,
    {$U Obj:Filercomm  } Filercomm,
    {$U Obj:PmDecl         } PmDecl,
     {$IFC fPrintOld}                                               {gdf 1/16/84}
        {$U Obj:PrStd.Obj }     PrStd,
     {$ELSEC}
        {$U Obj:PrStdInfo.Obj } PrStdInfo,
          (* {$U Obj:PrPublic.Obj }  PrPublic,  unneeded ? *)
     {$ENDC}                                                        {gdf 1/16/84}
    {$U Obj:UnitFmt.Obj    } UnitFmt,
    {$U Obj:UnitCs.Obj     } UnitCs,
    {$U Obj:UnitFf.Obj     } UnitFf,
    {$U Obj:Scrap.Obj      } Scrap,
    {$U Obj:AlertMgr       } AlertMgr,
    {$U ApLW/Queue.Obj      } Queue,
    {$U ApLW/UnitBox.Obj    } UnitBox,
    {$U ApLW/UnitRec.Obj    } UnitRec,
    {$U ApLW/UnitOver.Obj   } UnitOver,
    {$U ApLW/UnitTld.Obj    } UnitTld,
    {$U ApLW/UnitUs.Obj     } UnitUs,
    {$U ApLW/UnitUf.Obj     } UnitUf,
    {$U ApLW/UnitEd.Obj     } UnitEd,
    {$U ApLW/UnitEdit.Obj   } UnitEdit,
    {$U ApLW/UnitDsp.Obj    } UnitDsp,
    {$U ApLW/UnitSel.Obj    } UnitSel,
    {$U ApLW/UnitKid.Obj    } UnitKid,
    {$U ApLW/UnitPg.Obj     } UnitPg,
    {$U ApLW/BoxScid.Obj    } BoxScid,
    {$U ApLW/UnitFolder.Obj } UnitFolder,
    {$U ApLW/UnitRuler.Obj  } UnitRuler,
    {$U ApLW/UnitFigAtom.Obj  } UnitFigAtom;

CONST cPctNil = -1;
     {$IFC NOT fDbgOk} fTstScrap = FALSE; {$ENDC}

VAR  hzScrap: THz;
     ptThumb: TPt;
     spLotusPrefix: TSp; (* set to first part of Lotus' pathname, e.g. -upper-,
                     -lower-, or -paraport- *)
     icsFigScrap: TB;
{$IFC fDbgOk}
    fTstScrap: TF;
{$ENDC}

PROCEDURE RecScrapToOboxScrap(fLink: TF);
PROCEDURE CutCopy(fCut: TF);
PROCEDURE Paste;
PROCEDURE InitLScrap(hz: THz);
PROCEDURE PasteFrom(icsSrc: TB; lpFstSrc: TLp; lpLimSrc: TLp);

PROCEDURE IntInWindow(oint: TC; orecCon: TC);
FUNCTION CPctThumbObox(oboxPane: TC) : TC;
PROCEDURE LotusGetScrap;
PROCEDURE LotusPutScrap;
PROCEDURE SetRFstOfOint(oint: TC; oboxPane: TC;
                        VAR orec: TC; VAR r: TR; VAR orecCon: TC);
FUNCTION LpPgOfLpEd(icsPg: TB; icsEd: TB; lpPctEd: TLp) : TLp;
PROCEDURE  FailedDuringInit (freasonWhy: FReason);

IMPLEMENTATION

{$IFC fSymOK }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

VAR fScrapFromLotus: TF;
    fScrapIsUT:      TF; (* true iff icsScrap refers to the Universal icsFf *)
    icsSpace:  TB;

{$S LWMisc}
PROCEDURE FailedDuringInit (* freasonWhy: FReason *);
VAR cError: TC;
BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   TellFiler(cError, initFailed, freasonWhy, NIL);
   HALT;
END;


{$S LWStyle}
{--------------------------------------------}
PROCEDURE RecScrapToOboxScrap(* fLink: TF *);
{--------------------------------------------}
VAR pboxScrap: TPBox;
    orecScrap: TC;
    recScrap: TRec;
BEGIN
  {$IFC sampcalls}  ALogCall;  {$ENDC}
  IF oboxScrap <> oboxNil THEN
  BEGIN
    pboxScrap := POINTER(ORD(bdsp) + oboxScrap);
    orecScrap := pboxScrap^.refCon;
    recScrap := POINTER(ORD(dsp) + orecScrap);
    IF fLink THEN recScrap^.foPrnt.o := oboxScrap
             ELSE recScrap^.foPrnt.o := oboxNil;
  END;
END (* RecScrapToOboxScrap *);


{$S LWActive}
{-------------------}
PROCEDURE ReadScrap;
{-------------------}
VAR icsFfScrap: TB;
    lpMac: TL;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstScrap THEN WRITELN('In ReadScrap...');
 (*
   ifil := IFilOpen('LISA:SCRAP.LOTUS', cbPgFf, FALSE);
   icsFfScrap := IcsFfCreate(ifil, hzScrap, ffleader);
   IF ffleader.password <> pwFf THEN Break(9000);
   lpFst := ffleader.lpTxtFst;
   lpLim := ffleader.lpLimFf;
   IF fTstScrap THEN WRITELN(' icsFfScrap created for Scrap contents');
 *)
GetCsScrap(icsFfScrap);
IF icsFfScrap <> icsNil THEN
   BEGIN
     lpMac := LpMacFf(icsFfScrap);
     fScrapIsUT := TRUE;
   END
ELSE
   BEGIN
     lpMac := 0;
     fScrapIsUT := FALSE;
   END;
Replace(icsScrap, 0, lpMacEd(icsScrap), icsFfScrap, 0, lpMac);
END (* ReadScrap *);


{$S LWMisc}
{-------------------}
PROCEDURE WriteScrap;
{-------------------}
VAR ifil: TC;
    pglp: TPglp;
    cError: TC;
    hSrc: TH; hDst: TH; cbT: TC; n: TN;
    achadT: TAchad; argchT: TArgch;
    lpLimScrap: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
 (*
   ifil := IFilOpen('LISA:SCRAP.LOTUS', cbPgFf, TRUE);
   IF fTstScrap THEN WRITELN('WriteScrap -- ifil:', ifil:3);
   IF rghcs^[icsFfScrap]^^.tycs <> tycsFf THEN Break(9001);
   pglp := pglpStd;
   pglp.icsHdr := icsNil;
   pglp.icsFtr := icsNil;
   WriteIcsFf(icsScrap, pglp, tyrluDefault, ifil);
   IF fTstScrap THEN WRITELN('WriteScrap -- ifil written.');
   CleanIfil(hzScrap, ifil);
   CloseIfil(ifil);
   FreeIcs(icsFfScrap);
 *)
cError := 0; {initialize for non-figures}
lpLimScrap := LpMacEd(icsScrap);
IF FFigureAt(icsScrap, 0) AND (lpLimScrap = 1) THEN
     BEGIN
     achadT.rgch := @argchT;
     achadT.ichFst := 0; achadT.ichLim := 1;
     SetLpd(lpdStd, lpdStd^.rce^.icsFig, lpdStd^.rce^.lpFig,
            tysetStd, achadT);
     n := lpdStd^.figd.n;
     hSrc := HLockN(hzScrap, n, TRUE);
     IF hSrc <> hNil THEN
          BEGIN
          cbT := CbDataOfH(hzScrap, hSrc);
          StartPutScrap(cError);
          IF cError <= 0 THEN
               BEGIN
               hDst := HAllocate(HzOfScrap, cbT);
               IF hDst <> hNil THEN
                    BEGIN
                    MoveRgch(POINTER(ORD(hDst^)), POINTER(ORD(hSrc^)), cbT);
                    PutGrScrap(POINTER(ORD(hDst)), cError);
                    END;
               IF cError <= 0 THEN EndPutScrap(cError);
               END;
          END;
     END;
IF cError <= 0 THEN PutCsScrap(icsScrap, cError);
IF fTstScrap THEN IF cError <> 0 THEN
     BEGIN WRITELN('cError in WriteScrap = ', cError); Break(991); END;
END;


{$S LWActive}
{-----------------------}
PROCEDURE LotusGetScrap;
{-----------------------}
BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   fScrapFromLotus := FALSE; (* Lotus has not yet put anything in the Scrap
                                during this activation period *)
   ReadScrap;
END;

{-----------------------}
PROCEDURE LotusPutScrap;
{-----------------------}
VAR cError: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fScrapFromLotus THEN
   BEGIN
      EraseScrapData(cError); (* make sure nobody tries to read the Scrap
         via GetScrap; i.e., indicate that they must read LISA:SCRAP.LOTUS *)
      IF fTstScrap THEN IF cError <> 0 THEN Break(992);
      WriteScrap;
   END;
END;

{$S LWCommand}
{--------------------------------------------}
FUNCTION CPctThumbObox { (oboxPane: TC) : TC };
{--------------------------------------------}
LABEL 7;
VAR pboxPane: TPbox;
    orec, orecCon: TC;
    rec, recCon, recPrnt: TRec;
    ics, icsPg, icsBody: TB;
    lpFst,
    lpLst,
    lpMax,
    denom: TLp;
    pint, pintPrnt: TPint;
    cPct: TC;
    hcspg: THcspg;
    tyterm: TTyterm;
    fLayoutPage: TF;
    endPoint: TPt;

    PROCEDURE FindLpFromPoint (ptThumb: TPt; var lpFst: TLp);
    LABEL 55;
    BEGIN
     {$IFC sampcalls}  ALogCall;  {$ENDC}
     orec := OrecOfPt(orecCon, TRUE, ptThumb, TRUE);
     rec := POINTER(ORD(dsp) + orec);
     pint := POINTER(ORD(lldInt) + rec^.ointDep);
     ics := pint^.ics;
     lpFst := pint^.lpFst;
     IF (icsPg <> icsNil) THEN
          BEGIN
          IF (ics <> icsBody) THEN
               BEGIN
               WHILE TRUE DO
                    BEGIN
                    pint := POINTER(ORD(lldInt) + rec^.ointDep);
                    IF pint^.ics = icsPg THEN
                         BEGIN
                         lpFst := LpBodyFromLp(icsPg, pint^.lpFst);
                         GOTO 55;
                         END;
                    IF rec^.foPrnt.fObox THEN
                         BEGIN
                         lpFst := lpNil;
                         GOTO 55;
                         END;
                    rec := POINTER(ORD(dsp) + rec^.foPrnt.o);
                    END;
          55:
               ics := icsBody;
               END
          ELSE IF rec^.r.bottom <= ptThumb.v THEN
               BEGIN
               IF rec^.foPrnt.fObox THEN
                    lpFst := LpLimCon(orec)
               ELSE lpFst := lpFst + rec^.dlpLim;
               END;
          END;
     END;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
pboxPane := PboxFromObox(oboxPane);
orecCon := pboxPane^.refCon;
WHILE TRUE DO
    BEGIN
    recCon := POINTER(ORD(dsp) + orecCon);
    IF recCon^.orecSib = orecNil THEN GOTO 7;
    orecCon := recCon^.orecSib;
    END;
7:
recCon := POINTER(ORD(dsp) + orecCon);
fLayoutPage := NOT recCon^.foPrnt.fObox;
IF fLayoutPage THEN
    BEGIN
    recPrnt := POINTER(ORD(dsp)+recCon^.foPrnt.o);
    pint := POINTER(ORD(lldInt)+recPrnt^.ointDep);
    fLayoutPage := rghcs^[pint^.ics]^^.tycs = tycsPg;
    END;
tyterm := TytermUpdateRec(orecCon, iimgpScrn, fLayoutPage);

recCon := POINTER(ORD(dsp) + orecCon);
WITH endPoint, recCon^.r DO BEGIN
        v := bottom;
        h := right;
        IF fTstScrap
         THEN WRITELN('CPctThumbObox -- v: ', v:4, '; h:', h:4);
        END;
pint := POINTER(ORD(lldInt) + recCon^.ointDep);
hcspg := POINTER(ORD(rghcs^[pint^.ics]));
IF hcspg^^.cs.tycs = tycsPg THEN
     BEGIN
     icsPg := pint^.ics;
     icsBody := hcspg^^.pgd.icsBody;
     END
ELSE icsPg := icsNil;

FindLpFromPoint (ptThumb, lpFst);
IF lpFst = lpNil THEN cPct := cPctNil
ELSE IF rghcs^[ics]^^.tycs <> tycsEd THEN cPct := cPctNil
ELSE IF lpFst = 0 THEN cPct := 0
ELSE BEGIN
        lpMax := LpMacEd(ics);
        FindLpFromPoint (endPoint, lpLst);
        IF (lpLst = lpNil) OR (lpLst >= lpMax) THEN cPct := 100
        ELSE BEGIN
                denom := (lpMax - lpLst + lpFst);
                cPct := 1 + ((98 * lpFst + denom DIV 2) DIV denom);
                {insure non-zero, proportional percentage}
        END;
     END;
IF fTstScrap THEN WRITELN('CPctThumbObox -- lpFst: ', lpFst:1,
                                '; lpLst: ', lpLst:1,
                                '; lpMax: ', lpMax:1,
                                '; pct:', cPct:4);
CPctThumbObox := cPct;
END;


{$S LWPreview}
{-------------------------------------------------}
FUNCTION LpPgOfLpEd{(icsPg: TB; icsEd: TB; lpPctEd: TLp) : TLp};
{-------------------------------------------------}
LABEL 99;
VAR ipg: TC;
    pint: TPint;
    lpOrLppg: TLpOrLppg;
    hcspg: THcspg;
    lpFstIpgPrv: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstScrap THEN WRITELN('LpPgOfLpEd(', icsPg, ', ', lpPctEd, ')');
FindIpgLst(icsPg);
ipg := 0;
hcspg := POINTER(ORD(rghcs^[icsPg]));
lpOrLppg.lp := 0; lpFstIpgPrv := 0;
IF icsEd = hcspg^^.pgd.icsBody THEN
     BEGIN
     lpOrLppg.lppg.ptpg := ptpgBody;
     WHILE TRUE DO
          BEGIN
          IF ipg >= hcspg^^.pgd.ipgLst THEN IncIpgLst(icsPg {, tyxyScrn});
          pint := POINTER(ORD(lldInt) + hcspg^^.pgd.argbody[ipg].oint);
          IF fTstScrap THEN
                WITH pint^ DO WRITELN('ipg:', ipg:3, '; [lpFst; lpLim] = [',
                                        lpFst, '; ', lpLim, ']');
          { Since we are looking at an ointDep we must use
            lpFst of following page as lpLimPg}
          IF (pint^.lpFst > lpPctEd) THEN
                BEGIN
                lpOrLppg.lppg.ich := lpPctEd - lpFstIpgPrv;
                GOTO 99;
                END;
          lpOrLppg.lppg.ipg := ipg;
          IF hcspg^^.pgd.argbody[ipg].fEos THEN
                BEGIN
                lpOrLppg.lppg.ich := LpMinP(pint^.lpLim, lpPctEd) - pint^.lpFst;
                GOTO 99;
                END;
          lpFstIpgPrv := pint^.lpFst;
          ipg := ipg + 1;
          END;
99:
     END
ELSE BEGIN
     pint := POINTER(ORD(lldInt) + hcspg^^.pgd.ointHdr);
     IF icsEd = pint^.ics THEN
          lpOrLppg.lppg.ptpg := ptpgHdr
     ELSE BEGIN
          pint := POINTER(ORD(lldInt) + hcspg^^.pgd.ointFtr);
          IF icsEd = pint^.ics THEN
               lpOrLppg.lppg.ptpg := ptpgFtr
          ELSE lpOrLppg.lp := lpNil;
          END;
     END;
LpPgOfLpEd := lpOrLppg.lp;
IF fTstScrap THEN WRITELN(' : ', lpOrLppg.lp);
END;


{$S LWInsert}
{-----------------------------------------------}
PROCEDURE SetRFstOfOint { (oint: TC; oboxPane: TC;
                           VAR orec: TC; VAR r: TR; VAR orecCon: TC)};
{ return one-wide box of beginning of sel in screen coordinates (tyxyScrn) }
{ this routine is very similar to DxSel - they should be coalesced someday }
{-----------------------------------------------}
VAR rec: TRec; pintT: TPint;
    xOrYDummy: TCd;
    int: TInt;
    orecScroll, orecT: TC;
    tyterm: TTyterm;
    recScroll: TRec;
    tyxyCon: TTyxy;

    PROCEDURE LayoutParOfLp;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    orecScroll := Orec1Alloc(int.ics, int.lpFst, int.lpFst + 1, ptZero,
                        ptZero, tyxyCon, fixedLpLim, FALSE, foNil);
    tyterm := TytermUpdateRec(orecScroll, iimgpScrn, FALSE);
    recScroll := POINTER(ORD(dsp)+orecScroll);
    orecT := OrecOfLp(recScroll^.orecSon, int.ics, int.lpFst, TRUE);
    END;

BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
{$ifc fDbgOk}
IF fTstScrap THEN
     BEGIN
     WRITELN('SetRFstOfOint(', oint, ', ', oboxPane, ')');
     PxInt(oint); PxObox(oboxPane);
     END;
{$endc}
SetRect(r, 0, 0, 1, 12);
pintT := POINTER(ORD(lldInt) + oint); int := pintT^;
orecCon := OrecConOfOboxIcsLp(oboxPane, int.ics, int.lpFst);
IF fTstScrap THEN WRITELN('orecCon:', orecCon:4);
IF orecCon = orecNil THEN
     BEGIN
     orec := orecNil;
     END
ELSE BEGIN
     rec := POINTER(ORD(dsp) + orecCon);
     tyxyCon := rec^.tyxy;
     orec := OrecOfLp(rec^.orecSon, int.ics, int.lpFst, FALSE);
     IF fTstScrap THEN WRITELN('orec:', orec:4);
     IF orec = orecNil THEN
          LayoutParOfLp
     ELSE BEGIN
          rec := POINTER(ORD(dsp) + orec);
          IF rec^.r.top < 0 THEN
               BEGIN
               LayoutParOfLp;
               orec := orecNil;
               END
          ELSE BEGIN
               orecScroll := orecNil;
               orecT := orec;
               END;
          END;
     IF orecT <> orecNil THEN
          BEGIN
          GenOrec(orecT, iimgpScrn);

          rec := POINTER(ORD(dsp) + orecT);
          r := rec^.r;
          ConvertRTyxy(r, r, rec^.tyxy, tyxyScrn); {now top and bottom are OK}
          r.left := HOfLp(int.lpFst, crdStd);
          r.right := r.left + 1;
          END;
     IF orecScroll <> orecNil THEN orecScroll := OrecSibFree(orecScroll);
     END;
{$ifc fDbgOk}
IF fTstScrap THEN
     BEGIN
     PxR('SetRFstOfOint -- ', r);
     WRITELN('orec:', orec);
     END;
{$endc}
END;


{$S LWInsert}
{-----------------------------------------------}
PROCEDURE IntInWindow { (oint: TC; orecCon: TC) };
{-----------------------------------------------}
CONST
    vTopShowSel = 48; { Place the selection approx .5 inch from top of window }
    dhLftTweek = 8;   {Arbitrary tweek to push selection away from left side of
                      folder}
    dhRightTweek = 16;{Arbitrary tweek to push selection away from right side of
                      folder}
VAR rec, recCon: TRec;
    oboxHeadPane, oboxPane: TC;
    pboxPane: TPbox;
    cPct: -1..100;
    scid: TScid;
    lpLimT: TLp;
    dlpLimT: TLp;
    dptScroll: TPt;
    r: TR;
    rBBox: TR;
    hrgnShowing: THrgn;
    hrgnOfRFst: THrgn;
    ics: TB;
    lpToWindow: TLp;
    pint, pintCon, pintPrnt: TPint;
    recPrnt: TRec;
    orec: TC;
    tyxyCon: TTyxy;
    dhScrollRecs: TC;
    rRec: TR;
    tyterm: TTyterm;
    fOrecConOk: TF;
    orecConT: TC;
    icsCon: TB;
    argo: ARRAY [0..10] OF TC;

{$S LWScroll}
    PROCEDURE SetOrScroll(fScroll: TF);
    VAR orecCon1: TC;
        orecSib: TC;
        vTopCon: TC;
        lpFstCon: TLp;
        tyvh: TTyvh;
        obox1Pane: TC;
    BEGIN
    {$IFC sampcalls}  ALogCall;  {$ENDC}
    IF NOT fScroll THEN
         BEGIN
         recCon := POINTER(ORD(dsp) + orecCon);
         IF NOT recCon^.foPrnt.fObox THEN
              BEGIN
              pintCon := POINTER(ORD(lldInt) + recCon^.ointDep);
              recPrnt := POINTER(ORD(dsp) + recCon^.foPrnt.o);
              pintPrnt := POINTER(ORD(lldInt) + recPrnt^.ointDep);
              IF rghcs^[pintPrnt^.ics]^^.tycs <> tycsPg THEN
                   EXIT(SetOrScroll);
              lpFstCon := LpPgOfLpEd(pintPrnt^.ics, ics, lpToWindow);
              END
         ELSE lpFstCon := lpToWindow;
         tyvh := tyvhV;
         END
    ELSE IF dptScroll.v <> 0 THEN tyvh := tyvhV
    ELSE tyvh := tyvhH;

         { Loop through oboxes, setting lpFst or scrolling. }
    IF fTstScrap THEN
          WRITELN('dptScroll: (', dptScroll.h, ', ', dptScroll.v, '), tyvh: ', ORD(tyvh));
    scid := ScidFromObox(OboxOfOrec(orecCon), tyvh);
    oboxHeadPane := OboxFstOnSc(scid);
    obox1Pane := oboxHeadPane;
    WHILE obox1Pane <> oboxNil DO
          BEGIN
          {$ifc fDbgOk}
          IF fTstScrap THEN PxObox(obox1Pane);
          {$endc}
          IF fScroll THEN
                 BEGIN
                 IF fTstScrap THEN WRITELN('obox1Pane: ', obox1Pane:4);
                 ScrollOrec(obox1Pane, dptScroll, FALSE);
                 END
          ELSE BEGIN
                 IF fTstScrap THEN
                       WRITELN('Setting thumb of obox1Pane',
                       obox1Pane:4);
                 pboxPane := POINTER(ORD(bdsp) + obox1Pane);
                 orecCon1 := pboxPane^.refCon;
                 { normalize the doc orecCon }
                 WHILE orecCon1 <> orecNil DO
                      BEGIN
                      recCon := POINTER(ORD(dsp) + orecCon1);
                      orecSib := recCon^.orecSib;
                      IF orecSib = orecNil  THEN
                           BEGIN
                           pintCon := POINTER(ORD(lldInt) + recCon^.ointDep);
                           pintCon^.lpFst := lpFstCon;
                           obox1Pane := OboxVisOrec(orecCon1);
                           CopyRgn(thePort^.clipRgn, hrgnShowing);
                           SectRgn(thePort^.visRgn, hrgnShowing, hrgnShowing);

                           OffsetRect(r, 0, vTopShowSel - r.Top);
                           RectRgn(hrgnOfRFst, r);
                           SectRgn(hrgnShowing, hrgnOfRFst, hrgnOfRFst);
                           IF NOT FEqRs(r, hrgnOfRFst^^.rgnBBox) THEN
                                vTopCon := hrgnShowing^^.rgnBBox.top
                           ELSE vTopCon := vTopShowSel;
                           recCon := POINTER(ORD(dsp) + orecCon1);
                           recCon^.r.top := vTopCon;
                           NormalizeOrecCon(orecCon1);
                           InvalidOrec(orecCon1);
                           recCon := POINTER(ORD(dsp) + orecCon1);
                           pintCon := POINTER(ORD(lldInt) + recCon^.ointDep);
                           vTopCon := recCon^.r.top;
                           lpFstCon := pintCon^.lpFst;
                           END;
                      orecCon1 := orecSib;
                      END;
                 pboxPane := POINTER(ORD(bdsp) + obox1Pane);
                 orecCon1 := pboxPane^.refCon;
                 { now fix page ruler if necessary }
                 WHILE orecCon1 <> orecNil DO
                      BEGIN
                      recCon := POINTER(ORD(dsp) + orecCon1);
                      orecSib := recCon^.orecSib;
                      IF recCon^.strec.fScrollV AND (orecSib <> orecNil) THEN
                           BEGIN
                           pintCon := POINTER(ORD(lldInt) + recCon^.ointDep);
                           pintCon^.lpFst := lpFstCon;
                           recCon^.r.top := vTopCon;
                           END;
                      orecCon1 := orecSib;
                      END;
                 END;
          obox1Pane := OboxNxtOnSc(obox1Pane, tyvh);
          END;
    cPct := CPctThumbObox(oboxHeadPane);
    IF cPct <> cPctNil THEN SetLThumb(scid, cPct);
    ValidateDsp;
    END;{SetOrScroll}

{$S LWInsert}
BEGIN{IntInWindow}
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstScrap THEN WRITELN('IntInWindow');
IF (oint <> ointNil) AND (orecCon <> orecNil) THEN
     BEGIN
     {$ifc fDbgOk}
     IF fTstScrap THEN
          BEGIN
          PxInt(oint);
          PxOrec(orecCon);
          END;
    {$endc}
    pint := POINTER(ORD(lldInt) + oint);
    lpToWindow := pint^.lpFst;
    ics := pint^.ics;
    recCon := POINTER(ORD(dsp) + orecCon);
    pint := POINTER(ORD(lldInt) + recCon^.ointDep);
    fOrecConOk := FALSE;
    icsCon := pint^.ics;
    IF (icsCon = ics) AND
       ((pint^.lpFst <= lpToWindow) AND (pint^.lpLim > lpToWindow)) THEN
          IF LpLimCon(orecCon) > lpToWindow THEN
               fOrecConOk := TRUE;
    IF NOT fOrecConOk THEN
         BEGIN
         orecConT := OrecConOfOboxIcsLp(oboxNil, ics, lpToWindow);
         IF orecConT = orecNil THEN
              BEGIN
              IF icsCon <> ics THEN
                   BEGIN
                   orecConT := OrecConFromIcs(ics);
                   IF orecConT = orecNil THEN
                        BEGIN
                        { Last chance - maybe ics is in header or footer and
                          no where to be found on the screen }
                        IF rghcs^[icsCon]^^.tycs = tycsPg THEN
                             BEGIN
                             lpToWindow := LpPgOfLpEd(icsCon, ics, lpToWindow);
                             IF lpToWindow = lpNil THEN
                                  EXIT(IntInWindow)
                             ELSE ics := icsCon;
                             END
                        ELSE EXIT(IntInWindow);
                        END
                   ELSE orecCon := orecConT;
                   END;
              END
         ELSE orecCon := orecConT;
         END;
    recCon := POINTER(ORD(dsp) + orecCon);
    tyterm := recCon^.tyterm;
    IF recCon^.strec.fRecCon THEN
          BEGIN
          tyxyCon := recCon^.tyxy;
          SetRgoFromOrec(orecCon, @argo, 2);
          oboxPane := OboxVisOrec(argo[1]);
          hrgnShowing := NewRgn;
          CopyRgn(thePort^.clipRgn, hrgnShowing);
          SectRgn(thePort^.visRgn, hrgnShowing, hrgnShowing);
          rBBox := hrgnShowing^^.rgnBBox;
          SetRFstOfOint(oint, oboxPane, orec, r, orecConT);
          hrgnOfRFst := NewRgn;
          dptScroll.h := 0; dptScroll.v := 0;
          IF orec = orecNil THEN
               BEGIN
               IF (lpToWindow = LpLimCon(orecCon))
                 AND (tyterm = tytermOutOfWw) THEN
                    BEGIN
                    GenCrd(crdStd, ics, lpToWindow, tyxyCon);
                    dptScroll := crdStd^.arec.r.botRight;
                    SubPt(crdStd^.arec.r.topLeft, dptScroll);
                    dptScroll.h := 0; dptScroll.v := -dptScroll.v;
                    ConvertTyxy(dptScroll.h, dptScroll.v, tyxyCon, tyxyScrn);
                    SetOrScroll(TRUE);
                    END
               ELSE SetOrScroll(FALSE);
               END
          ELSE BEGIN
               IF r.bottom > rBBox.bottom THEN
                    BEGIN
                    dptScroll.v := rBBox.bottom - r.bottom;
                    IF ((rBBox.top - r.top) <= dptScroll.v) THEN
                         SetOrScroll(TRUE);
                    END
               ELSE IF r.top < rBBox.top THEN
                    BEGIN
                    dptScroll.v := rBBox.top - r.top;
                    SetOrScroll(TRUE);
                    END;
               END;
          dptScroll.v := 0;
          SetRFstOfOint(oint, oboxPane, orec, r, orecCon);
          IF orec <> orecNil THEN
               BEGIN
               dptScroll.h := (rBBox.left - r.left) + dhLftTweek;
               rec := POINTER(ORD(dsp) + orec);
               rRec := rec^.r; ConvertRTyxy(rRec, rRec, rec^.tyxy, tyxyScrn);
               IF (r.left >= rBBox.right) THEN
                    BEGIN
                    dhScrollRec := (rBBox.right - (dhLftTweek + rRec.right));
                    dptScroll.h := CMax(dhScrollRec, dptScroll.h);
                    SetOrScroll(TRUE);
                    SetRFstOfOint(oint, oboxPane, orec, r, orecCon);
                    END
               ELSE IF (r.left < rBBox.left) THEN
                    BEGIN
                    dhScrollRec := (rBBox.left - (rRec.left - dhLftTweek));
                    IF (r.right + dhRightTweek + dhScrollRec) < rBBox.right THEN
                         dptScroll.h := dhScrollRec;
                    SetOrScroll(TRUE);
                    SetRFstOfOint(oint, oboxPane, orec, r, orecCon);
                    END;

               RectRgn(hrgnOfRFst, r);
               SectRgn(hrgnShowing, hrgnOfRFst, hrgnOfRFst);
               IF NOT FEqRs(r, hrgnOfRFst^^.rgnBBox) THEN
                    SetOrScroll(FALSE);
               END;
          DisposeRgn(hrgnOfRFst);
          DisposeRgn(hrgnShowing);
          END;
     END;
END;


{$S LWCutPas}
{-------------------------------}
FUNCTION OintCut(ointWd: TC): TC;
{-------------------------------}
LABEL 200;
VAR ics: TB;
    pintWd: TPint;
    lpFstWd, lpLimWd: TLp;
    achad: TAchad;
    tyset: TTyset;
    lp: TLp;
    wd: TC;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
 { Find out which rec we're in. }
IF fTstScrap THEN WRITELN('OintCut -- oint:', ointWd:4);
pintWd := POINTER(ORD(lldInt) + ointWd);
ics := pintWd^.ics;
lpFstWd := pintWd^.lpFst;
lpLimWd := pintWd^.lpLim;
tyset.fRce := FALSE; tyset.fRpe := FALSE; tyset.fParBnds := FALSE;
achad.rgch := @wd;
 { Find the previous char. }
lp := lpFstWd - 1;
WHILE lp >= 0 DO
    BEGIN
    achad.ichFst := 0; achad.ichLim := 1;
    SetLpd(lpdStd, ics, lp, tyset, achad);
    { Did it skip a vanished run? }
    IF lpdStd^.lp = lp THEN
       IF achad.rgch^[0] = chSp THEN
          BEGIN
          lpFstWd := lp;
          GOTO 200;   { Win! }
          END
       ELSE lp := 0;  { exit }
    lp := lp - 1;
    END;
 { Find the next char. }
achad.ichFst := 0; achad.ichLim := 1;
SetLpd(lpdStd, ics, lpLimWd, tyset, achad);
IF (achad.ichLim <> achad.ichFst) AND (achad.rgch^[0] = chSp) THEN
    BEGIN
    { Might have skipped a vanished run: can't do lpLimWd + 1. }
    lpLimWd := lpdStd^.lp + 1;
    END;
200:
OintCut := OintMark(ointNil, ics, lpFstWd, lpLimWd, TRUE, ointNil);
END;

{$S LWStyle}
{--------------------------------}
FUNCTION FSelWord (sel: TSel): TF;
{--------------------------------}
CONST
   fBackward=TRUE;  fForward=FALSE;
   ichPrv2=0;  ichPrv=1;  ichFst=2;  ichSec=3;
   ichLst2=0;  ichLst=1;  ichLim=2;  ichLim2=3;
VAR
   lpPrv2Ch,lpPrvCh,lpFstCh,lpSecCh: TLp;
   lpLst2Ch,lpLstCh,lpLimCh,lpLim2Ch: TLp;
   lpFstSel,lpLimSel: TLp;
   oint: TC;  pint:TPint;
   ics: TC;
   achad: TAchad;
   argch: ARRAY[ichPrv2..ichSec] OF TCh;
   ich: TC;
BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   FSelWord := FALSE;

   oint := sel.oint;
   pint := POINTER(ORD(lldInt) + oint);
   ics := pint^.ics;
   lpFstSel := pint^.lpFst;
   lpLimSel := pint^.lpLim;

   achad.rgch := @argch;
   FOR ich:=ichLst TO ichLim2 DO argch[ich] := ORD(' ');

   {Get the last character in the selection and its two neighbors}
   achad.ichFst := ichLim;  achad.ichLim := achad.ichFst+1;
   lpLimCh  := LpVisAdjacent(ics, pint^.lpLim-1, fForward, achad);

   achad.ichFst := ichLst;  achad.ichLim := achad.ichFst+1;
   lpLstCh  := LpVisAdjacent(ics, pint^.lpLim, fBackward, achad);

   achad.ichFst := ichLst2;  achad.ichLim := achad.ichFst+1;
   lpLst2Ch  := LpVisAdjacent(ics, lpLstCh, fBackward, achad);

   achad.ichFst := ichLst2;  achad.ichLim := ichLim+1;
   IF NOT FQualifies(@achad, ichLst) THEN EXIT(FSelWord); {failure}

   achad.ichFst := ichLim2;  achad.ichLim := achad.ichFst+1;
   lpLim2Ch  := LpVisAdjacent(ics, lpLimCh, fForward, achad);

   achad.ichFst := ichLst;  achad.ichLim := ichLim2+1;
   IF FQualifies(@achad, ichLim) THEN EXIT(FSelWord); {failure}

   FOR ich:=ichPrv2 TO ichSec DO argch[ich] := ORD(' ');

   {Get the FIRST character in the selection and its two neighbors}
   achad.ichFst := ichFst;  achad.ichLim := achad.ichFst+1;
   lpFstCh  := LpVisAdjacent(ics, pint^.lpFst-1, fForward, achad);

   achad.ichFst := ichSec;  achad.ichLim := achad.ichFst+1;
   lpSecCh  := LpVisAdjacent(ics, lpFstCh, fForward, achad);

   achad.ichFst := ichPrv;  achad.ichLim := achad.ichFst+1;
   lpPrvCh  := LpVisAdjacent(ics, pint^.lpFst, fBackward, achad);

   achad.ichFst := ichPrv;  achad.ichLim := ichSec+1;
   IF NOT FQualifies(@achad, ichFst) THEN EXIT(FSelWord); {failure}

   achad.ichFst := ichPrv2;  achad.ichLim := achad.ichFst+1;
   lpPrv2Ch  := LpVisAdjacent(ics, lpPrvCh, fBackward, achad);

   achad.ichFst := ichPrv2;  achad.ichLim := ichFst+1;
   IF FQualifies(@achad, ichPrv) THEN EXIT(FSelWord); {failure}

   FSelWord := TRUE;
END;  {FSelWord}



{------------------------------}
PROCEDURE CutCopy { (fCut: TF) };
{------------------------------}
VAR pint: TPint;
    lpFstSel, lpLimSel, lpLimT, lpLimScrap: TLp;
    icsSel: TB;
    oint: TC;
    hop: THop;
    portT: TPort;
    rScrap: TR;
    fSelWd: TF;
    hcsedScrap: THcsEd;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF selCur.oint <> ointNil THEN
    BEGIN
    {$ifc fDbgOk}
    IF fTstScrap THEN
          BEGIN
          WRITE('selCur.oint:'); PxInt(selCur.oint);
          WRITELN('lpMacEd(icsScrap):',lpMacEd(icsScrap));
          END;
    {$endc}
    fSelWd := FSelWord(selCur);
    IF fSelWd THEN oint := OintCut(selCur.oint)
              ELSE oint := selCur.oint;
    pint := POINTER(ORD(lldInt) + oint);
    icsSel := pint^.ics;
    lpFstSel := pint^.lpFst;
    lpLimSel := pint^.lpLim;
    IF fSelWd THEN FreeInt(icsSel, oint);  {done with int created by OintCut}
    IF lpFstSel <> lpLimSel THEN
          BEGIN
          InheritScrap(TRUE);

          { erase any previous contents -- this code lifted from DrawUScrap. }
          GetPort(portT);
          SetPort(ScrapFolder);
          rScrap := ScrapFolder^.portRect;
          WITH rScrap DO
             BEGIN
             right := (right - dhScroll) + 1;
             bottom := (bottom - dvScroll) + 1;
             END;
          ClipRect(rScrap);
          EraseRect(rScrap); { erase the whole folder, less scroll bars }
          SetPort(portT);

          RecScrapToOboxScrap(TRUE) (* make oboxScrap's refCon refer to it *);
          lpLimScrap := lpMacEd(icsScrap);
          Replace(icsUndo, 0, LpMacEd(icsUndo), icsScrap, 0, lpLimScrap);

          { Selection contents to scrap. }
          Replace(icsScrap, 0, lpLimScrap, icsSel, lpFstSel, lpLimSel);

          (* mark that the Scrap now has Lotus contents *)
          fScrapFromLotus := TRUE;
          fScrapIsUT := FALSE;
          { In historical terms: scrap REPLACES undo buffer. }
          IF fScrapWord THEN hop:=hopRplWord ELSE hop:=hopReplace;
          Chronicle(icsScrap, 0, lpNil, icsUndo, 0, lpNil, hop);

          IF fCut THEN
               BEGIN
                { Select to just before deleted portion. }
               ShowSel(selCur, tyshowOff);
                { Selection does not include adjacent space }
               pint := POINTER(ORD(lldInt) + selCur.oint);
               Chronicle(icsSel, lpFstSel, lpFstSel,
                       icsSel, pint^.lpFst, pint^.lpLim, hopSelect);
                { Delete old selection. }
               Replace(icsSel, lpFstSel, lpLimSel, icsNil, 0, 0);
               IF fSelWd THEN hop := hopMovWord ELSE hop := hopMove;
               LSetSel(icsSel, lpFstSel, lpFstSel);
               END
          ELSE IF fSelWd THEN hop := hopRplWord ELSE hop := hopReplace;

          fScrapWord := fSelWd;
          { Historical terms: selection REPLACES (Copy) or MOVES TO (Cut) scrap. }
          Chronicle(icsSel, lpFstSel, lpLimSel, icsScrap, 0, lpNil, hop);
          END;
    {$ifc fDbgOk}
    IF fTstScrap THEN PxCs(icsScrap);
    {$endc}
    END;
END;

{$S LWCutPas}
{-----------------------------------------------------}
PROCEDURE IgnoreSpaces (ics: TB; VAR lpFst,lpLim: TLp);
{-----------------------------------------------------}
VAR
  tyset: TTyset;
  achad: TAchad;
  lpLimStrip: TLp;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
WITH tyset DO BEGIN fRce := TRUE; fRpe := FALSE; fParBnds := FALSE; END;
achad.rgch := NIL;
SetLpd(lpdStd, ics, lpFst, tyset, achad);
IF (NOT lpdStd^.rce^.fVan) AND (lpdStd^.lpLim <> lpdStd^.lp) THEN
    IF achad.rgch^[achad.ichFst] = ORD(' ') THEN
        BEGIN
        achad.rgch := NIL;
        lpFst := LpVisAdjacent(ics, lpFst, FALSE {following ch}, achad);
        EXIT(IgnoreSpaces);
        END;
achad.rgch := NIL;
lpLimStrip := lpVisAdjacent(ics, lpLim, TRUE {preceeding ch}, achad);
IF lpLimStrip >= 0 THEN
    IF achad.rgch^[achad.ichFst] = ORD(' ') THEN lpLim := lpLimStrip;
END;  {IgnoreSpaces}

{-----------------------------------------------------}
PROCEDURE InsertSpaces (ics: TB; VAR lpFst,lpLim: TLp);
{-----------------------------------------------------}
CONST
   fBackward=TRUE;  fForward=FALSE;
   ichPrv2=0;  ichPrv=1;  ichLim=2;  ichLim2=3;
VAR
   lpPrv2Ch,lpPrvCh,lpLimCh,lpLim2Ch: TLp;
   achad: TAchad;
   argch: ARRAY[ichPrv2..ichLim2] OF TCh;
   ich: TC;
   fSpaceBeforeWord, fSpaceAfterWord: TF;
BEGIN
   {$IFC sampcalls}  ALogCall;  {$ENDC}
   achad.rgch := @argch;
   {Characters that don't exist act as blanks}
   FOR ich:=ichPrv2 TO ichLim2 DO argch[ich] := ORD(' ');

   {Get the first two character BEYOND the selection}
   achad.ichFst := ichLim;  achad.ichLim := achad.ichFst+1;
   lpLimCh  := LpVisAdjacent(ics, lpLim-1, fForward, achad);
   fSpaceAfterWord := argch [ichLim] = ord (' ');

   achad.ichFst := ichLim2;  achad.ichLim := achad.ichFst+1;
   lpLim2Ch := LpVisAdjacent(ics, lpLimCh, fForward, achad);

   {Get the first two character BEFORE the selection}
   achad.ichFst := ichPrv;  achad.ichLim := achad.ichFst+1;
   lpPrvCh  := LpVisAdjacent(ics, lpFst, fBackward, achad);
   fSpaceBeforeWord := argch [ichPrv] = ord (' ');

   achad.ichFst := ichPrv2;  achad.ichLim := achad.ichFst+1;
   lpPrv2Ch := LpVisAdjacent(ics, lpPrvCh, fBackward, achad);

   achad.ichFst := ichPrv2;  achad.ichLim := ichLim+1;
   IF FQualifies(@achad, ichPrv) OR (fSpaceAfterWord AND NOT fSpaceBeforeWord)
    THEN BEGIN
      {insert a preceeding space}
      Replace(ics, lpFst, lpFst, icsSpace, 0, 1);
      { In historical terms: space INSERTED at lpFst of selection. }
      Chronicle(icsSpace, 0, 1, ics, lpFst, lpFst+1, hopInsert);
      lpLim := lpLim+1;
      lpFst := lpFst+1;
      END;

   achad.ichFst := ichPrv;  achad.ichLim := ichLim2+1;
   IF FQualifies(@achad, ichLim) OR (fSpaceBeforeWord AND NOT fSpaceAfterWord)
    THEN BEGIN
      {insert a trailing space}
      Replace(ics, lpLim, lpLim, icsSpace, 0, 1);
      { In historical terms: space INSERTED at lpLim of selection. }
      Chronicle(icsSpace, 0, 1, ics, lpLim, lpLim+1, hopInsert);
      lpLim := lpLim+1;
      END;
END;  {InsertSpaces}

{--------------------------------------------------}
PROCEDURE PasteFrom { (icsSrc, lpFstSrc, lpLimSrc) };
{--------------------------------------------------}
VAR pint: TPint;
    lpFstSel, lpLimSel, lpLstVis: TLp;
    icsSel: TB;
    oint: TC;
    achadT: TAchad; argchT: TArgch;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF selCur.oint <> ointNil THEN
    BEGIN
    pint := POINTER(ORD(lldInt) + selCur.oint);
    icsSel := pint^.ics;
    lpFstSel := pint^.lpFst;
    lpLimSel := pint^.lpLim;
    IF FFigureAt(icsSrc, lpFstSrc) THEN
         BEGIN
         IF NOT FParStart(icsSel, lpFstSel) THEN
              InsChKid(chCr);
         END;
    IF FFigureAt(icsSel, lpLimSel) THEN
         BEGIN
         lpLstVis := LpPrvVis(icsSrc, lpLimSrc);
         IF lpLstVis >= 0 THEN
              BEGIN
              achadT.rgch := @argchT; achadT.ichFst := 0; achadT.ichLim := 1;
              SetLpd(lpdStd, icsSrc, lpLstVis, tysetStd, achadT);
              IF argchT[0] <> chCr THEN
                   BEGIN
                   Ins1ChKid(chCr, TRUE);
                   LSetSel(icsSel, lpFstSel, lpFstSel);
                   END;
              END;
         END;
    RemoveKid(TRUE);
    {$ifc fDbgOk}
    IF fTstScrap THEN
          BEGIN
          WRITE('selCur.oint:'); PxInt(selCur.oint);
          WRITELN('lpLimSrc:',lpLimSrc);
          END;
    {$endc}
    oint := selCur.oint;
    pint := POINTER(ORD(lldInt) + oint);
    icsSel := pint^.ics;
    lpFstSel := pint^.lpFst;
    lpLimSel := pint^.lpLim;

    { If scrap contents is a word, skip a leading or trailing space }
    IF (icsSrc = icsScrap) AND (fScrapWord) THEN
        IgnoreSpaces(icsScrap, lpFstSrc, lpLimSrc);

    { Reset selection and chronicle old selection. }
    LSetSel(icsNil, 0, 0);
    Chronicle(icsNil, 0, 0, icsSel, lpFstSel, lpLimSel, hopSelect);

    { Selection goes to undo buffer; save selection contents. }
    IF lpFstSel < lpLimSel THEN
         BEGIN
         Replace(icsUndo, 0, LpMacEd(icsUndo), icsSel, lpFstSel, lpLimSel);
         { In historical terms: selection MOVED to undo buffer. }
         Chronicle(icsSel, lpFstSel, lpLimSel,
                   icsUndo, 0, LpMacEd(icsUndo), hopMove);
         END;

    { Source replaces selection. }
    Replace(icsSel, lpFstSel, lpLimSel, icsSrc, lpFstSrc, lpLimSrc);
    lpLimSel := lpFstSel + (lpLimSrc-lpFstSrc);
    { In historical terms: source INSERTED at lpFst of selection. }
    Chronicle(icsSrc, lpFstSrc, lpLimSrc, icsSel, lpFstSel, lpLimSel, hopInsert);

    { Insert leading and trailing spaces if appropriate }
    IF (icsSrc = icsScrap) AND fScrapWord THEN
        InsertSpaces (icsSel, lpFstSel, lpLimSel);

    LSetSel(icsSel, lpLimSel, lpLimSel);
    Chronicle(icsSel, lpLimSel, lpLimSel, icsNil, 0, 0, hopSelect);
    END;
END;

{--------------}
PROCEDURE Paste;
{--------------}
VAR cError: TC;
    icsLUTFf, icsFig: TB;
    ifilLUT, ifilFig: TC;
    hcsedScrap: THcsed;
    ffleader: TFfleader;
    pathLUT, pathFig: Pathname;
    pint:   TPint;
    lpFig: TC;
    hpicSrc: PicHandle;
    intSel: TInt;
    cT: TC; xRt: TX; yDummy: TY;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF selCur.oint <> ointNil THEN
   BEGIN
   IF LpMacEd(icsScrap) = 0 THEN
        BEGIN
        IF CurrScrapSet = [] THEN StopAlert(WPAlerts, 18) (* nothing to paste *)
        ELSE BEGIN
             IF ScrapUg IN CurrScrapSet THEN
                  BEGIN
                  StartGetScrap(cError);
                  IF cError <= 0 THEN
                       BEGIN
                       GetGrScrap(hpicSrc);
                       lpFig := LpFigAdd(icsFigScrap, hpicSrc);
                       CleanIfil(cError, hzScrap, IfilOfFig(icsFigScrap), FALSE);
                       IF cError > 0 THEN
                            StopAlert(WPAlerts, 23)
                       ELSE BEGIN
                            pint := POINTER(ORD(lldInt) + selCur.oint);
                            intSel := pint^;
                            WITH intSel DO
                              BEGIN
                              IF NOT (FParStart(ics, lpFst)
                                      AND FParStart(ics, lpLim)) THEN
                                 BEGIN
                                 Ins1ChKid(chCr, FALSE);
                                 lpFst := lpFst + 1;
                                 END;
                              Ins1ChKid(chCr, FALSE);
                              RemoveKid(FALSE);
                              { cT is necessary to coerce the byte to a word
                                before you pass its address - ugh }
                              cT := icsFigScrap;
                              ApplyFopEd(ics, lpFst, lpFst + 1,
                                         ifldIcsFig, 0, @cT);
                              ApplyFopEd(ics, lpFst, lpFst + 1,
                                         ifldLpFig, 0, @lpFig);
                              { More crazy clipping }
                              GenCrd(crdStd, ics, lpFst, tyxyCs);
                              xRt := mpichdx^[0];
                              ConvertTyxy(xRt, yDummy, crdStd^.tyxy, tyxyCs);
                              xRt := xRt + crdStd^.arec.r.left;
                              ApplyFopEd(ics, lpFst, lpFst + 1,
                                         ifldXRt, 0, @xRt);
                              LSetSel(ics, lpFst + 1, lpFst + 1);
                              END;
                            END;
                       END;
                  EndGetScrap(cError);
                  END
             ELSE StopAlert(WPAlerts, 19); (* non-Lotus Scrap contents *)
             END;
        END
   ELSE BEGIN
        IF fScrapIsUT THEN
           BEGIN (* make a copy of the UT Scrap for Lotus' reference;
                    we assume that icsScrap has been REPLACEd by the UT Scrap *)
           pathLUT := '{T1}LOTUS.UT';
           pathFig := '{T1}LOTUS.FIGURES';
           KILL_OBJECT(cError, pathLUT);
           KILL_OBJECT(cError, pathFig);
           ifilLUT := IFilOpen(cError, pathLUT, cbPgFf,
                               [dRead, dWrite, Append], hzScrap,'');
           IF cError <= 0 THEN
                icsFig := IcsFigCreate(cError, pathFig,
                               [dRead, dWrite, Append], hzScrap,'');
           IF cError <= 0 THEN
                BEGIN
                ifilFig := IfilOfFig(icsFig);
                hcsedScrap := POINTER(ORD(rghcs^[icsScrap]));
                WriteIcsFf(icsScrap, hcsedScrap^^.pglp, tyrluDefault,
                           ifilLUT, ifilFig, hzScrap);
                CleanIfil(cError, hzScrap, ifilLUT, FALSE);
                IF cError <= 0 THEN
                     CleanIfil(cError, hzScrap, ifilFig, FALSE);
                END;
           IF cError > 0 THEN
                BEGIN
                StopAlert(WPAlerts, 23);
                Replace(icsScrap, 0, LpMacEd(icsScrap), icsNil, 0, 0);
                fScrapIsUT := FALSE;
                EXIT(Paste);
                END
           ELSE BEGIN
                icsLUTFf := IcsFfCreate(ifilLUT, icsFig, hzScrap, ffleader);
                hcsedScrap := POINTER(ORD(rghcs^[icsScrap]));
                Replace(icsScrap, 0, LpMacEd(icsScrap), icsLUTFf, 0, LpMacFf(icsLUTFf));
                KILL_OBJECT(cError, pathLUT);
                fScrapIsUT := FALSE;
                END;
           END (* IF *);
        PasteFrom(icsScrap, 0, lpMacEd(icsScrap));
        END (* ELSE *);
   END (* IF *)
END (* Paste *);


{$S LWCreate}
{-----------------------------------------------}
PROCEDURE InitLScrap { (hz: THz) };
{-----------------------------------------------}
VAR pglp: TPglp;
    spT:  TSp;
    cError: TC;
    path: Pathname;
BEGIN
{$IFC sampcalls}  ALogCall;  {$ENDC}
IF fTstScrap THEN WRITELN('InitLScrap');
hzScrap := hz;
icsScrap := IcsEdCreate(10, pglpStd, FALSE, hz);
fScrapWord := FALSE;  {Scrap does not contain a word}
spT := ' ';
icsSpace:= IcsUsCreate(spT, hz);
ptThumb.h := 0; ptThumb.v := 0;
path := CONCAT(spLotusPrefix, '{t1}Scrap.Figures');
icsFigScrap := IcsFigCreate(cError, path, [dRead, dWrite, Append], hz,'');
IF cError > 0 THEN FailedDuringInit(internalError);
END;


END.

ÿ