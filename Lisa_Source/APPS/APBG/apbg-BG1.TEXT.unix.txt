(*$F-+*)
Unit BG1;                               {'Copyright 1983, 1984, Apple Computer Inc.'}

INTERFACE

uses (*$U UnitStd.obj *)                UnitStd,
     (*$U UnitHz.obj *)                 UnitHz,
     (*$U Storage.obj *)                Storage,
     (*$U QuickDraw.obj *)              QuickDraw,
     (*$U Fontmgr.obj *)                FontMgr,
     (*$U dbenv.obj *)                  dbenv,
     (*$U FEdec.obj *)                  FEdec,
     (*$U fld.obj *)                    fieldedit,
     (*$U teenv.obj *)                  teenv,

     (*$U libos/SysCall.obj    *)       Syscall,
     (*$U FPlib.obj *)                  FPlib,
     (*$U PMDecl *)                     PMDecl,
     (*$U PrStdInfo *)                  PrStdInfo,
     (*$U PrPublic.obj *)               PrPublic,
     (*$U aplc/mm/matmgr.obj *)         matmgr,
     (*$U FmgrUtil.obj   *)             FmgrUtil,

     (*$U wm.events.obj  *)             events,
     (*$U wm.folders.obj *)             folders,
     (*$U wm.menus.obj   *)             menus,
     (*$U AlertMgr.obj   *)             AlertMgr,

     (*$U aplc/mm/bgenv.obj      *)     bgenv,
     (*$U apbg/Graf2D.obj     *)        Graf2D,
     (*$U apbg/ttl.obj        *)        ttl,

     (*$U WMLstd.obj     *)             WMLstd,
     (*$U WMlsb.obj      *)             WMlsb,
     (*$U tm.obj         *)             tm,

     (*$U aplc/feglobals.obj  *)        feglobals,
     (*$U aplc/comgr.obj      *)        coMgr,
     (*$U aplc/TEexec.obj     *)        TEexec,

     (*$U scrap.obj      *)             Scrap,
     (*$U aplc/LCfexec.obj    *)        LCfexec,
     (*$U apbg/BG1a.obj       *)        BG1a;


Procedure DrawGraph;
Procedure InitBGWM;
Procedure BGSetGrfx;
Procedure InitGrfx;
Procedure InitBGPnl;
procedure InitBGstorage;
Procedure EraseBG;
Procedure BGGraphSize(newGraphProportion: tGraphProportion);
Procedure BGScroll( HorV: THorV; myScrollTYpe: ScrollType;
                    theScrollDir: ScrollDir; VAR Dest: Fract) ;

Procedure BGMenuCommand(MenuIndex,MenuItem: Integer; thePrMode : PrMenuSuppress);

Procedure BGYAxCk( NewMin, NewOrg, NewMax : Real; NewIncr: Real;
                    NewMinSet, NewOrgSet, NewMaxSet, NewIncrSet: Boolean);
Procedure BGXAxCk( NewMin, NewOrg, NewMax : Real; Newincr: Real;
                    NewMinSet, NewOrgSet, NewMaxSet, NewIncrSet: Boolean);

Procedure BGGetThumb(VAR XPerCent, YPerCent: Fract);

procedure BGNewRgImg;

procedure BGRgChged( aRg: range );

procedure FxBGstuff(mode : FIOkind; var status : integer);

procedure FxBGFree;

Procedure DoBGUndo;

Procedure BGReconfig;  (* reconfigures BG when the printer preference changes *)

IMPLEMENTATION

(*$R- *)

(*$IFC teSym *)
(*$D+ *)
(*$ELSEC *)
(*$D- *)
(*$ENDC *)

CONST
   leftWhite  = 0.25; (* number of inches of white space on sides of printed graph *)
   topWhite   = 0.25;
   rightWhite = 0.25;
   botWhite   = 0.25;

VAR
   (* Range of table cells changed since last call to BGNewRgImg. See also BG1.0/BGRgChged    *)
   BGRange: Range;


(**********************************************************************************************)
(* every routine in this file should be in segment BG1 *)

(*$S    *)
Procedure Drw3DBar(J: Integer; BarWidth, BarHeight: Real; dx, dY: Real);
(* Drw3DBar draws the shading for a 3D bar, leaving the CP unchanged. It assumes the CP
at the lower left corner of the spot for the shading. *)

VAR
   myPoly   : PolyHandle;
   pt1, pt2 : point;       (* upper left and lower right of front face *)
   BarRect  : Rect;


   Procedure DrwPerim(BarWidth, BarHeight: Real; dX, dY (* Perspective offsets *) : Real);
   (* Draw the perimeter of the shading. *)
   Begin
      (* Make sure you don't get little shadow tails below the bar *)
      BGMin(dY, ABS(BarHeight));
      If (BarHeight < 0.0) Then dY := -dY;

      (* Draw the perimeter of the shading *)
      Line2D(      0.0, -BarHeight);
      Line2D(       dx, +dy);
      Line2D(      0.0, BarHeight-dY);
      Line2D(      -dx, 0.0);
   end;

Begin
   (* Make the poly *)
   myPoly := OpenPoly;
   DrwPerim(BarWidth, BarHeight, dX, dY);
   ClosePoly;

   (* Fill, frame, and kill the poly *)
   FillPoly(myPoly, Patterns[10] (* Black *));
   FramePoly(myPoly);
   KillPoly(myPoly);
end;


(*$S     *)
Procedure Draw1Bar(I, J: Integer; BarWidth: Real; XLowLeft, YLowLeft: Real; dX, dY: Real);
(* Draw1Bar draws the Jth bar of the Ith cluster, making it BarWidth
wide in world coordinates. J is also used
to choose what form of hatching to use on the bar.
This routine assumes the CP is at the lower left corner of where
the bar is to be drawn, and updates the CP to the lower right
corner of the bar.


Note:
Each row in the matrix determines one cluster of bars
(the Ith row determines the Ith cluster of bars). Also, the value at the J+1
column determines the height of the Jth bar in the cluster. Therefore,
the data value in Matrix[I, J+1] corresponds to the bar in
the Ith cluster at the Jth position.                               *)

VAR
   DataVal : Real ;     (* Y data value out of the data record *)
   YPos    : Real;      (* World Y position of the data value    *)
   YOrgPos : Real;      (* World Y position of the Y axis origin *)
   BarHeight: Real;     (* wrld coord height of the bar          *)
   NANResult: cnSymKind;(* Not A Number (NAN) result, see the Matmgr code *)

Begin (* Draw1Bar *)
   (* Get the Y coordinate world position for this data value.         YPos  ->"
   Then calculate the BarHeight by taking the world coordinate                 "
   position of the Y axis origin and subtracting off the             BarHeight "
   world coordinate position for this data value.                              "
                                                                   YAxis.Org ->"
                                                                                 *)

   (* Draw the bar if the cell has a value, else just leave a blank space *)
   If (CellHasValue(I, J+1)) Then Begin
      (* Use J+1 col since the Y values start in the second col of the matrix *)
      GetValReal(I, J+1, NANResult, DataVal);

      (* The bar height is the distance between this DataVal and the Y axis org *)
      YPos      := YPosCalc(DataVal);
      YOrgPos   := YPosCalc(YAxis.Org);
      BarHeight := YOrgPos - YPos;

      (* Draw the actual bar, and the shading if it's a 3d bar  *)
      Moveto2D(XLowLeft, YLowLeft);

      PicComment(cPicGrpBegin, 0, Nil);
      DrwFooBar(J, BarWidth, BarHeight);                                   (* DrwFooBar in unit Ttl *)
      If (GType = SolidBar) Then Drw3DBar(J, BarWidth, BarHeight, dX, dY); (* in this unit          *)
      PicComment(cPicGrpEnd, 0, Nil);
   End (* If *)

   (* Else just move to the right to leave a blank space *)
   Else Move2D(BarWidth, 0.0);
End; (* Draw1Bar *)


(*$S    *)
Procedure DrawCluster(I:Integer; BarWidth, SpaceFactor, RClusterTot, dX, dY (* Persp. offset *): Real);
(* Draws the Ith cluster of bars.
BarWidth    = World width of 1 bar
SpaceFactor = SpaceFactor*BarWidth space on each side of cluster
RClusterTot = total # of clusters on entire graph. Needed to calculate
              where to put this cluster along length of X axis *)


VAR
   XPos, YPos: Real; (* world lower left corner for this cluster *)
   J     : Integer;  (* cntr for drawing each bar in the cluster *)

Begin

   (* calculate the proper spot to draw the Ith cluster.
   XPos = lower left corner of front face for positive bars,
        = upper left corner of front face for negative bars.
   YPos = a height equal to the placement of the Y axis origin *)

   (* Calc the XPos, also adding on the space factor on the left side *)
   With XAxis do Begin
      XPos  := XPos1 + Delta * (I-1)/RClusterTot + SpaceFactor*BarWidth;
   End; (* With *)
   (* XPos := XPos + SpaceFactor*BarWidth; *)

   YPos := YPosCalc(YAxis.Org);
   MoveTo2D(XPos, YPos);

   (* Draw all the bars in the cluster. A bar is in the cluster iff
      BarBoolean says it is, otherwise its a line rep and not drawn here *)
   For J := 1 to BGData.RepNum Do Begin
      If BarBoolean[J] Then Begin
         Draw1Bar(I, J, BarWidth, XPos, YPos, dX, dY);
         XPos := XPos + BarWidth;
      end;
   End;

   (* Dont have to add in blank space on the right *)
End; (* DrawCluster *)


(*$S BGLineScatter *)
Procedure DrwBar2LineRep(I: Integer; ClusterWidth: Real; LineFlag, ShowMarkers: Boolean);
(* Draws the Ith line rep for the barline and BarScat representation. This
   type of graph has text labels for the X axis and then a line or a scatter
   representation for the data.
   If LineFlag    = True then the connecting line is drawn between markers.
   If ShowMarkers = True then draw a marker at each data point            *)

VAR
   ColId,
   RowId      : Integer;   (* indices into the matrix      *)
   XPos,
   YPos       : Real;      (* Realgraf position to draw to *)
   myYVal     : Real;      (* Y value from the matrix      *)
   myNANResult: cnSYmKind; (* says if YVal is Not A Number *)
   J          : Integer;
   Found      : Boolean;
   myColor    : Longint;

Begin
   (* Find the first cell in the row containing a value and draw a mark *)
   RowId := 1;
   ColId := I+1;
   Found := False;

   Repeat Begin
      (* Draw a mark if the matrix has a value there *)
      If (CellHasValue(RowId, Colid)) Then Begin
         Found := True;
         XPos  := XAxis.XPos1 + (RowId - 0.5) * ClusterWidth;
         GetValReal(RowId, ColId, myNanResult, myYVal);
         YPos  := YPosCalc(myYVal);
         Moveto2D(XPos, YPos);
         If ShowMarkers then DrawMark(I);
      end;

      (* Bump the RowId in either case *)
      RowId := RowId + 1;
   End
   Until (Found OR (RowId > BGData.XListTot));

   (* Draw a line to the next point and a mark *)
   myColor := colornum(i);

   For J := RowId to BGData.XListTot do Begin
      XPos := XAxis.XPos1 + (J-0.5)*ClusterWidth;
      (* Get the Y value and YPos *)
      RowId := J;
      If (CellHasValue(RowId, ColId)) Then Begin
         GetValReal(RowId, ColId, myNanResult, myYVal);
         YPos := YPosCalc(myYVal);

         SetForeColor(myColor);

         If LineFlag Then Lineto2D(XPos, YPos)
                     Else Moveto2D(XPos, YPos);

         If ShowMarkers then DrawMark(I);
      end;
   End; (* For *)
   ColorDefault
End; (* subr *)


(*$S BGArea *)
Procedure DrwTextAreaRep;
(* Draws the Ith area rep for GType = TextAreaGraph. This type of graph has text labels
   for the X axis and an area representation representation for the data. *)

CONST
   LineFlag = True;

VAR
   ColId,
   RowId      : Integer;   (* indices into the matrix      *)
   XPos,
   YPos       : Real;      (* Realgraf position to draw to *)
   YOrgPos    : Real;      (* Y pos of the Y Axis origin   *)
   myYVal     : Real;      (* Y value from the matrix      *)
   myNANResult: cnSYmKind; (* says if YVal is Not A Number *)
   I          : Integer;
   Found      : Boolean;
   myPoly     : PolyHandle;
   ClusterWidth: Real;

Begin
   (* Amount of space for each data point *)
   ClusterWidth:= XAxis.Delta/BGData.XListTot;

   For I := 1 to BGData.RepNum do Begin

      (* Find the first cell in the row containing a value *)
      RowId := 1;
      ColId := I+1;
      Found := False;

      Repeat Begin
         (* Found the first value if the matrix has a value there *)
         If (CellHasValue(RowId, Colid)) Then Begin
            Found := True;
            XPos  := XAxis.XPos1 + (RowId - 0.5) * ClusterWidth;
            GetValReal(RowId, ColId, myNanResult, myYVal);
            YPos  := YPosCalc(myYVal);
         end;

         (* Bump the RowId in either case *)
         RowId := RowId + 1;
      End
      Until (Found OR (RowId > BGData.XListTot));

      If Found then With XAxis do Begin
         (* Draw the lines around the left margin *)
         myPoly := OpenPoly;
         YOrgPos := YPosCalc(YAxis.Org);
         Moveto2D(XPos1, YOrgPos);
         Lineto2D(XPos1, YPos);
         Lineto2D(XPos , YPos);

         (* Draw the lines for the data rep. Lines, no markers *)
         DrwBar2LineRep(I, ClusterWidth, LineFlag, False { no markers });

         (* Draw the connecting lines on the right margin and close the poly *)
         Lineto2D(XPos1+Delta, rp^.pen.y);
         Lineto2D(XPos1+Delta, YOrgPos);
         Lineto2D(XPos1, YOrgPos);

         (* Close, Fill, Frame, and kill the poly *)
         ClosePoly;

         SetBackColor(colornum(i));

         FillPoly(myPoly, Patterns[I]);
         FramePoly(myPoly);
         KillPoly(myPoly);
         ColorDefault;

         (* Draw the markers if they're needed.         No Lines, yes markers *)
         If BGMarkFlag Then DrwBar2LineRep(I, ClusterWidth, False, True);
      End; (* If *)
   end; (* For *)
End; (* subr *)



(*$S    *)
Function CalcNumBars: Integer;
(* Returns the number of data columns to be represented as bars (as opposed to lines) *)

VAR
   BarNum,
   I       : Integer;

Begin
   (* Calculate the number of bars in each cluster *)
   BarNum := 0;
   For I := 1 to BGData.RepNum do Begin
      If (BarBoolean[I]) Then BarNum := BarNum + 1;
   End;

   CalcNumBars := BarNum;
end;



(*$S    *)
Procedure DrwBarRep;
(* Draws the bar representation of the data. *)

CONST
   LineFlag    = True;
   dY          = 0.09;  (* inches in the y direction for the perspective offset *)
   SpaceFactor = 0.6;   (* Spacefactor * BarWidth space is placed on
                          each side of a cluster of bars           *)

VAR
   I            : Integer; (* Cntr to count through the clusters    *)
   ClusterWidth : Real;    (* world width of one cluster            *)
   BarWidth     : Real;    (* World width of a single bar           *)
   BarNum       : Integer; (* Number of bars in one cluster         *)
   dX           : Real;    (* Perspective offset for 3D bars        *)

Begin

   (* Calculate the width of each cluster. There is one cluster
   for each value in the X data list  *)

   ClusterWidth:= XAxis.Delta/BGData.XListTot;

   (* Calculate the number of bars in each cluster *)
   BarNum := CalcNumBars;

   (* Plot out the bars if there are any *)
   If (BarNum > 0) Then Begin
      (* calculate width of one bar. 2*SpaceFactor gives blank space on
         each side of a cluster. dX is the perspective offset for 3d bars. *)
      BarWidth := ClusterWidth/(BarNum + 2*SpaceFactor);
      dX       := BarWidth/5.5; (* derived experimentally *)

      For I := 1 to BGData.XListTot do Begin
         DrawCluster(I, BarWidth, SpaceFactor, BGData.XListTot, dX, dY);
      End; (* For *)
   end;

   (* Go Across the table plotting out any line reps. *)
   For I := 1 to BGData.RepNum do begin
      If (NOT BarBoolean[I]) Then Begin
         DrwBar2LineRep(I, ClusterWidth, LineFlag, BGMarkFlag);
      end;
   end;
End; (* DrwBarRep *)



(*$S BGLineScatter *)
Procedure Drw1Scat(J: Integer);
(* Draw the scatter representation for the Jth data set (i.e. Jth+1 column) *)
VAR
   XPos, YPos: Real;
   Done      : Boolean;

Begin
   Repeat
      GetNextPoint(J, XPos, YPos, Done);
      MoveTo2D(XPos, YPos);
      DrawMark(J);
   Until Done;
end;



(*$S BGArea *)
Procedure DrwNumbAreaRep;
(* Draws an area chart with numeric X axis labels. Similar to DrwLineRep below *)

VAR
   J        : Integer;  (* Index for each data rep number  *)
   XPos,YPos: Real;     (* Position for each data point    *)
   YOrgPos  : Real;     (* Y position of the Y axis origin *)
   Done     : Boolean;  (* True iff no more data in list J *)
   myPoly   : PolyHandle;

Begin
   ResetData;

   (* Draw each data rep in turn *)
   For J := 1 to BGData.RepNum Do begin
      (* Get the first point and see if done *)
      GetNextPoint(J, XPos, YPos, Done); (* in BG1A *)

      If (Not Done) Then With XAxis do Begin
         myPoly := OpenPoly;

         (* Draw the vertical and horizontal lines along the left margin and to the first point *)
         YOrgPos := YPosCalc(YAxis.Org);
         Moveto2D(XPos1, YOrgPos);
         Lineto2D(XPos1, YPos);
         Lineto2D(XPos , YPos);

         (* Draw a line and a mark if needed to each succeeding point *)
         GetNextPoint(J, XPos, YPos, Done);
         While (not Done) do Begin
            Lineto2D(XPos, YPos);
            GetNextPoint(J, XPos, YPos, Done);
         End; (* While *)

         (* Draw from the last point to the right margin and complete the poly *)
         Lineto2D(XPos1+Delta, YPos);
         Lineto2D(XPos1+Delta, YOrgPos);
         Lineto2D(XPos1      , YOrgPos);

         ClosePoly;
         PenNormal;

         (* Fill and frame the poly *)
         SetBackColor(colornum(j));

         FillPoly(myPoly, Patterns[J]);
         FramePoly(myPoly);
         KillPoly(myPoly);
         ColorDefault;

         (* Draw the marks as needed *)
         If (BGMarkFlag) Then Begin
            (* Really could just reset data set J here if add new subr to BG1A *)
            ResetData;
            Drw1Scat(J);
         end;
      End; (* If *)
   End; (* For *)
End; (* DrwNumbAreaRep *)


(*$S BGLineScatter *)
Procedure DrwLineRep(ShowMarkers: Boolean);
(* DrwLineRep draws the data representation for a line chart.
   It assumes that the data is already sorted by X value     *)

VAR
   J        : Integer;  (* Index for each data rep number    *)
   XPos,YPos: Real;     (* Position for each data point      *)
   Done     : Boolean;  (* True iff no more data in list J   *)
   myColor  : LongInt;

Begin
   ResetData;

   (* Draw each data rep in turn *)
   For J := 1 to BGData.RepNum Do begin
      (* Get the first point and see if done *)
      myColor := colornum(j);

      GetNextPoint(J, XPos, YPos, Done); (* in BG1A *)

      If (Not Done) Then Begin
         (* Group the lines and markers if within a quickdraw picture. Call is ignored otherwise *)
         PicComment(cPicGrpBegin, 0, Nil);

         (* Draw the first mark *)
         Moveto2D(XPos, YPos);
         If ShowMarkers Then DrawMark(J);
         GetNextPoint(J, XPos, YPos, Done);

         (* Draw a line to each succeeding point and put a mark *)
         While (not Done) do Begin

            SetForeColor(myColor);

            Lineto2D(XPos, YPos);
            If ShowMarkers Then DrawMark(J);
            GetNextPoint(J, XPos, YPos, Done);
         End; (* While *)

         PicComment(cPicGrpEnd, 0, Nil);
      End; (* Else *)
   End; (* For *)
   ColorDefault
End; (* DrwLineRep *)


(*$S BGLineScatter *)
Procedure DrwScatRep;
(* DrwScatRep draws the data representation for a scattergram *)

VAR
   J: Integer;

Begin
   ResetData;

   (* Draw each data rep (i.e. column) in turn *)
   For J := 1 to BGData.RepNum Do Begin
      PicComment(cPicGrpBegin, 0, Nil);

      (* Draw each scatter representation *)
      Drw1Scat(J);
      PicComment(cPicGrpEnd, 0, Nil);
   End; (* For *)
End; (* DrwSctRep *)


(*$S    *)
Procedure BGStripBlanks(TextPtr: PtrData; VAR numBytes: Integer; RowId, ColId: Integer);
(* If the cell has a money format, and there are blanks between the $ and the number,
   it will strip all the blanks following the $ (e.g. $   12 becomes $12). This routine
   assumes that the field is not a $ followed only by blanks i.e. that there is a number
   at the end of the blanks.
   Returns numBytes as the number of chars in the stripped field *)

VAR
   myDest,                                   { index of first char to right of currency symbol           }
   CharIndex   : Integer;                     { index of first non-blank char to right of currency symbol }

   myattr     : attrRecord;

Begin
   CellAttr(RowId, ColId, myAttr);

   (* Strip the blanks only if the cell has a money format *)
   If (myAttr.attFormat = fMoney) Then Begin

      { Strip the blanks only if the currency symbol is in the front of the string }
      If (DataFormat.dSignPos) Then Begin

         { make myDest index to the first char to the right of the currency symbol.
           dataFormat is a global in the matrix manager }
         myDest := Length(dataFormat.dSign);

         { make CharIndex index to the first non-blank char to the right of the currency symbol }
         CharIndex := myDest;
         While (TextPtr^[CharIndex] = Ord(' ')) AND (CharIndex < numBytes) Do Begin
            CharIndex := CharIndex + 1;
         end;

         { Move the chars left to delete the blanks }
         MoveLeft(TextPtr^[CharIndex], TextPtr^[myDest], numBytes - CharIndex);
         numBytes := numBytes - CharIndex + myDest;
      end;
   end;
end;


(*$S BGPie *)
Procedure BGPieAngle(XCntr, YCntr, Radius, RealAng: Real; PieRect: Rect;
                     VAR Pt: Point; VAR Angle: Integer);
(* Returns the Pt and the Integer Angle corresponding to the circle angle RealAng *)
VAR
   CenterPt: Point;
   DeltaH,
   DeltaV  : Integer;  (* Distance from the center pt to the circumference pt *)

Begin
   (* Get the first (approximate) point based on the RealAng *)
   BGMapPt(XCntr + Radius*SIN(RealAng), YCntr + Radius*COS(RealAng), Pt);

   (* Get the integer angle to return based on the approximate point *)
   PtToAngle(PieRect, Pt, Angle);

   (* Remap the point based on the integer angle used for the arc commands *)
   BGMapPt(XCntr + Radius*SIN(Angle*Pi/180.0), YCntr - Radius*COS(Angle*Pi/180.0), Pt);
End;



(*$S BGPie *)
Procedure BGPieRgn(XCntr, YCntr, Radius, AngStart, AngEnd: Real; Patnum:Integer; myRect:Rect;
                   VAR myPt: Point; VAR myAngle: Integer);
(* BGPieRgn draws one pie slice from AngStart to AngEnd and fills it with pattern PatNum.
   myPt and myAngle are the integer point and angle at which to start this pie slice. They
   get returned as the integer point and angle at which to start the next slice.  *)


VAR
   X1, Y1,
   X2, Y2  : Real;    (* real valued points at edge of the wedge  *)

   Pt1,               (* point at which to start this slice       *)
   Pt2     : Point;   (* point at which to end this slice         *)
   PtCenter: Point;   (* center point of the pie wedge            *)

   Angle1,
   Angle2,            (* integer start and end angles             *)
   mySweep : Integer; (* and the sweep angle between them         *)


Begin (* BGPieRgn *)

   (*************************************************************)
   (* Draw the wedge only if the pie rect intersects the refreshRgn *)
   If (RectinRgn(myRect, BGRefreshRgn) OR BGPrintFlag) Then Begin

      (* Calculate the points at the edge of the wedge *)
      pt1     := myPt;
      Angle1  := myAngle;
      BGPieAngle(XCntr, YCntr, Radius, AngEnd, myRect, pt2, Angle2);
      mySweep := Angle2 - Angle1;

      (* return the point and angle for the next go-round *)
      myPt    := pt2;
      myAngle := Angle2;

      (* Special case for sweep around entire 360 degrees. The 6.0 is used as a value slightly
         less than TwoPI *)
      If ((mySweep = 0) AND (AngStart-AngEnd > 6.0)) OR (mySweep < 0)
         Then mySweep := mySweep+360;

      (*******************************************************)
      (* Draw the arc to the screen *)
      SetBackColor(colornum(patNum));

      FillArc (myRect, Angle1, mySweep, Patterns[PatNum]);
      ColorDefault;

      (* Draw the radial lines and the outer edge. *)
      BGMapPt(XCntr, YCntr, PtCenter);
      PenSize(1, 1);
      FrameArc(myRect, Angle1, mySweep);
      PenSize(2, 2);
      Moveto(Pt1.h, pt1.v);
      Lineto(PtCenter.h, PtCenter.v);
      Lineto(pt2.h, pt2.v);
   end;
end;



(*$S BGPie *)
Procedure BGPieLaybl(XCntr, YCntr, Radius, MidAng: Real; RowId: Integer);
(* BGPieLaybl draws a label for a pie slice whose mid Angle is at MidAng *)

CONST
   WideFlg    = False;   (* CellValue does not want the wide angle view   *)
   ShowSel    = False;   (* Dont show the selection when drawing label    *)
   Erase      = True;    (* whether to erase before redrawing field       *)
   ColId      = 1;

VAR
   SinAng    : Real;     (* Sin of MidAng *)
   myFontNum : Integer;  (* large font for actual size, small for reduced *)

   XPos,
   YPos      : Real;     (* position for the label                        *)
   pt        : Point;    (* LisaGraf point corresponding to (XPos,YPos)   *)

   (* Vars returned by Matrix Managers CellValue call        *)
   (* IMPORTANT: numBytes set to Max upon entry to CellValue *)
   numBytes     : Integer;
   Status       : Integer;

   RealFactor   : Real;

Begin

   (***************************************************************************)
   (* Get a ptr to the text string in the matrix manager. numBytes and status
   are returned, the text is placed into the memory pointed at by pData *)

   numBytes := maxlngth; (* ANOMALY: value in, changed and returned *)
   CellValue(mmRead, RowId, ColId, hExtraFld^^.curvalue^, WideFlg, numBytes, status);

   {$IFC fDebug}
   If (Status <> 0) Then Writeln('***BG1/BGPieLaybl has error ',status);
   {$ENDC }

   (* Strip out any embedded blanks.  *)
   BGStripBlanks(hExtraFld^^.curValue^, numBytes, RowId, ColId);

   (* tell the fieldedit routines how long the text string is *)
   hExtraFld^^.curlen := numBytes;

   (* Exit if nothing to draw *)
   If (numBytes = 0) Then Exit(BGPieLaybl);

   (**************************************************************************)

   If (BGPreview or BGCutFlag or BGPrintFlag) Then myFontNum := p12Tile
                                              else myFontNum := p15Tile;
   SetRunFormat(hExtraFld, Nil, myFontNum, SetFont, status);

   (* Move to the proper point just outside the pie slice. The 1.14 factor
   puts the label outside the circumference *)
   SinAng := SIN(MidAng);

   RealFactor := 1.14 * Radius;
   XPos := XCntr + RealFactor * SinAng;
   YPos := YCntr + RealFactor * COS(MidAng);

   (* Center justify near the top and bottom. Right justify on the left side of pie. Left justify
      on the right side of the pie. NOTE: When Sin has a small magnitude you know you're near the
      top or bottom of the circle  *)

   With hExtraFld^^ do begin
      If      (ABS(SinAng) < 0.15) Then align := Center
      Else If (SinAng < 0.0)         Then align := right
      Else                                align := left;
   end;

   (* Draw the field *)
   BGDrawFldAt(hExtraFld, XPos, YPos, ShowSel, Erase);
End; (* BGPieLaybl *)



(*$S BGPie *)
Procedure BGPieSlice(XCntr, YCntr, Radius: Real; AngStart, AngEnd: Real; PatNum: Integer;
                     RowId: Integer; myRect: Rect; VAR myPt: Point; VAR myAngle: Integer);

(* BGPieSlice draws one slice of a pie chart from AngStart to AngEnd,
fills it with pattern PatNum, then labels the slice. myPt and myAngle are the integer point
and angle at which to start this pie slice, and get returned as the integer point and angle
at which to start the next slice  *)

Var
   MidAng: Real;              (* the angle midway between AngStart and AngEnd      *)

Begin
   (********************************************************************************)
   (* Group them if within a picture (call is ignored if not within a picture)     *)
   PicComment(cPicGrpBegin, 0, Nil);

   (* Draw and fill in the region for this pie slice *)
   BGPieRgn(XCntr, YCntr, Radius, AngStart, AngEnd, Patnum, myRect, myPt, myAngle);

   (* Calculate the angle for placing the pie segment label *)
   MidAng := (AngStart + AngEnd)/2.0;
   BGPieLaybl(XCntr, YCntr, Radius, MidAng, RowId);

   PicComment(cPicGrpEnd, 0, Nil);
End; (* BGPieSlice *)



(*$S BGPie *)
Procedure DrwPieRep;
(* DrwPieRep draws the data representation for a pie chart *)

Const
   YList = 1;               (* pie always uses the first Y list                *)

VAR
   YTot       : Real;       (* Sum of all the values in the Y list             *)
   AngOld,
   AngNew     : Real;       (* angles to draw pie slice between in radians     *)
   TwoPi      : Real;       (* constant of 2*Pi                                *)

   PatNum     : Integer;
   Rowid,                   (* Indices into the matrix                         *)
   ColId      : Integer;

   YVal       : Real;       (* Y value from the matrix                         *)
   NANResult  : cnSymKind;  (* Not A Number (NAN) result, see the MAtmgr code  *)

   XCntr,                   (* Center point for the pie                        *)
   YCntr,
   Radius     : Real;       (* pie radius                                      *)
   MidAng     : Real;       (* the angle midway between AngStart and AngEnd    *)
   ULeft,
   BRight     : Point;

   myRect     : Rect;       (* rect containing the entire pie circle           *)
   myPt       : Point;      (* point on circle at which to start the new wedge *)
   myAngle    : Integer;    (* angle at which to start the new wedge           *)


Begin
   (* Calc the center spot and the radius *)
   XCntr := XFct * GraphSize.XMax;
   YCntr := YFct * GraphSize.YMax;

   With GraphSize Do Begin
      Radius := XMax;
      BGMin(Radius, YMax);
      Radius := Radius*RadiusFct;
   end;

   (* Get the pie's bounding box *)
   BGMapPt(XCntr-Radius, YCntr-Radius, ULeft);
   BGMapPt(XCntr+Radius, YCntr+Radius, BRight);
   Pt2Rect(ULeft, BRight, myRect);
   With myRect do begin
      Right  := Right +1;
      Bottom := Bottom+1;
   end;
   TwoPi := 2.0 * Pi;

   (* Total up the values in the YList data list *)
   YTot := 0.0;

   ColId := 2;
   For RowId := 1 to BGData.XListTot Do Begin
      GetValReal(Rowid, ColId, NANResult, YVal);
      If (YVal > 0.0) Then YTot := YTot + YVal;
   End;

   (* Got the total, now draw out the slices one by one *)
   AngOld  := 100.0;   (* Init to sentinel value *)
   PatNum  := 1;
   ColId   := 2;

   For RowId := 1 to BGData.XListTot Do Begin
      (* Get the data value out of the matrix *)
      GetValReal(Rowid, ColId, NANResult, YVal);

      If (YVal > 0.0) Then begin

         (* Special action on the first pie wedge *)
         (* Plot the first, largest slice equidistant around the bottom.
            NOTE: 0 degrees points straight down in Graf2D coordinates.
            AngOld starts on the right side, and AngNew goes around the
            circle in a clockwise direction to agree with the direction
            required by the FillArc routine. *)
         If (AngOld = 100.0) Then Begin
            AngOld := Pi * (YVal/YTot);
            BGPieAngle(XCntr, YCntr, Radius, AngOld, myRect, myPt, myAngle);
            if 1 = BGData.XListTot then myAngle := 0
         end;

         (* Use pattern 3 if the last pattern is too similar to pattern 1 *)
         If (RowId = BGData.XListTot) Then If (PatNum < 3) Then PatNum := 3;

         (* Compute the new angle to draw to and plot the slice. The minus factor
         makes the angle go around the circle clockwise. *)
         AngNew  := AngOld - (YVal/YTot) * TwoPi;
         BGPieSlice(XCntr, YCntr, Radius, AngOld, AngNew, PatNum, RowId, myRect, myPt, myAngle);

         (* Set up for next runthrough. Note: there are LegendMax patterns *)
         If (PatNum >= LegendMax) Then PatNum := 1
                                  Else PatNum := PatNum + 1;
         AngOld  := AngNew;
      end;
   End; (* While *)
   PenNormal;
End; (* DrwPieRep *)


(*$S BGLineScatter *)
Procedure DrwBarLineRep(ShowMarkers: Boolean);
(* Draws a line rep in which the X-axis labels are text labels (as in
a bar chart) and the data representation is a line graph. Used now to do
draw a line chart with bar labels. Used in the future to do a hybrid bar
and line chart. *)

CONST
   LineFlag = True;

VAR
   ClusterWidth : Real;   (* width allowed for each data point *)
   I            : Integer;

Begin
   (* Width for each data point = XAxisWidth/(Number of data points) *)
   ClusterWidth := XAxis.Delta/BGData.XListTot;

   (* Draw each line rep in turn *)
   For I := 1 to BGData.RepNum do Begin
      DrwBar2LineRep(I, ClusterWidth, LineFlag, ShowMarkers);
   End;
End;


(*$S BGLineScatter *)
Procedure DrwBarScatRep;
(* Draws a scattergram rep in which the X axis labels are text labels (as in
a bar chart) and the data representation is a scatter. *)

CONST
   NoLine = False;

VAR
   ClusterWidth : Real;   (* width allowed for each data point *)
   I            : Integer;

Begin
   (* Width for each data point = XAxisWidth/(Number of data points) *)
   ClusterWidth := XAxis.Delta/BGData.XListTot;

   (* Draw each line rep in turn *)
   For I := 1 to BGData.RepNum do Begin
      DrwBar2LineRep(I, ClusterWidth, NoLine, BGMarkFlag);
   End;
End;


(*$S BGStacked *)
Procedure Draw1StackBar(I, J: Integer; BarWidth: Real; XPos: Real; VAR YAbove, YBelow: Real);
(* Draws the Jth bar on the Ith stack. Puts it on top if the cell value >= YAxis.Org, else below *)

VAR
   DataVal : Real ;     (* Y data value out of the data record   *)
   YPos    : Real;      (* World Y position of the data value    *)
   YOrgPos : Real;      (* World Y position of the Y axis origin *)
   BarHeight: Real;     (* wrld coord height of the bar          *)
   NANResult: cnSymKind;(* Not A Number (NAN) result, see the Matmgr code *)
   myPattern: Integer;  (* index for the shading pattern                  *)


Begin
   If (CellHasValue(I, J+1)) Then Begin
      (* Get the value out of the cell *)
      GetValReal(I, J+1, NANResult, DataVal);

      (* Calc the height of the bar *)
      BarHeight := YPosCalc(DataVal) - YPosCalc(0.0);

      (* Put it on top or bottom according to positive or negative *)
      If (DataVal >= 0.0) Then Begin
         YPos   := YAbove;
         YAbove := YAbove + BarHeight;
      end
      Else Begin
         YPos   := YBelow;
         YBelow := YBelow + BarHeight;
      end;

      (* Draw the bar *)
      Moveto2D(XPos, YPos);
      DrwFooBar(J, BarWidth, -BarHeight);
   end;
end;


(*$S BGStacked *)
Procedure DrawAStack(I: Integer; BarWidth, SpaceFactor: Real; RStackTotal: Real);
(* Draws the Ith stack of bars *)
VAR
   J   : Integer;
   YAbove,            (* lower corner Y position of a positive stacked bar *)
   YBelow : Real;     (* upper corner Y position of a negative stacked bar *)
   XPos   : Real;     (* Left side of a stacked bar *)

Begin
   With XAxis do Begin
      XPos := XPos1 + Delta*(I-1)/RStackTotal;
   end;
   XPos := XPos + SpaceFactor*BarWidth;

   (* Set up the Y pos at which to draw the positive and negative stacked bars *)
   YAbove := YPosCalc(0.0);
   YBelow := YAbove;

   (* Draw out each stacked bar in this stack *)
   For J := 1 to BGData.RepNum do Begin
      If (BarBoolean[J]) Then Begin
         Draw1StackBar(I, J, BarWidth, XPos, YAbove, YBelow);
      end;
   end;
end;


(*$S BGStacked *)
Procedure DrwStackBarRep;
(* Draws the stacked bar rep of the data *)
CONST
   LineFlag     = True;
   SpaceFactor  = 0.6;

VAR
   I            : Integer;
   ClusterWidth : Real;    (* world width of one cluster            *)
   BarWidth     : Real;    (* World width of a single bar           *)
   BarNum       : Integer; (* Number of bars in one cluster         *)

Begin

   ClusterWidth := XAxis.Delta/BGData.XListTot;
   BarNum       := CalcNumBars;

   If (BarNum > 0) Then Begin
      BarWidth := ClusterWidth/(1.0 + 2*SpaceFactor);

      (* Go down the table plotting out each stack in turn *)
      For I := 1 to BGData.XListTot do Begin
         DrawAStack(I, BarWidth, SpaceFactor, BGData.XListTot);
      end;
   end;

   (* Go across the table plotting out each line rep in turn *)
   For I := 1 to BGData.RepNum do Begin
      If (NOT BarBoolean[I]) Then Begin
         DrwBar2LineRep(I, ClusterWidth, LineFlag, BGMarkFlag);
      end;
   end;
end;



(*$S    *)
Procedure DrawRep;
(* DrawRep draws the data representation for the current user data
based on the current graph type the user has selected *)

Begin
   Case GType of

      Bar,
      SolidBar      : DrwBarRep;

      StackBar      : DrwStackBarRep;

      NumbAreaGraph : DrwNumbAreaRep;            (* area graph with numeric labels *)
      LineGraph     : DrwLineRep(BGMarkFlag);    (* line graph with numeric labels *)

      Scatter       : DrwScatRep;
      Pie           : DrwPieRep ;

      TextAreaGraph : DrwTextAreaRep;            (* area graph with text labels    *)
      BarLine       : DrwBarLineRep(BGMarkFlag); (* line graph with text labels    *)

      BarScat       : DrwBarScatRep;
   End; (* Case *)
End; (* DrawRep *)


(*$S    *)
Procedure DrawBndry;
(* DrawBndry draws the plotting boundary *)
VAR
   Pt1,
   Pt2    : Point;
   myRect : Rect;

Begin
   With PlotBndry Do Begin
      BGMapPt(XMin, YMin, Pt1);
      BGMapPt(XMax, YMax, Pt2);
      Pt2Rect(Pt1, Pt2, myRect);
      With myRect do Begin
         right := right  + 1;
         Bottom:= Bottom + 1;
      end;
      FrameRect(myRect);
   End;(* With*)
End; (* DrawBndry *)


(*$S    *)
Procedure BGLineStyle(myccPattern: TCc);

VAR
   myPrInfo: TPrInfo;
Begin
   Pensize(1, 1);
   If (myccPattern = ccGray) Then Begin
      PenPat(Gray);
      (* Enlarge the pensize when pat stretching to avoid a 1 thick gray line from falling
         between the pattern thereby drawing nothing *)
(*
 commented out  - 1/13/83
      If (BGPrintFlag) Then Begin
         PrMetrics(CurConfig, myPrInfo);
         If (myPrInfo.cPatScale = -2) Then PenSize(2, 2);
      end;
*)

   end
   Else PenPat(Black);
end;


(*$S    *)
Procedure DrwXAxis;
(* Draws the X axis, from left to right on the screen. *)

VAR
   XPos,
   YPos : Real;   (* left-hand side of the X axis *)

Begin
   If (YAxis.Org > YAxis.Min) Then Begin
      XPos := PlotBndry.XMin;
      YPos := YPosCalc(YAxis.Org);

      (* Move to the start position and draw the axis *)
      BGLineStyle(ccGray);
      Moveto2D(XPos,YPos);
      Line2D(XAxis.Delta, 0.0);
      BGLineStyle(ccBlack);
   End;
End; (* DrwXAxis *)


Procedure DrwYAxis;
(* Draws the Y axis, from bottom to top on the screen. *)

VAR
   XPos,
   YPos : Real;   (* bottom of the Y axis *)

Begin
   If (XAxis.Org > XAxis.Min) Then Begin
      If (GType = LineGraph) OR (GType = Scatter) Then Begin
         YPos := PlotBndry.YMax;
         XPos := XPosCalc(XAxis.Org);

         (* Move to the start position and draw the axis *)
         BGLineStyle(ccGray);
         Moveto2D(XPos,YPos);
         Line2D(0.0, -YAxis.Delta);
         BGLineStyle(ccBlack);
      End;
   End;
End; (* DrwYAxis *)


(*$S    *)
Procedure DrwXTicks;
(* Draws the tick marks or grid along the X axis for the line chart and
   the scattergram ( no X ticks for a bar chart)  *)

VAR
   J       : Integer;   (* for loop counter                       *)
   XPos,YPos: Real  ;   (* start position for each tick or grid   *)
   TkLen    : Real  ;   (* length of the ticks or grid lines      *)
   Data     : Real;

Begin

   Case GType Of

      LineGraph,Scatter :

         Begin
            (* calculate the tick length TkLen to cover the entire plot area. *)
            TkLen    := PlotBndry.YMin - PlotBndry.YMax;

            (* Set up the proper starting Y position according to grid on or off *)
            If (XAxis.Grid) Then Begin (* user wants gridding *)
               YPos := PlotBndry.YMax;
               BGLineStyle(ccGray);
            End

            Else Begin (* User wants tick marks only. Shorten the tick length *)
               YPos := XAxis.YPos1;
               TkLen := TkLen/25.0;
               BGLineStyle(ccBlack);
            End;

            (* Draw each tick mark or grid line in turn *)
            With XAxis do Begin
               J := 1;
               Data := XAxis.Min + J*AxIncr;

               (* Check J only to prevent error of infinite loop *)
               While (Data < Max) AND (J < 50) Do Begin
                  (* Plot the tick or grid mark *)
                  XPos := XPosCalc(Data);
                  MoveTo2D(XPos, YPos);
                  Line2D(0.0, TkLen);

                  (* get the next data point. *)
                  J    := J + 1;
                  Data := XAxis.Min + J*AxIncr;
               End;
            end;

            BGLineStyle(ccBlack);
         End; (* LineGraph and Scatter case *)

      Pie, Bar, BarLine, BarScat:
         Begin
         End; (* Pie and Bar case *)
      End; (* Case *)
End; (* DrwXTicks *)


(*$S    *)
Procedure DrwYTicks;
(* Draws the tick marks or grid along the Y axis for the line chart and
   the scattergram ( no X ticks for a bar chart)  *)

VAR
   J       : Integer;   (* for loop counter                    *)
   XPos,YPos: Real  ;   (* start position for each tick or grid*)
   TkLen    : Real  ;   (* length of the ticks or grid lines   *)
   Data     : Real  ;   (* data point for the next label       *)

Begin (* DrwYTicks *)
   (* calculate the tick length TkLen. TkLen
   will be shortened below if only tick marks are needed and not gridding *)
   TkLen    := PlotBndry.XMAx - PlotBndry.XMin;

   (* Set up the proper starting Y position according to grid on or off *)
   If (YAxis.Grid) Then Begin (* user wants gridding *)
      XPos := PlotBndry.XMin;
      BGLineStyle(ccGray);
   End (* IF *)

   Else Begin (* User wants tick marks only *)
      XPos := YAxis.XPos1;
      TkLen := TkLen/50.0;
      BGLineStyle(ccBlack);
   End; (* Else *)

   (* Draw each tick mark or grid line in turn. *)
   With YAxis do Begin
      J := 1;
      Data := YAxis.Min + J*AxIncr;

      (* Check J only to prevent error of infinite loop *)
      While (Data < Max) AND (J < 50) Do Begin
         (* Plot the tick or grid mark *)
         YPos := YPosCalc(Data);
         MoveTo2D(XPos, YPos);
         Line2D(TkLen, 0.0);

         (* get the next data point. *)
         J    := J + 1;
         Data := YAxis.Min + J*AxIncr;
      End;
   end;

   BGLineStyle(ccBlack);
End; (* DrwYTicks *)


(*$S    *)
Procedure DrawAxes;
(* DrawAxes draws the X and Y axes and the tic marks or grid *)
Begin
   DrwXTicks;
   DrwYTicks;
   DrwXAxis;
   (* Only a line chart and scattergram display Y axis origin, and only if its offset from minimum *)
   DrwYAxis;
End;

(*$IFC DEBUGVERSION *)
(*$S BG2 *)
(*$ELSEC *)
(*$S    *)
(*$ENDC *)

Procedure BGDrawFrame;
(* Draws a frame around the entire graph, and grays outside of graph when
   drawing on the screen *)

CONST
   Fudge = 300;

VAR
   pt1,
   pt2      : Point;    (* upper left and lower right points of graphsize *)
   myRect   : Rect;
   BGScreen : Boolean;  (* True when drawing to the screen                *)

Begin
   PenNormal;
   With GraphSize do Begin
      BGMapPt(XMin, YMin, Pt1);
      BGMapPt(XMax, YMax, Pt2);
      Pt2Rect(Pt1, Pt2, myRect);
   end;

   { Fill the graph with white when printing }
   If (BGPrintFlag) Then EraseRect(myRect);

   (* Draw a frame on the screen or when printing or cutting a fractional page *)
   BGScreen := Not(BGPrintFlag OR BGCutFlag);
   If (BGScreen OR (GraphProportion <> Full)) Then Begin
      (* Draw the frame around the exterior of the graph *)
      FrameRect(myRect);
   end; (* If *)

   (* Gray the exterior of the graph if you're going to the screen *)
   If (BGScreen) Then Begin
      (* Set up and fill the top exterior rect *)
      SetRect(myRect, pt1.h-Fudge, pt1.v-Fudge, pt2.h+Fudge, pt1.v);
      FillRect(myRect, gray);

      (* Offset the rect to be the bottom rect *)
      OffSetRect(myRect, 0, pt2.v - pt1.v + Fudge);
      FillRect(myRect, gray);

      (* Set up and fill the left rect *)
      SetRect(myRect, pt1.h-Fudge, pt1.v, pt1.h, pt2.v);
      FillRect(myRect, gray);

      (* Offset the rect to be the right exterior rect *)
      OffSetRect(myRect, pt2.h - pt1.h + Fudge, 0);
      FillRect(myRect, gray);
   end; (* if *)
end; (* BGDrawFrame *)


(*$S    *)
Procedure BGDrwRSquare(I: Integer; XPos, YPos: Real);
(* Draws the rSquare figure for the Ith data rep slightly above or below
   position XPos, YPos *)
CONST
   Before  = 1;
   After   = 2;
   ShowSel = False;
   Erase   = True;

VAR
   myFontNum,
   Status     : Integer;
   Error      : Boolean;

Begin
   myFontNum := p15Tile;
   hExtraFld^^.align := Right;
   SetRunFormat(hExtraFld, Nil, myFontNum, setFont, Status);

   (* Convert the rSquare to chars *)
   RealtoBytes(RgrsArray[I].rSquare, hExtraFld^^.CurValue^, hExtraFld^^.Maxlen,
               Before, After, hExtraFld^^.CurLen, Error);
   {$IFC fDebug }
   If Error then Writeln('BG1/BGDrwRSquare has RealToBytes error');
   {$ENDC }

   (* Adjust the position so the text doesn't overlap the endpoint of the
      regression line. YPos is adjusted + or - 0.10 inch *)
   XPos := XPos - 0.05;
   If (RgrsArray[I].RSlope >= 0) Then YPos := YPos - 0.10
                                 Else YPos := YPos + 0.10;
   BGDrawFldAt(hExtraFld, XPos, YPos, ShowSel, Erase);
end;


(*$S    *)
Procedure DrwTextRgrsn;
(* Draws the regression lines for all the graphs with a text X axis - i.e. Bar,
BarLine, BarScat, StackBar, SolidBar, and TextAreaGraph *)
CONST
   SpaceFactor = 0.6;

VAR
   I,
   BarNum,                     (* Total # of bars in each cluster                  *)
   BarsSoFar  : Integer;       (* Number of bars done so far                       *)
   ClusterWidth,
   BarWidth,
   XShift     : Real;          (* Inches to shift the regression line to the right *)
   XPos,
   YPos       : Real;
   YVal       : Real;

Begin
   BarNum       := CalcNumBars;
   ClusterWidth := XAxis.Delta/BGData.XListTot;
   BarWidth     := ClusterWidth/(BarNum+2*SpaceFactor);
   BarsSoFar    := 0;

   (* Do each data rep, but only if regression is turned on *)
   For I := 1 to BGData.RepNum do Begin

      (* Remember how many bars we've gone through *)
      If (BarBoolean[I]) Then BarsSoFar := BarsSoFar + 1;

      (* Draw the regression line if the user turned it on *)
      If (RgrsBoolean[I]) Then With RgrsArray[I], XAxis do Begin
         XShift := ClusterWidth*0.5;

         (* Adjust the XShift as needed to place it directly over its corresponding bar *)
         If ((GType = Bar) OR (GType = SolidBar)) AND
            (BarBoolean[I]) Then XShift := (SpaceFactor + BarsSoFar - 0.5)*BarWidth;

         (* Calculate the X and Y coords and draw the line *)
         XPos := XPos1 + XShift;
         YVal := Intrcpt + RSlope;
         YPos := YPosCalc(YVal);
         Moveto2D(XPos, YPos);

         XPos := (XPos1 + Delta) - ClusterWidth + XShift;
         YVal := Intrcpt + RSlope*BGData.XListTot;
         YPos := YPosCalc(YVal);
         Lineto2D(XPos, YPos);

         (* draw the rSquared figure *)
         BGDrwRSquare(I, XPos, YPos);
      end;
   end;
end;


(*$S    *)
Procedure DrawRgrsn;
(* Draws the regression lines as needed.
It draws it if the boolean in RgrsBoolean (in aplc/mm/BGEnv) says to.
The slope, intercept, and rsquared are in RgrsArray (in apbg/BG1A)   *)
VAR
   XPos, YPos: Real;
   YVal      : Real;
   J         : Integer;

Begin
   If ((GType = LineGraph) OR (GType = Scatter) OR (GType = NumbAreaGraph)) Then Begin
      For J := 1 to BGData.RepNum do Begin
         If (RgrsBoolean[J]) Then Begin
            (* Calculate and move to the first point *)
            XPos := XPosCalc(XAxis.Min);
            With RgrsArray[J] do YVal := Intrcpt + RSlope*XAxis.Min;
            YPos := YPosCalc(YVal);
            Moveto2D(XPos, YPos);

            (* Calculate and draw to the second point *)
            XPos := XPosCalc(XAxis.Max);
            With RgrsArray[J] do YVal := Intrcpt + RSlope*XAxis.Max;
            YPos := YPosCalc(YVal);
            Lineto2D(XPos, YPos);

            (* Draw the rSquared value *)
            BGDrwRSquare(J, XPos, YPos);
         end;
      end;
   end
   Else If (GType <> Pie) Then Begin
      DrwTextRgrsn;
   end;
end;





(*$S    *)
Procedure DrawPlot;
(* DrawPlot draws the boundary, the axes, and the data reps     *)
Begin
   (* Always draw the pie circle. Remember the wedge labels are outside the circle *)
   If (GType = Pie) Then Begin
      DrawRep;
   end

   (* Draw the rest only if the PlotRect intersects the RefreshRgn *)
   Else Begin
      If RectInRgn(PlotRect, BGRefreshRgn) OR BGPrintFlag OR BGCutFlag Then Begin
         DrawAxes;           (* the axes and the grid if needed    *)
         if not BGPrintFlag then DrawBndry;          (* the plotting boundary if needed    *)
         DrawRep;
         if BGPrintFlag then DrawBndry;          (* the plotting boundary if needed    *)
      end;

      (* Draw the regression values as needed *)
      DrawRgrsn;
   End;
End;


(*$S     *)
Procedure BarXLabels;
(* BarXLabels draws the X axis labels for a bar chart *)

CONST
   WideFlg  = False;     (* CellValue does not want the wide angle view *)
   ShowSel  = False;     (* Dont show the selection when drawing label  *)
   Erase    = True;      (* whether to erase before redrawing field     *)

VAR
   ClusterWidth : Real;  (* World width of one cluster of bars          *)
   XPos,YPos    : Real;  (* world center position of one cluster        *)
   pt           : Point; (* LisaGraf point corresponding to (XPos,YPos) *)
   I      : Integer;     (* cntr to loop through each label             *)
   RowId,
   ColId  : Integer;     (* Indices into matmgr                         *)
   myFontNum: Integer;   (* large font if graph actual size, else small *)

   (* Vars returned by Matrix Managers CellValue call                   *)
   (* IMPORTANT: numBytes goes in as max, returned as current length    *)
   numBytes     : Integer;
   Status       : Integer;
   errNum       : integer;

Begin
   If (BGPreview or BGPrintFlag or BGCutFlag) Then myFontNum := p12Tile
                                              else myFontNum := p15Tile;

   {myHFld  := CreateField(nullRect, maxlngth, 0, center, 0, 1, 0, myFontNum, False);}
   hExtraFld^^.Align := Center;
   SetRunFormat(hExtraFld, Nil, myFontNum, SetFont, status);

   (* This starts the actual graphical calculations *)
   (* calc the cluster width (Axis length/(number in X list) )*)
   ClusterWidth := XAxis.Delta/BGData.XListTot;

   (* Calc the Y position of the labels *)
   YPos := GraphSize.YMax * YFctLaybl;

   (* draw out each label in turn *)
   For I := 1 to BGData.XListTot do Begin
      (* Calculate the center position of the Ith cluster *)
      XPos := XAxis.XPos1 + (I - 0.5) * ClusterWidth;
      numBytes := MaxLngth; (* ANOMALY: numbytes in as Max, returned as current *)

      (* Get a ptr to the text string in the matrix manager. numBytes and status
      are returned *)
      CellValue(mmRead, I, 1, hExtraFld^^.CurValue^, WideFlg, numBytes, status);

      {$IFC fDebug }
      If (Status <> 0) Then Writeln('***BG1/BarXLabels has error ',status);
      {$ENDC }
      BGStripBlanks(hExtraFld^^.CurValue^, numBytes, I, 1);
      hExtraFld^^.curlen := numBytes;

      (* MoveField sets the field's bounding rect for erasure *)
      BGDrawFldAt(hExtraFld, XPos, YPos, ShowSel, Erase);
   End; (* For loop *)
End; (* BarXLabel *)


(*$S    *)
Function FBGInteger(RealVal: Real): Boolean;
(* Returns true if RealVal is close to being an integer *)

VAR
   myLongInt: LongInt;

Begin
   myLongInt := Trunc(RealVal);
   FBGInteger := (myLongInt = RealVal);
end;



(*$S     *)
Procedure LineSctXLabels;
(* LineSctXLabels draws the labels along the X axis *)

CONST
   Erase   = True;
   ShowSel = False;

VAR
   XPos,YPos   : Real;       (* position for each label                       *)
   DataDelt    : Real;       (* data difference between two adjacent labels   *)
   XData       : Real;       (* Value of the X data point for the label       *)
   I           : Integer;    (* Cntr                                          *)
   XSpaces     : Integer;    (* # of labels -1, or # of spaces between labels *)
   myFontNum   : Integer;    (* large for actual size, else small             *)
   myPt        : Point;      (* point at right of field to justify to         *)
   Before,
   After       : Integer;    (* digits before and after the decimal place     *)
   Error       : boolean;    (* conversion error *)
   Status      : Integer;

Begin
   (* calc the fixed Y position of the labels and set up a field *)
   YPos := GraphSize.YMax * YFctLaybl;

   If (BGPreview or BGCutFlag or BGPrintFlag) Then myFontNum := p12Tile
                                              else myFontNum := p15Tile;
   {myHFld  := CreateField(nullRect, maxlngth, 0, Center, 0, 1, 0, myFontNum, False);}
   hExtraFld^^.Align := Center;
   SetRunFormat(hExtraFld, Nil, myFontNum, SetFont, status);

   With XAxis do Begin
      (* calculate the constants  *)
      DataDelt := AxIncr;

      (* Set number of decimal places to 0 for integer values, otherwise
         to a value dependent on the distance between labels *)
      Before := 9; (* 4/18/83 *)
      If (FBGInteger(Min) AND FBGInteger(DataDelt) AND FBGInteger(Max)) Then Begin
         After := 0;
      end
      Else Begin
         After := Trunc(-ALog10(DataDelt)) + 1;  (* ALog10 in apbg/graf2d *)
         If (After < 1) Then After := 1;
      end;

      (* output each label in turn *)
      I := -1;
      Repeat begin
         I := I + 1;
         (* Calc the X position. Negative X goes to the left *)
         XData := Min + I*DataDelt;
         BGMin(XData, Max);
         XPos := XPosCalc(XData);

         (* Convert the Y data point to bytes. (RealToBytes in FeGlobal) *)
         RealToBytes(XData, hExtraFld^^.curValue^, hExtraFld^^.maxlen,
                        Before, After, hExtraFld^^.CurLen, Error);

         {$IFC fDebug }
         If Error then Writeln('BG1/LineSctXLabels has RealToBytes error');
         {$ENDC }

         (* Print the field *)
         BGDrawFldAt(hExtraFld, XPos, YPos, ShowSel, Erase);
      End
      Until (XData >= Max) OR (I > 50); (* I > 50 on error condition only *)
   End; (* With *)
End; (* LineSctXLabels *)


(*$S     *)
Procedure YLabels;
(* YLabels draws the labels along the Y axis *)

CONST
   Erase   = True;
   ShowSel = False;

VAR
   XPos,YPos   : Real;       (* position for each label                       *)
   DataDelt    : Real;       (* data difference between two adjacent labels   *)
   YData       : Real;       (* Value of the Y data point for the label       *)
   I           : Integer;    (* Cntr                                          *)
   myFontNum   : Integer;    (* large for actual size, else small             *)
   myPt        : Point;      (* point at right of field to justify to         *)
   Before,
   After       : Integer;    (* digits before and after the decimal place     *)
   Error       : boolean;    (* conversion error *)
   Status      : Integer;

Begin
   (* calc the fixed X position of the labels and set up a field *)
   XPos := GraphSize.XMax * XFctYLaybl;

   If (BGPreview or BGCutFlag or BGPrintFlag) Then myFontNum := p12Tile
                                              else myFontNum := p15Tile;
   {myHFld  := CreateField(nullRect, maxlngth, 0, right, 0, 1, 0, myFontNum, False);}
   hExtraFld^^.Align := Right;
   SetRunFormat(hExtraFld, Nil, myFontNum, SetFont, status);

   With YAxis do Begin
      (* calculate the constants  *)
      DataDelt := AxIncr;   (* automatic float *)

      (* Set number of decimal places to 0 for integer values, otherwise
         to a value dependent on the distance between labels *)
      Before := 9;  (* changed 4/18/83 *)
      If (FBGInteger(Min) AND FBGInteger(DataDelt) AND FBGInteger(Max)) Then Begin
         After := 0;
      end
      Else Begin
         After := Trunc(-ALog10(DataDelt)) + 1;  (* ALog10 in apbg/Graf2d *)
         If (After < 1) Then After := 1;
      end;

      (* output each label in turn *)
      I := -1;
      Repeat Begin
         (* Calc the Y position. Negative Y goes up the page *)
         I := I +1;
         YData := Min + I*DataDelt;
         BGMin(YData, Max);
         YPos := YPosCalc(YData);

         (* Raise the first label slightly for a graph in third page size to avoid
            overlap with the first X axis label *)
         If (I = 0) Then begin
            If (GraphProportion = Third) Then YPos := YPos * 0.98;
         end;

         (* Convert the Y data point to bytes. (RealToBytes in BG1A) *)
         RealToBytes(yData, hExtraFld^^.curValue^, hExtraFld^^.maxlen,
                        Before, After, hExtraFld^^.CurLen, Error);
         {$IFC fDebug }
         If Error then Writeln('BG1/YLabels has RealToBytes error');
         {$ENDC }

         (* Print the field *)
         BGDrawFldAt(hExtraFld, XPos, YPos, ShowSel, Erase); (* in apbg/Ttl *)
      End
      Until (YData >= Max) OR (I > 50); (* I > 50 on error condition only *)
   End; (* With *)
End; (* YLabels *)



(*$S      *)
Procedure DrawLabels;
(* DrawLabels draws all the labels for the X and Y axes.
The value and placement of these labels is a function of
1. the user supplied data values
2. if the user set the XMin, XOrg, etc.
3. if the labels fit without overlapping each other     *)

Begin
   (* Branch off the type of graph *)
   Case GType of

      Bar, BarLine, BarScat, StackBar, SolidBar, TextAreaGraph:
         Begin
            BarXLabels;
            YLabels;
         End;

      LineGraph,Scatter, NumbAreaGraph:
         Begin
            LineSctXLabels;
            YLabels;
         End;

      Pie:
         Begin
           (* Do nothing since Pie labels are drawn with the Pie segments *)
         End;
   End; (* Case *)
End; (* DrawLabels *)


(*$S     *)
Procedure DrawGraph;
(* DrawGraph is the highest level graph drawing routine. It is the only
drawing routine available to the outside world *)

VAR
   BGPnlRect: Rect;
   Pt1, Pt2 : Point;
   GraphRgn : RgnHandle;

Begin (* DrawGraph *)
   ColorDefault;

   If (NOT BGPrintFlag) Then Begin
      SetPnlPort(BGPnl);
      SetRealPort(rp);
      BGSetGrfx;
   end;

   (* Note: BG1.0/BGCuttoGE and BG1.0/BGPrint both set BGRefreshRgn to the entire graph. *)
   If (BGCutFlag) OR (BGPrintFlag) Then SetClip(BGRefreshRgn)
   Else Begin
      (* clip to the intersection of the pnlrect and BGRefreshRgn *)
      GetPnlRect(BGPnl, BGPnlRect);
      RectRgn(gp^.clipRgn, BGPnlRect);
      SectRgn(gp^.ClipRgn, BGRefreshRgn, gp^.ClipRgn);
   end;

   (* Redraw the frame and the gray exterior *)
   BGDrawFrame;    (* draws the frame and the gray outside the graph *)

   (************************************************************************)
   (* Now clip further to the graphsize so all the text remains
      inside the graph. *)
   With GraphSize do begin
      BGMapPt(XMin, YMin, pt1);
      BGMapPt(XMax, YMax, pt2);
   end;
   Pt2Rect(pt1, pt2, BGPnlRect);
   GraphRgn := NewRgn;
   RectRgn(GraphRgn, BGPnlRect);
   SectRgn(gp^.cliprgn, GraphRgn, gp^.cliprgn);
   DisposeRgn(GraphRgn);

   (************************************************************************)
   (* Draw all the stuff inside the graph *)

   DrawPlot;       (* the boundary, axes, and data rep *)

   DrawLabels;     (* X and Y axis labels              *)

   DrawLegends;    (* all the legends as needed        *)

   DrawTitles;     (* main, sub, axis, and footnote    *)

   DrawAnnots;     (* user annots if he added any      *)

   (* Inverse highlight if user selected all and not drawing to scrap etc. *)
   If BGAllFlag Then
      If (BGActive) AND (NOT BGCutFlag) AND (NOT BGPrintFlag) Then BGInvertAll;  (* In apbg/Ttl      *)

   (************************************************************************************)
   (* Set the RefreshRgn back to the empty region *)
   SetEmptyRgn(BGRefreshRgn);
End;

(*$I apbg/BG1.0.text*)
