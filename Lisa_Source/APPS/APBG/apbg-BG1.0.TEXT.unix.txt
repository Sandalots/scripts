
                            {'Copyright 1983, 1984, Apple Computer Inc.'}

(*$S     *)
Procedure BGSetGSize( myGraphProportion: TGraphProportion);
(* Sets the graph size based on the current graph proportion e.g. full, third.
   The subtraction factor is to allow several to fit on the same page. *)

Begin
   With GraphSize do begin
      (* Note: PaperSize corresponds to the printable rect of the printer paper *)
      XMin := PaperSize.XMin;
      XMax := PaperSize.XMax;
      YMin := PaperSize.YMin;
      YMax := PaperSize.YMax;

      Case myGraphProportion of

         Full: Begin
         End; (* Full Case *)

         Half: Begin
            YMax := YMax/2.03;
         End; (* Half *)

         Third: Begin
            YMax := YMax/3.08;
         End; (* Third *)

         Quarter: Begin
            XMax := XMax/2.1;
            YMax := YMax/2.03;
         End; (* Quarter *)
      End; (* Case *)
   End; (* With *)
End; (* BGSetGsize *)


Procedure BGSetGrfx;
(* Sets all the BG viewing parameters.
   0. sets the ViewPort to the BGPnlRect
   1. Sets CurVis as a fnc of the size of the BGPnlRect,
   2. Sets GraphSize as a function of the PaperSize, GraphProportion,
      and preview mode.
   3. does a LookAt from Upper Left to CurVis
   4. resets the plot bndry and the axis positions
   5. resets the title and legend positions
                                                                       *)

VAR
   BGRect   : Rect;     (* Rect for the BG Panel                       *)
   ViewRect : Rect;     (* Rect in BGPnl on which to display the graph *)
   h, v     : Integer;  (* horiz and vertical size of BGRect           *)
   myPt     : Point;
   hThumb,
   vThumb   : TC;       (* horiz and vert thumb positions              *)
   XScale,              (* Scale factor to cnvrt Graph inches to BGPnl *)
   YScale   : Real;     (* GraphSize.XMax * XScale = BGPnl[X]          *)

Begin
   (* Set the graphsize *)
   BGSetGSize(GraphProportion);

   (* Get the BG panel rect and tell Graf2D where to draw *)
   SetPnlPort(BGPnl);
   If (BGCutFlag) Then GetPnlRect(ScrapPnl, BGRect)
                  Else GetPnlRect(BGPnl, BGRect);
   With BGRect do begin
      h := right - left;
      v := bottom - top;
   end;

   (* Calculate UpLeft, CurVis, and ViewRect *)
   If (BGPreview) Then Begin
      (* Full Size display. *)
      (* Calculate how many inches of the graph will be visible based on
         the size of BGPnl *)
      XCurVis := h/90.0;  (* 90.0 pixels/inch in X direction *)
      YCurVis := v/60.0;  (* 60.0 pixels/inch in Y direction *)

      (* Set XUpLeft and YUpLeft based on the elevators in the scroll bars *)
      hThumb  := CThumbPos(BGHsbH);
      vThumb  := CThumbPos(BGHsbV);
      XUpLeft := (GraphSize.XMax - XCurVis) * (hThumb/1000.0);
      YUpLeft := (GraphSize.YMax - YCurVis) * (vThumb/1000.0);

      (* Display to the entire BGPnl *)
      ViewRect := BGRect;
   end (* if *)

   Else Begin
      (* Reduced size display *)
      (* Want to look at entire graph in proportion. Either scale the
         X direction of the graph to the X direction of BGPnl, or scale
         the Y direction according to which is a better fit. *)

      (* Entire graph will be visible *)
      With GraphSize do begin
         XCurVis := XMax;
         YCurVis := YMax;
         XUpLeft := 0.0;
         YUpLeft := 0.0;
      end; (* With *)

      (* Calculate the scale factors based on the X direction *)
      XScale := h/XCurVis;
      YScale := XScale * 0.6666667; (* pixels are 2x3 in size *)

      (* If YCurVis scales outside the BGPnl, recalc the scale factors
      based on the Y direction *)
      If (YCurVis * YScale > v) Then Begin
         YScale := v/YCurVis;
         XScale := 1.5 * YScale;    (* pixels are 2x3 in size *)
      end;

      (* Calculate the viewport rectangle in the BGPnl *)
      With ViewRect do Begin
         Left   := (h - Trunc(XCurVis*XScale)) div 2;
         Right  := Left + Trunc(XCurVis*XScale);

         Top    := (v - Trunc(YCurVis*YScale)) div 2;
         Bottom := Top + Trunc(YCurVis*YScale);
      end;
   end; (* else *)

   (* Set up the viewing parameters *)
   LookAt(XUpLeft, YUpLeft, XUpLeft + XCurVis, YUpLeft + YCurVis);
   ViewPort(ViewRect);
   ViewAngle(0.0);

   (* Set the plotting boundary (fnc of legends on or off)   *)
   (* This needs to be called before you can set the position of the
     axes or the titles since those routines key of the plot boundary *)
   SetPlotBndry;
   SetAxes;
   SetTtlPos;
   SetLegPos;
   SetAnoPos;

   (* Reset the selected field point if there's a selection *)
   If (BGFld <> Nil) Then Begin
      BGGetPt(BGFld, BGFldX, BGFldY);
   end;

   SetPnlPort(BGPnl);
End;


Procedure InitGrfx;
(* InitGrfx sets up  RealGraf, and sets up the viewing parameters *)

VAR
     status     : integer;
Begin
   SetPnlPort(BGPnl);
   GetPort(gp);
   rp := @RPport;
   OpenRealPort(rp, gp);

   (* Set the graphProportion and set all the viewing parameters *)
   GraphProportion := Half;
   BGPreview := False;
   XUpLeft := 0.0;
   YUpLeft := 0.0;
   { 3/23/83 BGSetGrfx;  also sets TtlPos and LegPos }

   (* Set the RefreshRect and clip limits to the whole pane *)
   GetPnlRect( BGPnl, RefreshRect);
   RectRgn(BGRefreshRgn, RefreshRect);
   CopyRgn(gp^.ClipRgn, BGRefreshRgn);
End; (* InitGrfx *)



(*************************************************************************************)
procedure initBGPnl;
(* NOTE: BGFld = Pointer(-1) implies alloc all except the fields.
         BGFld = Pointer( 1) implies alloc just the fields.
         BGFld = Nil         implies just continue on with no allocs at all *)

(* initBGPnl inits the Business Graphics panel. More specifically, it
   1. sets the default data,
   2. sets the default labels,
   3. sets the axes defaults,
   4. inits the graphics parameters,
   5. finally draws the default graph.
                                            *)

Begin
   (* alloc all except the fields. 4/12/83 *)
   If (BGFld = Pointer(-1)) Then Begin
      SetPnlPort(BGPnl);
      InitState;

      (* These 3 calls were pulled out of BG1A/InitBGTable and InitBGTable was deleted *)
      SetDataDflt; (* in apbg/BG1B. It calls InitDataPtrs etc. *)
      SetPlotSize; (* sets dimensions of plotting area so you can place the axes *)
      SetAxesDflt;

      (* Init all the grfx state vars and the realport. *)
      InitGrfx;    (* in BG1.0. As of 3/23/83, this no longer allocs the fields at all *)
      SetPnlPort(BGPnl);

      (* init the scroll bar icons and thumbpos. These may get reset later in BG1.0/FxBGStuff
         when we read in the information saved in the file. *)
      SetSBIcons(BGHsbH, [IconSkewer]);
      SetSBIcons(BGHsbV, []);

      SetThumb(BGHsbH, 0);
      SetThumb(BGHsbV, 0);

      (* Remember we only have to alloc the fields now *)
      BGFld := pointer(1);
   end

   (* 4/12/83 Alloc the fields only if the sentinel says to. This will be the case only
   after the openmatrix call when there was no file to read in. *)
   Else if (BGFld = pointer(1)) Then Begin
      SetDfltTitles;
      SetDefaultLegends;
      BGFld := Nil;  (* says we're done with all allocation *)
   end
End; (* InitBGPnl *)



(*$S BGInit *)
procedure InitBGstorage;
var x : integer;
    y : boolean;
begin
   BGRefreshRgn := NewRgn;
   CommentHnd := pointer(ord(newHandle(sizeof(longint))));

   (* init the patterns. (in file apbg/Ttl) *)
   InitPatterns;
end;


(*$S     *)
Procedure EraseBG;
(* EraseBG erases the active area of the BG graph. It also has to
turn off any text hilighting or other things that could cause a
problem when redrawing the graph. *)

VAR
   myRgn: RgnHandle;
   hSaveRuns: hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont: Boolean;
   SaveSubDev : Integer;

Begin
   SetPnlPort(BGPnl);  (* sets clipping to the entire BGPnlRect *)

   If (BGFld <> Nil) Then Begin
      (* Turn off the selection and add the Coords into BGRefreshRgn *)
      myRgn := NewRgn;
      RectRgn(myRgn, BGFld^^.Coords);
      UnionRgn(BGRefreshRgn, myRgn, BGRefreshRgn);
      DisposeRgn(myRgn);

      (* Turn off hilighting, but note that hFldSt remembers the selection *)
      BGSwapRuns   (BGFld, hSaveRuns, SaveRunNumber, SaveSubFont, SaveSubDev);
      HiLightSel   (BGFld, hFldSt, False);
      BGInstallRuns(BGFld, hSaveRuns, SaveRunNumber, SaveSubFont, SaveSubDev);
   End;

   EraseRgn(BGRefreshRgn);
End;


Procedure BGDrawAll;
(* redraws the entire BG pane *)
Begin
   GetPnlRect(cBGPnl, RefreshRect);
   RectRgn(BGRefreshRgn, RefreshRect);
   EraseBG;
   DrawGraph;
end;


Procedure BGGraphSize(* newGraphProportion: tGraphProportion*);
(* BGGraphSize implements the size menu option. It resets the user's
view to the upper left corner of the graph, and redraws the graph
in the new size requested by the user *)

Begin (* BGGraphSize *)
   (* Only do it if the user has requested a different graph size *)
   If ( GraphProportion <> newGraphProportion) Then Begin

      SetProportion(newGraphProportion);  (* in apbg/BG1B *)

      (* Reset and redraw everything *)
      BGSetGrfx; (* adjusts all the grfx prams and scroll bar icons *)

      BGDrawAll;
   End; (* If *)
End; (* BGGraphSize *)


(*$S    *)
Procedure BGGetThumb{VAR XPerCent, YPerCent: Fract};
{ Returns the thumb positions of each scroll bar }
Begin
   XPerCent := CThumbPos(BGHsbH);
   YPerCent := CThumbPos(BGHsbV);
end;



(*$S BGscrolling *)
Procedure BGJump( HorV: THorV; Dest: Fract);
{ jumps to the given Dest in the Horiz or vertical direction }
VAR
   myPnlRect: Rect;

Begin
   If (HorV = BGHoriz) Then Begin
      SetThumb(BGHsbH, Dest);
   end
   Else Begin
      SetThumb(BGhsbV, Dest);
   end;
   BGSetGrfx;
   BGDrawAll;
End;


(*$S BGscrolling *)
Procedure BGScroll{ HorV: THorV; myScrollType: ScrollType;
                    theScrollDir: ScrollDir; VAR Dest: Fract} ;

(* procedure to scroll the graph when in preview mode. It's a no-op
   in reduced mode since then the whole graph is visible.
   Dest is the Thumb position after all ScrollTypes; additionally,
   its the Thumb input for a jump type. *)

VAR
   Factor  : Real;    { fraction of curVis to scroll over            }
   Dummy   : Fract;

   myMin,
   myMax   : Real;    { Min and Max to which to move UpLeft corner   }
   pt1,               { Lisagraf point where UpLeft starts           }
   pt2     : Point;   { Lisagraf point to which UpLeft gets scrolled }
   XOld,
   YOld    : Real;    { the old XUpLeft, YUpLeft                     }
   XNew,
   YNew    : Real;    { the new, estimated XUpLeft, YUpLeft          }

   BGPnlRect: Rect;

Begin
   SetPnlPort(BGPnl);
   { Do a scroll only if we're in preview mode. In non-preview the whole
     graph is visible so you don't have to scroll }
   If BGPreview then begin
      { call another routine to do thumb scrolling }
      If (myScrollType = jmpScroll) Then Begin
         BGJump( HorV, Dest);
      end

      Else Begin
         { scroll 0.1 of amount visible for incremental scroll,
           0.6 of amount visible for page scroll }
         If (myScrollType = IncrScroll)      Then Factor := 0.1
         Else if (myscrollType = pageScroll) Then Factor := 0.5
         Else Factor := 0.0;

         { reverse direction for scroll backwards }
         If (theScrolldir = scrollbak) Then factor := -factor;

         { Get the BG panel rect }
         GetPnlRect(BGPnl, BGPnlRect);
         XOld := XUpLeft;
         YOld := YUpLeft;

         { Change the thumb position of the appropriate scroll box
           if some of the graph is not visible in that direction }

         If (HorV = BGHoriz) AND (XCurVis < GraphSize.XMax) Then Begin
            { reset the thumb pos since BGSetGrfx computes the upper left
              corner of the visible area based on the thumb positions.
              NOTE: the formula below for computing Dest must agree with
              the formula in BGSetGrfx for computing the thumb position. }
            XNew := XUpLeft + factor * XCurVis;
            Dest := Trunc((1000*XNew)/(GraphSize.XMax - XCurVis));
            SetThumb(BGHsbH, Dest);
            BGSetGrfx;
         End

         Else If (HorV = BGVert) AND (YCurVis < GraphSize.YMax) Then Begin
            YNew := YUpLeft + factor * YCurVis;
            Dest := Trunc((1000*YNew)/(GraphSize.YMax - YCurVis));
            SetThumb(BGHsbV, Dest);
            BGSetGrfx;
         End;

         (* Reset, then erase and redraw using BGRefreshRgn as set above *)
         If (XOld <> XUpLeft) OR (YOld <> YUpLeft) Then Begin
            RectRgn(BGRefreshRgn, BGPnlRect);
            EraseBG;
            DrawGraph;
         end;
      End; (* Else on the incr or page scroll *)
   End; (* if on preview mode *)
End;



(*$S BGprint *)
Procedure BGPrint(thePrMode : PrMenuSuppress);
(* Sets up the viewing parameters for printing and prints the graph *)

VAR
   pt1,
   pt2        : Point;   (* upleft and lowright of graph rect in printer coords     *)
   graphRect  : Rect;    (* graph rect in printer coords                            *)
   nullRect   : Rect;

   IndeedPrint,
   isNewStyle : Boolean;
   savePreview: Boolean;
   VertPixels : Integer;  (* number of vertical pixels when the graph is printed    *)
   thePrPort  : TPrPort;
   myPrRect   : rect;

Begin
   SetPnlPort(BGPnl);

   {******************************************************************}
   {Get a print instance into LcPrIns. See if we really should print. }
   IndeedPrint := FPrInsDlg(CurConfig, IsNewStyle, thePrMode);

   If (IsNewStyle) Then Begin
      ResolveFont;          { In LCPr , to reconfigure the table }
      BGReconfig;           { In BG1.0 to reconfigure the graph  }
   end;

   If (IndeedPrint) Then Begin

      {********************************************************************************************}

      myPrRect := CurConfig.PrInfo.rPrintable;
      With PaperSize, CurConfig.PrInfo do begin

         (* Take the white space off the left side of myPrRect. Top side already OK.            *)
         myPrRect.Left := myPrRect.Left + Trunc(LeftWhite * hRes);

         (* Lower the top of myPrRect to center the picture vertically                          *)
         VertPixels := Trunc((YMax - YMin) * VRes);
         With myPrRect do myPrRect.Top := Top + ((Bottom - Top) - vertPixels) div 2;

         (* Now set up the right and bottom edges of myPrRect based on paper size.              *)
         (* Adjust myPrRect to have the same aspect ratio as the paper size.
            This is the inverse to the operation in BGReconfig below *)

         myPrRect.Right  := myPrRect.Left + Trunc((XMax - XMin) * HRes);
         myPrRect.Bottom := myPrRect.Top  + Trunc((YMax - YMin) * VRes)
      end;

      {*************************************************************************************}
      { Set the RefreshRgn to the whole print rectangle }
      RectRgn(BGRefreshRgn, myPrRect);

      { turn off hilighting if there's a selected field. This avoids a black hilight box on
        the printed page when DrawFldAt tries to erase the hilight }
      If (BGFld <> Nil) Then Begin
         SetRect(nullRect, 0, 0, 0, 0);
         ClipRect(nullRect);
         Hilightsel(BGFld, hFldSt, False);
      end;

      {*************************************************************************}
      { set up the transformations and rescale everything to printer dimensions }

      BGPrinting(True);   (* in Graf2D *)
      With PaperSize do Begin
         LookAt( XMin, YMin, XMax, YMax);
      end;
      ViewPort(myPrRect);

      (* Set the graph size to the true print size if it's not already *)
      SavePreview := BGPreview;
      If not BGPreview Then Begin
         BGSetGSize(GraphProportion);  (* in apbg/BG1.0 *)
      end;

      (* Set the plotting boundary (fnc of legends on or off)   *)
      (* This needs to be called before you can set the position of the
        axes or the titles since those routines key off of the plot boundary *)
      SetPlotBndry;
      SetAxes;
      SetTtlPos;
      SetLegPos;
      SetAnoPos;

      (* set up the graphrect in printer coords *)
      With GraphSize do Begin
         BGMapPt(XMin, YMin, pt1);
         BGMapPt(XMax, YMax, pt2);
         Pt2Rect(pt1, pt2, GraphRect);
      end;

      (**************************************************************************)
      (* tell the printing unit in PrProcs to start a document                  *)

      if PrDocStart(CurConfig, thePrPort, printLdsn, true) then begin

         (**************************************************************************)
         (* start the next page                                                    *)

         if PrPageStart(CurConfig, thePrPort) then begin
            ColorDefault;
            EraseRect(GraphRect);
            DrawGraph
         end;

         (**************************************************************************)
         (* end this page *)

         if PrPageEnd(CurConfig, thePrPort) then ;
      end;

         (**************************************************************************)

      (* End printing *)
      PrDocEnd(CurConfig, thePrPort);

      (**************************************************************************)
      (* Completely done with all printing *)
      (* Reset the graph size and all the other grfx prams *)
      BGPrinting(False);
      BGPreview := SavePreview;
      BGSetGrfx;

      (* refresh the screen *)
      ColorDefault;
      GetPnlRect(BGPnl, RefreshRect);
      RectRgn(BGRefreshRgn, RefreshRect);
      updFolder(true);


   End; (* if on IndeedPrint *)
end; (* BGPrint *)


(*$S BGCutPaste*)
Procedure BGCutToGE;
(* Proc to convert a graph into data the GE can understand, then write it
out to where the GE can read it. It uses the Picture handle capability of Lisagraf *)

VAR
   BGPnlRect   : Rect;
   PreviewSave : Boolean;
   mySaveHeap  : tHZ;        (* handle to save my heap while I write into the scrap heap *)
   scrErr      : integer;
   hThumbPos,
   vThumbPos   : TC;         (* to save the Thumb positions                              *)
   Pt1,
   Pt2         : Point;
   RectAll     : Rect;

Begin
   BGCutFlag := True;        (* remember we're cutting the graph to the scrap            *)

   (* Set the graph size to the true print size even in reduced mode. Save thumb positions *)
   PreviewSave := BGPreview;
   BGPreview := True;
   hThumbPos := cThumbPos(BGHsbH);
   vThumbPos := cThumbPos(BGHsbV);
   SetThumb(BGHsbH, 0);
   SetThumb(BGHsbV, 0);
   BGSetGrfx;

   (* Set the refreshRgn to the entire graph *)
   With GraphSize do Begin
      BGMapPt(XMin, YMin, Pt1);
      BGMapPt(XMax, YMax, Pt2);
      Pt2Rect(pt1, pt2, RectAll);
   end;
   RectRgn(BGRefreshRgn, RectAll);

   (* Make the scrap mine and get rid of the old data *)
   InheritScrap(True);
   EraseScrapData(scrErr);
   {$IFC fDebug }
   If (ScrErr<>0) Then Writeln('BG1.0/BGCutToGe EraseScrapData returned ', scrErr);
   {$ENDC }

   (* Save away the current heap zone, install the scrap's heap zone *)
   GetHeap(mySaveHeap);
   SetHeap(HzofScrap);
   StartPutScrap(scrErr);
   {$IFC fDebug }
   If (ScrErr<>0) Then Writeln('BG1.0/BGCutToGe Startputscrap returned ', scrErr);
   {$ENDC }

   (* Turn on the cut flag and draw the graph. All the picture records go into the scrap heap *)
   GetPnlRect(BGPnl, BGPnlRect);
   BGPicHandle := OpenPicture(RectAll);
   PicComment( cPicGeDwg, 0, Nil);
   DrawGraph;
   ClosePicture;
   {$IFC fDebug }
   If (BGPicHandle^^.PicSize < 0) Then Begin
      Writeln('BG1.0/BGCutToGE picsize = ', BGPicHandle^^.PicSize);
   end;
   {$ENDC }

   (* Install the handle into the scrap data structures. *)
   PutScrap(ScrapBGraf, pointer(ord(BGPicHandle)), scrErr);
   {$IFC fDebug }
   If (ScrErr<>0) Then Writeln('BG1.0/BGCutToGe putscrap returned ', scrErr);
   {$ENDC }

   PutGrScrap(Pointer(Ord(BGPicHandle)), scrErr);
   {$IFC fDebug }
   If (ScrErr<>0) Then Writeln('BG1.0/BGCutToGe putGrscrap returned ', scrErr);
   {$ENDC }

   EndPutScrap(scrErr);

   (* Draw the universal graphics picture in the scrap *)
   DrawUScrap(ScrErr);
   {$IFC fDebug }
   If (ScrErr<>0) Then Writeln('BG1.0/BGCutToGe DrawUScrap returned ', scrErr);
   {$ENDC }

   SetPnlPort(ScrapPnl);
   DrwScrScrollBars(ScrapFolder = ActiveFolder);

   (* Reinstall the saved heap zone, remember we've ended the cut operation *)
   SetHeap(mySaveHeap);
   BGCutFlag := False;

   (* Reset the graph size and all the other grfx prams *)
   SetPnlPort(BGPnl);
   BGPreview := PreviewSave;
   SetThumb(BGHsbH, hThumbPos);
   SetTHumb(BGHsbV, vThumbPos);
   BGSetGrfx;
end;


(*$S     *)
Procedure BGSetIcons(fPreview: Boolean);
VAR
   hIconSet,
   vIconSet: TSIcon;
Begin
   (************************************************************************)
   (* reset the scroll bar icons                                           *)

   If (fPreview) Then Begin
      hIconSet := [IconSkewer, IconArwA, IconPagA, IconThumb, IconPagB, IconArwB];
      vIconSet := [IconArwA, IconPagA, IconThumb, IconPagB, IconArwB];
   end
   else begin
      hIconSet := [iconSkewer];
      vIconSet := [];
   end;

   SetSBIcons(BGHsbH, hIconSet);
   SetSBIcons(BGHsbV, vIconSet);
end;



Procedure BGSetPreview(NewBGPreview: Boolean);
(* NewBGPreview True says to set the Graph to its real size, otherwise reduce
   the graph isotropically to fit into the BGPnl.        *)

Begin
   (* do something only if the user is changing the mode *)
   If (BGPreview <> NewBGPreview) Then Begin

      (* reset and repaint the icons                     *)
      BGSetIcons(NewBGPreview);
      SetPnlPort(FolderPnl);
      PaintSB(BGHsbH);
      PaintSB(BGHsbV);
      SetPnlPort(BGPnl);

      (* Change the preview mode *)
      SetPreview(NewBGPreview);         (* in apbg/BG1B     *)
      BGSetGrfx;

      (* redraw the graph *)
      BGDrawAll;
   end;    (* if *)
end; (* BGSetPreview *)


Procedure DoBGXFilePrint(MenuIndex, MenuItem: Integer; thePrMode : PrMenuSuppress);
{ aplc/NewMenus/DoBGFilePrint does most of these. Currently this routine just
  has to perform printing the graph }

Begin
   if (menuItem = BGPrintGraph) or (menuItem = BGPrintDoc) then begin
      BGPrint(thePrMode);
   end; { if on status }
End; (* BGFile/Print*)


(*$S BGCutPaste*)
Procedure DoBGCopy;
VAR
   errnum: integer;

Begin
   If (BGFld <> Nil) Then Begin
      (* copy the current selection. False says Copy, True says
      put it into the scrap  *)
      CutCopyField(BGFld, hFldSt, False, True, errNum);
      If (errnum = 0) Then begin
         ClrUndo;
         SetUndo(uBGCopy, BGPnl);
         uBGFld := BGFld;  (* Remember the field to undo *)
      end
      else begin
         editTried(errNum);  (* error reporter in aplc/LCExecsubs *)
      end;
   End (* If *)

   Else if (BGAllFlag) Then Begin
      ClrUndo;
      BGCuttoGE;
      SetUndo(uBGCopyGraph, BGPnl);
   end

   Else Begin
      DoStopAlert(20031);
   End (* Else *)
End; (* feCopy Case *)


(*$S BGCutPaste*)
Procedure DoBGEdits(MenuIndex, MenuItem: Integer);
(* Performs the functions in the BG edits menu *)
CONST
   ShowSel = False;

VAR
   errnum       : integer;
   myRefreshRgn : RgnHandle;
   Rgn1,
   Rgn2         : RgnHandle;  (* old and new field coords during a Paste *)
   myPt         : Point;
   hSaveRuns    : hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;
   mySKind      : scrapKind;
   ScrapVal     : Array[0..maxlngth] of byte;
   numbytes,
   i            : integer;


{ does the edit menu for BG }
Begin
   Case MenuItem of
      BGUndoLast: Begin
         DoBGUndo;           { apbg/BG1.0 }
      end;

      BGRstrEntry: Begin
         TERestore;        { in aplc/TEExec }
      end;

      { Null item }

      BGCopy: Begin
         DoBGCopy;
      End;

      BGCut: Begin
         If (BGFld <> Nil) Then Begin

            (* cut the current selection. True says Cut, True says put it into the scrap  *)
            CutCopyField(BGFld, hFldSt, True, True, errNum);
            If (errnum = 0) Then Begin
               ClrUndo;
               SetUndo(uBGCut, BGPnl);
               uBGFld := BGFld; (* remember the field to undo *)
               BGEraseFld;
            end
            else begin
               EditTried(errNum);
            end;
         End (* If *)
         Else Begin
            doNoteAlert(20018);
         End; (* Else *)
      End; (* cut case *)

      BGPaste: Begin
         If (BGFld <> Nil) Then Begin
            (* Remember the old coords *)
            Rgn1 := NewRgn;
            RectRgn(Rgn1, BGFld^^.Coords);

            (* If there's a cell range in the scrap then I'll paste the text from cell 1 *)
            GetScrKind(mysKind);
            If (mySKind = cellsKind) Then Begin
               numBytes := maxLngth;
               If (aRgInScrap(@scrapVal, True, Numbytes)) Then Begin
                  For i := 0 to numbytes -1 do Begin
                     InsCh(Chr(scrapVal[i]), BGFld, hFldSt, errNum);
                  end;
               end
               else errNum := invScrapType;  (* shouldn't happen *)
            end

            (* else call the Field editor to paste the text *)
            else begin
               PasteField(BGFld, hFldSt, errnum, True, 80);
            end;

            If (Errnum = 0) Then Begin
               BGMapPt(BGFldX, BGFldY, myPt);
               BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
               BGAdjFld(BGFld, myPt);   (* adjust the vertical alignment *)
               MoveField(BGFld, hFldSt, myPt);
               BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

               (* Get the new coords *)
               Rgn2 := NewRgn;
               RectRgn(Rgn2, BGFld^^.Coords);

               (* Subtract the regions. Redraw just the field if the field got bigger.
                  Refresh the whole screen if the field got smaller, since something in
                  the background may have appeared. *)
               DiffRgn(Rgn1, Rgn2, Rgn1);
               If (EmptyRgn(Rgn1)) Then BGDrawFldAt(BGFld, BGFldX, BGFldY, True, True)
                                   else UnionRgn(Rgn1, BGRefreshRgn, BGRefreshRgn);

               DisposeRgn(Rgn2);

               (* set up the undo buffers *)
               ClrUndo;
               SetUndo(uBGPaste, BGPnl);
               uBGFld := BGFld;
            end
            else Begin
               EditTried(errNum);  (* error reporter in aplc/LCexecsubs *)
            end;

            DisposeRgn(Rgn1);
         End (* If *)
         Else Begin
            doNoteAlert(20019);
         End; (* Else *)
      End; (* Paste case *)

      { Null menu item }

      BGClr: Begin
         If (BGFld <> Nil) Then Begin

            ClearField(BGFld,  hFldSt,  errnum);
            If (Errnum = 0) Then Begin
              ClrUndo;
              SetUndo(uBGClr, BGPnl);
              uBGFld := BGFld;
               BGEraseFld;
            end
            else begin
               EditTried(errNum);   (* error reporter in aplc/LCExecsubs *)
            end;
         End;
      End; (* BGClr case *)

      { null menu item }

      { Insert blank row/column handled by NewMenu/Menucommand }

      SelecTable: Begin
         { exit any BG selection, let LC handle selecting the table }
         BGExit;
         ClrUndo;

         g.LastActPnl := g.ActivePnl;
         g.ActivePnl := cTblPnl;
      end;

      SelecGraph: Begin
         (* End the Tbl Editor selection and the current range in Lisacalc panel *)
         If (ForceEnter(errNum) = 0) Then Begin
            GetCR(G.curRange);    (* Tell fexec about it also  *)
            ChgStatPnl(False);    (* redraw the status panels  *)

            (* Make BGPnl the active one *)
            g.LastActPnl := g.ActivePnl;
            g.ActivePnl  := cBGPnl;

            ClrUndo;
            BGExit;               (* in apbg/Ttl *)
            BGInvertAll;          (* in apbg/Ttl *)
            BGAllFlag := True;
         end;
      end;


      otherwise begin
         {$IFC fDebug }
         writeln('BG1.0/DoBGEdits has illegal edit command');
         {$ENDC }
      end;
   End; (* Case *)
end;


(*$S BGTypeStyle *)
Procedure BGCkNewStyle(FontNum: Integer);
(* If substitution occurs with this font then put up an alert *)
VAR
   trialFont: TLFntId;
   cError   : Integer;

Begin
   (* build a long font ID in trialfont *)
   PrLFntId(curConfig, FontNum, [], trialFont);

   (* Map it. A negative error code -> the font mgr mapped the font to another font  *)
   FMMapFont(trialfont, cError);

end;

(*$S BGTypeStyle *)
Procedure DoBGTypeStyle(MenuIndex, MenuItem: Integer);
(* Does the BG typestyle menu items *)
VAR
   errnum: integer;
   Rgn1,
   Rgn2      : RgnHandle;
   myPt      : Point;
   myRect,
   BGPnlRect : Rect;
   myBool    : Boolean;
    myPlain        : Boolean;
    myRun          : Run;
   myFontNum,
   myFormat  : Integer;
   TrialFont : TLFntId;
    myInterval     : Interval;

   hSaveRuns: hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont: Boolean;
   SaveSubDev : Integer;

Begin
   If (BGFld <> Nil) Then Begin
      ClrUndo;
      myFontNum := 0;
      myFormat  := SetFont;
      myInterval := hFldSt^^.select.int;
      myInterval.LPLim := myInterval.LPLim - 1;
      FmtFromInt(BGFld, hFldSt, myInterval, myPlain, myRun);

      Case MenuItem of
         BGPlainText    : myFormat := SetNormal;
         BGUnderLine    : myFormat := SetUnderLine;
         BGBold         : myFormat := SetBold;
         BGItalic       : myFormat := SetItalics;
         BGHollow       : myFormat := SetOutline;
         BGShadow       : myFormat := SetShadow;

         7              : Begin (* null item *) end;
         BGClassic      : myFormat := setToClassic;
         BGmodern       : myFormat := setToModern;
         10             : Begin (* null item *) end;

         BG20Pitch      : myFontNum := p20Tile;
         BG15Pitch      : myFontNum := p15Tile;
         BG12Pitch      : if g.ModernFont then myFontNum := p12Tile
                          else myFontNum := p12Cent;
         BG10Pitch      : if g.ModernFont then myFontNum := p10Tile
                          else myFontNum := p12cent;
         BG12Point      : if g.ModernFont then myFontNum := tile12
                          else myFontNum := cent12;
         BG14Point      : if g.ModernFont then myFontNum := 15
                          else myFontNum := 15;
         BG18Point      : if g.ModernFont then myFontNum := tile18
                          else myFontNum := cent18;
         BG24Point      : if g.ModernFont then myFontNum := tile24
                          else myFontNum := cent24;
      end; (* Case *)

      (* Check the fontnum for font substitution, possibly put up an alert and redraw graph *)
      If (myFontNum <> 0) then BGCkNewStyle(myFontNum);
      SetPnlPort(BGPnl);

      (**************************************************************************************)
      (* prepare for and redraw the field                                                   *)

      (* Union the field's old Coords into BGRefreshRgn *)
      GetPnlRect(BGPnl, BGPnlRect);
      myBool := SectRect(BGFld^^.Coords, BGPnlRect, myRect);
      Rgn1 := NewRgn;
      RectRgn(Rgn1, myRect);
      UnionRgn(Rgn1, BGRefreshRgn, BGRefreshRgn);

      (* Turn off the selection (BGSwapRuns will enable font subbing if needed) *)
      BGSwapRuns(BGFld, hSaveRuns, SaveRunNumber, SaveSubFont, SaveSubDev);
      HiLightSel(BGFld, hFldSt, False);
      BGInstallRuns(BGFld, hSaveRuns, SaveRunNumber, SaveSubFont, SaveSubDev);

      (* update the selected field, get its new position. NOTE: This UpdateRuns call must be
      applied when the real runs info is installed in BGFld ( i.e. NOT when hSmallRun is
      installed as the Run handle ). Therefore, the user can only change the typestyle in
      full size display. *)
      UpdateRun(BGFld, hFldSt, myFontNum, myFormat, errNum);
      BGMapPt(BGFldX, BGFldY, myPt);

      (* Union the field's new Coords into BGRefreshRgn *)
      BGSwapRuns(BGFld, hSaveRuns, SaveRunNumber, SaveSubFont, SaveSubDev);
      BGAdjFld(BGFld, myPt);  (* in apbg/Ttl to adjust the vertical alignment *)
      MoveField(BGFld, hFldSt, myPt);
      BGInstallRuns(BGFld, hSaveRuns, SaveRunNumber, SaveSubFont, SaveSubDev);

      myBool := SectRect(BGFld^^.Coords, BGPnlRect, myRect);
      RectRgn(Rgn1, myRect);
      UnionRgn(Rgn1, BGRefreshRgn, BGRefreshRgn);

      (* dispose of the region *)
      DisposeRgn(Rgn1);

      (* Remember what to undo *)
      SetUndo(uBGTypeStyle, BGPnl);
      uBGFld := BGFld;
   end;
end;


(*$S    *)
Procedure DoBGPageLayout(MenuIndex, MenuItem: Integer);
Begin
   Case MenuItem of
      {BGCWidth: should be handled for the LC table in NewMenus/MenuCommand }

      { delineation line }

      BGFull   : BGGraphSize(Full);

      BGHalf   : BGGraphSize(Half);

      BGThird  : BGGraphSize(Third);

      BGQuarter: BGGraphSize(Quarter);

      {delineation line. Do nothing };

      BGActual : BGSetPreview(True);

      BGReduced: BGSetPreview(False);

         {$IFC fDebug }
      { delineation line }

      11: BGPrint(ePrNorMal);   { temporary till real printing }

      OtherWise Begin
         Writeln('***BG1.0/DoBGPageLayout: unknown item ', menuitem);
      end;
         {$ENDC }
   End; (* Case *)
end;


Procedure DoBGGType(MenuIndex, MenuItem: Integer);
{ handles the graph type menu for BG }

VAR
   myHiCol : Integer;
   I       : Integer;
   Status  : Integer;
   rg      : Range;

Begin
   Status := OK;
   SetRg(rg, aWTBoxRg, minfsnip, minfsnip, pinfsnip, pinfsnip);
   Case MenuItem of
      BGBar: Begin(* User chose the Bar menu item *)
         (* Set the entire graph to a Bar chart if not already bar. *)
         If (GType <> Bar) Then Begin
            SetType(Bar);
            UnsortData(Status);
            BGRgChged(rg);
            BGNewRgImg;
         End; (* If *)
      end;

      BGLine: Begin(* User chose the Line Menu item *)
         (* Set to line chart if X column is all numbers, else barline *)
         If (Gtype = LineGraph) or (GType = BarLine) Then Begin
            (* Do Nothing *)
         End

         Else Begin
            (* Linegraph if X column all numbers, else a barline graph*)
            If BGXAllNumbers Then Begin
               (* Set to linegraph *)
               SetType(LineGraph);
               UnsortData(Status);
               SortData(Status);
               BGRgChged(rg);
               BGNewRgImg;
            End (* If *)
            Else Begin
               (* Set to barline *)
               SetType(BarLine);
               UnsortData(Status);
               BGRgChged(rg);
               BGNewRgImg;
            End; (* Else *)
         End; (* else *)
      end;

      BGScatter: Begin(* User selected the scatter menu item. *)
         (*Set to scatter if X column is all numbers, else to barscat *)
         If (GType = Scatter) or (GType = BarScat) Then Begin
            (* Do nothing *)
         end

         Else Begin
            (* set to scatter if X col all numbers, else barscat *)
            If BGXAllNumbers Then Begin
               (* Set to scatter *)
               SetType(Scatter);
               UnsortData(Status);
               SortData(Status);
               BGRgChged(rg);
               BGNewRgImg;
            end
            Else Begin
               (* Set to BarScat *)
               SetType(BarScat);
               UnSortData(Status);
               BGRgChged(rg);
               BGNewRgImg;
            end;
         end;
      end;

      BGPie: Begin
         (* Set to pie chart. Sort data from largest to smallest on Y *)
         If (GType <> Pie) Then Begin
            SetType(Pie);
            Unsortdata(Status);
            BGRgChged(rg);
            BGNewRgImg;
         End; (* If *)
      end;

      BGStackBar: Begin(* User chose the Stacked Bar menu item *)
         (* Set the entire graph to a Stacked Bar chart if not already *)
         If (GType <> StackBar) Then Begin
            SetType(StackBar);
            UnsortData(Status);
            BGRgChged(rg);
            BGNewRgImg;
         End; (* If *)
      end;

      BGSolidBar: Begin(* User chose the Stacked Bar menu item *)
         (* Set the entire graph to a Stacked Bar chart if not already *)
         If (GType <> SolidBar) Then Begin
            SetType(SolidBar);
            UnsortData(Status);
            BGRgChged(rg);
            BGNewRgImg;
         End; (* If *)
      end;


      BGAreaGraph: Begin(* User chose the Area Menu item *)
         (* Do something only if it's not already an area graph *)
         If (NOT ((GType = NumbAreaGraph) OR (GType = TextAreaGraph))) Then Begin

            (* Set to NumbAreaGraph if X column all numbers, else a TextAreaGraph *)
            If BGXAllNumbers Then Begin
               (* All numbers in the X column *)
               SetType(NumbAreaGraph);
               UnsortData(Status);
               SortData(Status);
               BGRgChged(rg);
               BGNewRgImg;
            End (* If *)

            Else Begin
               (* have some text in the X data column *)
               SetType(TextAreaGraph);
               UnsortData(Status);
               BGRgChged(rg);
               BGNewRgImg;
            end;
         End; (* else *)
      end;

      Otherwise Begin
         {$IFC fDebug }
         Writeln('*** BG1.0/DoBGGtype: Illegal graph type.');
         {$ENDC }
      end;
   End; (* Case *)

   {make sure column titles reflect the new graph type}
   if (oldGtype <> Gtype) and ((GType = Pie) or (oldGType = Pie)) then begin
      SetRg(rg, aRowRg, mInfSnip, 1, mInfSnip, 9);
      NewRgImg(rg)
   end;
end;



Procedure DoBGOptions(MenuIndex, MenuItem: Integer);
{ handles the customize menu items }

VAR
   myBool    : Boolean;
   myDummy   : Boolean;
   myPnlRect : Rect;
   myHiCol,
   I         : Integer;
   myRg      : Range;


   Procedure SaveBGBoolean(VAR OldBool: tBoolArray; BooltoSave: tBoolArray);
   VAR
      I: Integer;
   Begin
      For I := 1 to YListMax do OldBool[I] := BooltoSave[I];
   end; (* SaveBGBoolean *)

Begin
   Case MenuItem of

      BGGridOn,
      BGGridOff: Begin (* Turn on/off the grid *)
         myBool := (MenuItem = BGGridOn);

         If (myBool <> XAxis.Grid) Then Begin
            SetBGGrid(myBool, myBool); (* in apbg/BG1B *)

            (* Redraw the graph if it's not a pie chart *)
            If (GType <> Pie) Then Begin
               GetPnlRect(BGPnl, myPnlRect);
               myDummy := SectRect( PlotRect, myPnlRect, RefreshRect);
               RectRgn(BGRefreshRgn, RefreshRect);
               EraseBG;
               DrawGraph;
            End;
         End; (* If *)
      End;

      BGLegOn,
      BGLegOff: Begin (* Turn legends on/off. *)
         myBool := (MenuItem = BGLegOn);
         If (myBool <> Legends.LegendFlag) Then Begin
            (* Exit the legend if its selected (in apbg/Ttl) *)
            If LegSelect Then BGExit;

            (* Reset the state var and the menu checkbox *)
            SetBGLegends(myBool);       (* in apbg/BG1B *)

            (* Reset the plot boundary and axes etc. *)
            BGSetGrfx;

            (* Redraw the graph if it's not a pie chart *)
            If (GType <> Pie) Then Begin
               BGDrawAll;
            End;
         End;
      End;


      BGYaxSpec: Begin (* Y Axis specification *)
            (* in file BG1B. Filters down to BG1B/PutAxisBox which does EnterCalc etc. *)
            BGYAxMenu;
      End;


      BGXAxSpec: Begin (* X Axis specification *)
            BGXAxMenu; (* in file BG1B *)
      End;


      BGShowLine,
      BGShowBar: Begin
         myBool := (MenuItem = BGShowBar);

         (* The next line of code assumes that the Show As Bar/Line menu items are enabled only
            for the various types of bar graphs (e.g. bar, stackedbar, and solidbar). Otherwise,
            you must insert an If test here to see if GType= Bar OR GType=stackbar etc. *)

         If (g.ActivePnl = cTblPnl) AND (g.CurRange.rKind = aColRg) then With g.curRange do Begin
            If (2 <= loCol) and (loCol <= 9) Then Begin
               SaveBGBoolean(OldBarBoolean, BarBoolean); (* save the old one for the undo *)
               ClrUndo;
               SetUndo(uBGHybrid, BGPnl);

               myHiCOl := CMin(HiCol, 9);
               For I := loCol to myHiCol do Begin
                  BarBoolean[I-1] := myBool;
               end;

               (* Check the y axis range, redraw *)
               SetRg(myRg, aWTBoxRg, minfsnip, minfsnip, pinfsnip, pinfsnip);
               CkAxes(myRg);
               BGDrawAll;
            end;
         end
      End;

      BGRgrsOn,
      BGRgrsOff: Begin
         myBool := (MenuItem = BGRgrsOn);

         (* Turn the regression booleans on or off *)
         If (g.ActivePnl = cTblPnl) AND (g.CurRange.rKind = aColRg) then With g.curRange do Begin
            If (2 <= loCol) and (loCol <= 9) Then Begin
               SaveBGBoolean(OldRgrsBoolean, RgrsBoolean); (* save the old one for the undo *)
               ClrUndo;
               SetUndo(uBGRgrsn, BGPnl);

               myHiCOl := CMin(HiCol, 9);
               For I := loCol to myHiCol do Begin
                  RgrsBoolean[I-1] := myBool;
               end;

               (* Check the y axis range, redraw *)
               SetRg(myRg, aWTBoxRg, minfsnip, minfsnip, pinfsnip, pinfsnip);
               CkAxes(myRg);
               BGDrawAll;
            end;
         end
      end;

      BGMarkOn,
      BGMarkOff: Begin
         myBool := (MenuItem = BGMarkOn);
         If (myBool <> BGMarkFlag) Then Begin

            (* Reset the state var and the menu checkbox *)
            SetBGMark(myBool);       (* in apbg/BG1B *)

            (* Reset the plot boundary and axes etc. *)
            BGSetGrfx;

            (* Redraw the graph if it's not a pie chart *)
            If NOT((GType = Pie) OR (GType = Scatter))Then Begin
               BGDrawAll;
            End;
         End;
      End;


      Otherwise begin
         {$IFC fDebug }
         (* Illegal number *)
         Writeln('*** BG1.0/DoBGOption: illegal option');
         {$ENDC }
      End; (* Else case *)
   End; (* Case *)
End;


(*$S     *)
Procedure BGMenuCommand(* MenuIndex, MenuItem: Integer; thePrMode : PrMenuSuppress *);
(* BGMenuCommand processes the case where the user enters a menu command.
The actual command is located by the MenuIndex title, and the MenuItem
item beneath that title *)

VAR
   myBool   : Boolean;
   errnum   : integer;    (* error number for the field edit routines *)
   myDummy  : Boolean;
   myPnlRect: Rect;    (* rect for BG Pnl *)
   myRg     : Range;   (* set to whole table range to change data list dir *)


Begin
   BGPnlPort;   (* in apbg/Ttl *)
   Case MenuIndex of
      (* File/Print Menu *)
      BGFilePrint     : DoBGXFilePrint(MenuIndex, MenuItem, thePrMode);

      BGEdits         : DoBGEdits(MenuIndex, MenuItem);

      BGTypeStyle     : DoBGTypeStyle(MenuIndex, MenuItem);

      MenuBGPageLayout: DoBGPageLayout(MenuIndex, MenuItem);

      BGFormat        : {$IFC fDebug }
                        Writeln('BGMenuCommand stub for format')
                        {$ENDC } ;

      MenuBGType      : DoBGGType(MenuIndex, MenuItem);

      MenuBGOptions   : DoBGOptions(MenuIndex, MenuItem);

      (* Unknown index *)
      Otherwise begin
         {$IFC fDebug }
         Writeln('*** BG1.0/BGMenuCommand has unknown index ', MenuIndex);
         {$ENDC }
      End;
   End; (* Case *)
End; (* BGMenuCommand *)



(*$S BGAxis *)
Procedure BGYAxCk(* NewMin, NewOrg, NewMax : Real; NewIncr: Real;
                    NewMinSet, NewOrgSet, NewMaxSet, NewIncrSet: Boolean *);
(* BGYAxCk checks the new values the user entered are consistent
and recalcs the Y axis and redraws the graph as necessary *)

Begin

   (* Store away the newly entered axis values *)
   With YAxis do Begin
      MinSet := NewMinSet;
      If MinSet Then Min := NewMin;

      OrgSet := NewOrgSet;
      If (OrgSet) Then begin
         Org := NewOrg;

         (* Set Org to standard if it's below the minimum *)
         If (MinSet and (Org < Min)) Then Begin
            OrgSet := False;
            doStopAlert(20011); { illegal Y axis origin }
         end;
      end;

      MaxSet := NewMaxSet;
      If MaxSet Then begin
         Max := NewMax;

         (* Set Max to standard if it's below the minimum *)
         If MinSet and (Max <= Min) Then Begin
            MaxSet := False;
            doStopAlert(20012);
         end

         (* Set Max to standard if it's below the origin *)
         Else If OrgSet and (Max < Org) Then Begin
            MaxSet := False;
            doStopAlert(20013);
         end;
      end;

      AxIncrSet := NewIncrSet;
      If AxIncrSet Then UserAxIncr := NewIncr;
   End; (* With *)

   (* recalc all the axis values (in apbg/BG1B) *)
   RecalcYAxis;

   (* Erase and redraw *)
   BGDrawAll;
End; (* BGYAxCk *)


(*$S BGAxis *)

Procedure BGXAxCk(* NewMin, NewOrg, NewMax : Real; NewIncr: Real;
                    NewMinSet, NewOrgSet, NewMaxSet, NewIncrSet: Boolean *);
(* BGXAxCk checks the new values the user entered are consistent
and recalcs the X axis and redraws the graph as necessary *)
VAR
   aRg: Range;

Begin
   (* Store away the newly entered axis values *)
   With XAxis do Begin
      MinSet := NewMinSet;
      If MinSet Then Min := NewMin;

      OrgSet := NewOrgSet;
      If (OrgSet) Then begin
         Org := NewOrg;

         (* Set Org to standard if it's below the minimum *)
         If (MinSet and (Org < Min)) Then Begin
            OrgSet := False;
            doStopAlert(20014); { illegal X axis origin }
         end;
      end;

      MaxSet := NewMaxSet;
      If MaxSet Then begin
         Max := NewMax;

         (* Set Max to standard if it's below the minimum *)
         If MinSet and (Max <= Min) Then Begin
            MaxSet := False;
            doStopAlert(20015);
         end

         (* Set Max to standard if it's below the origin *)
         Else If OrgSet and (Max < Org) Then Begin
            MaxSet := False;
            doStopAlert(20016);
         end;
      end;

      AxIncrSet := NewIncrSet;
      If AxIncrSet Then UserAxIncr := NewIncr;
   End; (* With *)

   (* Recalculate the X axis values. Since adding the regression feature on 10/26/83,
      RecalcXAxis also calls CkYAxisRange to possibly reset the Y axis values. *)
   RecalcXAxis;

   (* Erase and redraw *)
   BGDrawAll;
End; (* BGXAxCk *)


(*$S   *)
procedure BGNewRgImg;
        { For Business Graphics, it determines the current size of the
        data table and sets up how many data values to plot. Then it
        replots the graph accordingly.
        NOTE: BGNewRgImg looks at BGRange, a global variable maintained
        with calls to BGRgChged. }

VAR
   mystatus: Integer;

Begin
(*$IFC fDebug *)
   if tracing then LCtraceMess(177);
(*$ENDC *)

   (* When rp = Nil it means that Realgraf has not been initted yet so
   we are still initting the data values. Therefore don't redraw
   the graph.

   Note: BG1A/SetDataDflt sets rp to nil just prior to initting the
   data values with the Matmgr calls. BG1.0/InitGrfx sets rp to
   non-nil by calling OpenRealPort, which means that we're now
   ready to start drawing the graph. *)

   If (rp <> nil) Then Begin
      myStatus := OK;

      (* reset BGData.XListTot and BGData.RepNum to the
      current limits of the data in the data table *)
      AdjTblLimits;                         (* in BG1A *)

      (* Ck if the graph type should change (e.g. the user entered
         a text value into the X column that was all numbers ) *)
      BGCkXCol(BGRange, mystatus);          (* in BG1A *)

      (* If needed, adjust the linked data lists. Returns true if redraw required. *)
      If AdjDataLists(BGRange, mystatus) Then Begin        (* in BG1A *)

         (* If status is OK, then Reset the axes and redraw the graph *)
         If (myStatus = OK) Then Begin
            (* Check that the axes are properly arranged              *)
            CkAxes(BGRange);                               (* In BG1B *)
            BGDrawAll;
         end;

      end;

      If (myStatus <> OK) Then DoStopAlert(20028);

      (* set BGRange back to the null range *)
      BGRange.rKind := aNullRg;
      FixRange(BGRange);
    End; (* If *)
end; (* BGNewRgImg *)


procedure BGRgChged {aRg: range};
(* remembers the range of table cells that have changed since the last call to BGNewRgImg.
   Basically it merges a new aRg into the old existing global BGRange. *)
begin
   With BGRange do Begin
      (* if the new one is null then do nothing *)
      If (aRg.rKind = aNullRg) Then

      (* if the old one is null then stuff the new one into it *)
      Else if (rKind = aNullRg) Then Begin
         BGRange := aRg;

         (* set BGRange to the whole table if rKind is not understandable *)
         If (Ord(BGRange.rKind) > 2) Then Begin
            BGRange.rKind := aWTBoxRg;
            FixRange(BGRange);
         end;
      end

      (* if they're both a1cellrg and/or rect range then combine them into a new range *)
      Else if ((aRg.rKind = a1CellRg) OR (aRg.rKind = aRectRg)) AND
              ((rKind     = a1CellRg) OR (rKind = aRectRg)) Then Begin
         loRow := cMin(loRow, aRg.loRow);
         loCol := cMin(loCol, aRg.loCol);
         hiRow := cMax(hiRow, aRg.hiRow);
         hiCol := cMax(hiCol, aRg.hiCol);
         If (loRow = hiRow) AND (loCol = HiCol) Then rKind := a1CellRg
                                                else rKind := aRectRg;
      end

      (* otherwise redo the whole table *)
      Else Begin
         rKind := aWTBoxRg;
         fixRange(BGRange);
      end;
   end;
end;



(*$S BGInit*)
Procedure BGRWText(myhFld: hndField; VAR Status: Integer);
(* Read/writes the actual text for a field. Assumes that Curlen contains the length of the
text to be read/written *)

VAR
   dataLen: Integer;

Begin
   DataLen := myHFld^^.CurLen;
   SetSize(Pointer(Ord(myHFld^^.CurValue)), dataLen + 1);
   myHFld^^.MaxLen := dataLen + 1;
   fBufStuff(fRawData, myHFld^^.CurValue^, dataLen, status);
end;


(*$S BGInit*)
Procedure BGRWRuns(myhFld: hndField; VAR Status: Integer);
(* Read/writes the run number and the actual runs for a field. *)

VAR
   dataLen: Integer;

Begin
   (* Read/write the number of runs *)
   DataLen := SizeOf(myHFld^^.CurFmts);
   fBufStuff(fRawData, @myHFld^^.CurFmts, dataLen, status);

   (* Read/write the runs info *)
   dataLen := myHFld^^.CurFmts * SizeOf(run);
   SetSize(Pointer(Ord(myHFld^^.Fmtinfo)), dataLen);
   myHFld^^.MaxFmts := myHFld^^.CurFmts;
   fBufStuff(fRawData, Pointer(Ord(myHFld^^.FmtInfo^)), dataLen, status);
end;



(*$S BGInit*)
Procedure fxAnnotStuff( mode: fioKind; status: integer );
(* Writes or Reads the annotations. Called by apbg/BG1.0/FxBGStuff *)

CONST
   EndFlag = -1;

VAR
   myHAnotRec : THAnotRec;
   myHFld     : hndField;
   XPos,
   YPos       : Real;
   endVar     : Integer;
   dummyField : Field;    (* used to write out the -1 signifying the end of the annots *)
   dataLen    : Integer;

Begin

   If (mode = mmClose) OR (mode = mmSuspend) Then Begin
      (* Go through each annotation record in the list.  *)

      myHAnotRec := HAnotFirst;
      While (myHAnotRec <> Nil) do Begin
         myHFld := myHAnotRec^^.AnotFld;

         (* Write it out if it has a positive length *)
         If (myHFld^^.CurLen > 0) Then Begin

            (* Write out the current length of the Annot *)
            dataLen := sizeof(myHFld^^.CurLen);
            fBufStuff(fRawData, @myHFld^^.curLen, dataLen, status);

            (* write out the text itself *)
            BGRWText(myHFld, status);

            (* write out all the runs information *)
            BGRWRuns(myHFld, status);

            (* Write out the fractional position of its location *)
            dataLen := sizeOf(myHAnotRec^^.XFract);
            fBufStuff(fRawData, @myHAnotRec^^.XFract, dataLen, status);
            fBufStuff(fRawData, @myHAnotRec^^.YFract, dataLen, status);
         end;

         (* Advance to the next annotation *)
         myHAnotRec := myHAnotRec^^.AnotNext;
      end; (* While *)

      (* Write out the end flag *)
      dummyField.curLen := EndFlag;
      dataLen := sizeOf(dummyField.CurLen);
      fBufStuff(fRawData, @dummyField.CurLen, dataLen, status);
   end

   else if (mode  = mmUnsuspend) OR (mode = mmOpen) Then Begin
      dataLen := SizeOf(dummyField.CurLen);
      fBufStuff(fRawData, @dummyField.CurLen, dataLen, status);

      While (DummyField.CurLen <> EndFlag) Do Begin
         GetHAnotRec(myHAnotRec);
         myHFld := myHAnotRec^^.AnotFld;
         myHFld^^.CurLen := DummyField.CurLen;

         (* write out the text itself *)
         BGRWText(myHFld, status);

         (* write out all the runs information *)
         BGRWRuns(myHFld, status);

         (* Read in the fractional position of its location *)
         dataLen := sizeOf(myHAnotRec^^.XFract);
         fBufStuff(fRawData, @myHAnotRec^^.XFract, dataLen, status);
         fBufStuff(fRawData, @myHAnotRec^^.YFract, dataLen, status);

         (* Prepare to go to the next one *)
         dataLen := SizeOf(dummyField.CurLen);
         fBufStuff(fRawData, @dummyField.CurLen, dataLen, status);
      end;
   end;
end;


(*$S BGInit *)
procedure FxBGMemInit(VAR Status: integer);
(* Makes sure there's enough room for any BG linked lists during initialization. Returns a status
of noMem if there's not enough memory. Assumes that the matrix has already been initted and
read in. This code is similar to the code in BGNewRgImg except it doesn't redraw the graph *)
VAR
   aRg: Range;
   myBool : Boolean;

Begin
   setRg(aRg, aWTBoxRg, mInfSnip, mInfSnip, pInfSnip, pInfSnip);

   (* reset BGData.XListTot and BGData.RepNum to the current limits of the data in the data table *)
   AdjTblLimits;                             (* in BG1A *)

   (* Ck if the graph type should change (e.g. the user entered
      a text value into the X column that was all numbers ) *)
   BGCkXCol(aRg, Status);                    (* in BG1A *)

   (* Adjust the linked data lists *)
   myBool := AdjDataLists(aRg, Status);      (* in BG1A *)

   (* Check that the axes are properly arranged *)
   CkAxes(aRg);                              (* In BG1B *)
End;


(*$S BGInit *)
Procedure CalcPgSize(VAR XInches, YInches: Real);
(* Sets XInches, Yinches to the real width and height of the paper according to the current
print info in CurConfig *)

VAR
   myHRes,
   myVRes     : Integer;
   myPrRect   : rect;

Begin
   myPrRect := CurConfig.prInfo.rPrintable;
   With myPrRect do Begin
      (* Take some white space off the left, right, and bottom sides of rPrintable. Top side
         already always has white space in all cases. *)
      myHRes := CurConfig.prInfo.hRes;
      myVRes := CurConfig.prInfo.vRes;

      left   := left   + Trunc(leftWhite  * myhRes);
      right  := right  - Trunc(rightWhite * myhRes);
      bottom := bottom - Trunc(botWhite   * myvRes);

      (* Calculate the number of inches for the paper size of the graph *)
      XInches := ((Right  - Left) DIV myhRes);
      YInches := ((Bottom - Top ) DIV myvRes);
   end;
end;



(*$S BGInit *)
procedure FxBGstuff
  {mode       : FIOkind;
   var status : integer
  };

const BGverNum = 6; (* Changed from 5 to 6 on 11/7/83 for Spring release code *)

var datalen      : integer;
    I            : TitleNames;          { for incring through the titles     }
    LegNum       : Integer;             { for incring through the legends    }
    LegTot       : Integer;             { total # of legends to read/write   }
    myCurLen     : Integer;             { length of each string              }
    BGVersionNum : Integer;             { the version number                 }
    hThumbPos,
    vThumbPos    : TC;                  { thumb position in the scroll bars  }
    XInches,
    YInches      : Real;                { page size of the paper             }

begin

   { Save the BG data }
   BGVersionNum := BGverNum;
   dataLen      := sizeof(Integer);
   fBufStuff(fRawData, @BGVersionNum, datalen, status);
   {$IFC fDebug }
   If (Status <> 0) Then Writeln('BG1.0/fxBGStuff has bad status = ', status);
   {$ENDC }

   { check the version numbers }
   if ((BGVersionNum < 1) OR (BGVersionNum > BGVerNum)) then begin
      {$IFC fDebug }
      Writeln('BG1.0/FxBGStuff has bad version number ', BGVersionNum);
      {$ENDC }

      status := BadFile;
      exit(FxBGStuff)
   end;


   { read in GType }

   dataLen := sizeof(GType);
   fBufStuff(fRawData, @GType, dataLen, status);
   if BGVersionNum = 5 then
      case GType of
         StackBar : GType := BarLine;
         SolidBar : GType := BarScat
      end;
   {$IFC fDebug }
   If (Status <> 0) Then Writeln('fxDataStuf error ', Status);
   {$ENDC }

   {*********************************************************************}
   { read in the new preview mode }

   dataLen := sizeof(BGPreview);
   fBufStuff(fRawData, @BGPreview, datalen, status);

   {*********************************************************************}
   { Read in the new graphproportion }

   dataLen := sizeof(GraphProportion);
   fBufStuff(fRawData, @GraphProportion, datalen, status);

   {*********************************************************************}
   {Axes info }
   DataLen := sizeof(AxisCntl);
   fBufStuff(fRawData, @XAxis, dataLen, status);

   DataLen := sizeof(AxisCntl);
   fBufStuff(fRawData, @YAxis, dataLen, status);

   {**********************************************************************}
   { Legend info }
   { Legends.LegendTot used below for reading }
   dataLen := sizeof(Legends);
   fBufStuff(fRawData, @Legends, dataLen, status);

   {*********************************************************************}
   { Rest of these don't affect the menus.                               }

   dataLen := sizeof(PaperSize);
   fBufStuff(fRawData, @PaperSize, dataLen, status);

   dataLen := sizeof(BarBoolean);
   fBufStuff(fRawData, @BarBoolean, dataLen, status);

   {*************************************************************************************}
   { On a read, OR on a write where the fields arent allocated yet,
     alloc the field structures off the mxHz heap. Both routines in apbg/Ttl. }
   If ((mode  = mmUnsuspend) OR (mode = mmOpen) OR (BGFld = Pointer(1))) then begin
      SetDfltTitles;
      SetDefaultLegends;
      BGFld := Nil;  { Says we're done with all allocation. 4/12/83 }
   end

   { on a write, exit the current selection before writing out the fields }
   else begin
      BGExit;
   end;

   {***************************************************************************}
   { Save the alignment, length, text and Runs for each title and legend       }

   For I := Main to FootNote do Begin
      dataLen := sizeof(hFld[I]^^.align);
      fBufStuff(fRawData, @hFld[I]^^.align, dataLen, status);

      (* Read the length number into CurLen. *)
      dataLen  := sizeof(hFld[I]^^.CurLen);
      fBufStuff(fRawData, @hFld[I]^^.CurLen, datalen, status);

      (* write out the text itself *)
      BGRWText(HFld[I], status);

      (* write out all the runs information *)
      BGRWRuns(HFld[I], status);
   End;

   { Read/Write the number of legends }
   LegTot := BGData.RepNum;
   dataLen := SizeOf(LegTot);
   fBufStuff(fRawData, @LegTot, dataLen, status);
   BGData.RepNum := LegTot;

   I := Leg1;
   For LegNum := 1 to BGData.RepNum do Begin
      dataLen := sizeof(hFld[I]^^.align);
      fBufStuff(fRawData, @hFld[I]^^.align, dataLen, status);

      { Read/write the length number into CurLen }
      dataLen  := sizeof(hFld[I]^^.CurLen);
      fBufStuff(fRawData, @hFld[I]^^.CurLen, datalen, status);

      { Read/write the text itself }
      BGRWText(HFld[I], status);

      { Read/write the runs information }
      BGRWRuns(HFld[I], status);
      I := succ(I);
   End;

   { Save the annotations }
   fxAnnotStuff(mode, status);  { listed above }

   { Read/Write the scroll bar positions }
   hThumbPos := CThumbPos(BGHsbH);
   dataLen := sizeof(hThumbPos);
   fBufStuff(fRawData, @hThumbPos, dataLen, status);
   SetThumb(BGHsbH, hThumbPos);

   vThumbPos := CThumbPos(BGHsbv);
   dataLen := sizeof(vThumbPos);
   fBufStuff(fRawData, @vThumbPos, dataLen, status);
   SetThumb(BGHsbV, vThumbPos);

   { Set the scroll bar icons according to the preview mode.
     NOTE: Just sets them, no repaint. }
   BGSetIcons(BGPreview);

(* RgrsBoolean sets which data sets have the regressions on. BGMarkFlag determines
   whether the data markers get shown on the line graph etc *)
   { 11/7/83 new stuff for spring release }
   If (BGVersionNum > 5) Then Begin
      { declared in BGEnv }
      dataLen := SizeOf(RgrsBoolean);
      fBufStuff(fRawData, @RgrsBoolean, dataLen, status);

      dataLen := SizeOf(BGMarkFlag);
      fBufStuff(fRawData, @BGMarkFlag, dataLen, status);
   end;


   {****************************************************************************}

   { Calculate and set the new page size according to the current print info in CurConfig }
   CalcPgSize(XInches, YInches);
   SetPGSize(XInches, YInches);

   BGSetGrfx;

   If (mode = mmOpen) or (mode = mmUnSuspend) then begin
      (* make sure there's enough room in memory for the linked lists *)
      FxBGMemInit(Status);
   end;
end;


(*$S BGInit *)
Procedure FXBGFree;
(* frees up all the BG data structures from the heap *)
VAR
   status: Integer;

Begin
   { as of 3/23/83, does nothing since these are all on the mxHZ heap which gets deallocated }
end;



(*$S     *)
Procedure SwapBool(VAR Bool1, Bool2: tBoolArray);
(* Undoes the command where the user set up a hybrid bar/line chart *)

VAR
   myTemp: Boolean;
   I     : Integer;

Begin
   (* Reinstall the old barboolean by swapping old with new *)
   For I := 1 to YListMax do begin
      myTemp   := Bool1[I];
      Bool1[I] := Bool2[I];
      Bool2[I] := myTemp;
   end;
end;



Procedure DoBGUndo;
(* Undo the last BG operation. Generally, this just calculates the proper menu command
to call and then calls BGMenuCommand to handle it *)

VAR
   myMenuIndex,
   myMenuItem: Integer;
   myhFldSt  : hndFState;  (* field state handle for a text undo *)
   errNum    : integer;
   myRg      : Range;


   Procedure DoBGFldUndo( VAR errNum : Integer);
   (* undoes the field and field state when user has selected undo for a text operation *)
   Begin
      If (uBGFld <> Nil) Then Begin
         (* if you've moved to a new field, exit it and reenter the one to be undone *)
         If (uBGFld <> BGFld) Then begin
            BGExit;
            BGFld := uBGFld;
            InitFState(BGFld, hFldSt);
            BGGetPt(BGFld, BGFldX, BGFldY);
         end;
         BGEraseFld;

         UndoEdit(BGFld, hFldSt, errnum);
      end;
   end; (* DOBGFldUndo *)


Begin (* doBGUndo *)
   Case UndoRec.UndoOp of
      uGType: Begin
         myMenuIndex := MenuBGType;
         myMenuItem := ord(OldGType) + 1;

         (* Correct for the line, scatter, and area graphs with text X axis *)
         If (myMenuItem >= 10) Then myMenuItem := 7
         Else if (myMenuItem >= 8) Then myMenuItem := myMenuItem - 6;
         BGMenuCommand(myMenuIndex, myMenuItem, ePrNormal);
      end;

      UBGPreview: Begin
         myMenuIndex := MenuBGPageLayout;
         myMenuItem  := BGReduced - ord(oldBGPreview);
         BGMenuCommand(myMenuIndex, myMenuItem, ePRnormal);
      End;

      uGraphProportion: Begin
         myMenuIndex := MenuBGPageLayout;
         myMenuItem  := ord(oldGraphProportion) + 3;
         BGMenuCommand(myMenuIndex, myMenuItem, ePRnormal);
      End;

      uLegends: Begin
         myMenuIndex := MenuBGOptions;
         myMenuItem  := BGLegOff - Ord(OldLegend);
         BGMenuCommand(myMenuIndex, myMenuItem, ePRnormal);
      End;

      uGrid: Begin
         myMenuIndex := MenuBGOptions;
         myMenuItem  := BGGridOff - Ord(OldGrid);
         BGMenuCommand(myMenuIndex, myMenuItem, ePRnormal);
      End;

      uBGCut,
      uBGCopy: Begin
         doBGFldUndo(errNum);
         If (errnum = 0) Then UndoInheritScrap(errNum)
         {$IFC fDebug}
         Else Writeln('BG1.0/BGUndo has error ', errnum)
         {$ENDC }  ;
      end;

      uBGCopyGraph: Begin
         UndoInheritScrap(errnum);
         {$IFC fDebug}
         If (errNum <> 0) Then Writeln('BG1.0/BGUndo: uBGCopyGraph has error ', errnum)
         {$ENDC }  ;
      end;

      uBGKey,
      uBGPaste,
      uBGClr,
      uBGTypestyle: Begin
         doBGFldUndo(errNum);
         {$IFC fDebug}
         If (errNum <> 0) Then Writeln('BG1.0/BGUndo: error ', errnum)
         {$ENDC }  ;
      end;

      uBGAxis: Begin
         DoStopAlert(109);
      end;

      uBGHybrid: Begin
         SwapBool(OldBarBoolean, BarBoolean);
         BGDrawAll;
      end;

      uBGMark: Begin
         myMenuIndex := MenuBGOptions;
         myMenuItem  := BGMarkOff - Ord(OldBGMark);
         BGMenuCommand(myMenuIndex, myMenuItem, ePRnormal);
      End;

      uBGRgrsn: Begin
         SwapBool(oldRgrsBoolean(* in apbg/BG2 *), RgrsBoolean(* in aplc/mm/BGenv *));
         (* Check the y axis range, redraw *)
         SetRg(myRg, aWTBoxRg, minfsnip, minfsnip, pinfsnip, pinfsnip);
         CkAxes(myRg);
         BGDrawAll;
      end;

      otherwise begin
         DoUndo;   (* in aplc/LCMenus *)
      end;
   end; (* Case *)
end;


Procedure BGReconfig;
(* Reconfigures BG when the printer preference changes *)
VAR
   XInches,
   YInches    : Real;
   BGpnlRect : rect;
Begin
   (* Calculate the new page size according to the current print info in CurConfig *)
   CalcPgSize(XInches, YInches);
   SetPGSize(XInches, YInches);
   BGSetGrfx;

   (* Redraw everything *)
   BGDrawAll;
   GetPnlRect(BGPnl, BGPnlRect);
   ValidRect(BGPnlRect);
end;

(*$S BGInit*)
End.
