UNIT Ttl;                               {'Copyright 1983, 1984, Apple Computer Inc.'}
(* Unit containing the title and annotation routines *)

(* Problems:  PRdev calls - are they needed. NEEDS MORE WORK IN DRAWMARK. 1/22/84
*)

INTERFACE

uses (*$U UnitStd.obj *)                UnitStd,
     (*$U UnitHz.obj *)                 UnitHz,
     (*$U Storage.obj *)                Storage,
     (*$U QuickDraw.obj *)              QuickDraw,
     (*$U Fontmgr.obj *)                FontMgr,
     (*$U dbenv.obj *)                  dbenv,
     (*$U FEdec.obj *)                  FEdec,
     (*$U fld.obj *)                    fieldedit,
     (*$U teenv.obj *)                  teenv,

     (*$U libos/SysCall.obj    *)       Syscall,
     (*$U FPlib.obj *)                  FPlib,
     (*$U PMDecl *)                     PMDecl,
     (*$U PrStdInfo *)                  PrStdInfo,
     (*$U PrPublic.obj *)               PrPublic,
     (*$U aplc/mm/matmgr.obj *)         matmgr,
     (*$U FmgrUtil.obj   *)             FmgrUtil,

     (*$U wm.events.obj *)              events,
     (*$U wm.folders.obj *)             folders,
     (*$U wm.menus.obj *)               menus,
     (*$U AlertMgr.obj *)               AlertMgr,

     (*$U aplc/mm/bgenv.obj      *)     bgenv,
     (*$U apbg/Graf2D.obj     *)        Graf2D,

     (*$U WMLstd.obj  *)                WMLstd,
     (*$U WMlsb.obj   *)                WMlsb,
     (*$U tm.obj      *)                tm,

     (*$U aplc/feglobals.obj *)         feglobals,
     (*$U aplc/comgr.obj *)             coMgr,
     (*$U scrap.obj      *)             scrap,
     (*$U aplc/TEexec.obj     *)        TEexec,
     (*$U aplc/LCfexec.obj    *)        LCfexec;


CONST
   chbs = 8;  (* backspace character *)

   TitleMax  = 5;       (* Main,subtitle,X Axis,Y Axis, and footnote   *)
   LayblMax  = 20;      (* Maximum labels ever                         *)
   XLabDflt  = 4;       (* # of X axis labels to start with(line,Scttr *)
   YLabDflt  = 5;       (* # of Y axis labels to start with            *)
   LegendMax = 8;       (* Max number of legends ever                  *)
   PatternMax= 10;
   PlotMax   = 8;       (* Max number of data plots on one graph ever  *)
   YListMax  = 8;       (* Max number of Y data lists allowed in table *)
   Maxlngth  = 50;      (* maximum length of a string                  *)

   RepNumDflt = 1;      (* Number of data plots in default graph     *)


   XFct1 = 0.14;         (* (old .15 )upper left of plot boundary *)
   YFct1 = 0.23;

   XFct2 = 0.80;         (* lower right of plot boundary when *)
   YFct2 = 0.80;         (* legends are on                      *)

   XFct3 = 0.90;         (* (old .95)lower right of plot boundary when   *)
   YFct3 = 0.80;         (* legends are off                     *)

   RadiusFct = 0.30;     (* pie radius = RadiusFct * YSize      *)
   XFct      = 0.50;     (* Pie center centered on X            *)
   YFct      = 0.57;     (* Slightly below center on Y          *)

   XFctLeg   = 0.90;     (* Center for legend placement         *)
   XFctLgWidth=0.03;     (* Width of a legend bar               *)
   XFctYLaybl= 0.13;     (* Right margin for Y Axis labels      *)

   YFctMain  = 0.06;     (* Orig depth of main title            *)
   YFctSub   = 0.13;     (* Orig depth of subtitle              *)
   YFctYTitle= 0.19;     (* Orig depth of Y axis title from top *)
   YFctLaybl = 0.852;    (* Orig depth of X axis labels         *)
   YFctXTitle= 0.918;    (* Orig depth of X axis title from top *)
   YFctFoot  = 0.965;    (* Orig depth of footnote from top     *)


   (* Initialization constants              *)

   XSizeDflt  = 7.0;  (* Initial paper size *)
   YSizeDflt  = 10.0;
   Pi         = 3.14159265359;

   (* Picture comment constants             *)
   cPicGEDwg    = 100;
   cPicTxtBegin = 101;
   cPicTxtEnd   = 102;
   cPicGrpBegin = 103;
   cPicGrpEnd   = 104;
   cPicForeGnd  = 108;
   cPicBackGnd  = 109;


Type

   StringMax = String[Maxlngth];

   Rctngl = Record
      XMin,XMax : Real; (* World coordinate left and right sides *)
      YMin,YMax : Real; (* World coordinate top and bottom sides *)
   End;

   DataRecHnd = ^DataRecPtr;
   DataRecPtr = ^DataRec;
   DataRec = Record
      XIndex: Integer;       (* index into the X column in the matrix     *)
      XVal  : Real;          (* the actual X data value for the X-Y pair  *)
      Next  : DataRecHnd;    (* pointer to the next data rec              *)
   End;

   DataHndArray = Array[1..YListMax] of DataRecHnd;

   DataCntl  = Record
      RepNum : Integer;     (* current number of data reps shown         *)
      XListTot:Integer;     (* total # of elts in the X data list.       *)
                            (* determines # of clusters for a bar chart  *)
      First  : DataHndArray;(* hnd to the start of each data list           *)
      Unread : DataHndArray;(* hnd to the next unread data rec in each list *)

      XMinData,             (* Minimum X data point                      *)
      XMaxData: Real;       (* Maximum X data point                      *)
      YMinData,             (* Minimum Y data point in the whole table   *)
      YMaxData: Real;       (* Maximum Y data point in the whole table   *)
   End;


     ptrLongInt = ^Longint;
     hndLongInt = ^ptrLongint;

var

   CommentHnd : hndLongInt;

   GraphSize   : Rctngl;        (* world coords in inches             *)
   PlotBndry   : Rctngl;        (* World coord plot boundary          *)

   (* Papersize corresponds to the printable portion of the printer paper *)
   PaperSize   : Rctngl;
   XUpLeft,
   YUpLeft     : Real;          (* upper left corner of visible area  *)
   XCurVis,
   YCurVis     : Real;          (* amount currently visible in inches *)

   PlotRect    : Rect;          (* Lisagraf rect corresponding to PlotBndry *)

   BGData : DataCntl;           (* the data control parameters              *)

   gp     : GrafPtr;               (* ptr to LisaGraf state variables      *)
   rp     : RealPtr;               (* ptr to RealGraf state variables      *)

   Patterns: Array[1..PatternMax] of Pattern;   (* Lisagraf patterns       *)

   BigNum    : Real;              (* A Real bigger than any user number    *)

   YAxis     : AxisCntl;          (* Axis specs. XAxis declared in apbg/BGEnv *)
   OldGrid   : Boolean;           (* Grid boolean used for undo            *)
   oldGType  : GraphTypes;        (* old one for undo. Real one in apbg/BGEnv *)
   oldLegend : Boolean;           (* old legend used to undo               *)
   oldGraphProportion: tGraphProportion; (* to undo the graph size e.g. 1/3, 1/2 ... *)
   oldBGPreview: Boolean;         (* to undo the prevoew mode              *)
   oldBarBoolean: tBoolArray;

   BGPicHandle  : PicHandle;      (* handle to the picture in the scrap    *)

   RPport : RealPort;

   BGActive: Boolean;      (* true if BG folder is active. See TTL/DoBGAct *)
   oldRgrsBoolean:tBoolArray; (* used for undo          *)
   oldBGMark: Boolean;     (* old marker flag for undo                     *)

   hfld      : Array[Main..Leg8] of hndfield;           (* Field handles     *)
   hExtraFld : hndfield;                (* utility field for axis labels etc.*)

   BGFldSt   : fieldState;              (* single field state                *)
   pBGFldSt  : ptrFState;               (* ptr to the field state            *)

   uBGFld    : hndField;                (* handle to the undo field          *)
   (* NOTE: BGFld and hFldSt declared in apbg/BGEnv *)

   (* BGFld moved down to BGEnv so LCMenus can use it to gray the menu items *)

   BGFldX,
   BGFldY    : Real;                    (* Loc of BG field under edit        *)
   BGFmtInfo : hndRuns;                 (* big fmtinfo of field under edit   *)
   BGCurFmts : Integer;                 (* true # of fmts for field under edit *)

   HAnotFirst : THAnotRec;              (* First annotation handle             *)

   hSmallRun : hndRuns;
   pSmallRun : ptrRuns;
   SmallRun  : Run;

   TtlSubFont: Boolean;
   TtlSubDev : Integer;

   StackPattern: Array[1..PatternMax] of integer; (* permutation to put dark patterns at bottom for stacked bars *)


Procedure InitPatterns;
Procedure SetTtlPos;
Procedure SetDfltTitles;
Procedure DrawTitles;
Procedure DrawMark(J: Integer);
Procedure SetLegPos;
Procedure SetAnoPos;
Procedure SetDefaultLegends;
Procedure DrwFooBar(J: Integer; BarWidth, BarHeight: Real);
Procedure BGDrawFldAt(hFld: hndField; XPos, YPos: Real; ShowSel: Boolean; BGErase: Boolean);
Procedure DrawLegends;
Procedure DrawAnnots;

Procedure BGTmOut(myEvent: EventRec);
Procedure BGUp   (myEvent: EventRec);
Function  TtlSelect(mouseloc: point; VAR TtlName:TitleNames): BOOLEAN;
Function  AnotSelect(mouseLoc: point; VAR HAnotRec: THAnotRec): BOOLEAN;
Procedure GetHAnotRec( VAR HAnotRec: THAnotRec);
Procedure BGDown (mouseloc: point);
Procedure BGMove (mouseloc: point);
Procedure BGEraseFld;
Procedure BGKey  (MyEvent: EventRec);
Procedure BGExit;
Procedure DoBGAct( Activate: Boolean);

Procedure BGGetPt(myHFld: hndField; VAR XPt, YPt: Real);
Procedure BGInvertAll;
Procedure BGSwapRuns   (myhFld: hndField; VAR hSaveRuns: hndRuns; VAR SaveRunNumber: Integer;
                        VAR SaveSubFont: Boolean; VAR SaveSubDev : Integer);

Procedure BGInstallRuns(myhFld: hndField; VAR hSaveRuns: hndRuns; VAR SaveRunNumber: Integer;
                        VAR SaveSubFont: Boolean; VAR SaveSubDev : Integer);

Function  LegSelect: Boolean;
Procedure BGPnlPort;
Procedure BGAdjFld(myhFld: hndFIeld; VAR myPt: Point);

procedure ColorDefault;
function  colorNum(col : integer) : longint;
procedure SetForeColor(theColor : longint);
procedure SetBackColor(theColor : longint);


IMPLEMENTATION

(*$R- *)

(*$IFC teSym *)
(*$D+ *)
(*$ELSEC *)
(*$D- *)
(*$ENDC *)


Procedure EraseBG  ; external;  (* in apbg/BG1 *)
Procedure DrawGraph; external;  (* in apbg/BG1 *)


(*$S     *)
procedure SetForeColor(* theColor : longint *);
begin
   ForeColor(theColor);
   CommentHnd^^ := theColor;
   PicComment(cPicForeGnd, 4, pointer(ord(CommentHnd)))
end;


(*$S     *)
procedure SetBackColor(* theColor : longint *);
begin
   if BGPrintFlag then BackColor(theColor);
   CommentHnd^^ := theColor;
   PicComment(cPicBackGnd, 4, pointer(ord(CommentHnd)))
end;


(*$S     *)
procedure ColorDefault;
begin
   SetForeColor(blackColor);
   SetBackColor(WhiteColor);
end;


(*$S     *)
function colorNum(* col : integer) : longint *);
var myColor    : Longint;
    myDColor   : longint;
    status     : integer;
    xNumber    : valuetype;
begin

   case col of
      1 : myColor := redColor;
      2 : myColor := blueColor;
      3 : myColor := greenColor;
      4 : myColor := cyanColor;
      5 : myColor := yellowColor;       {will be combined with redColor for orange}
      6 : myColor := magentaColor;
      7 : myColor := yellowColor;
      8 : myColor := blackColor;
      9 : myColor := cyanColor;
   end;

   myDColor := myColor;
   if col = 5 then myDcolor := redColor;

(*$IFC fDebug *)
   if col = 0 then col := 8;
   if not CellBlank(col, 10) then begin
      GetValue(col, 10, true, xNumber);
      X2L(xNumber.val.xRealVar, myColor);
   end;
   if not CellBlank(col, 11) then begin
      GetValue(col, 11, true, xNumber);
      X2L(xNumber.val.xRealVar, myDColor);
   end;
(*$ENDC *)

   colorNum := myColor;
   SetForeColor(myDColor);
end;


(*$S BGInit*)
PROCEDURE InitPatterns;
var fError : integer;
BEGIN
  GetPattern(SysPat,  3, Patterns[1], fError);    (* XLtGray *)
  GetPattern(SysPat, 24, Patterns[2], fError);    (* G45F    *)
  GetPattern(SysPat,  5, Patterns[3], fError);    (* MedGray *)
  GetPattern(SysPat, 31, Patterns[4], fError);    (* VDash   *)
  GetPattern(SysPat,  7, Patterns[5], fError);    (* Gray    *)
  GetPattern(SysPat, 23, Patterns[6], fError);    (* G90F    *)
  GetPattern(SysPat,  4, Patterns[7], fError);    (* LtGray  *)
  GetPattern(SysPat, 36, Patterns[8], fError);    (* G45C    *)
  GetPattern(SysPat, 19, Patterns[9], fError);    (* hDash   *)
  GetPattern(SysPat,  9, Patterns[10],fError);    (* Black   *)

  (* Init the permutation for the stacked bar patterns, to place dark patterns at the bottom *)
  StackPattern[1] := 5;
  StackPattern[2] := 2;
  StackPattern[3] := 6;
  StackPattern[4] := 8;
  StackPattern[5] := 3;
  StackPattern[6] := 9;
  StackPattern[7] := 7;
  StackPattern[8] := 1;
  StackPattern[9] := 10;
  StackPattern[10]:= 10; (* Black *)
END;


(*$S BGInit*)
Procedure SetTtlHandles;
(* Sets all the ptrs and handles for the title & legend records. Does not set
the position or text of any of the titles, just sets up all the pointers *)

Const
   GrowChar  = 5;     (* grow the number of chars in a field by 5  *)
   RunNumber = 1;     (* original number of runs in a field        *)
   RunGrow   = 2;     (* grow the number of runs by 2 at a time    *)
   Protect   = False; (* Fields are not protected                  *)

VAR
   I         : TitleNames;
   NullRect  : Rect;
   errnum    : integer;
   myFontNum : Integer;
   mySaveHeap: THz;

Begin
   (* CreateField sets up a data structure that looks like this:
      hfld -> pfld -> afld.curvalue -> pFldData -> Data   *)

   myFontNum := p12Tile;

   (* Allocate off the matrix mgr heap. Allocate the extra field used for axis labels etc. *)
   mySaveHeap := FldHeap;
   FldHeap   := mxHz;
   hExtraFld := CreateField(NullRect, MaxLngth, 0, Center, 0(*pad*), RunNumber, 0, myFontNum, Protect);
   SetRunFormat(hExtraFld, nil, myFontNum, setBold, errNum);

   For I := Main to Footnote do Begin
      hFld[I] := CreateField(NullRect, MaxLngth, GrowChar, Center, 4, RunNumber, RunGrow, myFontNum, Protect);
      SetRunFormat(hFld[I], nil, myFontNum, setBold, errNum);
   End;
   FldHeap := mySaveHeap;

   hFld[YAx]^^.Align := Left;  (* Y Axis title is left aligned *)

   (* Make the main title temporarily smaller to set up the smallrun.
      Note: p15Tile is smaller than p12Tile. *)
   SetRunFormat(hFld[Main], Nil, p15Tile, setFont, errnum);

   (* Set up the small run record used when drawing in reduced mode *)
   hSmallRun := @pSmallRun;
   pSmallRun := @SmallRun;
   SmallRun  := hFld[Main]^^.fmtInfo^^[0];

   (* Also set up the fieldstate handle *)
   pBGFldSt := @BGFldSt;
   hFldSt   := @pBGFldSt;

   { restore the main title back to p12tile }
   SetRunFormat(hFld[Main], Nil, myFontNum, setFont, errnum);

   { and set up some globals }
   BGFld      := Nil;    (* currently no field under edit *)
   HAnotFirst := Nil;

End; (* SetTtlHandles *)



(*$S BGInit*)
Procedure SetTtlText;
(* SetTtlText inserts the default text values into the title fields *)

VAR
   myStr   : Str255;
   myTtl   : TitleNames;

Begin

   For myTtl := Main to FootNote do Begin
      DoGetAlert( Ord(myTtl) + 20022, @myStr);
      hFld[myTtl]^^.CurLen := 255;
      StoB(myStr, hFld[myTtl]^^.CurValue^, hFld[myTtl]^^.CurLen);
   end; (* For *)
End; (* SetTtlText *)

(*$S BGInit*)
Procedure SetDfltTitles;
(* SetDfltTitles sets up all the title records with their default values *)

VAR
   I : TitleNames;
   errNum : integer;

Begin
   SetTtlHandles;
   SetTtlText;
End; (* SetDfltTitles *)


(*$S     *)
Procedure GetTtlPos( Ttl: TitleNames; VAR XPos, YPos: Real);
(* Returns the real (XPos, YPos) for the title named Ttl *)
Begin
   (* calc the X center position for this type of title.  *)
   If (GType = Pie) Then XPos := 0.5 * GraphSize.XMax
                    Else XPos := 0.5 * (PlotBndry.XMax + PlotBndry.XMin);


   (* Branch off the type of title *)
   case Ttl Of
      Main     : YPos := YFctMain;
      SubTitle : YPos := YFctSub;
      XAx      : YPos := YFctXTitle;
      YAx      : begin
                    XPos := PlotBndry.XMin;
                    YPos := YFctYTitle;
                 end;

      Footnote : YPos := YFctFoot;
   end; (* Case *)
   YPos := YPos * GraphSize.YMax
end;


(*$S     *)
Procedure BGAdjFld(* myhFld: hndFIeld; VAR myPt: Point *);
VAR
   ascent,
   descent: Integer;

Begin
   VertCoords(myHFld, ascent, descent);
   myPt.v := myPt.v + (ascent + descent) div 3;
end;


(*$S     *)
Procedure BGSwapRuns(* myhFld: hndField; VAR hSaveRuns: hndRuns; VAR SaveRunNumber: Integer;
                       VAR SaveSubFont: Boolean; VAR SaveSubDev: Integer *);
(* ALWAYS returns myFld's FMTInfo and CurFmts. If the graph is currently in reduced mode to
the screen, it also installs a handle to the small run into myFld and sets CurFmt to 1 *)

Begin
   (* Return the Field editor global substitution parameters *)
   SaveSubFont := SubFont;
   SaveSubDev  := SubDev;

   With myhFld^^ do Begin
      hSaveRuns     := FmtInfo;
      SaveRunNumber := curFmts;

      (* Do nothing if drawing full size *)
      If (BGPreview OR BGPrintFlag or BGCutFlag) Then Begin
         (* Do Nothing *)
      end

      (* otherwise the graph is shrunk to fit, so install the small run *)
      else begin
         FmtInfo := hSmallRun;
         CurFmts := 1;
      end;
   end;
end;


(*$S     *)
Procedure BGInstallRuns(* myhFld: hndField; hSaveRuns: hndRuns; SaveRunNumber: Integer;
                       SaveSubFont: Boolean; SaveSubDev: Integer *);
(* Installs hSaveRuns and SaveRunNumber into myHFld as its new FmtInfo and CurFmt. Installs
   the substitute font values as the field editor globals values. *)

Begin
   (* Reinstall the field editor variables *)
   SubFont := SaveSubFont;
   SubDev  := SaveSubDev;

   (* Reinstall the true runs information into BG's chosen field *)
   With myhFld^^ do Begin
      FmtInfo := hSaveRuns;
      CurFmts := SaveRunNumber;
   end;
end;


(*$S     *)
Procedure SetTtlPos;
(* SetTtlPos sets the text rectangle in the field record. It also sets
   the fmtinfo to point at the big size text or the small size text. *)

VAR
   XCntr,YCntr: Real;  (* Real coords for center point *)
   pt         : Point; (* Lisagraf point               *)
   I          : TitleNames;  (* indexes through Main, Subtitle ... *)
   hSaveRun   : HndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;

Begin
   For I := Main to FootNote Do Begin
      (* Set the big or small run as needed *)
      BGSwapRuns(hFld[I], hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

      (* Get the proper position for each title *)
      GetTtlPos(I, XCntr, YCntr);

      (* Get the LisaGraf coords of the center position and reset the field coords *)
      BGMapPt(XCntr, YCntr, Pt);
      BGAdjFld(hFld[I], Pt);   (* adjust the vertical alignment *)
      MoveField(hFld[I], nil, pt);

      (* Reset the proper runs info *)
      BGInstallRuns(hFld[I], hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   End; (* For *)

End; (* SetTtlPos *)


(*$S     *)
Procedure DrawMark(* J: Integer *);
(* DrawMark draws marker J at the current position and leaves the
current position unchanged *)

VAR
   ferror   : integer;
   myLFntId : TLFntId;
   myFInfo  : FontInfo;
   dh,
   dv       : Integer;
   myPoint  : point;
   myBool   : boolean;

Begin
   GetPen(myPoint);
   TextFont(Marker);

   PrLFntId(curConfig, Marker, [], myLFntId);
   If (NOT BGPrintFlag) Then mylFntId.Dev := DevScreen;

   myBool := FMFontMetrics(myLFntId, myFInfo, fError);
   With myFInfo do Begin
      dh  := WidMax div 2;
      dv  := (Ascent + Descent) div 2;
   end;
   Move(-dh, -dv);

   CommentHnd^^ := colornum(J);

   DrawChar(Chr(J));
   Moveto(myPoint.h, myPoint.v);
   ColorDefault
End;



(*$S BGInit*)
Procedure SetLegHandles;
(* Sets all the ptrs and handles for the legend records. Does not set
the position or text of any of the legends, just sets up all the pointers *)

Const
   GrowChar  = 5;     (* grow the number of chars in a field by 5  *)
   RunNumber = 1;     (* original number of runs in a field        *)
   RunGrow   = 2;     (* grow the number of runs by 2 at a time    *)
   Protect   = False; (* Fields are not protected                  *)

VAR
   I:   TitleNames;
   NullRect: Rect;
   errNum  : Integer;
   mySaveHeap : tHz;

Begin
   (* CreateField sets up a data structure that looks like this:
      hfld -> pfld -> afld.curvalue -> pFldData -> Data   *)

   (* Allocate off the matrix mgr heap *)
   mySaveHeap := FldHeap;
   FldHeap    := mxHz;

   For I := Leg1 to Leg8 do Begin
      hFld[I] := CreateField(NullRect, MaxLngth, GrowChar, Center, 4, RunNumber,
                             RunGrow, p12Tile, Protect);

      SetRunFormat(hFld[I], nil, p12Tile, setBold, errNum);

   End;

   FldHeap := mySaveHeap;
End; (* SetLegHandles *)


(*$S BGInit*)
Procedure SetLegText;
(* SetLegText puts all the default text values into the legend fields
as required by the field edit routines *)

VAR
   J           : Leg1..Leg8;
   myStr       : Str255;

Begin
   (* Set up the source data and ptr to it *)
   doGetAlert(20027, @myStr);

   (* Set up each legend in turn *)
   For J := Leg1 to Leg8 Do Begin
      hFld[J]^^.CurLen := 255;
      StoB(myStr, hFld[J]^^.CurValue^, hFld[J]^^.CurLen);
   End; (* For *)
End; (* SetLegText *)


(*$S     *)
Procedure GetLegPos(J: Integer; VAR XCntr, YCntr: Real);
(* Returns the upper center point of the Jth legend *)

VAR
   YSpace     : Real;    (* The amount of space for each legend           *)
   YTop       : Real;    (* The Y value at the top of the legend area     *)
   YBot       : Real;    (* The Y value at the bottom of the legend area  *)
   YSize      : Real;    (* Y Size in inches of the entire graph          *)

Begin
   (* Calculate some constants *)
   With GraphSize do Begin
      XCntr  := XMax * XFctLeg;
      YSize  := YMax;
   end;

   (* Calculate the Y center position *)
   If (GType = StackBar) Then Begin
      (* For the stacked bars, move the top a little higher, then make the legends run from
         the bottom to the top *)
      YTop  := 0.875 * (YFctYTitle * YSize);
                           (* Proportional factor is in parens *)   (* total Y size *)
      YCntr := YTop + 1.125*((BGData.RepNum - J)/(BGData.RepNum+1)) * (YSize - YTop);
   end
   else begin
      (* for all other graph types, set the top even with the Y axis title, then make the
      legends run from the top to the bottom *)
      YTop   := YFctYTitle * YSize;
      YSpace := (YSize - YTop)/LegendMax;
      YCntr  := YTop + (J - 1) * YSpace;
   end;
End; (* GetLegPos *)


(*$S     *)
Procedure SetLegPos;
(* SetLegPos calculates and stores the proper placement for the legends *)

VAR
   I          : Leg1..Leg8;
   XCntr,YCntr: Real;    (* The world center point for each legend        *)
   YSpace     : Real;    (* The amount of space for each legend           *)
   YTop       : Real;    (* The Y value at the top of the legend area     *)
   YBot       : Real;    (* The Y value at the bottom of the legend area  *)
   pt         : Point;   (* Lisagraf point *)
   LegOrd     : Integer; (* ord of the legend you're working on           *)
   hSaveRun   : hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;


Begin
   LegOrd := 1;

   (* Set up each legend in turn *)
   For I := Leg1 to Leg8 do Begin
      (* Set the big run if printing, cutting, or full size to screen *)
      BGSwapRuns(hFld[I], hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

      (* Get the top center point for each legend *)
      GetLegPos(LegOrd, XCntr, YCntr);

      (* Get the Lisagraf point for the center position and sets the field Coords *)
      BGMapPt(XCntr, YCntr, pt);
      BGAdjFld(hFld[I], pt);    (* adjust the vertical alignment *)
      MoveField(hFld[I], Nil, pt);
      LegOrd := LegOrd + 1;
      BGInstallRuns(hFld[I], hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   End; (* For *)
End; (* SetLegPos *)


Procedure SetAnoPos;
(* SetAnoPos calculates and stores the proper placement for the annots    *)

VAR
   XCntr,YCntr: Real;      (* The world point for each annotation         *)
   pt         : Point;     (* Lisagraf point                              *)
   myHAnotRec : THAnotRec; (* ptr to each annotation record               *)
   hSaveRun   : HndRuns;
   SaveRunNumber : Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;


Begin
   myHAnotRec := HAnotFirst;

   (* Move each annotation in turn *)
   While (myHAnotRec <> Nil) Do Begin
      With myHAnotRec^^ Do Begin
         If (AnotFld^^.CurLen > 0) OR (AnotFld = BGFld) Then Begin
            BGSwapRuns(AnotFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

            (* Calculate the point at which to draw the annotation *)
            XCntr := XFract*GraphSize.XMax;
            YCntr := YFract*GraphSize.YMax;

            (* Move the field to that point *)
            BGMapPt(XCntr, YCntr, pt);
            BGAdjFld(AnotFld, pt);
            MoveField(AnotFld, Nil, pt);

            BGInstallRuns(AnotFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
         end; (* if *)
      end; (* with *)

      myHanotRec := myHAnotRec^^.AnotNext;
   End; (* While *)
End; (* SetAnoPos *)



Procedure SetDefaultLegends;
(* Sets up all the default legends *)

VAR
   I     : Leg1..Leg8;

Begin
   SetLegHandles;
   SetLegText;
End; (* Procedure *)


Procedure DrwQDBar(J: Integer; BarRect: Rect);
(* Draws a rect and fills it with the Jth pattern *)
Begin
   (* Permute the patterns when filling stacked or solid bars *)
   case gtype of
      StackBar,
      SolidBar : J := StackPattern[J]
   end;
   SetBackColor(colornum(J));
   FillRect(BarRect, Patterns[J]);

   (* Frame the rect if it's wide enough, else draw a vertical line. Fixes Bug LG67 *)
   if BarRect.Right - BarRect.Left > 1 then begin
      ColorDefault;
      FrameRect(BarRect)
   end
   else with BarRect do Begin
           MoveTo(left, top);
           Lineto(left, bottom - 1);
        end;
   ColorDefault
end;


Procedure DrwFooBar(*J: Integer; BarWidth, BarHeight: Real*);
(* DrwFooBar draws a bar starting at the current position with dimensions
BarWidth and BarHeight and fills the bar with the Jth fill pattern. The
CP is assumed to start at the lower left corner of the bar, and the routine
leaves it at the lower right corner of the bar *)

VAR
   pt1,pt2: Point;   (* diagonally opposite corners of the bar     *)
   BarRect: Rect;    (* LisaGraf rectangle for the bar             *)
   Top,
   Bottom : Integer; (* Top and bottom sides of the bar            *)
   PatNum : Integer; (* pattern number with which to fill this bar *)

Begin
   (* Get the Lisagraf coords of the diagonally opposite points.    *)
   With rp^ do Begin
      BGMapPt(pen.x, pen.y, pt1);
      BGMapPt(pen.x+BarWidth, pen.y-BarHeight, pt2);
   end;

   (* Set the BarRect, and move the bottom down 1 so the FrameRect bottom coincides
      with any lines it may be sitting on. (FrameRect draws on the inside of the
      rectangle, and lines get drawn below the specified pixels *)
   pt2Rect(pt1, pt2, BarRect);
   BarRect.Bottom := BarRect.Bottom + 1;

   (* Draw the rect, then move the CP at the lower right corner *)
   DrwQDBar(J, BarRect);
   Move2D(BarWidth, 0.0);
end;


Procedure DrwLegBar(J:TitleNames);
(* DrwLegBar draws one legend bar for the legend of a bar chart.
This routine is related to the code in SetLegPos in terms of positioning
the legends  *)

VAR
   XCntr,              (* The X center position of the legends   *)
   YCntr,              (* The Y center position of the legends   *)
   BarHeight,          (* World height of one of the legend bars *)
   BarWidth,           (* World width of one of the legend bars  *)
   YSpace,             (* Space for one complete legend          *)
   XLowLeft,           (* X Lower left of one of the legend bars *)
   YLowLeft            (* Y Lower left of one of the legend bars *)
            : Real;

   LegNum   : Integer; (* Legend Number e.g. 1,2,3 .. 8          *)

Begin
   (* Get the upper center position of the entire space for the legend *)
   LegNum := ord(J) - ord(Leg1) + 1;
   GetLegPos(LegNum, XCntr, YCntr);

   (* the legend bar is centered in the X direction *)
   BarWidth  := GraphSize.XMax * XFctLgWidth;
   XLowLeft  := XCntr - BarWidth/2.0;

   (* calc the bar's height and Y placement as % of the total height available for legends.
   This calculation must agree with the one in SetLegPos. *)
   YSpace    := (1.0-YFctYTitle) * GraphSize.YMax/LegendMax;
   BarHeight := YSpace * 0.31;
   YLowLeft  := YCntr + 0.60 * YSpace;

   (* Draw the bar *)
   Moveto2D(XLowLeft, YLowLeft);
   DrwFooBar(LegNum, BarWidth, BarHeight);
End; (* DrwLegBar *)


Procedure BGDrawFldAt(* hFld: hndField; XPos, YPos: Real; ShowSel: Boolean; BGErase: Boolean *);
(* Handles all drawing of all fields to all devices. *)

VAR
   myPt    : Point;     (* Lisagraf integer point         *)
   hRes    : Integer;   (* hi or low res                  *)
   hSaveRun: hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;
   hAlign       : QDhandle;

Begin
   (* Get the point at which to draw the text *)
   BGMapPt(XPos, YPos, myPt);

   (* set up the proper runs info *)
   BGSwapRuns(hFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

   (* Adjust the vertical alignment *)
   BGAdjFld(hFld, myPt);

   (* Handle specially if it's the selected field *)
   If (hFld = BGFld) Then Begin
      MoveField(BGFld, hFldSt, myPt);
      hFldSt^^.ValidLP := 0; (* 3/18/83 corrects unreported bug of non-erased background rect *)

      (* When printing or cutting, draw the field only if its length is greater than 0 *)
      If (BGPrintFlag OR BGCutFlag) Then Begin
         If (BGFld^^.CurLen > 0) Then Begin  (* corrects bug LG123 *)
            ShowSel := False;
            DrawFldAt(BGFld, hFldSt, myPt, ShowSel, BGErase);
         end;
      end

     else if (BGFld^^.Curlen = 0) Then Begin
         HiLightSel(BGFld, hFldSt, True);
         hFldSt^^.Valid := True;
      end

      else begin
         DrawFldAt(BGFld, hFldSt, myPt, ShowSel, BGErase);
      end;
   end

   else begin
      (* move it first *)
      MoveField(hFld, nil, myPt);

      (* then draw it only if it has a positive length *)
      If (hFld^^.CurLen > 0) Then Begin
         (* Put in a picture comment if cutting to Grfx editor so it knows it's one field. *)
         If (BGCutFlag) Then Begin
            HAlign := Pointer(Ord(AllocBlock(Sizeof(hFld^^.Align)))); (* AllocBlock in aplc/mm/UM1 *)
            If (HAlign <> Nil) then Begin
               HAlign^^ := hFld^^.Align;
               PicComment(cPicTxtBegin, SizeOf(hFld^^.Align), hAlign);
            end;
         end;

         DrawFldAt(hFld, nil, myPt, False, BGErase);

         If (BGCutFlag) AND (hAlign <> Nil) Then Begin
            PicComment(cPicTxtEnd, 0, Nil);
            Freeh(mxHz, pointer(ord(hAlign)));
            NumHandles := NumHandles - 1;
         end;
      end; (* if *)
   end;

   (* Reinstall the field's true runs, and reinstall the Field Editors substitute font parameters *)
   BGInstallRuns(hFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
end;


Procedure DrwLegMark(LegTtl: TitleNames);
(* When showing the data points, draws a marker for legend LegTtl. When data points are off,
   draws a horizontal line. *)

VAR
   XCntr,              (* The X center position of the legends    *)
   YCntr,              (* The Y center position of the legends    *)
   BarWidth,           (* World width of one of the legend bars   *)
   YSpace,             (* Space for one complete legend           *)
   YLowLeft : Real;    (* Y Lower left of one of the mark or line *)
   LegNum   : Integer; (* Legend Number e.g. 1,2,3 .. 8           *)

Begin
   (* Get the upper center position of the entire space for the legend *)
   LegNum := ord(legTtl) - ord(Leg1) + 1;
   GetLegPos(LegNum, XCntr, YCntr);

   (* Calc the Y placement as % of the total height available for legends.
   This calculation must agree with the one in SetLegPos. *)
   YSpace    := (1.0-YFctYTitle) * GraphSize.YMax/LegendMax;
   YLowLeft  := YCntr + 0.40 * YSpace;

   (* Put a marker under these conditions... *)
   If (BGMarkFlag OR (GType = Scatter)) Then Begin
      Moveto2D(XCntr, YLowLeft);
      DrawMark(LegNum);
   end

   (* or else draw a line if markers are turned off e.g. for color *)
   Else Begin
      BarWidth  := GraphSize.XMax * XFctLgWidth;
      Moveto2D(XCntr-BarWidth, YLowLeft);

      CommentHnd^^ := colornum(legnum);
      Line2D(2*BarWidth, 0.0);
      ColorDefault
   end;
End; (* DrwLegmark *)


Procedure DrawLegends;
(* DrawLegends draws all the legends, which are a function of
1. if legends are on
2. how many Y data lists there are
3. the text for each legend
4. the graph type (e.g. bar gets bar texture, line gets line texture)
5. nothing gets drawn for a pie chart *)

Const
   Erase   = True;          (* Always erase before redrawing the field     *)
   ShowSel = True;          (* Show the selection if there is one          *)

VAR
   J      : Integer;        (* loops through for proper number of legends  *)
   LegTtl : TitleNames;     (* Title of each legend in turn                *)
   XPos,
   YPos   : Real;           (* The Real coord center position              *)

Begin
   (* draw the legends only if it's not a pie chart and legends are on *)
   If ((GType <> Pie) and (Legends.LegendFlag)) Then Begin

      LegTtl := Leg1;

      (* Draw each legend in turn, both the texture and the text *)
      For J := 1 to BGData.RepNum Do Begin
         (* Draw the texture *)
         Case Gtype of

            Bar, StackBar, SolidBar: Begin
               If (BarBoolean[J]) Then DrwLegBar (LegTtl)
                                  Else DrwLegMark(LegTtl);
            End; (* Bar case *)

            LineGraph, Scatter, BarLine, BarScat: Begin
               DrwLegMark(LegTtl);
            end;

            NumbAreaGraph, TextAreaGraph: Begin
               DrwLegBar(LegTtl);
            end;

            Pie: Begin
               (* do nothing *)
            End; (* Pie Case *)

            {$IFC fDebug }
            Otherwise Writeln('Ttl/DrawLegend bug');
            {$ENDC }
         End; (* Case *)

         (* then draw the text *)
         GetLegPos(J, XPos, YPos);
         BGDrawFldAt(hFld[LegTtl], XPos, YPos, ShowSel, Erase);

         (* Bump the legend number. This assumes there's another title after the
         last legend. Refer to the TitleNames Type in BG2 *)
         LegTtl := succ(LegTtl);
      End; (* For *)
   End; (* If *)
End; (* Drawlegends *)


Procedure DrawTitles;
(* DrawTitles draws all the titles. The placement and appearance
of the titles is determined by

1. the text the user has entered
2. the current size of the graph,
   a. if fractional page use smaller font set
   b. titles are placed proportionally to size of graph
3. the justification of the title.
4. whether it's the main title or one of the others (main is larger)
                                                        *)
CONST
   Erase   = False;            (* Dont erase before redrawing the field   *)
   ShowSel = True;             (* Show the selection if there is one      *)

VAR
   I         : TitleNames;
   myHFldSt  : HndFState;      (* local ptr to the global field state     *)
   ShowSelect: Boolean;        (* true if the field should be highlighted *)
   XPos, YPos: Real;           (* Real position of this title             *)

Begin
   For I := Main to FootNote Do Begin

      (* Draw Main,Sub, and Footnote for all graph types; don't draw XAx
      and YAx for a pie chart *)
      Case I of

         Main, SubTitle, Footnote: Begin (* Draw these for all graph types *)
            GetTtlPos(I, XPos, YPos);
            BGDrawFldAt(hFld[I], XPos, YPos, ShowSel, Erase);
         End; (* Main etc. Case *)

         XAx, YAx: If (GType <> Pie) Then Begin
            (* Draw these if not a pie chart *)
            GetTtlPos(I, XPos, YPos);
            BGDrawFldAt(hFld[I], XPos, YPos, ShowSel, Erase);
         End; (* XAx,YAx IF case *)
      End; (* Case *)
   End; (* For *)
End; (* DrawTitles *)



Procedure DrawAnnots;
(* DrawAnnots draws all the user annotations. These are placed
in a fractional position on the page so stay in same relative position when
the user changes the graph size. However, the available set of fonts changes
when the user switches from a fractional page to a full page graph
or vice-versa  *)

CONST
   Erase   = True;
   ShowSel = True;

VAR
   myHAnotRec : THAnotRec;
   myHFld     : hndField;
   XPos,
   YPos       : Real;

Begin
   { 3/16/83 SetPnlPort(cBGPnl);  }

   (* Go through each annotation record in the list. Draw it special if its
      the one under edit, else just draw it if the field length is > 0  *)
   myHAnotRec := HAnotFirst;
   While (myHAnotRec <> Nil) do Begin
      myHFld := myHAnotRec^^.AnotFld;

      (* Draw it if it has a positive length or its the one under edit even if 0 length *)
      If (myHFld^^.CurLen > 0) OR (myHFld = BGFld) Then Begin
         XPos := myHAnotRec^^.XFract * GraphSize.XMax;
         YPos := myHAnotRec^^.YFract * GraphSize.YMax;
         BGDrawFldAt(myHFld, XPos, YPos, ShowSel, Erase);
      end;

      (* Advance to the next annotation *)
      myHAnotRec := myHAnotRec^^.AnotNext;
   end;
End; (* DrawAnnots *)


Function TtlSelect(*mouseloc: point; VAR TtlName:TitleNames):BOOLEAN *);
(* TtlSelect returns True iff the mouse location is within one of the
graph titles. In this case, TtlName returns the name of the user
selected title *)

VAR
   I      : Integer;
   Name   : TitleNames;
   Answer : Boolean;
   Exists : Boolean;   (* Set true when the title is being displayed *)

Begin
   Answer    := False;

   (* Loop through each title *)
   For Name := Main to Footnote Do Begin

      Case Name of
         Main, Subtitle, Footnote: Begin
            Exists := True;
         end;

         YAx, XAx: Begin
            Exists := (Gtype <> Pie); (* no axis titles for a pie chart *)
         end;
      end; (* Case *)

      If (Exists AND PtInRect(mouseLoc, hfld[Name]^^.coords)) Then Begin
         (* It's inside this title rectangle *)
         TtlName := Name;
         Answer  := True;
      End; (* If *)
   End; (* For *)

   (* If it wasn't in a title, see about a legend *)
   (* Ck this only if legends are on and it's not a pie chart (since pie chart
   doesn't display legends) *)

   If ((Not Answer) and (Legends.LegendFlag) and (GType <> Pie)) Then Begin

      (* Ck each legend in turn *)
      Name := Leg1;
      For I := 1 to BGData.Repnum Do Begin
         If (PtInRect(mouseLoc, hfld[Name]^^.coords)) Then Begin
            (* It's inside this legend rectangle *)
            TtlName := Name;
            Answer  := True;
         End; (* If *)
         Name := succ(Name);
      End; (* For *)
   End; (* If *)

   TtlSelect := Answer;
End; (* TtlSelect *)


Function  AnotSelect(*mouseLoc: point; VAR HAnotRec: THAnotRec): BOOLEAN*);
(* Returns true and an AnotRec when the mouseloc is over an annotation,
otherwise returns false *)

VAR
   myHAnotRec: THAnotRec;
   myHFld    : hndField;

Begin
   myHAnotRec := HAnotFirst;    (* the one you're checking *)
   HAnotRect  := Nil;           (* the one you'll return   *)

   (* Go until you find one or hit the end of the list *)
   While (HAnotRec = nil) and (myHAnotRec <> Nil) do Begin
      myHFld := myHAnotRec^^.AnotFld;

      (* Have a hit if mouse is in the coords of a field of length > 0 OR
         any time its in the coords of the field under edit *)
      If PtInRect(mouseloc, myHFld^^.coords) AND ((myHFld^^.CurLen > 0) OR (myHFld = BGFld)) Then begin
         HAnotRec := myHAnotRec;
      end

      else begin
         (* Go to the next one *)
         myHAnotRec := myHAnotRec^^.AnotNext;
      end;
   end;

   AnotSelect := (HAnotRec <> Nil);
end;


Procedure GetHAnotRec(* VAR HAnotRec: THAnotRec *);
(* Returns a handle to an empty annotation field. If there's an unused
   anotrec it will reuse it, else it creates a new one at the end of
   the annot list *)

Const
   GrowChar  = 5;     (* grow the number of chars in a field by 5  *)
   RunNumber = 1;     (* original number of runs in a field        *)
   RunGrow   = 2;     (* grow the number of runs by 2 at a time    *)
   Protect   = False; (* Fields are not protected                  *)

VAR
   myHFld     : hndField;
   myHAnotRec : THAnotRec;
   nullRect   : Rect;
   errnum     : Integer;
   mySaveHeap : tHz;

Begin

   (* See if there's an empty AnotRec that can be reused *)
   HAnotRec   := Nil;
   myHAnotRec := HAnotFirst;

   While ((HAnotRec = Nil) and (myHAnotRec <> Nil)) do Begin
      If (myHAnotRec^^.AnotFld^^.CurLen = 0) Then Begin
         (* Found an empty one so reuse it *)
         HAnotRec := myHAnotRec;
         SetRunFormat(myhAnotRec^^.AnotFld, Nil, p12Tile, SetNormal, errNum);
         SetRunFormat(myhAnotRec^^.AnotFld, Nil, p12Tile, SetBold  , errNum);
         SetRunFormat(myhAnotRec^^.AnotFld, Nil, p12Tile, SetFont  , errNum);
      end
      else begin
         myHAnotRec := myHanotRec^^.AnotNext;
      end;
   end;

   (* If didn't find an existing one, create a new one. As of 3/18/83, calls UM1/AllocBlock *)
   If (HAnotRec = Nil) Then Begin
      HAnotRec := Pointer(Ord(AllocBlock(Sizeof(TAnotRec)))); (* AllocBlock in aplc/mm/UM1 *)
      If (HAnotRec = pointer(ord(Nil))) then Begin
         DoStopAlert(20029);
      end
      else begin

         (* Allocate off the matrix mgr heap *)
         mySaveHeap := FldHeap;
         FldHeap  := mxHz;

         SetRect(NullRect, 0, 0, 0, 0);
         myHFld   := CreateField(NullRect, MaxLngth, GrowChar, Left, 4, RunNumber,
                                   RunGrow, p12tile, Protect);
         SetRunFormat(myHFld, nil, p12Tile, setBold, errNum);

         FldHeap := mySaveHeap;

         (* Set the fields in the new record *)
         With HAnotRec^^ do Begin
            AnotFld     := myHFld;
            AnotNext    := Nil;
            XFract      := -1.0;
            YFract      := -1.0;
         end;

         (* Thread the new one into the annot list *)
         (* If it's the first one just make HAnotFirst point at it *)
         If (HAnotFirst = Nil) Then Begin
            HAnotFirst := HAnotRect;
         end
         else begin
            (* Make the old last one pt to this one *)
            myHAnotRec := HAnotFirst;
            While (myHAnotRec^^.AnotNext <> Nil) do begin
               myHAnotRec := myHAnotRec^^.AnotNext;
            end;
            myHAnotRec^^.AnotNext := HAnotRec;
         end;
      end;
   end;
end;



Procedure BGTmOut(* myEvent *);
(* BGTmOut handles the case where the Window Manager reports a timeout
event. If a field is being edited, it:
   1. gets redrawn as needed,
   2. blinks the cursor.
Later on, add code to check if you're editing a legend, adding an
annotation etc. since you may want to blink the cursor etc. there also *)

CONST
   Erase   = True;
   ShowSel = True;

VAR
   errnum: integer;
   myPt  : Point;
   myRgn : rgnHandle;
   hSaveRun: hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;


Begin
   BGPnlPort;

   (* Check if we're editing a field *)
   If (BGFld <> Nil) Then Begin

      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

      (* if the field is not valid, add its coords into the refreshrgn *)
      If (hfldSt^^.Valid) Then BlinkCaret(BGFld, hFldSt, g.CurTimeOut)
      else Begin
         BGMapPt(BGFldX, BGFldY, myPt);
         BGAdjFld(BGFld, myPt);   (* adjust the vertical alignment *)
         MoveField(BGFld, hFldSt, myPt);

         myRgn := NewRgn;
         RectRgn(myRgn, BGFld^^.Coords);
         UnionRgn(myRgn, BGRefreshRgn, BGRefreshRgn);
         DisposeRgn(myRgn);
         StartBlink(g.curTimeOut);
      End;  (* Else *)

      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   End; (* If *)

   (* redraw the graph if BGRefreshRgn contains a rgn to be redrawn *)
   If (EmptyRgn(BGRefreshRgn)) Then Begin
      (* do Nothing *)
   end
   else begin
      EraseBG;
      DrawGraph;
   end;
End; (* BGTmOut *)


Procedure BGUp(* myEvent: EventRec *);
(* BGUp handles a mouse up action *)

Begin
   BGPnlPort;
   StartBlink(g.curTimeOut);
   If (BGFld <> Nil) Then ObscureCursor;
   g.curNbrhood := gp^.portrect;
   AdjRect(BGPnl, g.curNbrHood);
End;


Procedure BGMouseToFract(mouseloc: Point; VAR myXFract, myYFract: Real);
(* Converts a mouseloc to a fraction of the real world graph *)

VAR
   myViewRect : Rect;
   mouseDist,
   TotalDist  : Integer;
   mouseFract : Real;
   CurVisFract: Real;

Begin
   myViewRect := rp^.ViewRect;

   (* Remember we're projecting XUpLeft -> XCurVis onto the ViewRect, so
   calculate the Fractions using the formulas:
      MouseFract = Fraction mouse is into the viewrect
      myXFract   = (XUpLeft + MouseFract*Amount Visible)/GraphSize    *)

   mouseDist  := mouseloc.h - myViewRect.Left;
   TotalDist  := myViewRect.Right - myViewRect.Left;
   mouseFract := mouseDist/TotalDist;
   myXFract   := (XUpLeft + mouseFract*XCurVis)/GraphSize.XMax;

   mouseDist  := mouseloc.v - myViewRect.Top;
   TotalDist  := myViewRect.Bottom - myViewRect.Top;
   mouseFract := mouseDist/TotalDist;
   myYFract   := (YUpLeft + mouseFract*YCurVis)/GraphSize.YMax;
end;


Procedure BGDown(*mouseloc: point*);
(* Handles a BG down event. *)

VAR Ttl       : TitleNames;    (* index to the hit title         *)
    myHAnotRec: THanotRec;     (* Handle to the hit annotation   *)
    myPt      : Point;
    XPos,
    YPos      : Real;          (* real position of an annotation *)
    hSaveRun  : HndRuns;
    SaveRunNumber: Integer;
    SaveSubFont  : Boolean;
    SaveSubDev   : Integer;



   Procedure BGCkRange( VAR myReal: Real; LoLim, HiLim: Real);
   Begin
      If (myReal < LoLim) Then myReal := LoLim
      else if (myReal > HiLim) Then myReal := HiLim;
   end;


   Procedure BGInitFState(mouseloc: Point;
      hSaveRun: HndRuns; SaveRunNumber: Integer; SaveSubFont: Boolean; SaveSubDev: Integer);
   (* Utility proc to save code space *)
   Begin
      InitFState(BGFld, hfldSt);
      Select(mouseloc, BGFld, hfldst, g.curNbrHood, g.curtimeout);
      AdjRect(BGPnl, g.curNbrHood);
      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   end;


Begin
   (* End the Tbl Editor selection and the current range in Lisacalc panel *)
   NullCR;              (* see file TMSProcs3       *)
   GetCR(G.curRange);   (* Tell fexec about it also *)
   ChgStatPnl(False);   (* redraw the status panels *)

   (* Make sure you're in the BG Panel, set up substitute fonts *)
   BGPnlPort;

   (* Ck for double or triple click *)
   If (c.FndDouble) and (BGFld <> Nil) Then Begin
      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      SelectWord(mouseloc, BGFld, hFldSt, g.curNbrhood, g.curTimeOut);
      AdjRect(BGPnl, g.curNbrHood);
      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   end

   else if (c.FndTriple) AND (BGFld <> Nil) Then Begin
      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      ExitField (BGFld, hFldSt);
      SelectAll (BGFld, hfldSt, g.curTimeOut);
      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   end

   { if shiftkey and there's a selection then extend the selection }
   else if (WMEvent.shiftkey and (BGFld <> Nil)) then begin
      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      GrowSel(mouseloc, BGFld, hFldSt, g.curNbrhood);
      AdjRect(BGPnl, g.curNbrHood);
      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   end

   (* everything else treated as a single click, so locate it and reset the selection       *)

   (* See if you hit an annotation first, since they're on top in the picture *)
   Else if (AnotSelect(mouseLoc, myHAnotRec)) Then Begin
      (* End the old selection *)
      BGExit;

      (* Set up the global selection vars and init the fieldstate *)
      With myHAnotRec^^ Do Begin
         BGFld   := AnotFld;
         BGFldX  := XFract*GraphSize.XMax;
         BGFldY  := YFract*GraphSize.YMax;
      end;

      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      BGInitFState(mouseloc, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   end (* Else if *)

   (* else see if hit a title or legend *)
   Else If (TtlSelect(mouseloc, Ttl)) Then Begin
      (* User moused over a title or a legend. *)
      (* Exit the old selection *)
      BGExit;

      (* Store BG info about the new one the user moused over *)
      BGFld   := hFld[Ttl];
      If (Main <= Ttl) AND (Ttl <= FootNote)
         Then GetTtlPos(Ttl, BGFldX, BGFldY)
         else GetLegPos(Ord(Ttl) - Ord(Leg1) + 1, BGFldX, BGFldY);

      (* call the field editor routines to start editing the field *)
      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      BGInitFState(mouseloc, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   End (* If *)

   Else Begin
      (* User moused not over an existing field *)
      (* Exit current field *)
      BGExit;

      (* Set up a new annotation *)
      GetHAnotRec(myHAnotRec);

      With myHAnotRec^^ do Begin
         (* Set up the global selection vars *)
         BGFld   := AnotFld;

         (* move the field to its proper position i.e. somewhat within the very edge of the graph.  *)
         BGMouseToFract(mouseloc, XFract, YFract);
         BGCkRange(XFract, 0.02, 0.96);
         BGCkRange(YFract, 0.05, 0.95);

         BGFldX := XFract * GraphSize.XMax;
         BGFldY := YFract * GraphSize.YMax;
         BGMapPt(BGFldX, BGFldY, myPt);
         BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
         BGAdjFld(BGFld, myPt);
         MoveField(AnotFld, nil, myPt);

         (* Init the fieldstate *)
         BGInitFState(mouseloc, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      end;
   End; (* Else *)
End; (* BGDown *)


Procedure BGMove(*mouseloc: point*);
(* BGMove handles the case where the user has moved the mouse.
Therefore it should handle the case where the user is extending
a text selection. Otherwise, it doesn't have to do much. *)
VAR
   hSaveRun: hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;


Begin
   BGPnlPort;

   If (BGFld <> Nil) Then Begin
      (* Save the current Field editor Substitute font parameters so we can restore them later *)
      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

      (* Grow the selection *)
      GrowSel(mouseloc, BGFld, hFldSt, g.curNbrhood);
      AdjRect(BGPnl, g.curNbrHood);

      (* Restore the substitute font parameters *)
      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   End;
End; (* BGMOve *)


Procedure BGEraseFld;
(* erases the Coords of BGFld and adds the region into BGRefreshRgn *)
VAR
   CoordsRgn : RgnHandle;
   hSaveRun  : hndRuns;
   SaveRunNumber : Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;


Begin
   (* add the old text coords rectangle to the refreshRgn *)
   CoordsRgn := NewRgn;
   RectRgn (CoordsRgn, BGFld^^.Coords);
   UnionRgn(CoordsRgn, BGRefreshRgn, BGRefreshRgn);

   (* Turn off the selection and erase the rgn *)
   BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   HiLightSel(BGFld, hFldSt, False);
   BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   EraseRgn(CoordsRgn);

   (* Dispose of the rgn *)
   DisposeRgn(CoordsRgn);
end;



Procedure BGKey(* myEvent *);
(* BGKey handles a keyboard input event. *)

CONST
   ShowSel = False;

VAR
   errnum       : integer;
   Rgn1,
   Rgn2         : RgnHandle;
   myPt         : Point;
   hSaveRun     : hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;


Begin
   If (BGFld <> Nil) Then Begin
      BGPnlPort;
      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      CaretOn(BGFld, hFldSt);
      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

      With myEvent Do Begin
         (* Branch off the type of character in the eventrecord *)
         Case ord(ascii) of
            chbs: Begin
               if (shiftKey) and (AppleKey) Then Begin
                  ForwardWord(BGFld, hFldSt, errnum);
               end

               else if (shiftKey) and (NOT AppleKey) Then Begin
                  Forwardspace(BGFld, hFldSt, errnum);
               End (* else if *)

               else if (NOT ShiftKey) and (AppleKey) Then Begin
                  BackWord(BGFld, hFldSt, errnum);
                  hFldSt^^.ValidLP := 0;
                  BGEraseFld;
               end

               Else Begin
                  (* delete the character from the text data *)
                  BackSpace(BGFld, hFldSt, errnum);
                  hFldSt^^.ValidLP := 0;
                  If (Errnum = 0) Then BGEraseFld;
               End; (* Else *)
            End; (* chbs *)

            (* filter out the field motion keys - return, tab, etc. *)
            chLeft, chRight, chUp, chdown, chTab, chReturn, chEnter: Begin
               DoStopAlert(20021);
               SetPnlPort(cBGPnl);

               (* Following is a special case for a blinking caret to avoid caret garbage left on screen *)
               If (BGFld^^.CurLen > 0) Then With hFldSt^^.select.int do begin
                  If (lpFst = lpLim) Then Begin
                     hFldSt^^.ValidLP := 0;
                     BGEraseFld;
                     DrawGraph;
                  end;
               end;
            end;

            (* insert the character into the field *)
            Otherwise begin
               (* Remember the old coords *)
               Rgn1 := NewRgn;
               RectRgn(Rgn1, BGFld^^.Coords);

               (* Insert the character and move the field to the new position *)
               InsCh(ascii, BGFld, hFldSt, errnum);
               BGMapPt(BGFldX, BGFldY, myPt);
               BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
               BGAdjFld(BGFld, myPt);   (* adjust the vertical alignment *)
               MoveField(BGFld, hFldSt, myPt);
               BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);

               (* Get the new coords *)
               Rgn2 := NewRgn;
               RectRgn(Rgn2, BGFld^^.Coords);

               (* Subtract the regions. Redraw just the field if the field got bigger.
                  Refresh the whole screen if the field got smaller, since something in
                  the background may have appeared. *)
               DiffRgn(Rgn1, Rgn2, Rgn1);
               If (EmptyRgn(Rgn1)) Then Begin
                  BGDrawFldAt(BGFld, BGFldX, BGFldY, True, True);
               end
               else begin
                  UnionRgn(Rgn1, BGRefreshRgn, BGRefreshRgn);
               end;

               DisposeRgn(Rgn1);
               DisposeRgn(Rgn2);

               ObscureCursor;
               ClrUndo;
               SetUndo(uBGKey, BGPnl);
               uBGFld := BGFld;  (* remember the field for possible undo *)
            End;
         End; (* Case *)
      End; (* With *)

      g.curTimeOut := 0;
      {$IFC fDebug }
      If (errnum <> 0) Then Writeln('*** Ttl/BGKey has error # ',errnum);
      {$ENDC }
   end
   else begin
      DoStopAlert(20032);
   end;
End; (* BGKey *)


Procedure BGExit;
(* BGExit does all the actions necessary when the user exits BGPnl.
At this point, all that need be done is to end the text selection *)
VAR
   hSaveRun: HndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;


Begin
   BGPnlPort;

   If (BGFld <> Nil) Then Begin
      (* End the selection *)
      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      ExitField(BGFld, hfldSt);
      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      BGFld := Nil;
   End; (* If *)

   If (BGAllFlag) Then Begin
      BGInvertAll;
      BGAllFlag := False;
   end;
End; (* BGExit *)


(*$S     *)
Procedure DoBGAct(* Activate: Boolean *);
(* Handles the activate/deactivate event by dim highlighting the BG selection *)
VAR
   hSaveRun: hndRuns;
   SaveRunNumber: Integer;
   SaveSubFont  : Boolean;
   SaveSubDev   : Integer;


Begin
   BGPnlPort;

   (* Remember BG's state *)
   BGActive := Activate;

   If (BGFld <> Nil) Then Begin
      (* Dim highlight the selection properly *)
      BGSwapRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
      ChangeSelHiLight(BGFld, hFldSt, not Activate);
      BGInstallRuns(BGFld, hSaveRun, SaveRunNumber, SaveSubFont, SaveSubDev);
   end

   else if BGAllFlag then begin
      BGInvertAll;
   end;
   SetPnlPort(FolderPnl);
end;


(*$S     *)
Procedure BGGetPt(*myHFld: hndField; VAR XPt, YPt: Real*);
(* Given a handle to a field, this returns the point at which to draw it. *)

VAR
   I          : TitleNames;
   Found      : Boolean;
   myHAnotRec : THanotRec;

Begin
   XPt := -1.0;    (* Return these if don't find anything else *)
   YPt := -1.0;
   Found := False;

   (* Ck the titles *)
   I := Main;
   While (Not Found) AND (I <= FootNote) do Begin
      If (myHFld = hFld[I]) Then Begin
         GetTtlPos(I, XPt, YPt);
         Found := True;
      end
      Else Begin
         I := succ(I);
      end;
   end;

   (* Ck the legends if needed *)
   I := Leg1;
   While (Not Found) AND (I <= Leg8) do Begin
      If (myHFld = hFld[I]) Then Begin
         GetLegPos(Ord(I) - Ord(Leg1) + 1, XPt, YPt);
         Found := True;
      End
      Else Begin
         I := succ(I);
      end;
   End;

   (* check the annots *)
   myHAnotRec := HAnotFirst;
   While (Not Found) AND (myHAnotRec <> Nil) do Begin
      With myHAnotRec^^ do begin
         If (BGFld = AnotFld) Then Begin
            XPt := XFract*GraphSize.XMax;
            YPt := YFract*GraphSize.YMax;
            Found := True;
         end

         else begin
            myHAnotRec := AnotNext;
         end;
      end; (* With *)
   end; (* While *)
end;


Procedure BGInvertAll;
(* Visually inverts the BG Pnl Rect *)

VAR
   myPnlRect: Rect;

Begin
   GetPnlRect(BGPnl, myPnlRect);
   InvertRect(myPnlRect);
end;


Function LegSelect(* : Boolean *);
(* Returns True iff a legend title is the current selection *)
VAR
   J: TitleNames;
   Answer : Boolean;
begin
   Answer := False;
   For J := Leg1 to Leg8 do Answer := Answer OR (BGFld = hFld[J]);
   LegSelect := Answer;
end;


(*$S     *)
Procedure BGPnlPort;
(* Sets the pnlport to BGPnl and sets the cliprgn to the intersection of the
BGPnlRect and the Graphsize rect *)
VAR
   pt1,
   pt2       : Point;
   myRgn     : rgnHandle;
   GraphRect : Rect;

Begin
   SetPnlPort(BGPnl);
   With GraphSize do Begin
      BGMapPt(XMin, YMin, Pt1);
      BGMapPt(XMax, YMax, Pt2);
   end;

   Pt2Rect(Pt1, Pt2, GraphRect);
   myRgn :=NewRgn;
   RectRgn(myRgn, GraphRect);
   SectRgn(gp^.clipRgn, myRgn, gp^.ClipRgn);
   DisposeRgn(myRgn);
end;


(*$S BGInit *)
End.

