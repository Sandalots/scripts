
                            {'Copyright 1983, 1984, Apple Computer Inc.'}

(* include file for apbg/BG1A *)

(*$S BGInit*)
Procedure SetDataDflt;
(* Sets up all the default data values *)

VAR
   I: Integer;

Begin

   (* Note: aplc/Lcfexec/InitFexec calls InitHeap and BG uses that same heap
   for its data records *)

   (* Init the RealPort pointer to Nil so these data points will not
   be plotted as I enter them. FxNewRgImg does not call DrawGraph if
   the rp pointer is nil. *)
   rp := nil;

   (* Remember there's 1 Y data list, init XListTot and all the minimum
   data values. These get reset when the matrix manager calls fxNewRgImg
   that will compare the new value against these Min and Max values *)
   With BGData Do Begin
      RepNum   := 1;
      XListTot := 0;

      (* Set the default data min and max *)
      XMinData := 0;
      XMaxData := 100;
      YMinData := 0;
      YMaxData := 100;
   End; (* With *)

   For I := 1 to YListMax do Begin
      BarBoolean[I]   := True;    (* Start with a bar representation *)
      RgrsBoolean[I]  := False;   (* Dont show regression lines      *)
      BGData.First[I] := Nil;
      BGData.Unread[I]:= Nil;
   end;
   BGMarkFlag := True;            (* Show markers on the data lines  *)
End; (* SetDataDflt *)


(*$S BGInit*)
Procedure SetAxesDflt;
(* SetAxesDflt sets the default values for the X and Y axes.
The Min, Org, and Max values for the axes must be big enough
to include all the data values set above by SetDataDflt.

Later, change all these assignments to procedure calls  *)

Begin
   With XAxis do Begin

      MinSet := False;
      OrgSet := False;
      MaxSet := False;
      AxIncrSet := False;

      XPos1 := PlotBndry.XMin;
      YPos1 := PlotBndry.YMax;

      Delta := PlotBndry.XMax - PlotBndry.XMin;
      Grid  := False;
   End; (* With *)

   With YAxis do Begin

      MinSet := False;
      OrgSet := False;
      MaxSet := False;
      AxIncrSet := False;

      XPos1 := PlotBndry.XMin;
      YPos1 := PlotBndry.YMax;

      Delta := PlotBndry.YMax-PlotBndry.YMin;
      Grid  := False;
   End; (* With *)
End; (* SetAxesDflt *)


(*$S BGInit*)
Procedure InitState;
(* InitState sets all the state variables to their default        *)

Begin
   (* Init the BigNum that should be bigger than any user number. This number
   is used by the X and Y axis calculation routines *)
   BigNum := 1.0/0.0;

   (* Set the type to bar, and the size to default *)
   GType := Bar;
   SetPgSize(XSizeDflt, YSizeDflt);
   GraphSize       := PaperSize;
   GraphProportion := Half;
   BGPreview       := False;

   (* Turn off the x and y grid, and legends on *)
   XAxis.grid := False;
   YAxis.grid := False;
   Legends.LegendFlag := True;

   (* No cut currently in progress *)
   BGCutFlag := False;    (* vars in apbg/BG2 *)
   BGAllFlag := False;
   BGActive  := True;
End; (* InitState *)


(*$S     *)
Procedure SetAxes;
(* SetAxes recalculates all the dependent variables for the
Axes records. It assumes that the PlotBndry has already been set *)

Begin
   With XAxis Do Begin
      Delta := PlotBndry.XMax - PlotBndry.XMin;
      XPos1 := PlotBndry.XMin;
      YPos1 := PlotBndry.YMax;
   End; (* With *)

   With YAxis Do Begin
      Delta := PlotBndry.YMax - PlotBndry.YMin;
      XPos1 := PlotBndry.XMin;
      YPos1 := PlotBndry.YMax;
   End; (* With *)
End;


(*$S     *)
Procedure SetPlotSize;
(* SetPlotSize calculates and stores the world coordinates of the
plot boundary. These points are a function of whether legends
are off or on *)

Begin
   With PlotBndry Do Begin

      (* Calculate the upper left pt of the plot boundary         *)
      XMin := XFct1*GraphSize.XMax;
      YMin := YFct1*GraphSize.YMax;

      (* Calculate the lower right corner *)
      If (Legends.LegendFlag)
         Then XMax := XFct2*GraphSize.XMax  (* legends are on *)
         Else XMax := XFct3*GraphSize.XMax; (* legends are off *)

      YMax := YFct2 * GraphSize.YMax;
   End; (* With *)
End; (* SetPlotSize *)


(*$S     *)
Procedure SetPlotRect;
(* SetPlotRect stores the Lisagraf coordinates into the PlotRect rect *)
VAR
   pt1,pt2 : point;  (* Lisagraf points (upper left and lower right ) *)

Begin
   With PlotBndry Do Begin
      BGMapPt(XMin, YMin, pt1);
      BGMapPt(XMax, YMax, pt2);
   End;

   (* Store the coordinates into the PlotRect variable *)
   Pt2Rect(pt1, pt2, PlotRect);
End;


(*$S     *)
Procedure SetPlotBndry;
(* SetPlotBndry sets the world coord plot size into PlotBndry, and sets
the Lisagraf rectangle into PlotRect *)
Begin
   SetPlotSize;
   SetPlotRect;
End;


(*$S     *)
Procedure Calc0Axis(MinData, MaxData: Real; VAR MinAxis, MaxAxis: Real;
                   VAR BGIntrvl: Real; VAR LayblTot: Integer);
(* Calc0Axis calculates and returns MinAxis and MaxAxis such that:
   1. MinAxis <= 0 <= MaxAxis  (i.e. 0 is in the axis range),
   2. MinAxis <=MinData <= MaxData <= MaxAxis (i.e. the axis includes all
      the data points),
   3. MinAxis and MaxAxis are 'easy to read' (i.e. they are 2, 4, 5, or 10
      times an integral power of 10).

   Additionally, LayblTot is returned as the number of labels on the axis,
   and BGIntrvl is returned as the interval between labels    *)

VAR
   myDataDelt: Real;      (* range of the data                 *)
   myDataNormal: Real;    (* normalized data in range 10-100   *)
   myLog     : Real;      (* log of the data range             *)
   PwrFactor : Real;      (* 10**IntPower                      *)
   intrvl    : Real;      (* Interval between succesive labels *)
   (* 3/24/83 changed Slide from Integer to LongInt to correct overflow problem.      *)
   Slide     : LongInt;   (* Number of intervals to move to get MinAxis below MinData *)

Procedure BGGetIntrvl( DataNormal: Real; VAR Intrvl: Real;
                       VAR LayblTot: Integer);
(* Helper routine to return the interval size and the number of labels
   given a data range normalized from 0 to DataNormal, where DataNormal
   is in the range 10 to 100 *)

Begin
  (* Branch on which interval DataNormal is in *)
  If (DataNormal < 40) Then Begin
     If (DataNormal < 16) Then Begin
        (* Range 10-16. Labels are 0, 4, 8, 12, 16 *)
        Intrvl := 4;
        LayblTot := 5;
     End { if }
     Else Begin
        If (DataNormal < 25) Then Begin
           { Range 16-25. Labels are 0, 5, 10, 15, 20, 25 }
           intrvl := 5;
           LayblTot := 6;
        End { If }
        Else Begin
           { Range 25-40 }
           Intrvl := 10;
           LayblTot := 5;
        End;{ Else }
     End; { Else }
  End { If }
  Else Begin { DataNormal >= 40 }
     If (DataNormal < 50) Then Begin
        { Range 40-50. Labels are 0, 10, 20, 30, 40, 50 }
        Intrvl := 10;
        LayblTot := 6;
     End { If }
     Else Begin
        If (DataNormal < 80) Then Begin
           { Range 50-80 }
           Intrvl := 20;
           LayblTot := 5;
        End { If }
        Else Begin
           { 80- 100 }
           Intrvl := 20;
           LayblTot := 6;
        End; { Else }
     End; { Else }
  End; { Else }
End; { BGGetIntrvl }

Begin { Calc0Axis }
   myDataDelt := MaxData - MinData;
   If (myDataDelt <= 0.0) Then myDataDelt := 1.0;

   { Set PwrFactor to an integral power of ten }
   { e.g. 10^-2 for range (0.1,1); 10^-1 for (1,10); 10^0 for (10,100); 10^1 for (100,1000) etc. }
   myLog := Alog10(myDataDelt);
   If      (myLog <= -35) Then pwrFactor := PwrOfTen(-37)
   Else if (myLog < 0   ) Then pwrFactor := PwrOfTen(Trunc(myLog) -2)
                          Else pwrFactor := PwrOfTen(Trunc(myLog) -1);

   { Normalize the data to range (10,100) }
   myDataNormal := myDataDelt/PwrFactor;

   { Get the normalized interval size and the number of labels }
   BGGetIntrvl(myDataNormal, Intrvl, LayblTot);

   { Scale the interval to the real size }
   Intrvl   := Intrvl * PwrFactor;
   BGIntrvl := Intrvl; (* return the interval *)

   (* Figure 'slide value' to get MinAxis below MinData *)
   If (MinData >= 0) Then Slide := Trunc(MinData/Intrvl)
                     Else Slide := Trunc(MinData/Intrvl) - 1;
   MinAxis := Slide * Intrvl;

   { If needed, bump LayblTot so MaxAxis will include all the data points. The LayblTot < 50 is
     just a bug-catcher to prevent infinite loops. }
   MaxAxis := MinAxis + (LayblTot-1) * Intrvl;
   While (MaxAxis <= MaxData ) do begin
      LayblTot := LayblTot + 1;
      MaxAxis := MinAxis + (LayblTot-1) * Intrvl;
      If (LayblTot > 50) Then Begin
         {$IFC fDebug }
         Writeln;
         writeln('BG1B/Calc0Axis error with MinData, MaxData = ', MinData, MaxData);
         writeln('MinAxis, MaxAxis, Intrvl, LayblTot = ', MinAxis, MaxAxis, Intrvl, LayblTot);
         {$ENDC}

         MaxAxis := MaxData + 1.0;
      end;
   End; { While }
End; { Calc0Axis }


(*$S     *)
Procedure ReCalcXAxis;
(* RecalcXAxis recalculates the X axis based on the state variables
in BGData.XMinData, BGData.XMaxData. It also takes into account the
axis min and max requested by the user if he has set those values.
NOTE: On an error, the NoteAlerts should not update the screen after
they go away. See routine DoNoteAlert. *)

VAR
   NewMinAxis,              (* new minimum Y axis value rtned            *)
   NewMaxAxis: Real;        (* new maximum Y axis value rtned            *)
   Int       : Real;        (* the interval between labels rtned         *)
   FudgeMin  : Real;        (* a value slightly below the Y data minimum *)
   FudgeMax  : Real;        (* a value slightly above the Y data maximum *)
   NewLayblTot: Integer;
   aRg        : Range;

Begin
   (* Calculate the new X axis range. Make sure that there are no data points
   below the minimum axis or above the maximum axis. *)

   With BGData, XAxis do Begin
      (*******************************************************************)
      (* Calculate the minimum to send to the calculation routines.      *)
      (* If the user set the minimum, use the lesser of his value and the
         lowest data point *)

      If ((MinSet) AND (Min <= XMinData)) Then FudgeMin := Min
      else Begin
         FudgeMin := XMinData - 0.0005*ABS(XMinData);
         (* If MaxSet, then ensure FudgeMin is enough below the user set axis max *)
         If (MaxSet) Then BGMin(FudgeMin, Max - 0.02);
      end;

      (****************************************************************************)
      (* Calculate the maximum to send to the calculation routines                *)
      (* Send in the user set maximum if its greater than all the data points     *)

      If ((MaxSet) AND (Max >= XMaxData)) Then FudgeMax := Max
      Else FudgeMax := XMaxData + 0.0008*ABS(XMaxData);
   end; (* With *)

   (* Make sure FudgeMax > FudgeMin. (Consider XMinData = XMaxData = 0)   *)
   If (FudgeMax <= FudgeMin) Then FudgeMax := FudgeMin + 0.02;

   (***********************************************************************)
   (* Calculate the new preferred, automatic axis range                   *)

   Calc0Axis(FudgeMin, FudgeMax, NewMinAxis, NewMaxAxis, Int, NewLayblTot);

   (***********************************************************************)
   (* Set the proper values in the XAxis record                           *)

   With XAxis Do Begin

      (********************************************************************)
      (* Set the axis minimum *)

      If (MinSet) Then Begin
         (* Reset the user set axis minimum if there's a data point below the minimum *)
         If (BGData.XMinData < Min) Then Begin
            Min    := NewMinAxis;
            MinSet := False;
            doNoteAlert(20005); { overriding X axis minimum }
         end;
      end
      else Begin
         (* User has not set the minimum so I'll do it automatically *)
         Min := NewMinAxis;
      end; (* Else *)

      (*********************************************************************)
      (* Set the axis maximum                                              *)

      If (MaxSet) Then Begin
         (* Reset the user set maximum if there's a data point above it *)
         If (BGData.XMaxData > Max) Then Begin
            Max    := NewMaxAxis;
            MaxSet := False;
            doNoteAlert(20006); { overriding X axis maximum }
         end;
      end
      else Begin
         (* User has not set the maximum so I'll do it automatically *)
         Max := NewMaxAxis;
      end; (* Else *)

      (*********************************************************************)
      (* Set the axis origin                                               *)

      If (OrgSet) Then Begin
         (* User set the origin so I must use it as is *)
         If (Org < Min) Then Min := Org;
         If (Org > Max) Then Max := Org;
      End (* If *)

      Else Begin
         (* User didn't set the origin so I'll pick out a good value. *)
         (* Use 0 if the axis range includes 0, else use the min value *)
         If ((Min <= 0) and (0 <= Max)) Then Org := 0
                                        Else Org := Min;
      End; (* Else *)

      (*********************************************************************)
      (* Set the increment                                                 *)
      If (AxIncrSet) Then Begin
         (* Use the users increment if he set it and it makes sense *)
         If ((Max - Min)/UserAxIncr < 20.0) Then AxIncr := UserAxIncr
         else begin
            AxIncr := Int;
            AxIncrSet := False;
            doNoteAlert(20007);
         end;
      end
      else AxIncr := Int;
   End;

   (* 10/26/83 Because of the regression feature, must also check the Y axis here.
      Whenever you change the X axis min and max, this can possibly affect the
      Y axis min and max via the regression values at the ends of the X axis *)
   SetRg(aRg, aWTBoxRg, minfsnip, minfsnip, pinfsnip, pinfsnip);
   CkYAxisRange(aRg);
End; (* RecalcXAxis *)


(*$S     *)
Procedure ReCalcYAxis;
(* RecalcYAxis recalculates the Y axis based on the state variables
in BGData.YMinData, BGData.YMaxData. It also takes into account the
axis min and max requested by the user if he has set those values *)

VAR
   NewMinAxis,              (* new minimum Y axis value rtned            *)
   NewMaxAxis: Real;        (* new maximum Y axis value rtned            *)
   Int       : Real;        (* the interval between labels rtned         *)
   FudgeMin : Real;        (* a value slightly below the Y data minimum *)
   FudgeMax : Real;        (* a value slightly above the Y data maximum *)
   NewLayblTot: Integer;

Begin
   (* Calculate the new Y axis range. Make sure that there are no data points
      below the axis minimum or above the axis maximum. *)

   With BGData, YAxis do Begin
      (**************************************************************************)
      (* Calculate the minimum to send to the calculation routines *)
      (* If the user set the minimum and its below all the data then use it *)
      (* 3/24/83 if test changed so FudgeMin set to min only when Min <= YMinData. *)

      If ((MinSet) AND (Min <= YMinData)) Then FudgeMin := Min
      else begin
         (* user didn't set the value or set it improperly so calc the axis min
         based on the lesser of the datamin or 0 *)
         FudgeMin := YMinData - 0.0001*Abs(YMinData);
         BGMin(FudgeMin, 0);
         If (MaxSet) then BGMin(FudgeMin, Max - 0.02);
      end;

      (* Send in the Org if the user set it and it's below FudgeMin *)
      If (OrgSet) Then BGMin(FudgeMin, Org);

      (**************************************************************************)
      (* Calculate the maximum to send to the calculation routines *)
      (* If the user set the maximum and it's above all the data points then use it *)

      If ((MaxSet) AND (Max >= YMaxData)) Then FudgeMax := Max
      else begin
         (* user didn't set the value or he set it improperly so calc the axis max
            based on the greater of datamax or 0 *)
         FudgeMax := YMaxData + 0.0001*Abs(YMaxData);
         BGMax(FudgeMax, 0);
      end;

      (* Send in Org if the user set it and it's bigger than FudgeMax *)
      If (OrgSet) Then BGMax(FudgeMax, Org);
   end; (* With *)


   (***************************************************************************)
   (* Calculate the new preferred, automatic axis range                       *)

   Calc0Axis(FudgeMin, FudgeMax, NewMinAxis, NewMaxAxis, Int, NewLayblTot);

   (* Stuff the proper info into the Y axis variables. Calc0Axis calculates
      the preferred ones, now I have to decide whether to use those or the
      ones the user set *)

   With YAxis Do Begin
      (* Set the axis minimum *)
      If (MinSet) Then Begin
         (* Reset the user set minimum if there's a data point below it. *)
         If (BGData.YMinData < Min) Then Begin
            Min    := NewMinAxis;
            MinSet := False;
            doNoteAlert(20000); { overriding user set Y axis minimum }
         end;
      end
      else Begin
         (* User has not set the minimum so I'll do it automatically *)
         Min := NewMinAxis;
      end; (* Else *)

      (* Set the axis maximum *)
      If (MaxSet) Then Begin
         (* Reset the user set maximum if there's a data point above it *)
         If (BGData.YMaxData > Max) Then Begin
            Max    := NewMaxAxis;
            MaxSet := False;
            doNoteAlert(20001); { overriding user set Y axis maximum }
         end;
      end
      else Begin
         (* User has not set the maximum so I'll do it automatically *)
         Max := NewMaxAxis;
      end; (* Else *)

      (* Set the axis origin *)
      If (OrgSet) Then Begin
         (* User set the origin so I must use it as is *)
         If (Org < Min) Then Min := Org;
         If (Org > Max) Then Max := Org;
      End (* If *)

      Else Begin
         (* User didn't set the origin so I'll pick out a good value. *)
         (* Use 0 if the axis range includes 0, else use the min value *)
         If ((Min <= 0) and (Max >= 0)) Then Org := 0
                                        Else Org := Min;
      End; (* Else *)

      (* Reset the interval size *)
      If (AxIncrSet) Then Begin
         (* Use the users increment if he set it and it makes sense *)
         If ((Max - Min)/UserAxIncr < 20.0) Then Begin
            AxIncr := UserAxIncr;
         end
         else begin
            AxIncr := Int;
            AxIncrSet := False;
            doNoteAlert(20003); { user set the Y axis incr too small }
         end;
      end

      else begin
         AxIncr := Int;
      end;
   End;
End; (* RecalcYAxis *)


(*$S     *)
Procedure CkXAxisRange;
(* CkXAxisRange checks and possibly resets the Min and Max X data values
used to determine the X axis range for a numerical X axis. It assumes that
the linked lists are already set up. *)

VAR
   NewXMin,
   NewXMax      : Real;      (* the min and max in the table currently   *)
   Temp         : Real;      (* Value out of Cell[I,J] in the data table *)
   J            : Integer;
   myPtr        : DataRecHandle;

Begin
   (* set the NewXMin and NewXMax values to their opposite extremes *)
   NewXMin := +BigNum;
   NewXMax := -BigNum;
   ResetData;

   (* Go through each data list to find the min and max. NOTE: The lists are sorted
      from smallest X value to largest. *)
   For J := 1 to BGData.RepNum do Begin
      (* Get the first value and compare it to the previous minimum value *)
      myPtr := GetDataPtr(J);
      If (myPtr <> Nil) Then BGMin(NewXMin, myPtr^^.XVal);

      (* Get the last value and compare it to the previous maximum value *)
      Temp := -BigNum;
      While (myPtr <> Nil) do Begin
         Temp  := myPtr^^.XVal;
         myPtr := GetDataPtr(J);
      end;
      BGMax(NewXMax, Temp);
   end;

   (* Recalc the X axis range if either the min or the max has changed *)
   With BGData Do Begin
      If ((NewXMax <> XMaxData) or (NewXMin <> XMinData)) Then Begin
         XMaxData := NewXMax;
         XMinData := NewXMin;
         ReCalcXAxis;
      End; (* If *)
   End; (* With *)
End; (* CkXAxisRange *)


Procedure CkYNumbRange(aRg: Range; VAR newYMin, newYMax: Real);
(* CkYNumbRange returns the Y Min and Max data points when there's a numerical X axis.
It goes down the linked lists to determine the min and max values. *)

VAR
   NANResult    : cnSymKind; (* Not A Number (NAN)                             *)
   RowId,ColId  : Integer;   (* indices into the data table                    *)
   Temp         : Real;      (* Value out of Cell[I,J] in the data table       *)
   myPtr        : DataRecHandle;
   J            : Integer;

Begin
   ResetData;
   newYMin := +BigNum;
   newYMax := -BigNum;

   (* Go through the data for each data rep (each column) in turn *)
   For J := 1 to BGData.RepNum do Begin
      myPtr := GetDataPtr(J);
      While (myPtr <> Nil) Do Begin
         (* Get the Y value out of the matrix *)
         RowId := myPtr^^.XIndex;
         ColId := J+1;
         GetValReal(RowId, ColId, NANResult, Temp);

         (* Compare the Y value to the previous min and max Y values *)
         BGMin(newYMin, Temp);
         BGMax(newYMax, Temp);

         (* Get the next data value *)
         myPtr := GetDataPtr(J);
      end;
   end;
end;


Procedure InitRgrsn(VAR N: Integer; VAR SumX, SumY, SumXY, SumXSqr, SumYSqr: Real);
Begin
   N := 0;
   SumX := 0.0; SumY := 0.0; SumXY := 0.0; SumXSqr := 0.0; SumYSqr := 0.0;
end;


Procedure AddRgrsnStats(X, Y: Real; VAR SumX, SumY, SumXY, SumXSqr, SumYSqr: Real);
Begin
   SumX    := SumX + X;      SumY := SumY + Y;         SumXY := SumXY + X*Y;
   SumXSqr := SumXSqr + X*X; SumYSqr := SumYSqr + Y*Y;
end;


Procedure CalcRgrsnStats(I, N: Integer; SumX, SumY, SumXY, SumXSqr, SumYSqr: Real);
VAR
   Denom,
   Temp : Real;

Begin
   With RgrsArray[I] do Begin
      (* Calculate the slope *)
      Denom   := (SumXSqr - (SumX*SumX/N));
      If (Denom = 0.0) Then RSlope := 0.0
                       Else RSlope  := (SumXY - (SumX*SumY/N))/Denom;


      (* the intercept *)
      Intrcpt := (SumY - RSlope*SumX)/N;

      (* and the RSquared *)
      Temp    := SumY*SumY/N;
      Denom   := (SumYSqr - Temp);
      If (Denom = 0.0) Then RSquare := 1.0
                       Else RSquare := (Intrcpt*SumY + RSlope*SumXY - Temp)/Denom;
      (* Dont let roundoff make rSquare bigger than 1.0 *)
      BGMin(RSquare, 1.0);
   end;
end;



Procedure CkY2RgrsnRange(aRg: Range;VAR newYMin, newYMax: Real);
(* Returns the extreme regression values in newYMin and newYMax if they are more
extreme than the newYMin and Max coming in. As a side effect, it sets the
Regression values in RgrsArray for all the data reps with their regression turned on *)
VAR
   I, N, ColId,
   RowId: Integer;
   NANResult : cnSymKind;  (* Not A Number (NAN)                 *)
   X, Y, SumX, SumY, SumXY, SumXSqr, SumYSqr : Real;

Begin
   For I := 1 to BGData.RepNum do Begin
      If (RgrsBoolean[I]) Then Begin
         (* Init, then collect all the stats for this data rep *)
         InitRgrsn(N, SumX, SumY, SumXY, SumXSqr, SumYSqr);
         ColId := I + 1;

         For RowId := 1 to BGData.XListTot do Begin
            If (CellHasValue(RowId, ColId)) Then Begin
               N := N+1;
               X := RowId;
               GetValReal(RowId, ColId, NanResult, Y);
               AddRgrsnStats(X, Y, SumX, SumY, SumXY, SumXSqr, SumYSqr);
            end;
         end;

         (* Calculate and store all the regression figures for the Ith data rep *)
         CalcRgrsnStats(I, N, SumX, SumY, SumXY, SumXSqr, SumYSqr);

         (* Calculate the required extreme values *)
         With RgrsArray[I] do Begin
            Y := Intrcpt + RSlope;
            BGMin(NewYMin, Y);
            BGMax(newYMax, Y);

            Y := Intrcpt + RSlope*BGData.XListTot;
            BGMin(newYMin, Y);
            BGMax(newYMax, Y);
         end;
      end;
   end;
end;




Procedure CkYStackRange(aRg: Range; VAR newYMin, newYMax: Real);
(* CkYStackRange returns the Y min and Max data points when there's a stacked bar chart.
It basically looks through the entire table summing the values to get the min and
max values. *)
VAR
   RowYMax,
   RowYMin      : Real;      (* min and max sum of the row under consideration *)

   NANResult    : cnSymKind; (* Not A Number (NAN)                             *)
   RowId,ColId  : Integer;   (* indices into the data table                    *)
   Temp         : Real;      (* Value out of Cell[I,J] in the data table       *)

Begin
   (* Init the new potential min and max data values *)
   NewYMin := 0.0;
   NewYMax := 0.0;

   (* Look through each row in turn to find the data min and max *)
   For RowId := 1 to BGData.XListTot Do Begin
      RowYMax := 0.0;
      RowYMin := 0.0;

      (* Look at each cell in this row *)
      For ColId := 2 to BGData.RepNum + 1 Do Begin
         (* Consider the cell only if there's a value there *)
         If (CellHasValue(RowId, ColId)) Then Begin
            GetValReal(RowId, ColId, NANResult, Temp);

            (* For stacked bars, sum the positive and negative heights of all the stacked bars.
               Don't consider values here that get graphed as a line *)
            If (BarBoolean[ColId - 1]) Then Begin
               If (Temp >= 0.0) Then RowYMax := RowYMax + Temp
                                Else RowYMin := RowYMin + Temp;
            end

            (* if it's graphed as a line just look at the immediate data value *)
            Else Begin
               BGMin(NewYMin, Temp);
               BGMax(newYMax, Temp);
            end;
         End; (* If on CellHasValue *)
      End; (* For on ColId *)

      (*Reset the min and max if the current row sums are more extreme *)
      BGMin(NewYMin, RowYMin);
      BGMax(NewYMax, RowYMax);
   End; (* For on RowId *)

   CkY2RgrsnRange(aRg, newYMin, newYMax);
End;



Procedure CkYTextRange(aRg: Range; VAR newYMin, newYMax: Real);
(* CkYTextRange returns the Y min and Max data points when there's a text X axis. It
basically looks through the entire table to get the min and max values. *)
VAR
   NANResult    : cnSymKind; (* Not A Number (NAN)                             *)
   RowId,ColId  : Integer;   (* indices into the data table                    *)
   Temp         : Real;      (* Value out of Cell[I,J] in the data table       *)

Begin
   (* Init the new potential min and max data values *)
   NewYMin := +BigNum;
   NewYMax := -BigNum;

   (* Look through each row in turn to find the data min and max *)
   For RowId := 1 to BGData.XListTot Do Begin
      (* Look at each cell in this row *)
      For ColId := 2 to BGData.RepNum + 1 Do Begin
         (* Consider the cell only if there's a value there *)
         If (CellHasValue(RowId, ColId)) Then Begin
            GetValReal(RowId, ColId, NANResult, Temp);

            (* Reset the min and max if the new value is outside of them *)
            BGMin(NewYMin, Temp);
            BGMax(NewYMax, Temp);
         End; (* If on CellHasValue *)
      End; (* For on ColId *)
   End; (* For on RowId *)

   CkY2RgrsnRange(aRg, newYMin, newYMax);
End;


Procedure CkYRgrsnRange(aRg: Range; VAR RgrsnMin, RgrsnMax: Real);
(* Returns the extreme values required by any possible regression values.
As a side effect, it records the intercept, slope, and R squared of any
required regression values *)
VAR
   X, Y  : Real;           (* the data values for each data pair *)
   myPtr : DataRecHandle;
   I     : Integer;
   ColId : Integer;
   NANResult : cnSymKind;  (* Not A Number (NAN)                 *)

   N       : Integer;      (* number of values in the data set   *)

   SumX, SumY, SumXY, SumXSqr, SumYSqr : Real;

Begin
   ResetData;
   RgrsnMin := +BigNum;
   RgrsnMax := -BigNum;

   (* Go through each linked list in turn *)
   For I := 1 to BGData.Repnum do begin
      (* Do it only if regression is turned on for this data set *)
      If (RgrsBoolean[I]) then Begin

         (* Init the variables *)
         InitRgrsn(N, SumX, SumY, SumXY, SumXSqr, SumYSqr);

         ColId := I+1;
         myPtr := GetDataPtr(I);

         (* Sum the values for all the records in the linked list *)
         While (myPtr <> Nil) Do Begin
            N := N + 1;
            X := myPtr^^.XVal;
            GetValReal(myPtr^^.XIndex, ColId, NANResult, Y);

            (* Sum all the regression stats *)
            AddRgrsnStats(X, Y, SumX, SumY, SumXY, SumXSqr, SumYSqr);

            (* Get the next ptr in the list *)
            myPtr := GetDataPtr(I);
         end;

         With RgrsArray[I] do Begin
            (* Calc and store the regression stats into RgrsArray[I] *)
            CalcRgrsnStats(I, N, SumX, SumY, SumXY, SumXSqr, SumYSqr);

            (* See what data min and max are required for the regression *)
            Y        := Intrcpt + RSlope*XAxis.Min;
            BGMin(RgrsnMin, Y);
            BGMax(RgrsnMax, Y);

            Y        := Intrcpt + RSlope*XAxis.Max;
            BGMin(RgrsnMin, Y);
            BGMax(RgrsnMax, Y);
         end; (* With *)
      end; (* If *)
   end; (* For *)
end; (* Subr *)


(*$S     *)
Procedure CkYAxisRange(*aRg: range*);
(* CkYAxisRange checks and possibly resets the Min and Max Y data values
used to determine the Y axis range *)

VAR
   NewYMin,
   NewYMax,               (* the min and max in the table currently         *)
   RgrsnMin,
   RgrsnMax: Real;        (* min and max required by any regression lines   *)

Begin
   If ((GType=LineGraph) OR (GType=Scatter) OR (GType=NumbAreaGraph)) Then Begin
      (* Get the extreme data values and the extreme regression values *)
      CkYNumbRange (aRg, newYMin,  newYMax);
      CkYRgrsnRange(aRg, RgrsnMin, RgrsnMax);

      (* Use the more extreme of the data value or the regression value *)
      BGMin(newYMin, RgrsnMin);
      BGMax(newYMax, RgrsnMax);
   end

   Else if (GType = StackBar) Then Begin
      CkYStackRange(aRg, newYMin, NewYMax);
   end

   Else Begin
      CkYTextRange(aRg, newYMin, newYMax);
   end;

   If (newYMin = +BigNum) Then NewYMin := 0;
   If (newYMax = -BigNum) Then NewYMax := NewYMin + 1;

   (* Recalc the Y axis range if either the min or the max has changed *)
   With BGData Do Begin
      If ((NewYMin <> YMinData) OR (NewYMax <> YMaxData)) Then Begin
         YMinData := NewYMin;
         YMaxData := NewYMax;
         ReCalcYAxis;
      End; (* If *)
   End; (* With *)
end;


(*$S     *)
Procedure CkAxes(*aRg: Range*);
(* CkAxes checks that the axes are properly adjusted according to the
min and max data values and any mins and maxes that the user may have set *)
Begin
   (* If there's a numerical X axis and the change includes the X column
   then you have to adjust the X axis range *)
   If ((GType = LineGraph) OR (GType = Scatter) OR (GType = NumbAreaGraph)) Then Begin
      CkXAxisRange;
   End;

   (* Check the Y axis range for all graph types except pie. CkYAxisRange filters out
   ranges that don't affect the Y axis *)
   If (GType <> Pie) Then CkYAxisRange(aRg);
End;


(*$S BGAxis*)
Function BytesToReal(pByteData: ptrdata; Len : Integer;
                     VAR error:boolean): Real;
{Returns the value of the bytestring at pByteData converted to a real value
 Len = Length of the byte data on input. Recalced below.
 Error return is from the x80 conversion routine, or if there are extra chars after a separator }

var
   myStr          : stringtype;
   myNumber       : real;
   myDecimal      : Decimal;
   next,
   InsertPos,
   PtPos,                        (* Index of first dec point on the right *)
   CharDist       : Integer;     (* Distance from tsep to dec point       *)

begin
   error := False;

   (* convert the bytes into a string *)
   SfromB(myStr, pByteData, Len);

   (* Find the first decimal point from the right side *)
   PtPos := Len + 1;
   For Next := 1 to Len do Begin
      If (myStr[Next] = DataFormat.DecPt) Then  PtPos := Next;
   end;

   (* Strip off all the thousand separators *)
   InsertPos := 1;
   For Next  := 1 to Len do Begin
      If (myStr[Next] = DataFormat.tSep) Then Begin
         (* Each thousand separator should be 4 char positions from the decimal point *)
         CharDist := PtPos - Next;
         Error := Error OR ((CharDist Mod 4) <> 0) OR (CharDist < 0);
      end
      Else Begin
         (* Move the character left if it's not a thousand separator *)
         mystr[InsertPos] := mystr[Next];

         (* Change the local decimal pt to the period character.
            Must not do this before in case '.' is the local thousand separator *)
         If (mystr[InsertPos] = DataFormat.DecPt) Then mystr[InsertPos] := '.';
         InsertPos := InsertPos + 1;
      end;
   end;
   myStr[0] := Chr(InsertPos - 1);  (* reset the length *)

   (*Convert the string to a real *)
   (* Convert and place the result into FP0 *)
   If (Not Error) Then Begin
      ClearXcps;
      next := 1;
      Str2Dec(myStr, next, myDecimal, error);
      Dec2S(myDecimal, myNumber);
      error := TestXcp(INVALID) or (next <= length(myStr))
   end;

   (* Return 0 on error, else return the Real value in FP0 *)
   if error then BytestoReal := 0.0
            Else BytestoReal := myNumber;
End; (* BytesToReal *)


(*$S BGAxis*)
procedure doAxisBox;
        {The user has hit DoIt for the Axis dialog box.  Respond to the
        new value by setting the axis info if the numbers are valid.}

     var
        NewMin,             (* new minimum for axis *)
        NewOrg,
        NewMax,
        NewIncr   : real;

        NewMinSet,
        NewOrgSet,
        NewMaxSet,
        NewIncrSet: boolean;  (* each set true when user entered a new foo *)

        error:      boolean;

     begin
(*$IFC DEBUGVERSION *)
        if traceDi then LCtraceMess(97);
(*$ENDC *)
        (* End the dialog box selection. Assumes l.lastpnl = cDialogPnl. These routines are in
           aplc/LCSMgr *)
        endPnlSel;
        nullPnlSel;

        ClrUndo;
        SetUndo(uBGAxis, BGPnl);
        g.LastActPnl := g.ActivePnl;
        g.ActivePnl := BGPnl;


        (* Get the axis minimum. Convert the byte data to a real value.
           (The first parameter is a pointer to the byte data.) *)
        NewMin := BytesToReal(diHfld[1]^^.curValue^, diHfld[1]^^.curlen, error);
        NewMinSet := Not Error;

        (* Get the axis origin *)
        NewOrg := BytesToReal(diHfld[2]^^.curValue^, diHfld[2]^^.curlen, error);
        NewOrgSet := Not Error;

        (* Get the axis max *)
        NewMax := BytesToReal(diHfld[3]^^.curValue^, diHfld[3]^^.curlen, error);
        NewMaxSet := Not Error;

        (* Get the increment from the user entered value. If there's
           no error, set NewIncr to the truncated value entered by the user *)
        NewIncr := BytesToReal(diHfld[4]^^.curValue^, diHfld[4]^^.curlen, error);
        NewIncrSet := Not error;

        (* Call BG1.0/BGYAxCk to check the values and redraw the graph *)
        If (CurDiBox = diYAxis) Then Begin
           BGYAxCK(NewMin, NewOrg, NewMax, NewIncr,
                   NewMinSet, NewOrgSet, NewMaxSet, NewIncrSet);
        end (* If *)
        else begin
          BGXAxCk(NewMin, NewOrg, NewMax, NewIncr,
                  NewMinSet, NewOrgSet, NewMaxSet, NewIncrSet);
        end;

        RmvDiBox;

     end; (* DoAxisBox *)




(*$S BGAxis*)
procedure endAxisBox;
        {The user has hit GoAway for the Axis dialog box.  Reselect the
        current range, leaving the g.ActivePnl at BGPnl}
     begin
(*$IFC DEBUGVERSION *)
        if traceDi then LCtraceMess(202);
(*$ENDC *)
        rmvDiBox;
        g.ActivePnl := BGPnl;
     end;



(*$S BGAxis*)
procedure BGAxisGrafix;
(* Draw the specialized labels for the BG axis dialog box. *)
CONST
   AxisMsgV = 20;   (* must agree with the values below in PutAxisBox *)
   MsgH     = 22;

VAR
   myItem : Integer;
   myLbl  : Str255;

begin
   SetPnlPort(dialogPnl);
   MoveTo(msgH, AxisMsgV + 2);
   TextFont(SysText);
   myItem := XAxMin + ord(CurDiBox = DiYAxis);
   GetItem(myMenus[MenuBuzz], myItem, @mylbl);
   DrawString(myLbl);
end;


(*$S BGAxis*)
procedure putAxisBox (AxisType: tAxisType);
{Put up a dialog box to query the axes.  AxisType tells whether
 its the Y axis or the X axis}

const
   before = 7;          (* number of places before the decimal point *)
   after  = 0;          (* number of places after the decimal place  *)
   AirSpace    = 7;     (* air space at top of dialog box            *)
   AxisBoxDv   = 110;   (* Height of axis box                        *)
   AxisMsgV    = 20;    (* vertical loc of message                   *)
   AxisLblLeft = 100;
   AxisFldLeft = 240;   (* left of editable field                    *)
   msgH        = 22;

var
   status: integer;
   error:  boolean;
   myPtrData: ptrData;
   myAxis   : AxisCntl;  (* type declared in apbg/BG2              *)
   myAxMin  : Integer;   (* index into the menubuzz menu items  *)


   Procedure PutAxisHelp( myPtr: PtrData; VAR CurLen: Integer );
   { stuffs the word 'Automatic' from the menu file into the data array pted at by myPtr }
   VAR
      myLbl    :  Str255;
      mylblPtr : ItemPtr;
   Begin
      mylblPtr := @myLbl;
      GetItem(myMenus[menuBuzz], AxStandard, mylblPtr);
      CurLen := 255;

      { Convert the string to bytes and set CurLen to the proper length }
      StoB(myLbl, myPtr, CurLen);
   End; { PutAxisHelp }


   Procedure PutLblHelp(VAR myLbl: lblFld; myMenuItem: Integer; myLblNum: Integer);
   { Inits and displays the uneditable labels }
   Begin
      (* Set up and draw the label *)
      with mylbl do begin
         lbl       := lMenu;
         lMenuNum  := MenuBuzz;
         lMenuItem := myMenuItem;
         SetRect(lblBox, AxisLblLeft, (myLblNum-1)*AxisMsgV+AirSpace,
                         AxisFldLeft,    myLblNum *AxisMsgV+AirSpace);
         lblH := AxisLblLeft;
         lblV := myLblNum*AxisMsgV - 5 + AirSpace;
         assocFldH := diHfld[myLblNum];
         assocFSH := diHfs[myLblNum];
         end;
      putDiLbl(@myLbl);
   end;

   Procedure PutFldHelp(myFldNum: Integer; fUserSet: Boolean; UserVal: Real; VAR Status: Integer);
   { Inits and displays the user editable fields }
   Begin
      With diHfld[myFldNum]^^ do begin

         (* Use the user set value if he set it or else use the default *)
         If fUserSet then RealToBytes(UserVal, curvalue^, maxlen, before, after, curlen, error)
                     else PutAxisHelp(curvalue^, curlen);

         SetRect(coords, AxisFldLeft, (myFldNum-1)*AxisMsgV + AirSpace,
                         ButLeftEdge,   myFldNum  *AxisMsgV + AirSpace);
      end;

      InitFstate(diHfld[myFldNum], diHfs[myFldNum]);
      putDiFld  (diHfld[myFldNum], diHfs[myFldNum], status);
   end;



begin
(*$IFC DEBUGVERSION *)
   if traceDi then LCtraceMess(208);
(*$ENDC *)
   if tblEditPnl(g.ActivePnl) then Begin
      (* End the Tbl Editor selection and the current range in Lisacalc panel *)
      Status := ForceEnter(status);
      GetCR(G.curRange);   (* Tell fexec about it also *)
      ChgStatPnl(False);   (* redraw the status panels *)
   end;

   BGExit;    (* in apbg/Ttl. Ends any BG selection *)

   (* Add a dialog box with both a doit button and a goaway button *)
   addDiBox(AxisBoxDv, @doAxisBox, @endAxisBox, false, false);

   (* Set up and draw the axis labels *)
   PutLblHelp(lblA, AxMin , 1);
   PutLblHelp(lblB, AxOrig, 2);
   PutLblHelp(lblC, AxMax , 3);
   PutLblHelp(lblD, AxIncrement, 4);

   (* Set up and draw the fifth message label. *)
   with lblE do begin
      lbl       := lMenu;
      lMenuNum  := MenuBuzz;
      lMenuItem := AxMessage;
      SetRect(lblBox, 0, 4*AxisMsgV+AirSpace, ButLeftEdge, 5*AxisMsgV+AirSpace);
      lblH := MsgH;
      lblV := 5*AxisMsgV - 5 + AirSpace;
      assocFldH := Nil;
      assocFSH := Nil;
      end;
   putDiLbl(@lblE);

   (************************************************************)
   (* init the editable fields (the labels aren't editable) *)

   (* Make myAxis hold the X or Y axis information *)
   If ( AxisType = YAxisType) Then Begin
      myAxis   := YAxis;
      curDiBox := diYAxis;
   end (* If *)
   Else Begin
      myAxis   := XAxis;
      curDiBox := diXAxis;
   end;

   (* Set up and draw the editable fields for the axis minimum, origin, max, and increment *)
   PutFldHelp(1, MyAxis.MinSet,    myAxis.Min,        Status);
   PutFldHelp(2, MyAxis.OrgSet,    myAxis.Org,        Status);
   PutFldHelp(3, MyAxis.MaxSet,    myAxis.Max,        Status);
   PutFldHelp(4, MyAxis.AxIncrSet, myAxis.UserAxIncr, Status);

   {$IFC fDebug }
   (* check the status *)
   if (status <> 0) then
      writeln('PutAxisBox: status = ', status, ' after putDiFld');
   {$ENDC }

   (* Draw the label that says Y-axis or X-Axis *)
   PutGraphics(@BGAxisGrafix);

   pnlSelAll(dialogPnl, g.curTimeout);
   g.ActivePnl := dialogPnl;
end;


(*$S BGAxis*)
Procedure BGYAxMenu;
(* Call the dialog box to get the information about the axes *)

Begin
   putAxisBox( YAxisType );
End; (* BGYAxMenu *)


(*$S BGAxis*)
Procedure BGXAxMenu;
(* Call the dialog box to get the information about the axes *)

Begin
   putAxisBox( XAxisType );
End; (* BGXAxMenu *)


Procedure SetType(*X: Graphtypes*);
(* Sets the type of the graph as a whole *)
Begin
   OldGType := GType;
   GType:=X;
   ClrUndo;                    (* in aplc/AppDiBox  *)
   SetUndo(uGType, BGPnl);     (* in aplc/FeGlobals *)
End;


Procedure SetPgSize(*XPageSize, YPageSize: Real*);
(* Sets the X and Y page size of the whole graph      *)
Begin
   With Papersize Do Begin
      XMin := 0.0;
      XMax := XPageSize;
      YMin := 0.0;
      YMax := YPageSize;
   End; (* With *)
End; (*  SetPgSize *)


Procedure SetBGGrid(* XGrid, YGrid: Boolean *);
(* SetBGGrid sets the grid booleans for the X Grid and the Y Grid *)
Begin
   oldGrid    := XAxis.Grid;
   ClrUndo;
   SetUndo(uGrid, BGPnl);

   XAxis.Grid := XGrid;
   YAxis.Grid := YGrid;
End;


Procedure SetBGLegends(* XLegendFlag: Boolean *);
(* Set the legends flag saying whether legends should appear *)
Begin
   oldLegends := Legends.LegendFlag;
   ClrUndo;
   SetUndo(uLegends, BGPnl);

   Legends.LegendFlag := XLegendFlag;
End;


Procedure SetProportion(* newGraphProportion: TGraphProportion *);
Begin
   oldGraphProportion := GraphProportion;
   ClrUndo;
   SetUndo(uGraphProportion, BGPnl);

   GraphProportion := NewGraphProportion;
end;


Procedure SetPreview(*newBGPreview: Boolean*);
Begin
   oldBGPreview := BGPreview;
   ClrUndo;
   SetUndo(uBGPreview, BGPnl);

   BGPreview := NewBGPreview;
end;


Procedure SetBGMark(*newBGMark: Boolean*);
Begin
   oldBGMark := BGMarkFlag;
   ClrUndo;
   SetUndo(uBGMark, BGPnl);

   BGMarkFlag := NewBGMark;
end;

(*$S BGInit*)
End.


ÿ