{L:DmDoc 15-Feb-84} { Copyright 1983, 1984, Apple Computer Inc. }

UNIT DmDoc;

{ This UNIT contains the procedures that bring documents to the desktop and puts
  them back, locates, starts, and stops tools, and the dummy which manages all
  windows for which the tool code is not on-line. }

{ The system error numbers in this module range from 800-899.
  The highest number in use is 898.  }


INTERFACE

USES {$U HwInt    } HwInt,
     {$U LibOS/SysCall  } SysCall,
     {$U LibOS/PSysCall } PSysCall,
     {$U UnitStd  } UnitStd,
     {$U UnitHz   } UnitHz,
     {$U Storage  } Storage,
     {$U QuickDraw} QuickDraw,
     {$U FontMgr  } FontMgr,
     {$U WM.Events} Events,
     {$U WM.Windows}Windows,
     {$U WM.Folders}Folders,
     {$U WM.Menus } Menus,
     {$U AlertMgr } AlertMgr,
     {$U FilerComm} FilerComm,
     {$U dbenv    } dbenv,
     {$U dbdecl1  } dbdecl1,
     {$U PMDecl   } PMDecl,
     {$U Scrap    } Scrap,

     {$U ApDm/Globals } DmGlobals,
     {$IFC flrDebug}
     {$U apdm/tracecalls.obj}   tracecalls,
     {$ENDC}
     {$U ApDm/Entry   } DmEntry,
     {$U ApDm/Cat     } DmCat;

CONST
       fNoErr      = 0;
       aborted     = 13;        { User clicked Cancel/op aborted   }
       fBadData    = 9;         { The doc's data is corrupted      }
       fBadPassword= 17;        { Password could not access all diskfiles }
       fCantAlter  = 16;        { The doc is so old the tool cant convert it }
       fCantRead   = 3;         { Unable to read the source diskfile }
       fCantWrite  = 4;         { Unable to write to dest diskfile }
       fCatalogErr = 5;         { Err accessing filer catalog      }
       fDirtyDoc   = 2;         { An edited doc can refuse to put back, etc. }
       fMustAlter  = 15;        { User wouldn't let tool convert old doc to new format }
       fNewerDoc   = 14;        { Doc is newer than tool           }
       fNoMemory   = 7;         { Insufficient memory space        }
       fNoSpace    = 6;         { Not enough room on disk for doc  }
       fNotClosed  = 11;        { Doc was not closed               }
       fNotXfer    = 1;         { The document was not copied      }
       fOneTool    = 10;        { Cant dup tool on same disk       }
       fUserAbort  = 12;        { User typed 'apple .'             }
       fToolErr    = 8;         { Tool could respond normally      }
       fTooOld     =-1;         { Obj not xfer'd, older than cutoff date }

       copyDsSize  = 10000;     { Size of file copy buffer         }

TYPE   PtrFs_Info  = ^Q_Info;
       Tswitch     = (turnOff, turnOn);
       TuserOp     = (opMove, opCopy, opStartup, opRefile, opBackup, opRebuild,
                      opClose);

VAR    copyDsAddr:      LONGINT;
       copyDsBound:     INTEGER;
       copyDsMemSize:   LONGINT;
       copyDsRefnum:    INTEGER;
       folderPort:      GrafPort;
       scrapTool:       TtoolID;     { Type of tool that can display it, 0 if not ours }
       toolSet:         KindSet;

       copyThread:      LONGINT;     { backup volume fs info }
       dtvb:            LONGINT;
       volBackedup:     UID;
       fullBackup:      BOOLEAN;
       volID:           UID;
       VolIsGone:       BOOLEAN;       {*** SALLY RHODES ***}

PROCEDURE BuildDocName (docID: IdType; toolID: TtoolID; VAR docName: E_Name);

{ This procedure builds a document diskfile name prefix. }

PROCEDURE BindCopyDataSeg;

{ This procedure binds a previously created data seg to the copyDsLdsn.  It should
  be called before and type of diskfile transfer.  It is self protecting in that
  it will not try to bind the ds if it is already bound.  }

PROCEDURE CloseDoc (VAR err: INTEGER; hVol: TentryHdl; catRID: TcatRID;
                    normal, forSure: BOOLEAN);

{ This procedure closes a document. If normal is TRUE, all edits are
  integrated into the doc, it is closed, and removed from the desktop.
  If FALSE, the doc's diskfiles are closed as is, and it is left on the
  desktop.  If forSure is true, the application is told to close the
  document's diskfiles at any cost if they cannot first be closed in the
  standard manner.

  Errors:  fNoErr, fNotXfer  }

PROCEDURE CloseTool (volHdl: TentryHdl; catRID: TcatRID);

{ This proc shuts down a tool, suspending any docs that it has open, and
  destroys its tool entry, if any.  }

FUNCTION DeflowerMasterTool (toolID: INTEGER; devHdl: TentryHdl) : BOOLEAN;

{ This proc is called when copying the master copy of a tool for the first
  time.  This can be recognized by looking at Fs_Info.machine_ID of any of
  a tool's diskfiles - it will be 0.  This proc informs that user that this
  is the first copy and asks if the tool should be deflowered; if ok and the
  deflowering is successful, the function returns true, otherwise false.  }

PROCEDURE DummyDisplay (wPtr: WindowPtr);

PROCEDURE FCopyDiskfile (VAR err: INTEGER; source, destination: Pathname;
                        VAR svol, dvol: TentryHdl; sCatRID, dCatRID: TcatRID;
                        bufrAdrs, bufrSize: LONGINT; theOp: FCopyOp;
                        xferOp: TuserOp;
                        VAR osErr: INTEGER;
                        VAR diskCt: INTEGER;
                        catalog: BOOLEAN;
                        split: BOOLEAN);

PROCEDURE FinishTerminating;

{ This proc handles a tool's reply to a docTerminate event. It currently
  does nothing. }

FUNCTION  FitOnDisk(size: LONGINT; devHdl: TentryHdl): BOOLEAN;

{ This proc checks the given size (in blocks) against the maximum free space
  available on a newly initialized disk.  }

PROCEDURE InitDocCtrl;

{ This proc readies this unit for use. }

PROCEDURE KillDoc (VAR err: INTEGER; docHdl: TentryHdl; normal: BOOLEAN;
                   windowGone, forSure: BOOLEAN);

{ This proc tells the tool to close/suspend the open document indicated by
  docHdl.  If 'normal' is true, the doc will be closed else it will be suspended.
  'WindowGone' should be true if window is to be disposed of.  'ForSure' should
  be true if the document is being placed in the wastebasket, i.e. it is to be shredded.  }

FUNCTION KillExtraProcs (volHdl: TentryHdl) : BOOLEAN;

{ This proc should be called when the OS reports that it is out of system
  memory (sysGlobals) or disk.  This proc terminates all processes on the
  volume, volHdl, (NIL may be passed to kill all extra procs) that are
  currently unused, i.e. they have no docs open.  If this procedure succeeds
  in terminating at least one process, TRUE is returned and the operation
  that reported the out of space condition should be retried.  }


PROCEDURE MakeFolder (VAR err: INTEGER; fVol: TentryHdl; fCatRID: TcatRID;
                     sVol: TentryHdl; sCatRID: TcatRID);

{ This proc is used to make a folder diskfile and its label.  If sVol and sCatRID are not
  NIL then the password of that folder, if any, is put onto the new folder.  }

FUNCTION ObjInTrash (volHdl: TentryHdl; catRID: TcatRID) : BOOLEAN;

{ This proc returns TRUE if the catRID object or one of its parents is in the wastebasket.  }


FUNCTION ObjectSize (hVol: TentryHdl; objCatRID: TcatRID;
                  devInfoPtr: TFsInfoPtr; excludeUnfiled: BOOLEAN;
                  VAR dtm, dtc: LONGINT) : LONGINT;

{ This proc gets the total size of all objects within it unless excludeUnfiled
  is TRUE in which case those objects on the desktop will be ignored.  If the
  object is a container the proc will recurse as necessary.  See DocSize for a
  description of the other parameters.  }

PROCEDURE OpenDoc (hVol: TentryHdl; catRID: TcatRID; window: WindowPtr;
                   VAR docHdl: TentryHdl; password: E_Name; startTool: BOOLEAN);

{ This proc opens the document on the desktop behind the window indicated by
  'behind'.  If it is to be the top document, behind = dialogFolder.  If startTool
  is TRUE we will attempt to locate and start the tool otherwise we will keep
  the document as an orphan and display a 'to view, activate' message.  }

PROCEDURE PutDocIn (VAR err: INTEGER; sVol: TentryHdl; sCatRID: TcatRID;
                    dVol: TentryHdl; dParent: IDType; VAR newCatRID: TcatRID);

{  This proc closes an open document, asking the tool to move the doc to another
   disk in the process.  Parent is the destination container on the new disk.
   If the doc is closed, fNoErr is returned otherwise the user is informed and
   aborted is returned.

   Errors:  fNoErr, aborted }

FUNCTION ReclaimDiskSpace (volHdl: TentryHdl; blocksNeeded: INTEGER) : INTEGER;

{ This procedure destroys idle processes and objects in the wastebasket on the
  indicated volume.  blocksNeeded is a hint about how much space is required;
  use 0 if requirements are uncertain.  The space freed, in blocks, is returned. }

FUNCTION RecompFolderSize (hVol: TentryHdl; objCatRID: TcatRID) : LONGINT;

{ This proc recomputes, updates ( in the catalog), and returns the size of the
  given container.  If the object is not a container, e.g. a document, the document's
  size as stored in the catalog is returned.  }

PROCEDURE ResumeDocs (wPtr: WindowPtr);

{ This proc tries to find tools for docs on the desktop that need tools.
  It is called whenever a disk is removed (tools removed but docs may remain)
  or inserted (a source of new tools).  If wPtr is NIL then we attepmt to
  resume all docs otherwise only the doc indicated by wPtr.  }

PROCEDURE RetToolPathname (VAR error: INTEGER; toolID: TtoolID;
                    devHdl: TentryHdl; VAR toolPathName: Pathname);

{ This proc builds a tool diskfile pathname, less extension e.g. 'obj', given
  the tools id and the device it is on.  }

PROCEDURE SendFilerEvent (VAR err: INTEGER; proc: processID; folder: WindowPtr;
                          what: FilerOp; docName: Pathname; dfRefnum: INTEGER;
                          sourceName: Pathname; password: E_Name; VAR reply: FReason);

{ This proc creates an event record and sends it via SendEvent to the proc and
  folder indicated.  ThePrefix is ignored for some FilerOps.  The dfRefnum is
  used only with the fcDfClose op.  the sourceName is used (optionally) with fcCopy.
  The proc's reply is returned via 'reply'.  }

FUNCTION ShredContents(volHdl: TentryHdl; objCatRID: TcatRID;
                       dontResize: BOOLEAN; cantAbort: BOOLEAN) : BOOLEAN;

FUNCTION ShredObject (volHdl: TentryHdl; objCatRID: TcatRID;
                      dontResize: BOOLEAN; cantAbort: BOOLEAN) : BOOLEAN;

PROCEDURE SonTerminated;

{ This proc is called by the OS when an application terminates.  It cleans up
  the tool entry, suspends any docs open by the tool, attempts crash recovery
  if appropriate, and dismounts the tool's volume if the volume is marked for
  dismount and this is the last tool on it. }

PROCEDURE StartDoc (docHdl: TentryHdl; resume: BOOLEAN);

{ This proc is used to start the tool behind the doc. It can be used both for
  newly opend docs and those previously opened but whose tool could not be
  run for whatever reason. If resume is true, messages to the user are suppressed.
  The password, if any, must already be stored in docHdl^^.docPassword.
  Success of this operation is indicated, on return, in docHdl^^.state.  }


PROCEDURE TellUserWhy (sVolHdl,dVolHdl: TentryHdl; sCatRID,deCatRID: TcatRID;
                       theReason: INTEGER; theOp: TuserOp);

{ This proc tells the user, via a stop alert, why the operation he requested
  was not performed.  TheReason and theOp tell what the user was doing and why
  the operation failed. }

PROCEDURE TermTools (volHdl: TentryHdl; VAR activeTools: BOOLEAN);

{ This proc terminates all running tools on the volume. Called when a volume
  is being dismounted. IF volHdl is NIL then all tool processes are shutdown.
  ActiveTools is TRUE if any running process were found on the volume. }

FUNCTION ToolCheck (hVol: TentryHdl; catRID: TcatRID;
                    FUNCTION FoundOne (pToolRec: PtrCatRec; pFsInfo: PtrFs_Info) : BOOLEAN
                   ) : BOOLEAN;

{ This procedure checks for tools.  If the catRID is that of a container, each
  object in the catainer is checked recursively looking for tools.  This procedure
  returns FALSE if no tools are found.  If a tool is found, the function
  FoundOne is called.  IF FoundOne returns TRUE, ToolCheck quits checking for tools
  and returns TRUE.  IF FoundOne returns FALSE, ToolCheck continues checking for
  more tools.  If no more are found, ToolCheck returns FALSE. }

PROCEDURE UnbindCopyDataSeg;

{ This proc unbinds the copy buffer after the data transfer has been completed. }

PROCEDURE UnsolicitedFilerEvent (VAR destroyWindow: BOOLEAN);

{ This proc is called when an unsolicited message is received by the Filer from
  an application.  It assumes that curEvent contains the event just received.
  The acceptable messages are defined in FilerComm.  }

PROCEDURE WriteVerify (devHdl: TentryHdl; onOff: Tswitch);

{ This proc turns disk write verification on and off for the specified device.
  As a side effect, sparing of bad blocks and rewrite on soft read errors are
  also enabled.  No errors are returned. }

PROCEDURE XferObj (VAR err: INTEGER; sCatRID: TcatRID; VAR intoCatRID: TcatRID;
                   VAR sVolHdl: TentryHdl; VAR dVolHdl: TentryHdl; excludeUnfiled: BOOLEAN;
                   xferOp: TuserOp; split: BOOLEAN; VAR diskCt: INTEGER; sinceDate: LONGINT);

{ This is an internal proc for use by FVolCtrl. See XferObject, below, for a
  description of its operation.  }

PROCEDURE XferObject (VAR err: INTEGER; sCatRID: TcatRID; dParent: IdType;
                   sVolHdl, dVolHdl: TentryHdl; excludeUnfiled: BOOLEAN;
                   move: BOOLEAN; splitflag,joinflag: BOOLEAN; diskCt: INTEGER;
                   VAR newCatRID: TcatRID; VAR diskgone: BOOLEAN);

{ This proc moves everything in sCatRID on sVolHdl into dParent on dVolHdl.
  (If an object is open, the application is told to duplicate it.)  It is assumed
  that there is sufficient disk space; if not, any diskfiles transferred to the
  destination during this call are deleted, i.e. everything moves or nothing moves.

  dParent is the object into which the sCatRID object is to be copied.  If the
  operation is sucessful, the newly created catRID of the xfered object is returned
  in newCatRID.

  diskCt should normally be '0' except when the object being xfered is the whole
  disk, in which case diskCt should be 1 (it is incremented to reflect the number
  of destination diskettes used and so is not a boolean).

  It is a cover proc for XferObj above. }

PROCEDURE XferSysFiles (VAR err: INTEGER; sVolHdl: TentryHdl;
                        VAR dVolHdl: TentryHdl; xferOp: TuserOp;
                        bootOnly: BOOLEAN; VAR diskCt: INTEGER;
                        split: BOOLEAN);

{ This proc copies all system diskfiles from sVol to dVol.  First those diskfiles
  with the sys name prefix are copied (those required to boot a disk), then, if
  bootOnly is TRUE, any other non-filer managed disk files are copied, e.g.
  non-required intrinsics (any diskfile whose name does not begin with '{').
  For first release, any diskfiles that already exist on the destination disk are
  not copied.

  errors: fNoError, fNotXfered  }

PROCEDURE ZapPassword (VAR fileName: Pathname);


IMPLEMENTATION

{$IFC FlrSymbols }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

{$IFC FlrDebug }
{$R+ }
{$ELSEC }
{$R- }
{$ENDC }

CONST copyDsDfName  = '{!CopyBufr}';
      intLibName    = 'Intrinsic.lib';
      minDsSize     =  512;


        { tool startup errors - ordered in report order }
      noCode        = 1;        { No code file found             }
      toolProtected = 2;        { Not executable on this machine }
      toolInvalid   = 3;        { Code file is bad/incomplete    }
      toolTooBusy   = 4;        { Not enough memory              }
      toolNeedsDisk = 5;        { Not enough disk space          }

        { OS file system overhead }
      entriesPerMapBlk = 119;   { OS keeps list of data blk ptrs ext to data blks }
      fixedOverhead    = 2;     { 1 hints and label, 1 map block                  }

TYPE  DocStates =       SET OF TdocState;

VAR   blankStr:         NameString;
      containerSet:     KindSet;
      resumable:        DocStates;   { Doc states that can be resumed   }
      shellDfName :     E_Name;
      systemIntrinsics: Lf_List;     { The intrinsics used by the Filer }

      waitList:         T_WaitList;  {*** O/S bug workaround ***}
      eventBlk:         r_eventBlk;  {*** ditto ***}




   { references into FVolCtrl }

PROCEDURE AnotherDiskette (VAR err: INTEGER; devHdl: TentryHdl; theOp: TuserOp; diskct: INTEGER;
                           seqNum: INTEGER; eraseDisk: BOOLEAN);              EXTERNAL;

PROCEDURE DismountVol (device: Tdevice; eject: BOOLEAN; resume: BOOLEAN);     EXTERNAL;

FUNCTION  GetNextDiskette (VAR err: INTEGER; devHdl, sVolHdl: TentryHdl;
                           VAR diskCt: INTEGER; xferOp: TuserOp) : BOOLEAN;   EXTERNAL;

FUNCTION SaveSomeSpace (devHdl: TentryHdl) : {err} INTEGER;       EXTERNAL;



   { references into Filer }

PROCEDURE AdjustDesktopMenu;                                        EXTERNAL;
PROCEDURE DeleteObject (volHdl: TentryHdl; catRID: TcatRID);        EXTERNAL;
PROCEDURE DestroyObject(volHdl: TentryHdl; uniqueID: IdType);       EXTERNAL;
PROCEDURE DoActivateEvent;                                          EXTERNAL;
PROCEDURE DeactObject(newProc, newWind: BOOLEAN);                   EXTERNAL;
FUNCTION  EmptyTrashCan (volHdl: TentryHdl; diskAlso, showAlert: BOOLEAN) : BOOLEAN;
                                                                    EXTERNAL;
FUNCTION  GetPassword (volHdl: TentryHdl; catRID: TCatRID; VAR passwd: E_Name) : BOOLEAN;
                                                                    EXTERNAL;
FUNCTION  OnDesktop (volHdl: TentryHdl; uniqueID: IDType) : BOOLEAN;EXTERNAL;
PROCEDURE UpdateAll;                                                EXTERNAL;

{**************************************************************************}
{                         Internal Procedures                              }
{**************************************************************************}

FUNCTION  ItWillFit (objSize: LONGINT; volHdl: TentryHdl) :BOOLEAN; FORWARD;
PROCEDURE KillTool (toolHdl: TentryHdl);                            FORWARD;
PROCEDURE ReconstructParentage (sVolHdl, dVolHdl: TentryHdl; catRID: TcatRID);
                                                                    FORWARD;
PROCEDURE RetDocName (docHdl: TentryHdl; VAR docName: E_Name);      FORWARD;
FUNCTION  ShredDoc (hVol: TentryHdl; catRID: TcatRID) : BOOLEAN;    FORWARD;
FUNCTION  ToolOnDisk (volHdl: TentryHdl; toolNum: TtoolID;
                     VAR toolCatRID: TcatRID) : BOOLEAN;            FORWARD;
FUNCTION  ToolSize (hVol: TentryHdl; toolID: TtoolId; devInfoPtr:
                    TFsInfoPtr; VAR dtm, dtc: LONGINT) : LONGINT;   FORWARD;
PROCEDURE WMStatus;                                                 FORWARD;


{**************************************************************************}

{$S flrDm1 }

PROCEDURE AdjustParentObjSize (volHdl: TentryHdl; parentID: IdType; inOut: BOOLEAN);
VAR catRec:       TcatRec;
    catRID:       TcatRID;
    dtc:          LONGINT;
    dtm:          LONGINT;
    err:          INTEGER;
    objName:      FMaxStr;
    objSize:      LONGINT;
    parentCatRID: TcatRID;

  PROCEDURE CheckErr (location: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF ErrorFound (warnError, location, err, volHdl^^.devHdl) THEN;
    IF parentID <> idDisk
    THEN BEGIN
      GetObjName (volHdl, diskCatRID, objName);
      ParamAlert (objName, volHdl^^.devHdl^^.userNmHdl^^, '');
      NoteAlert (flrAlert, 288);
      UpdateAll;
      END;
    EXIT (AdjustParentObjSize);
    END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('AdjustParentObjSize: parentID is ',parentID:1);

err := 0;
parentCatRID.fatherID := idNil;
parentCatRID.uniqueID := parentID;
WHILE (parentCatRID.uniqueID <> idDisk) AND (err <> endOfCat)
DO BEGIN
  GetCatRec (err, volHdl, parentCatRID, catRec);
  IF err <> endOfCat
  THEN BEGIN
    CheckErr (816);
    catRID.uniqueID := catRec.selfID;
    catRID.fatherID := catRec.parentID;
    objSize := ObjectSize (volHdl, catRID, NIL, FALSE, dtm, dtc);
    IF (objSize = catRec.objSize) AND (dtm = catRec.modified) AND NOT inOut
    THEN err := endOfCat     { Nothing to update, force loop termination }
    ELSE BEGIN
      catRec.objSize := objSize;
      IF inOut THEN catRec.modified := TimeStamp;
      IF trcFDocCtrl
      THEN BEGIN
        ExtObjName (catRec, objName);
        WRITELN ('   ',objName,' new size = ',catRec.objSize:1,
                 '. Parent is ',catRec.parentID:1);
        END;
      UpdCatRec (err, volHdl, parentCatRID, catRec);
      CheckErr (824);
      parentCatRID.uniqueID := catRec.parentID;
      END;
    END;
  END;

IF trcFDocCtrl THEN WRITELN ('   exit AdjustParentObjSize');
END;


{**************************************************************************}
{*** This procedure was taken from libfc/fcimpl.text and modified to    ***}
{*** support the splitting and rebuilding of large documents.           ***}
{*** Added arguments svol, sCatRID, and split ( which indicates         ***}
{*** that the file belongs to a partial document or that it may be      ***}
{*** split over multiple diskettes).                                    ***}
{**************************************************************************}

{$S flrSplit}

PROCEDURE FCopyDiskfile {VAR err: INTEGER; source, destination: Pathname;
                        svol, dvol: TentryHdl; sCatRID, dCatRID: TcatRid;
                        bufrAdrs, bufrSize: LONGINT; theOp: FCopyOp;
                        xferOp: TuserOp;
                        VAR osErr: INTEGER; VAR diskCt: INTEGER;
                        catalog: BOOLEAN; split: BOOLEAN};

{ This proc copies a single diskfile from source to destination. It uses
  a memory-resident data seg as a buffer. Normally the buffer is unbound
  and sized to zero for performance reasons. This proc checks its size and,
  if = 0, sizes and binds it. The caller should unbind it and resize it after
  it returns from the last call. The memory size delta should be -useDsAdrs,
  its disk size delta should be zero. Its refnum is copyDsRefnum. }

LABEL 33;

CONST  retries =  3;

TYPE  copytype = (normal,splitok,rebuild);

VAR atEnd:          BOOLEAN;
    blocksAllocated:LONGINT;
    blocksNeeded:   LONGINT;
    bytesPerIO:     INTEGER;
    bytesRead:      LONGINT;
    bytesWritten:   LONGINT;
    copyaction:     copytype;                {*** Added for large doc backup ***}
    copycomplete:   BOOLEAN;                 {*** Added for large doc backup ***}
    createfile:     BOOLEAN;                 {*** Added for large doc backup ***}
    dcatRec:        TcatRec;                 {*** Added for large doc backup ***}
    dDevHdl:        TentryHdl;               {*** Added for large doc backup ***}
    dDevPathname:   Pathname;                {*** Added for large doc backup ***}
    dDfName:        E_Name;
    dDfPathname:    Pathname;
    dDfRefInfo:     fs_Info;
    dDfRefNum:      INTEGER;
    devName:        E_name;                  {*** Added for large doc backup ***}
    devPathname:    Pathname;
    devInfo:        fs_Info;
    dfInfo:         fs_Info;                 {*** Added for large doc backup ***}
    docName:        FMaxStr;
    docpiece:       INTEGER;                 {*** Added for large doc backup ***}
    docnum:         IDtype;                  {*** Added for large doc backup ***}
    doread:         BOOLEAN;                 {*** Added for large doc backup ***}
    dtc:            LONGINT;                 {*** Added for large doc backup ***}
    dtm:            LONGINT;                 {*** Added for large doc backup ***}
    filepiece:      INTEGER;                 {*** Added for large doc backup ***}
    fsParms:        Ut_Parmt;
    dontCare:       BOOLEAN;
    gcdBytesPerBlk: INTEGER;
    i:              INTEGER;
    labeled:        BOOLEAN;                 {*** Added for large doc backup ***}
    labelRec:       LabelFmt;                {*** Added for large doc backup ***}
    lastpiece:      BOOLEAN;                 {*** Added for large doc backup ***}
    Lbytesread:     LONGINT;                 {*** Added for large doc backup ***}
    Lbyteswritten:  LONGINT;                 {*** Added for large doc backup ***}
    newDiskSize:    LONGINT;
    newfile:        BOOLEAN;                 {*** Added for large doc backup ***}
    otherErr:       INTEGER;
    Prefix:         E_Name;
    prefixEnd:      INTEGER;
    prefixStart:    INTEGER;
    saveDfName:     Pathname;                {*** Added for large doc backup ***}
    scatRec:        TcatRec;                 {*** Added for large doc backup ***}
    sDevHdl:        TentryHdl;               {*** Added for large doc backup ***}
    sDfRefInfo:     fs_Info;
    sDfRefNum:      INTEGER;
    userVolName:    FMaxStr;                 {*** Added for large doc backup ***}
    totsize:        LONGINT;                 {*** Added for large doc backup ***}

  PROCEDURE OSError (at: INTEGER; result: INTEGER);
  VAR tempErr:  INTEGER;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

  IF Abort                      { Check for user abort        }
  THEN BEGIN
    osErr := fceAborted;
    result := fceAborted;
    END;

  IF osErr > 0
  THEN BEGIN
    IF trcFDocCtrl THEN WRITELN ('Error at ',at:1,' in FCopyDiskfile: ',osErr:1,
                             '; copying ',source,' to ',destination);
    err := result;
    Close_Object (tempErr, sDfRefNum);          { Close the source file      }
    Close_Object (tempErr, dDfRefNum);          { Close the destination file }
    IF dDfRefnum <> 0                           { Don't kill if not opened   }
    THEN BEGIN
      ZapPassword (destination);
      Kill_Object (tempErr, destination);    { Only part of it was copied }
      END;
    Sched_Class (tempErr, TRUE);
    EXIT (FCopyDiskfile);
    END;
  END;


  FUNCTION Gcd (m, n: INTEGER) : INTEGER;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF n = 0
  THEN gcd := m
  ELSE gcd := Gcd (n, m MOD n);
  END;


  PROCEDURE ChgDestVol;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('ChgDestVol');

  saveDfName := CONCAT('-',dDevHdl^^.nameHdl^^,'-',saveSpace);
  ZapPassword (saveDfName);
  Kill_Object (osErr,saveDfName);

  {update current disk for split file}

  filepiece := filepiece + 1;
  dDfRefInfo.file_portion := filepiece;

  IF theOp <> fcDocCopy
  THEN BEGIN
    dDfRefInfo.DTM := sDfRefInfo.DTM;
    IF theOp = fcDocBackup
    THEN BEGIN
      sDfRefInfo.DTB := sDfRefInfo.DTM;
      PSet_File_Info (osErr, sDfRefNum, sDfRefInfo);{ Set date/time backudup field }
      OSError(130,fceCantWrite);
      END;
    END;
  PSet_File_Info(osErr, dDfRefNum, dDfRefInfo);     { update os directory }
  OSError(132,fceCantWrite);

  {update current destination disk for docpiece and totsize for split document or tool}

  IF catalog
  THEN BEGIN
    IF docpiece = nullInt2 THEN docpiece := 1;
    dCatRec.split := docpiece;
    dCatRec.objsize := ObjectSize(dvol, dCatRID, NIL, False, dtm, dtc);
    UpdCatRec(osErr, dvol, dcatRID, dCatRec);
    OSError(200,fceCantWrite);

    prefixStart := POS ('{', destination);
    prefixEnd := POS ('}', destination);
    dDevPathname := COPY (destination, 1, prefixStart-2);
    Prefix := COPY (destination, prefixStart, prefixEnd - prefixStart +1);

    osErr := 0;
    Reset_Catalog (osErr, dDevPathname);
    OSError (133,fceCantRead);
    Get_Next_Entry (osErr, Prefix, dDfName);
    IF osErr <> 848 THEN OSError(134,fceCantRead);     { 848 - no diskfiles            }
    WHILE osErr <= 0
    DO BEGIN
      dDfPathName := CONCAT(dDevPathname,'-',dDfName);
      Read_Label (osErr, dDfPathName, ORD(@labelRec), SizeOf(labelRec), LbytesRead);
      IF trcFDocCtrl THEN WRITELN ('Read_Label returned ',osERR,', bytesRead: ',LbytesRead,
                                    ' split = ',labelRec.split,', totalsize = ',labelRec.totalSize);

      IF osErr = 848
      THEN BEGIN                   { GET LABEL OF FIRST FILE IN DOCUMENT }
         IF scatRec.objKind = docKind
         THEN docnum := scatRec.selfid
         ELSE docnum := 0;
         IF NOT LabelIO (FALSE, svol^^.devHdl^^.nameHdl^^, scatRec.toolId, docnum, labelRec)
         THEN BEGIN
            LabelDefault(labelRec);  { create label }
            labeled := TRUE;
            END;
         END;
      labelRec.split := docpiece;
      labelRec.totalSize := totsize;  { store total document size in label }
      Write_Label (osErr, dDfPathName, ORD(@labelRec), LbytesRead, LbytesWritten);
      OSError(95,fceCantWrite);
      Get_Next_Entry (osErr, Prefix, dDfName);
      END;
    END;

  Truncate (osErr, dDfRefNum);
  Close_Object (osErr, dDfRefNum);          { Close the destination file        }
  OSError(100,fceCantWrite);


  IF NOT GetNextDiskette(osErr, dDevHdl, svol, diskCt, xferOp)
  THEN BEGIN                     { User wouldn't/couldn't supply another diskette }
    dvol := dDevHdl^^.volHdl;    { Reset vol handle }
    IF dDevHdl^^.volHdl = NIL
    THEN VolIsGone := TRUE;      {Set global variable to indicate that volume has changed }
    OSError (140, osErr);
    END
  ELSE BEGIN
    dvol := dDevHdl^^.volHdl;    { Reset vol handle }
    VolIsGone := TRUE;           {Set global variable to indicate that volume has changed }
    osErr := SaveSomeSpace(dDevHdl);
    OSError(45,fceCantWrite);
    CASE xferOp OF
      opBackup: BEGIN
                ReconstructParentage (sVol, dVol, sCatRID);
                GetObjName (svol, diskCatRID, userVolName);
                ParamAlert (userVolName,sDevHdl^^.userNmHdl^^,dDevHdl^^.userNmHdl^^);
                WaitAlert (flrAlert, 236);            { 'Backing up...'                }
                END;
      OTHERWISE BEGIN
                GetObjName (svol, sCatRID, docName);
                GetObjName (dvol, diskCatRID, userVolName);
                ParamAlert (docName, userVolName, '');
                IF xferOp = opCopy
                THEN WaitAlert(flrAlert, 101)
                ELSE WaitAlert(flrAlert, 100);
                END;
      END;
    IF catalog
    THEN BEGIN
      docpiece := docpiece + 1;
      dCatRec.split := docpiece;
      dCatRec.objsize := 0;
      dCatRec.closedPt.v := MAXINT;
      dCatRec.closedPt.h := MAXINT;
      AddCatRec(oserr, dvol, dCatRec, FALSE, dCatRID);
      OsError (103,fceCantWrite);
      END;
    END;

  IF trcFDocCtrl THEN WRITELN ('   exit ChgDestVol');
  END;



  PROCEDURE ChgSourceVol;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('ChgSourceVol');

  REPEAT
    devPathname := CONCAT('-',sdevHdl^^.nameHdl^^);
    Lookup(osErr,devPathName,devInfo);
    Truncate (osErr, dDfRefNum);
    Close_Object (osErr, sDfRefNum);          { Close the source file             }
    AnotherDiskette (osErr, sDevHdl, xferOp, diskct, devInfo.volNum, FALSE);
    IF (osErr <= 0) OR (sDevHdl^^.volHdl = NIL)
    THEN VolIsGone := TRUE;      {Set global variable to indicate that volume has changed }
    svol := sDevHdl^^.volHdl;
    OSError(112,osErr);

    IF oserr <= 0
    THEN BEGIN
      Lookup (err, source, sDfRefInfo);
      IF ErrorFound (warnError, 947, err, sDevHdl)
      THEN BEGIN
        err := aborted;
        EXIT (FCopydiskfile);
      END;
    END;

    POpen (osErr, source, sDfRefNum, [dread], dontCare);{ Open a source diskfile }

    CASE osErr OF
      0, -1173, -1174, -1175: ;                   { Ignore these warnings        }
      950, 951: OsError (115,fceInUse);             { Already opened privately     }
      OTHERWISE OsError (120,fceCantRead);
    END;
    IF trcFDocCtrl THEN WRITELN('sDfRefInfo.file_portion = ', sDfRefInfo.file_portion,
                                'lastfilepiece was ', filepiece);

    IF ABS(sDfRefInfo.file_portion) <> (filepiece + 1)
    THEN BEGIN
      IF trcFDocCtrl THEN WRITELN('Wrong file segment: ',sDfRefInfo.file_portion);
      GetObjName (svol, sCatRID, userVolName);
      ParamAlert (userVolName,'','');
      NoteAlert (flrAlert, 271);
      END
    ELSE
      CASE xferOp OF
        opRebuild: BEGIN
                   GetCatRec (oserr, sVol, sCatRID, scatRec);
                   OSError (141,fceCantRead);
                   ParamAlert (dDevHdl^^.userNmHdl^^,sDevHdl^^.userNmHdl^^,'');
                   WaitAlert (flrAlert, 270);       { 'Restoring...' }
                   END;
        OTHERWISE  BEGIN
                   GetObjName (svol, sCatRID, docName);
                   GetObjName (dvol, diskCatRID, userVolName);
                   ParamAlert (docName, userVolName, '');
                   WaitAlert(flrAlert, 312);        { 'Reconstructing...' }
                   END;
        END;
    UNTIL ABS(sDfRefInfo.file_portion) = (filepiece +1);

  IF trcFDocCtrl THEN WRITELN ('   exit ChgSourceVol');
  END;

{**********************************   FCopyDiskFile   *****************************}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl
THEN WRITELN ('FCopyDiskFile: copying from ',source,' to ',destination,' catalog = ',catalog);

copyaction := normal;
copycomplete := FALSE;
err := 0;
dDfRefNum := 0;

Sched_Class (osErr, FALSE);

  { Verify allright to copy }
Lookup (osErr, source, sDfRefInfo);           { Need various information     }
OSError(5,fceCantRead);
osErr := 1;                                   { For the following tests      }
IF NOT (sDfRefInfo.fType IN [userFile, userCat, exec, spool, sysData, swapData,
                             swapCode, bootFile])
THEN BEGIN                                    { Only certain types are copied }
  IF trcFDocCtrl THEN WRITELN ('   not xfering, file type is ',ORD(sDfRefInfo.fType):1);
  OsError (15,fceCantRead);
  END;

POpen (osErr, source, sDfRefNum, [dread], dontCare);{ Open a source diskfile }
CASE osErr OF
  0, -1173, -1174, -1175: ;                   { Ignore these warnings        }
  950, 951: OsError (20,fceInUse);             { Already opened privately     }
  OTHERWISE OsError (25,fceCantRead);
  END;

IF split
THEN BEGIN
  copyaction := splitok;
  sDevHdl := svol^^.devHdl;       { Save device handles }
  dDevHdl := dvol^^.devHdl;
  docpiece := nullInt2;
  filepiece := 0;
  totsize := 0;

  { Check whether splitting or joining a file. }
  IF sDfRefInfo.file_portion <> 0   { split file }
  THEN BEGIN
    copyaction := rebuild;
    filepiece := abs(sDfRefInfo.file_portion);
    END;

  { Check whether splitting or joining a document. }
  IF catalog
  THEN BEGIN
    GetCatRec (oserr, sVol, sCatRID, scatRec);
    OSError (142,fceCantRead);
    GetCatRec (oserr, dVol, dCatRID, dcatRec);
    OSError (143,fceCantRead);

    IF scatRec.split <> nullInt2       { split document }
    THEN BEGIN
      copyaction := rebuild;
      docpiece := ABS(scatRec.split);
      END
    ELSE BEGIN
      IF dcatRec.split <> nullInt2 THEN docpiece := ABS(dcatRec.split);
      totsize := sCatRec.objSize;
      END;
    END;
  END;

createfile := TRUE;
labeled := TRUE;
Read_Label (osErr, source, ORD(@labelRec), SizeOf(labelRec), LbytesRead);
IF osErr > 0
THEN BEGIN
  IF osErr = 848          { 848 = no label }
  THEN CASE copyaction OF
       rebuild:  OSError(30,fceCantRead);  { Must have label to rebuild  }
       OTHERWISE   labeled := FALSE;
       END
  ELSE OSError(40,fceCantRead);
  END;

doread := TRUE;
newfile := TRUE;

blocksNeeded := 0;
blocksAllocated := 0;

WHILE NOT copycomplete DO
  BEGIN
33:
  IF newfile
  THEN BEGIN
    atEND := FALSE;
    newfile := FALSE;
    END;

      { Create the destination diskfile }

  IF createfile
  THEN BEGIN
    createfile := FALSE;
    Make_File (osErr, destination, max_Label_Size);{ Create destination           }
    IF osErr = 890
    THEN BEGIN                                    { See if the file has been damaged}
      Lookup (otherErr, destination, dDfRefInfo);
      IF dDfRefInfo.file_Scavenged
      THEN BEGIN                                  { File scavenged, replace it   }
        ZapPassword (destination);
        Kill_Object (osErr, destination);
        Make_File (osErr, destination, max_Label_Size);
        END;
      END;
    OSError(50,fceOutOfDiskSpace);

    IF sDfRefInfo.protected                       { Set protections if appropriate}
    THEN Protect (osErr, destination, FALSE, sDfRefInfo.machine_ID);
    OSError(55,fceCantWrite);
    POpen (osErr, destination, dDfRefNum, [dwrite, append], dontCare);
    OSError(60,fceCantWrite);

    IF err <= 0 THEN WITH fsParms DO BEGIN        { copy the password, if any }
      gp_parm := 0;
      command := xfer_Passwd;
      path    := source;
      op      := pswRead;
      FS_Utilities (err, fsParms);
      IF err <= 0 THEN
        BEGIN
        path  := destination;
        op    := pswWrite;
        FS_Utilities (err, fsParms);
        END;
      END;

    END;

    { Allocate the disk space }

  Info (osErr, dDfRefNum, dDfRefInfo);       { Need the logical block size  }
  OSError(65,fceCantWrite);
  IF dDfRefInfo.pSize = 0                    { Destination is not a blocked dev}
  THEN OSError(70,fceCantWrite);
  IF blocksNeeded > blocksAllocated
  THEN blocksNeeded := blocksNeeded - blocksAllocated
  ELSE blocksNeeded := (sDfRefInfo.pSize DIV dDfRefinfo.lpSize) - 1; { Size of source in blocks }
  Allocate (osErr, dDfRefNum, FALSE, blocksNeeded, blocksAllocated);
  IF trcFDocCtrl THEN WRITELN ('   blocksneeded ',blocksneeded:1,' blocksallocated:',blocksallocated:1);
  IF blocksAllocated < blocksNeeded
  THEN BEGIN
    CASE copyaction OF
      rebuild,
      normal : BEGIN
               IF osErr < 0 THEN osErr := -osErr; { Change warning to error }
               IF osErr = 0 THEN osErr := 826;    { Allocate doesn't necessarily return an error }
               OSError (75,fceOutOfDiskSpace);
               END;
      END;
    END;

     { Calculate bytes per IO       }

  gcdBytesPerBlk := sDfRefInfo.LpSize *
                    (dDfRefInfo.LpSize DIV
                     Gcd (sDfRefInfo.LpSize, dDfRefInfo.LpSize));
  IF gcdBytesPerBlk > bufrSize
  THEN bytesPerIO := bufrSize              { inefficient but necessary        }
  ELSE bytesPerIO := (bufrSize DIV gcdBytesPerBlk) * gcdBytesPerBlk;
  IF trcFDocCtrl
  THEN IF bytesPerIO <= 0
       THEN WRITELN ('ERROR in FCopyDiskfile: bytesPerIO = ',bytesPerIO:1,
                  ', bufrSize = ',bufrSize:1,
                  ', gcdBytesPerBlk =',gcdBytesPerBlk:1);

     { Copy the diskfile }

  REPEAT
    IF doread
    THEN BEGIN
      Read_Data (osErr, sDfRefNum, bufrAdrs, bytesPerIO, bytesRead,
                 sequential, 0);
      CASE osErr OF
        0, 848, 881, 883, 956: BEGIN    { Various end-of-file conditions   }
          IF osErr <> 0
          THEN BEGIN
            atEnd := TRUE;
            osErr := 0;
            END;
          END;
        OTHERWISE OsError (85,fceCantRead);
        END;
      END;


     IF bytesRead > 0
     THEN BEGIN
        IF doread
        THEN Write_Data (osErr, dDfRefNum, bufrAdrs, bytesRead, bytesWritten, sequential, 0)
        ELSE BEGIN
          doread := TRUE;
          Write_Data (osErr, dDfRefNum, ORD(bufrAdrs) + bytesWritten, bytesRead - bytesWritten,
                      bytesWritten, sequential, 0);
          END;

        CASE osErr OF
          0: ;
          848,
          882: IF copyaction = splitok
               THEN BEGIN
                 IF (bytesread > byteswritten) OR NOT atEND
                 THEN BEGIN
                   ChgDestVol;                 {update current volume and get new volume }
                   createfile := TRUE;
                   IF bytesread > byteswritten
                   THEN BEGIN
                     doread := FALSE;
                     GOTO 33;     {*** FI 322 ***}
                     END;
                   END;
                 END
               ELSE OsError (105,fceOutOfDiskSpace);
         OTHERWISE OsError (110,fceCantWrite);
         END;
      END;

    IF atEND
    THEN BEGIN
      IF copyaction = rebuild
      THEN BEGIN
        IF sDfRefInfo.file_portion <= 0
        THEN copycomplete := TRUE
        ELSE BEGIN
          ChgSourceVol;   { close source volume and mount another}
          filepiece := filepiece + 1;
          newfile := TRUE;
          END;
        END
      ELSE copycomplete := TRUE;
      END;
  UNTIL (atEnd OR createfile);    { end of inner loop }
END;                              { end of outer loop }

IF theOp <> fcDocCopy
THEN BEGIN                                    { Set dtc/dtm/dtb  }
  PSet_File_Info (osErr, dDfRefNum, sDfRefInfo);{ Set date/time, file close flds}
  OSError(125,fceCantWrite);
  IF theOp = fcDocBackup
  THEN BEGIN
    sDfRefInfo.DTB := sDfRefInfo.DTM;
    PSet_File_Info (osErr, sDfRefNum, sDfRefInfo);{ Set date/time backedup field }
    OSError(130,fceCantWrite);
    END;
  END;

CASE copyaction OF
  splitok:
      BEGIN
      IF docpiece > 0
      THEN BEGIN
        IF NOT labeled
        THEN BEGIN
          IF scatRec.objKind = docKind
          THEN docnum := scatRec.selfid
          ELSE docnum := 0;
          IF NOT LabelIO (FALSE, svol^^.devHdl^^.nameHdl^^, scatRec.toolId, docnum, labelRec)
          THEN LabelDefault(labelRec);  { create label }
          labeled := TRUE;
          END;
        labelRec.split := docpiece;
        labelRec.totalSize := totsize;  { store total document size in label }
        END;
      IF filepiece > 0
      THEN dDfRefInfo.file_portion := - (filepiece + 1);
      END;
  rebuild:
      BEGIN
      labelRec.split := nullInt2;
      labelRec.totalsize := 0;
      dDfRefInfo.file_portion := 0;
      END;
  END;

IF labeled
THEN BEGIN
  Write_Label (osErr, destination, ORD(@labelRec), LbytesRead, LbytesWritten);
  OSError(135,fceCantWrite);
  END;

IF copyaction <> normal
THEN BEGIN
  PSet_File_Info(osErr, dDfRefNum, dDfRefInfo);     { update os directory }
  OSError(136,fceCantWrite);
  END;

Truncate (osErr, dDfRefNum);
Close_Object (osErr, dDfRefNum);          { Close the destination file        }
OSError(140,fceCantWrite);
Close_Object (osErr, sDfRefNum);          { Close the source file             }
Sched_Class (osErr, TRUE);
osErr := 0;

IF trcFDocCtrl THEN WRITELN ('exit FCopyDiskFile, err:',err:1);
END;



{$S flrSplit}

PROCEDURE FindLast (VAR err: INTEGER; sDevPathname: Pathname; sPrefix: E_Name;
                    VAR lastname: E_Name);
VAR dfInfo:      Fs_Info;
    sDfname:     E_Name;
    sDfPathname: Pathname;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('FindLast: device pathname = ',sDevPathname,'prefix = ',sPrefix);

Reset_Catalog(err,sDevPathname);
IF err <= 0 THEN Get_Next_Entry(err,sPrefix,sDfName);
WHILE (err <= 0) AND (lastname = '')
DO BEGIN
  sDfPathname := CONCAT(sDevPathname,'-',sDfName);
  Lookup(err,sDfPathName,dfinfo);
  IF err <= 0 THEN
    IF dfinfo.file_portion = 1
    THEN lastname := sDfName
    ELSE Get_Next_Entry(err,sPrefix,sDfName);
  END;

IF trcFDocCtrl THEN WRITELN ('   exit FindLast: lastName is ',lastname);
END;


{**************************************************************************}
{*** This procedure was taken from libfc/fcimpl.text and modified to    ***}
{*** support the splitting and rebuilding of large documents.           ***}
{**************************************************************************}

{$S flrSplit}

PROCEDURE FCopyDoc (VAR error: INTEGER; fromPrefix, toPrefix: Pathname;
                   svol, dvol: TentryHdl; sCatRid, dCatRID: TcatRID;  useLdsn: INTEGER;
                   theOp: FCopyOp; xferOp: TuserOp; VAR docSize: LONGINT; Var diskCt: INTEGER;
                   split: BOOLEAN);
CONST copyDsSize = 20000;
VAR bytesread:      LONGINT;
    byteswritten:   LONGINT;
    copyDsName:     Pathname;
    copyDsRefnum:   INTEGER;
    dDevHdl:        TentryHdl;
    dDevName:       E_Name;
    dDevPathname:   Pathname;
    dDfName:        E_Name;
    dDfPathname:    Pathname;
    dDocName:       E_Name;
    dfInfo:         Fs_Info;
    docNameStart:   INTEGER;
    dsInfo:         DsInfoRec;
    dtm,dtc:        LONGINT;     {*** large doc backup**}
    labelRec:       LabelFmt;    {*** large doc backup**}
    lengthSDocName: INTEGER;
    osErr:          INTEGER;
    otherErr:       INTEGER;
    savename:       E_Name;               {*** Added for large doc backup ***}
    sCatRec,dCatRec: TcatRec;
    sDevHdl:        TentryHdl;
    sDevName:       E_Name;
    sDfName:        E_Name;
    sDfPathname:    Pathname;
    sDocName:       E_Name;
    sDevPathname:   Pathname;
    useDsAdrs:      LONGINT;
    useDsMemSize:   LONGINT;
    dcParams:       DcType;
    joinflag:       BOOLEAN;
    lastname:       E_Name;


  PROCEDURE OSError (result: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF Abort                        { Check for user abort        }
  THEN BEGIN
    osErr := fceAborted;
    result := fceAborted;
    END;

  IF osErr <> 0
  THEN BEGIN
    IF trcFDocCtrl THEN WRITELN ('Error in FCopyDoc: ',osErr:1);
    error := result;
    IF useLDSN > 0 THEN Close_DataSeg (osErr, copyDsRefnum);
    EXIT (FCopyDoc);
    END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

    (* Extract device and doc names: prefix looks like  -devName-{Dx...Tx...} *)

docNameStart := POS ('{', fromPrefix);
sDevName := COPY (fromPrefix, 2, docNameStart-3);
sDevPathname := COPY (fromPrefix, 1, docNameStart-2);
sDocName := COPY (fromPrefix, docNameStart, LENGTH(fromPrefix)-docNameStart+1);
lengthSDocName := LENGTH (sDocName);

docNameStart := POS ('{', toPrefix);
dDevName := COPY (toPrefix, 2, docNameStart-3);
dDevPathname := CONCAT ('-',dDevName);
dDocName := COPY (toPrefix, docNameStart, LENGTH(toPrefix)-docNameStart+1);

sDevHdl := svol^^.devHdl;       { Save device handles }
dDevHdl := dvol^^.devHdl;

    { Locate the first document diskfile }

osErr := 0;
Reset_Catalog (osErr, sDevPathname);
OSError (fceCantRead);
Get_Next_Entry (osErr, sDocName, sDfName);
IF osErr <> 848 THEN OSError(fceCantRead);     { 848 - no diskfiles            }

    { If diskfiles found, open the buffer ldsn }

IF osErr <= 0
THEN BEGIN
  IF useLDSN > 0
  THEN BEGIN                                   { Create temporary dataseg      }
    copyDsName := 'copyTemp';
    Make_DataSeg (osErr, copyDsName, copyDsSize, 0, copyDsRefnum, useDsAdrs,
                  useLdsn, ds_private);
    OSError(fceNoMemory);
    useDsMemSize := copyDsSize;
    END
  ELSE IF useLDSN < 0
  THEN BEGIN                                   { Use the client's LDSN         }
    Info_LDSN (osErr, -useLDSN, copyDsRefnum);
    IF osErr <= 0 THEN Info_DataSeg (osErr, copyDsRefnum, dsInfo);
    OSError (fceBadLDSN);
    useDsAdrs := dsInfo.segPtr;
    useDsMemSize := dsInfo.mem_Size;
    END
  ELSE BEGIN                                   { No LDSN provided              }
    osErr := 2;
    OSError (fceBadLDSN);
    END;
  END;

error := 0;
docSize := 0;
joinflag := FALSE;
lastname := '';
savename := '';

IF split
THEN BEGIN
   GetCatRec(osErr,svol,sCatRID,sCatRec);
   OSError(fceCantRead);
   IF sCatRec.split <> nullInt2
   THEN BEGIN
      joinflag := TRUE;
      FindLast(oserr,sDevPathname,sDocName,lastname);
      IF oserr <> 848
      THEN
         OSError(fceCantRead);
      Reset_Catalog (osErr, sDevPathname);
      OSError (fceCantRead);
      Get_Next_Entry (osErr, sDocName, sDfName);
   END;
END;


WHILE (osErr <= 0) AND (error <= 0)
DO BEGIN
   sDfPathname := CONCAT (sDevPathname,'-',sDfName);
   dDfPathname := CONCAT (dDevPathname,'-',dDocName,
                  COPY (sDfName, lengthSDocName+1, LENGTH(sDfName)-lengthSDocName));

   IF (sDfName <> lastname) AND (sDfName <> savename)
   THEN BEGIN
                                         { Copy the diskfile             }
      FCopyDiskfile (error, sDfPathname, dDfPathname, svol, dvol, sCatRID, dCatRID, useDsAdrs,
                     useDsMemSize, theOp, xferOp, osErr, diskCt, TRUE, split);

      svol := sDevHdl^^.volHdl;      { reset vol handles }
      dvol := dDevHdl^^.volHdl;
      IF split AND NOT joinflag THEN
      BEGIN
        savename := sDfname;
        Reset_Catalog(oserr,sDevPathname);
        OSError(fceCantRead);
        Get_Next_Entry(osErr,sDocName,sDfName);
        WHILE (osErr <= 0) AND (savename <> sDfName)
        DO BEGIN
            Get_Next_Entry(osErr,sDocName,sDfName);
        END;
      END;
   END;
   IF oserr <= 0 THEN Get_Next_Entry (osErr, sDocName, sDfName);

   IF (oserr = 848)  AND (lastname <> '')
   THEN BEGIN
       Reset_Catalog(oserr,sDevPathname);
       OSError(fceCantRead);
       Get_Next_Entry(osErr,sDocName,sDfName);
       WHILE (osErr <= 0) AND (lastname <> sDfName)
       DO BEGIN
          Get_Next_Entry(osErr,sDocName,sDfName);
       END;
       sDfPathname := CONCAT (sDevPathname,'-',sDfName);
       dDfPathname := CONCAT (dDevPathname,'-',dDocName,
                      COPY (sDfName, lengthSDocName+1, LENGTH(sDfName)-lengthSDocName));

        FCopyDiskfile (error, sDfPathname, dDfPathname, svol, dvol, sCatRID, dCatRID, useDsAdrs,
                       useDsMemSize, theOp, xferOp, osErr, diskCt, TRUE, split);
        svol := sDevHdl^^.volHdl;      { reset vol handles }
        dvol := dDevHdl^^.volHdl;
        lastname := '';
        savename := sDfname;
        FindLast(osErr,sDevPathname,sDocName,lastname);
        IF osErr <> 848
        THEN
           OSError (fceCantRead);
        Reset_Catalog (osErr, sDevPathname);
        OSError (fceCantRead);
        Get_Next_Entry (osErr, sDocName, sDfName);
   END;
 END;      {end of WHILE loop}

   { Document copying finished, delete it if there was an error }

IF error <> fceNoErrors
THEN BEGIN                             { Delete any diskfiles that were copied }
  Reset_Catalog (osErr, dDevPathname);
  IF osErr <= 0 THEN Get_Next_Entry (osErr, dDocName, dDfName);
  WHILE osErr <= 0
  DO BEGIN
    dDfPathname := CONCAT ('-',dDevName,'-',dDfName);
    ZapPassword (dDfPathname);
    Kill_Object (osErr, dDfPathname);
    Get_Next_Entry (osErr, dDocName, dDfName);
    END;
  END
ELSE
   IF split
   THEN BEGIN
      GetCatRec(osErr,dvol,dCatRID,dCatRec);
      OSError(fceCantRead);
      IF joinflag
      THEN BEGIN
         dCatRec.split := nullInt2;
         dCatRec.objsize := ObjectSize(dvol,dCatRID,NIL,FALSE,dtm,dtc);
         UpdCatRec(oserr,dvol,dCatRID,dCatRec);
         OSError(fceCantWrite);
         END
      ELSE BEGIN
         dCatRec.objsize := ObjectSize(dvol,dCatRID,NIL,FALSE,dtm,dtc);
         dCatRec.split := - dCatRec.split;
         UpdCatRec(oserr,dvol,dCatRID,dCatRec);
         OSError(fceCantWrite);

         Reset_Catalog(oserr,dDevPathname);
         IF oserr <= 0
         THEN
            Get_Next_Entry(oserr,dDocName,dDfName);
            WHILE oserr <= 0
            DO BEGIN
               dDfPathname := CONCAT ('-',dDevName,'-',dDfName);
               Read_Label(oserr,dDfPathname,ORD(@labelRec),SizeOf(labelRec),bytesread);
               OSError(fceCantRead);
               IF labelRec.split > 0
               THEN BEGIN
                  labelRec.split := - labelRec.split;
                  Write_Label(oserr,dDfPathname,ORD(@labelRec),bytesread,byteswritten);
                  END;
               Get_Next_Entry(oserr,dDocName,dDfName);

               END;
       END;
    END;


IF useLDSN > 0 THEN Close_DataSeg (osErr, copyDsRefnum);

END;

{****************************************************************************}
{$S flrDm1 }
PROCEDURE DfSize (devHdl: TentryHdl; prefix: E_Name; devInfoPtr: TFsInfoPtr;
                  VAR sizeBlks: LONGINT; VAR writers: BOOLEAN;
                  VAR modified, created: LONGINT);

VAR devInfo:     FS_Info;
    devName:     E_Name;
    devPathname: Pathname;
    dfBlks:      LONGINT;
    dfInfo:      Q_Info;
    dfName:      E_Name;
    dfPathname:  Pathname;
    err:         INTEGER;
    schedErr:    INTEGER;

  PROCEDURE CheckErr (location: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF ErrorFound (askError, location, err, devHdl) THEN;
    created := nullInt4;
    modified := nullInt4;
    IF trcFDocCtrl THEN WRITELN ('   exit DfSize: err = ',err:1);
    EXIT (DfSize);
    END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('DfSize: ',prefix,' on ',devHdl^^.nameHdl^^);

writers := FALSE;
modified := nullInt4;
created := nullInt4;
sizeBlks := 0;

devName := devHdl^^.nameHdl^^;
devPathname := CONCAT('-',devName);
IF devInfoPtr = NIL
THEN BEGIN
  Lookup (err, devPathname, devInfo);
  CheckErr (872);
  devInfoPtr := @devInfo;
  END;
Reset_Catalog (err, devPathname);
CheckErr (873);

Get_Next_Entry (err, prefix, dfName);
IF err <> 848          { no diskfiles }
THEN BEGIN
  CheckErr (874);
  WITH devInfoPtr^ DO
  REPEAT
    dfPathname := CONCAT(devPathname,'-',dfName);
    Quick_Lookup (err, dfPathname, dfInfo);
    CheckErr (875);
    IF dfInfo.nWriters > 0 THEN writers := TRUE;
    IF (dfInfo.dtm > modified)
    AND (dfInfo.dtm <> 0)                  {*** OS inits to 0 ***}
    THEN modified := dfInfo.dtm;
    IF dfInfo.dtc > created THEN created := dfInfo.dtc;
    dfBlks := dfInfo.pSize DIV dataSize;
    IF dfInfo.pSize MOD dataSize <> 0 THEN dfBlks := dfBlks + 1;
    sizeBlks := sizeBlks + dfBlks + dfInfo.fs_Overhead;
    IF trcFDocCtrl THEN WRITELN ('   data size of ',dfName,' = ',dfBlks:1,
                                 ', overhead is ',dfInfo.fs_Overhead:1);
    Get_Next_Entry (err, prefix, dfName);
    UNTIL err <> 0;
  IF err <> 848 THEN CheckErr (844);
  END;
IF created = nullInt4 THEN created := TimeStamp;
IF trcFDocCtrl THEN WRITELN ('   exit DfSize: size = ',sizeBlks:1,
                             ', writers is ',writers,', dtm is ',modified);
END;


{**************************************************************************}

{$S flrDm1 }

PROCEDURE DocSize (hVol: TentryHdl; docCatRID: TcatRID; devInfoPtr: TFsInfoPtr;
                   VAR size: LONGINT; VAR dtm, dtc: LONGINT);

{ This proc scans the diskfiles that makeup the document and and returns the
  total number of blocks occupied by the document, including OS overhead.
  The size is based on the datasize and clustersize in the fs_info record
  via devInfoPtr.  If devInfoPtr is NIL, hVol is used to retrieve
  the fs_info record for the document's volume.  }


VAR docName:    E_Name;
    err:        INTEGER;
    intStr:     NumberStr;
    writers:    BOOLEAN;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('DocSize: doc ',docCatRID.uniqueID:1,
                             ' on ',hVol^^.nameHdl^^);

IntToStr (docCatRID.uniqueID, intStr);
docName := CONCAT('{D',intStr,'T');
DfSize (hVol^^.devHdl, docName, devInfoPtr, size, writers, dtm, dtc);

IF trcFDocCtrl THEN WRITELN ('   exit DocSize: size = ',size:1,', dtm ',dtm:1);
END;


{*************************************************************************}

{$S flrDm }

PROCEDURE DupDoc (VAR err: INTEGER; sCatRID, deCatRID: TcatRID;
                  sVol, dVol: TentryHdl; copyOp: FCopyOp; xferOp: TuserOp;
                  VAR diskCt: INTEGER; split: BOOLEAN);

VAR catErr:         INTEGER;
    catRec:         TcatRec;
    dDevHdl:        TentryHdl;
    dDfPathname:    FMaxStr;
    dDocDfName:     E_Name;
    docHdl:         TentryHdl;
    dtc:            LONGINT;
    dtm:            LONGINT;
    field:          TfieldVar;
    reply:          FReason;
    sDevHdl:        TentryHdl;
    sDfPathname:    Pathname;
    sDocDfName:     E_Name;


  PROCEDURE AbortDup;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('AbortDup: err = ',err:1);

  CASE err OF
    aborted:           ;    {user cancelled, so do not put up message}
    fUserAbort,
    fceAborted:        BEGIN
                       WaitAlert (flrAlert, 263);
                       err := fUserAbort;
                       END;
    fceCantRead:       err := fCantRead;
    fceCantWrite:      err := fCantWrite;
    fceOutOfDiskSpace: err := fNoSpace;
    fceNoMemory:       err := fNoMemory;
    fceInUse:          err := fCantRead;
    OTHERWISE          BEGIN
                       IF ErrorFound (warnError, 859, err, NIL) THEN ;
                       err := aborted;
                       END;
    END;

  IF trcFDocCtrl THEN WRITELN ('   exit AbortDup and DupDoc');
  EXIT (DupDoc);
  END;


{------------------- DupDoc -----------------------------------------------}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('DupDoc: ',sCatRID.uniqueID:1,
                             ' to ',deCatRID.uniqueID:1);

field.fieldType := dCatRID;                 { Get doc entry if doc is open    }
field.catRID := sCatRID;
GetEntry (doc, sVol, NIL, field, docHdl);

sDevHdl := svol^^.devHdl;       { Save device handles }
dDevHdl := dvol^^.devHdl;

GetCatRec (err, sVol, sCatRID, catRec);
IF err > 0 THEN AbortDup;

IF (catRec.objSize = 0) AND (docHdl = NIL)  { Doc not open and no diskfiles   }
THEN EXIT(DupDoc);

  { Build the document diskfile names}
BuildDocName (sCatRID.uniqueID, catRec.toolID, sDocDfName);
BuildDocName (deCatRID.uniqueID, catRec.toolID, dDocDfName);
dDfPathname := CONCAT('-',dVol^^.devHdl^^.nameHdl^^,'-',dDocDfName);
sDfPathname := CONCAT('-',sVol^^.devHdl^^.nameHdl^^,'-',sDocDfName);

IF docHdl = NIL
THEN BEGIN                                 { Doc is not open                 }
  IF trcFDocCtrl THEN WRITELN ('   copying ',sDfPathname,' to ',dDfPathname);
  FCopyDoc (err, sDfPathname, dDfPathname, svol, dvol, sCatRID, deCatRID, -dfCopyLDSN, copyOp,
            xferOp, catRec.objSize, diskCt, split);
  IF err <> 0 THEN AbortDup;
  IF split THEN BEGIN
    svol := sDevHdl^^.volHdl;
    dvol := dDevHdl^^.volHdl;
    END;
  END
ELSE BEGIN
  IF trcFDocCtrl THEN WRITELN ('   doc is on the desktop');
  IF docHdl^^.state = opened
  THEN BEGIN                             { Doc is open, belongs to the tool}
    SendFilerEvent (err, docHdl^^.toolHdl^^.procID, docHdl^^.fWindow,
                    fcCopy, dDfPathname, 0, '', '', reply);
    IF err <= 0
    THEN BEGIN
      GetCatRec (catErr, dVol, deCatRID, catRec);
      IF catErr <= 0
      THEN BEGIN
        DocSize (dVol, deCatRID, NIL, catRec.objSize, dtm, dtc);
        UpdCatRec (catErr, dVol, deCatRID, catRec);
        IF trcFDocCtrl THEN WRITELN ('UpdCatRec returned: ',catErr:1,', CatRec.split = ',CatRec.split,
                                     ', CatRec.objsize  = ',CatRec.objsize);
        END;
      IF catErr <= 0 THEN AdjustParentObjSize (dVol, catRec.parentID, TRUE);
      IF ErrorFound (warnError, 879, catErr, dVol^^.devHdl) THEN;
      END;
    END
  ELSE BEGIN                             { Doc is open but its the Filer's }
    IF trcFDocCtrl THEN WRITELN ('   copying desktop doc ',sDfPathname,' to ',dDfPathname);
    IF catRec.objSize <> 0
    THEN BEGIN
      FCopyDoc (err, sDfPathname, dDfPathname, svol, dvol, sCatRID, deCatRID, -dfCopyLDSN, copyOp,
                xferOp, catRec.objSize, diskCt, split);
      IF err > 0 THEN AbortDup;
      IF split THEN BEGIN
        svol := sDevHdl^^.volHdl;
        dvol := dDevHdl^^.volHdl;
        END;
      END;
    END;
  END;

IF trcFDocCtrl THEN WRITELN ('   exit DupDoc: err = ',err:1);
END;


{**************************************************************************}
{$S flrCopy }

PROCEDURE DupTool (VAR err: INTEGER; toolID: TtoolId; sCatRID, dCatRID: TcatRID;
                   sVol, dVol: TentryHdl; movingTool: BOOLEAN; VAR diskCt: INTEGER;
                   xferOp: TuserOp; split: BOOLEAN);
LABEL 33, 66, 77, 99;
VAR catErr:       INTEGER;
    catRec:       TcatRec;
    dataBlks:     LONGINT;
    dDevHdl:      TentryHdl;
    dDevPathname: Pathname;
    deltaSize:    LONGINT;
    dfInfo:       Fs_Info;
    dfPathname:   Pathname;
    dfName:       E_Name;
    dtc:          LONGINT;
    dtm:          LONGINT;
    intStr:       NumberStr;
    isMaster:     BOOLEAN;
    isProtected:  BOOLEAN;
    isMachine:    LONGINT;
    osErr:        INTEGER;
    schedErr:     INTEGER;
    sDevHdl:      TentryHdl;
    sDevPathname: Pathname;
    sDfPathname:  Pathname;
    sizeSoFar:    LONGINT;
    toolDfName:   E_Name;
    toolName:     FMaxStr;
    toolPathname: Pathname;
    toolPrefix:   E_Name;
    writers:      BOOLEAN;


  PROCEDURE AbortDup;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('AbortDup: err = ',err:1);

  CASE err OF
    fUserAbort,
    fceAborted:        BEGIN
                       WaitAlert (flrAlert, 263);
                       err := fUserAbort;
                       END;
    198,                                  { Cant read intrinsic.lib }
    fceCantRead:       err := fCantRead;
    fceCantWrite:      err := fCantWrite;
    fceOutOfDiskSpace: err := fNoSpace;
    fceNoMemory:       err := fNoMemory;
    fceInUse:          err := fCantRead;
    aborted,
    fOneTool: ;
    OTHERWISE          BEGIN
                       IF ErrorFound (warnError, 863, err, NIL) THEN ;
                       err := aborted;
                       END;
    END;

  IF trcFDocCtrl THEN WRITELN ('   exit AbortDup and DupTool');
  EXIT (DupTool);
  END;


  PROCEDURE ToolMustBeClosed;
  VAR field:   TfieldVar;
      toolHdl: TentryHdl;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('ToolMustBeClosed');

  GetToolName (err, toolID, sVol^^.devHdl, toolName);
  IF err > 0
  THEN BEGIN                     { Can't find tool name, use its number   }
    IntToStr (toolID, intStr);
    toolName := CONCAT('Tool ',COPY (intStr, 0, LENGTH(intStr)));
    END;
  ParamAlert (toolName,'','');
  IF AskAlert (flrAlert, 273) = 2{ Shall we terminate tool to xfer?       }
  THEN BEGIN                     { Yes, suspend all tool instances        }
    UpdateAll;
    field.fieldType := tID;
    field.ID := toolID;
    GetEntry (tool, sVol, NIL, field, toolHdl);
    IF toolHdl = NIL
    THEN BEGIN
      err := nullErr;
      AbortDup;
      END;
    REPEAT
      KillTool (toolHdl);
      GetEntry (tool, sVol, NIL, field, toolHdl);
      UNTIL toolHdl = NIL;
    END
  ELSE BEGIN
    UpdateAll;
    err := aborted;
    AbortDup;
    END;

  IF trcFDocCtrl THEN WRITELN ('   exit ToolMustBeClosed');
  END;

{------------------- DupTool ---------------------------------------------}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('DupTool: from ',sVol^^.devHdl^^.nameHdl^^,
                             ' to ',dVol^^.devHdl^^.nameHdl^^,
                             ' moving is ',movingTool);


IF sVol = dVol                { A tool can't be duplicated on the same disk }
THEN BEGIN
  err := fOneTool;
  AbortDup;
  END;

   { Check if it will fit on the disk }
GetCatRec (err, sVol, sCatRID, catRec);
IF err > 0 THEN AbortDup;
IF NOT ItWillFit (catRec.objSize, dVol)
THEN BEGIN
  err := fceOutOfDiskSpace;
  AbortDup;
  END;

sDevHdl := svol^^.devHdl;       { Save device handles }
dDevHdl := dvol^^.devHdl;

err := fNoErr;
sDevPathname := CONCAT ('-',svol^^.devHdl^^.nameHdl^^);
dDevPathname := CONCAT ('-',dvol^^.devHdl^^.nameHdl^^);
BuildToolName (toolID, toolPrefix);

  { Check protections }
sDfPathname := CONCAT (sDevPathname,'-',toolPrefix,'obj');
Lookup (err, sDfPathname, dfInfo);
IF err > 0 THEN AbortDup;
IF dfInfo.protected AND dfInfo.master_File
THEN BEGIN
  IF movingTool
  THEN BEGIN
    StopAlert (flrAlert, 278);             { Can't move master off the disk }
    GOTO 99;
    END;
  IF dfInfo.machine_ID = 0
  THEN BEGIN                               { First copy                     }
    IF DeflowerMasterTool (toolID, sVol^^.devHdl)
    THEN Lookup (err, sDfPathname, dfInfo) { Deflowering sets machine_ID    }
    ELSE BEGIN                             { User did not want to deflower  }
      err := aborted;
      AbortDup;
      END;
    END;
  END;

WITH dfInfo DO BEGIN
  isMaster := master_File;
  isProtected := protected;
  isMachine := machine_ID;
  END;

Reset_Catalog (err, sDevPathname);
IF err > 0 THEN AbortDup;
Get_Next_Entry (err, toolPrefix, toolDfName);
WHILE err <= 0 DO BEGIN                   { Copy each diskfile             }
  sDfPathname := CONCAT (sDevPathname,'-',toolDfName);
33:
  IF Abort
  THEN BEGIN
    err := fUserAbort;
    AbortDup;
    END;
  Lookup (err, sDfPathname, dfInfo);
  IF err > 0 THEN AbortDup;
  IF dfInfo.nWriters > 0                 { Diskfile may be changing       }
  THEN BEGIN
    ToolMustBeClosed;
    Lookup (err, sDfPathname, dfInfo);
    IF err > 0 THEN GOTO 77;             { diskfile dissappeared, get next }
    END;

  dfPathname := CONCAT(dDevPathname,'-',toolDfName); { Copy the diskfile  }
66:
  IF trcFDocCtrl THEN WRITELN ('   copying ',sDfPathname,' to ',dfPathname);
  FCopyDiskFile (err, sDfPathname, dfPathname, svol, dvol, sCatRID, dCatRID, copyDsAddr,
                copyDsMemSize,fcDocMove, xferOp, osErr, diskCt, TRUE, FALSE);
  svol := sDevHdl^^.volHdl;
  dvol := dDevHdl^^.volHdl;
  IF err > 0 THEN AbortDup;

  DownShift (@toolDfName);
  IF POS('obj',toolDfName) <> 0          { Is this an object file?        }
  THEN BEGIN
    IF isProtected                       { Set the protection flags       }
    THEN BEGIN
      IF trcFDocCtrl THEN WRITELN ('   setting protection: ',dfPathname,' ',
                                   dfInfo.machine_ID:1);
      Protect (err, dfPathname, isMaster AND movingTool, isMachine);
      END;
    END;
  IF split THEN BEGIN
    svol := sDevHdl^^.volHdl;
    dvol := dDevHdl^^.volHdl;
    END;
77:
  Get_Next_Entry (err, toolPrefix, toolDfName);
  END;
IF err = 848 THEN err := 0;

IF err <= 0
THEN BEGIN
  GetCatRec (err, dVol, dCatRID, catRec);   { Set size                   }
  IF err <= 0
  THEN BEGIN
    catRec.objSize := ToolSize (dVol, toolId, NIL, dtm, dtc);
    UpdCatRec (err, dVol, dCatRID, catRec);
    END;
  END;

99:
IF trcFDocCtrl THEN WRITELN ('   exit DupTool: err = ',err:1);
END;


{*************************************************************************}
{$S flrClose }
PROCEDURE FinishClose (window: WindowPtr);
LABEL 99;
VAR catRec:      TcatRec;
    diskName:    FMaxStr;
    docName:     FMaxStr;
    docHdl:      TentryHdl;
    dtc:         LONGINT;
    err:         INTEGER;
    extraProcHdl:TentryHdl;
    field:       TfieldVar;
    hTermTool:   TentryHdl;
    moreMem:     BOOLEAN;
    reply:       FReason;
    responsePtr: ReplyPtr;
    savePort:    GrafPtr;
    tempToolHdl: TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('FinishClose');

field.fieldType := dFwindow;            { Get the doc entry for the sender  }
field.fWindow := window;
GetEntry (doc, NIL, NIL, field, docHdl);
IF docHdl = NIL                             { Bullet proofing               }
THEN BEGIN
  IF dbgFiler THEN WRITELN ('ERROR in FinishClose: could not find doc entry for window ',
                             ORD(window):1);
  GOTO 99;
  END;

tempToolHdl := docHdl^^.toolHdl;
responsePtr := @curEvent.userData;
IF NOT (responsePtr^.theReply IN [docClosd, docXfered, initFailed])
THEN WITH docHdl^^ DO BEGIN                 { Tool could not close the doc  }
  CASE responsePtr^.theReason OF
    cantRead:    err := fCantRead;
    wrongPassword: err := fBadPassword;
    cantWrite:   err := fCantWrite;
    dirtyDoc:    err := fDirtyDoc;
    newerDoc:    err := fNewerDoc;
    noDiskSpace: err := fNoSpace;
    noMemory:    err := fNoMemory;
    internalErr: err := fToolErr;
    aUserAbort:  err := fUserAbort;
    END;
  state := opened;
  IF responsePtr^.theReply <> docNotXfered
  THEN TellUserWhy (volHdl, volHdl, catRID, catRID, err, opClose);
  END
ELSE BEGIN                                  { Doc was closed by the tool    }
  IF trcFDocCtrl THEN WRITELN ('   doc was closed');
  WITH docHdl^^ DO BEGIN
    IF toolHdl <> NIL
    THEN WITH toolHdl^^ DO BEGIN            { Update the tool entry         }
      docsOpen := docsOpen - 1;
      moreDocs := TRUE;
      END;
    END;

     { Update catalog record fields }
  GetCatRec (err, docHdl^^.volHdl, docHdl^^.catRID, catRec);
  IF NOT ErrorFound (warnError, 820, err, docHdl^^.volHdl^^.devHdl)
  THEN IF catRec.objKind = docKind
  THEN BEGIN
    DocSize (docHdl^^.volHdl, docHdl^^.catRID, NIL, catRec.objSize,
             catRec.modified, dtc);
    UpdCatRec (err, docHdl^^.volHdl, docHdl^^.catRID, catRec);
    IF NOT ErrorFound (warnError, 821, err, docHdl^^.volHdl^^.devHdl)
    THEN AdjustParentObjSize (docHdl^^.volHdl, catRec.parentID, FALSE);
    IF trcFDocCtrl THEN WRITELN ('   doc catRec updated: objSize is ',catRec.objSize,
                                 ', modified is ',catRec.modified:1);
    END;

    { Kill the doc entry or reclaim the window }
  IF docHdl^^.state = closingFolder
  THEN KillEntry (docHdl)                   { filing doc or removing vol    }

  ELSE BEGIN                                { Reclaim window                }
    TakeWindow (docHdl^^.fWindow);
    GetPort (savePort);
    SetPort (docHdl^^.fWindow);
    ClipRect (docHdl^^.fWindow^.portRect);  { Reset to whole window         }
    EraseRect (docHdl^^.fWindow^.portRect); { Erase all content             }
    InvalRect (docHdl^^.fWindow^.portRect); { Schedule an update event      }
    SetPort (savePort);

    IF NOT (Abort
    OR (docHdl^^.state IN [closing, closingFolder])
    OR (responsePtr^.theReason = docPutBack))
    THEN BEGIN                              { Try to restart                }
      WITH docHdl^^ DO
      IF toolHdl <> NIL THEN toolHdl^^.docsOpen := toolHdl^^.docsOpen + 1;
                                            { Prevent this tool from being killed }
      CASE responsePtr^.theReason OF
        noMemory:      moreMem := KillExtraProcs (docHdl^^.volHdl);
        noDiskSpace,
        cantWrite:     moreMem := ReclaimDiskSpace (docHdl^^.volHdl, 0) > 0;
        wrongPassword: BEGIN
                       FixPassword (docHdl^^.volHdl, docHdl^^.CatRID);
                       docHdl^^.docPassword := '';
                       moreMem := FALSE;
                       END;
        OTHERWISE  moreMem := FALSE;
        END;
      WITH docHdl^^ DO
      IF toolHdl <> NIL THEN toolHdl^^.docsOpen := toolHdl^^.docsOpen - 1;
      IF moreMem AND (NOT Abort)
      THEN BEGIN
        docHdl^^.state := blank;
        StartDoc (docHdl, FALSE);
        IF docHdl^^.fWindow = activeFolder    {*** FI ??? ***}
        THEN BEGIN
          DeactObject(TRUE,TRUE);             { pretend I received a deactivate  }
          AdjustDesktopMenu;
          ClearMenuBar;                       { app won't do a TakeControl }
          END;
        IF trcFDocCtrl THEN WMStatus;
        GOTO 99;
        END;
      END;

    WITH docHdl^^ DO
    CASE responsePtr^.theReason OF          { Update the doc entry          }
      allOk:  BEGIN                         { Doc suspended, unlink from tool}
          state := noTool;
          END;

         { These should happen only for an unsolicited docClose }
      aUserAbort:    BEGIN
          state := blank;
          StopAlert (flrAlert, 255);
          END;

      docPutBack:                           { Process put away the doc      }
          KillEntry (docHdl);

      noMoreDocs:    BEGIN                  { Process can't handle another doc}
          IF trcFDocCtrl THEN WRITELN ('   noMoreDocs');
          IF state = toolOpened
          THEN BEGIN                        { Tool must have a doc to run   }
            state := docReqd;
            END
          ELSE BEGIN
            IF toolHdl <> NIL
            THEN toolHdl^^.moreDocs := FALSE;{ Process can't handle it       }
            state := blank;
            StartDoc (docHdl, FALSE);
            END;
          END;

      badData:       state := deadDoc;      { broken doc, tool can't display}
      cantConvert:   state := tooOld;       { tool can't convert to new format}
      cantRead:      state := deadDoc;      { unable to read doc diskfiles  }
      wrongPassword: state := blank;        { inconsistent password was reset }
      cantWrite:     state := noDisk;       { unable to write out the doc   }
      needToConvert: state := mustAlter;    { old format, must be converted }
      newerDoc:      state := tooNew;       { doc is newer version than tool}
      noDiskSpace:   state := noDisk;       { tool can't open doc           }
      noMemory:      state := tooBusy;      { tool can't open doc           }
      internalError: state := deadDoc;      { tool cannot display doc       }
      OTHERWISE      BEGIN
                     state := blank;
                     IF ErrorFound (warnError, 898, ORD(responsePtr^.theReason),
                                    NIL) THEN;
                     END;
      END;
    END;
  END;

(*****
   { Kill the tool if it is excess }
IF tempToolHdl <> NIL THEN IF tempToolHdl^^.docsOpen = 0
THEN BEGIN
  IF tempToolHdl^^.toolState = sTerminating
  THEN hTermTool := tempToolHdl
  ELSE BEGIN                              { Check if there are other spares }
    hTermTool := NIL;
    field.fieldType := tID;
    field.id := tempToolHdl^^.id;
    GetEntry (tool, NIL, NIL, field, extraProcHdl);
    WHILE extraProcHdl <> NIL DO BEGIN
      IF (extraProcHdl <> tempToolHdl) AND (extraProcHdl^^.docsOpen = 0)
      THEN hTermTool := extraProcHdl;     { Found an extra, kill it         }
      GetEntry (tool, NIL, extraProcHdl, field, extraProcHdl);
      END;
    END;
  IF hTermTool <> NIL
  THEN  KillTool (hTermTool);
  END;
*****)

99:
IF trcFDocCtrl THEN WRITELN ('   exit FinishClose');
END;


{$S flrCopy }

FUNCTION FitOnEmptyDisk (objSize: LONGINT; devHdl: TentryHdl) : BOOLEAN;
{ checks if the object could fit on the volume if it were empty }
VAR devInfo:     FS_Info;
    devPathname: Pathname;
    emptySize:   LONGINT;
    err:         INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('FitOnEmptyDisk: objSize is ',objSize:1,', device is ',devHdl^^.nameHdl^^);
FitOnEmptyDisk := FALSE;

{ how much free space is there on an empty volume? }
devPathname := CONCAT('-',devHdl^^.nameHdl^^);
LookUp (err,devPathname,devInfo);
IF err > 0 THEN
   BEGIN
   IF trcFiler THEN WRITELN('   exit FitOnEmptyDisk: error looking up pathname ',devPathname,': ',err:1);
   EXIT(FitOnEmptyDisk);
   END;
WITH devInfo DO emptySize := fs_Size - fs_Overhead - catOverhead - sizeSpace;

IF objSize < emptySize THEN FitOnEmptyDisk := TRUE;

IF trcFiler THEN WRITELN('   exit FitOnEmptyDisk: empty size is ',emptySize:1);
END;


{**************************************************************************}

{$S flrCopy }

FUNCTION ItWillFit {objSize: LONGINT; volHdl: TentryHdl) : BOOLEAN};
VAR blocksNeeded: LONGINT;
    devInfo:      FS_Info;
    devPathname:  Pathname;
    err:          INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ItWillFit: size is ',objSize:1,', disk is ',volHdl^^.devHdl^^.nameHdl^^);

ItWillFit := FALSE;

   { get the disk free space count }
devPathname := CONCAT('-', volHdl^^.devHdl^^.nameHdl^^);
Lookup (err,devPathname,devInfo);
IF ErrorFound (warnError,-1019,err,volHdl^^.devHdl) THEN EXIT(ItWillFit);

IF objSize < devInfo.freeCount
THEN ItWillFit := TRUE
ELSE BEGIN                      { not enough room, try to free enough }
   blocksNeeded := objSize - devInfo.freeCount;
   ItWillFit := (ReclaimDiskSpace (volHdl,blocksNeeded) >= blocksNeeded);
   END;

IF trcFDocCtrl THEN WRITELN ('   exit ItWillFit');
END;

{**************************************************************************}
{$S flrCat }
PROCEDURE KillTool {toolHdl: TentryHdl};

VAR activeDocs:  BOOLEAN;
    docHdl:      TentryHdl;
    err:         INTEGER;
    field:       TfieldVar;
    reply:       FReason;


  PROCEDURE SuspendDocs (toolHdl: TentryHdl; VAR activeDocs: BOOLEAN);

  { This procedure suspends all documents either on the the disk being
    dismounted (volHdl) OR opened by a tool (toolHdl). The unused Hdl should
    equal nilHdl. This proc is called when a volume is being dismounted. ActiveDocs
    is TRUE if opendocs were found. }

  LABEL  99;
  VAR err:        INTEGER;
      docHdl:     TentryHdl;
      fieldVar:   TfieldVar;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('SuspendDocs');

  activeDocs := FALSE;
  fieldVar.fieldType := dToolHdl;
  fieldVar.toolHdl := toolHdl;
  docHdl := NIL;

  REPEAT                                { Suspend each doc the tool has  }
    GetEntry (doc, NIL, docHdl, fieldVar, docHdl);
    IF docHdl = NIL THEN GOTO 99;       { No more docs                   }
    KillDoc(err, docHdl,FALSE,FALSE,FALSE); {Don't file doc or rem window}
    activeDocs := (toolHdl^^.docsOpen <> 0); { may be dead on return from KillDoc}
    UNTIL FALSE;

  99:
  IF trcFDocCtrl THEN WRITELN ('   exit SuspendDocs: activeDocs = ',ORD(activeDocs));
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('KillTool: ',toolHdl^^.nameHdl^^);

IF toolHdl^^.toolState = sTerminating
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   exit KillTool: ',toolHdl^^.nameHdl^^,
                               ' is already terminating');
  EXIT (KillTool);
  END;

CASE toolHdl^^.toolState OF
  sRunning: BEGIN                               { Terminate after docs closed }
      IF trcFDocCtrl THEN WRITELN ('   tool is running, terminating');
      IF toolHdl^^.docsOpen <> 0                { Bullet-proofing             }
      THEN SuspendDocs (toolHdl, activeDocs)    { Close the tool's docs       }
      ELSE activeDocs := FALSE;
      toolHdl^^.toolState := sTerminating;
      IF NOT activeDocs
      THEN SendFilerEvent (err, toolHdl^^.procID, NIL, fcTerminate, '', 0, '', '', reply)
      END;

  sTerminating: BEGIN                           { Do nothing                  }
      IF trcFDocCtrl THEN WRITELN ('   tool is already terminating, ignored');
      END;

  OTHERWISE BEGIN
      IF trcFDocCtrl THEN WRITELN ('   no code file for tool, deleting entry');
      KillEntry (toolHdl);
      END;
  END;

IF trcFDocCtrl THEN WRITELN ('   exit KillTool');
END;


{**************************************************************************}
{$S flrSplit}

PROCEDURE ReconstructParentage {sVolHdl, dVolHdl: TentryHdl; catRID: TcatRID};
VAR catErr:        INTEGER;
    catRec:        TcatRec;
    destination:   Pathname;
    err:           INTEGER;
    fsParms:       Ut_Parmt;
    newCatRID:     TcatRID;
    objName:       FMaxStr;
    oldCatRID:     TcatRID;
    posExact:      TcatRID;
    source:        Pathname;

  PROCEDURE CheckErr (location, theErr: INTEGER; volHdl: TentryHdl);
  VAR devHdl: TentryHdl;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF theErr > 0
  THEN BEGIN
    IF volHdl <> NIL
    THEN devHdl := volHdl^^.devHdl
    ELSE devHdl := NIL;
    IF ErrorFound (askError, location, theErr, devHdl)
    THEN BEGIN
      IF trcFDocCtrl THEN WRITELN ('   exit ReconstructParentage: err set to aborted');
      theErr := aborted;
      EXIT (ReconstructParentage);
      END
    ELSE theErr := 0;
    END;
  err := theErr;  { in case caller passed in catErr or some such }
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ReconstructParentage');

posExact.fatherID := idNil;
posExact.uniqueID := catRID.fatherID;
catRec.parentID := catRID.fatherID;
WHILE catRec.parentID <> idDisk
DO BEGIN
  GetCatRec (catErr, sVolHdl, posExact, catRec);
  CheckErr (861,catErr,sVolHdl);
  oldCatRID.fatherID := catRec.parentID;
  oldCatRID.uniqueID := catRec.selfID;
  GetObjPrefix (sVolHdl, oldCatRID, source, TRUE);
  IF trcFDocCtrl
  THEN BEGIN
    ExtObjName (catRec, objName);
    WRITELN ('  adding catRec for ', objName,' id is ',catRec.selfID:1);
    END;
  AddCatRec (catErr,dVolHdl,catRec,FALSE,newCatRID);
  CheckErr (862,catErr,dVolHdl);
  GetObjPrefix (dVolHdl, newCatRID, destination, TRUE);
  posExact.fatherID := catRec.parentID;
  MakeFolder (err, dVolHdl, newCatRID, sVolHdl, posExact);

  { copy the password, if any }
  IF err <= 0 THEN WITH fsParms DO BEGIN
    gp_parm := 0;
    command := xfer_Passwd;
    path    := source;
    op      := pswRead;
    FS_Utilities (err, fsParms);
    IF err <= 0 THEN
      BEGIN
      path  := destination;
      op    := pswWrite;
      FS_Utilities (err, fsParms);
      END;
    END;

  posExact.fatherID := idNil;
  posExact.uniqueID := catRec.parentID;
  END;

IF trcFDocCtrl THEN WRITELN ('   exit ReconstructParentage');
END;


{**************************************************************************}
{$S flrMisc }
FUNCTION RecompFolderSize {hVol: TentryHdl; objCatRID: TcatRID) : LONGINT};
LABEL 99;
VAR catRec:     TcatRec;
    err:        INTEGER;
    pCatRec:    PtrCatRec;
    size:       LONGINT;
    sonCatRID:  TcatRID;

  PROCEDURE CheckErr (location: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF ErrorFound (warnError, location, err, hVol^^.devHdl) THEN;
    RecompFolderSize := size;
    IF trcFDocCtrl THEN WRITELN ('   exit RecompFolderSize: err = ',err:1);
    EXIT (RecompFolderSize);
    END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN('RecompFolderSize - parent: ',objCatRID.fatherID:1,
                                              ' id: ',objCatRID.uniqueID:1);

size := 0;

GetCatRec(err, hVol, objCatRID, catRec);     { Get obj catRec             }
CheckErr (803);
CASE catRec.objKind OF
  docKind,
  docPad,
  calcKind,
  clockKind,
  computerKind,
  comp2Kind,
  printKind,
  toolKind:
      size := catRec.objSize;

  trashKind,                                  { The object is a container  }
  inBox1Kind,
  inbox2Kind,
  outBox1Kind,
  outBox2Kind,
  letterKind,
  letterPad,
  folderPad,                                  { It can contain docs        }
  folderKind: BEGIN

      { position to first record of contents }
      posApprox.fatherID := objCatRID.uniqueID;
      PosCatRec(err, hVol, posApprox, pCatRec);

      { loop thru sons }
      WHILE (err <= 0) AND (pCatRec^.parentID = objCatRID.uniqueID) DO
         BEGIN                            { Found a son, container not empty}
         sonCatRID.fatherID := pCatRec^.parentID;
         sonCatRID.uniqueID := pCatRec^.selfID;
         IF trcFDocCtrl
         THEN WRITELN ('   son is ',pCatRec^.selfID:1,', size is ',pCatRec^.objSize:1);
         size := size + RecompFolderSize (hVol, sonCatRID);
         PosCatRec(err, hVol, sonCatRID, pCatRec); { Reposition to get next }
         IF err <= 0 THEN PosCatRec(err, hVol, posNext, pCatRec); { Get next son, if any }
         IF err <> endOfCat THEN CheckErr (806);
         END;

      IF err <> endOfCat THEN CheckErr (856);
      catRec.objSize := size;
      UpdCatRec (err, hVol, objCatRID, catRec);
      CheckErr (856);
      END;

  OTHERWISE BEGIN
      err := ORD(catRec.objKind);
      CheckErr (855);
      END;
  END;

99:
RecompFolderSize := size;
IF trcFDocCtrl THEN WRITELN('   exit RecompFolderSize: ',size:1);
END;


{**************************************************************************}
{$S flrOpen }
PROCEDURE RetDocName {docHdl: TentryHdl; VAR docName: E_Name};

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('RetDocName: docHdl = ',ORD(docHdl):1);

BuildDocName (docHdl^^.catRID.uniqueID, docHdl^^.toolID, docName);

IF trcFDocCtrl THEN WRITELN ('   exit RetDocName: ',docName:1);
END;


{**************************************************************************}

{$S flrOpen }
PROCEDURE RetDocPathname (docHdl: TentryHdl; VAR docPathname: Pathname);
VAR
    docName:   E_Name;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('RetDocPathname: docHdl = ',ORD(docHdl):1);

RetDocName (docHdl, docName);
docPathname := CONCAT ('-',docHdl^^.volHdl^^.devHdl^^.nameHdl^^,'-',
                       docName);

IF trcFDocCtrl THEN WRITELN ('   exit RetDocPathname: ',docPathname);
END;


{**************************************************************************}
{$S flrOpen }
PROCEDURE RetToolPathname {VAR error: INTEGER; toolID: TtoolID;
                           devHdl: TentryHdl; VAR toolPathName: Pathname};
VAR toolName:  E_Name;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFdocCtrl THEN WRITELN ('RetToolPathname: toolID = ',toolID,
                             ', devicename = ',devHdl^^.nameHdl^^);
BuildToolName (toolID,toolName);
toolPathname := CONCAT ('-',devHdl^^.nameHdl^^,'-',toolName);
error := 0;

IF trcFdocCtrl THEN WRITELN ('   exit RetToolPathname:', toolPathname);
END;


{**************************************************************************}
{$S flrCopy }
FUNCTION ShredDoc {hVol: TentryHdl; catRID: TcatRID) : BOOLEAN};
VAR
     catRec:       TcatRec;
     catName:      Pathname;
     dfName:       E_Name;
     dfPathname:   Pathname;
     docHdl:       TentryHdl;
     delDocName:   E_Name;
     err:          INTEGER;
     field:        TfieldVar;
     schedErr:     INTEGER;

  PROCEDURE CheckErr (location: INTEGER);
  VAR diskName:  FMaxStr;
      objName:   FMaxStr;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    GetObjName (hVol, catRID, objName);
    GetObjName (hVol, diskCatRID, diskName);
    ParamAlert (diskName, hVol^^.devHdl^^.userNmHdl^^, objName);
    StopAlert (flrAlert, 289);
    UpdateAll;
    EXIT (ShredDoc);
    END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ShredDoc');

  { Ignore if doc is open      }

ShredDoc := FALSE;
field.fieldType :=  dCatRID;
field.catRID := catRID;
GetEntry (doc, hVol, NIL, field, docHdl);
IF docHdl <> NIL THEN EXIT (ShredDoc);

  { Delete the diskfiles       }

GetCatRec (err, hVol, catRID, catRec);         { Need the doc name          }
CheckErr (839);
WITH catRec DO BuildDocName (selfID, toolID, delDocName);
catName := CONCAT ('-',hVol^^.devHdl^^.nameHdl^^);
Reset_Catalog (err, catName);                  { Scan the OS catalog        }
CheckErr (840);
Get_Next_Entry (err, delDocName, dfName);      { Get a doc diskfile name    }
IF trcFDocCtrl THEN IF err > 0 THEN WRITELN ('   no diskfiles');
WHILE err <= 0
DO BEGIN                                       { Destroy each doc diskfile  }
  dfPathname := CONCAT (catName, '-', dfName);
  IF trcFDocCtrl THEN WRITELN ('   deleting ',dfPathName);
  ZapPassword (dfPathname);
  Kill_Object (err, dfPathname);
  IF dbgFiler THEN IF err > 0 THEN WRITELN ('ERROR in ShredDoc doing Kill_Object: ',err:1);
  IF err <= 0 THEN Get_Next_Entry (err, delDocName, dfName);
  END;
IF err <> 848 THEN CheckErr (853);

  { Destroy the cat entry      }
DelCatRec (err, hVol, catRID);
CheckErr (841);

ShredDoc := TRUE;

IF trcFDocCtrl THEN WRITELN ('   exit ShredDoc');
END;


{**************************************************************************}

{$S flrCopy }
FUNCTION ShredFolder (hVol: TentryHdl; catRID: TcatRID) : BOOLEAN;
VAR devPathname:     Pathname;
    err:             INTEGER;
    folderDfName:    E_Name;
    folderPathname:  Pathname;
    folderPrefix:    E_Name;
    UIDstr:          NumberStr;

  PROCEDURE CheckErr (location: INTEGER);
  VAR diskName:  FMaxStr;
      objName:   FMaxStr;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    GetObjName (hVol, catRID, objName);
    GetObjName (hVol, diskCatRID, diskName);
    ParamAlert (diskName, hVol^^.devHdl^^.userNmHdl^^, objName);
    StopAlert (flrAlert, 289);
    UpdateAll;
    EXIT (ShredFolder);
    END;
  END;

BEGIN
IF trcFDocCtrl THEN WRITELN ('ShredFolder');

ShredFolder := FALSE;
IF hVol = NIL THEN EXIT(ShredFolder);
IF NOT ShredContents(hVol, catRID, TRUE, TRUE)
THEN EXIT (ShredFolder);


devPathname := CONCAT('-',hVol^^.devHdl^^.nameHdl^^);
Reset_Catalog (err, devPathname);
CheckErr (840);
IntToStr (catRID.uniqueID, UIDstr);
folderPrefix := CONCAT('{F',UIDstr,'}');
Get_Next_Entry (err, folderPrefix, folderDfName);
IF trcFDocCtrl THEN IF err > 0 THEN WRITELN ('   no diskfiles');
WHILE err <= 0
DO BEGIN                                       { Find each folder diskfile  }
  folderPathname := CONCAT (devPathname, '-', folderDfName);
  ZapPassword (folderPathname);
  Kill_Object (err, folderPathname);
  IF trcFDocCtrl THEN WRITELN ('   Killed ',folderPathname,', err is ',err:1);
  IF err <= 0 THEN Get_Next_Entry (err, folderPrefix, folderDfName);
  END;
IF err <> 848 THEN CheckErr (840);

DelCatRec (err, hVol, catRID);
CheckErr (840);
ShredFolder := TRUE;

IF trcFDocCtrl THEN WRITELN ('   exit ShredFolder');
END;


{**************************************************************************}

{$S flrCopy }

FUNCTION ShredTool (hVol: TentryHdl; catRID: TcatRID) : BOOLEAN;
VAR  catRec:       TcatRec;
     devPathname:  Pathname;
     dfInfo:       Q_Info;
     dfName:       E_Name;
     dfPathname:   Pathname;
     dfPrefix:     E_Name;
     err:          INTEGER;
     field:        TfieldVar;
     i:            INTEGER;
     schedErr:     INTEGER;
     toolName:     FMaxStr;
     toolNmPrefix: E_Name;
     toolNum:      E_Name;

   {---------------------------------------------------------------------------}

   PROCEDURE CheckErr (location: INTEGER);
   VAR diskName:  FMaxStr;
       objName:   FMaxStr;
   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
   IF err > 0
   THEN BEGIN
     GetObjName (hVol, catRID, objName);
     GetObjName (hVol, diskCatRID, diskName);
     ParamAlert (diskName, hVol^^.devHdl^^.userNmHdl^^, objName);
     StopAlert (flrAlert, 289);
     UpdateAll;
     EXIT (ShredTool);
     END;
   END;

{-------------------------------------------------------------------------------}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ShredTool');

ShredTool := FALSE;
CloseTool (hVol, catRID);                      { In case it is running      }
devPathname := CONCAT ('-',hVol^^.devHdl^^.nameHdl^^);
GetCatRec (err, hVol, catRID, catRec);         { Need the tool dfName prefix}
CheckErr (839);
WITH catRec DO BuildToolName (toolID, toolNmPrefix);

   { Delete the diskfiles       }
Reset_Catalog (err, devPathname);              { Scan the OS catalog        }
CheckErr (840);
toolNum := COPY (toolNmPrefix, 3, POS('}',toolNmPrefix)-2);
IF trcFDocCtrl THEN WRITELN ('   toolNum is ',toolNum);
dfPrefix := '{T';
Get_Next_Entry (err, dfPrefix, dfName);        { Get a tool diskfile name   }
IF trcFDocCtrl THEN IF err > 0 THEN WRITELN ('   no diskfiles');
WHILE err <= 0
DO BEGIN                                       { Find each tool diskfile    }
  IF POS(toolNum, dfName) = 3
  THEN BEGIN
    dfPathname := CONCAT (devPathname, '-', dfName);
    IF trcFDocCtrl THEN WRITELN ('   deleting ',dfPathName);
    ZapPassword (dfPathname);
    Kill_Object (err, dfPathname);             { Ignore errors              }
    END;
  Get_Next_Entry (err, dfPrefix, dfName);
  END;
IF err <> 848 THEN CheckErr (852);

DelCatRec (err, hVol, catRID);                 { Destroy the cat entry      }
CheckErr (841);

ShredTool := TRUE;

IF trcFDocCtrl THEN WRITELN ('   exit ShredTool');
END;

{**************************************************************************}

{$S flrOpen}

PROCEDURE ToolCantInit (theReason: FReason);

VAR field:   TFieldVar;
    msg:     Str255;
    msgPtr:  TPstr255;
    toolHdl: TentryHdl;
    toolName:FMaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ToolCantInit: procID = ',curEvent.fromProcess:1);

field.fieldType := tProcID;
field.procID := curEvent.fromProcess;
GetEntry (tool, NIL, NIL, field, toolHdl);
IF toolHdl = NIL
THEN BEGIN                                  { BulletProofing               }
  WMKillProcess (curEvent.fromProcess);
  IF dbgFiler THEN WRITELN ('   exit ToolCantInit - no entry for dying tool');
  EXIT (ToolCantInit);
  END;

msgPtr := @msg;
IF theReason = aUserAbort
THEN StopAlert (flrAlert, 255)
ELSE BEGIN
  CASE theReason OF
    noDiskSpace:   GetAlert (flrAlert, 415, msgPtr);
    noMemory:      GetAlert (flrAlert, 416, msgPtr);
    internalError: GetAlert (flrAlert, 417, msgPtr);
    OTHERWISE      msg := '';
    END;
  ParamAlert (toolHdl^^.nameHdl^^, msg, '');
  StopAlert (flrAlert, 248);
  END;
UpdateAll;
toolHdl^^.toolState := sIniting;

IF trcFDocCtrl THEN WRITELN ('   exit ToolCantInit');
END;


{**************************************************************************}

{$S flrOpen }

FUNCTION ToolOnDisk {volHdl: TentryHdl; toolNum: TtoolID; VAR toolCatRID: TcatRID)
                     : BOOLEAN};
VAR onDisk:  BOOLEAN;
    pCatRec: PtrCatRec;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ToolOnDisk: disk is ',volHdl^^.devHdl^^.userNmHdl^^,
                             ', tool is ',ORD(toolNum):1);

IF ObjInCat (volHdl, '', toolSet, toolNum, pCatRec)
THEN WITH pCatRec^ DO BEGIN
  IF trcFDocCtrl THEN WRITELN ('   tool found');
  toolCatRID.fatherID := parentID;
  toolCatRID.uniqueID := selfID;
  onDisk := TRUE;
  END
ELSE onDisk := FALSE;
ToolOnDisk := onDisk;

IF trcFDocCtrl THEN WRITELN ('   exit ToolOnDisk: ',onDisk);
END;

{**************************************************************************}

{$S flrDm1 }

FUNCTION ToolSize {hVol: TentryHdl; toolID: TtoolId; devInfoPtr: TFsInfoPtr;
                   VAR dtm, dtc: LONGINT) : LONGINT};

VAR intStr:     NumberStr;
    size:       LONGINT;
    toolName:   E_Name;
    writers:    BOOLEAN;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ToolSize: tool ',toolId:1, ' on ',hVol^^.nameHdl^^);

IntToStr (toolID, intStr);
toolName := CONCAT('{T',intStr,'}');
DfSize (hVol^^.devHdl, toolName, devInfoPtr, size, writers, dtm, dtc);
ToolSize := size;
dtc := dtm;                             { Tools are only 'created'... }
dtm := nullInt4;                        { ... never 'modified'        }

IF trcFDocCtrl THEN WRITELN ('   exit ToolSize: size = ',size:1);
END;


{**************************************************************************}

{$S flrDebug }

PROCEDURE WMStatus;
VAR evHdl:       EventHandle;
    folderName:  Str255;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
{$IFC flrDebug }

WRITELN;
WRITELN ('                       Window Manager Status');
WRITELN;

  { print the interesting global vars }
IF activeFolder = Nil
THEN folderName := ''
ELSE GetFldrTitle (activeFolder, folderName);
WRITELN ('   activeProcess: ',activeProcess:2,', activeFolder: ',ORD(activeFolder):8,'  ',folderName);
IF keyWindow = Nil
THEN folderName := ''
ELSE GetFldrTitle (keyWindow, folderName);
WRITELN ('   keyProcess:    ',keyProcess:2,   ', keyWindow:    ',ORD(keyWindow):8,'  ',folderName);
WRITELN ('   filerProcess:  ',filerProcess:2, ', filerFolder:  ',ORD(filerFolder):8,
           ',  queueLocked = ',queueLocked);

  { print the window manager queue }
evHdl := FirstEvent;
IF evHdl = Nil
THEN WRITELN ('   The Window Manager queue is empty')
ELSE BEGIN
  WRITELN ('     The Window Manager Queue');
  WRITELN ('   Kind  From          To');
  REPEAT
    GetFldrTitle (evHdl^^.who, folderName);
    WITH evHdl^^ DO WRITELN (what:6,fromProcess:6,ORD(fromFolder):10,toProcess:4,ORD(who):10,
                             '  ',folderName);
    evHdl := NextEvent (evHdl);
    UNTIL evHdl = NIL;
    END;

{$ENDC }
END;

{**************************************************************************}
{                        External Procedures                               }
{**************************************************************************}

{$S flrDm }

PROCEDURE BindCopyDataSeg;
LABEL 33;
VAR copyDsName:   Pathname;
    newDiskSize:  LONGINT;
    osErr:        INTEGER;

{------ NOTE: The data segment may not be bound if an error is encountered ---}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('BindCopyDataSeg: bind depth is ',copyDsBound:1);

copyDsBound := copyDsBound + 1;

IF copyDsBound = 1
THEN BEGIN
  copyDsName := 'dmTemp';
  copyDsMemSize := copyDsSize;
33:
  Make_DataSeg (osErr, copyDsName, copyDsSize, 0, copyDsRefnum,
                copyDsAddr, dfCopyLDSN, ds_Private);
  IF dbgFiler THEN IF osErr > 0 THEN WRITELN ('   Make_Dataseg osErr: ',osErr:1);
  CASE osErr OF
    0:   ;
    304: copyDsBound := copyDsBound + 1;  { opps, dataseg already exists }
    306,
    311,
    315: BEGIN
         copyDsMemSize := copyDsMemSize - 1024;
         IF copyDsMemSize > 0 THEN GOTO 33;
         END;

    OTHERWISE IF ErrorFound (warnError, 850, osErr, NIL) THEN;
    END;
  IF osErr <> 304 THEN IF ErrorFound (warnError, 851, osErr, NIL) THEN;
  IF trcFDocCtrl THEN WRITELN ('   copy data seg bound');
  END
ELSE IF trcFDocCtrl THEN WRITELN ('   copy data seg already bound');

IF trcFDocCtrl THEN WRITELN ('   exit BindCopyDataSeg: copyDsMemSize set to ',
                             copyDsMemSize:1);
END;


{**************************************************************************}

{$S flrOpen }

PROCEDURE BuildDocName {docID: IdType; toolID: TtoolID; VAR docName: E_Name};
VAR
    docStr:  NumberStr;
    toolStr: NumberStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFdocCtrl THEN WRITELN ('BuildDocName: docId = ', docID:1,
                             ', toolID = ',toolID:1);
IntToStr (docID, docStr);
IntToStr (toolID, toolStr);
docName := CONCAT ('{D',docStr,'T',toolStr,'}');

IF trcFdocCtrl THEN WRITELN ('   exit BuildDocName: ',docName);
END;


{**************************************************************************}

{$S flrClose }

PROCEDURE CloseDoc {VAR err: INTEGER; hVol: TentryHdl; catRID: TcatRID;
                    normal, forSure: BOOLEAN};
VAR
     docHdl:    TentryHdl;
     field:     TfieldVar;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('CloseDoc: doc ',catRID.uniqueID:1);

err := fNoErr;

field.fieldType := dCatRID;
field.catRID := catRID;
GetEntry (doc, hVol, NIL, field, docHdl);

IF docHdl <> NIL                { If not found, then its already closed    }
THEN KillDoc (err, docHdl, normal, TRUE, forSure);

IF trcFDocCtrl THEN WRITELN ('   exit CloseDoc: err = ',err:1);
END;


{**************************************************************************}

{$S flrCat }

PROCEDURE CloseTool {volHdl: TentryHdl; catRID: TcatRID};

VAR field:   TfieldVar;
    toolHdl: TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('CloseTool: tool catRID',catRID.uniqueID:1,
                             ' on vol ',volHdl^^.devHdl^^.userNmHdl^^);

field.fieldType := tToolCatRID;
field.toolCatRID := catRID;
GetEntry (tool, volHdl, NIL, field, toolHdl);
IF toolHdl <> NIL THEN KillTool (toolHdl);

IF trcFDocCtrl THEN WRITELN ('   exit CloseTool');
END;

{**************************************************************************}
{$S flrCopy }
FUNCTION DeflowerMasterTool {toolID: INTEGER; devHdl: TentryHdl) : BOOLEAN};
VAR catRec:       TcatRec;
    devPathname:  Pathname;
    err:          INTEGER;
    machineNum:   LONGINT;
    schedErr:     INTEGER;
    toolDfName:   E_Name;
    toolName:     E_Name;
    toolPathname: Pathname;
    userToolName: FMaxStr;

  PROCEDURE CheckErr (location: INTEGER);
  VAR diskName:  FMaxStr;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF ErrorFound (warnError, location, err, devHdl) THEN ;
    GetObjName (devHdl^^.volHdl, diskCatRID, diskName);
    ParamAlert (diskName, devHdl^^.userNmHdl^^, userToolName);
    StopAlert (flrAlert, 289);
    UpdateAll;
    DeflowerMasterTool := FALSE;
    EXIT (DeflowerMasterTool);
    END;
  END;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('DeflowerMasterTool: ',toolID:1,
                             ' on ',devHdl^^.nameHdl^^);

DeflowerMasterTool := FALSE;
GetToolName (err, toolID, devHdl, userToolName);
ParamAlert (userToolName,'','');
IF AskAlert (flrAlert, 246) = 2             { 'First copy of <tool>...'    }
THEN BEGIN
  UpdateAll;
  devPathname := CONCAT('-',devHdl^^.nameHdl^^);
  BuildToolName (toolID, toolName);
  Reset_Catalog (err, devPathname);
  CheckErr (878);
  Get_Serial_No (err, machineNum);
  Get_Next_Entry (err, toolName, toolDfName);
  WHILE err <= 0
  DO BEGIN                                  { Protect each diskfile        }
    toolPathname := CONCAT (devPathname,'-',toolDfName);
    DownShift (@toolDfName);
    IF POS('obj', toolDfName) <> 0          { Only obj diskfiles are protected }
    THEN BEGIN
      IF trcFDocCtrl THEN WRITELN ('   protecting ',toolPathname,' machine ID is ',
                                   machineNum);
      Protect (err, toolPathname, TRUE, machineNum);
      END;
    Get_Next_Entry (err, toolName, toolDfName);
    END;
  IF err <> 848 THEN CheckErr (882);
  DeflowerMasterTool := TRUE;
  END;
UpdateAll;

IF trcFDocCtrl THEN WRITELN ('   exit DeflowerMasterTool');
END;


{*************************************************************************}

{$S flrAll }

PROCEDURE DummyDisplay {wPtr: WindowPtr};
LABEL 99;
VAR alertNum: INTEGER;
    curPt:    Point;
    docHdl:   TentryHdl;
    docRect:  Rect;
    err:      INTEGER;
    field:    TfieldVar;
    infoProc: ProcInfoRec;
    retryMsg: BOOLEAN;
    volName:  FMaxStr;
    toolName: FMaxStr;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('DummyDisplay');

IF wPtr <> scrapFolder
THEN BEGIN
  field.fieldType := dFWindow;                    { Get the toolname          }
  field.fWindow := wPtr;
  GetEntry (doc, NIL, NIL, field, docHdl);
  IF docHdl = NIL THEN EXIT (DummyDisplay);       { No doc entry for the window}
  IF docHdl^^.state IN [closing, closingFolder]
  THEN EXIT (DummyDisplay);
  GetToolName (err, docHdl^^.toolID, NIL, toolName);
  END
ELSE GetToolName (err, scrapTool, NIL, toolName);

EndUpdate (wPtr);                { So that we can rewrite the whole window    }
SetPort (wPtr);
SetOrigin(0,0);
TextFont (sysText);                               { Non-editable system font  }
TextFace ([]);
ClipScrollBars(wPtr,TRUE);
EraseRect (wPtr^.portRect);                       { Erase all content         }

retryMsg := FALSE;
ArgAlert (1, toolName);
IF wPtr = scrapFolder
THEN BEGIN
  IF scrapTool = 0 THEN GOTO 99;
  alertNum := 439;
  END
ELSE BEGIN
  retryMsg := TRUE;
  CASE docHdl^^.state OF
    blank:   BEGIN
             alertNum := 430;
             retryMsg := FALSE;
             END;
    badTool: alertNum := 432;
    deadDoc: alertNum := 436;
    docReqd: BEGIN
             alertNum := 437;
             retryMsg := FALSE;
             END;
    mustAlter: alertNum := 445;
    noDisk:  BEGIN
             GetObjName (docHdl^^.volHdl, diskCatRID, volName);
             ArgAlert (2, volName);
             alertNum := 431;
             END;
    noTool:  BEGIN
             alertNum := 433;
             retryMsg := FALSE;
             END;
    noToolDisk: alertNum := 443;
    opened,
    toolOpened: WITH docHdl^^ DO BEGIN     { Tool crashed w/o telling us }
             IF toolHdl <> NIL             { Cleanup tool stuff }
             THEN BEGIN
               Info_Process (err, toolHdl^^.procID, infoProc);
               IF err = 100                { Process is dead             }
               THEN BEGIN
                 curEvent.fromProcess := toolHdl^^.procID;  { Setup for FinishTerm... }
                 FinishTerminating;
                 END;
               END;
             alertNum := 434;
             END;
    protectedTool: alertNum := 441;
    toolCrashed: alertNum := 434;
    tooBusy: alertNum := 435;
    tooNew:  alertNum := 442;
    tooOld:  alertNum := 444;
    END;
  END;

WITH wPtr^.portRect DO BEGIN
  docRect.left := left+15;
  docRect.right := MAX (right-30, 350);
  docRect.top := top+10;
  docRect.bottom := bottom;
  END;
DrawAlert (flrAlert, alertNum, docRect);

IF retryMsg
THEN BEGIN
  GetPen (curPt);
  docRect.top := curPt.v + 10;
  IF docRect.top < docRect.bottom THEN DrawAlert (flrAlert, 438, docRect);
  END;

99:
ValidRect (wPtr^.portRect);      { In case there are any Update events pending }

IF trcFDocCtrl THEN WRITELN ('   exit DummyDisplay');
END;


{**************************************************************************}

{$S flrClose }

PROCEDURE FinishTerminating;
LABEL  99;
VAR err:        INTEGER;     {*** for OS workaround ***}
    chnInfo:    T_Chn_Sts;
    chnRefNum:  INTEGER;     {*** ditto ***}
    field:      TfieldVar;
    toolHdl:    TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('FinishTerminating: process is ',curEvent.fromProcess);

IF curEvent.fromProcess <> printProcess
THEN BEGIN
  field.fieldType := tProcID;             { Ignore multiple/extraneous 'ImDying' calls }
  field.procID := curEvent.fromProcess;
  GetEntry (tool, NIL, NIL, field, toolHdl);
  IF toolHdl = NIL THEN EXIT (FinishTerminating);
  END;

IF trcFDocCtrl THEN WRITELN ('waiting for son terminated event');
REPEAT
  Wait_Event_Chn (err, waitList, chnRefNum, @eventBlk); {*** O/S bug workaround ***}
  IF ErrorFound (fatalError, 826, err, NIL) THEN;
  SonTerminated;      {*** workaround - also see FVolCtrl ***}
  Info_Event_Chn (err, chnRefNum, chnInfo);
  IF ErrorFound (fatalError, 843, err, NIL) THEN;
  UNTIL chnInfo.num_Events = 0;

99:
IF trcFDocCtrl THEN WRITELN ('   exit FinishTerminating');
END;


{**************************************************************************}

{$S flrMisc }
FUNCTION  FitOnDisk{size: LONGINT; devHdl: TentryHdl): BOOLEAN};
{ checks if the object could fit on the volume if it were empty }
VAR devInfo: Fs_Info;
    devPathname: Pathname;
    emptySize: LONGINT;
    err: INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN('FitOnDisk: size is ',size:1,', device is ',devHdl^^.nameHdl^^);
FitOnDisk := FALSE;

{ how much free space is there on an empty volume? }
devPathname := CONCAT('-',devHdl^^.nameHdl^^);
LookUp (err,devPathname,devInfo);
IF err > 0 THEN
   BEGIN
   IF trcFDocCtrl THEN WRITELN('   exit FitonDisk: error looking up pathname ',devPathname,': ',err:1);
   EXIT(FitOnDisk);
   END;
WITH devInfo DO emptySize := fs_Size - fs_Overhead - catOverhead - sizeSpace;

IF size < emptySize THEN FitOnDisk := TRUE;

IF trcFDocCtrl THEN WRITELN('   exit FitOnDisk: empty size is ',emptySize:1);
END;


{**************************************************************************}

{$S  }

PROCEDURE InitDocCtrl;

VAR copyDsInfoRec: DsInfoRec;
    copyDsName:    Pathname;
    curTime:       Time_Rec;
    err:           INTEGER;
    eventChnName:  Pathname;
    excepName:     T_Ex_Name;
    myProcInfo:    ProcInfoRec;
    newDiskSize:   LONGINT;
    thruDash:      INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('InitDocCtrl');
blankStr := '';
copyDsBound := 0;
toolSet :=      [toolKind, computerKind, comp2Kind, calcKind, clockKind];
containerSet := [diskKind,disk1Kind,disk2Kind,profileKind,drawerKind,folderKind,
                 inbox1Kind,inbox2Kind,outbox1Kind,outbox2Kind,letterKind];
resumable :=    [noTool, tooBusy, tooNew, tooOld, mustAlter, badTool, protectedTool, toolCrashed];
                                                 { User fixable states           }

IF trcFDocCtrl THEN WRITELN('   Opening SYS_SON_TERM event channel ...');
eventChnName := '';                       { Setup the son term excep hdlr    }
excepName := '';                          {*** OS bug workaround ***}
Open_Event_Chn (err, eventChnName, termEventRefnum, excepName, TRUE);
IF ErrorFound (fatalError, 827, err, NIL) THEN;
waitlist.length := 1;                    {*** more workaround ***}
waitList.refnum[0] := termEventRefnum;   {*** more workaround ***}
IF trcFDocCtrl THEN WRITELN ('   event chn opened: termEventRefNum = ',
                             termEventRefNum);

IF trcFDocCtrl THEN WRITE ('   looking up the system intrinsics: ');
Info_Process (err, My_ID, myProcInfo);
IF err <= 0 THEN List_LibFiles (err, myProcInfo.progPathname, systemIntrinsics);
IF ErrorFound (fatalError, 894, err, NIL) THEN;
REPEAT
  thruDash := POS ('-', myProcInfo.progPathname);
  IF thruDash > 0 THEN DELETE (myProcInfo.progPathname, 1, thruDash);
  UNTIL thruDash = 0;
shellDfName := myProcInfo.progPathname;

IF trcFDocCtrl THEN WRITELN ('   exit InitDocCtrl');
END;


{**************************************************************************}

{$S flrCat }

PROCEDURE KillDoc {VAR err: INTEGER; docHdl: TentryHdl; normal: BOOLEAN;
                   windowGone, forSure: BOOLEAN};
VAR fcOp:       FilerOp;
    reply:      FReason;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('KillDoc: ',docHdl^^.NameHdl^^,
                             ' docHdl = ',ORD(docHdl));

err := fNoErr;

IF ((docHdl^^.state = closing) OR (docHdl^^.state = closingFolder))
THEN EXIT (KillDoc);                                      { Doc is already being closed   }

IF (docHdl^^.state IN [opened, toolOpened])
AND (docHdl^^.toolHdl <> NIL)                             { bullet proofing }
THEN BEGIN
  WITH docHdl^^ DO BEGIN                                  { Tell tool to close doc        }
    IF trcFDocCtrl THEN WRITELN ('   closing the doc');
    IF forSure
    THEN BEGIN
      fcOp := fcShred;
      state := closingFolder;
      END
    ELSE BEGIN
      IF normal
      THEN fcOp := fcClose
      ELSE fcOp := fcSuspend;
      IF windowGone
      THEN state := closingFolder
      ELSE state := closing;
      END;
    SendFilerEvent (err, toolHdl^^.procID, fWindow, fcOp, '', 0, '', '', reply);
    END;
  IF (err > 0) AND forSure AND (docHdl^^.toolHdl <> NIL)
  THEN BEGIN
    IF dbgFiler THEN WRITELN ('ERROR in KillDoc: tool ',docHdl^^.toolHdl^^.nameHdl^^,
                              ' refused an fcShred. Err is ',err:1);
    docHdl^^.state := closingFolder;
    SendFilerEvent (err, docHdl^^.toolHdl^^.procID, docHdl^^.fWindow,
                    fcTerminate, '', 0, '', '', reply);
    IF dbgFiler THEN IF err <> 0
    THEN WRITELN ('ERROR in KillDoc: tool ',docHdl^^.toolHdl^^.nameHdl^^,
                  ' refused to terminate. Err is ', err:1);
    err := 0;
    END;
  IF (reply <> allOk) AND (docHdl^^.toolHdl <> NIL) THEN err := fNotClosed;
  END

ELSE IF windowGone                        { Doc not open by a tool        }
  THEN KillEntry (docHdl);           { Window was destroyed          }

IF trcFDocCtrl THEN WRITELN ('   exit KillDoc');
END;


{**************************************************************************}

{$S flrCat }

FUNCTION KillExtraProcs {volHdl: TentryHdl) : BOOLEAN};

VAR nextToolHdl: TentryHdl;
    toolHdl:     TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('   KillExtraProcs: volHdl = ',ORD(volHdl):1);

KillExtraProcs := FALSE;
GetEntry (tool, volHdl, NIL, nilField, toolHdl);
WHILE toolHdl <> NIL DO BEGIN
  IF Abort
  THEN BEGIN
    IF trcFDocCtrl THEN WRITELN ('   exit KillExtraProcs: user aborted');
    EXIT (KillExtraProcs);
    END;
{$IFC flrDebug }
  IF trcFDocCtrl THEN PrintEntry (tool, toolHdl);
{$ENDC }
  GetEntry (tool, volHdl, toolHdl, nilField, nextToolHdl);
  IF toolHdl^^.docsOpen = 0
  THEN BEGIN
    KillTool (toolHdl);
    KillExtraProcs := TRUE;
    END;
  toolHdl := nextToolHdl;
  END;

IF trcFDocCtrl THEN WRITELN ('   exit KillExtraProcs');
END;


{*************************************************************************}

{$S flrDm1 }

PROCEDURE MakeFolder {VAR err: INTEGER; fVol: TentryHdl; fCatRID: TcatRID;
                      sVol: TentryHdl; sCatRID: TcatRID};
LABEL 99;
VAR catRec:         TcatRec;
    dDfPathname:    Pathname;
    dFolderDfName:  E_Name;
    dfRefnum:       INTEGER;
    fsInfo:         FS_Info;
    fsParms:        Ut_Parmt;
    labelRec:       LabelFmt;
    sDfPathname:    Pathname;
    sFolderDfName:  E_Name;
    UIDstr:         NumberStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('MakeFolder: ',fCatRID.uniqueID:1,' on ',fVol^^.devHdl^^.nameHdl^^);

  { Build the folder diskfile name}
IntToStr (fCatRID.uniqueID, UIDstr);
dFolderDfName := CONCAT('{F',UIDstr,'}');
dDfPathname := CONCAT('-',fVol^^.devHdl^^.nameHdl^^,'-',dFolderDfName);

IF trcFDocCtrl THEN WRITELN ('   making ',dDfPathname);
Make_File (err, dDfPathname, SIZEOF(labelRec));
IF err > 0 THEN GOTO 99;

  { make the label }
LabelDefault (labelRec);
GetCatRec(err, fVol, fCatRID, catRec);
ExtObjName (catRec, labelRec.name);
WITH labelRec DO BEGIN
  kind     := catRec.objKind;
  parentID := catRec.parentID;
  windLoc  := catRec.openRect;
  END;
IF LabelIO(TRUE, fVol^^.devHdl^^.nameHdl^^, 0, fCatRID.uniqueID, labelRec) THEN;

  { set the date/time created/modifed }
Open (err, dDfPathname, dfRefnum, [dRead]);
IF err <= 0
THEN BEGIN
  Lookup (err, dDfPathname, fsInfo);
  fsInfo.dtm := catRec.modified;
  fsInfo.dtc := catRec.created;
  PSet_File_Info (err, dfRefnum, fsInfo);
  Close_Object (err, dfRefnum);
  END;

  { copy the password, if any }
IF sVol <> NIL
THEN WITH fsParms DO BEGIN
  IntToStr (sCatRID.uniqueID, UIDstr);
  sFolderDfName := CONCAT('{F',UIDstr,'}');
  sDfPathname := CONCAT('-',sVol^^.devHdl^^.nameHdl^^,'-',sFolderDfName);
  gp_parm := 0;
  command := xfer_Passwd;
  path    := sDfPathname;
  op      := pswRead;
  FS_Utilities (err, fsParms);
  IF err <= 0 THEN
    BEGIN
    path  := dDfPathname;
    op    := pswWrite;
    FS_Utilities (err, fsParms);
    END;
  err := 0;
  END;

99:
IF trcFDocCtrl THEN WRITELN ('   exit MakeFolder: err = ',err:1);
END;


{**************************************************************************}

{$S flrDm1 }

FUNCTION ObjectSize { hVol: TentryHdl; objCatRID: TcatRID; devInfoPtr: TFsInfoPtr;
                   excludeUnfiled: BOOLEAN; VAR dtm, dtc: LONGINT) : LONGINT };
LABEL 99;
VAR err:        INTEGER;
    deviceName: Pathname;
    devInfo:    Fs_Info;
    pCatRec:    PtrCatRec;
    size:       LONGINT;

  PROCEDURE CheckErr (location: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF ErrorFound (warnError, location, err, hVol^^.devHdl) THEN;
    ObjectSize := 0;
    dtm := nullint4;
    dtc := nullint4;
    IF trcFDocCtrl THEN WRITELN ('   exit ObjectSize: err = ',err:1);
    EXIT (ObjectSize);
    END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN('ObjectSize - parent: ',objCatRID.fatherID:1,
                                            ' id: ',objCatRID.uniqueID:1);

IF objCatRID.uniqueID = idDisk THEN GOTO 99;

IF devInfoPtr = NIL
THEN BEGIN
  deviceName := CONCAT('-',hVol^^.devHdl^^.nameHdl^^);
  Lookup (err, deviceName, devInfo);
  devInfoPtr := @devInfo;
  END;

PosCatRec(err, hVol, objCatRID, pCatRec);     { Get obj catRec             }
CheckErr (803);
CASE pCatRec^.objKind OF
  docKind,                                    { The object is a document   }
  docPad:
      DocSize (hVol, objCatRID, devInfoPtr, size, dtm, dtc);

  calcKind,
  clockKind,
  computerKind,
  comp2Kind,
  printKind,
  toolKind:                                   { The object is a tool       }
      size := ToolSize (hVol, pCatRec^.toolID, devInfoPtr, dtm, dtc);

  trashKind,                                  { The object is a container  }
  inBox1Kind,
  inbox2Kind,
  outBox1Kind,
  outBox2Kind,
  letterKind,
  letterPad,
  folderPad,                                  { It can contain docs        }
  folderKind: BEGIN
      size := 0;
      dtm := nullInt4;
      dtc := nullInt4;

      { position to first record of contents }
      posApprox.fatherID := objCatRID.uniqueID;
      PosCatRec(err, hVol, posApprox, pCatRec);
      WHILE (err <= 0) AND (pCatRec^.parentID = objCatRID.uniqueID) DO
         BEGIN                            { Found a son, container not empty}
         IF trcFDocCtrl
         THEN WRITELN ('   son is ',pCatRec^.selfID:1,', size is ',pCatRec^.objSize:1);
         WITH pCatRec^ DO BEGIN
           size := size + objSize;
           IF created > dtc THEN dtc := created;
           IF modified > dtm THEN dtm := modified;
           END;
         PosCatRec(err,hVol, posNext, pCatRec);   { Get next son, if any }
         IF err <> endOfCat THEN CheckErr (806);
         END;
      IF err <> endOfCat THEN CheckErr (856);
      END;

  OTHERWISE BEGIN
      err := ORD(pCatRec^.objKind);
      CheckErr (855);
      END;
  END;

ObjectSize := size;

99:
IF trcFDocCtrl THEN WRITELN('   exit ObjectSize: ',size:1);
END;


{**************************************************************************}

{$S flrOpen }

FUNCTION ObjInTrash {volHdl: TentryHdl; catRID: TcatRID) : BOOLEAN};

VAR  pCatRec:  PtrCatRec;
     err:      INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ObjInTrash');

REPEAT
  PosCatRec (err, volHdl, catRID, pCatRec);
  catRID.fatherID := idNil;
  catRID.uniqueID := pCatRec^.parentID;
  UNTIL (err > 0)
     OR (pCatRec^.parentID = idDisk)
     OR (pCatRec^.parentID = idTrash);

ObjInTrash := FALSE;
IF (err <> endOfCat)          { Preferences doesn't have a catalog entry }
THEN IF (NOT ErrorFound (warnError, 832, err, volHdl^^.devHdl))
THEN IF pCatRec^.parentID <> idDisk THEN ObjInTrash := TRUE;

IF trcFDocCtrl THEN WRITELN ('   ObjInTrash: ',pCatRec^.parentID=idTrash);
END;


{**************************************************************************}

{$S flrOpen }

PROCEDURE OpenDoc {hVol: TentryHdl; catRID: TcatRID; window: WindowPtr;
                   VAR docHdl: TentryHdl; password: E_Name; startTool: BOOLEAN};
VAR
     catRec:       TcatRec;              { Catalog entry for document   }
     err:          INTEGER;
     field:        TfieldVar;
     thePrefix:    Pathname;
     docName:      FmaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('OpenDoc');

GetCatRec (err, hVol, catRID, catRec);
IF err > 0 THEN EXIT (OpenDoc);        { Doc may have been deleted     }
ExtObjName(catRec,docName);
CreateEntry (doc, @docName, docHdl);    { To hold the open doc info     }
IF docHdl = NIL
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   exit OpenDoc: doc entry not created');
  EXIT (OpenDoc);
  END;

WITH docHdl^^
DO BEGIN
  volHdl := hVol;
  toolID := catRec.toolID;
  fWindow := window;
  docPassword := password;
  END;
docHdl^^.catRID := catRID;

IF startTool
THEN StartDoc (docHdl, FALSE)
ELSE DummyDisplay (docHdl^^.fWindow);

IF trcFDocCtrl THEN WRITELN ('   exit OpenDoc');
END;


{**************************************************************************}

{$S flrCopy }

PROCEDURE PutDocIn {VAR err: INTEGER; sVol: TentryHdl; sCatRID: TcatRID;
                    dVol: TentryHdl; dParent: IDType; VAR newCatRID: TcatRID};

VAR catErr:      INTEGER;
    catRec:      TcatRec;
    dDfName:     E_Name;
    dDfPathname: Pathname;
    docHdl:      TentryHdl;
    docgone:     BOOLEAN;
    dtc:         LONGINT;
    field:       TfieldVar;
    reply:       FReason;

  PROCEDURE CheckErr (location: INTEGER; volHdl: TentryHdl);
  VAR devHdl:  TentryHdl;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF volHdl = NIL
    THEN devHdl := NIL
    ELSE devHdl := volHdl^^.devHdl;
    IF ErrorFound (askError, location, err, devHdl) THEN;
    IF trcFDocCtrl THEN WRITELN ('   exit PutDocIn: transfer aborted, err = ',err:1);
    err := aborted;
    EXIT (PutDocIn);
    END;
  END;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('PutDocIn: ',sCatRID.uniqueID,' to ',dParent:1,
                             ', ',dVol^^.nameHdl^^);

field.fieldType := dCatRID;
field.catRID := sCatRID;
GetEntry (doc, sVol, NIL, field, docHdl);
err := aborted;
IF docHdl = NIL THEN EXIT (PutDocIn);
IF docHdl^^.state IN [closingFolder,closing]
THEN IF ErrorFound (warnError, 870, ORD(docHdl^^.state), NIL) THEN EXIT (PutDocIn);

IF docHdl^^.state <> opened
THEN XferObject (err, sCatRID, dParent, sVol, dVol, TRUE, TRUE, FALSE,FALSE, 0, newCatRID,docgone)

ELSE BEGIN
    {Create the destination catRec}
  GetCatRec (err, docHdl^^.volHdl, docHdl^^.catRID, catRec);
  CheckErr (865, docHdl^^.volHdl);
  catRec.parentID := dParent;
  AddCatRec (err, dVol, catRec, TRUE, newCatRID);
  CheckErr (807, dVol);
  FlushCat (dVol);

    {Tell tool to put doc in ... }
  BuildDocName (newCatRID.uniqueID, catRec.toolID, dDfName);
  dDfPathname := CONCAT('-',dVol^^.devHdl^^.nameHdl^^,'-',dDfName);
  docHdl^^.state := closingFolder;
  SendFilerEvent (err, docHdl^^.toolHdl^^.procID, docHdl^^.fWindow, fcPut,
                  dDfPathname, 0, '', '', reply);
  IF err > 0
  THEN IF ShredDoc (dVol, newCatRID) THEN ELSE
  ELSE BEGIN
    GetCatRec (catErr, dVol, newCatRID, catRec);
    IF catErr <= 0
    THEN BEGIN
      DocSize (dVol, newCatRID, NIL, catRec.objSize, catRec.modified, dtc);
      UpdCatRec (catErr, dVol, newCatRID, catRec);
      END;
    IF catErr <= 0 THEN AdjustParentObjSize (dVol, catRec.parentID, TRUE);
    IF ErrorFound (warnError, 877, catErr, dVol^^.devHdl) THEN;
    END;
  END;

IF trcFDocCtrl THEN WRITELN ('   exit PutDocIn: err = ',err:1,' reply = ',ORD(reply):1);
END;


{*************************************************************************}

{$S flrCat }

FUNCTION ReclaimDiskSpace {volHdl: TentryHdl; blocksNeeded: INTEGER) : INTEGER};
LABEL 99;
VAR blocksFreed: LONGINT;
    err:         INTEGER;
    devName:     E_Name;
    devPathname: Pathname;
    fsInfo:      Fs_Info;
    pCatRec:     PtrCatRec;
    spaceStart:  LONGINT;

  PROCEDURE CheckErr (location: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF ErrorFound (warnError, location, err, volHdl^^.devHdl) THEN;
    IF trcFDocCtrl THEN WRITELN ('   exit ReclaimDiskSpace: err = ',err:1);
    EXIT (ReclaimDiskSpace);
    END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ReclaimDiskSpace: blocks needed: ',blocksNeeded:1,
                             ', device: ',volHdl^^.devHdl^^.userNmHdl^^);

blocksFreed := 0;
devName := volHdl^^.devHdl^^.nameHdl^^;
devPathname := CONCAT('-',devName);
Lookup (err, devPathname, fsInfo);
CheckErr (845);
spaceStart := fsInfo.freeCount;
IF trcFDocCtrl THEN WRITELN ('   free blocks at start: ',spaceStart:1);

IF KillExtraProcs (volHdl)   { Free any space used by idle processes   }
THEN BEGIN
  Lookup (err, devPathname, fsInfo);
  CheckErr (845);
  blocksFreed := fsInfo.freeCount - spaceStart;
  IF trcFDocCtrl THEN WRITELN ('   blocks freed by procs: ',blocksFreed:1);
  IF blocksNeeded > 0 THEN IF blocksFreed > blocksNeeded THEN GOTO 99;
  END;

IF Abort THEN GOTO 99;

PosCatRec (err, volHdl, trashCatRID, pCatRec);
CheckErr (846);
IF (pCatRec^.objSize = 0)                            { Wastebasket is empty  }
OR ((pCatRec^.objSize + blocksFreed) < blocksNeeded) { Wastebasket too small }
THEN GOTO 99;

IF Abort THEN GOTO 99;

IF EmptyTrash (volHdl, TRUE, TRUE) THEN;
Lookup (err, devPathname, fsInfo);
CheckErr (845);
blocksFreed := fsInfo.freeCount - spaceStart;
EndWaitAlert;

99:
ReclaimDiskSpace := blocksFreed;

IF trcFDocCtrl THEN WRITELN ('   exit ReclaimDiskSpace: blocks freed: ',blocksFreed:1);
END;


{**************************************************************************}

{$S flrOpen }

PROCEDURE ResumeDocs {wPtr: WindowPtr};

VAR  docHdl:     TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ResumeDocs: wPtr = ',ORD(wPtr):1);

IF bootVol^^.volState IN [sDismounting, sEjecting]
THEN BEGIN                                  { Don't start anything         }
  IF trcFDocCtrl THEN WRITELN ('   exit ResumeDocs: power down in progress');
  EXIT (ResumeDocs);
  END;

IF wPtr <> NIL
THEN BEGIN                                     { Resume a single window       }
   docHdl := WindowToDocEntry (wPtr);
   IF docHdl <> NIL
   THEN IF docHdl^^.state IN resumable THEN StartDoc (docHdl, TRUE);
   END

ELSE BEGIN                                     { Resume all windows           }
   GetEntry (doc, NIL, NIL, nilField, docHdl); { check each doc for restart   }
   WHILE docHdl <> NIL
   DO BEGIN
      IF docHdl^^.state IN resumable THEN StartDoc (docHdl, TRUE);
      GetEntry (doc, NIL, docHdl, nilField, docHdl); { Check next doc         }
      END;
   END;

IF trcFDocCtrl THEN WRITELN ('   exit ResumeDocs');
END;

{**************************************************************************}

{$S flrOpen }

PROCEDURE SendFilerEvent {err: INTEGER; proc: processID; folder: WindowPtr;
                          what: FilerOp; docName: Pathname; dfRefnum: INTEGER;
                          sourceName: Pathname; password: E_Name; VAR reply: FReason};
LABEL  99;
VAR chnRefNum : INTEGER;
    docHdl:     TentryHdl;
    field:      TfieldVar;
    gotReply:   BOOLEAN;
    parmsHdl:   hFilerExt;
    procRec:    ProcInfoRec;
    saveHeap:   THz;
    theEvent:   EventRecord;
    udPtr:      ReplyPtr;

  PROCEDURE ProcessDied;
  BEGIN                              { Proc we're waiting for died           }
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF what = fcTerminate
  THEN BEGIN
    err := fNoErr;
    reply := allOk;
    END
  ELSE BEGIN
    err := aborted;
    reply := internalError;
    END;
  gotReply := TRUE;
  IF curEvent.what = folderActivate
  THEN DoActivateEvent
  ELSE FinishTerminating;
  END;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('SendFilerEvent: kind ',ORD(what):1, ', to ',proc:1);

reply := allOk;

IF NOT (what IN [fcResume,fcNone])               { Bullet proofing          }
THEN BEGIN
  Info_Process (err, proc, procRec);
  IF err > 0
  THEN BEGIN                                     { No process exists        }
    eventBlk.event_Header.send_PID := proc;      { SonTerm looks here for procID }
    SonTerminated;                               { Clean up the tool entry  }
    IF trcFDocCtrl THEN WRITELN ('   exit SendEvent - process does not exist');
    EXIT (SendFilerEvent);
    END;
  END;

theEvent.who := folder;                          { Build the event record   }
theEvent.what := filerEvent;
theEvent.toProcess := proc;
theEvent.fromFolder := filerFolder;
theEvent.fromProcess := filerProcess;
GetHeap (saveHeap);
SetHeap (wmHeap);
theEvent.userData := ORD(NewHandle(SIZEOF(FilerExt)));
SetHeap (saveHeap);
parmsHdl := POINTER(theEvent.userData);
docHdl := WindowToDocEntry (folder);
WITH parmsHdl^^
DO BEGIN
  theFlrOp := what;
  theDF := dfRefnum;
  thePrefix := docName;
  IF docHdl <> NIL
  THEN thePassword := docHdl^^.docPassword
  ELSE thePassword := password;
  IF what = fcCopy
  THEN theResult := sourceName
  ELSE theResult := '';
  END;

IF trcFDocCtrl THEN WRITELN ('   sending event ');
PushEvent (theEvent);

   { Wait for and process the reply. }

CASE what OF

  fcResume,
  fcNone:   BEGIN                  { Don't wait for reply, too much swapping }
      GiveWindow (folder, proc);
      END;

  OTHERWISE BEGIN                  { Wait for a reply to the event     }
      gotReply := FALSE;
      REPEAT
         IF trcFDocCtrl THEN WRITELN ('   waiting for reply ');

         GetEvFrom (proc, curEvent);

         CASE curEvent.what OF

            filerEvent :
               BEGIN
               udPtr := @curEvent.userData;
               reply := udPtr^.theReason;
               CASE udPtr^.theReply OF
                  dfClosed,
                  dfNotClosed : ;

                  docNotClosed:  BEGIN
                         IF trcFDocCtrl THEN WRITELN ('   doc not closed, try to free disk');
                         field.fieldType := dFwindow;
                         field.fWindow := folder;
                         GetEntry (doc, NIL, NIL, field, docHdl);
                         IF docHdl <> NIL
                         THEN CASE udPtr^.theReason OF
                                noDiskSpace:
                                      IF (ReclaimDiskSpace (docHdl^^.volHdl, 0) > 0)
                                      AND (NOT Abort)
                                      THEN BEGIN
                                        SendFilerEvent (err, proc, folder,
                                                        what, docName, dfRefNum, sourceName,
                                                        password, reply);
                                        GOTO 99;
                                        END;

                                noMemory:  IF KillExtraProcs (docHdl^^.volHdl)
                                      THEN BEGIN
                                        SendFilerEvent (err, proc, folder,
                                                           what, docName, dfRefNum, sourceName,
                                                           password, reply);
                                        GOTO 99;
                                        END;

                                END;

                         IF trcFDocCtrl THEN WRITELN ('   no space to free');
                         IF what <> fcCopy THEN FinishClose (curEvent.fromFolder);
                         END;

                  docClosd,
                  docXfered,                { Might be a 'Put In...' or 'Copy' }
                  docNotXfered : IF what <> fcCopy
                                 THEN FinishClose (curEvent.fromFolder);

                  OTHERWISE      IF ErrorFound (warnError,835,ORD(udPtr^.theReply),
                                                NIL) THEN;
                  END;

               gotReply := TRUE;
               CASE reply OF
                 allOK:        err := fNoErr;
                 aUserAbort:   err := fUserAbort;
                 badData:      err := fbadData;
                 cantRead:     err := fCantRead;
                 wrongPassword:err := fBadPassword;
                 cantWrite:    err := fCantWrite;
                 dirtyDoc:     err := fDirtyDoc;
                 internalErr:  err := fToolErr;
                 newerDoc:     err := fNewerDoc;
                 noDiskSpace:  err := fNoSpace;
                 noMemory:     err := fNoMemory;
                 noMoreDocs:   err := fNoErr;
                 okButNoMore:  err := fNoErr;
                 OTHERWISE     BEGIN
                               IF ErrorFound (warnError,836,ORD(udPtr^.theReply),
                                              NIL) THEN;
                               err := aborted;
                               END;
                 END;
               END;

            diedEvent :
               ProcessDied;

            folderActivate :
               IF (curEvent.why = whyDied)
               THEN ProcessDied
               ELSE IF ErrorFound (fatalError, 831, ORD(curEvent.why), NIL) THEN;

            OTHERWISE
               IF ErrorFound (fatalError, 832, ORD(curEvent.what), NIL) THEN;
            END;

      UNTIL gotReply;
      END;
  END;

99:
IF trcFDocCtrl THEN WRITELN ('   exit SendFilerEvent: reply is ',ORD(reply):1);
END;

{**************************************************************************}

{$S flrCopy }

FUNCTION ShredContents {volHdl: TentryHdl; objCatRID: TcatRID;
                        dontResize: BOOLEAN; cantAbort: BOOLEAN) : BOOLEAN};
{ destroys contents of a filed object }

LABEL 86;
VAR catRec:     TcatRec;
    err:        INTEGER;
    nextID:     IdType;
    pCatRec:    PtrCatRec;
    sonCatRID:  TcatRID;

  PROCEDURE CheckAbort;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF NOT cantAbort THEN IF Abort
  THEN BEGIN
    IF err <> fUserAbort
    THEN BEGIN
      err := fUserAbort;
      WaitAlert (flrAlert, 263);
      END;
    IF trcFDocCtrl THEN WRITELN ('   exit ShredContents: user aborted');
    EXIT (ShredContents);
    END;
  END;

  PROCEDURE CheckErr (location: INTEGER);
  VAR diskName:  FMaxStr;
      objName:   FMaxStr;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF ErrorFound (askError, location, err, volHdl^^.devHdl) THEN ;
    GetObjName (volHdl, objCatRID, objName);
    GetObjName (volHdl, diskCatRID, diskName);
    ParamAlert (diskName, volHdl^^.devHdl^^.userNmHdl^^, objName);
    StopAlert (flrAlert, 289);
    UpdateAll;
    EXIT (ShredContents);
    END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN('ShredContents - parent: ',objCatRID.fatherID:1,
                                            ' id: ',objCatRID.uniqueID:1);
ShredContents := FALSE;
IF volHdl = NIL THEN EXIT(ShredContents);
CheckAbort;
IF volHdl = NIL THEN EXIT(ShredContents);

{ position to first record of contents }

posApprox.fatherID := objCatRID.uniqueID;
PosCatRec (err, volHdl, posApprox, pCatRec); { Find first son              }
IF err = endOfCat THEN GOTO 86;              { Nothing to shred            }
CheckErr (822);

sonCatRID.fatherID := objCatRID.uniqueID;
sonCatRID.uniqueID := pCatRec^.selfID;

{ Shred each object (and it's descendants) in this container }

REPEAT
   CheckAbort;
   PosCatRec (err, volHdl, sonCatRID, pCatRec);{ Set to rec about to be shreded }
   CheckErr (808);
   PosCatRec (err, volHdl, posNext, pCatRec);
   IF trcFDocCtrl THEN WRITELN ('   positioned to obj ',posNext.uniqueID:1,
                                ', parent is ',posNext.fatherID:1);
   CASE err OF
     0:        IF (pCatRec^.parentID = sonCatRID.fatherID)
               THEN nextID := pCatRec^.selfID  { Found another son         }
               ELSE nextID := idNil;           { No more sons in container }
     endOfCat: nextID := idNIL;                { No more recs in db        }
     OTHERWISE CheckErr(823);                  { OOPS!                     }
     END;

   IF NOT ShredObject (volHdl, sonCatRID, dontResize, cantAbort)
   THEN EXIT (ShredContents);
   sonCatRID.uniqueID := nextID;
   UNTIL nextID = idNIL;

86:
IF NOT dontResize
THEN BEGIN
  GetCatRec (err, volHdl, objCatRID, catRec);
  IF err <= 0
  THEN BEGIN
    catRec.objSize := 0;
    catRec.modified := 0;
    UpdCatRec (err, volHdl, objCatRID, catRec);
    IF NOT ErrorFound (askError, 849, err, volHdl^^.devHdl) THEN;
    END;
  END;

CheckAbort;           { To put up msg for ShredObject, don't want to flash }
ShredContents := TRUE;

IF trcFDocCtrl THEN WRITELN('   exit ShredContents');
END;

{**************************************************************************}

{$S flrCopy }

FUNCTION ShredObject {volHdl: TentryHdl; objCatRID: TcatRID
                      dontResize: BOOLEAN; cantAbort: BOOLEAN) : BOOLEAN};
{ destroys all disk structures for a filed object and its descendants }
VAR err:      INTEGER;
    catRec:   TcatRec;
    diskName: FMaxStr;
    objName:  FMaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN('ShredObject - parent: ',objCatRID.fatherID:1,
                                       ' id: ',objCatRID.uniqueID:1);
ShredObject := FALSE;
IF volHdl = NIL THEN EXIT(ShredObject);
IF NOT ShredContents(volHdl,objCatRID, dontResize, cantAbort)
THEN EXIT (ShredObject);

IF NOT cantAbort THEN IF Abort
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   exit ShredObject: user aborted');
  EXIT (ShredObject);
  END;

DeleteObject(volHdl, objCatRID);
GetCatRec(err,volHdl,objCatRID,catRec);
IF err > 0
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   exit ShredObject: unable to get catRec, err is ',err:1);
  EXIT (ShredObject);
  END;

CASE catRec.objKind OF
  docKind,
  docPad:     IF NOT ShredDoc(volHdl,objCatRID) THEN EXIT(ShredObject);

  calcKind,
  clockKind,
  computerKind,
  comp2Kind,
  printKind,
  toolKind:   IF NOT ShredTool (volHdl, objCatRID) THEN EXIT(ShredObject);  {*** FI ??? ***}

  folderPad,                                  { The object is a container  }
  inBox1Kind,
  inbox2Kind,
  outBox1Kind,
  outBox2Kind,
  letterKind,
  letterPad,
  folderKind: IF NOT ShredFolder (volHdl, objCatRID) THEN EXIT(ShredObject);  {*** FI ??? ***}

  diskKind,
  disk1Kind,
  disk2Kind,
  drawerKind,
  profileKind,
  trashKind,
  clipBdKind: ;     { catRecs for these objects are never deleted }

  OTHERWISE BEGIN
     DelCatRec(err,volHdl,objCatRID);
     IF ErrorFound (askError, 809, err, volHdl^^.devHdl)
     THEN BEGIN
       GetObjName (volHdl, objCatRID, objName);
       GetObjName (volHdl, diskCatRID, diskName);
       ParamAlert (diskName, volHdl^^.devHdl^^.userNmHdl^^, objName);
       StopAlert (flrAlert, 289);
       UpdateAll;
       IF trcFDocCtrl THEN WRITELN ('   exit ShredObject: unable to delete catRec');
       EXIT (ShredObject);
       END;
     END;
  END;

IF NOT dontResize THEN AdjustParentObjSize (volHdl, objCatRID.fatherID, TRUE);
ShredObject := TRUE;

IF trcFDocCtrl THEN WRITELN('   exit ShredObject');
END;

{**************************************************************************}
{$S flrClose }
PROCEDURE SonTerminated;

LABEL 99;

VAR   clipBdKind:    scrapType;
      docHdl:        TentryHdl;
      docName:       FMaxStr;
      err:           INTEGER;
      fieldVar:      TfieldVar;
      heapHdl:       TH;
      newDocState:   TdocState;
      normalTermination: BOOLEAN;
      responsePtr:   ReplyPtr;
      toolHdl:       TentryHdl;
      toolName:      FMaxStr;
      toolPathname:  Pathname;
      toolStartingUp:BOOLEAN;
      theTopWindow:  WindowPtr;
      whoDied:       INTEGER;
      windowKilled:  BOOLEAN;

  PROCEDURE ReclaimDocs (docHdl: TentryHdl);

  VAR  fWindow:     WindowPtr;
       nextDocHdl:  TentryHdl;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('ReclaimDocs');

  IF docHdl = NIL THEN BEGIN             { All docs reclaimed            }
    WMKillProcess (whoDied);             { Flush events, subwindows      }
    KillEntry (toolHdl);                 { Kill the tool entry           }
    IF trcFDocCtrl THEN WRITELN ('   exit ReclaimDocs: all docs reclaimed');
    EXIT (ReclaimDocs);
    END;

  docHdl^^.toolHdl := NIL;
  fWindow := docHdl^^.fWindow;
  If docHdl^^.state <> docReqd           { Don't blink 'doc req'd' msg   }
  THEN BEGIN
    IF trcFDocCtrl THEN WRITELN ('   reclaiming ',docHdl^^.nameHdl^^,
                                 ', fWindow = ',ORD(docHdl^^.fwindow):1);
    TakeWindow (fWindow);
    SetPort (fWindow);
    EndUpdate (fWindow);
    SetOrigin (0, 0);
    PenNormal;
    ClipRect (fWindow^.portRect);
    EraseRect (fWindow^.portRect);       { Erase all content             }
    END;

   { Reclaim next doc }
  GetEntry (tool, NIL, docHdl, fieldVar, nextDocHdl);
  ReclaimDocs (nextDocHdl);

  SetPort (docHdl^^.fWindow);
  InvalRect (fWindow^.portRect);     { Force cleanup of window        }
  IF normalTermination
  THEN docHdl^^.state := blank       { Show standard 'to display...' msg  }
  ELSE IF docHdl^^.state <> docReqd  { Don't change doc req'd state   }
  THEN BEGIN                         { Probably a bug in the tool code}
    IF trcFDocCtrl THEN WRITELN ('   badCode');
    IF NOT (toolStartingUp OR (docHdl^^.state IN [closing, closingFolder]))
    THEN BEGIN                       { Ask user if we should redisplay}
      InvalRect (fWindow^.portRect);
      IF ImActive                    { Only ask if Filer is active... }
      THEN BEGIN
        docHdl^^.state := newDocState;
        IF fWindow = theTopWindow    { ... and only for top window    }
        THEN BEGIN
          GetObjName (docHdl^^.volHdl, docHdl^^.catRID, docName);
          ParamAlert (toolName, docName, '');
          IF AskAlert (flrAlert, 223) = 2
          THEN BEGIN
            UpdateAll;
            StartDoc (docHdl, FALSE);
            DeactObject(TRUE,TRUE);             { pretend I received a deactivate  }
            AdjustDesktopMenu;
            ClearMenuBar;                       { app won't do a TakeControl }
            END
          ELSE UpdateAll;            { Update background if not redisplay }
          END;
        END;
      END
    ELSE docHdl^^.state := newDocState;  { Don't ask if opening, closing  }
    END;

  END;



BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('SonTerminated: process id is ',
                              eventBlk.event_Header.send_PID:1);

whoDied := eventBlk.event_Header.send_PID;
theTopWindow := TopWindow;                { msg user only if top window involved }

  { IF background printing, restart it }
IF whoDied = printProcess
THEN BEGIN
  IF dbgFiler THEN WRITELN ('Restarting the background printing process');
  MakePrintProcess (err);
  IF err > 0
  THEN BEGIN
    IF dbgFiler THEN WRITELN ('Printing not restarted: ',err:1);
    IF ImActive THEN StopAlert (flrAlert, 277);
    END;
  GOTO 99;
  END;

  { Do all events from process before doing a KillProcess }
newDocState := toolCrashed;
IF curEvent.what = folderActivate
THEN REPEAT
  GetEvFrom (whoDied, curEvent);
  CASE curEvent.what OF
    diedEvent: ;
    FilerEvent: BEGIN                               { Probably an 'InitFailed'}
      UnsolicitedFilerEvent (windowKilled);
      responsePtr := @curEvent.userData;
      IF responsePtr^.theReply = initFailed
      THEN CASE responsePtr^.theReason OF
        aUserAbort:    newDocState := blank;        { User interrrupted startup     }
        badData:       newDocState := deadDoc;      { broken doc, tool can't display}
        cantConvert:   newDocState := tooOld;       { unable to convert old format  }
        cantRead:      newDocState := deadDoc;      { unable to read doc diskfiles  }
        wrongPassword: newDocState := blank;        { unable to read due to bad password }
        cantWrite:     newDocState := noDisk;       { unable to write out the doc   }
        needToConvert: newDocState := mustAlter;    { old format must be converted  }
        newerDoc:      newDocState := tooNew;       { doc is newer version than tool}
        noDiskSpace:   newDocState := noDisk;       { tool can't open doc           }
        noMemory:      newDocState := tooBusy;      { tool can't open doc           }
        internalError: newDocState := deadDoc;      { tool cannot display doc       }
        OTHERWISE      BEGIN
                       newDocState := blank;
                       IF trcFDocCtrl THEN WRITELN ('   unexpected reason',
                                                   ORD(responsePtr^.theReason):1);
                       END;
        END;
      END;
    OTHERWISE   IF dbgFiler THEN WRITELN ('Unxpected event from dying process: what = ',
                                           curEvent.what:1);
    END;
  UNTIL (curEvent.what = diedEvent) AND (curEvent.fromProcess = whoDied);

  { Get the dead tool's entry }
fieldVar.fieldType := tProcID;            { Get tool entry                 }
fieldVar.procID := whoDied;
GetEntry (tool, NIL, NIL, fieldVar, toolHdl);
IF toolHdl = NIL                          { bullet proofing                }
THEN BEGIN                                { Ooops, should be an entry!     }
{$IFC flrDebug }
  WRITELN ('ERROR - SonTerminated: can''t find tool entry for process ',
            ORD(fieldVar.procID):1);
  PrintEntry (tool, NIL);
{$ENDC }
  IF ErrorFound (fatalError, 830, nullErr, NIL) THEN;
  END;
IF trcFDocCtrl THEN WRITELN ('   found entry for terminating tool ',
                             toolHdl^^.nameHdl^^,', procID = ',toolHdl^^.procID);

    { recover the scrap }
IF whoDied = scrapProcess
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   reclaiming the scrap');
  KillScrapOwner (whoDied, err);          { errors can be ignored          }
  GetScrap (clipBdKind, heapHdl);
  IF clipBdKind = scrapRef
  THEN InheritScrap (FALSE)               { clear out the icon refs        }
  ELSE scrapTool := toolHdl^^.id;         { maintain content until we can give away }
  SetPort (scrapFolder);
  InvalRect (scrapFolder^.portRect);      { Force an update                }
  END;

    { Normal or Abnormal termination }
IF eventBlk.event_Header.event_Type = ended
THEN toolHdl^^.toolState := sTerminating; { Executing 'End.' is a normal term }
normalTermination := toolHdl^^.toolState = sTerminating;
IF NOT normalTermination
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   abnormal termination');
  GetToolName (err, toolHdl^^.id, NIL, toolName);
  toolStartingUp := toolHdl^^.toolState = sIniting;
  END
ELSE
  IF trcFDocCtrl THEN WRITELN ('   normal termination');

  { Reclaim the dead tool's windows }
fieldVar.fieldType := dToolHdl;
fieldVar.toolHdl := toolHdl;
GetEntry (doc, NIL, NIL, fieldVar, docHdl);
IF ImActive THEN InitCursor;              { Tool may have hidden it        }
ReclaimDocs (docHdl);

    { make no references to the old tool entry after this point }

  { Give the scrap to someone else }
IF scrapTool <> 0
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   pawn off the scrap. toolid is ',ORD(scrapTool):1);
  fieldVar.fieldType := tID;
  fieldVar.id := scrapTool;
  GetEntry (tool, NIL, NIL, fieldVar, toolHdl);
  WHILE (toolHdl <> NIL) AND (scrapTool <> 0)
  DO BEGIN
    IF trcFDocCtrl THEN WRITELN ('   found a tool entry: state is ',
                                 ORD(toolHdl^^.toolState):1);
    IF toolHdl^^.toolState = sRunning
    THEN BEGIN
      WMKillPicture (scrapFolder);          { Force tool to update it      }
      ReviveScrapOwner (toolHdl^^.procID);  { Tag, your it                 }
      SetPort (scrapFolder);
      InvalRect (scrapFolder^.portRect);    { Force tool to update scrap   }
      scrapTool := 0;
      END
    ELSE GetEntry (tool, NIL, toolHdl, fieldVar, toolHdl);
    END;                                      { If no tool found, leave for update ev}
  END;

99:
IF trcFDocCtrl THEN WRITELN ('   exit SonTerminated');
END;

{**************************************************************************}

{$S flrOpen }

PROCEDURE StartDoc {docHdl: TentryHdl; resume: BOOLEAN};

VAR catErr:      INTEGER;
    catRec:      TcatRec;
    docRect:     Rect;
    docName:     FMaxStr;
    err:         INTEGER;
    reply:       FReason;
    savePort:    GrafPtr;
    startingTool:BOOLEAN;
    theOp:       FilerOp;
    thePrefix:   Pathname;
    toolName:    FMaxStr;
    xToolHdl:    TentryHdl;


  PROCEDURE CheckErr (location, err: INTEGER; volHdl: TentryHdl);
  VAR devHdl:  TentryHdl;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF volHdl = NIL
    THEN devHdl := NIL
    ELSE devHdl := volHdl^^.devHdl;
    IF ErrorFound (warnError, location, err, devHdl) THEN;
    WITH docHdl^^ DO BEGIN
      state := blank;
      SetPort (fWindow);
      InvalRect (fWindow^.portRect);
      END;
    IF trcFDocCtrl THEN WRITELN ('   exit StartDoc: err ',err:1,' trying to start doc');
    EXIT (StartDoc);
    END;
  END;

  PROCEDURE StartTool (VAR err: INTEGER; toolID: TtoolID; docVolHdl: TentryHdl;
                       toolWindow: BOOLEAN; VAR toolHdl: TentryHdl);

  VAR field:        TfieldVar;
      return:       INTEGER;
      toolCatRec:   TcatRec;
      volHdl:       TentryHdl;


     PROCEDURE CheckVolForTool (theVolHdl: TentryHdl);
     LABEL 33, 88;
     VAR err:          INTEGER;
         entryName:    NameString;
         makeErr:      INTEGER;
         newProcID:    LONGINT;
         schedErr:     INTEGER;
         theCatRID:    TcatRID;
         toolName:     FMaxStr;
         toolPathname: Pathname;

     BEGIN
     {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
     IF trcFDocCtrl THEN WRITELN ('CheckVolForTool ', theVolHdl^^.devHdl^^.nameHdl^^,
                                  ' for ',toolID:1);

     IF theVolHdl^^.volState <> sMounted         { Bullet proofing           }
     THEN BEGIN
       IF trcFDocCtrl THEN WRITELN ('   exit CheckVolForTool: vol not mounted');
       EXIT (CheckVolForTool);
       END;

     makeErr := 130;    { OS error for not on disk }
     IF ToolOnDisk (theVolHdl, toolID, theCatRID){ Check the catalog for the tool}
     THEN BEGIN
       IF startingTool
       OR NOT ObjInTrash (theVolHdl, theCatRID){ Don't use tools in the trash  }
       THEN BEGIN
         RetToolPathname (err, toolID, theVolHdl^^.devHdl, toolPathname);
         toolPathname := CONCAT(toolPathname,'obj'); { name of codefile          }
         entryName := 'nonPreempt';
      33:
         Make_Process (makeErr, newProcID, toolPathname, entryName, termEventRefnum);
         IF makeErr <= 0
         THEN BEGIN                                  { No entry for tool,make one}
           IF trcFDocCtrl THEN WRITELN ('Tool ',toolPathname,' started: procID = ',
                                        ORD(newProcID):1);
           SetPriority_Process (err, newProcID, 120);{ Lower to background level }
           GetToolName (err, toolID, docVolHdl, toolName);
           CheckErr (819, err, docVolHdl);
           CreateEntry (tool, @toolName, toolHdl);
           IF toolHdl = NIL
           THEN BEGIN                               { No memory/disk for entry }
             IF KillExtraProcs (NIL) THEN GOTO 33;
             makeErr := toolNeedsDisk;
             GOTO 88;
             END;

           WITH toolHdl^^ DO BEGIN
             toolCatRID := theCatRID;
             volHdl := theVolHdl;
             procID := newProcID;
             toolState := sRunning;
             END;
           GetCatRec (err, theVolHdl, theCatRID, toolCatRec);
           toolHdl^^.moreDocs := toolCatRec.props[manyDocs];
           toolHdl^^.id := toolID;                   { There is a 'toolID' in TentryHdl}
           return := 0;
           END
         ELSE IF trcFDocCtrl
              THEN WRITELN ('Tool ',toolPathname,' not started: makeErr = ',makeErr:1);
         END;
       END;

     CASE makeErr OF{ Which err to return: noCode<toolProtected<toolInvalid<toolTooBusy}
       0:   ;

       130:                             makeErr := noCode;
       142:                             makeErr := toolProtected;
       131,132,138,141,143,144,145,146,
       -149,-150:                       BEGIN
                                        IF makeErr < 0 THEN Kill_Process (err, newProcID);
                                        makeErr := toolInvalid;
                                        END;
       135:                             BEGIN
                                        IF KillExtraProcs (NIL) THEN GOTO 33;
                                        makeErr := toolTooBusy;
                                        END;
       133,134,136,147,148:             BEGIN
                                        IF (ReclaimDiskSpace (bootVol, 0) > 0)
                                        AND (NOT Abort)
                                        THEN GOTO 33;
                                        makeErr := toolNeedsDisk;
                                        END;
       OTHERWISE                        CheckErr (818, makeErr, theVolHdl);
       END;
  88:
     IF makeErr > return THEN return := makeErr;

     IF trcFDocCtrl THEN WRITELN ('   exit CheckVolForTool: makeErr = ',makeErr:1);
     END;

  {-------------------- StartTool ---------------------------------------------}

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('StartTool: ',toolID:1,', toolWindow is ',toolWindow);

    { Is there a process avail? }
  field.fieldType := tID;
  field.id := toolID;
  GetEntry (tool, NIL, NIL, field, toolHdl);
  WHILE toolHdl <> NIL DO BEGIN               { Is the tool on the volume }
    IF (toolHdl^^.moreDocs AND (toolHdl^^.toolState = sRunning))
    AND NOT (toolWind AND (toolHdl^^.volHdl <> docVolHdl))
    THEN BEGIN                                { A running process is avail}
      IF trcFDocCtrl THEN WRITELN ('   exit StartTool: found a running proc');
      GetCatRec (err, toolHdl^^.volHdl, toolHdl^^.toolCatRID, toolCatRec);
      CheckErr (837, err, toolHdl^^.volHdl);
      toolHdl^^.moreDocs := toolCatRec.props[manyDocs];
      err := 0;
      EXIT (StartTool);
      END;
    GetEntry (tool, NIL, toolHdl, field, toolHdl);
    END;

    { Didn't find a running process, will have to try to start one }
  IF trcFDocCtrl THEN WRITELN ('   checking boot vol');
  return := 0;

  IF startingTool
  THEN BEGIN
    IF trcFDocCtrl THEN WRITELN ('   checking tool vol');
    CheckVolForTool (docVolHdl);
    END
  ELSE BEGIN
    CheckVolForTool (bootVol); { First check the boot vol}

    IF (toolHdl = NIL)                           { Not on boot vol, try doc vol }
    AND(bootVol <> docVolHdl)
    THEN BEGIN
      IF trcFDocCtrl THEN WRITELN ('   checking doc vol');
      CheckVolForTool (docVolHdl);
      END;

    GetEntry (vol, NIL, NIL, nilField, volHdl);
    WHILE (toolHdl = NIL) AND (volHdl <> NIL)
    DO BEGIN                                     { Not on doc vol, check others }
      IF(volHdl <> bootVol)
      AND(volHdl <> docVolHdl)
      THEN BEGIN
        IF trcFDocCtrl THEN WRITELN ('   checking ',volHdl^^.devHdl^^.nameHdl^^);
        CheckVolForTool (volHdl);
        END;
      IF toolHdl = NIL THEN GetEntry (vol, NIL, volHdl, nilField, volHdl);
      END;
    END;

  err := return;

  IF trcFDocCtrl THEN WRITELN ('   exit StartTool: ',return:1);
  END;

{-------------------- StartDoc ---------------------------------------------}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('StartDoc: ', docHdl^^.nameHdl^^,', resume is ',resume);

IF docHdl^^.state IN [opened, toolOpened, closingFolder, closing]
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   exit StartDoc: state is ',ORD(docHdl^^.state):1);
  EXIT (StartDoc);
  END;

GetToolName (catErr, docHdl^^.toolID, NIL, toolName); {*** specify device ***}
IF NOT resume
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   clear the window');
  GetPort (savePort);
  SetPort (docHdl^^.fWindow);
  ClipRect (docHdl^^.fWindow^.portRect);
  EraseRect (docHdl^^.fWindow^.portRect);
  WITH docHdl^^.fWindow^.portRect DO BEGIN
    docRect.left := left+15;
    docRect.right := right;
    docRect.top := top+10;
    docRect.bottom := bottom;
    END;
  TextFont (sysText);
  TextFace ([]);
  ArgAlert (1, toolName);
  DrawAlert (flrAlert, 440, docRect);
  SetPort (savePort);
  END;

GetCatRec (err, docHdl^^.volHdl, docHdl^^.catRID, catRec);
CheckErr (854, err, docHdl^^.volHdl);
startingTool := catRec.objKind IN toolSet;
StartTool (err, docHdl^^.toolID, docHdl^^.volHdl, startingTool, xToolHdl);
docHdl^^.toolHdl := xToolHdl;
IF err <= 0
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   tool found');
  IF startingTool
  THEN BEGIN                                     { Set the fc op                 }
    IF trcFDocCtrl THEN WRITELN ('   op is fcNone');
    thePrefix := '';
    theOp := fcNone;
    docHdl^^.state := toolOpened;
    END
  ELSE BEGIN
    IF trcFDocCtrl THEN WRITELN ('   op is fcResume');
    RetDocPathname (docHdl, thePrefix);
    theOp := fcResume;
    docHdl^^.state := opened;
    END;

  SendFilerEvent (err, docHdl^^.toolHdl^^.procID, docHdl^^.fWindow, theOp,
                  thePrefix, 0, '', docHdl^^.docPassword, reply);
  WITH docHdl^^ DO BEGIN
    toolHdl^^.docsOpen := toolHdl^^.docsOpen + 1;
    IF scrapTool = toolHdl^^.id
    THEN BEGIN
      ReviveScrapOwner (toolHdl^^.procID);
      SetPort (scrapFolder);
      InvalRect (scrapFolder^.portRect);             { Force scrap update }
      scrapTool := 0;
      END;
    END;
  END

ELSE BEGIN
  IF trcFDocCtrl THEN WRITELN ('   tool not found');
  GetObjName (docHdl^^.volHdl, docHdl^^.catRID, docName);
  ParamAlert (docName,toolName,'');
  CASE err OF
    noCode: BEGIN
        IF NOT resume THEN StopAlert (flrAlert, 250);
        IF catRec.objKind IN toolSet
        THEN docHdl^^.state := docReqd  {*** for now - shouldn't happen in release ***}
        ELSE docHdl^^.state := noTool;
        END;
    toolProtected: BEGIN
        IF NOT resume THEN StopAlert (flrAlert, 251);
        docHdl^^.state := protectedTool;
        END;
    toolInvalid: BEGIN
        IF NOT resume THEN StopAlert (flrAlert, 252);
        docHdl^^.state := badTool;
        END;
    toolTooBusy: BEGIN
        IF NOT resume THEN StopAlert (flrAlert, 253);
        docHdl^^.state := tooBusy;
        END;
    toolNeedsDisk: BEGIN
        IF NOT resume THEN StopAlert (flrAlert, 257);
        docHdl^^.state := noToolDisk;
        END;
    OTHERWISE  CheckErr (838, nullErr, NIL);
    END;
  InvalRect (docHdl^^.fWindow^.portRect);        { Insure a window update }
  UpdateAll;
  END;

IF trcFDocCtrl THEN WRITELN ('   exit StartDoc: state = ',ORD(docHdl^^.state):1);
END;

{**************************************************************************}

{$S flrCold }

PROCEDURE TellUserWhy {sVolHdl,dVolHdl: TentryHdl; sCatRID,deCatRID: TcatRID;
                       theReason: INTEGER; theOp: TuserOp};
VAR diskName:   FMaxStr;
    docHdl:     TentryHdl;
    docName:    FMaxStr;
    toolName:   FMaxStr;
    err:        INTEGER;
    field:      TfieldVar;
    reply:      FReason;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('TellUserWhy: theReason ',theReason:1);

IF NOT ImActive
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   exit TellUserWhy, filer is not active');
  EXIT (TellUserWhy);
  END;

CASE theReason OF
  aborted:   EndWaitAlert;             { In case the caller expects us to overwrite one }
  fBadData:  BEGIN
        GetObjName (sVolHdl, sCatRID, docName);
        ParamAlert (docName,'','');
        StopAlert (flrAlert, 254);
        END;
  fBadPassword:  BEGIN
        field.fieldType := dCatRID;
        field.catRID := sCatRID;
        GetEntry (doc, NIL, NIL, field, docHdl);
        FixPassword (docHdl^^.volHdl, docHdl^^.CatRID);
        END;
  fCantAlter,
  fMustAlter: ;                        { The tool should tell the user what happened }
  fCantRead: BEGIN
        GetObjName (sVolHdl, sCatRID, docName);
        GetObjName (sVolHdl, diskCatRID, diskName);
        ParamAlert (docName,diskName,'');
        StopAlert (flrAlert, 203);
        END;
  fCantWrite: BEGIN
        GetObjName (sVolHdl, sCatRID, docName);
        GetObjName (dVolHdl, diskCatRID, diskName);
        ParamAlert (docName,diskName,'');
        StopAlert (flrAlert, 204);
        END;
  fDirtyDoc : BEGIN
        GetObjName (sVolHdl, sCatRID, docName);
        ParamAlert (docName,'','');
        StopAlert (flrAlert, 216);
        END;
  fNewerDoc : BEGIN
        field.fieldType := dCatRID;
        field.catRID := sCatRID;
        GetEntry (doc, NIL, NIL, field, docHdl);
        GetToolName (err, docHdl^^.toolID, NIL, toolName);
        ArgAlert (1, toolName);
        StopAlert (flrAlert, 280);
        END;
  fNoErr: ;
  fNoMemory: BEGIN
        GetObjName (sVolHdl, sCatRID, docName);
        GetObjName (sVolHdl, diskCatRID, diskName);
        ParamAlert (docName, diskName,'');
        StopAlert (flrAlert, 206);
        END;
  fNoSpace: BEGIN
        GetObjName (sVolHdl, sCatRID, docName);
        GetObjName (dVolHdl, diskCatRID, diskName);
        ParamAlert (docName, diskName,'');
        CASE theOp OF
          opClose,
          opRefile:  StopAlert (flrAlert, 208);

          OTHERWISE  StopAlert (flrAlert, 205);
          END;
        END;
  fNotClosed: BEGIN
           { No msg, other alerts already done }
        END;
  fOneTool: BEGIN
        StopAlert (flrAlert, 249);
        END;
  fToolErr: BEGIN
        field.fieldType := dCatRID;
        field.catRID := sCatRID;
        GetEntry (doc, sVolHdl, NIL, field, docHdl);
        IF docHdl = NIL
        THEN StopAlert (flrAlert, 217)
        ELSE BEGIN
          GetToolName (err, docHdl^^.toolID, NIL, toolName);
          ArgAlert (1, toolName);
          IF (AskAlert (flrAlert, 209) = 2) AND (docHdl^^.toolHdl <> NIL)
          THEN BEGIN
            UpdateAll;
            SendFilerEvent (err, docHdl^^.toolHdl^^.procID, NIL, fcTerminate,
                            '', 0, '', '', reply);
            END;
          END;
        END;
  fUserAbort: BEGIN
        StopAlert (flralert, 255);
        END;
  OTHERWISE IF ErrorFound (warnError, 891, theReason, NIL) THEN;
  END;
UpdateAll;

IF trcFDocCtrl THEN WRITELN ('   exit TellUserWhy');
END;

{**************************************************************************}

{$S flrClose }

PROCEDURE TermTools {volHdl: TentryHdl; VAR activeTools: BOOLEAN};

{  Terminate the process on the specified volume.  To minimize swapping, kill
   all the process of the same kind together.  We do this by making multiple passes
   over the tool (process) list, killing a processes of the same type as the first
   one found. }

VAR activeDocs: BOOLEAN;
    err:        INTEGER;
    nextToolHdl:TentryHdl;
    reply:      FReason;
    sameTool:   TtoolID;
    toolHdl:    TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('TermTools');

GetEntry (tool, volHdl, NIL, nilField, toolHdl);   { Get first tool entry on volume }
WHILE toolHdl <> NIL DO
  BEGIN
  sameTool := toolHdl^^.id;                        { Defines which process to kill this pass }
  REPEAT                                           { Kill all processes of the same type }
    IF trcFDocCtrl THEN WRITELN ('   terminating tool ',toolHdl^^.NameHdl^^,
                                 ', toolHdl = ',ORD(toolHdl):1);
    GetEntry (tool, volHdl, toolHdl, nilField, nextToolHdl);
    IF toolHdl^^.id = sameTool THEN KillTool (toolHdl);
    toolHdl := nextToolHdl;
    UNTIL toolHdl = NIL;
  GetEntry (tool, volHdl, NIL, nilField, toolHdl); { Get new first tool entry on volume }
  END;

   { are any tools still active }
GetEntry (tool, volHdl, NIL, nilField, toolHdl);
IF toolHdl = NIL
then activeTools := FALSE
ELSE activeTools := TRUE;

IF trcFDocCtrl THEN WRITELN ('   exit TermTools: activeTools = ',ORD(activeTools));
END;


{**************************************************************************}

{$S flrCopy }

FUNCTION ToolCheck {hVol: TentryHdl; catRID: TcatRID;
                    FUNCTION FoundOne () : BOOLEAN
                   ) : BOOLEAN};
LABEL 99;
VAR catRec:       TcatRec;
    dfInfo:       Q_Info;
    err:          INTEGER;
    toolFound:    BOOLEAN;
    pCatRec:      PtrCatRec;
    sonCatRID:    TcatRID;
    toolName:     FMaxStr;
    toolPathname: Pathname;
    toolPrefix:   E_Name;

  PROCEDURE CheckErr (location: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0
  THEN BEGIN
    IF ErrorFound (askError, location, err, hVol^^.devHdl) THEN;
    toolFound := TRUE;                 { Prevent caller from continuing }
    IF trcFDocCtrl THEN WRITELN ('   exit ToolCheck: err = ',err:1);
    EXIT (ToolCheck);
    END;
  END;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('ToolCheck');

toolFound := FALSE;
IF Abort THEN EXIT (ToolCheck);

IF (catRID.fatherID = diskCatRID.fatherID)
AND (catRID.uniqueID = diskCatRID.uniqueID)    { use a quicker search if checking whole disk }
THEN BEGIN
  toolPrefix := '{T';
  toolPathname := CONCAT('-',hVol^^.devHdl^^.nameHdl^^);
  Reset_Catalog (err, toolPathname);
  WHILE TRUE DO BEGIN
    Lookup_Next_Entry (err, toolPrefix, dfInfo);
    IF err = 848 THEN GOTO 99;           { no more tools }
    CheckErr (896);
    IF POS('}obj',dfInfo.name) = (LENGTH(dfInfo.name) - 3)
    THEN toolFound := FoundOne (@catRec, @dfInfo); { Tell client, ask if we should continue? }
    IF toolFound THEN GOTO 99;
    END;
  END;

GetCatRec (err, hVol, catRID, catRec); { Get the tool's unique id       }
CheckErr (896);
IF trcFDocCtrl THEN WRITELN ('   objKind: ',catRec.objKind:1);

IF catRec.objKind IN containerSet
THEN BEGIN
  IF trcFDocCtrl THEN WRITELN ('   this is a container: id is ',catRID.uniqueID:1);
  sonCatRID.fatherID := catRID.uniqueID;
  posApprox.fatherID := catRID.uniqueID;
  PosCatRec (err, hVol, posApprox, pCatRec);
  IF err <> endOFCat THEN CheckErr (896);
  IF trcFDocCtrl THEN WRITELN ('   positioned to obj ',pCatRec^.selfID:1,
                               ', father''s id is ',pCatRec^.parentID:1);
  WHILE (err <= 0) AND (pCatRec^.parentID = sonCatRID.fatherID) DO BEGIN
    sonCatRID.uniqueID := pCatRec^.selfID;
    toolFound := ToolCheck (hVol, sonCatRID, FoundOne);
    IF toolFound THEN GOTO 99;        { toolFound found and user said don't copy }
    PosCatRec (err, hVol, sonCatRID, pCatRec);  { Reposition to where we were }
    CheckErr (896);
    PosCatRec (err, hVol, posNext, pCatRec);
    IF trcFDocCtrl THEN WRITELN ('   positioned to obj ',pCatRec^.selfID:1,
                                 ', father''s id is ',pCatRec^.parentID:1);
    END;
  IF err <> endOfCat THEN CheckErr (896);
  IF trcFDocCtrl THEN WRITELN ('   finished with folder: err = ',err:1);
  GOTO 99;
  END;

IF NOT (catRec.objKind IN toolSet)
THEN GOTO 99;                          { This is not a tool             }

IF trcFDocCtrl THEN WRITELN ('   this is a tool: id = ',catRec.toolID:1);
BuildToolName (catRec.toolID, toolPrefix);
toolPathname := CONCAT ('-',hvol^^.devHdl^^.nameHdl^^,'-',toolPrefix,'obj');
Quick_Lookup (err, toolPathname, dfInfo);
IF err <= 0
THEN toolFound := FoundOne (@catRec, @dfInfo); { Tell client, ask if we should continue? }

99:
ToolCheck := toolFound;
IF trcFDocCtrl THEN WRITELN ('   exit ToolCheck: ', toolFound);
END;


{**************************************************************************}

{$S flrDm }

PROCEDURE UnbindCopyDataSeg;

VAR err:          INTEGER;
    newDiskSize:  LONGINT;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('UnbindCopyDataSeg');

IF copyDsBound > 1
THEN copyDsBound := copyDsBound - 1
ELSE BEGIN
  Close_Dataseg (err, copyDsRefnum);
  IF dbgFiler THEN IF err > 0 THEN WRITELN ('   error killing dataseg: ',err:1);
  copyDsBound := 0;
  END;

IF trcFDocCtrl THEN WRITELN ('   exit UnbindCopyDataSeg');
END;

{**************************************************************************}

{$S flrClose }

PROCEDURE UnsolicitedFilerEvent {VAR destroyWindow: BOOLEAN};
LABEL 99;
VAR docHdl:   TentryHdl;
    field:    TfieldVar;
    udPtr:    ReplyPtr;
    windPeek: WindowPeek;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('UnsolicitedFilerEvent: from ',curEvent.fromProcess:1);

destroyWindow := FALSE;
udPtr := @curEvent.userData;
IF trcFDocCtrl THEN WRITELN ('   msg is ',ORD(udPtr^.theReply):1,
                             ', reason is ',ORD(udPtr^.theReason));
IF trcFDocCtrl THEN WMStatus;

CASE udPtr^.theReply OF
  docClosd:   BEGIN
              FinishClose (curEvent.fromFolder);
              IF (udPtr^.theReason = docPutBack) THEN
                 destroyWindow := TRUE;
              END;

  initFailed: BEGIN
           (* IF udPtr^.theReason IN [noDiskSpace, noMemory]
              THEN BEGIN
                field.fieldType := dFWindow;  { Get the doc entry }
                field.fWindow := curEvent.fromFolder;
                GetEntry (doc, NIL, NIL, field, docHdl);
                IF docHdl <> NIL
                THEN BEGIN
                  IF (ReclaimDiskSpace (docHdl^^.toolHdl^^.volHdl, 0) > 0)
                  AND (NOT Abort)
                  THEN BEGIN
                    StartDoc (docHdl, TRUE);
                    IF trcFDocctrl THEN WMStatus;
                    GOTO 99;
                    END;
                  END;
                END; *)
              IF trcFDocctrl THEN WMStatus;
              FinishClose (curEvent.fromFolder);
              ToolCantInit (udPtr^.theReason);
              END;

  OTHERWISE   IF ErrorFound (warnError, 897 ,ORD(udPtr^.theReply), NIL) THEN;
  END;

99:
IF trcFDocCtrl THEN WRITELN ('   exit UnsolicitedFilerEvent');
END;

{**************************************************************************}

{$S flrCopy }

PROCEDURE WriteVerify {devHdl: TentryHdl; onOff: Tswitch};

VAR dcParams:     dcType;
    devPathname:  Pathname;
    err:          INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('WriteVerify: dev is ',devHdl^^.nameHdl^^,
                             ', onOff is ',ORD(onOff):1);

dcParams.dcVersion := 2;
dcParams.dcCode := 21;
dcParams.dcData[0] := 1;        { Spare bad blocks }
dcParams.dcData[1] := 1;        { Rewrite on soft errors }
IF onOff = turnOn
THEN dcParams.dcData[2] := 1    { Write verify on  }
ELSE dcParams.dcData[2] := 0;   { Write verify off }
devPathname := CONCAT('-',devHdl^^.nameHdl^^);
Device_Control (err, devPathname, dcParams);

IF trcFVolCtrl THEN WRITELN ('   exit WriteVerify: err = ',err:1);
END;


{**************************************************************************}

{$S flrDm }

PROCEDURE XferObj {VAR err: INTEGER;
                       sCatRID: TcatRID;
                   VAR intoCatRID: TcatRID;
                   VAR sVolHdl: TentryHdl;
                   VAR dVolHdl: TentryHdl;
                       excludeUnfiled: BOOLEAN;
                       xferOp: TuserOp;
                       split: BOOLEAN;
                   VAR diskCt: INTEGER;
                       sinceDate: LONGINT};

LABEL 99;

VAR catErr:      INTEGER;
    catRec:      TcatRec;
    copyOp:      FCopyOp;
    deCatRID:    TcatRID;
    dDevHdl:     TentryHdl;
    dtc:         LONGINT;
    dtm:         LONGINT;
    objName:     FMaxStr;   { For debugging use only }
    objPathname: Pathname;
    oldCatRec:   TcatRec;
    otherErr:    INTEGER;
    parentCatRID:TcatRID;
    pCatRec:     PtrCatRec;
    qInfo:       Q_Info;
    sDevHdl:     TentryHdl;
    sonCatRID:   TcatRID;
    sonXferred:  BOOLEAN;
    sUserVolName:FMaxStr;
    tempCatRID:  TcatRID;
    toolCatRID:  TcatRID;

  PROCEDURE Backingup;  FORWARD;

  PROCEDURE CheckErr (location, theErr: INTEGER; volHdl: TentryHdl);
  VAR devHdl: TentryHdl;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF theErr > 0
  THEN BEGIN
    IF volHdl <> NIL
    THEN devHdl := volHdl^^.devHdl
    ELSE devHdl := NIL;
    IF ErrorFound (askError, location, theErr, devHdl)
    THEN BEGIN
      WaitAlert (flrAlert, 290);
      IF trcFDocCtrl THEN WRITELN ('   exit XferObj: err set to aborted');
      theErr := aborted;
      EXIT (XferObj);
      END
    ELSE theErr := 0;
    END;
  err := theErr;  { in case caller passed in catErr or some such }
  END;

  PROCEDURE AbortXfer;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('AbortXfer');

  IF  (dVolHdl <> NIL)
  AND (deCatRID.uniqueID <> idNil)
  AND (deCatRID.uniqueID <> idDisk)
  THEN IF ShredObj (dVolHdl, deCatRID, FALSE, TRUE) THEN;{ Delete the obj being moved }

  IF (err <> fUserAbort) AND (err <> aborted) AND (xferOp IN [opBackUp, opRebuild])
  THEN Backingup                          { ProFile to Diskette backup }
  ELSE BEGIN
    IF trcFDocCtrl THEN WRITELN ('   exit AbortXfer and XferObj: err =',err:1);
    EXIT (XferObj);
    END;

  IF trcFDocCtrl THEN WRITELN ('   exit AbortXfer');
  END;

  PROCEDURE CheckAbort;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF Abort
  THEN BEGIN
    IF err <> fUserAbort
    THEN BEGIN
      err := fUserAbort;
      WaitAlert (flrAlert, 263);
      END;
    AbortXfer;
    END;
  END;

  PROCEDURE Backingup;
  LABEL 98;
  VAR alertNum:     INTEGER;
      dDevHdl:      TentryHdl;
      dDevPathname: Pathname;
      dDfInfo:      Fs_Info;
      sDevPathname: Pathname;
      sDfInfo:      Fs_Info;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('BackingUp: diskCt = ',diskCt:1);

  CheckAbort;
  dDevHdl := dVolHdl^^.devHdl;

  CASE err OF
    fUserAbort:  BEGIN
      IF trcFDocCtrl THEN WRITELN ('   exit BackingUp and XferObj: user aborted backup');
      EXIT (XferObj);
      END;

    fNoSpace: BEGIN
      IF diskCt = 0
      THEN BEGIN
        err := aborted;
        GetObjName (dVolHdl, diskCatRID, objName);
        ParamAlert (sUserVolName, objName, '');
        StopAlert (flrAlert, 205);
        UpdateAll;
        EXIT (XferObj);
        END
      ELSE BEGIN
        IF NOT FitOnEmptyDisk (catRec.objSize, dDevHdl)
        THEN BEGIN
          ExtObjName (catRec, objName);
          ArgAlert (1, objName);
          IF AskAlert (flrAlert, 311) = 1
          THEN err := aborted
          ELSE BEGIN
            err := 0;
            ParamAlert (sUserVolName,sVolHdl^^.devHdl^^.userNmHdl^^,
                        dVolHdl^^.devHdl^^.userNmHdl^^);
            WaitAlert (flrAlert, 236);            { 'Backing up...'                }
            END;
          UpdateAll;
          GOTO 98;
          END;

        IF GetNextDiskette (err, dDevHdl, sVolHdl, diskCt, xferOp)
        THEN BEGIN
          dVolHdl := dDevHdl^^.volHdl;
          IF xferOp = opBackup
          THEN BEGIN
            ParamAlert (sUserVolName,sVolHdl^^.devHdl^^.userNmHdl^^,
                        dVolHdl^^.devHdl^^.userNmHdl^^);
            WaitAlert (flrAlert, 236);            { 'Backing up...'                }
            END
          ELSE BEGIN
            ParamAlert (dVolHdl^^.devHdl^^.userNmHdl^^,
                        sVolHdl^^.devHdl^^.userNmHdl^^,'');
            WaitAlert (flrAlert, 270);            { 'Rebuilding...'                }
            END;
          ReconstructParentage (sVolHdl, dVolHdl, sCatRID);
          tempCatRID := parentCatRID;
          XferObj (err, sCatRID, tempCatRID, sVolHdl, dVolHdl, excludeUnfiled, xferOp,
                   split, diskCt, sinceDate);            { Try xfer again to the new disk }
          sVolHdl := sDevHdl^^.volHdl;
          dVolHdl := dDevHdl^^.volHdl;
          IF err <= 0 THEN intoCatRID := tempCatRID;
          END
        ELSE BEGIN
          IF trcFDocCtrl THEN WRITELN ('   exit BackingUp and XferObj: user aborted backup');
          dVolHdl := dDevHdl^^.volHdl;
          GOTO 98;
          END;
        END;
      END;

    OTHERWISE BEGIN
      IF xferOp = opBackup
      THEN alertNum := 237
      ELSE alertNum := 296;
      GetObjName (sVolHdl, sCatRID, objName);
      ArgAlert (1, objName);
      IF AskAlert (flrAlert, alertNum) = 2        { '... not transferred, continue?}
      THEN BEGIN
        err := 0;
        IF xferOp = opBackup
        THEN BEGIN
          ParamAlert (sUserVolName,sVolHdl^^.devHdl^^.userNmHdl^^,
                      dVolHdl^^.devHdl^^.userNmHdl^^);
          WaitAlert (flrAlert, 236);            { 'Backing up...'                }
          END
        ELSE BEGIN
          ParamAlert (dVolHdl^^.devHdl^^.userNmHdl^^,
                      sVolHdl^^.devHdl^^.userNmHdl^^,'');
          WaitAlert (flrAlert, 270);            { 'Rebuilding...'                }
          END;
        END
      ELSE BEGIN
        UpdateAll;
        err := aborted;
        IF trcFDocCtrl THEN WRITELN ('   exit BackingUp and XferObj: user aborted backup');
        EXIT (XferObj);
        END;
      END;

    END;
98:
  IF trcFDocCtrl THEN WRITELN ('   exit BackingUp');
  END;


  PROCEDURE XferContents (fromId: IdType; deCatRID: TcatRID);
  VAR tempCatRID:  TcatRID;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFDocCtrl THEN WRITELN ('XferContents: from ',fromId:1,' to ',deCatRID.uniqueId:1);

    { position to first record of contents }
  posApprox.fatherID := fromId;
  PosCatRec(catErr, sVolHdl, posApprox, pCatRec); { Find first son     }
  IF catErr <> endOfCat
  THEN CheckErr (812, catErr, sVolHdl);

  IF sinceDate = nullInt4
  THEN sonXferred := TRUE
  ELSE sonXferred := FALSE;              { Delete entry if no sons     }

  sonCatRID.fatherID := fromId;
  WHILE (catErr <= 0) AND (pCatRec^.parentID = sCatRID.uniqueID) DO
     BEGIN                               { Copy the sons               }
     IF NOT (excludeUnfiled AND OnDesktop (sVolHdl, pCatRec^.selfID))
     THEN BEGIN                          { Xfer the son                }
       sonCatRID.uniqueID := pCatRec^.selfID;
       tempCatRID := deCatRID;
       XferObj (err, sonCatRID, tempCatRID, sVolHdl, dVolHdl, excludeUnfiled,
                xferOp, split, diskCt, sinceDate);
       sVolHdl := sDevHdl^^.volHdl;
       dVolHdl := dDevHdl^^.volHdl;
       CASE err OF
         0:        sonXferred := TRUE;
         fTooOld:  err := 0;
         OTHERWISE AbortXfer;
         END;

       PosCatRec(catErr, sVolHdl, sonCatRID, pCatRec); { May have repositioned}
       IF catErr <> endOfCat THEN CheckErr (813, catErr, sVolHdl);
       END;
     IF catErr <= 0
     THEN BEGIN
       PosCatRec(catErr, sVolHdl, posNext, pCatRec);{ Get next, maybe a son }
       IF catErr <> endOfCat THEN CheckErr (815, catErr, sVolHdl);
       END;
     END;

  IF NOT (sonXferred OR (deCatRID.uniqueID = idDisk))
  THEN BEGIN                    { Delete if no sons and not disk entry   }
    IF trcFDocCtrl THEN WRITELN ('   deleting catRID for ',objName,', id is ',
                                 catRec.selfID:1,', parent is ',catRec.parentID:1);
    DelCatRec (catErr, dVolHdl, deCatRID);
    err := fTooOld;
    END
  ELSE BEGIN                    { Update the objSize and modified fields }
    catRec.objSize := ObjectSize (dVolHdl, deCatRID, NIL, FALSE, dtm, dtc);
    IF  (xferOp = opBackup)
    AND (catRec.created < sinceDate)      { its not a recent folder }
    AND (catRec.objSize = 0)              { its empty }
    THEN BEGIN
      IF ShredFolder (dVolHdl, deCatRID) THEN;
      END
    ELSE BEGIN
      IF (xferOp <> opRebuild) AND (xferOp <> opBackup)
      THEN catRec.modified := dtm;
      UpdCatRec (catErr, dVolHdl, deCatRID, catRec);
      END;
    END;

  IF catErr <> endOfCat THEN CheckErr (857, catErr, dVolHdl);

  IF trcFDocCtrl THEN WRITELN ('   exit XferContents');
  END;

{----------------------- XferObj ------------------------------------------}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('XferObj: obj ',sCatRID.uniqueID:1,
                             ' from device ',sVolHdl^^.devHdl^^.nameHdl^^,
                             ' into ',intoCatRID.uniqueID:1,
                             ' on ',dVolHdl^^.devHdl^^.nameHdl^^,
                             ' if modified since ',sinceDate:1);

err := 0;
IF xferOp = opBackup THEN IF sCatRID.uniqueID = idFolderPad THEN GOTO 99;
deCatRID.uniqueID := idNIL;

IF Abort
THEN BEGIN
  WaitAlert (flrAlert, 263);
  err := fUserAbort;
  GOTO 99;
  END;

sDevHdl := sVolHdl^^.devHdl;       { Save device handles }
dDevHdl := dVolHdl^^.devHdl;

IF (sVolHdl = dVolHdl) AND (sCatRID.uniqueID = intoCatRID.uniqueID)
THEN BEGIN                                    { Cannot dup an object into itself}
  StopAlert (flrAlert, 274);
  UpdateAll;
  err := aborted;                             { No additional user msgs    }
  GOTO 99;
  END;

parentCatRID := intoCatRID;
GetCatRec(catErr, sVolHdl, sCatRID, catRec);  { Get source obj catRec      }
CheckErr (814, catErr, sVolHdl);
IF trcFDocCtrl THEN WRITELN ('   xferOp is ',ORD(xferOp):1);
CASE xferOp OF                                { Coerse for DupDoc calls    }
  opCopy:    copyOp := fcDocCopy;
  opMove,
  opRebuild: copyOp := fcDocMove;
  opBackup:  copyOp := fcDocBackup;
  OTHERWISE CheckErr (833, ORD(xferOp), NIL);
  END;
GetObjName (sVolHdl, diskCatRID, sUserVolName);

IF (sVolHdl = dVolHdl) AND (xferOp = opMove)
THEN BEGIN                                    { No bits are being moved    }
  catRec.parentID := intoCatRID.uniqueID;
  UpdCatRec (catErr, sVolHdl, sCatRID, catRec);
  GOTO 99;
  END;

  { Create the destination catalog entry }
IF (sCatRID.uniqueID = idDisk)
THEN deCatRID := intoCatRID                   { disk backup                }
ELSE BEGIN                                    { working on a doc, tool, etc}
  IF catRec.objKind IN toolSet
  THEN BEGIN
    IF ToolOnDisk (dVolHdl, catRec.toolID, toolCatRID)
    THEN BEGIN
      IF ObjInTrash (dVolHdl, toolCatRID)
      AND (sVolHdl <> dVolHdl)           {*** FI 199 ***}
      THEN BEGIN
        DestroyObject (dVolHdl, toolCatRID.uniqueID);
        IF NOT ShredTool (dVolHdl, toolCatRID)
        THEN BEGIN
          err := fOneTool;
          AbortXfer;
          END;
        END
      ELSE BEGIN
        err := fOneTool;
        AbortXfer;
        END;
      END
    ELSE
    END

  ELSE BEGIN
    IF xferOp = opCopy
    THEN WITH catRec DO BEGIN
      modified := nullInt4;
      created := TimeStamp;
      END;
    END;

  catRec.parentID := intoCatRID.uniqueID;
  IF trcFDocCtrl
  THEN BEGIN
    ExtObjName (catRec, objName);
    WRITE ('   adding catRID for ',objName,', id is ',catRec.selfID:1,
             ', parent is ',catRec.parentID:1);
    END;
  IF dVolHdl^^.fsVersion < 17 THEN catRec.props[iconPassWd] := FALSE;  { reset password flag } {*** FI 332 ***}
  AddCatRec (catErr, dVolHdl, catRec, NOT (xferOp IN [opBackUp,opRebuild]), deCatRID);
  IF trcFDocCtrl THEN IF catErr > 0
  THEN WRITELN (': err is ',catErr:1,', catRec not added')
  ELSE BEGIN
    WRITELN (': new id is ',catRec.selfID:1);
    IF err < 0 THEN WRITELN ('   AddCatRec WARNING: ',err:1);
    END;
  IF (catErr = 2) AND (xferOp IN [opBackUp,opRebuild])
  THEN BEGIN
    IF trcFDocCtrl THEN WRITE ('   duplicates: ');
    catErr := 0;
    deCatRID.uniqueID := catRec.selfID;
    deCatRID.fatherID := catRec.parentID;
    IF NOT (catRec.objKind IN containerSet)
    THEN BEGIN
      GetCatRec(otherErr, dVolHdl, deCatRID, oldCatRec);  { Get dest obj catRec   }
      IF otherErr <= 0
      THEN BEGIN
        IF trcFDocCtrl THEN WRITELN ('old modified is ',oldCatRec.modified:1,
                                     ', new modified is ',catRec.modified:1);
        IF (catRec.modified > oldCatRec.modified)
        OR ((catRec.modified <> oldCatRec.modified)
            AND ((oldCatRec.modified = 0) OR (oldCatRec.modified = nullInt4)))
        THEN BEGIN                      { Object on diskette is newer, delete old one }
          IF trcFDocCtrl THEN WRITELN ('   deleting old version');
          IF ShredObj (dVolHdl, deCatRID, FALSE, TRUE) THEN;
          AddCatRec (catErr, dVolHdl, catRec, FALSE, deCatRID);
          END
        ELSE GOTO 99;                   { Skip this outdated object }
        END;
      END;
    END;
  IF catErr > 0
  THEN BEGIN
    CheckErr (810, catErr, dVolHdl);
    AbortXfer;
    END;
  intoCatRID := deCatRID;
  FlushCat (dVolHdl);
  END;

  { Xfer the object }
CheckAbort;
IF trcFDocCtrl THEN WRITELN ('   object type: ',catRec.objKind:1);
CASE catRec.objKind OF
  docKind,                                    { The object is a document   }
  docPad:  BEGIN
      IF (catRec.created >= sinceDate)
      OR ((catRec.modified >= sinceDate)
          AND (catRec.modified <> 0))         { *** OS inits to 0 ***}
      THEN BEGIN
        DupDoc (err, sCatRID, deCatRID, sVolHdl, dVolHdl, copyOp, xferOp, diskCt, split);
        sVolHdl := sDevHdl^^.volHdl;
        dVolHdl := dDevHdl^^.volHdl;
        IF err > 0
        THEN BEGIN
          AbortXfer;
          END;

        END
      ELSE BEGIN                        { opBackup AND modified < sinceDate }
        err := fTooOld;
        IF trcFDocCtrl THEN WRITELN ('   deleting catRID for ',objName,', id is ',
                                     catRec.selfID:1,', parent is ',catRec.parentID:1);
        DelCatRec (catErr, dVolHdl, deCatRID);
        END;
      END;

  calcKind,
  computerKind,
  comp2Kind,
  clockKind,
  printKind,
  toolKind: BEGIN                              { The object is a tool       }
      IF  (catRec.created >= sinceDate)        { Tools are never 'modified' }
      THEN BEGIN
        DupTool (err, catRec.toolID, sCatRID, deCatRID, sVolHdl, dVolHdl,
                (xferOp=opMove), diskCt, xferOp, FALSE);
        sVolHdl := sDevHdl^^.volHdl;
        dvolHdl := dDevHdl^^.volHdl;
        CASE err OF
          fNoErr: ;

          fOneTool: BEGIN
             IF trcFDocCtrl THEN WRITELN ('   deleting catRID for ',objName,', id is ',
                                          catRec.selfID:1,', parent is ',catRec.parentID:1);
             DelCatRec (catErr, dVolHdl, deCatRID);{ Don't shred, will delete codefiles}
             CheckErr (811, catErr, dVolHdl);
             AbortXfer;
             END;

          OTHERWISE BEGIN
             AbortXfer;
             dvolHdl := dDevHdl^^.volHdl;
             END;
          END;
        END
      ELSE BEGIN                        { opBackup AND modified <= sinceDate }
        err := fTooOld;
        IF trcFDocCtrl THEN WRITELN ('   deleting catRID for ',objName,', id is ',
                                     catRec.selfID:1,', parent is ',catRec.parentID:1);
        DelCatRec (catErr, dVolHdl, deCatRID);
        END;
      END;

  folderPad,                                  { The object is a container  }
  inBox1Kind,
  inbox2Kind,
  outBox1Kind,
  outBox2Kind,
  letterKind,
  letterPad,
  folderKind: BEGIN
              MakeFolder (err, dVolHdl, deCatRID, sVolHdl, sCatRID);
              XferContents (sCatRID.uniqueId, deCatRID);
              END;

  diskKind,                                   { The object is a disk       }
  disk1Kind,
  disk2Kind,
  drawerKind,                                 { internal hard disk         }
  profileKind:  BEGIN
      IF sinceDate = nullInt4
      THEN BEGIN                { Xfer non-cataloged objects, ignore trash }
        objPathname := CONCAT('-',sVolHdl^^.devHdl^^.nameHdl^^,'-{T11}obj');
        Quick_Lookup (err, objPathname, qInfo);
        IF err <= 0
        THEN BEGIN
          IF NOT ItWillFit (ToolSize(sVolHdl,11,NIL,dtm,dtc),dVolHdl)
          THEN IF GetNextDiskette (err, dDevHdl, sVolHdl, diskCt, xferOp)
            THEN BEGIN
              dVolHdl := dDevHdl^^.volHdl;
              ParamAlert (sUserVolName,sVolHdl^^.devHdl^^.userNmHdl^^,dVolHdl^^.devHdl^^.userNmHdl^^);
              WaitAlert (flrAlert, 236);
              END;
          IF err <=0
          THEN DupTool (err, 11, sCatRID, deCatRID, sVolHdl, dVolHdl, FALSE, diskCt, xferOp, FALSE);
          IF err > 0 THEN AbortXfer;
          END;
        END;
      XferContents (idDisk, deCatRID);        { Xfer the cataloged objects }
      END;

  OTHERWISE CheckErr (858, ORD(catRec.objKind), NIL);
  END;

99:
IF trcFDocCtrl THEN WRITELN ('   exit XferObj: err = ',err:1,
                             ', new obj: ',intoCatRID.uniqueID:1);
END;

{**************************************************************************}

{$S flrDm }

PROCEDURE XferObject {VAR err: INTEGER; sCatRID: TcatRID; dParent: IdType;
                   sVolHdl, dVolHdl: TentryHdl; excludeUnfiled: BOOLEAN;
                   move: BOOLEAN; splitflag,joinflag: BOOLEAN; VAR diskCt: INTEGER;
                   VAR newCatRID: TcatRID; docgone: BOOLEAN};

VAR catRec:      TcatRec;
    dDevHdl:     TentryHdl;
    intoCatRID:  TcatRID;
    sDevHdl:     TentryHdl;
    xferOp:      TuserOp;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('XferObject');

sDevHdl := sVolHdl^^.devHdl;       { Save device handles }
dDevHdl := dVolHdl^^.devHdl;
volIsGone := FALSE;           {Set global variable that disk has not changed}

intoCatRID.fatherID := idNil;
intoCatRID.uniqueID := dParent;
IF (sVolHdl = dVolHdl) AND move
THEN BEGIN                                      { No bits are being moved    }
  GetCatRec(err, sVolHdl, sCatRID, catRec);     { Get obj catRec             }
  catRec.parentID := dParent;
  UpdCatRec (err, sVolHdl, sCatRID, catRec);
  END
ELSE BEGIN
  BindCopyDataSeg;
  IF move
  THEN xferOp := opMove
  ELSE xferOp := opCopy;
  XferObj (err, sCatRID, intoCatRID, sVolHdl, dVolHdl, excludeUnfiled, xferOp,
           splitflag OR joinflag, diskCt, nullInt4);
  diskgone := volIsGone;   {reset whether disk has been ejected}
  IF splitflag OR joinflag THEN BEGIN
    sVolHdl := sDevHdl^^.volHdl;
    dVolHdl := dDevHdl^^.volHdl;
    END;
  IF volIsGone
  THEN IF splitflag
       THEN DismountVol(dDevHdl^^.device,TRUE,FALSE)
       ELSE IF joinFlag THEN DismountVol(sDevHdl^^.device,TRUE,FALSE);
  UnbindCopyDataSeg;
  END;

IF err <= 0
THEN BEGIN
  err := 0;
  newCatRID := intoCatRID;
  IF dDevHdl^^.volHdl <> NIL THEN AdjustParentObjSize (dVolHdl, dParent, TRUE);
  IF (sDevHdl^^.volHdl <> NIL) AND (dParent <> sCatRID.fatherID)
  THEN AdjustParentObjSize (sVolHdl, sCatRID.fatherID, TRUE);
  END;

IF trcFDocCtrl THEN WRITELN ('   exit XferObject: err =',err:1);
END;

{**************************************************************************}

{$S flrDskIn }

PROCEDURE XferSysFiles {VAR err: INTEGER, sVolHdl: TentryHdl;
                        VAR dVolHdl: TentryHdl; xferOp: TuserOp;
                        bootOnly: BOOLEAN; VAR diskCt: INTEGER;
                        split: BOOLEAN};

LABEL 33, 34, 66, 99;

VAR blocksAllocated: LONGINT;
    catRecPtr:    PtrCatRec;
    dataSize:     LONGINT;
    devName:      E_Name;
    dDevHdl:      TentryHdl;
    dDevPathname: Pathname;
    dfInfo:       Fs_Info;
    dDfPathname:  Pathname;
    dDfRefnum:    INTEGER;
    dfName:       E_Name;
    dfRestart:    E_Name;
    osErr:        INTEGER;
    prefix:       E_Name;
    schedErr:     INTEGER;
    sDevHdl:      TentryHdl;
    sDevPathname: Pathname;
    sDfInfo:      Fs_Info;
    sDfPathname:  Pathname;
    sUserVolName: FMaxStr;
    toolCatRID:   TcatRID;


  PROCEDURE CheckAbort;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF Abort
  THEN BEGIN
    IF err <> fUserAbort
    THEN BEGIN
      WaitAlert (flrAlert, 263);
      err := fUserAbort;
      END;
    IF trcFDocCtrl THEN WRITELN ('   exit XferSysFiles: user aborted');
    EXIT (XferSysFiles);
    END;
  END;

  PROCEDURE CheckErr (location, theErr: INTEGER; volHdl: TentryHdl);
  VAR devHdl: TentryHdl;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF theErr > 0
  THEN BEGIN
    IF volHdl <> NIL
    THEN devHdl := volHdl^^.devHdl
    ELSE devHdl := NIL;
    IF ErrorFound (warnError, location, theErr, devHdl) THEN;
    IF trcFDocCtrl THEN WRITELN ('   exit XferSysFiles: aborted - theErr = ',theErr:1);
    err := fNotXfered;
    EXIT (XferSysFiles);
    END;
  END;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('XferSysFiles: ',sVolHdl^^.devHdl^^.nameHdl^^,
                             ' to ',dVolHdl^^.devHdl^^.nameHdl^^,
                             ' bootOnly is ',bootOnly);

sDevHdl := sVolHdl^^.devHdl;       { Save device handles }
dDevHdl := dVolHdl^^.devHdl;

dfRestart := '';
err := 0;
prefix := '';
dDevHdl := dVolHdl^^.devHdl;
dDevPathname := CONCAT('-',dVolHdl^^.devHdl^^.nameHdl^^);
sDevPathname := CONCAT('-',sVolHdl^^.devHdl^^.nameHdl^^);
GetObjName (sVolHdl, diskCatRID, sUserVolName);
Lookup (osErr, dDevPathname, dfInfo);   {*** FI 229 ***}
CheckErr (863, osErr, dVolHdl);
dataSize := dfInfo.dataSize;

Reset_Catalog (osErr, sDevPathname);
CheckErr (863, osErr, sVolHdl);         {*** duplicate error number ****}
REPEAT
  Get_Next_Entry (osErr, prefix, dfName);
  UNTIL (osErr > 0) OR (dfName[1] <> '{');
IF osErr <> 848 THEN CheckErr (865, osErr, sVolHdl);

BindCopyDataSeg;
WHILE osErr <= 0
DO BEGIN
33:
  CheckAbort;
  IF trcFDocCtrl THEN WRITELN ('   found ',dfName);
  sDfPathname := CONCAT (sDevPathname,'-',dfName);
  dDfPathname := CONCAT (dDevPathname,'-',dfName);
  Lookup (osErr, sDfPathname, sDfInfo);
  CheckErr (865, osErr, sVolHdl);
  IF (sDfInfo.fType IN [undefined, MDDFFile, rootCat, freeList, badBlocks,
                        pipe, bootFile, raMap, killedObject])
  THEN err := 0                       { Some kinds of files aren't copied }
  ELSE BEGIN
    IF trcFDocCtrl THEN WRITE ('   copying ');
    FCopyDiskFile (err, sDfPathname, dDfPathname, sVolHdl, dVolHdl, diskCatRID, diskCatRID,
                   copyDsAddr, copyDsMemSize, fcDocMove, xferOp, osErr, diskCt,
                   FALSE, FALSE);  {using diskCatRID instead of Nil}
  END;
  CheckAbort;

  IF trcFDocCtrl THEN WRITELN (': err = ',err:1,', osErr = ',osErr:1);
  IF err > 0 THEN                    { If err, process according to osErr}
66:
  CASE osErr OF
    0,                                { Diskfile copied OK                }
    1,                                { Diskfile being written to by another}
    890: err := 0;                    { Diskfile already exists           }


    854,855,826,882,848,1146,-1146:
        BEGIN                         { Out of disk space, get next disk  }

        IF NOT FitOnDisk (sDfInfo.pSize DIV dataSize, dDevHdl) {*** FI 229 ***}
        THEN BEGIN
          ArgAlert (1, dfName);
          IF AskAlert (flrAlert, 311) = 1   { Tell user won't fit, continue? }
          THEN BEGIN
            err := aborted;
            EXIT (XferSysFiles);
            END;
          GOTO 34;
          END;

        dfRestart := dfName;          { Save name of first diskfile xfered}
        IF GetNextDiskette (err, dDevHdl, sVolHdl, diskCt, xferOp)
        THEN BEGIN
          dVolHdl := dDevHdl^^.volHdl;
          ParamAlert (sUserVolName,sVolHdl^^.devHdl^^.userNmHdl^^,
                      dVolHdl^^.devHdl^^.userNmHdl^^);
          WaitAlert (flrAlert, 236);  { 'Backing up...'                   }
          Reset_Catalog (osErr, sDevPathname);  { Reposition in case disk was repaired }
          IF osErr <= 0 THEN Get_Next_Entry (osErr, dfRestart, dfName);
          CheckErr (865, osErr, sVolHdl);
          GOTO 33;                    { Try to copy the diskfile again    }
          END
        ELSE BEGIN                    { User aborted                      }
          dVolHdl := dDevHdl^^.volHdl;
          GOTO 99;
          END;
        END;

    950,951: BEGIN                    { Diskfile inuse, just allocate space}
        IF dbgFiler THEN WRITELN ('Unexpected diskfile in use: copying ',sDfPathname);
        err := fNotXfered;            { Just in case we find an os error  }
        Make_File (osErr, dDfPathname, max_Label_Size);
        IF osErr <= 0 THEN Open (osErr, dDfPathname, dDfRefnum, [dWrite, append]);
        IF osErr <= 0
        THEN BEGIN
          blocksAllocated := sDfInfo.pSize DIV sDfInfo.lpSize;
          IF (osErr <= 0) AND (blocksAllocated > 0)
          THEN Allocate (osErr, dDfRefnum, FALSE, blocksAllocated, blocksAllocated);
          Close_Object (osErr, dDfRefnum);
          END;
        err := 0;
        END;

    OTHERWISE  BEGIN
        IF dbgFiler THEN WRITELN ('Unexpected error in XferFiles: ',osErr:1,' copying ',sDfPathname);
        IF err = fceCantRead
        THEN ArgAlert (1, sVolHdl^^.devHdl^^.userNmHdl^^)
        ELSE ArgAlert (1, dDevHdl^^.userNmHdl^^);
        StopAlert (flrAlert, 218);
        UpdateAll;

        IF err = fceCantWrite
        THEN BEGIN
          IF GetNextDiskette (err, dDevHdl, sVolHdl, diskCt, xferOp)
          THEN BEGIN
            dVolHdl := dDevHdl^^.volHdl;
            Reset_Catalog (osErr, sDevPathname);
            IF osErr <= 0 THEN Get_Next_Entry (osErr, dfRestart, dfName);
            CheckErr (865, osErr, sVolHdl);
            GOTO 33;
            END
          ELSE BEGIN
            dVolHdl := dDevHdl^^.volHdl;
            GOTO 99;
            END;
          END
        ELSE BEGIN
          err := fNotXfered;
          GOTO 99;
          END;

        END;
    END;
34:
  REPEAT
    Get_Next_Entry (osErr, prefix, dfName);
    UNTIL (osErr > 0) OR (dfName[1] <> '{');
  END;
IF osErr = 848 THEN osErr := 0;

99:
UnbindCopyDataSeg;

IF trcFDocCtrl THEN WRITELN ('   exit XferSysFiles: diskCt = ',diskCt:1,', err = ',err:1);
END;

{**************************************************************************}

{$S flrCopy }

PROCEDURE ZapPassword {VAR fileName: Pathname};
VAR err:       INTEGER;
    fsParams:  UT_Parmt;

BEGIN
IF trcFDocCtrl THEN WRITELN ('ZapPassword: fileName is ',fileName);

WITH fsParams DO BEGIN
  gp_parm  := 0;
  command  := xfer_Passwd;
  path     := fileName;
  password := '';
  op       := pswWrite;
  END;
FS_Utilities (err, fsParams);

IF trcFDocCtrl THEN WRITELN ('   exit ZapPassword: err = ',err:1);
END;


{

 10-Jan-83  A4 Release
 26-Jan-83  ToolOnDisk: added call to ObjInCat - fixed null Preference tool name.
  4-Feb-83  SonTerminated: added TopWindow check to limit 'tool crashed' msg to top window.
  8-Feb-83  SonTerminated: added call to PrCleanup.
            StartDoc: added TextFont/TextFace calls before drawing in window.
            TellUserWhy: added HideFolder to 'aborted' arm of CASE stmt.
 10-Feb-83  A5 Release
 11-Feb-83  ToolCantInit: changed 'msg' type from TParamAlert to STR255.
            SendFilerEvent: added aUserAbort arm to CASE stmt.
 24-Feb-83  DummyDisplay: added docRect.top calculation (FI136)
            SendFilerEvent: added 'cantRead' to CASE stmt (FI139)
 28-Feb-83  SonTerminated: added 'whoDied' to UNTIL check (FI140)

 }

END.
