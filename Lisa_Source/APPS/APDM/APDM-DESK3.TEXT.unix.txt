{apdm/desk3.text 5-Dec-83} { Copyright 1983, Apple Computer Co.}

{This file contains the procedures used to set up, display and monitor a dialog box.
 It is called exclusively by the routines in apdm/desk4.
                                                 - Ken Krugler}

{The data structures used by these routines are declared at the end of the standard type
 declarations in apdm/desk.}

{The following routines all draw the appropriate object from the info in PanelRec.
 The correct way to use these routines is to set the QD bottleneck procs to nil,
 start up picture recording, draw every panel (with DrawPanel, which will call one
 of these routines), close the picture and call UseDiBox.  UseDiBox will then handle
 events like keydown, mouseDown, etc., changing the panel states accordingly.  Any
 panel which has its state (visible/invisible) changed has its changed flag set to true.
 UseDiBox will then call ShowDiBox, which first sets the QD procs to be its own special
 procs, then replays the dialog picture.  If the panel being drawn by the replaced QD
 proc has changed, it is drawn and its changed flag is reset, otherwise the next panel
 is processed.  We know which panel corresponds to what QD proc call as the panels were
 all originally drawn in a linear order, which will match the ordering of the QD calls}

{DrawDiLabel, DrawDiButton, DrawDiField, DrawDiLine, DrawDiRect}

{******** Modification Log ********)
{First skeleton written : 12/2/83}
{Filled out ShowAttributes to work with newly defined data structures : 12/3/83}
{Added diLine, diRect, made it actually put up a box (finally) : 12/4/83}
{Broke out routines that do dialog box specific stuff, into apdm/desk4 : 12/5/83}
{Does real picture recording : 12/5/83}
{General extension, first object specific (disk/folder/doc) panels : 12/10/83}
{Fixed problem with heap crash in QD pictures : 12/13/83}
{Modified QD picComment code to reference only a handle : 12/27/83}
{Added field editor code : 1/10-16/84}
{Changed field framing on drawPicture : 3/4/84}
{SelDiField change for use in desk4, DoDiUpdate fixes half-button problem : 3/14/84}

{$S flrDiBox}

{**************************************************************************************************}
FUNCTION AddDiPanel {*  : PanelHandle *};

{Create a new panel, link with the panel list and return it}

VAR
   tempPanel   : PanelHandle;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[AddDiPanel], entry');

tempPanel := NewDiPanel (diBox.numPanels);    { get a new panel }
tempPanel^^.prev := diBox.lastPanel;          { set up back pointer to last panel }
diBox.lastPanel^^.next := tempPanel;          { set up the forward pointer }
diBox.lastPanel := tempPanel;                 { reset last panel pointer }
AddDiPanel := tempPanel;

IF trcDialog THEN WRITELN ('   [AddDiPanel], exit');
END; {of PROC AddDiPanel}

{**************************************************************************************************}
PROCEDURE ClearDiField {* thePanel: PanelHandle *};
{resets an edit field, erases inside the box}

VAR
   err      : INTEGER;
   pnState  : PenState;

BEGIN
IF (thePanel = nil) THEN
   EXIT(ClearDiField);
GetPenState (pnState);
PenSize (1,1);
PenPat (black);
ClearField (thePanel^^.info.fieldHdl, thePanel^^.info.fStateHdl, err);
ClipRect (thePanel^^.outline);
EraseRect (thePanel^^.outline);
FrameRect (thePanel^^.outline);
SetPenState (pnState);

END; {of PROCEDURE ClearDiField}

{**************************************************************************************************}
PROCEDURE ClipDiName {* VAR name: FmaxStr; maxSize: INTEGER; isQuoted: BOOLEAN *};

{clips the name to length maxSize.  If greater, chops name to maxSize-3 and adds three '.'}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[ClipDiName], entry');

IF (LENGTH(name) <= maxSize) OR (maxSize < 6) THEN
   EXIT (ClipDiName);

IF (isQuoted) THEN
   name := COPY (name, 1, maxSize-4)      { need space for the trailing ..." }
ELSE
   name := COPY (name, 1, maxSize-3);
name := CONCAT (name,'...');
IF (isQuoted) THEN
   name := CONCAT (name,'"');

IF trcDialog THEN WRITELN ('[ClipDiName], exit');
END; {of PROC ClipName}

{**************************************************************************************************}
PROCEDURE CloseDiBox;

{make the linked list of panels a circular one, draw all of the panels to set up the picture,
 then show the dialog window on the screen for the first time and reset the menu bar.}

VAR
   thePanel    : PanelHandle;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[CloseDiBox], entry');

diBox.firstPanel^^.prev := diBox.lastPanel;
diBox.lastPanel^^.next := diBox.firstPanel;

StartDiPic;                   { start recording the picture of the dialog box }
thePanel := diBox.firstPanel;
DrawPanel (thePanel);
thePanel := diBox.firstPanel^^.next;
WHILE (thePanel <> diBox.firstPanel) DO
   BEGIN
   DrawPanel (thePanel);
   thePanel := thePanel^^.next;
   END; {of WHILE block}
StopDiPic;

{Initialize the dialog box (on the screen)}
DialogHeight (diBox.height, FALSE{no update event});  { draw the dialog box }
HiLiteMenu(0);                                        { remove the highliting of File/Print menu }

diBox.drawMode := DiNormal;

IF trcDialog THEN WRITELN ('   [CloseDiBox], exit');
END; {of PROC CloseDiBox}

{**************************************************************************************************}
PROCEDURE DiCommandKey;

{needs to handle the Apple-x (cut, paste, etc) for scrap...Actually should put up an alert for
 'Cant do cut/paste/copy with passwords...', then ignore it}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

IF (diBox.curSel = nil) THEN
   StopAlert (flrAlert, 329)           { need a selection before typing }
ELSE
   StopAlert (flrAlert, 330);          { no command keys may be used to edit a password field }

END; {of PROC DiCommandKey}

{**************************************************************************************************}
PROCEDURE DiFieldEdit;

{ called when a button down occurs in an editable field in the dialog box }
{ assumes that the grafport is set correctly }

VAR
   nbrHood     : Rect;
   pt          : Point;
   tempInfo    : PanelRec;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

pt := inDiBox;
ClipRect (diBox.curSel^^.outline);

tempInfo := diBox.curSel^^.info;

IF curEvent.shiftKey THEN
   GrowSel(pt,tempInfo.fieldHdl,tempInfo.fStateHdl,nbrHood)   { extend the selection }
ELSE
   BEGIN
   HilightSel(tempInfo.fieldHdl,tempInfo.fStateHdl,FALSE);   { turn off current selection }
   CASE clickCount OF
      1: Select(pt,tempInfo.fieldHdl,tempInfo.fStateHdl,nbrHood,timeoutInterval);
      2: SelectWord(pt,tempInfo.fieldHdl,tempInfo.fStateHdl,nbrHood,timeoutInterval);
      OTHERWISE
         SelectAll(tempInfo.fieldHdl,tempInfo.fStateHdl,timeoutInterval);
      END;
   END;

{ grow the selection while the button is down }
WHILE StillDown DO
   IF clickCount < 3 THEN
      BEGIN
      GetMouse(pt);
      IF NOT PtInRect(pt,nbrHood) THEN
         GrowSel(pt,tempInfo.fieldHdl,tempInfo.fStateHdl,nbrHood);
      END;

{ Set the timeout to blink the caret if appropriate }
IF (tempInfo.fStateHdl^^.select.tyHilight = tyHiInvert) THEN
   timeoutInterval := noTimeout
ELSE
   StartBlink(timeoutInterval);

ObscureCursor;
SetTimeout(timeoutInterval);

IF (NOT tempInfo.fStateHdl^^.valid) THEN
   BEGIN
   {make sure it's re-displayed}
   DrawField (tempInfo.fieldHdl, tempInfo.fStateHdl, TRUE{show selection}, TRUE{erasing});
   FrameRect (diBox.curSel^^.outline);
   END;

{re-stuff the changed info panel}
diBox.curSel^^.info := tempInfo;

END; {of PROC DiFieldEdit}

{**************************************************************************************************}
PROCEDURE DispHandle {* h: Handle *};
{First checks to see if the handle is Nil, otherwise disposes of it (frees up the heap)}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

IF (h = nil) THEN
   EXIT(DispHandle);
DisposeHandle (h);

END; {of PROC DispHandle}

{**************************************************************************************************}
PROCEDURE DiTextKey;
{handles the key processing for the dialog box. If typing performance becomes a problem, create a
 global field edit structrue variable for the password panel, thus eliminating the need for the
 tempInfo record and accompanying assignments}

CONST
   ccUnknown   = 0;
   ccEnter     = 3;    { enter char code }
   ccLeft      = 28;   { left arrow char code }
   ccRight     = 29;   { right arrow char code }
   ccUp        = 30;   { up arrow char code }
   ccDown      = 31;   { down arrow char code }

VAR
   err         : INTEGER;
   tempInfo    : PanelRec;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};


IF (diBox.curSel = nil) THEN
   BEGIN
   StopAlert(flrAlert,329);  { no selection for typing ... }
   EXIT (DiTextKey);
   END
ELSE IF (diBox.curSel^^.info.tag <> diField) THEN
   BEGIN
   StopAlert (flrAlert, 329);
   EXIT (DiTextKey);
   END;

{now know that we have a valid panel, so start processing}

tempInfo := diBox.curSel^^.info;

err := 0;
CASE ORD(curEvent.ascii) OF

   ccBS:       { backspace - comes in a variety of flavors }
      BEGIN
      IF curEvent.appleKey THEN
         IF curEvent.shiftKey THEN
            ForwardWord(tempInfo.fieldHdl,tempInfo.fStateHdl,err)
         ELSE
            BackWord(tempInfo.fieldHdl,tempInfo.fStateHdl,err)
      ELSE
         IF curEvent.shiftKey THEN
            ForwardSpace(tempInfo.fieldHdl,tempInfo.fStateHdl,err)
         ELSE
            BackSpace(tempInfo.fieldHdl,tempInfo.fStateHdl,err);
      END;

   ccUnknown,ccHT,ccLeft,ccRight,ccUp,ccDown:
      Exit(DiTextKey);   { ignore these }

   ccEnter, ccCR:
      IF (diBox.curSel = diPassword.passwdPanel) THEN        {enter, <CR> => clicking enter button on dialog box}
         DoDiBtn(diPassword.enterBtnPanel^^.info.buttonProc)
      ELSE
         EXIT(DiTextKey);

   ccEsc:      { clear => erase contents of the field }
      BEGIN
      ClearField(tempInfo.fieldHdl,tempInfo.fStateHdl,err);
      END;

   OTHERWISE   { character to be inserted into the field }
      BEGIN
      InsCh(curEvent.ascii,tempInfo.fieldHdl,tempInfo.fStateHdl,err);
      END;
   END;


IF (err = 0) THEN
   BEGIN
   InsetRect (diBox.curSel^^.outline, 1, 1);
   ClipRect (diBox.curSel^^.outline);
   InsetRect (dibox.curSel^^.outline, -1, -1);
   DrawField (tempInfo.fieldHdl, tempInfo.fStateHdl, TRUE{selection}, TRUE{erasing});

   { Set the timeout to blink the caret if appropriate }
   IF (tempInfo.fStateHdl^^.select.tyHilight = tyHiInvert) THEN
      timeoutInterval := noTimeout
   ELSE
      StartBlink(timeoutInterval);
   ObscureCursor;
   SetTimeout(timeoutInterval);

   IF (tempInfo.fieldHdl^^.curLen > 0) THEN
      BEGIN
      CaretOn(tempInfo.fieldHdl,tempInfo.fStateHdl);           { keep the caret on while typing }
      END;
   END
ELSE
   BEGIN
   FldEditError(err);
   ClearDiField (diBox.curSel);
   SelDiField (diBox.curSel, TRUE{draw it});
   END;

{now restore all the changed information to the dialog box panel}
diBox.curSel^^.info := tempInfo;

END; {of PROC DiTextKey}

{**************************************************************************************************}
{the next Di<XX>Proc routines are dialog specific procedures that are substituted for the standard
 QD bottleneck routines}
{**************************************************************************************************}
PROCEDURE DiCommentProc (kind, dataSize: INTEGER; dataHandle: QDHandle);
{Note: In this case dataHandle references yet another handle, this time the real one to the panel
 record}

LABEL 99;

TYPE
   TpnlHdlPtr  = ^PanelHandle;
   TpnlHdlHdl  = ^TpnlHdlPtr;

VAR
   tempBound   : RgnHandle;
   tempInfo    : PanelRec;
   tempPanel   : PanelHandle;
   handlehdl   : TpnlHdlHdl;

   {---------------------------------------------------------------------------------------------}
   PROCEDURE PanelSetup;

   BEGIN
   doPanel := TRUE;
   ClipRect(tempPanel^^.outline);
   EraseRect(tempPanel^^.outline);
   END; {of PROC PanelSetup}
   {---------------------------------------------------------------------------------------------}

BEGIN
handleHdl := Pointer(ORD(dataHandle));
tempPanel := handleHdl^^;
tempBound := tempPanel^^.bound;

IF (kind = PicLParen) THEN
   BEGIN
   CASE diBox.drawMode OF
      DiNormal:
         BEGIN
         IF (NOT (tempPanel^^.changed AND tempPanel^^.visible)) THEN
            GOTO 99;
         doPanel := TRUE;
         IF (tempPanel^^.selected) THEN
            CASE (tempPanel^^.info.tag) OF
               diButton:
                  {do invert, reframe after the right picture comment}
                  doPanel := FALSE;
               diField:
                  SelDiField (tempPanel, TRUE);
               END; {of CASE block}
         IF (doPanel) THEN
            PanelSetup;
         END; {of CASE ITEM DiNormal}

      DiUpdate:
         BEGIN
         {assumes no selected panels}
         IF (NOT (tempPanel^^.visible)) THEN
            GOTO 99;
         PanelSetup;
         END; {of CASE ITEM DiUpdate}

      DiErase:
         BEGIN
         IF (NOT (tempPanel^^.changed AND (NOT tempPanel^^.visible))) THEN
            GOTO 99;
         PanelSetup;
         {only want to erase the panel}
         doPanel := FALSE;
         END;
      END; {of CASE block}
   END {of IF THEN block}
ELSE IF (kind = PicRParen) THEN
   BEGIN
   WITH tempPanel^^ DO
      BEGIN
      {button inverting}
      IF ((info.tag = diButton) AND selected) THEN
         IF ((diBox.drawMode = DiNormal) AND changed AND visible) THEN
            BEGIN
            ClipRect(outline);
            InvertRgn(tempBound);
            PenSize (info.btnPenW, info.btnPenH);
            PenPat (black);
            FrameRgn (tempBound);
            END; {of IF THEN block}
      {now set changed flag only if mode indicates that panel has been updated}
      CASE (diBox.drawMode) OF
         DiNormal, DiUpdate: IF visible THEN changed := FALSE;
         DiErase: IF (NOT visible) THEN changed := FALSE;
         END; {of CASE block}
      END; {of WITH block}
   doPanel := FALSE;
   END {of ELSE IF THEN block}
ELSE
   BEGIN END;

99:
END; {of PROC DiCommentProc}

{**************************************************************************************************}
PROCEDURE DiLineProc (newPt: Point);

BEGIN
IF doPanel THEN
   StdLine (newPt);
END;

{**************************************************************************************************}
PROCEDURE DiRectProc (verb: GrafVerb; r: rect);

BEGIN
IF doPanel THEN
   StdRect (verb, r)
END;

{**************************************************************************************************}
PROCEDURE DiRRectProc (verb: GrafVerb; r: rect; ovalWidth, ovalHeight: INTEGER);

BEGIN
IF doPanel THEN
   stdRRect (verb, r, ovalWidth, ovalHeight);
END;

{**************************************************************************************************}
PROCEDURE DiTextProc (count: INTEGER; textAddr: QDPtr; numer, denom: Point);

BEGIN
IF doPanel THEN
   StdText (count, textAddr, numer, denom);
END;

{**************************************************************************************************}
{End of Di<xxx>Proc routines}
{**************************************************************************************************}
PROCEDURE DoDiBtnDown;

VAR
   err      : INTEGER;
   wasHit   : BOOLEAN;     { TRUE => on previous button-still-down loop there was a selected panel }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[DoDiBtnDown], entry: btn at ',curEvent.where.h:1,'/',curEvent.where.v:1);

inDiBox := curEvent.where;
IF (diBox.curSel <> nil) THEN
   IF (diBox.curSel^^.info.tag = diField) THEN
      {we were editing a field before button-down, so do some consistancy checking}
      BEGIN
      IF PtInRgn(inDiBox, diBox.curSel^^.bound) THEN
         {we're inside of the same box as before, so just edit}
         BEGIN
         DiFieldEdit;
         EXIT (DoDiBtnDown);
         END
      ELSE
         {we've button-down outside of the box, so abort from field editing}
         BEGIN
         IF (diBox.curSel^^.info.active) THEN
            BEGIN
            ExitField (diBox.curSel^^.info.fieldHdl, dibox.curSel^^.info.fStateHdl);
            diBox.curSel^^.info.active := FALSE;
            END;
         END;
      END;

{keep inverting buttons until not stilldown, then return hitDiPanel if inside a valid panel}
diBox.curSel := TestDiBox;
IF (diBox.curSel <> nil) THEN
   BEGIN
   diBox.curSel^^.selected := TRUE;
   IF (diBox.curSel^^.info.tag = diField) THEN
      {it happened, so set up a consistant field}
      BEGIN
      diBox.curSel^^.info.active := TRUE;
      ClearDiField (diBox.curSel);
      DiFieldEdit;
      END;
   END; {of IF THEN block}

IF trcDialog THEN WRITELN ('   [DoDiBtnDown], exit');
END; {of PROC DoDiBtnDown}

{**************************************************************************************************}
PROCEDURE DoDiBtnUp;
{called from DoBtnUpEvent (in Apdm/Desk), executes button code if a button is currently selected}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

IF (diBox.curSel <> nil) THEN
   CASE diBox.curSel^^.info.tag OF
      diButton:
         DoDiBtn (diBox.curSel^^.info.buttonProc);
      diField:
         BEGIN
         IF (NOT diBox.curSel^^.info.active) THEN
            {button up in a new field, so reset current selection and do nothing}
            BEGIN
            diBox.curSel := nil;
            END;
         END;
      diCheckBox:
         BEGIN
         END;
      END {of CASE block}
ELSE
   BEGIN
   {hmmm, current selection is nil, no button selection, let's see if we were editing the password}
   IF (diPassword.passwdPanel <> nil) THEN
      IF (diPassword.passwdPanel^^.info.fieldHdl^^.curLen <> 0) THEN
         {we were! act as though he hit the enter button, don't let him cheat}
         DoDiBtn(diPassword.enterBtnPanel^^.info.buttonProc);
   END; {of IF ELSE block}

END; {of PROC DoDiBtnUp}

{**************************************************************************************************}
PROCEDURE DoDiFinished {* reQueue: BOOLEAN *};

{terminates the dialog box, calls the terminating procedure}
{reQueue = TRUE => shouldn't have done GetEvent, so re-queue for the filer}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

IF (reQueue) THEN
   SendEvent(curEvent,filerProcess);   { re-queue the event for myself }
StopDiBox;
IF (diBox.finishProc <> nil) THEN
   DoDiBtn (diBox.finishProc);
END;

{**************************************************************************************************}
PROCEDURE DoDiUpdate;
{handles a folder update sent to the dialog folder}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF (curEvent.who <> dialogFolder) THEN
   BEGIN
   DoUpdateEvent;          { do the main Filer code for this event }
   EXIT (DoDiUpdate);
   END;

{when we redraw something it generates an undate event for us, so trap the re-draw after a re-draw
 situation}

BeginUpdate (dialogFolder);         { set the update visRgn }

WITH diBox DO
   BEGIN
   drawMode := DiUpdate;
   ShowDiBox;
   drawMode := DiNormal;
   END; {of WITH block}

EndUpdate (dialogFolder);           { restore normal visRgn }
ValidRect (diBox.outline);          { cancel all updates for this area }

ShowDiBtn (diPassword.enterBtnPanel, FALSE{not selected});
ShowDiBtn (diPassword.cancelBtnPanel, FALSE{not selected});
ShowDiBtn (diPassword.noPassBtnPanel, FALSE{not selected});

ResetPwdFields;                     { reset the password fields, etc. }

END; {of PROC DoDiUpdate}

{**************************************************************************************************}
PROCEDURE DrawDiButton {* VAR info: PanelRec; outline: rect *};

VAR
   buttonHeight   : INTEGER;
   buttonInfo  : FontInfo;
   tempStr     : FmaxStr;
   textHeight  : INTEGER;
   textStart   : Point;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[DrawDiButton], entry: text is ',info.buttontext^^);

PenNormal;
WITH info DO
   BEGIN
   TextFont (buttonfont);
   TextFace (buttonface);
   PenSize (btnPenW, btnPenH);
   buttonHeight := outline.bottom - outline.top;
   FrameRoundRect (outline, DiBtnW, DiBtnH);
   MoveTo (buttonLoc.h, buttonLoc.v);                 { set point so as text is drawn inside of box }
   GetStrg (buttontext, tempStr);                     { de-reference the string handle, copy to tempStr }
   IF trcDialog THEN WRITELN ('   Button ',tempStr,' at ',textStart.h:1,'/',textStart.v:1);
   DrawString (tempStr);
   END; {of WITH block}
PenNormal;

IF trcDialog THEN WRITELN ('[DrawDiButton], exit');
END; {of PROC DrawDiButton}

{**************************************************************************************************}
PROCEDURE DrawDiLabel {* VAR info: PanelRec; outline: rect *};
{ Draw a dialog box label into the dialog box picture }

VAR
   labelInfo   : FontInfo;
   tempStr     : FmaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[DrawDiLabel], entry: text is ',info.labeltext^^);

PenNormal;
WITH info DO
   BEGIN
   TextFont (labelfont);
   TextFace (labelface);
   GetFontInfo (labelInfo);
   MoveTo (outline.left, outline.bottom - labelInfo.descent); { set point so as text is drawn inside of box }
   GetStrg (labeltext, tempStr);                      { de-reference the string handle, copy to tempStr }
   DrawString (tempStr);
   END; {of WITH block}

IF trcDialog THEN WRITELN ('   [DrawDiLabel], exit');
END; {of PROC DrawDiLabel}

{**************************************************************************************************}
PROCEDURE DrawDiLine {* info: PanelRec; outline: Rect *};

{ Draw a dialog box line into the dialog box picture }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[DrawDiLine], entry');

WITH info DO
   BEGIN
   PenSize (linePen, linePen);
   PenPat (linePat);
   MoveTo (lineStart.h, lineStart.v);
   LineTo (lineStop.h, lineStop.v);
   END; {of WITH block}

IF trcDialog THEN WRITELN ('   [DrawDiLine], exit');
END; {of PROC DrawDiLine}

{**************************************************************************************************}
PROCEDURE DrawDiRect {* outline: rect *};
{ Draw a dialog box rectangle into the dialog box picture }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[DrawDiRect], entry');

PenNormal;
FrameRect (outline);

IF trcDialog THEN WRITELN ('   [DrawDiRect], exit');
END; {of PROC DrawDiRect}

{**************************************************************************************************}
PROCEDURE DrawPanel {* thePanel: PanelHandle *};

{stuffs the picture being formed with a left paren, the QD commands to draw the panel, and a right
 paren.  Point of order, the QDHandle of the left paren points to a copy of what handleHdl points
 to.  This value is the actual handle to the designated panel -- all this because PicComment mades
 a copy of the data structure that you pass it a handle to.}

TYPE
   TpanHdlPtr  = ^PanelHandle;
   TpanHdlHdl  = ^TpanHdlPtr;

VAR
   tempInfo    : PanelRec;
   tempRect    : rect;
   handlePtr   : TpanHdlPtr;
   handleHdl   : TpanHdlHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[DrawPanel], entry');

handlePtr := Pointer(@thePanel);
handleHdl := Pointer(@handlePtr);

{put a left paren comment at the start of the panel draw routines}
PicComment (picLParen, 4{size of a handle}, Pointer(ORD(handleHdl)));

tempInfo := thePanel^^.info;
tempRect := thePanel^^.outline;

CASE thePanel^^.info.tag OF
   diLabel:
      DrawDiLabel (tempInfo, tempRect);
   diButton:
      DrawDiButton (tempInfo, tempRect);
   diCheckBox:
      BEGIN END;
   diLine:
      DrawDiLine (tempInfo, tempRect);
   diRect, diField:
      DrawDiRect (tempRect);
   OTHERWISE
      BEGIN
      IF trcDialog THEN WRITELN ('   Cant handle tag type ',ORD(thePanel^^.info.tag));
      END;
   END; {of CASE block}

{now close up the panel picture definition with a right paren comment}
PicComment (picRParen, 4{size of a handle}, Pointer(ORD(handleHdl)));

 IF trcDialog THEN WRITELN ('   [DrawPanel], exit');
 END; {of PROCEDURE DrawPanel}

{**************************************************************************************************}
{$S dmMain }    { a first call to process most events }
FUNCTION InDialog {* : BOOLEAN *};

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

InDialog := diBox.active;
END; {of FUNC InDialog}

{**************************************************************************************************}
{$S flrDiBox}
PROCEDURE InitDiBox;

{Set up the variables used for building a dialog box.
 (Note: First panel reference number is set to 1)}

CONST
   MenuWidth = 10;      { height of the menu bar }
   DialogWidth = 100;   { default height of the dialog box }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[InitDiBox], entry');

WITH diBox DO
   BEGIN
   numPanels := 0;                              { set the panel reference number }
   height := 0;                                 { initial height of box = 0 }
   drawMode := DiNormal;
   shot := Nil;                                 { start with no picture }
   obj := Nil;                                  { start with no desk object [optional value] }
   { set up the outline rectangle around the dialog box (mostly for drawing pictures }
   SetRect (outline, 0, MenuWidth, screenwidth, MenuWidth + DialogWidth);
   curSel := Nil;                      { no current panel selection }
   firstPanel := NewDiPanel(numPanels);     { initialize the first panel }
   lastPanel := firstPanel;                 { set up pointer to the last panel in the structure }
   END; {of WITH block}

IF trcDialog THEN WRITELN ('[InitDiBox], exit');
END; {of PROC InitDiBox}

{**************************************************************************************************}
FUNCTION NewDiPanel {* VAR reference: INTEGER) : PanelHandle *};

{Returns a handle to a newly allocated panel record (with the record fields set to defaults).
 Also bumps the reference number by one.}

VAR
   tempBound   : RgnHandle;
   tempPanel   : PanelHandle;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[NewDiPanel], entry: reference = ',reference:1);

tempPanel := Pointer(ORD(NewHdl(SizeOf(Panel))));
WITH tempPanel^^ DO
   BEGIN
   prev := Nil;
   next := Nil;
   visible := TRUE;
   selected := FALSE;
   changed := TRUE;                    { all new panels have obviously changed, right? }
   reference := reference + 1;         { bump first, as reference = last panel in dialog box }
   refnum := reference;
   END; {of WITH block}
tempBound := NewRgn;
tempPanel^^.bound := tempBound;
NewDiPanel := tempPanel;

IF trcDialog THEN WRITELN ('[NewDiPanel], exit');
END; {of FUNC NewDiPanel}

{ the following nil<XX>Proc routines are for setting up the QD bottleneck procedures }
{**************************************************************************************************}
PROCEDURE nilArcProc (verb: GrafVerb; r: Rect; startAngle, arcAngle: INTEGER);

BEGIN END;

{**************************************************************************************************}
PROCEDURE nilCommentProc (kind, dataSize: INTEGER; dataHandle: QDHandle);

BEGIN END;

{**************************************************************************************************}
PROCEDURE nilLineProc (newPt: Point);

BEGIN END;

{**************************************************************************************************}
PROCEDURE nilOvalProc (verb: GrafVerb; r: Rect);

BEGIN END;

{**************************************************************************************************}
PROCEDURE nilPolyProc (verb: GrafVerb; poly: PolyHandle);

BEGIN END;

{**************************************************************************************************}
PROCEDURE nilRectProc (verb: GrafVerb; r: Rect);

BEGIN END;

{**************************************************************************************************}
PROCEDURE nilRRectProc (verb: GrafVerb; r: Rect; ovalwidth, ovalHeight: INTEGER);

BEGIN END;

{**************************************************************************************************}
PROCEDURE nilTextProc (byteCount: INTEGER; textAddr: QDPtr; numer, denom: Point);

BEGIN END;

{**************************************************************************************************}
PROCEDURE RmvDiBox;

{Removes the dialog box from the desktop, also deallocate the panels from the heap}

VAR
   tempPanel   : PanelHandle;
   temp2Panel  : PanelHandle;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[RmvDiBox], entry');

DialogHeight (0, false{no update event});
FlushInput (dialogFolder);                      {get rid of all of the pending keystrokes for the diBox}

tempPanel := diBox.firstPanel;
{ now dispose of all the panels }
REPEAT
   CASE tempPanel^^.info.tag OF
      diLabel: DispHandle (Pointer(ORD(tempPanel^^.info.labeltext)));
      diButton: DispHandle (Pointer(ORD(tempPanel^^.info.buttontext)));
      diField:
         BEGIN
         DispHandle (Pointer(ORD(tempPanel^^.info.fStateHdl)));
         RemoveField (tempPanel^^.info.fieldHdl);
         END;
      diCheckBox:
         BEGIN
         DispHandle (Pointer(ORD(tempPanel^^.info.checkOn)));
         DispHandle (Pointer(ORD(tempPanel^^.info.checkOneOf)));
         END; {of CASE ITEM diCheckBox}
      END; {of CASE block}
   DisposeRgn (tempPanel^^.bound);
   temp2Panel := tempPanel;
   tempPanel := tempPanel^^.next;
   DispHandle (Pointer(ORD(temp2Panel)));
   UNTIL (tempPanel = diBox.firstPanel);        { UNTIL we've looped back to the head }

KillPicture (diBox.shot);

IF trcDialog THEN WRITELN ('[RmvDiBox], exit');
END; {of PROC RmvDiBox}

{**************************************************************************************************}
PROCEDURE SelDiField {* thePanel: PanelHandle; drawNow: BOOLEAN *};
{sets field as selected, it required shows a selected field w/blinking cursor, etc.}

VAR
   pnState  : PenState;
   pt       : Point;
   tempRect : Rect;

BEGIN
diBox.curSel := thePanel;
diBox.curSel^^.selected := TRUE;
diBox.curSel^^.info.active := TRUE;
IF (NOT drawNow) THEN
   EXIT(SelDiField);

{save the current state}
GetPenState (pnState);
PenSize (1,1);
PenPat (black);
{erase any garbage that might still be in the field}
ClipRect (thePanel^^.outline);
EraseRect (thePanel^^.outline);
FrameRect (thePanel^^.outline);
{pretend as though we clicked on the far left of the panel}
pt.h := thePanel^^.outline.left + 3;
pt.v := thePanel^^.outline.top + 1;
Select (pt,thePanel^^.info.fieldHdl,thePanel^^.info.fStateHdl,tempRect,timeoutInterval);
StartBlink(timeoutInterval);
ObscureCursor;
Settimeout(timeoutInterval);
CaretOn(thePanel^^.info.fieldHdl, thePanel^^.info.fStateHdl);
{restore the old state}
SetPenState (pnState);
END; {of PROC SelDiField}

{**************************************************************************************************}
PROCEDURE SetDiButton {* thePanel: PanelHandle; location: Point; text: str255; buttonface: Style;
                         buttonFont, buttonLine, buttonWidth: INTEGER; isVisible: Boolean; doIt: TProc *};
{stuffs panel with the appropriate info}

VAR
   buttoninfo     : FontInfo;
   buttonheight   : INTEGER;     { height of button bounding box }
   tempBounds     : RgnHandle;   { for creating hit test region }
   tempRect       : Rect;        { for creating the hit-test region }
   tempStrHdl     : FmaxStrHdl;
   textHeight     : INTEGER;     { Max height of the button text }
   textWidth      : INTEGER;     { width of the text field }
   upperLeft, lowerRight: Point;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[SetDiButton], entry: text = ',text,' at ',location.h:1,location.v:1);

TextFont (buttonFont);     { set up font & face for call to GetFontInfo & StringWidth }
WITH thePanel^^ DO
   BEGIN
   visible := isVisible;
   selected := FALSE;
   info.tag := diButton;
   info.buttonface := buttonface;
   info.buttonfont := buttonfont;
   info.btnPenH := buttonline;
   info.btnPenW := (buttonLine * 3) DIV 2;         {increase the width for 3/2 ratio problem}
   info.buttonproc := doIt;
   TextFace (buttonface);
   GetFontInfo (buttonInfo);
   textHeight := buttonInfo.ascent + buttonInfo.descent;
   buttonHeight := textHeight + (textHeight DIV 2);                  { add 50% to the box height }
   info.buttonLoc := location;
   IF (buttonWidth = 0) THEN
      BEGIN
      { add 1/2 of the box height to each side of the text string }
      upperLeft.h := location.h - (buttonHeight DIV 2);
      lowerRight.h := upperLeft.h + StringWidth (text) + buttonHeight;
      END {of IF THEN block}
   ELSE
      BEGIN
      textWidth := StringWidth (text);
      info.buttonLoc.h := location.h + ((buttonWidth - textWidth) DIV 2);
      upperLeft.h := location.h;
      lowerRight.h := location.h + buttonWidth;
      END; {of IF ELSE block}
   upperLeft.v := location.v - (buttonInfo.ascent + (buttonHeight - textHeight) DIV 2);
   lowerRight.v := upperLeft.v + buttonHeight;
   tempRect.topLeft := upperLeft;
   tempRect.botRight := lowerRight;
   outline := tempRect;
   END; {of WITH block}
tempStrHdl := NewStrg(text);
thePanel^^.info.buttontext := tempStrHdl;

{ Open the region and frame a round rect (this creates the region for hit testing and selection inverting) }
tempBounds := thePanel^^.bound;
OpenRgn;
FrameRoundRect(tempRect, DiBtnW, DiBtnH);
CloseRgn(tempBounds);
thePanel^^.bound := tempBounds;

IF trcDialog THEN WRITELN ('   [SetDiButton], exit');
END; {of PROC SetDiButton}

{**************************************************************************************************}
PROCEDURE SetDiField {* thePanel: PanelHandle; location: Point; text: FmaxStr; fieldFace: Style;
                        fieldFont: INTEGER; maxSize: INTEGER; isVisible: BOOLEAN *};
{stuffs panel with the appropriate info}

VAR
   charPtr     : ^CHAR;             {for setting up the field data area}
   err         : INTEGER;
   fieldInfo   : FontInfo;
   textHeight  : INTEGER;
   rectHeight  : INTEGER;
   tempBounds  : RgnHandle;
   tempFldHdl  : hndField;
   tempFstate  : hndFstate;
   tempRect    : Rect;
   tempStrHdl  : FmaxStrHdl;
   upperLeft, lowerRight: Point;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[SetDiField], entry: text = ',text,' at ',location.h:1, location.v:1);

{first set up the rectangle for the field outline}
TextFont (fieldFont);         { set up font & face for call to StringWidth }
TextFace (fieldFace);
GetFontInfo (fieldInfo);
textHeight := fieldInfo.ascent + fieldInfo.descent;
rectHeight := textHeight + (textHeight DIV 2);     { add 50% to textheight }
upperLeft.h := location.h - (textHeight DIV 2);
upperLeft.v := location.v - ((rectHeight - textHeight) DIV 2) - fieldInfo.ascent;
lowerRight.h := location.h + ((maxSize+1) * CharWidth('W')) + (textHeight DIV 2);
lowerRight.v := upperLeft.v + rectHeight;
thePanel^^.outline.topLeft := upperLeft;
thePanel^^.outline.botRight := lowerRight;
tempRect := thePanel^^.outline;
{offset left side of rectange in by 2, so that field frame isn't erased by first character selection}
tempRect.left := tempRect.left + 2;

{initialize the temporary field variables}
tempFldHdl := CreateField (tempRect,maxSize,0{dont grow},left,4{pad},1{runs},0,fieldFont,FALSE);
tempFstate := Pointer(ORD(NewHdl(SizeOf(fieldState))));
InitFState (tempFldHdl, tempFstate);

WITH tempFldHdl^^ DO
   BEGIN
   curLen := Min(LENGTH(text), MaxSize);
   charPtr := Pointer(ORD(@text) + 1);
   MOVELEFT (charPtr, curValue^^, curLen);
   fmtInfo^^[0].font := fieldFont;
   fmtInfo^^[0].face := fieldFace;
   END;

WITH thePanel^^ DO
   BEGIN
   visible := isVisible;
   info.tag := diField;
   info.fieldHdl := tempFldHdl;
   info.fStateHdl := tempFstate;
   END; {of WITH block}

{Create a region suitable for hit testing}
tempBounds := thePanel^^.bound;
tempRect := thePanel^^.outline;
OpenRgn;
FrameRect(tempRect);
CloseRgn(tempBounds);
thePanel^^.bound := tempBounds;

IF trcDialog THEN WRITELN ('   [SetDiField], exit');
END; {of PROC SetDiField}

{**************************************************************************************************}
PROCEDURE SetDiLabel {* thePanel: PanelHandle; location: Point; text: str255; labelface: Style;
                        labelfont: INTEGER; isVisible: BOOLEAN *};

{stuffs panel with the appropriate info}

VAR
   labelinfo   : FontInfo;
   lowerRight  : Point;
   tempStrHdl  : FmaxStrHdl;
   upperLeft   : Point;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[SetDiLabel], entry: text = ',text,' at ',location.h:1, location.v:1);

WITH thePanel^^ DO
   BEGIN
   visible := isVisible;
   info.tag := diLabel;
   info.labelface := labelface;
   info.labelfont := labelfont;
   TextFont (labelfont);         { set up font & face for call to StringWidth }
   TextFace (labelface);
   GetFontInfo (labelInfo);
   upperLeft.h := location.h;    { we need to set up the panel box (rectangle) now }
   upperLeft.v := location.v - labelInfo.ascent;
   lowerRight.h := upperLeft.h + StringWidth (text);
   lowerRight.v := upperLeft.v + labelInfo.ascent + labelInfo.descent;
   outline.topLeft := upperLeft;
   outline.botRight := lowerRight;
   END; {of WITH block}
tempStrHdl := NewStrg(text);
thePanel^^.info.labeltext := tempStrHdl;

IF trcDialog THEN WRITELN ('  [SetDiLabel, exit');
END; {of PROC SetDiLabel}

{**************************************************************************************************}
PROCEDURE SetDiLine {* thePanel: PanelHandle; startLine, stopLine: Point; widthOfPen: INTEGER;
                       patOfPen: Pattern; isVisible: BOOLEAN *};

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[SetDiLine], entry');

WITH thePanel^^ DO
   BEGIN
   info.tag := diLine;
   visible := isVisible;
   IF (startLine.v = stopLine.v) THEN  { horizontal line }
      BEGIN
      outline.left := startLine.h;
      outline.right := stopLine.h;
      outline.top := startLine.v - 1;
      outline.bottom := startLine.v + widthOfPen + 1;
      END {of IF THEN block}
   ELSE                                { vertical line }
      BEGIN
      outline.left := startLine.h - 1;
      outline.right := startLine.h + widthOfPen + 1;
      outline.top := startLine.v;
      outline.bottom := stopLine.v;
      END; {of IF ELSE block}
   info.lineStart := startLine;
   info.lineStop := stopline;
   info.linePen := widthOfPen;
   info.linePat := patOfPen;
   END; {of WITH block}

IF trcDialog THEN WRITELN ('[SetDiLine], exit');
END; {of PROC SetDiLine}

{**************************************************************************************************}
PROCEDURE SetDiRect {* thePanel: PanelHandle; theRect: rect; isVisible: BOOLEAN *};

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[SetDiRect], entry');

WITH thePanel^^ DO
   BEGIN
   info.tag := diRect;
   visible := isVisible;
   outline := theRect;
   END; {of WITH block}

IF trcDialog THEN WRITELN ('   [SetDiRect], exit');
END; {of PROC SetDiRect}

{**************************************************************************************************}
PROCEDURE SetNullProcs {* VAR myGrafProcs: QDProcs *};
{Sets all of the quickdraw bottleneck procedures that draw dialog box
 panels to be Nil (dialogFolder is thePort)}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[SetNullProcs], entry');

SetStdProcs (myGrafProcs);
WITH myGrafProcs DO
   BEGIN
   textProc := @nilTextProc;
   lineProc := @nilLineProc;
   rectProc := @nilRectProc;
   rRectProc := @nilRRectProc;
   ovalProc := @nilOvalProc;
   arcProc := @nilArcProc;
   polyProc := @nilPolyProc;
   commentProc := @nilCommentProc;
   END; {of WITH block}

IF trcDialog THEN WRITELN ('[SetNullProcs], exit (finally!)');
END; {of PROC SetNullProcs}

{**************************************************************************************************}
PROCEDURE ShowDiBox;

{Display the dialog box.  Use the linked panel list from diBox}

VAR
   myGrafProcs : QDProcs;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[ShowDiBox], entry: height = ',diBox.height);

SetPort (dialogFolder);          { make sure we're still drawing to the right port }
ClipRect (diBox.outline);        { set clipping correctly }

SetStdProcs (myGrafProcs);
WITH myGrafProcs DO
   BEGIN
   textProc := @DiTextProc;
   lineProc := @DiLineProc;
   rectProc := @DiRectProc;
   rRectProc := @DiRRectProc;
   commentProc := @DiCommentProc;
   END; {of WITH block}
dialogFolder^.grafProcs := @myGrafProcs;

doPanel := FALSE;

DrawPicture (diBox.shot, diBox.outline);
dialogFolder^.grafProcs := nil;                 { reset procs so that if we die, we don't screw things up }

IF trcDialog THEN WRITELN ('[ShowDiBox], exit');
END; {of PROC ShowDiBox}

{**************************************************************************************************}
PROCEDURE ShowDiBtn {* thePanel: PanelHandle; isSelected: BOOLEAN *};

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF (thePanel = nil) THEN
   EXIT(ShowDiBtn);
WITH thePanel^^ DO
   BEGIN
   IF (isSelected) THEN
      selected := TRUE
   ELSE
      selected := FALSE;
   changed := TRUE;
   END;
ShowDiBox;
END; {of PROC ShowDiBtn}

{**************************************************************************************************}
PROCEDURE StartDiPic;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[StartDiPic], entry');

diBox.shot := OpenPicture (diBox.outline);            { start recording all QD calls }
ClipRect (diBox.outline);

IF trcDialog THEN WRITELN ('   [StartDiPic], exit');
END; {of PROC StartDiPic}

{**************************************************************************************************}
PROCEDURE StopDiBox;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[StopDiBox], entry');

diBox.active := FALSE;

IF trcDialog THEN WRITELN ('[StopDiBox], exit');
END; {of PROC StopDiBox}

{**************************************************************************************************}
PROCEDURE StopDiPic;

VAR
   myGrafProcs : QDProcs;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[StopDiPic], entry');

ClosePicture;                       { stop recording QD calls }
SetStdProcs (myGrafProcs);          { reset QD bottleneck procs }
dialogFolder^.grafProcs := @myGrafProcs;

IF trcDialog THEN WRITELN ('[StopDiPic], exit');
END; {of PROC StopDiPic}

{**************************************************************************************************}
FUNCTION TestDiBox {* PanelHandle *};
{draws picture, only non-nil bottleneck routine is TestDiPanel.  TestDiPanel sets hitDiPanel non-nil
 of button up occured in a valid selectable panel (button/field).  TestDiPanel also inverts the
 current panel (PtInRgn check)}

VAR
   myGrafProcs : QDProcs;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[TestDiBox], entry');


hitDiPanel := nil;                        { nothing hit yet }
abortTest := FALSE;                       { assume button still down }
SetPort(dialogFolder);
SetNullProcs (myGrafProcs);
myGrafProcs.commentProc := @TestDiPanel;
dialogFolder^.grafProcs := @myGrafProcs;

REPEAT
   GetMouse(inDiBox);
   DrawPicture (diBox.shot, diBox.outline);
   IF (NOT StillDown) THEN
      abortTest := TRUE;
   UNTIL (abortTest);

TestDiBox := hitDiPanel;
dialogFolder^.grafProcs := nil;           { reset grafProcs (if we crash, other processes won't be screwed) }

IF trcDialog THEN WRITELN ('[TestDiBox], exit: hitDiPanel = ',ORD(hitDiPanel));
END; {of PROC TestDiBox}

{**************************************************************************************************}
PROCEDURE TestDiPanel {* kind, dataSize: INTEGER; dataHandle: QDHandle *};

{This routine substituted for the QD StdComment routine.  Then the picture is 'drawn', with all the
 other QD procs set to nil.}

LABEL
   99;

TYPE
   TpnlHdlPtr  = ^PanelHandle;
   TpnlHdlHdl  = ^TpnlHdlPtr;

VAR
   keepGoing   : BOOLEAN;
   pnState     : PenState;
   tempPanel   : PanelHandle;
   handleHdl   : TpnlHdlHdl;

   {-------------------------------------------------------------------------}
   PROCEDURE InvertIfButton;
   {inverts the panel if it is a button}

   BEGIN
   IF (tempPanel^^.info.tag = diButton) THEN
      BEGIN
      ClipRect (tempPanel^^.outline);
      InvertRgn(tempPanel^^.bound);
      GetPenState (pnState);
      PenSize (tempPanel^^.info.btnPenW, tempPanel^^.info.btnPenH);
      PenPat (black);
      FrameRgn(tempPanel^^.bound);
      SetPenState (pnState);
      END;
   END; {of PROC InvertIfButton}

   {-------------------------------------------------------------------------}
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[TestDiPanel], entry: comment type = ',kind:1);

IF ((abortTest) OR (kind = PicRParen)) THEN    { must be a left paren comment, nothing hit so far }
   GOTO 99;

handleHdl := Pointer(ORD(dataHandle));
tempPanel := handleHdl^^;

IF (NOT tempPanel^^.visible) THEN
   GOTO 99;                         {only hit-test visible panels}

IF PtInRgn(inDiBox, tempPanel^^.bound) THEN
   BEGIN
   hitDiPanel := tempPanel;
   InvertIfButton;
   keepGoing := TRUE;
   WHILE (keepGoing) DO
      BEGIN
      GetMouse(inDiBox);
      IF (NOT PtInRgn(inDiBox, tempPanel^^.bound)) THEN
         BEGIN
         {dragged outside of area, still down, reinvert image, etc.}
         InvertIfButton;
         hitDiPanel := nil;
         keepGoing := FALSE;
         END
      ELSE
         IF (NOT StillDown) THEN
            {still in panel, button up, so don't invert, leave hitDiPanel alone}
            BEGIN
            keepGoing := FALSE;
            abortTest := TRUE;
            END;
      END; {of WHILE block}
   END; {of IF THEN block}

99:
IF trcDialog THEN WRITELN ('[TestDiPanel], exit');
END; {of PROC TestDiPanel}

{**************************************************************************************************}
PROCEDURE UseDiBox;
{main processing loop, co-exists uncomfortably with the main filer loop.  Basically calls ProcessTheEvent,
 which then calls the appropriate sub-event (ie. DoBtnDownEvent).  At the lower level routine is where
 the branch to either main filer code or dialog box code occurs}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcDialog THEN WRITELN ('[UseDiBox], entry');

ShowDiBox;                                            { initial draw to get everything up there }

{ now go into event loop..we know we're the active window until we get a deactivate event,
  so don't bother with the NOT ImActive stuff }

diBox.active := TRUE;
WHILE (ImActive AND diBox.active) DO
   BEGIN
   IF EventAvail THEN               { anything for me? }
      BEGIN
      GetEvent (curEvent);
      ProcessTheEvent;              { handle it with care, use the main filer routine for this }
      END {of IF THEN block}
   ELSE
      BEGIN
      IdleTasks;                    { blick cursor for field editing, etc. }
      LetOthersRun;                 { let the background processes (if any) run }
      END; {of IF ELSE block}
   END; {of WHILE loop}
diBox.active := FALSE;                   { bail out, reset dialog box active flag }

IF trcDialog THEN WRITELN ('[UseDiBox], exit');
END; {of PROC UseDiBox}

{$S }    {set back to main segment}

ÿ