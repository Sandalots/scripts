PROGRAM Desk;

   {

            L                        DDDD
            L      o                 D   D                 k
            L         sssss  aaaaaa  D    D  eeeee  sssss  k  k
            L      i  s      a    a  D    D  e      s      k k
            L      i  sssss  aaaaaa  D    D  eeeee  sssss  kk
            L      i      s  a    a  D   D   e          s  k k
            LLLLLL i  sssss  a    a  DDDD    eeeee  sssss  k  k


                                Copyright 1983, 1984, Apple Computer Inc.


   Conventions used:

      "{"  is used for comments.

      "(*" is used to comment out code that may contain comments.

      "{*** comment"   => more work needed in this area.

      "{**** <name>"   => code added for enhancement/fix of <name>.

      Many routines are named:

          <verb>Object    =>  action is applied to the object & optionally to sons
          <verb>Contents  =>  action is applied to contents (sons) of the object

      All routines are declared in alphabetical order.

      Unexpected errors are handled by the routine "ErrorFound" in unit "Catalog."
      Error numbers 1000-1099 are reserved for this module.
      The last used error number is 1042.
   }


USES
     {$U HwInt       }  HwInt,
     {$U LibOS/SysCall     }  SysCall,
     {$U LibOS/PSysCall    }  PSysCall,
     {$U LibPl/PPasLibC    }  PPasLibC,
     {$U UnitStd     }  UnitStd,
     {$U UnitHz      }  UnitHz,
     {$U Storage     }  Storage,
     {$U QuickDraw   }  QuickDraw,
     {$U FontMgr     }  FontMgr,
     {$U WM.Events   }  Events,
     {$U WM.Windows  }  Windows,
     {$U WM.Folders  }  Folders,
     {$U WM.Menus    }  Menus,
     {$U WmlStd      }  WmlStd,
     {$U WmlCrs      }  WmlCrs,
     {$U WmlSb       }  WmlSb,
     {$U WmlGrow     }  WmlGrow,
     {$U GrafUtil    }  GrafUtil,
     {$U AlertMgr    }  AlertMgr,
     {$U IntrLib     }  International,
     {$U DBenv       }  DBenv,
     {$U DBdecl1     }  DBdecl1,
     {$U PMDecl      }  PMDecl,
     {$U PMM         }  PMM,
     {$U PrStdInfo   }  PrStdInfo,
     {$U PrPublic    }  PrPublic,
     {$U Scrap       }  Scrap,
     {$U FEDec       }  FEDec,
     {$U Fld         }  FieldEdit,
     {$U FilerComm   }  FilerComm,  { Communication from apps to Desktop Manager }


        { Desktop Manager Modules }

     {$U ApDm/Globals }  DmGlobals,   { Common routines & declarations }
     {$IFC flrDebug}
     {$U apdm/tracecalls.obj} tracecalls,
     {$ENDC}
     {$U ApDm/Time    }  DmTime,      { Time & date formatting }
     {$U ApDm/Entry   }  DmEntry,     { Manages lists of docs, tools, vols }
     {$U ApDm/Cat     }  DmCat,       { Cover procs for database intrinsics }
     {$U ApDm/Doc     }  DmDoc,       { Creating, communicating with apps }
     {$U ApDm/Vol     }  DmVol;       { Mount, unmount, copy of volumes }




{$IFC flrSymbols }
   {$D+}
{$ELSEC }
   {$D-}
{$ENDC }

{$IFC flrDebug }
   {$R+}
{$ELSEC }
   {$R-}
{$ENDC }


CONST
      version = '  Release 3.0';  { Put two spaces before the first character }
      currentFsVersion = 17;      { Change this to match the current OS fsVersion }
      pwdFsVersion = 17;          { First supported file system to provide passwords }
{$IFC flrDebug}
      theNMIKey = 33;             { Key to the right of the 'clear' key }
{$ELSEC }
      theNMIKey = 0;
{$ENDC }


         { Menu & menu item id's.  These must match the menu file }

      filingMenu  = 1;
        mCloseAll     = 1;
        mClose        = 2;
        mBlank13      = 3;
        mPutBack      = 4;
        mOpen         = 5;
        mDuplicate    = 6;
        mAttributes   = 7;
        mNew          = 8;
        mMakePad      = 9;
        mBlank19      = 10;
        mPrintStatus  = 11;

      editMenu    = 2;
        mUndoLast     = 1;
        mBlank22      = 2;
        mCut          = 3;
        mCopy         = 4;
        mCopyRef      = 5;
        mPaste        = 6;
        mBlank26      = 7;
        mSelectAll    = 8;

      housekeepingMenu    = 3;
        mEject        = 1;
        mBlank32      = 2;
        mSpatial      = 3;
        mAlpha        = 4;
        mChron        = 5;
        mCompact      = 6;
        mBlank37      = 7;
        mRepair       = 8;
        mErase        = 9;
        mBlank310     = 10;
        mEmpty        = 11;

      scrapMenu   = 4;        { Contains only first two items of File/Print menu }
        {
        mCloseAll     = 1;
        mClose        = 2;
        mBlank43      = 3;
        mPrinter      = 4;
        }

      specialMenu = 5;     { special debugging menu.  Toggled by command "!" }
        mTrcAll       = 1;    { Turn on all tracing flags }
        mTrcOff       = 2;    { Turn off all tracing flags }
        mTrcEvents    = 3;    { Toggle window manager event tracing }
        mTrcFEntry    = 4;    { Toggle tracing in unit FEntry }
        mTrcCatalog   = 5;    { Toggle tracing in unit Catalog }
        mTrcFDocCtrl  = 6;    { Toggle tracing in unit FDocCtrl }
        mTrcFVolCtrl  = 7;    { Toggle tracing in unit FVolCtrl }
        mTrcFiler     = 8;    { Toggle tracing in main program }
        mTrcDialog    = 9;    { Toggle tracing in unit Desk3 }
        mTrcAttribute = 10;   { Toggle tracing in unit Desk4 }
        mPrintDocs    = 11;   { Display the document list data structure }
        mPrintVols    = 12;   { Display the volume list data structure }
        mPrintTools   = 13;   { Display the tool list data structure }
        mPrintDevs    = 14;   { Display the device list data structure }
        mSplit        = 15;   { Set split info for selected icon }
        mQuit         = 16;   { Exits the program }

      stressMenu  = 6;     { stress tests heaps and IO checks. Toggled by command "!" }
        mTestIOerr    = 1;   { Toggle the faking of errors from lowlevel routines}
        mFakeNoHeap   = 2;   { Toggle the faking of no heap space }
        mCheckHeap    = 3;   { Toggle checking of my heap }
        mCheckWmHeap  = 4;   { Toggle checking of window manager heap }
        mCheckFmHeap  = 5;   { Toggle checking of font manager heap }
        mMixHeap      = 6;   { Toggle scrambling of my heap }
        mMixWmHeap    = 7;   { Toggle scrambling of window manager heap }
        mMixFmHeap    = 8;   { Toggle scrambling of font manager heap }
        mFlushing     = 9;   { Toggle flushing of catalog to disk }
        mTraceCalls   = 10;  { Toggle tracing of procedure calls }

      xtraMenu    = 7;      { Not displayed.  Holds strings used for diff menus. }
        xClose        = 1;    { "Set Aside" }
        xOpen         = 2;    { "Open" }
        xPutBack      = 3;    { "Put Back" }
        xObjects      = 4;    { "Icons" }
        xEject        = 5;    { "Eject" }
        xRepair       = 6;    { "Repair" }
        xErase        = 7;    { "Erase" }
        xEmpty        = 8;    { "Empty" }
        xDisk         = 9;    { "Disk" }
        xDiskette     = 10;   { "Diskette" }
        xAttributes   = 11;   { "Attributes of" }
        xDuplicate    = 12;   { "Duplicate" }
        xNew          = 13;   { "Tear Off Stationery"}
        xMakePad      = 14;   { "Make Stationery Pad" }
        xMonitor      = 15;   { "Monitor the Printer ..." }
        xLast = xMonitor;

      xDesktop    = 8;

      firstFlrMenu  = filingMenu;
      lastFlrMenu   = xDesktop;

         { Known char codes in WMFont, see also "InitIcons" for more codes }

      graySymbol    = 64;
      blackSymbol   = 65;


         { Screen size constants }

      icon2Width   = 24;  { iconWidth/2 }
      icon2Ht      = 16;  { iconHt/2 }
      tinyWidth    = 24;  { width of tiny list view icon }
      tinyHt       = 16;  { height of tiny list view icon }
      menuHt       = 16;  { height of menu bar }
      titleHt      = 16;  { height of window title bar }
      hScrollInc   = 32;  { pixels scrolled for "smooth" horizontal scroll }

         { list view column layout }

      tinyStart    =  10;  { start of tiny icon }
      nameStart    =  40;  { start of icon title }
      nameEnd      = 270;  { end of title field }
      sizeEnd      = 320;  { end of size field (right justified }
      modEnd       = 500;  { end of modified date/time field }
      creatEnd     = 680;  { end of creation date/time field }

         { filename constants }

      fnameAlerts    = 'System.DmAlerts';        { phrase file for alert msgs }
      fnameHeap      = '{!DmHeap}';            { name of data seg used for heap }
      fnameJrnlFiles = 'JrnlFiles.Text';       { holds filenames for play/record }

         { gridding parameters }

      hGrid      = 120;   { deskWidth DIV 6 }
      vGrid      =  43;   { deskHt DIV 8 }
      hGridStart =  36;   { (hGrid - iconWidth) DIV 2 }
      vGridStart =   2;   { (vGrid - iconHt - icontitleHt) DIV 2 }
      nDeskRows  =   8;   { number of rows of icons on desktop }
      nDeskCols  =   6;   { number of columns of icons on desktop }

         { Miscellaneous constants }

      whyHitOrphan = 400;     { "why" value sent to self when orphan hit }
      noTimeout    = -1;      { no "timeouts" when "timeoutTime" set to this }
      listFont     = p10Tile; { font used for titles in list view }
      noFont       = -1;      { nil value for fonts }
      noFile       = -1;      { nil value for filesys refnums }
      overlayCode  =  0;      { char code of overlay in OEM tool font }
      dataCode     =  1;      { char code of icon in OEM tool font }
      maskCode     =  2;      { char code of icon mask in OEM tool font }
      MaxPasswd    = 20;      { maximum length of a password }
      DiBtnW       = 12;      { radius (width) for dialog box buttons }
      DiBtnH       =  8;      { radius (height) for dialog box buttons }


TYPE ObjectState  = (nilState,     { used for the "nilObject" }
                     openState,    { open (from container or desktop) }
                     normal,       { closed in container or on desktop (unselected)}
                     hilited,      { closed in container or on desktop (selected) }
                     limbo,        { Xor image while being moved }
                     placeHolder); { gray ghost in container }

     StateSet     = SET OF ObjectState;

     ViewType     = spatialView..chronView;  { defined in "Catalog" }

         { object node - one for each icon on screen & for list head/tail

           Those objects which can hold other objects are refered to as
           "containers."  There is a special container called the "deskObject"
           which holds all objects on the desktop.  The objects in a given
           container are kept in a doubly linked circular list pointed at by
           the field "contents."  "Contents" points to either a head/tail node
           for a circular list, or to the nil object.  The circular list structure
           is used so that the object list be traversed back to front for drawing,
           and front to back for hit testing.  When a container is opened,
           the catalog is read and a window and a list of object nodes
           are created.  When the container is closed the window and contents
           are deallocated.

         }

     ObjectHandle = ^ObjectPtr;
     ObjectPtr    = ^ObjectRecord;
     ObjectRecord = RECORD
                    nameHdl:    FmaxStrHdl;     { handle to icon title }
                    loc:        Point;          { topLeft of bounding box }
                    kind:       ObjectKind;     { doc, folder, disk, etc. }
                    toolNumber: TtoolId;        { tool to use, else "deskTool" }
                    volHdl:     TentryHdl;      { volume on which object lives }
                    catRID:     TcatRID;        { catalog record ID }
                    state:      ObjectState;    { icon state: normal,hilited... }
                    next:       ObjectHandle;   { next brother }
                    prev:       ObjectHandle;   { previous brother }
                    container:  ObjectHandle;   { father }
                    contents:   ObjectHandle;   { sons }
                    wasOpened:  BOOLEAN;        { TRUE => has been opened }
                    isOpen:     BOOLEAN;        { TRUE => window is on screen }
                    setAside:   BOOLEAN;        { TRUE => obj being opened had been set aside }
                    dirty:      BOOLEAN;        { TRUE => catalog needs update}
                    toBeCopied: BOOLEAN;        { TRUE => dup'd, but not real }
                    visible:    BOOLEAN;        { TRUE => draw icon }
                    updateLabel:BOOLEAN;        { TRUE => name was edited }
                    split:      BOOLEAN;        { obj is split across disks, this is one piece }
                    passworded: BOOLEAN;        { diskfiles are password protected }
                    userPassword: E_Name;       { user supplied password }
                    viewMode:   ViewType;       { spatial, alpha, etc. }
                    objWindow:  WindowPtr;      { grafport for icon's window }
                    windowRect: Rect;           { last window location & size }
                    scrollDh:   INTEGER;        { h scroll position }
                    scrollDv:   INTEGER;        { v scroll position }
                    hThumbPos:  INTEGER;        { h thumb position in 1000ths }
                    vThumbPos:  INTEGER;        { v thumb position in 1000ths }
                    listSeqNum: INTEGER;        { position in list (1,2,3 ...) }
                    created:    LongInt;        { time stamp when created }
                    modified:   LongInt;        { time stamp when modified }
                    size:       LongInt;        { disk size in blocks }
                    freeSpace:  LongInt;        { used for disks only }
                    backedUp:   LongInt;        { used for disks only }
                    nameRect:   Rect;           { bounding box of icon title }
                    END;


     {
          deskObject
              !
              v
            -----
            !   !
            -----         Objects on desktop
             ! ^
             ! !<-----------------------------
             ! !        ^                    ^
             v !        !                    !
            -----     -----                -----
        --> !h/t! --> !   ! -->         -->! f ! --> to h/t
        <-- !   ! <-- !   ! <--   ...   <--!   ! <-- from h/t
            -----     -----                -----
              !         !                   ! ^              contents of "f"
              v         v                   ! !
           nilObject                        ! !<----------------------------
                                            ! !        ^         ^         ^
                                            v !        !         !         !
                                           -----     -----     -----     -----
                                       --> !h/t! --> !   ! --> !   ! --> !   ! -->
                                       <-- !   ! <-- !   ! <-- !   ! <-- !   ! <--
                                           -----     -----     -----     -----
                                             !         !         !         !
                                             v         v         v         v
                                          nilObject
     }



        { format for info about OEM tools (memory structure) }

     PtrToolNode = ^TtoolInfo;
     HdlToolNode = ^PtrToolNode;
     TtoolInfo = RECORD
                 toolNum:        TtoolID;     { which tool }
                 tryToOpen:      BOOLEAN;     { TRUE => haven't looked for font yet }
                 usesStationery: BOOLEAN;     { TRUE => supports documents }
                 whichVol:       TentryHdl;   { volume on which font is open }
                 font:           Tfam;        { font containing custom icons }
                 bbox:           Rect;        { bounding box of icon }
                 next:           HdlToolNode; { next in list }
                 END;


{******** Attributes code: Type declarations for Attributes dialog box ********}


   PanelHandle  = ^PanelPtr;  {declared here because the compiler can't handle circular def's}

   TdiMode      = (DiNormal,                    { normal drawing mode, only changed, visible panels }
                   DiUpdate,                    { update of the box, all visible panels }
                   DiErase);                    { label overlays, erase only changed, invisible panels }

   {DialogBox is the dialog box data structure.  A dialog box is represented as a double linked list
    of panels, each of which represents some (possibly visible) object in the dialog box}

   DialogBox    = RECORD
                  active      : BOOLEAN;        { TRUE => dialog box being displayed }
                  height      : INTEGER;        { size (height) of the dialog box }
                  numPanels   : INTEGER;        { number of panels in dialog box }
                  drawMode    : TdiMode;        { drawing mode }
                  obj         : ObjectHandle;   { object being modified by dialog box }
                  shot        : PicHandle;      { shot of the entire dialog box }
                  outline     : rect;           { bounding rectangle around entire dialog box (for pic) }
                  firstPanel  : panelHandle;    { the first panel in the double linked data structure }
                  lastPanel   : panelHandle;    { the last panel in the list }
                  curSel      : panelHandle;    { the current panel selection (nil if none is selected) }
                  finishProc  : TProc;          { procedure to execute when the dialog box is done }
                  END; {of RECORD}

   {DialogInfo is a record set by a call to SetAttInfo.  Eventually this should be a variant record,
    but no time right now to define the various classes, plus the information is mostly the same.}

   TobjState    = (protectable, notProt, noFiles, oldDisk, setAside);

   DialogInfo   = RECORD
                  kind        : INTEGER;        { type of object info is about }
                  kindLbl1    : FmaxStrHdl;     { string following object name, ie 'is a folder' }
                  kindLbl2    : FmaxStrHdl;     { additional 'kind' string, for long disk info }
                  name        : FmaxStrHdl;     { name of the object }
                  storedOn    : FmaxStrHdl;     { (doc/folder/tool) 'Office/WS' string }
                  storeIn1    : FmaxStrHdl;     { (doc/folder/tool) 'in Folder A in Folder B...' string }
                  storeIn2    : FmaxStrHdl;     { second stored in string, on second line }
                  topLines    : INTEGER;        { number of text lines in the top panel of diBox }
                  infoLines   : INTEGER;        { number of text lines in the information box }
                  size        : LongInt;        { disk size of object (or size of disk) }
                  created     : LongInt;        { date object was created }
                  modified    : LongInt;        { (doc/pad/folder/tool) date modified }
                  version     : INTEGER;        { (tool/disk/Preferences) version number }
                  backedUp    : LongInt;        { (disk) date backed up, = 0 if never }
                  free        : LongInt;        { (disk) number of free pages }
                  objState    : TobjState;      { what type of object (w/regard to prot) do we have }
                  protected   : BOOLEAN;        { TRUE => (doc/tool) is protected }
                  split       : BOOLEAN;        { TRUE => (doc) split into multiple OS files }
                  splitNum    : INTEGER;        { (doc) If split, then which piece (1..numPieces) }
                  splitSize   : LongInt;        { (doc) If split, total size of complete document }
                  END; {of RECORD}

   ProtState    = (safe,                        { document/tool is protected }
                   unprotected,                 { document/tool is unprotected }
                   verified,                    { document/tool protected, user entered correct old passwd }
                   noProt);                     { object cannot be protected }

   {PasswdRec is a record containing information about a password set/change}

   PasswdRec    = RECORD
                  state       : ProtState;      { state that the document is in, relative to protection }
                  oldState    : ProtState;      { previous state of protection, set only in protattdiBox }
                  old         : E_Name;         { old password on the object }
                  new         : E_Name;         { new password on the object }
                  entered     : E_Name;         { passsword that was entered }
                  path        : PathName;       { pathname for object files (without extension) }
                  iconName    : FmaxStrHdl;     { handle to name of the icon that we're dealing with }
                  enterBtnPanel : PanelHandle;  { Set to enter button panel }
                  cancelBtnPanel : PanelHandle; { Set to cancel button panel }
                  noPassBtnPanel : PanelHandle; { Set to no password button panel }
                  passwdPanel : PanelHandle;    { Set to the password field panel at setup time }
                  pwdLine1    : PanelHandle;    { Set to first line label for passworded object }
                  upwdLine1   : PanelHandle;    { Set to first line label for unprotected object }
                  pwdinit     : PanelHandle;    { second line, passworded, initial line }
                  pwdVerified : PanelHandle;    { second line, passworded, verified }
                  upwdinit    : PanelHandle;    { second line, unpassworded, initial }
                  validPasswd : BOOLEAN;        { TRUE => new password was entered/verified by enter btn }
                  passworded  : BOOLEAN;        { TRUE => object originally had a password }
                  END; {of RECORD}

   {Checklist is a linked list of panelHandles.  Each panelHandle references an existing panel in the
    dialog box.  Each Checklist is referenced by a particular checkbox.  Each checkbox has two checklists;
    the first is a list of those panels in the dialog box which must be visible if the checkbox is selected,
    the second is a list of panels in the dialog box which must be invisible if the checkbox is not
    selected (light)}

   ListHandle  = ^ListPtr;
   ListPtr     = ^CheckList;
   CheckList   = RECORD
                 selectedPanel : PanelHandle;          { panel that must be on if checklist is enabled }
                 next         : ListHandle;
                 END; {of RECORD}

   {A diLabel is just some text on the screen, drawn inside the panel box.
    A dibutton is a rounded rectangle with text inside of it.  Clicking on a button implies some action
       will occur.  The rounded rectangle is drawn inside the panel box.
    A dicheckbox is a small square of standard checkbox size which is either off (not selected, = light)
       or on (selected, = dark).  A checkbox can control whether other panels will be visible or not.
    A difield is an editable line of text enclosed by the panel box (uses the field editor).
    A diLine is a line drawn in the dialog box.
    A diRect is a rectandle, drawn as the panel box}

   TPanel = (diLabel, diButton, diCheckbox, diField, diLine, diRect);

   {The location of each different object is determined the same way.  They are all drawn inside
    of the panel box, where this box is of the minimum bounding size (with some margin in the case
    of a diLabel)}

   PanelRec    =  RECORD
                  CASE tag : TPanel OF
                     diLabel:
                        (labeltext  : FmaxStrHdl;     { text of label }
                         labelface  : Style;          { typeface for label }
                         labelfont  : INTEGER);       { font to draw label with }
                     diButton:
                        (buttontext : FmaxStrHdl;     { text inside of button }
                         buttonLoc  : Point;          { location of button text }
                         buttonface : Style;          { typeface for button }
                         buttonfont : INTEGER;        { font to draw button text with }
                         buttonproc : TProc;          { procedure to execute if pushed }
                         btnPenW    : INTEGER;        { pen width to use for drawing button outline }
                         btnPenH    : INTEGER);       { pen height to use for drawing button outline }
                     diCheckbox:
                        (CheckOn    : ListHandle;     { panels that are visible iff checkbox is dark}
                         checkOneOf : ListHandle);    { checkbox panels in a checkbox group }
                     diField:
                        (fieldHdl   : HndField;       { handle to the field record }
                         fStateHdl  : HndFstate;      { handle to the state of the field }
                         active     : BOOLEAN);       { TRUE => field is currently being edited }
                      diLine:
                        (linestart  : Point;          { start of line }
                         linestop   : Point;          { end of line }
                         linepen    : INTEGER;        { pensize for drawing line }
                         linepat    : Pattern);       { pattern to use for drawing line }
                      diRect:
                        ();                           { no information }
                  END; {of RECORD}

   PanelPtr     = ^Panel;
   Panel        = RECORD
                  prev  : panelHandle;          { previous panel in dialog box data structure }
                  next  : panelHandle;          { next panel in structure (linked list) }
                  bound : rgnHandle;            { region used for hit testing of mouse down events }
                  outline  : rect;              { rect used for panel placement and erasing }
                  visible : BOOLEAN;            { to draw or not to draw, that is the question }
                  selected : BOOLEAN;           { for checkboxes, fields and buttons }
                  changed  : BOOLEAN;           { has the panel become visible/invisible recently? }
                  refnum : INTEGER;             { used to uniquely identify every panel in a dibox }
                  info  : panelRec;             { panel type specific information }
                  END; {of RECORD}


{******** End of Dialog box type declarations ********}


VAR debugStartup:       BOOLEAN;  { Initialized to FALSE.  To trace startup, set }
                                  { to TRUE with debugger after first statement  }

       { These variables are used to determine multiple mouse clicks }

    clickTime:          LongInt;   { set to last button up + clickDelay }
    clickCount:         INTEGER;   { clicks seen so far }
    clickLoc:           Point;     { where clicked last (local coords) }
    clickGlobalLoc:     Point;     { where clicked last (global coords) }
    shiftClick:         BOOLEAN;   { TRUE => shift key down on 1st click }


       { These are set constants }

    allKindsSet:        KindSet;   { all - nilKind }
    allStates:          StateSet;  { all object states }
    containerSet:       KindSet;   { all containers - disks, folders, etc. }
    diskSet:            KindSet;   { all disk kinds, floppies, profile }
    docToolSet:         KindSet;   { anything associated w/ a process }
    dupSet:             KindSet;   { can be duplicated }
    openSet:            KindSet;   { kinds which can be opened }
    padSet:             KindSet;   { the pad kinds, doc & folder }
    putBackSet:         KindSet;   { kinds which can be put back }

       { Handles to "system" objects }

    nilObject:          ObjectHandle;  { lists are terminated by this }
    deskObject:         ObjectHandle;  { highest level container }
    trashObject:        ObjectHandle;  { the disposal for deleting objects }
    scrapObject:        ObjectHandle;  { the buffer for document pieces }
    configObject:       ObjectHandle;  { configuration info }
    inBoxObject:        ObjectHandle;  { place for incoming mail (network rls) }
    outBoxObject:       ObjectHandle;  { place for outgoing mail (network rls) }
    activeObject:       ObjectHandle;  { object that owns the active window }
    editObject:         ObjectHandle;  { object whose title is being edited }
    edit2Object:        ObjectHandle;  { used when editObject appears twice }
    orphanObject:       ObjectHandle;  { orphan to be restarted after desk active }
    deskList:           ARRAY [1..23] OF ObjectHandle; { Current desktop menu items }


       { Scroll bar stuff }

    sbList:             TsbList;       { scroll bar list descriptor }
    hsbV:               THsb;          { handle to vertical scroll bar info }
    hsbH:               THsb;          { handle to horizontal scroll bar info }
    maxThumb:           LongInt;       { constant used to force long arithmetic }
    scrollRgn:          RgnHandle;     { gets set to update rgn after ScrollRect }


       { Field editor stuff }

    hShowFld:           hndField;      { handle to a field used only for drawing }
    hCurFld:            HndField;      { field being edited }
    hCurFstate:         HndFstate;     { state of field being edited }
    timeoutTime:        LongInt;       { holds next time to blink caret or draw }
    timeoutInterval:    Integer;       { holds interval for next "timeout" }
    iconFntInfo:        FontInfo;        { holds iconfont attributes }
    lineHt:             INTEGER;       { height of line in list view }
    botToBaseLn:        INTEGER;       { offset from rect, lineHt tall, to baseline}
    dateWidth:          INTEGER;       { const: pixel width of date string }
    timeWidth:          INTEGER;       { const: pixel width of time string }
    prevName:           FmaxStr;       { used to check if icon name was changed }


       { These variable are used to keep track of temporary XOR icon images }

    xorSrcObj:          ObjectHandle;  { container from which objects were dragged }
    xorDstObj:          ObjectHandle;  { container into which objects were dragged }
    xorWindow:          WindowPtr;     { window in which objects are to be drawn }
    xorDh,xorDv:        INTEGER;       { amount moved from original location }
    xorObj:             ObjectHandle;  { used during a document split/join.  Points to }
                                       { the single image being split/joined. }


       { Miscellaneous global variables }

    appleOff:           BOOLEAN;       { TRUE => apple key pressed with power btn }
    copyMode:           BOOLEAN;       { TRUE => blinking duplicates exist }
    flrHeapRefnum:      INTEGER;       { heap data seg id.  Used to grow heap }
    menuForScrap:       BOOLEAN;       { TRUE => scrap menu up last }
    specialUp:          BOOLEAN;       { TRUE => special debug menu is visible }
    startingUp:         BOOLEAN;       { TRUE => in initialization code }
    takingPicture:      BOOLEAN;       { TRUE => skip visRgn optimization check }
    toolList:           HdlToolNode;   { head of OEM tool info list }
    xtraStrgs:          ARRAY [xClose..xLast] OF FMaxStrHdl; { heap copies of menu strings }

{**** Attributes code: Dialog global variables ****}

    abortTest  : BOOLEAN;               { TRUE => stop hit-testing dialog panels }
    diBox      : dialogBox;             { global dialog box var }
    diPassword : PasswdRec;             { password set in info for dibox action }
    doPanel    : BOOLEAN;               { TRUE => draw the current panel }
    hitDiPanel : PanelHandle;           { Handle to panel clicked on, nil if no selection made }
    inDiBox    : Point;                 { Location of buttonDown event in dialog window }

{**** End of dialog box global variables ****}

    {$IFC flrDebug }
    fmHeap:             THz;           { ptr to font mgr heap for debugging }
    {$ENDC }

       { Menu descriptors.  Read in from menu file }
    flrMenus:           ARRAY [firstFlrMenu..lastFlrMenu] OF MenuInfo;

       { table describing desktop icon compaction order }
    gridTable:          ARRAY [0..nDeskRows,0..nDeskCols] OF Byte;

       { table telling which kinds of objects a given container will accept }
    matchTable:         ARRAY [ObjectKind] OF KindSet;

       { used when reading icon references from the scrap }
    refAbort:           BOOLEAN;
    refObj:             ObjectHandle;
    refIconInfo:        TIconRef;
    refProc:            ProcessID;
    refWindow:          WindowPtr;


   { Forward Declarations.   Used to maintain alphabetical order }

PROCEDURE AdjustContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
PROCEDURE AdjustDesktopMenu;
  FORWARD;
PROCEDURE AdjustMenus;
  FORWARD;
PROCEDURE AdjustObject(obj: ObjectHandle; stayInWindow: BOOLEAN);
  FORWARD;
PROCEDURE BackupDisk(srcDisk,dstDisk: ObjectHandle);
  FORWARD;
PROCEDURE BlinkContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
PROCEDURE BlinkObject(obj: ObjectHandle);
  FORWARD;
PROCEDURE ChangeContents(obj: ObjectHandle;
                         oldState,newState: ObjectState;
                         dh,dv: INTEGER;
                         redraw: BOOLEAN);
  FORWARD;
PROCEDURE ChangeName(obj: ObjectHandle; VAR newName: FmaxStr);
  FORWARD;
PROCEDURE ChangeObject(obj: ObjectHandle;
                       newState: ObjectState;
                       dh,dv: INTEGER;
                       redraw: BOOLEAN);
  FORWARD;
FUNCTION  ChangeParentID(obj: ObjectHandle; newParentID: IDType): BOOLEAN;
  FORWARD;
PROCEDURE ChangeView(obj: ObjectHandle; newView: ViewType);
  FORWARD;
PROCEDURE CheckContents(obj: ObjectHandle);
  FORWARD;
PROCEDURE CheckLoc(container: ObjectHandle; VAR loc: Point; VAR changed: BOOLEAN);
  FORWARD;
PROCEDURE CheckObject(obj: ObjectHandle);
  FORWARD;
FUNCTION  CheckPasswords(volHdl: TentryHdl; catRID: TcatRID; excludeUnfiled: BOOLEAN;
                         VAR foundOne: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  ChooseHome(obj: ObjectHandle; VAR newHomeLoc: Point): BOOLEAN;
  FORWARD;
PROCEDURE ChoosePos(container: ObjectHandle; VAR pos: Point);
  FORWARD;
FUNCTION  CleanupDisk(diskObj: ObjectHandle; recordDesktop: BOOLEAN): BOOLEAN;
  FORWARD;
PROCEDURE ClimbTree(whichVol: TentryHdl; recID: TcatRID;
                    VAR fatherRecID: TcatRID; VAR fatherObj: ObjectHandle);
  FORWARD;
PROCEDURE ClipContent(obj: ObjectHandle);
  FORWARD;
PROCEDURE ClipName(obj: ObjectHandle);
  FORWARD;
FUNCTION  CloseContents(obj: ObjectHandle; putback,suspendDocs: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  CloseObject(obj: ObjectHandle; sonsAlso,putBack,
                                                  suspendDoc: BOOLEAN): BOOLEAN;
  FORWARD;
PROCEDURE CommandKey;
  FORWARD;
FUNCTION  CopyContents(obj: ObjectHandle; whichState: ObjectState; dh,dv: INTEGER;
                       chooseAhome: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  CopyObject(obj: ObjectHandle; newParent: IdType;
                     chooseAhome: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  CountContents(obj: ObjectHandle): INTEGER;
  FORWARD;
PROCEDURE DeskMgr;
  FORWARD;
PROCEDURE DoAbortEvent;
  FORWARD;
PROCEDURE DoActivateEvent;
  FORWARD;
PROCEDURE DoBtnDownEvent;
  FORWARD;
PROCEDURE DoBtnUpEvent;
  FORWARD;
PROCEDURE DoCatalogEvent;
  FORWARD;
PROCEDURE DoDeactivateEvent;
  FORWARD;
PROCEDURE DoDiskEvent;
  FORWARD;
PROCEDURE DoFilerEvent;
  FORWARD;
PROCEDURE DoKeyDownEvent;
  FORWARD;
PROCEDURE DoMovedEvent;
  FORWARD;
PROCEDURE DoUpdateEvent;
  FORWARD;
PROCEDURE DragContents(obj: ObjectHandle;
                       whichState: ObjectState;
                       whichKinds: KindSet;
                       tallyCount: INTEGER;
                       startPt : Point;
                       pointAt: ObjectHandle;
                       VAR targetContainer: ObjectHandle;
                       VAR targetIcon: ObjectHandle;
                       VAR targetMatch: BOOLEAN;
                       VAR dh,dv: INTEGER;
                       maxDh,maxDv,minDh,minDv: INTEGER);
  FORWARD;
PROCEDURE DragRect(obj: ObjectHandle; startPt: Point; VAR dstRect: Rect);
  FORWARD;
PROCEDURE DrawContents(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawInsides(obj: ObjectHandle; wantScroll: BOOLEAN);
  FORWARD;
PROCEDURE DrawList(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawName(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawObject(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawRow(obj: ObjectHandle; erase: BOOLEAN);
  FORWARD;
PROCEDURE DrawSpatial(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawSymbol(obj: ObjectHandle; pt: Point; invert: BOOLEAN);
  FORWARD;
PROCEDURE DrawTinyObject(obj: ObjectHandle; invert: BOOLEAN);
  FORWARD;
PROCEDURE DrawTheIcon(obj: ObjectHandle);
  FORWARD;
PROCEDURE DupContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
PROCEDURE EditCommands(menuItem: INTEGER);
  FORWARD;
PROCEDURE EditName(obj: ObjectHandle; pt: Point);
  FORWARD;
FUNCTION  EmptyGridSpot(container: ObjectHandle; gridSpot: INTEGER): BOOLEAN;
  FORWARD;
FUNCTION  EmptyTrashCan(volHdl: TentryHdl; diskAlso, showAlert: BOOLEAN): BOOLEAN;
  FORWARD;
PROCEDURE EndEdit;
  FORWARD;
PROCEDURE EraseDisk(diskObj: ObjectHandle);
  FORWARD;
PROCEDURE FailedAlert;
  FORWARD;
FUNCTION  FindToolNode(toolNumber: LongInt; makeOne: BOOLEAN): HdlToolNode;
  FORWARD;
PROCEDURE FindVisHome(obj: ObjectHandle; VAR visHome: ObjectHandle;
                                         VAR visPt: Point);
  FORWARD;
PROCEDURE FindVisParent(obj: ObjectHandle; VAR visParent: ObjectHandle);
  FORWARD;
PROCEDURE FldEditError(err: INTEGER);
  FORWARD;
PROCEDURE FlushObject(obj: ObjectHandle);
  FORWARD;
PROCEDURE FlushTypeAhead(toFront: BOOLEAN);
  FORWARD;
PROCEDURE FlushVols;
  FORWARD;
FUNCTION  ForeignDisk(obj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  GenContents(obj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE GenTrashContents;
  FORWARD;
PROCEDURE GetContentRect(obj: ObjectHandle; VAR r: Rect);
  FORWARD;
PROCEDURE GetFldStr(hFld: HndField; hFstate: HndFstate; VAR strg: FMaxStr);
  FORWARD;
FUNCTION  GetHomeObj(obj: ObjectHandle): ObjectHandle;
  FORWARD;
PROCEDURE GetIconRect(obj: ObjectHandle; VAR bbox: Rect);
  FORWARD;
PROCEDURE GetIcons(obj: ObjectHandle; VAR shapeFont: Tfam; VAR mask,data: CHAR;
                                      VAR faceFont: Tfam;  VAR overlay: CHAR;
                                      VAR iconBBox: Rect);
  FORWARD;
PROCEDURE GetListPos(obj: ObjectHandle; tinyIcon: BOOLEAN; VAR pt: Point);
  FORWARD;
PROCEDURE GetNameLoc(obj: ObjectHandle; VAR fldPt: Point);
  FORWARD;
PROCEDURE GetObjTitle(obj: ObjectHandle; addQuotes: BOOLEAN; VAR title: FmaxStr);
  FORWARD;
FUNCTION  GetPlaceHolder(obj: ObjectHandle): ObjectHandle;
  FORWARD;
FUNCTION  GetToolInfo(obj: ObjectHandle; VAR toolInfo: TtoolInfo): BOOLEAN;
  FORWARD;
PROCEDURE GetVisLoc(obj: ObjectHandle; withinContainer: BOOLEAN; VAR pt: Point);
  FORWARD;
PROCEDURE GridToPt(container: ObjectHandle; gridSpot: INTEGER; VAR pt: Point);
  FORWARD;
FUNCTION  GrowHeap(hz: Thz; bytesNeeded: INTEGER): INTEGER;
  FORWARD;
PROCEDURE HandleWhyActivated(event : EventRecord);
  FORWARD;
PROCEDURE HideScroll(obj: ObjectHandle);
  FORWARD;
PROCEDURE HitContainer(obj: ObjectHandle);
  FORWARD;
PROCEDURE HitGrowIcon(obj: ObjectHandle; ptDown: Point);
  FORWARD;
PROCEDURE HitMenuBar;
  FORWARD;
PROCEDURE HitOrphan(obj: ObjectHandle);
  FORWARD;
PROCEDURE HitScrap;
  FORWARD;
PROCEDURE HitScrollBar(obj: ObjectHandle; whichSb: THsb; whichIcon: TIcon);
  FORWARD;
PROCEDURE IdleTasks;
  FORWARD;
FUNCTION  IgnoreDeactivate: BOOLEAN;
  FORWARD;
FUNCTION  InCopyMode: BOOLEAN;
  FORWARD;
FUNCTION  InGrowIcon(obj: ObjectHandle; pt: Point): BOOLEAN;
  FORWARD;
PROCEDURE Initialize;
  FORWARD;

{$IFC flrJrnl }
PROCEDURE InitJournal;
  FORWARD;
{$ENDC }

PROCEDURE InitMatchTable;
  FORWARD;
PROCEDURE InitObjects;
  FORWARD;
FUNCTION  InListView(obj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  InScrollBar(obj: ObjectHandle; pt: Point; VAR whichSb: THsb;
                                                    VAR whichIcon: TIcon): BOOLEAN;
  FORWARD;
FUNCTION  InSpatialView(obj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE InstallMenus;
  FORWARD;
PROCEDURE InvertContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
PROCEDURE InvertObject(obj: ObjectHandle);
  FORWARD;
FUNCTION  IsContainer(obj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  IsFather(obj,aContainer: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  IsOrphan(obj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE KillContents(obj: ObjectHandle; sonsAlso,erase: BOOLEAN);
  FORWARD;
PROCEDURE KillDuplicates(container: ObjectHandle);
  FORWARD;
PROCEDURE KillObject(obj: ObjectHandle; sonsAlso,erase: BOOLEAN);
  FORWARD;
PROCEDURE KillScroll(window : WindowPtr; needUpdate: BOOLEAN);
  FORWARD;
PROCEDURE LastWishes(environPtr : P_env_blk; excepDataPtr : P_term_ex_data);
  FORWARD;
FUNCTION  LiveObject(obj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE MakeObjActive(obj: ObjectHandle);
  FORWARD;
FUNCTION  MakeObject(father:      ObjectHandle;
                     name:        FmaxStr;
                     whatKind:    ObjectKind;
                     whatTool:    LongInt;
                     where:       Point;
                     windRect:    Rect;
                     newState:    ObjectState;
                     whatView:    ViewType;
                     whichVol:    TentryHdl;
                     recId:       TcatRID;
                     createTime:  LongInt;
                     modTime:     LongInt;
                     diskSize:    LongInt;
                     diskSplit:   BOOLEAN;
                     accessCtrl:  BOOLEAN): ObjectHandle;
  FORWARD;
PROCEDURE MakePadContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
FUNCTION  Match(target: ObjectHandle; srcSet: KindSet; srcCount: INTEGER): BOOLEAN;
  FORWARD;
PROCEDURE MenuCommand(menu,item: INTEGER);
  FORWARD;
FUNCTION  MountAll(mountThem: BOOLEAN): BOOLEAN;
  FORWARD;
PROCEDURE MountAvolume(device: Tdevice);
  FORWARD;
FUNCTION  MoveContents(obj:        ObjectHandle;
                       whichState: ObjectState;
                       newState:   ObjectState;
                       dh,dv:      INTEGER;
                       dstObj:     ObjectHandle;
                       chooseLoc:  BOOLEAN;
                       eraseDim:   BOOLEAN;
                       VAR splitflag: BOOLEAN;
                       VAR joinflag: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  MoveObject(obj:       ObjectHandle;
                     newState:  ObjectState;
                     dh,dv:     INTEGER;
                     dstObj:    ObjectHandle;
                     chooseLoc: BOOLEAN;
                     eraseDim:  BOOLEAN;
                     splitflag: BOOLEAN;
                     VAR joinflag:  BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  MoveToDesk(obj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  MoveToDiffVol(obj,dstObj: ObjectHandle; splitflag,joinflag: BOOLEAN;
              VAR diskgone: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  MoveToSameVol(obj: ObjectHandle; newParent: IDType): BOOLEAN;
  FORWARD;
FUNCTION  MoveToTrash(obj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  MoveUnfiled(obj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  MyWindow(window: WindowPtr): BOOLEAN;
  FORWARD;
FUNCTION  NameWidth(obj: ObjectHandle): INTEGER;
  FORWARD;
PROCEDURE NearestEmpty(obj: ObjectHandle; startLoc: Point; stayInWindow: BOOLEAN;
                       VAR emptyLoc: Point);
  FORWARD;
FUNCTION  NearList(listHead: ObjectHandle; pt: Point): ObjectHandle;
  FORWARD;
FUNCTION  NewObjList(father: ObjectHandle): ObjectHandle;
  FORWARD;
FUNCTION  NewWindow(obj: ObjectHandle; title: FmaxStr): WindowPtr;
  FORWARD;
PROCEDURE NormalEnvironment(obj: ObjectHandle);
  FORWARD;
FUNCTION  NumFromObj(obj: ObjectHandle): INTEGER;
  FORWARD;
FUNCTION  NumGridCols(obj: ObjectHandle): INTEGER;
  FORWARD;
FUNCTION  ObjFromVol(volHdl: TentryHdl): ObjectHandle;
  FORWARD;
FUNCTION  ObjFromWindow(window : WindowPtr): ObjectHandle;
  FORWARD;
PROCEDURE ObjToBack(obj: ObjectHandle);
  FORWARD;
PROCEDURE ObjToFront(obj: ObjectHandle; redraw: BOOLEAN);
  FORWARD;
FUNCTION  OnDesktop(whichVol: TentryHdl; objID: IDType): BOOLEAN;
  FORWARD;
FUNCTION  OneDiskSelected(VAR diskObj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  OnGridPt(obj: ObjectHandle; VAR gridSpot: INTEGER ): BOOLEAN;
  FORWARD;
PROCEDURE OpenContents(obj: ObjectHandle; whichState : ObjectState);
  FORWARD;
FUNCTION  OpenFont(volHdl: TentryHdl; toolNum: LongInt; VAR font: Tfam): BOOLEAN;
  FORWARD;
FUNCTION  OpenObject(obj: ObjectHandle; startTool: BOOLEAN): BOOLEAN;
  FORWARD;
PROCEDURE Pause(hundredths: INTEGER);
  FORWARD;
PROCEDURE PasteIcons;
  FORWARD;
PROCEDURE PasteRef;
  FORWARD;
PROCEDURE PhotoContents(obj: ObjectHandle; takePhoto: BOOLEAN);
  FORWARD;
PROCEDURE PhotoObject(obj: ObjectHandle; takePhoto: BOOLEAN; sonsAlso: BOOLEAN);
  FORWARD;
PROCEDURE ProcessTheEvent;
  FORWARD;
FUNCTION  PutBackContents(obj: ObjectHandle; whichStates: StateSet;
                                             suspendDocs: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  PutBackObject(obj: ObjectHandle;
                        sonsAlso: BOOLEAN;
                        suspendDoc: BOOLEAN;
                        selectHome: BOOLEAN;
                        VAR homeObj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE ReferenceIcons(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
PROCEDURE RemoveWindow(obj: ObjectHandle; destroyIt: BOOLEAN);
  FORWARD;
PROCEDURE RepairDisk(diskObj: ObjectHandle);
  FORWARD;
FUNCTION  RestoreDesktop(whichVol: TentryHdl; newDisk: BOOLEAN; VAR diskObj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  RoomForContents(obj: ObjectHandle; whichState: ObjectState;
                          volHdl: TentryHdl; VAR failVol: TentryHdl): BOOLEAN;
  FORWARD;
FUNCTION  RoomForObject(obj: ObjectHandle; volHdl: TentryHdl): BOOLEAN;
  FORWARD;
PROCEDURE SaveDesktop(diskObj: ObjectHandle);
  FORWARD;
FUNCTION  ScrapIsText: BOOLEAN;
  FORWARD;
PROCEDURE ScrollContents(obj: ObjectHandle; dh,dv,minH,minV,maxH,maxV: INTEGER;
                         adjustThumb: BOOLEAN);
  FORWARD;
PROCEDURE ScrollEnvironment(obj: ObjectHandle);
  FORWARD;
PROCEDURE ScrollLimits(obj: ObjectHandle; VAR minH,minV,maxH,maxV: INTEGER);
  FORWARD;
PROCEDURE ScrollToRect(obj: ObjectHandle; r: Rect);
  FORWARD;
FUNCTION  SearchContents(obj: ObjectHandle; hVol: TentryHdl; id: IDType;
                                 skipPlaceHolder,sonsAlso: BOOLEAN): ObjectHandle;
  FORWARD;
FUNCTION  SearchObject(obj: ObjectHandle; hVol: TentryHdl; id: IDType;
                                 skipPlaceHolder,sonsAlso: BOOLEAN): ObjectHandle;
  FORWARD;
PROCEDURE SelAllObjects(container: ObjectHandle);
  FORWARD;
PROCEDURE SelectContents(obj: ObjectHandle; groupRect: Rect);
  FORWARD;
PROCEDURE SelectObject(obj: ObjectHandle; hitName: BOOLEAN);
  FORWARD;
PROCEDURE SelectName(obj: ObjectHandle; hitName: BOOLEAN);
  FORWARD;
PROCEDURE SetAttributes(obj: ObjectHandle; VAR changed: BOOLEAN);
  FORWARD;
PROCEDURE SetHomePt(obj: ObjectHandle; pt: Point);
  FORWARD;
PROCEDURE SetTimeout(interval: INTEGER);
  FORWARD;
PROCEDURE ShowFld(pStr: PtrString; r: Rect; theAlign: INTEGER; theFont: TFam;
                  theFace: Style; erase: BOOLEAN);
  FORWARD;
PROCEDURE ShowFldAt(pStr: PtrString; pt: Point; theAlign: INTEGER; font: TFam;
                    VAR fldRect: Rect);
  FORWARD;
PROCEDURE ShowScrap;
  FORWARD;
PROCEDURE ShowScroll(obj: ObjectHandle);
  FORWARD;
PROCEDURE ShrinkHeap;
  FORWARD;
PROCEDURE ShutDown;
  FORWARD;
FUNCTION  SkipEvent: BOOLEAN;
  FORWARD;
PROCEDURE SortContents(obj: ObjectHandle; newView: viewType);
  FORWARD;
{$IFC flrDebug}
PROCEDURE SplitObj(obj: ObjectHandle);
  FORWARD;
{$ENDC}
FUNCTION  StopDoc(obj: ObjectHandle; suspendDoc,forSure: BOOLEAN): BOOLEAN;
  FORWARD;
PROCEDURE TallyContents(obj: ObjectHandle;
                        whichState: ObjectState;
                        namesAlso: BOOLEAN;
                        VAR partial: BOOLEAN;
                        VAR tallyCount: INTEGER;
                        VAR tallySet: KindSet;
                        VAR tallyBBox: Rect;
                        VAR topObject: ObjectHandle);
  FORWARD;
PROCEDURE TearOffContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
FUNCTION  TearOffObject(padObj: ObjectHandle; VAR newObj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE TextKey;
  FORWARD;
FUNCTION  TextSelected: BOOLEAN;
  FORWARD;
FUNCTION  ThumbHpos(obj: ObjectHandle; minH,maxH: INTEGER): INTEGER;
  FORWARD;
FUNCTION  ThumbVpos(obj: ObjectHandle; minV,maxV: INTEGER): INTEGER;
  FORWARD;
PROCEDURE ToggleObject(obj: ObjectHandle);
  FORWARD;
FUNCTION  UnfiledSize(obj: ObjectHandle): LongInt;
  FORWARD;
FUNCTION  UnfileObject(obj: ObjectHandle; deskPt: Point): BOOLEAN;
  FORWARD;
FUNCTION  UnmountAvolume(device: Tdevice; eject,restartDocs,recordDesktop: BOOLEAN;
                                          alertNum: INTEGER): BOOLEAN;
  FORWARD;
PROCEDURE UpdateAll;
  FORWARD;
PROCEDURE UpdateAttributes(obj: ObjectHandle; parentsOnly: BOOLEAN);
  FORWARD;
PROCEDURE UpdateContents(obj: ObjectHandle);
  FORWARD;
PROCEDURE UpdateCursor;
  FORWARD;
PROCEDURE UpdateField;
  FORWARD;
PROCEDURE UpdateObject(obj: ObjectHandle; sonsAlso: BOOLEAN);
  FORWARD;
PROCEDURE UpdateRec(obj: ObjectHandle; VAR catRec: TcatRec);
  FORWARD;
PROCEDURE UpdateRow(obj: ObjectHandle);
  FORWARD;
PROCEDURE UpdateText;
  FORWARD;
FUNCTION  UserAbort: BOOLEAN;
  FORWARD;
PROCEDURE ValidContents(obj: ObjectHandle; whichState: ObjectState; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidIcon(obj: ObjectHandle; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidName(obj: ObjectHandle; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidObject(obj: ObjectHandle; good: BOOLEAN);
  FORWARD;
PROCEDURE ValRect(r: Rect; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidScrollBars(window : WindowPtr; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidWindow(window: WindowPtr; good: BOOLEAN);
  FORWARD;
FUNCTION  Visible(r: Rect): BOOLEAN;
  FORWARD;
FUNCTION  VolInContents(obj: ObjectHandle; whichState: ObjectState; whichVol: TentryHdl): BOOLEAN;
  FORWARD;
PROCEDURE WalkHome(obj: ObjectHandle; VAR homeObj: ObjectHandle);
  FORWARD;
PROCEDURE WalkContents(obj: ObjectHandle; whichState: ObjectState;
                       dhStart,dvStart,dhStop,dvStop: INTEGER);
  FORWARD;
PROCEDURE WalkObject(obj: ObjectHandle; dhStart,dvStart,dhStop,dvStop: INTEGER;
                     whichWindow: WindowPtr);
  FORWARD;
FUNCTION  WhichObject(container: ObjectHandle; r: Rect; ignoreNames: BOOLEAN;
                      VAR hitName: BOOLEAN): ObjectHandle;
  FORWARD;
FUNCTION  WhichWindow(pt: Point): WindowPtr;
  FORWARD;
PROCEDURE WriteLabel(obj: ObjectHandle);
  FORWARD;
FUNCTION  WriteName(obj: ObjectHandle): CHAR;
  FORWARD;
PROCEDURE XorContents(obj: ObjectHandle; whichState: ObjectState;
                      dh,dv: INTEGER; whichWindow: WindowPtr);
  FORWARD;
PROCEDURE XorObject(obj: ObjectHandle; dh,dv: INTEGER; whichWindow: WindowPtr);
  FORWARD;
PROCEDURE ZoomObject(obj: ObjectHandle; zoomUp: BOOLEAN);
  FORWARD;
PROCEDURE ZoomRect(VAR smallRect,bigRect: Rect; zoomUp: BOOLEAN);
  FORWARD;

{**** Attributes code: Forward declaration of procedures ****}

{ first the general dialog box routines (apdm/desk3) }
FUNCTION AddDiPanel : PanelHandle;
  FORWARD;
PROCEDURE ClearDiField (thePanel: PanelHandle);
  FORWARD;
PROCEDURE ClipDiName (VAR name: FmaxStr; maxSize: INTEGER; isQuoted: BOOLEAN);
  FORWARD;
PROCEDURE CloseDiBox;
  FORWARD;
PROCEDURE DiCommandKey;
  FORWARD;
PROCEDURE DiFieldEdit;
  FORWARD;
PROCEDURE DispHandle (h: Handle);
  FORWARD;
PROCEDURE DiTextKey;
  FORWARD;
PROCEDURE DoDiBtnDown;
  FORWARD;
PROCEDURE DoDiBtnUp;
  FORWARD;
PROCEDURE DoDiFinished (reQueue: BOOLEAN);
  FORWARD;
PROCEDURE DoDiUpdate;
  FORWARD;
PROCEDURE DrawDiButton (VAR info: PanelRec; outline: rect);
  FORWARD;
PROCEDURE DrawDiLabel (VAR info: PanelRec; outline: rect);
  FORWARD;
PROCEDURE DrawDiLine (VAR info: PanelRec; outline: rect);
  FORWARD;
PROCEDURE DrawDiRect (outline: rect);
  FORWARD;
PROCEDURE DrawPanel (thePanel: PanelHandle);
  FORWARD;
FUNCTION  InDialog : BOOLEAN;
  FORWARD;
PROCEDURE InitDiBox;
  FORWARD;
FUNCTION  NewDiPanel (VAR reference: INTEGER) : PanelHandle;
  FORWARD;
PROCEDURE RmvDiBox;
  FORWARD;
PROCEDURE SelDiField (thePanel: PanelHandle; drawNow: BOOLEAN);
  FORWARD;
PROCEDURE SetDiButton (thePanel: PanelHandle; location: Point; text: str255; buttonface: Style;
                       buttonFont, buttonLine, buttonWidth: INTEGER; isVisible: BOOLEAN; doIt: TProc);
  FORWARD;
PROCEDURE SetDiField (thePanel: PanelHandle; location: Point; text: FmaxStr; fieldFace: Style;
                        fieldFont: INTEGER; maxSize: INTEGER; isVisible: BOOLEAN);
  FORWARD;
PROCEDURE SetDiLabel (thePanel: PanelHandle; location: Point; text: str255; labelface: Style;
                      labelfont: INTEGER; isVisible: BOOLEAN);
  FORWARD;
PROCEDURE SetDiLine (thePanel: PanelHandle; startLine, stopLine: Point; widthOfPen: INTEGER;
                       patOfPen: Pattern; isVisible: BOOLEAN);
  FORWARD;
PROCEDURE SetDiRect (thePanel: PanelHandle; theRect: rect; isVisible: BOOLEAN);
  FORWARD;
PROCEDURE SetNullProcs (VAR myGrafProcs: QDProcs);
  FORWARD;
PROCEDURE ShowDiBox;
  FORWARD;
PROCEDURE ShowDiBtn (thePanel: PanelHandle; isSelected: BOOLEAN);
  FORWARD;
PROCEDURE StartDiPic;
  FORWARD;
PROCEDURE StopDiBox;
  FORWARD;
PROCEDURE StopDiPic;
  FORWARD;
FUNCTION  TestDiBox : PanelHandle;
  FORWARD;
PROCEDURE TestDiPanel (kind, dataSize: INTEGER; dataHandle: QDHandle);
  FORWARD;
PROCEDURE UseDiBox;
  FORWARD;

{ the dialog specific routines (apdm/desk4) }
PROCEDURE AttCancelBtn;
  FORWARD;
PROCEDURE AttDoneBtn;
  FORWARD;
PROCEDURE AttEnterBtn;
  FORWARD;
PROCEDURE AttNoPassBtn;
  FORWARD;
FUNCTION AttError (myError, error: INTEGER) : BOOLEAN;
  FORWARD;
FUNCTION AttObjInfo (obj: ObjectHandle; VAR diInfo: dialogInfo) : BOOLEAN;
  FORWARD;
PROCEDURE BreakInTwo (source: FmaxStr; maxSize: INTEGER; VAR firstStr, secondStr: FmaxStr);
  FORWARD;
PROCEDURE GetADocName (VAR error: INTEGER; selfIdent: IdType; toolIdent: tToolId; volHdl: TEntryHdl;
                       VAR path: Pathname);
  FORWARD;
PROCEDURE GetAFldrName (VAR error: INTEGER; selfIdent: IdType; volHdl: TEntryHdl;
                        VAR path: Pathname);
  FORWARD;
FUNCTION  GetPassField : BOOLEAN;
  FORWARD;
FUNCTION  GetPassword (volHdl: TEntryHdl; CatRID: TCatRID; VAR passwd: E_Name) : BOOLEAN;
  FORWARD;
PROCEDURE InitPwdFields;
  FORWARD;
PROCEDURE PassCancelBtn;
  FORWARD;
PROCEDURE PassEnterBtn;
  FORWARD;
PROCEDURE ProtAttDiBox;
  FORWARD;
PROCEDURE ResetPwdFields;
  FORWARD;
PROCEDURE SetAttDiBox (obj: ObjectHandle; VAR noError: BOOLEAN);
  FORWARD;
PROCEDURE SetPassDiBox (volHdl: TEntryHdl; catRec: TcatRec; VAR noError: BOOLEAN);
  FORWARD;
PROCEDURE ShowAttributes (obj: ObjectHandle);
  FORWARD;

{ external assembly language routine in apdm/asm.text }
PROCEDURE DoDiBtn (btnProc: TProc);
  EXTERNAL;

{**** End of Attributes code ****}

{$I Apdm/Desk3.text }
{$I Apdm/Desk4.text }



{$S flrDm }
PROCEDURE AdjustContents{* obj: ObjectHandle; whichState: ObjectState *};
{ moves objects in "whichState" to non-overlapping positions }
VAR listHead,son: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state = whichState THEN AdjustObject(son,FALSE);
   son := son^^.next;
   END;
END;


{$IFC network }
{$S flrCold }
PROCEDURE AdjustIcon(obj: ObjectHandle);
{ adjusts the icon shape according to state.  Currently used only for in/out
  baskets }
VAR err: INTEGER;
    pCatRec: PtrCatRec;
    empty: BOOLEAN;
    oldKind,newKind: ObjectKind;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF (obj <> inBoxObject) AND (obj <> outBoxObject) THEN EXIT(AdjustIcon);

   { check catalog for entries in in/out box container }

posApprox.fatherId := obj^^.catRID.uniqueID;
PosCatRec(err,obj^^.volHdl,posApprox,pCatRec);
empty := err <> 0;

oldKind := obj^^.kind;

   { determine the appropriate icon kind }

IF obj = inBoxObject THEN
   IF empty THEN
      newKind := inBox1Kind
   ELSE
      newKind := inBox2Kind
ELSE
   IF empty THEN
      newKind := outBox1Kind
   ELSE
      newKind := outBox2Kind;

IF newKind = oldKind THEN EXIT(AdjustIcon);    { no change }

ValidIcon(obj,FALSE);                { invalidate the area under the old icon }
obj^^.kind := newKind;               { switch to new icon }
ValidIcon(obj,FALSE);                { invalidate the area under the new icon }

UpdateObject(deskObject,FALSE);      { force redraw now }
END;
{$ENDC }



{$S dmMain }
PROCEDURE AdjustDesktopMenu;
{ Creates the menu text for the desktop menu.  Very similar to the window mgr's Menus.SetItem
  but done this way to improve performance.  }
VAR
    dstPtr:   ^Str255;
    i,j:       INTEGER;
    icon:      STRING[1];
    itemStr:   Str255;
    len:       INTEGER;
    listHead:  ObjectHandle;
    overlay:   STRING[1];
    son:       ObjectHandle;
    sorted:    BOOLEAN;
    whichTool: TtoolID;

  PROCEDURE WalkTree (obj: ObjectHandle);
  { this proc walks the tree and puts the object handle of each open window in deskList }
  VAR listHead: ObjectHandle;
      son:      ObjectHandle;

  BEGIN
  listHead := obj^^.contents;
  son := listHead^^.next;
  WHILE son <> listHead DO
     BEGIN
     IF son^^.state = openState THEN
        BEGIN
        i := i + 1;
        deskList[i] := son;
        WalkTree (son);   { only an open container can have an open son that is not on the desktop }
        END;
     son := son^^.next;
     END;
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('AdjustDesktopMenu');

{ create the deskList, i.e. an ordered list of windows and icons on the desktop }
FOR i := 1 TO 23 DO deskList[i] := NIL;
i := 0;
WalkTree (deskObject);  { put all windows into the deskList }

{ add icons on the desktop to the deskList }
listHead := deskObject^^.contents;
son := listHead^^.next;
WHILE (son <> listHead) AND (i < 22) DO
   BEGIN
   IF son^^.state IN [normal, hilited] THEN
      BEGIN
      i := i + 1;
      deskList[i] := son;
      END;
   son := son^^.next;
   END;

{ sort the desklist }
REPEAT
  sorted := TRUE;
  FOR j := 1 TO i-1 DO BEGIN
    IF (CompStrMagnitude(@deskList[j+1]^^.nameHdl^^, @deskList[j]^^.nameHdl^^,TRUE) < 0)
    THEN BEGIN
      sorted := FALSE;
      son := deskList[j];
      deskList[j] := deskList[j+1];
      deskList[j+1] := son;
      END;
    END;
  UNTIL sorted;

{ ready the menu data structure }
SetSize (desktopMenu[1].menuData, 800{maxBytes from libwm/menus});  { extend to full size }
dstPtr := POINTER(ORD(desktopMenu[1].menuData^));

{ skip past the title }
len := LENGTH(dstPtr^);
dstPtr := POINTER(ORD(dstPtr) + len + 1);

{ add each of the menu items to the menu text }
icon := ' ';
overlay := ' ';
i := 1;
IF deskList[1] <> NIL THEN REPEAT
   son := deskList[i];

   { build the menu item entry, i.e. icon char, overlay char, icon user name, apple key, check char, style }
   icon[1] := tinyData[son^^.kind];
   whichTool := son^^.toolNumber;
   IF (whichTool > deskTool) AND (whichTool <= maxKnownTool) THEN
      overlay[1] := tinyOverlay[whichTool]
   ELSE
      overlay[1] := CHR(noIcon);
   itemStr := CONCAT(icon,overlay,son^^.nameHdl^^);
   len := LENGTH (itemStr);
   {$R-}
   itemStr[len+1] := ' ';             { blank apple key command }
   itemStr[len+2] := CHR(checkMark);  { standard check mark     }
   itemStr[len+3] := ' ';             { blank style             }
   {$R+}

   { add the menu item to the menu text }
   MoveLeft (itemStr, dstPtr^, len+4);
   dstPtr := POINTER(ORD(dstPtr) + len + 4);

   { set the check flag if the icon's window is open }
   CheckItem(desktopMenu[1], i, (son^^.state = openState));
   i := i + 1;
   UNTIL deskList[i] = NIL;

dstPtr^ := '';    { add a null string to denote the end of the menu text }
dstPtr := POINTER(ORD(dstPtr) + 2);  { bump past the null string }

{ calculate the menu's dimensions }
SetSize (desktopMenu[1].menuData,
         (ORD(dstPtr) - ORD(desktopMenu[1].menuData^)));  { trim the menu text heap object }
CalcMenuSize (desktopMenu[1]);                      { width  }
desktopMenu[1].menuHeight := (i-1) * vertSpace;     { height }

END;


{$S dmMain }
PROCEDURE AdjustMenus;
{ adjusts menu enable/disable state and menu text according to the selection }
VAR diskObj,topObject: ObjectHandle;
    dstPtr: ^Str255;
    len:  INTEGER;
    tallyCount: INTEGER;
    tallySet: KindSet;
    tallyBBox: Rect;
    oneDisk,deskActive: BOOLEAN;
    partial: BOOLEAN;
    removable: BOOLEAN;
    enableViewItems,enablePutback,enableOpen: BOOLEAN;
    itemString: Str255;
    buzzWord: Str255;
    topObjTitle,actObjTitle,trashTitle: FmaxStr;
    aContainer: BOOLEAN;
    theTime:   MilliSeconds;


   PROCEDURE AddItem (VAR itemStr: Str255; appleChar: CHAR);
   BEGIN
   len := LENGTH (itemStr);
   {$R-}
   itemStr[len+1] := appleChar;       { blank apple key command }
   itemStr[len+2] := ' ';             { no check mark           }
   itemStr[len+3] := ' ';             { blank style             }
   {$R+}

   { add the menu item to the menu text }
   MoveLeft (itemStr, dstPtr^, len+4);
   dstPtr := POINTER(ORD(dstPtr) + len + 4);
   END;


  PROCEDURE AdjustItem(menuId,itemId : INTEGER; enable: BOOLEAN);
  BEGIN
  IF enable THEN
      EnableItem(flrMenus[menuId],itemId)
  ELSE
      DisableItem(flrMenus[menuId],itemId);
  END;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('AdjustMenus');

IF trcFDocCtrl THEN theTime := Timer;
AdjustDesktopMenu;
IF trcFDocCtrl THEN
   BEGIN
   WRITELN ('milliseconds to adjust desk menu: ',(Timer-theTime):1);
   theTime := Timer;
   END;

TallyContents(activeObject,hilited,FALSE,partial,tallyCount,tallySet,
              tallyBBox,topObject);
oneDisk := OneDiskSelected(diskObj);
deskActive := activeObject = deskObject;
GetObjTitle(topObject,TRUE,topObjTitle);
GetObjTitle(activeObject,TRUE,actObjTitle);

{ add each of the menu items to the menu text }

   { SetAside menu item.  Concatenate name of active window }

itemString := xtraStrgs[xClose]^^;
IF NOT deskActive THEN
   itemString := CONCAT(itemString,' ',actObjTitle);

IF activeObject = scrapObject THEN
   BEGIN
   SetItem(flrMenus[scrapMenu],mClose,@itemString);
   EXIT(AdjustMenus);
   END;

{ ready the filing menu data structure }
SetSize (flrMenus[filingMenu].menuData, 800{maxBytes from libwm/menus});  { extend to full size }
dstPtr := POINTER(ORD(flrMenus[filingMenu].menuData^));
len := LENGTH(dstPtr^);                         { skip past the title }
dstPtr := POINTER(ORD(dstPtr) + len + 1);
len := LENGTH(dstPtr^);                         { Skip the Set Aside All menu item }
dstPtr := POINTER(ORD(dstPtr) + len + 4);

AddItem(itemString,' ');                        { Append the Set Aside menu item }
AdjustItem(filingMenu,mClose,(NOT deskActive));

itemString := '-';
AddItem(itemString,' ');                            { Append blank line }
AdjustItem(filingMenu,mCloseAll,(TopWindow <> filerFolder));

   { Put Back menu item.  Concatenate name of active window or desk icon(s) }

enablePutBack := TRUE;
itemString := xtraStrgs[xPutBack]^^;
IF activeObject^^.kind IN putBackSet THEN
   itemString := CONCAT(itemString,' ',actObjTitle)
ELSE IF deskActive AND ((tallySet * putBackSet) <> []) THEN
   BEGIN
   IF tallyCount = 1 THEN
      itemString := CONCAT(itemString,' ',topObjTitle)
   ELSE
      itemString := CONCAT(itemString,' ',xtraStrgs[xObjects]^^);
   END
ELSE
   enablePutBack := FALSE;

AddItem(itemString,' ');                             { Append the Put Back Menu item }
AdjustItem(filingMenu,mPutBack,enablePutBack);


   { Open menu item.  Concatentate name of icon(s) }

itemString := xtraStrgs[xOpen]^^;
enableOpen := (tallyCount > 0) AND (tallySet <= openSet);
IF enableOpen THEN
   BEGIN
   IF tallyCount = 1 THEN
      itemString := CONCAT(itemString,' ',topObjTitle)
   ELSE
      itemString := CONCAT(itemString,' ',xtraStrgs[xObjects]^^);
   END;

AddItem(itemString,' ');                             { Append the Open Menu Item }
AdjustItem(filingMenu,mOpen,enableOpen);

itemString := xtraStrgs[xDuplicate]^^;
AddItem(itemString,'D');                             { Append the Duplicate Menu Item }
AdjustItem(filingMenu,mDuplicate,
                      ((tallyCount = 1) AND (topObject^^.kind IN diskSet)) OR
                      ((tallyCount > 0) AND (tallySet <= dupSet)));

   { attributes menu item }

itemString := xtraStrgs[xAttributes]^^;
IF ((tallyCount = 0) AND (NOT deskActive)) THEN
   itemString := CONCAT(itemString,' ',actObjTitle,' ...')
ELSE IF (tallyCount = 1) AND (NOT ForeignDisk(diskObj)) THEN    {*** FI 278 ***}
   itemString := CONCAT(itemString,' ',topObjTitle,' ...')
ELSE
   itemString := CONCAT(itemString,' ...');
AddItem(itemString,' ');
AdjustItem(filingMenu,mAttributes,((tallyCount<=1)
                               AND (NOT ((tallyCount = 0) AND deskActive))
                               AND (NOT ForeignDisk(diskObj))));    {*** FI 278 ***}


   { other items in filing menu }

itemString := xtraStrgs[xNew]^^;
AddItem(itemString,' ');                             { Append the Tear Off Menu Item }
AdjustItem(filingMenu,mNew,(tallyCount > 0) AND (tallySet <= padSet));

itemString := xtraStrgs[xMakePad]^^;
AddItem(itemString,' ');                             { Append the Make Stationery Pad Menu Item }
AdjustItem(filingMenu,mMakePad,(tallyCount > 0) AND
                               (tallySet <= ([docKind,folderKind,letterKind] )));

itemString := '-';
AddItem(itemString,' ');                             { Append a blank line }

itemString := xtraStrgs[xMonitor]^^;
AddItem(itemString,' ');                             { Append the Monitor the printer Menu Item }

itemString := '';
AddItem(itemString,' ');    { add a null string to denote the end of the menu text }

{ calculate the menu's dimensions }
SetSize (flrMenus[filingMenu].menuData,
         (ORD(dstPtr) - ORD(flrMenus[filingMenu].menuData^)));  { trim the menu text heap object }
CalcMenuSize (flrMenus[filingMenu]);                      { width  }

   { Adjust edit menu items }

AdjustItem(editMenu,mCopy,TextSelected);
AdjustItem(editMenu,mCut,TextSelected AND NOT hCurFld^^.protect);
AdjustItem(editMenu,mCopyRef,((tallyCount >= 1) AND (tallySet <= docToolSet)));
aContainer := FALSE;
IF scrapRef IN currScrapSet
THEN IF (((tallyCount = 1) AND (tallySet <= containerSet))
      OR ((tallyCount = 0) AND (activeObject^^.kind IN containerSet)))
     THEN aContainer := TRUE;
AdjustItem(editMenu,mPaste,(aContainer OR
         (ScrapIsText AND (editObject <> nilObject) AND NOT hCurFld^^.protect)));


   { adjust houskeeping menu items }

enableViewItems := IsContainer(activeObject);
AdjustItem(housekeepingMenu,mCompact,enableViewItems AND
                             (activeObject^^.viewMode = spatialView));
enableViewItems := enableViewItems AND NOT deskActive;
AdjustItem(housekeepingMenu,mSpatial,enableViewItems);
AdjustItem(housekeepingMenu,mAlpha,enableViewItems);
AdjustItem(housekeepingMenu,mChron,enableViewItems);
CheckItem(flrMenus[housekeepingMenu],mAlpha,enableViewItems AND
                                      (activeObject^^.viewMode = alphaView));
CheckItem(flrMenus[housekeepingMenu],mChron,enableViewItems AND
                                      (activeObject^^.viewMode = chronView));
CheckItem(flrMenus[housekeepingMenu],mSpatial,enableViewItems AND
                                      (activeObject^^.viewMode = spatialView));
IF oneDisk THEN
   IF deskActive THEN
      buzzWord := topObjTitle
   ELSE
      buzzWord := actObjTitle
ELSE
   buzzword := xtraStrgs[xDisk]^^;
itemString := CONCAT(xtraStrgs[xRepair]^^,' ',buzzword);
SetItem(flrMenus[housekeepingMenu],mRepair,@itemString);
AdjustItem(housekeepingMenu,mRepair,oneDisk);
itemString := xtraStrgs[xErase]^^;
itemString := CONCAT(itemString,' ',buzzWord);
SetItem(flrMenus[housekeepingMenu],mErase,@itemString);
AdjustItem(housekeepingMenu,mErase,oneDisk);
GetObjTitle(trashObject,TRUE,trashTitle);
itemString := CONCAT(xtraStrgs[xEmpty]^^,' ',trashTitle);
SetItem(flrMenus[housekeepingMenu],mEmpty,@itemString);
AdjustItem(housekeepingMenu,mEmpty,((tallyCount=1) AND (trashKind IN tallySet))
                             OR (activeObject^^.kind = trashKind));

IF trcFDocCtrl THEN WRITELN ('milliseconds to adjust all other menus: ',(Timer-theTime):1);
END;


{$S flrDm }
PROCEDURE AdjustObject{* obj: ObjectHandle; stayInWindow: BOOLEAN *};
{ moves an object to a non-overlapping position }
VAR dh,dv: INTEGER;
    whichState: ObjectState;
    emptyLoc: Point;
    window: WindowPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('AdjustObject',WriteName(obj));

NearestEmpty(obj,obj^^.loc,stayInWindow,emptyLoc);
dh := emptyLoc.h - obj^^.loc.h;
dv := emptyLoc.v - obj^^.loc.v;

IF (dh <> 0) OR (dv <> 0) THEN
   IF InSpatialView(obj) THEN
      BEGIN
      ValidObject(obj,FALSE);                { cause erasure at current position }
      whichState := obj^^.state;             { remember object's state }
      window := obj^^.container^^.objWindow; { window to clip to }
      ChangeObject(obj,limbo,0,0,TRUE);     { make gray ghost }
      WalkObject(obj,0,0,dh,dv,window);      { animate to new position }
      ChangeObject(obj,whichState,dh,dv,FALSE);
      ValidObject(obj,FALSE);                { cause redraw at new postion }
      UpdateObject(obj^^.container,FALSE);   { redraw }
      END
   ELSE
      obj^^.loc := emptyLoc;                 { record the spatial location }
END;



{$S flrAll }
PROCEDURE AutoScroll(obj: ObjectHandle; whichState: ObjectState);

{ Tries to scroll the contents of obj so that all objects in "whichState" are
   visible }
VAR topObject: ObjectHandle;
    tallyCount: INTEGER;
    tallySet: KindSet;
    tallyBBox: Rect;
    partial: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('AutoScroll');
IF obj = deskObject THEN EXIT(AutoScroll);

TallyContents(obj,whichState,TRUE,partial,tallyCount,tallySet,tallyBBox,topObject);
IF tallyCount = 0 THEN EXIT(AutoScroll);

IF obj^^.viewMode = spatialView THEN
   InsetRect(tallyBBox,-2,-2);   { add a little spacing }

ScrollToRect(obj,tallyBBox);
END;



{$S DmBackup }
PROCEDURE BackupDisk{* srcDisk,dstDisk: ObjectHandle *};
{ initiates the backup of a disk }
VAR err: INTEGER;
    srcVol,dstVol: TentryHdl;
    srcDev,dstDev: TentryHdl;
    dstDevice: Tdevice;
    dstName: FmaxStr;
    catRec: TcatRec;
    diskInfo: FS_Info;
    diskPathname: Pathname;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('BackupDisk',WriteName(srcDisk),
                         ' to ',WriteName(dstDisk));
IF NOT ((srcDisk^^.kind IN diskSet) AND (dstDisk^^.kind IN diskSet)) THEN
   EXIT(BackupDisk);

{ If this is a duplicate then, use the object handle of the original }
IF srcDisk^^.toBeCopied THEN
   srcDisk := Pointer(srcDisk^^.volHdl^^.devHdl^^.objHdl);

srcVol := srcDisk^^.volHdl;
dstVol := dstDisk^^.volHdl;
dstDevice := dstVol^^.devHdl^^.device;
srcDev := srcVol^^.devHdl;
dstDev := dstVol^^.devHdl;

{ put back everything on source before copy }
IF NOT CleanupDisk(srcDisk,TRUE) THEN EXIT(BackupDisk);

{ put back everything on destination before copy }
IF NOT CleanupDisk(dstDisk,FALSE) THEN EXIT(BackupDisk);

{ do the actual backup }
BackupVol(err,srcDev,dstDev);   { handles error messages }
srcVol := srcDev^^.volHdl;
dstVol := dstDev^^.volHdl;


{ Tell the user if couldn't do the backup }
IF err <> 0 THEN
   TellUser (srcVol,dstVol,diskCatRID,diskCatRID,err,opBackup);

{ install new volume handles }
srcDisk^^.volHdl := srcVol;
IF (srcVol = NIL) AND (srcDev^^.objHdl <> ORD(NIL)) THEN
   BEGIN
   KillObject(srcDisk,TRUE,TRUE);
   srcDev^^.objHdl := ORD(NIL);
   END;
dstDisk^^.volHdl := dstVol;
IF (dstVol = NIL) AND (dstDev^^.objHdl <> ORD(NIL)) THEN
   BEGIN
   KillObject(dstDisk,TRUE,TRUE);
   dstDev^^.objHdl := ORD(NIL);
   END;

{ Update destination disk name (BackupVol changes it) }
IF dstVol <> NIL THEN
   BEGIN
   GetCatRec(err,dstVol,dstDisk^^.catRID,catRec);
   IF err <> 0 THEN EXIT(BackupDisk);
   ExtObjName(catRec,dstName);
   ChangeName(dstDisk,dstName);
   ValidIcon(Pointer(dstVol^^.devHdl^^.objHdl),FALSE);
   END;

IF RestoreDesktop(srcVol,FALSE{newDisk},srcDisk) THEN;
IF srcVol <> NIL THEN
   BEGIN
   diskPathname := CONCAT('-',srcVol^^.devHdl^^.nameHdl^^);
   Lookup (err,diskPathname,diskInfo);
   srcDisk^^.backedUp := diskInfo.dtvb;
   END;
END;



{$S flrAll }
PROCEDURE BlinkContents{* obj: ObjectHandle; whichState: ObjectState *};
{ blinks contents matching "whichState".  No net change to screen }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('BlinkContents',WriteName(obj));
InvertContents(obj,whichState);
Pause(20);   { 0.2 sec }
InvertContents(obj,whichState);
Pause(40);
END;



{$S flrAll }
PROCEDURE BlinkObject{* obj: ObjectHandle *};
{ blink an icon, used when an icon is moved over another and accepted }
VAR i: INTEGER;
    blinkTime: LongInt;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('BlinkObject',WriteName(obj));
FOR i := 1 to 6 DO
   BEGIN
   InvertObject(obj);
   blinkTime := Time + 2;  { 1/50 second }
   REPEAT UNTIL Time > blinkTime;
   END;
END;



{$S flrCopy }
PROCEDURE CalcBBox(font: Tfam; ch: Char; VAR bbox: Rect);

{ calculate the bounding box of each icon by looking at its mask }

LABEL 1,2,3,4;

VAR h,v:        INTEGER;
    tempBits:   BitMap;
    savePort:   GrafPtr;
    tempPort:   GrafPort;
    tempBuf:    ARRAY[0..95] OF INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF ch = CHR(noIcon) THEN
   BEGIN
   SetRect(bbox,0,0,0,0);
   EXIT(CalcBBox);
   END;

GetPort(savePort);
OpenPort(@tempPort);

{ set up an offscreen bitmap }
tempBits.baseAddr := @tempBuf;
tempBits.rowBytes := 6;
SetRect(tempBits.bounds,0,0,iconWidth,iconHt);
SetPortBits(tempBits);

TextFont(font);

EraseRect(tempBits.bounds);
MoveTo(0,0);
DrawChar(ch);   { draw the character into the bitmap }

bbox.left   := 0;
bbox.right  := iconWidth;
bbox.top    := 0;
bbox.bottom := iconHt;

FOR h := 0 TO iconWidth-1 DO  { scan for left }
    FOR v := 0 TO iconHt-1 DO IF BitTst(@tempBuf, v*iconWidth + h) THEN
       BEGIN
       bbox.left := h;
       GOTO 1;
       END;
1:

FOR v := 0 TO iconHt-1 DO  { scan for top }
    FOR h := 0 TO iconWidth-1 DO IF BitTst(@tempBuf, v*iconWidth + h) THEN
       BEGIN
       bbox.top := v;
       GOTO 2;
       END;
2:

FOR h := iconWidth-1 DOWNTO 0 DO  { scan for right }
    FOR v := 0 TO iconHt-1 DO IF BitTst(@tempBuf, v*iconWidth + h) THEN
       BEGIN
       bbox.right := h + 1;
       GOTO 3;
       END;
3:

FOR v := iconHt-1 DOWNTO 0 DO  { scan for bottom }
    FOR h := 0 TO iconWidth-1 DO IF BitTst(@tempBuf, v*iconWidth + h) THEN
       BEGIN
       bbox.bottom := v + 1;
       GOTO 4;
       END;
4:

IF trcFiler THEN WITH bbox DO WRITELN('bbox = ',left,top,right,bottom);

{ deallocate regions for temporary port }
DisposeRgn(thePort^.clipRgn);
DisposeRgn(thePort^.visRgn);

SetPort(savePort);
END;



{$S  }
PROCEDURE CantInit(err: INTEGER; lowlvlerr: INTEGER);
{ called if failure during startup }

VAR clkTime:   Time_Rec;
    interval:  Timestmp_Interval;
    response:  FMaxStr;
    tempStr:   NumberStr;
    errStr:    STRING[5];
    lowLvlStr: STRING[5];

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF lowlvlerr <= 0 THEN EXIT (CantInit);

IF dbgFiler THEN WRITELN('Initialization failed');
IntToStr (ABS(err), tempStr);            { Build alert msg params           }
errStr := tempStr;
IF lowlvlerr <> nullErr
THEN BEGIN
  IntToStr (lowlvlerr, tempStr);
  lowlvlstr := CONCAT('/',tempStr);
  END
ELSE lowlvlstr := '';
MoveConsole(err, mainScreen);
SetScreenKeybd(PriScrn);
WRITELN('HALT ',errStr,lowlvlStr);
WITH interval DO BEGIN
  sec := 10;
  msec := 0;
  END;
Delay_Time (err, interval, clkTime);    { Give the user a chance to read the message }

HALT;
END;



{$S flrAll }
PROCEDURE ChangeContents{* obj: ObjectHandle;
                           oldState,newState: ObjectState;
                           dh,dv: INTEGER;
                           redraw: BOOLEAN *};
{ change all objects in oldState to newState, }
{ move them dh,dv, and re-draw back to front if flag true }
VAR listHead,son: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ChangeContents',WriteName(obj));
listHead := obj^^.contents;
son:=listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state=oldState THEN ChangeObject(son,newState,dh,dv,redraw);
   son:=son^^.prev;
   END;
END;


{$S flrDm1 }
PROCEDURE ChangeName{* obj: ObjectHandle; VAR newName: FmaxStr *};

{ Used to change the title of an icon not currently being edited }
VAR width,oldNameWidth,halfDiff: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ChangeName',WriteName(obj),' to "',newName,'"');
SetStrg(obj^^.nameHdl,newName);
obj^^.dirty := TRUE;
obj^^.updateLabel := TRUE;
IF InSpatialView(obj) THEN
   BEGIN
   width := NameWidth(obj);
   WITH obj^^.nameRect DO
      BEGIN
      oldNameWidth := right - left;
      IF width > oldNameWidth THEN   { new name is larger so reset the name rect }
         BEGIN
         IF trcFiler THEN WRITELN('   new name is larger, reset nameRect');
         halfDiff := (width - oldNameWidth + 1) DIV 2;
         left := left - halfDiff;
         right := right + halfDiff;
         END;
      END;
   ValidName(obj,FALSE);
   UpdateObject(obj^^.container,FALSE);
   END
ELSE
   DrawName(obj);
END;



{$S flrDm1 }
PROCEDURE ChangeObject{* obj: ObjectHandle;
                         newState: ObjectState;
                         dh,dv: INTEGER;
                         redraw: BOOLEAN *};
{ changes state to "newState" adjusts location by dh,dv and redraws if flag true }
VAR isSpatial: BOOLEAN;
    fldPt: Point;
    savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ChangeObject',WriteName(obj));

isSpatial := InSpatialView(obj);
obj^^ .state := newState;

IF isSpatial AND ((dh <> 0) OR (dv <> 0)) THEN
   BEGIN
   WITH obj^^ DO
      BEGIN
      loc.h := loc.h + dh;
      loc.v := loc.v + dv;
      dirty := TRUE;
      OffsetRect(nameRect,dh,dv);
      END;
   IF obj = editObject THEN
      BEGIN
      GetPort(savePort);
      SetPort(obj^^.container^^.objWindow);
      CaretErased(hCurFld,hCurFstate);      { tell fld ed that caret is gone }
      GetNameLoc(obj,fldPt);
      MoveField(hCurFld,hCurFstate,fldPt);  { tell field editor about move }
      SetPort(savePort);
      END;
   END;

IF redraw THEN
   BEGIN
   DrawTheIcon(obj);
   IF isSpatial AND (newState <> limbo) THEN  { avoids name flash before move }
      DrawName(obj);
   END;
END;



{$S flrMisc }
FUNCTION ChangeParentID{* obj: ObjectHandle; newParentID: IDType): BOOLEAN *};
{ updates catalog to reflect new parent, returns true if successful }
VAR newCatRID: TcatRID;
    err: INTEGER;
    diskgone:   BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ChangeParentID',WriteName(obj));

ChangeParentId := TRUE;
IF newParentID = obj^^.catRID.fatherID THEN EXIT(ChangeParentID);

WITH obj^^ DO
   XferObject(err,catRID,newParentID,volHdl,volHdl,TRUE,TRUE,FALSE,FALSE,0,newCatRID,diskgone);

IF ErrorFound(askError,1000,err,obj^^.volHdl^^.devHdl) THEN
   BEGIN
   ChangeParentId := FALSE;
   EXIT(ChangeParentID);
   END;

obj^^.catRID.fatherID := newParentID;
END;



{$S flrMisc }
PROCEDURE ChangeView{* obj: ObjectHandle; newView: ViewType *};
{ changes viewing mode and redraws }
VAR savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ChangeView',WriteName(obj));
IF NOT IsContainer(obj) THEN EXIT(ChangeView);

EndEdit;   {*** should preserve editing across view changes ***}

IF newView <> spatialView THEN SortContents(obj,newView);

WITH obj^^ DO
   BEGIN
   dirty := TRUE;
   viewMode := newView;
   hThumbPos := 0;
   vThumbPos := 0;
   scrollDh  := 0;
   scrollDv  := 0;
   END;

{ reset scroll position to topleft }
GetPort(savePort);
SetPort(obj^^.objWindow);
SetOrigin(0,0);
SetPort(savePort);

{ adjust scrollbars for new origin }
IF obj = activeObject THEN ShowScroll(obj);

DrawContents(obj);
END;



{$S flrDm }
PROCEDURE CheckContents{* obj: ObjectHandle *};
{ checks all objects in a container for valid field values }
VAR son,listHead: ObjectHandle;
    newLoc: Point;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CheckContents',WriteName(obj));
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   CheckObject(son);
   son := son^^.next;
   END;
END;



{$S flrDm }
PROCEDURE CheckLoc{* container: ObjectHandle; VAR loc: Point
                                              VAR changed: BOOLEAN *};
{ checks icon location for a reasonable value }
VAR tooBig: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
WITH loc DO
   BEGIN
   IF trcFiler THEN WRITELN('CheckLoc  (',h:1,',',v:1,') in',WriteName(container));
   tooBig := FALSE;
   IF container = deskObject THEN WITH container^^.objWindow^.portRect DO
      tooBig := (h > right) OR (v > bottom)
   ELSE
      tooBig := (h = MAXINT) OR (v = MAXINT);  { flag to choose a position }

   IF tooBig OR (h < -icon2Width) OR (v < -icon2Ht) THEN
      BEGIN
      ChoosePos(container,loc);  { choose a good position }
      changed := TRUE;
      END
   ELSE
      Changed := FALSE;
   END;
END;


{$S flrDm1 }
FUNCTION CheckPasswords{volHdl: TentryHdl; catRID: TcatRID; excludeUnfiled: BOOLEAN;
                        VAR foundOne: BOOLEAN) : BOOLEAN};
{ recursively checks the password of this icon and all its sons }

VAR err:         INTEGER;
    foundAnother:BOOLEAN;
    pCatRec:     PtrCatRec;
    sonCatRID:   TCatRID;
    thePassword: E_Name;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcAttributes THEN WRITELN('CheckPasswords: selfID is ',catRID.uniqueID:1);

CheckPasswords := FALSE;
foundOne := FALSE;
IF NOT GetPassword(volHdl, catRID, thePassword) THEN
   BEGIN
   IF trcAttributes THEN WRITELN('   exit CheckPasswords: could not get password');
   EXIT(CheckPasswords);
   END;

foundOne := LENGTH(thePassword) > 1;
PosCatRec(err, volHdl, catRID, pCatRec);             { check the passwords for all of the sons }
IF (pCatRec^.objKind IN containerSet) THEN
   BEGIN
   IF trcAttributes THEN WRITELN('   ',catRID.uniqueID:1,' is a container');
   posApprox.fatherID := catRID.uniqueID;            { find first son in container }
   PosCatRec(err, volHdl, posApprox, pCatRec);
   IF trcAttributes THEN IF err > 0 THEN WRITELN('   no sons found');
   sonCatRID.fatherID := catRID.uniqueID;
   WHILE (err <= 0) AND (pCatRec^.parentID = sonCatRID.fatherID) DO
      BEGIN                                          { check each son's password }
      IF (excludeUnfiled AND OnDesktop(volHdl, pCatRec^.selfID)) THEN
         BEGIN
         IF trcAttributes THEN WRITELN('   skipping unfiled object');
         END
      ELSE
         BEGIN
         sonCatRID.uniqueID := pCatRec^.selfID;
         IF NOT CheckPasswords(volHdl, sonCatRID, excludeUnfiled, foundAnother) THEN
            BEGIN
            IF trcAttributes THEN WRITELN('   exit CheckPasswords: passwords not checked');
            foundOne := FALSE;
            EXIT(CheckPasswords);
            END;
         foundOne := foundOne OR foundAnother;
         PosCatRec(err, volHdl, sonCatRID, pCatRec); { reposition catalog scan to this son }
         END;
      IF err <= 0 THEN PosCatRec(err, volHdl, posNext, pCatRec);
      END;
   END;

IF (err <= 0) OR (err = endOfCat) THEN
   CheckPasswords := TRUE
ELSE
   IF ErrorFound(warnError, 1042, err, volHdl^^.devHdl) THEN foundOne := FALSE;

IF trcAttributes THEN WRITELN('   exit CheckPasswords: err = ',err:1);
END;


{$S flrDm }
PROCEDURE CheckObject{* obj: ObjectHandle *};
{ checks object an object for valid field values }
VAR changedLoc: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CheckObject',WriteName(obj));

CheckLoc(obj^^.container,obj^^.loc,changedLoc);
IF changedLoc THEN obj^^.dirty := TRUE;
END;



{$S flrMisc }
FUNCTION ChooseHome{* obj: ObjectHandle; VAR newHomeLoc: Point): BOOLEAN *};

{ Used to determine a spatial home location for an object created on the desktop }

VAR homeObj,placeObj: ObjectHandle;
    name: FmaxStr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ChooseHome',WriteName(obj));
ChooseHome := FALSE;
homeObj := GetHomeObj(obj);

IF homeObj^^.isOpen THEN     { home container is open, choose empty spot }
   BEGIN
   IF trcFiler THEN WRITELN('   home container is open, choose empty spot');

   ChoosePos(homeObj,newHomeLoc);

      { create a placeholder object in the container }
   GetStrg(obj^^.nameHdl,name);
   WITH obj^^ DO
      placeObj :=
         MakeObject(homeObj,name,kind,toolNumber,newHomeLoc,windowRect,
                    placeHolder,viewMode,volHdl,catRID,created,modified,size,
                    split,passworded);

   IF placeObj = NIL THEN EXIT(ChooseHome);

   placeObj^^.dirty := TRUE;

   IF homeObj^^.viewMode = spatialView THEN
      DrawObject(placeObj)
   ELSE
      BEGIN
      SortContents(homeObj,homeObj^^.viewMode);
      DrawContents(homeObj);
      END;
   END
ELSE       { Home container not open.  Flag to choose spot when container opened }
   SetPt(newHomeLoc,MAXINT,MAXINT);

SetHomePt(obj,newHomeLoc);   { update catalog }
ChooseHome := TRUE;
END;



{$S flrMisc }
PROCEDURE ChoosePos{* container: ObjectHandle; VAR pos: Point *};

{ Find the first free position in container.  If the container is closed then }
{ sets the location to MAXINT as a flag to compute the position when the container
{ is opened.   Chooses a location near the top for containers.  Chooses a location
{ along the right and bottom edges for the desktop. }

VAR listHead: ObjectHandle;
    pt: Point;
    gridSpot,maxGridSpots: INTEGER;
    foundPos: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ChoosePos in',WriteName(container));
IF NOT container^^.isOpen THEN
   BEGIN
   pos.h := MAXINT;   { flag to choose pt next time container is opened }
   pos.v := MAXINT;
   EXIT(ChoosePos);
   END;

listHead := container^^.contents;

gridSpot := 0;
foundPos := FALSE;
maxGridSpots := nDeskCols*nDeskRows;

REPEAT
   GridToPt(container,gridSpot,pt);
   IF NearList(listHead,pt) = nilObject THEN
      foundPos := TRUE
   ELSE
      BEGIN
      gridSpot := gridSpot + 1;
      IF container = deskObject THEN
         IF gridSpot >= maxGridSpots THEN foundPos := TRUE;
      END
UNTIL foundPos;

pos := pt;
IF trcFiler THEN WRITELN('   empty spot = ',pt.h,pt.v);
END;



{$S flrMisc }
FUNCTION CleanupDisk{* diskObj: ObjectHandle; recordDesktop: BOOLEAN): BOOLEAN *};

{ saves desktop state and puts back all unfiled objects.  Returns FALSE if any
  documents refuse to be put back or if user pushes abort }

VAR listHead,obj,nextObj,homeObj: ObjectHandle;
    refnum,err: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CleanupDisk',WriteName(diskObj));
CleanupDisk := FALSE;

{ make sure that screen is updated before animation }
UpdateAll;

{ record the current desktop state }
IF recordDesktop THEN
   SaveDesktop(diskObj)
ELSE
   BEGIN
   refnum := diskObj^^.volHdl^^.saveRefnum;
   IF refnum <> noFile THEN
      BEGIN
      Close_Object(err,refnum);
      diskObj^^.volHdl^^.saveRefnum := noFile;
      END;
   END;

{ put back all on desktop from this disk }
listHead := deskObject^^.contents;
obj := listHead^^.next;
WHILE obj <> listHead DO
   BEGIN
   nextObj := obj^^.next;
   IF UserAbort THEN EXIT(CleanUpDisk);  { give user a bailout }
   IF (obj <> diskObj) AND (obj^^.volHdl = diskObj^^.volHdl) THEN
      IF NOT PutBackObject(obj,TRUE,TRUE,FALSE,homeObj) THEN EXIT(CleanUpDisk);
   obj := nextObj;
   END;

{ put back all opened in place from this disk }
IF NOT PutBackObject(diskObj,TRUE,TRUE,FALSE,homeObj) THEN EXIT(CleanUpDisk);

{ remove any icons in trash for this vol }
IF EmptyTrashCan(diskObj^^.volHdl,FALSE,FALSE) THEN;

  { take care of any update now, looks better }
UpdateAll;

CleanUpDisk := TRUE;
END;



{$S flrDm1 }
FUNCTION ClickedNewWindow: BOOLEAN;
{ Returns TRUE if the user has clicked ahead on another window, i.e., a new window
  is to become active.  Occasionally the Desk wants to activate a window.  If the
  user has clicked ahead then the desk may want to skip doing its activate }
VAR evHandle: EventHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ClickedNewWindow');

evHandle := FirstEvent;
WHILE evHandle <> NIL DO
   BEGIN
   IF evHandle^^.what = folderDeactivate THEN
      BEGIN
      ClickedNewWindow := TRUE;
      EXIT(ClickedNewWindow);
      END;
   evHandle := NextEvent(evHandle);
   END;

ClickedNewWindow := FALSE;
END;



{$S flrDm1 }
PROCEDURE ClimbTree{* whichVol: TentryHdl; recID: TcatRID;
                      VAR fatherRecID: TcatRID; VAR fatherObj: ObjectHandle *};
{ returns recID of father and handle to object if visible }
VAR pCatRec: PtrCatRec;
    err: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ClimbTree');
{ check if father is visible }
fatherObj := SearchContents(deskObject,whichVol,recID.fatherID,TRUE,TRUE);
IF fatherObj <> nilObject THEN
   fatherRecID := fatherObj^^.catRID
ELSE
   BEGIN  { father not visible.  fetch the catalog entry }
   fatherRecID.fatherID := idNil;
   fatherRecID.uniqueID := recID.fatherID;
   PosCatRec(err,whichVol,fatherRecID,pCatRec);
   IF ErrorFound(askError,1002,err,whichVol^^.devHdl) THEN
      fatherRecId.fatherId := idDisk              { choose disk if an error }
   ELSE
      fatherRecID.fatherID := pCatRec^.parentID;  { set father's father }
   END;
END;



{$S flrAll }
PROCEDURE ClipContent{* obj: ObjectHandle *};
{ sets clipping to the content area of a window, excludes scroll & status }
VAR tempRect: Rect;
    savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ClipContent',WriteName(obj));
IF obj^^.objWindow = NIL THEN EXIT(ClipContent);
GetPort(savePort);
SetPort(obj^^.objWindow);
GetContentRect(obj,tempRect);
ClipRect(tempRect);
SetPort(savePort);
END;



{$S flrAll }
PROCEDURE ClipName{* obj: ObjectHandle *};
{ Sets clipping to keep name in bounds }
VAR r: Rect;
    savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('ClipName',WriteName(obj));

GetPort(savePort);
SetPort(obj^^.container^^.objWindow);
GetContentRect(obj^^.container,r);
IF InListView(obj) THEN
   IF SectRect(r,obj^^.nameRect,r) THEN;
ClipRect(r);
SetPort(savePort);
END;



{$S flrMisc }
FUNCTION CloseContents{* obj: ObjectHandle; putBack,suspendDocs: BOOLEAN): BOOLEAN *};

{ closes all objects contained in obj.  "suspendDocs" tells what kind of  }
{ document shutdown to do (suspend or normal) if documents are encountered }
{ which were opened directly from their filing home.  Returns FALSE and bails }
{ out if any document refuses to shutdown or user pushes abort }

VAR son,nextSon,listHead : ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CloseContents',WriteName(obj));
CloseContents := FALSE;
listHead := obj^^.contents;
son := listHead^^.next;

WHILE son <> listHead DO
   BEGIN
   IF UserAbort THEN EXIT(CloseContents);
   nextSon := son^^.next;
   IF NOT CloseObject(son,TRUE {sons also},putback,suspendDocs) THEN
      EXIT(CloseContents);
   son := nextSon;
   END;

CloseContents := TRUE;
END;



{$S flrDskOut }
PROCEDURE CloseFont(toolNode: HdlToolNode);
{ closes the font for an OEM tool entry and resets the fields }
VAR lfntId: TlfntId;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CloseFont');
IF toolNode = NIL THEN EXIT(CloseFont);

IF toolNode^^.font <> noFont THEN
   BEGIN
   WITH lfntId DO
      BEGIN
      fam := toolNode^^.font;
      setEface := [];
      dev := devScreen;
      END;
   FMDelFont(lfntId);
   END;

WITH toolNode^^ DO
   BEGIN
   font := noFont;
   whichVol := NIL;
   tryToOpen := TRUE;
   bbox := iconBoxes[toolKind];
   END;
END;



{$S flrDm1 }
FUNCTION CloseObject{* obj: ObjectHandle; sonsAlso: BOOLEAN; putBack: BOOLEAN;
                                           suspendDoc: BOOLEAN): BOOLEAN *};

{  Zooms the window down to a hilited icon.  If the object is a container then }
{  its content object nodes are freed and the window destroyed.  If the object }
{  is a document then it will be shut down if it was opened directly from its }
{  filing home (or if putBack is TRUE), otherwise its window is hidden.  }
{  CloseObject returns TRUE except in the case of a document which refuses to }
{  shut down (inconsistent, not enough disk space, etc.) }

VAR savePort: GrafPtr;
    newState: ObjectState;
    splitflag,joinflag: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CloseObject',WriteName(obj));
splitflag := FALSE;
joinflag := FALSE;

CloseObject := FALSE;
IF (obj = deskObject) OR (obj = NIL) THEN EXIT(CloseObject);

IF NOT obj^^.isOpen THEN
   BEGIN
   IF putBack AND (LiveObject(obj) OR IsOrphan(obj)) THEN    { shut down doc }
      CloseObject := StopDoc(obj,suspendDoc,FALSE)
   ELSE
      CloseObject := TRUE;
   EXIT(CloseObject);
   END;

{ de-select all others in same container }
IF NOT copyMode THEN ChangeContents(obj^^.container,hilited,normal,0,0,TRUE);
EndEdit;

{ remember window location }
WITH obj^^ DO
   BEGIN
   windowRect := objWindow^.portRect;
   GetPort(savePort);
   SetPort(objWindow);
   LocalToGlobal(windowRect.topLeft);
   LocalToGlobal(windowRect.botRight);
   SetPort(savePort);
   END;

{ Unfile the object if desired }
IF (obj^^.container <> deskObject) AND (NOT putBack) THEN
   IF NOT MoveObject(obj,openState,0,0,deskObject,TRUE {chooseLoc},FALSE,splitflag,joinflag) THEN
      EXIT(CloseObject);

{ Hide or destroy the window }

IF obj = scrapObject THEN
   RemoveWindow(obj,FALSE)       { just hide the window for the scrap }
ELSE IF obj^^.kind IN docToolSet THEN
   BEGIN
   IF putBack THEN
      BEGIN   { shut down the document.  Note document may refuse! }
      IF NOT StopDoc(obj,suspendDoc,FALSE) THEN EXIT(CloseObject);
      END
   ELSE
      RemoveWindow(obj,FALSE);   { just hide the window }
   END
ELSE
   BEGIN
   { Take care of objects opened from their container, close or move to desktop }
   IF sonsAlso THEN
      BEGIN
      IF NOT CloseContents(obj,putBack,suspendDoc) THEN EXIT(CloseObject);
      END
   ELSE   { Move any objects opened in place from this object to the desktop }
      IF NOT MoveContents(obj,openState,openState,0,0,deskObject,TRUE,FALSE,splitflag,joinflag){***Sally***}
      THEN EXIT(CloseObject);

   { dispose of contents object list }
   KillContents(obj,TRUE,FALSE);

   { remove the window }
   RemoveWindow(obj,TRUE);
   END;

{ recompute activeObject since activeFolder may have changed }
activeObject := ObjFromWindow(activeFolder);
IF activeObject = nilObject THEN activeObject := deskObject;
obj^^.isOpen := FALSE;

{ take care of any update for container }
UpdateObject(obj^^.container,FALSE);

{ Zoom down }
ZoomObject(obj,FALSE);

{ change object state to selected if only one being closed and no click ahead }
obj^^.state := normal;
IF sonsAlso OR ClickedNewWindow OR copyMode THEN
   DrawObject(obj)
ELSE
   BEGIN
   MakeObjActive(obj^^.container);
   SelectObject(obj,FALSE);
   END;


{ IF put back doc or tool then update it's list attributes }
IF (obj^^.kind IN docToolSet) AND putBack THEN
   UpdateAttributes(obj,FALSE);

{ Dispose of pictures for closed objects }
WITH obj^^ DO
   IF (objWindow <> NIL) AND (objWindow <> scrapFolder) THEN
       WmKillPicture(objWindow);

CloseObject := TRUE;
END;



{$S dmMain }
PROCEDURE CommandKey;

{ an Apple key was pressed. Do appropriate command if any }

VAR minTime     : LongInt;
    whichMenu   : INTEGER;
    whichItem   : INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CommandKey');

IF (InDialog) THEN
   BEGIN
   DiCommandKey;
   EXIT (CommandKey);
   END;

{$IFC flrDebug }
IF (curEvent.ascii = '1') THEN        { command - 1 => toggle debugging menu }
   BEGIN
   If specialUp THEN
      BEGIN
      DeleteMenu(specialMenu);
      DeleteMenu(stressMenu);
      END
   ELSE
      BEGIN
      InsertMenu(flrMenus[specialMenu],0);
      InsertMenu(flrMenus[stressMenu],0);
      END;
   DrawMenuBar;
   specialUp := NOT specialUp;
   EXIT(CommandKey);
   END;
{$ENDC }

AdjustMenus;                                  { set menu enable/disable states }
MenuKey(curEvent.ascii,whichMenu,whichItem);  { Map key to menu & item }

IF whichMenu = 0 THEN
   BEGIN
   StopAlert(flrAlert,116);  { this apple key is either not used or disabled ... }
   EXIT(CommandKey);
   END;

IF (whichMenu <> housekeepingMenu) OR (whichItem <> mEject) THEN
   IF InCopyMode THEN IF copyMode THEN EXIT(CommandKey);

HiLiteMenu(whichMenu);             { show the user which menu was selected }
minTime := Time + 5;               { 1/20th of a second }
MenuCommand(whichMenu,whichItem);  { process the menu command }
REPEAT UNTIL Time > minTime;       { ensure that menu remains black long enough }
HiliteMenu(0);                     { turn off hiliting }
END;



{$S flrCold }
PROCEDURE CompactContents(obj: ObjectHandle);
{ aligns all objects to grid position }
VAR listHead,son,minObj: ObjectHandle;
    dh,dv,numSons,spot,gridSpot,dist,minDist: INTEGER;
    gridPt: Point;
    onGrid: BOOLEAN;
    saveState: ObjectState;
    window: WindowPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CompactContents',WriteName(obj));

IF NOT IsContainer(obj) THEN EXIT(CompactContents);

numSons := CountContents(obj);
IF obj = deskObject THEN numSons := MIN(numSons,nDeskRows*nDeskCols);
listHead := obj^^.contents;
window := obj^^.objWindow;

{ step through the grid locations moving those not already there }
FOR spot := 0 TO numSons-1 DO
   IF EmptyGridSpot(obj,spot) THEN
      BEGIN
         { find closest obj not already on gridPt }
      son := listHead^^.next;
      minDist := MAXINT;
      minObj  := nilObject;
      GridToPt(obj,spot,gridPt);

      WHILE son <> listHead DO
         BEGIN
         onGrid := OnGridPt(son,gridSpot);
         IF NOT onGrid OR (gridSpot >= numSons) THEN
            BEGIN
            dist := ABS(son^^.loc.h-gridPt.h) + ABS(son^^.loc.v-gridPt.v);
            IF dist < minDist THEN
               BEGIN
               minDist := dist;
               minObj := son;
               END;
            END;
         son := son^^.next;
         END;

      IF minObj <> nilObject THEN
         BEGIN
         ValidObject(minObj,FALSE);           { cause erasure at current position }
         saveState := minObj^^.state;
         ChangeObject(minObj,limbo,0,0,TRUE);  { make gray ghost }
         dh := gridPt.h - minObj^^.loc.h;
         dv := gridPt.v - minObj^^.loc.v;
         WalkObject(minObj,0,0,dh,dv,window);   { animate to new position }
         ChangeObject(minObj,saveState,dh,dv,FALSE);
         ValidObject(minObj,FALSE);             { cause redraw at new postion }
         UpdateObject(obj,FALSE);               { redraw }
         END;
      END;

END;



{$S flrMisc }
FUNCTION CopyContents{* obj: ObjectHandle; whichState: ObjectState;
                         dh,dv: INTEGER; chooseAhome: BOOLEAN): BOOLEAN *};

{ Copies all "whichState" objects in same container.  Erases dim images and redraws
  hilited at dh,dv as each object is copied.  Returns FALSE if not all were copied
  or if user aborts. }

LABEL 1;
VAR son,listHead,diskObj,theCopy: ObjectHandle;
    failVol: TentryHdl;
    diskName: FmaxStr;
    numCopied: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CopyContents',WriteName(obj));
CopyContents := FALSE;

{ make sure there is enough space to make the copies }
IF NOT RoomForContents(obj,whichState,NIL,failVol) THEN
   BEGIN
   IF failVol = NIL { aborted } THEN EXIT(CopyContents);
   diskObj := ObjFromVol(failVol);
   GetObjTitle(diskObj,TRUE,diskName);
   ParamAlert(diskName,'','');
   StopAlert(flrAlert,102);  { Insufficient space ... }
   EXIT(CopyContents);
   END;

numCopied := 0;
listHead := obj^^.contents;
son := listHead^^.prev;

WHILE son <> listHead DO
   BEGIN
   IF UserAbort THEN GOTO 1;
   IF son^^.state = whichState THEN
      BEGIN
      IF NOT CopyObject(son,son^^.catRID.fatherID,chooseAhome) THEN GOTO 1;
      XorObject(son,dh,dv,xorWindow);
      ChangeObject(son,hilited,dh,dv,TRUE); { draw hilited after copy complete }
      numCopied := numCopied + 1;
      theCopy := son;
      END;
   son := son^^.prev;
   END;

copyMode := FALSE;  { all copied }
CopyContents := TRUE;

1:
IF numCopied = 0 THEN EXIT(CopyContents);
IF numCopied = 1 THEN SelectName(theCopy,FALSE);
UpdateAttrbutes(theCopy,TRUE {parentsOnly});
FlushVols;      { flush catalog on all volumes involved }
END;



{$S flrMisc }
FUNCTION CopyObject{* obj: ObjectHandle; newParent: IdType;
                      chooseAhome: BOOLEAN): BOOLEAN *};

{ Makes a blinking duplicate permanent on the same disk as the source.
  Returns FALSE if the copy fails }

VAR err: INTEGER;
    catRec: TcatRec;
    foundOne: BOOLEAN;
    newCatRID,dstCatRID: TcatRID;
    newHomeLoc: Point;
    diskObj: ObjectHandle;
    diskgone:  BOOLEAN;
    objName,diskName: FmaxStr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CopyObject',WriteName(obj));

{ make sure catalog is current for this object }
FlushObject(obj);
CopyObject := FALSE;
WITH obj^^ DO IF CheckPasswords (volHdl,catRID,TRUE,foundOne)
THEN ValidObj(obj,FALSE)  {*** FI 275 ***}
ELSE EXIT(CopyObject);

{ tell the user what's being duplicated }
GetCatRec(err,obj^^.volHdl,obj^^.catRID,catRec);
IF LiveObject(obj) OR (catRec.objSize > 0) OR (err > 0) THEN
   BEGIN
   diskObj := ObjFromVol(obj^^.volHdl);
   GetObjTitle(obj,TRUE,objName);
   GetObjTitle(diskObj,TRUE,diskName);
   ParamAlert(objName,diskName,'');
   WaitAlert(flrAlert,101);   { Duplicating ... }
   END;

{ make the copy on the same disk }
WITH obj^^ DO
   XferObject(err,catRID,newParent,
              volHdl,volHdl,TRUE,FALSE,FALSE,FALSE,0,newCatRID,diskgone);

{ Tell the user if couldn't make the copy }
IF err <> 0 THEN
   BEGIN
   dstCatRID.fatherID := idNil;
   dstCatRID.uniqueID := newParent;
   WITH obj^^ DO TellUser (volHdl,volHdl,catRID,dstCatRID,err,opMove);
   EXIT(CopyObject);
   END;

{ update the object record of the duplicate }
obj^^.catRID := newCatRID;

{ if created on desk then give it a home location }
IF chooseAhome THEN
   IF NOT ChooseHome(obj,newHomeLoc) THEN
      BEGIN    { back out }
      IF ShredObject(obj^^.volHdl,newCatRID,FALSE,TRUE {can't abort}) THEN;
      EXIT(CopyObject);
      END;

obj^^.toBeCopied := FALSE;
UpdateAttributes(obj,FALSE);

obj^^.volHdl^^.flush := TRUE;
obj^^.dirty := TRUE;
FlushObject(obj);       { update catalog entry  }

CopyObject := TRUE;
EndWaitAlert;
END;



{$S flrMisc }
FUNCTION CountContents{* obj: ObjectHandle): INTEGER *};
{ returns number of objects contained in "obj".   Note: "obj" must be open }
VAR listHead,son: ObjectHandle;
    numObjects: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('CountContents',WriteName(obj));
numObjects := 0;
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   numObjects := numObjects + 1;
   son := son^^.next;
   END;
CountContents := numObjects;
END;



{$S flrAll}
PROCEDURE DeactObject(newProc,newWind: BOOLEAN);
{ does deactivate stuff for the active object.   }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DeactObject',WriteName(activeObject));

KillDuplicates(activeObject);         { Abort possible copy mode }

IF newWind THEN   { a new window is to be made active }
   BEGIN
   IF editObject^^.container = activeObject THEN EndEdit;  { end editing }
   ChangeContents(activeObject,hilited,normal,0,0,TRUE);   { deselect all }
   HideScroll(activeObject);                               { erase scroll bars }
   END;

IF newProc THEN   { a new process will own the active window }
   BEGIN
   ShrinkHeap;                         { compact heap, shrink data segment }
   PhotoObject(deskObject,TRUE,TRUE);  { create W/M pictures for fast updating }
   IF MyWindow(scrapFolder) THEN
      FETerminate;                     { cause text to be put in scrap segment }
   END;

activeObject := nilObject;
END;



{$S flrCopy }
PROCEDURE DeleteObject(volHdl: TentryHdl; catRID:TcatRID);
{ called by low level routine (oops!) when disk files are about to be deleted.
  If deleting a tool then checks tool info list and closes font }
VAR err: INTEGER;
    pCatRec: PtrCatRec;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DeleteObject');
PosCatRec(err,volHdl,catRID,pCatRec);
IF err = 0 THEN
   IF (pCatRec^.objKind = toolKind) AND (pCatRec^.toolId > maxKnownTool) THEN
      CloseFont(FindTool(pCatRec^.toolId,FALSE));
END;



{$S flrDm }
PROCEDURE DeskMgr;

{     Most event fetching and processing goes through here.  The exception is    }
{     when we have sent an event to an application and are waiting for a reply.  }
{     In this case we wait for the event in the routine "SendFilerEvent" in the  }
{     "FDocCtrl" module.                                                         }

BEGIN
REPEAT  { Main Program Loop }

   { loop here processing requests and suspending until activated }

   WHILE NOT ImActive DO
      BEGIN
      GetEvent(curEvent);     { wait suspended until an event for me }
      ProcessTheEvent;        { handle the event }
      END;


   { loop here while one of my windows is the active window }

   WHILE ImActive DO
      BEGIN
      IF EventAvail THEN      { ask if any events for me (don't wait) }
         BEGIN
         GetEvent(curEvent);  { fetch the event }
         ProcessTheEvent;     { handle the event }
         END
      ELSE
         BEGIN
         IdleTasks;           { no events so draw any typed chars, blink caret, etc }
         LetOthersRun;        { give background processes a chance to run }
         END;
      END;

   UNTIL FALSE;

END;


{$S flrCopy }
PROCEDURE DestroyObject(volHdl: TentryHdl; uniqueID: IdType);
{ like KillObject, but searches for object first }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DestroyObject');
KillObject(SearchContents(deskObject,volHdl,uniqueID,TRUE,TRUE),FALSE,TRUE {erase});
END;


{$S flrCopy }
PROCEDURE DoAbortEvent;

{ Handles abort events.  If we are in "copy mode", i.e., blinking duplicates on
  screen, then abort it.  All other abortable operations are handled by polling the
  window manager function "Abort" which returns true if there is an abort event in
  the queue. }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF copyMode THEN
   BEGIN
   StopAlert(flrAlert,255);       { operation aborted at your request ...}
   KillDuplicates(activeObject);  { remove the blinking duplicates }
   END;
END;


{$S flrAll }
PROCEDURE DoActivateEvent;

{ Handles activate events.
  An activate event can be received if:
     1) An inactive window of mine is clicked on.
     2) The close icon of some window was double clicked.
     3) An application died.
     4) I sent myself an activate, because I need to be active to handle the event.
     5) An application has activated me through the "DoFilingCmd" call because a
        filing menu item was chosen.
}
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
TakeControl(curEvent,FALSE,FALSE);            { accept "activeness" }
activeObject := ObjFromWindow(curEvent.who);  { find the object record }
IF activeObject = nilObject THEN activeObject := deskObject;
PhotoObject(deskObject,FALSE,TRUE);           { kill all my pictures }
InstallMenus;                                 { insert the appropriate menus }
ShowScroll(activeObject);                     { put up the scroll bars }
HandleWhyActivated(curEvent);                 { take care of "special" activates }
END;



{$S dmMain }
PROCEDURE DoBtnDownEvent;

{ Handles mouse button down events.  First determines if this is a multiple click,
  then checks to see if the event is for one of the special system defined windows,
  otherwise must be for the active window. }

VAR dh,dv: INTEGER;     { how far has the mouse moved since last button down }
    whichSb: THsb;      { which scroll bar was hit }
    whichIcon: TIcon;   { which icon within the scrollbar was hit }
    curGlobalLoc: Point;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

{ Check for multiple click.  Criteria: down time is within interval set at last
  button up,  mouse has not moved much, and shift key was not and is not down }

curGlobalLoc := curEvent.where;    { compare pts globally in case of auto-scroll }
SetPort(curEvent.who);
LocalToGlobal(curGlobalLoc);

dh := ABS(curGlobalLoc.h-clickGlobalLoc.h);
dv := ABS(curGlobalLoc.v-clickGlobalLoc.v);

IF (curEvent.when < clickTime) AND (dh <= 9) AND (dv <= 6) AND (NOT shiftClick)
                                             AND (NOT curEvent.shiftKey) THEN
   clickCount := clickCount + 1
ELSE
   BEGIN
   clickCount := 1;
   shiftClick := curEvent.shiftKey; { was shift key down on first click }
   clickLoc := curEvent.where;      { record down loc to check against next down }
   clickGlobalLoc := curGlobalLoc;
   END;

{ do dialog box consistancy check }
IF (InDialog) AND (curEvent.who <> dialogFolder) THEN
   BEGIN
   DoDiFinished (TRUE{requeue the event});
   EXIT (DoBtnDownEvent);
   END;

   { Now check which window the event is for }

IF curEvent.who = menuFolder THEN             { In menu bar? }
   HitMenuBar

ELSE IF curEvent.who = dialogFolder THEN      { In dialog box? }
   BEGIN
   DoDiBtnDown;
   END

ELSE IF curEvent.who = alertFolder THEN       { In alert box? }
   BEGIN END
                                              { In grow icon? }
ELSE IF InGrowIcon(activeObject,curEvent.where) THEN
   HitGrowIcon(activeObject,curEvent.where)
                                              { In scroll bar? }
ELSE IF InScrollBar(activeObject,curEvent.where,whichSb,whichIcon) THEN
   HitScrollBar(activeObject,whichSb,whichIcon)

ELSE IF IsContainer(activeObject) THEN        { In a container? (disk,folder,..) }
   HitContainer(activeObject)

ELSE IF curEvent.who = scrapFolder THEN       { In content of the scrap? }
   HitScrap

ELSE                                          { assume an orphan window }
   BEGIN
   orphanObject := activeObject;  { call HitOrphan on this when I become active }
   FlushTypeAhead(TRUE);          { flush typeahead, see comment in MakeObjActive }
   MakeFldrActive(filerFolder,whyHitOrphan);  { send activate to self }
   END;
END;



{$S dmMain }
PROCEDURE DoBtnUpEvent;

{ Handles button up events.  This event is currently used only for measuring
  multiple clicks.  A multiple click is counted if the mouse button goes down
  within a short interval after it last went up.  The window manager global
  "clickDelay" contains the interval.  }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
clickTime := curEvent.when + clickDelay;    { save multiple click time }
IF (InDialog) THEN
   DoDiBtnUp;
END;



{$S flrCat }
PROCEDURE DoCatalogEvent;

{ Handles application requests for catalog access. }

VAR catRID: TcatRID;
    err: INTEGER;
    offset: INTEGER;
    paramHdl: hFilerExt;
    theName: Pathname;
    volHdl: TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
paramHdl := POINTER(ORD(curEvent.userData));
theName := paramHdl^^.thePrefix;
CASE paramHdl^^.theFlrOp OF
  fcNameToPrefix: PrefixFromName (err, offset, theName, theName);
  fcPrefixToName: BEGIN
                  PrefixInCat (err, offset, theName, volHdl, catRID);
                  IF err <= 0 THEN GetObjPathname (volHdl, catRID, theName);
                  END;
  OTHERWISE       paramHdl^^.theErr := fceBadEventType;
  END;

  { Return the results }
WITH paramHdl^^ DO BEGIN
  theErr := err;
  theDf := offset;
  theResult := theName;
  END;
WITH curEvent DO BEGIN
  who         := fromFolder;
  toProcess   := fromProcess;
  fromProcess := filerProcess;
  fromFolder  := filerFolder;
  END;
PushEvent (curEvent);

END;


{$S flrAll}
PROCEDURE DoDeactivateEvent;

{ Handles deactivate events.  Action taken depends on who is being activated }

VAR newActProcess,newActWindow: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF IgnoreDeactivate THEN EXIT(DoDeactivate);
newActProcess := NOT MyWindow(curEvent.fromFolder);      { different process? }
newActWindow  := (curEvent.fromFolder <> curEvent.who);  { different window? }
DeactObject(newActProcess,newActWindow);                 { deactivate current }
AdjustDesktopMenu;
GiveControl(curEvent);        { pass "activeness" on to new active window }
END;



{$S flrCat}
PROCEDURE DoDiskEvent;

{ Handles disk events (also power off & mouse unplugged).  "curEvent.keyCap"
  contains the modifier indicating what happened.  The Desk must be active to
  handle these events since it puts up an alert.  The window manager always
  activates the desk before sending "disk" events, but since the activate could
  have been flushed, a check is made to ensure that the Desk is active }

VAR devHdl: TentryHdl;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DoDiskEvent: ',curEvent.keyCap:1);

{ must be active before handling this event }
IF activeProcess <> filerProcess THEN
   BEGIN
   MakeObjActive(deskObject);          { request "activeness" }
   SendEvent(curEvent,filerProcess);   { re-queue the event for myself }
   EXIT(DoDiskEvent);
   END;

{ map the event to a device entry }
CASE curEvent.keyCap OF
  disk1InCode,
  disk1OutCode:   devHdl := uTwigHdl;

  disk2InCode,
  disk2OutCode,
  microInCode,
  microOutCode:   devHdl := lTwigHdl;

  micro1InCode,
  micro1OutCode,
  micro2InCode,
  micro2OutCode,
  micro3InCode,
  micro3OutCode:  EXIT(DoDiskEvent);
  END;

CASE curEvent.keyCap OF

   powerCode:                   { the power button was pushed }
      BEGIN
      appleOff := curEvent.appleKey;   { TRUE => return to selector shell }
      ShutDown;
      END;

   disk1InCode,disk2InCode,microInCode,
   micro1InCode,micro2InCode,micro3InCode:     { a diskette was inserted }
      BEGIN
      IF devHdl^^.volHdl = NIL THEN MountAvolume(devHdl^^.device);
      END;

   disk1OutCode,disk2OutCode,microOutCode,
   micro1OutCode,micro2OutCode,micro3OutCode:   { a diskette eject button was pushed }
      BEGIN
      IF devHdl^^.volHdl <> NIL THEN IF devHdl^^.volHdl^^.volState = sMounted THEN
         BEGIN
         ArgAlert(1,devHdl^^.userNmHdl^^);
         WaitAlert(flrAlert,131);   { putting things away ... }
         END;
      IF UnmountAvolume(devHdl^^.device,TRUE,FALSE,TRUE,0) THEN;
      EndWaitAlert;
      END;

   mouseCode:                    { the mouse was unplugged/plugged in }
      BEGIN
      IF ORD(curEvent.ascii) > 0 THEN   { unplugged event? }
         IF NOT KeyIsDown(7) THEN       { Is it unplugged now? }
            NoteAlert(flrAlert,127);    { mouse unplugged...}
      END;

   {$IFC flrDebug }
   OTHERWISE
      WRITELN('Unknown "disk" command = ',curEvent.keyCap:1);
   {$ENDC }

   END;
END;


{$S flrClose }
PROCEDURE DoFilerEvent;

{ Handles "Desk events".  These are events sent by an application via the
  "FilerComm" routine "TellFiler".  Some examples are: intialization failed,
  document put away  }

VAR putBack: BOOLEAN;
    fromWindow: WindowPtr;
    homeObj: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
fromWindow := curEvent.fromFolder;   { save this since routine changes curEvent }

UnsolicitedFilerEvent(putBack);

   { putback TRUE => user selected "Putback" from menu }

IF putBack THEN
   IF PutBackObject(ObjFromWindow(fromWindow),FALSE,FALSE,TRUE,homeObj) THEN;
END;


{$S dmMain }
PROCEDURE DoKeyDownEvent;

{ Handles key down events.  If we are in "copy mode", i.e., blinking duplicates
 on the screen, then tell the user to move the duplicates first.  }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

IF curEvent.appleKey AND (ORD(curEvent.ascii) <> ccBS) THEN
   CommandKey
ELSE
   BEGIN
   IF (NOT InDialog) THEN
      IF InCopyMode THEN IF copyMode THEN EXIT(DoKeyDownEvent);
   TextKey;
   END;
END;



{$S flrDm}
PROCEDURE DoMovedEvent;

{ Handles the window moved event.  Adjusts the window's bottom right to keep
  scrollbars on screen }

VAR savePort: GrafPtr;
    tempRect: Rect;
    changeSize: BOOLEAN;
    minH,minV,maxH,maxV: INTEGER;
    window: WindowPtr;
    obj: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
window := curEvent.who;
obj := ObjFromWindow(window);
IF obj = nilObject THEN EXIT(DoMovedEvent);

GetPort(savePort);
SetPort(window);
changeSize := FALSE;
tempRect := window^.portRect;

WITH tempRect DO
   BEGIN
   LocalToGlobal(botRight);
   IF right > screenWidth THEN
      BEGIN
      right := screenWidth;
      changeSize := TRUE;
      END;
   IF bottom > screenHt THEN
      BEGIN
      bottom := screenHt;
      changeSize := TRUE;
      END;
   IF changeSize THEN
      BEGIN
      GlobalToLocal(botRight);
      FolderSize(window,Max(dhSbox,right-left),Max(dvSbox,bottom-top),FALSE);
      ScrollLimits(obj,minH,minV,maxH,maxV);
      obj^^.hThumbPos := ThumbHpos(obj,minH,maxH);
      obj^^.vThumbPos := ThumbVpos(obj,minV,maxV);
      ShowScroll(obj);
      END;
   END;
SetPort(savePort);
END;


{$S flrDm }
PROCEDURE DoUpdateEvent;
{ Handles update events.  A portion of some window needs to be redrawn. }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
UpdateObject(ObjFromWindow(curEvent.who),FALSE);
END;



{$S flrAll }
PROCEDURE DragContents{* obj: ObjectHandle;
                         whichState: ObjectState;
                         whichKinds: KindSet;
                         tallyCount: INTEGER;
                         startPt: Point;
                         pointAt: ObjectHandle;
                         VAR targetContainer: ObjectHandle;
                         VAR targetIcon: ObjectHandle;
                         VAR targetMatch: BOOLEAN;
                         VAR dh,dv: INTEGER;
                         maxDh,maxDv,minDh,minDv: INTEGER *};

{ Drags the specified objects around, hiliting valid targets under it.
  Returns the container object (nilObject if not a valid container).
  Returns the target icon if dropped on one (nilObject if not over an icon). }

VAR oldPt,newPt: Point;
    oldTargetIcon: ObjectHandle;
    targetInverted: BOOLEAN;
    hitName: BOOLEAN;
    startRect,testRect: Rect;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DragContents',WriteName(obj));
dh := 0;
dv := 0;
oldTargetIcon := nilObject;
targetIcon := nilObject;
targetContainer := obj;
targetMatch := FALSE;
targetInverted :=FALSE;
oldPt :=startPt;

IF (tallyCount = 1) AND (obj^^.viewMode = spatialView) THEN
   BEGIN    { hit test against bounding box }
   GetIconRect(pointAt,startRect);
   OffsetRect(startRect,pointAt^^.loc.h,pointAt^^.loc.v);
   END
ELSE WITH startPt DO
   SetRect(startRect,h-3,v-2,h+3,v+2);

IF trcFiler THEN WITH testRect DO WRITELN('   rect: ',left,top,right,bottom);

XorContents(obj,whichState,0,0,deskPort);      { draw image in XOR }

{ drag the selection around, hilighting valid targets under it }
REPEAT
   GetMouse(newPt);
   IF (newPt.h <> oldPt.h) OR (newPt.v <> oldPt.v) THEN
      BEGIN
      XorContents(obj,whichState,dh,dv,deskPort);  { erase old xor image }
      dh := newPt.h - startPt.h;
      dv := newPt.v - startPt.v;

      testRect := startRect;
      OffsetRect(testRect,dh,dv);

      IF dh > maxDh THEN dh := maxDh;
      IF dv > maxDv THEN dv := maxDv;
      IF dh < minDh THEN dh := minDh;
      IF dv < minDv THEN dv := minDv;
      XorContents(obj,whichState,dh,dv,deskPort);  { draw new xor image }
      oldPt:=newPt;

      { over which container? }
      targetContainer := ObjFromWindow(WhichWindow(newPt));

      { over which icon? }
      targetIcon := WhichObject(targetContainer,testRect,TRUE{ignoreNames},hitName);

      IF targetIcon <> oldTargetIcon THEN
         BEGIN
         IF targetInverted THEN   { un-invert old target if its inverted }
            BEGIN
            InvertObject(oldTargetIcon);
            targetInverted := FALSE;
            END;


          IF targetIcon^^.state IN [nilState,limbo,openState,placeHolder] THEN
             targetMatch := FALSE
          ELSE
             targetMatch := Match(targetIcon,whichKinds,tallyCount);

          { If the object pointed at when dragging began is over its own
            placeholder then pretend the place holder doesn't exist }
          WITH targetIcon^^ DO
             IF state = placeHolder THEN
                IF (volHdl = pointAt^^.volHdl) AND
                   (catRID.uniqueID = pointAt^^.catRID.uniqueID) THEN
                   targetIcon := nilObject;

          IF targetMatch THEN
             BEGIN
             InvertObject(targetIcon);
             targetInverted := TRUE;
             END;

          oldTargetIcon:=targetIcon;
        END;
    END;

UNTIL NOT StillDown;

XorContents(obj,whichState,dh,dv,deskPort);  { erase final xor image }

{ un-invert target if it's inverted }
IF targetInverted THEN InvertObject(targetIcon);
END;



{$S flrAll }
PROCEDURE DragRect{* obj: ObjectHandle; startPt: Point; VAR dstRect: Rect *};
{ get a rectangle from the mouse by dragging out a flickering outline }
VAR saveMode: INTEGER;
    newPt,oldPt: Point;
    contentRect: Rect;
    dh,dv,minH,minV,maxH,maxV: INTEGER;
    savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DragRect');
GetPort(savePort);

ScrollLimits(obj,minH,minV,maxH,maxV);     { determine scroll limits }

dstRect.topLeft  := startPt;
dstRect.botRight := startPt;
oldPt := startPt;
SetPort(obj^^.objWindow);

WHILE StillDown DO
   BEGIN
   GetMouse(newPt);
   IF (newPt.h <> oldPt.h) OR (newPt.v <> oldPt.v) THEN
      BEGIN
      FrameRect(dstRect);   { hide old, does nothing first time thru }

         { scroll if out of content area }
      GetContentRect(obj,contentRect);
      IF NOT PtInRect(newPt,contentRect) THEN
         BEGIN
         dh := 0; dv := 0;
         IF newPt.h < contentRect.left THEN
            dh := hScrollInc
         ELSE IF newPt.h > contentRect.right THEN
            dh := -hScrollInc;
         IF newPt.v < contentRect.top THEN
            dv := lineHt
         ELSE IF newPt.v > contentRect.bottom THEN
            dv := -lineHt;
         PenNormal;
         ScrollContents(obj,dh,dv,minH,minV,maxH,maxV,TRUE);
         END;

      ClipContent(obj);
      PenPat(gray);
      PenMode(notPatXor);
      Pt2Rect(startPt,newPt,dstRect);
      FrameRect(dstRect);   { draw new }
      oldPt := newPt;
      END;
   END;

FrameRect(dstRect);   { hide final image }
PenNormal;
SetPort(savePort);
END;



{$S flrAll }
PROCEDURE DrawContents{* obj: ObjectHandle *};
{ draw the contents of a container object in its display mode }
VAR savePort: GrafPtr;
    window: WindowPtr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawContents',WriteName(obj));
IF (NOT obj^^.isOpen) OR (NOT IsContainer(obj)) THEN EXIT(DrawContents);

GetPort(savePort);
window := obj^^.objWindow;

{ Erase the background }
SetPort(window);
ClipScrollBars(window,TRUE);
IF obj = deskObject THEN
   FillRect(window^.portRect,gray)
ELSE
   EraseRect(window^.portRect);

{ Draw the objects in the container }
CASE obj^^.viewMode OF
   spatialView: DrawSpatial(obj);
   alphaView,
   chronView:   DrawList(obj);
   END;

{ Draw any xor images if necessary }
IF obj^^.objWindow = xorWindow THEN
   BEGIN
   XorContents(xorSrcObj,limbo,xorDh,xorDv,xorWindow);
   XorObject(xorObj,xorDh,xorDv,xorWindow);   { In case of split/join }
   END;

SetPort(savePort);
END;



{$S flrAll }
PROCEDURE DrawInsides{* obj: ObjectHandle; wantScroll: BOOLEAN *};
{ call appropriate drawing routine based on which object }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawInsides',WriteName(obj));
IF obj = nilObject THEN EXIT(DrawInsides);

IF wantScroll THEN
   ShowScroll(obj)
ELSE
   HideScroll(obj);

IF obj = scrapObject THEN
   ShowScrap
ELSE IF obj^^.kind IN docToolSet THEN
   DummyDisplay(obj^^.objWindow)
ELSE
   DrawContents(obj);
END;



{$S flrDraw }
PROCEDURE DrawList{* obj: ObjectHandle *};
{ draws contents in list mode }
VAR son,listHead: ObjectHandle;
    savePort: GrafPtr;
    fldRect: Rect;
    strg : FMaxStr;
    objCount: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawList',WriteName(obj));
GetPort(savePort);
SetPort(obj^^.objWindow);

{ create bounding rectangle for column titles }
WITH fldRect DO
   BEGIN
   left := nameStart;
   top := thePort^.portRect.top;
   right := thePort^.portRect.right;
   bottom := top + lineHt;
   END;

{ draw column titles }
IF Visible(fldRect) THEN
   BEGIN
   ClipScrollBars(obj^^.objWindow,TRUE);

   GetString(700,@strg);   { name column title }
   ShowFld(@strg,fldRect,left,sysText,[underline],FALSE);

   fldRect.right := sizeEnd;
   GetString(701,@strg);   { size column title }
   ShowFld(@strg,fldRect,right,sysText,[underline],FALSE);

   fldRect.right := modEnd;
   fldRect.left := fldRect.right - (dateWidth + timeWidth);
   GetString(702,@strg);   { modified column title }
   ShowFld(@strg,fldRect,center,sysText,[underline],FALSE);

   fldRect.right := creatEnd;
   fldRect.left := fldRect.right - (dateWidth + timeWidth);
   GetString(703,@strg);   { created column title }
   ShowFld(@strg,fldRect,center,sysText,[underline],FALSE);
   END;

   { draw the table }

ClipContent(obj);

objCount := 0;
listHead := obj^^.contents;
son := listHead^^.prev;

WHILE son <> listHead DO
   BEGIN
   IF son^^.visible THEN
      BEGIN
      objCount := objCount + 1;
      son^^.listSeqNum := objCount;
      DrawRow(son,FALSE);
      END;
   son := son^^.prev;
   END;

SetPort(savePort);
END;



{$S flrAll }
PROCEDURE DrawName{* obj: ObjectHandle *};
{ draw an object's name, special case name being edited }
VAR fldPt: Point;
    someChars: BOOLEAN;
    newNameRect: Rect;
    name: FmaxStr;
    savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawName',WriteName(obj));

GetPort(savePort);
SetPort(obj^^.container^^.objWindow);
ClipName(obj);

IF InSpatialView(obj) THEN
   BEGIN
   GetNameLoc(obj,fldPt);

   IF obj = editObject THEN
      BEGIN
      MoveField(hCurFld,hCurFstate,fldPt);   { compute new bounding box }
      newNameRect := hCurFld^^.coords;

      { if name is smaller than before then invalidate it to update uncovered area }
      IF (newNameRect.right - newNameRect.left) <
         (obj^^.nameRect.right - obj^^.nameRect.left) THEN
         BEGIN
         IF trcFiler THEN WRITELN('   name is smaller - invalidate it');
         InvalRect(obj^^.nameRect);            { add name rect to update region }
         CaretErased(hCurFld,hCurFstate);      { tell fld ed that caret is gone }
         obj^^.nameRect := newNameRect;        { set name rect so update will draw }
         UpdateObject(obj^^.container,FALSE);  { updates area and draws smaller name }
         END
      ELSE     { new name is same or larger, just draw it }
         BEGIN
         IF trcFiler THEN WRITELN('   name is same or bigger - draw it');
         someChars := (hCurFld^^.curLen > 0);
         DrawFldAt(hCurFld,hCurFState,fldPt,someChars {show select},someChars {erase});
         IF NOT someChars OR TextSelected THEN
            timeoutInterval := noTimeout
         ELSE
            StartBlink(timeoutInterval);   { Start caret blinking if appropriate }
         SetTimeout(timeoutInterval);
         obj^^.nameRect := newNameRect;
         END;
      END
   ELSE
      ShowFldAt(@obj^^.nameHdl^^,fldPt,center,iconNamFont,obj^^.nameRect);
   END
ELSE       { list view }
   BEGIN
   IF obj = editObject THEN
      BEGIN
      hCurFld^^.coords := obj^^.nameRect;
      someChars := (hCurFld^^.curLen > 0);
      DrawField(hCurFld,hCurFstate,someChars,TRUE {erase});
      IF NOT someChars OR TextSelected THEN
         timeoutInterval := noTimeout
      ELSE
         StartBlink(timeoutInterval);
      SetTimeout(timeoutInterval);
      END
   ELSE
      ShowFld(@obj^^.nameHdl^^,obj^^.nameRect,left,listFont,[],TRUE);
   END;

SetPort(savePort);
END;



{$S flrAll }
PROCEDURE DrawObject{* obj: ObjectHandle *};
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF NOT obj^^.visible THEN EXIT(DrawObject);

IF trcFiler THEN WRITELN('DrawObject',WriteName(obj));

IF InListView(obj) THEN
   DrawTinyObject(obj,FALSE)
ELSE
   BEGIN
   DrawTheIcon(obj);
   DrawName(obj);
   END;
END;



{$S flrDraw }
PROCEDURE DrawRow{* obj: ObjectHandle; erase: BOOLEAN *};
{ draws an object's entry in the list view  }
VAR
   r: Rect;
   savePort: GrafPtr;
   tinyLoc: Point;
   numStr: NumberStr;
   modTime,creatTime: LongInt;
   dateStr,timeStr: TTimeStr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawRow',Writename(obj));
GetPort(savePort);
SetPort(obj^^.container^^.objWindow);

WITH r DO
   BEGIN
   left := 0;
   top :=  obj^^.listSeqNum*lineHt;
   right := thePort^.portRect.right - dhSbox;
   bottom := top + lineHt;
   END;

SetRect(obj^^.nameRect,nameStart,r.top,nameEnd,r.bottom);

{ draw the symbol, name, and attributes }
IF Visible(r) THEN
   BEGIN
   ClipContent(obj^^.container);
   IF erase THEN EraseRect(r);

   SetPt(tinyLoc,tinyStart,r.bottom - botToBaseLn - 13);
   DrawSymbol(obj,tinyLoc,FALSE);

   DrawName(obj);

   ClipContent(obj^^.container);
   IntToStr(obj^^.size,numStr);
   r.right := sizeEnd;
   ShowFld(@numStr,r,right,sysText,[],FALSE);

   modTime := obj^^.modified;
   IF (modTime <> nullInt4) AND (modTime <> 0) THEN
      BEGIN
      TimeToStr(FALSE,modTime,dateStr,timeStr);
      r.right := modEnd - dateWidth;
      ShowFld(@timeStr,r,right,sysText,[],FALSE);
      r.right := modEnd;
      ShowFld(@dateStr,r,right,sysText,[],FALSE);
      END;

   creatTime := obj^^.created;
   IF (creatTime <> nullInt4) AND (creatTime <> 0) THEN
      BEGIN
      TimeToStr(FALSE,creatTime,dateStr,timeStr);
      r.right := creatEnd - dateWidth;
      ShowFld(@timeStr,r,right,sysText,[],FALSE);
      r.right := creatEnd;
      ShowFld(@dateStr,r,right,sysText,[],FALSE);
      END;
   END;

SetPort(savePort);
END;



{$S flrAll }
PROCEDURE DrawSpatial{* obj: ObjectHandle *};
{ draws contents in spatial view mode (back to front) and foreign disk msgs }

VAR son,listHead: ObjectHandle;
    theRect: Rect;
    alertNum: INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawSpatial',WriteName(obj));

IF ForeignDisk(obj) THEN      { foreign disk }
   BEGIN
   CASE obj^^.volHdl^^.volState OF
      sMacDisk:      alertNum := 449;
      sBadCatalog,
      sOldCatalog:   alertNum := 450;
      sNoCatalog:    alertNum := 447;
      sNoFileSystem: alertNum := 448;
      END;
   WITH obj^^.objWindow^.portRect DO
      BEGIN
      theRect.left   := left+15;
      theRect.right  := MAX (right-30, 350);
      theRect.top    := top+10;
      theRect.bottom := bottom;
      END;
   EndUpdate(obj^^.objWindow);
   EraseRect(obj^^.objWindow^.portRect);
   TextFont (sysText);                          { Non-editable system font  }
   TextFace ([]);
   DrawAlert (flrAlert, alertNum, theRect);
   EXIT(DrawSpatial);
   END;
                                                { normal container }
listHead := obj^^.contents;
son := listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   DrawObject(son);
   son := son^^.prev;
   END;
END;


{$S flrDraw }
PROCEDURE DrawSymbol{* obj: ObjectHandle; pt: Point; invert: BOOLEAN *};
{ draws small icon for list view & and window top left }
VAR savePort: GrafPtr;
    whichTool: TtoolId;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawSymbol',WriteName(obj),'"  at: ',pt.h,pt.v,
                         '  invert: ',invert,'  state: ',ORD(obj^^.state):1);
GetPort(savePort);
SetPort(obj^^.container^^.objWindow);
ClipContent(obj^^.container);

TextFont(wmFont);

IF NOT invert THEN
   BEGIN   { if not inverting then erase, current before drawing new }
   MoveTo(pt.h,pt.v);
   TextMode(srcBic);
   DrawChar(CHR(blackSymbol));     { erase the area }
   MoveTo(pt.h,pt.v);
   IF obj^^.state IN [openState,limbo,placeHolder] THEN
      BEGIN
      TextMode(srcOr);
      DrawChar(tinyMask[obj^^.kind]);    { OR on the mask }
      MoveTo(pt.h,pt.v);
      TextMode(srcBic);
      DrawChar(CHR(graySymbol));   { punch holes in it }
      END
   ELSE
      BEGIN
      TextMode(srcOr);
      DrawChar(tinyData[obj^^.kind]);     { draw the symbol }
      whichTool := obj^^.toolNumber;
      IF (whichTool > deskTool) and (whichTool <= maxKnownTool) THEN
         BEGIN
         IF tinyOverlay[whichTool] <> CHR(noIcon) THEN
            BEGIN
            MoveTo(pt.h,pt.v);
            DrawChar(tinyOverlay[whichTool]);     { draw the overlay }
            END;
         END;
      END;
   END;

IF (obj^^.state = hilited) OR invert THEN
   BEGIN
   MoveTo(pt.h,pt.v);
   TextMode(srcXor);
   DrawChar(tinyMask[obj^^.kind]);
   END;

TextMode(srcOr);
SetPort(savePort);
END;



{$S flrDraw }
PROCEDURE DrawTinyObject{* obj: ObjectHandle; invert: BOOLEAN *};
{ draws object in when container viewing mode is a list }
VAR pt: Point;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawTinyObject',WriteName(obj));
IF NOT obj^^.container^^.isOpen THEN EXIT(DrawTinyObject);

GetListPos(obj,TRUE,pt);
DrawSymbol(obj,pt,invert);
END;



{$S flrAll }
PROCEDURE DrawTheIcon{* obj: ObjectHandle *};
LABEL 1;
VAR objKind:   ObjectKind;
    savePort:  GrafPtr;
    h,v:       INTEGER;
    iconRect:  Rect;
    shapeFont,faceFont: TFam;
    mask,data,overlay: CHAR;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DrawTheIcon',WriteName(obj),' kind: ',obj^^.kind:1);

IF InListView(obj) THEN
   BEGIN
   DrawTinyObject(obj,FALSE);
   EXIT(DrawTheIcon);
   END;

GetPort(savePort);
SetPort(obj^^.container^^.objWindow);

GetIcons(obj,shapeFont,mask,data,faceFont,overlay,iconRect);
h := obj^^.loc.h;       { topLeft of where to draw icon char }
v := obj^^.loc.v;
OffsetRect(iconRect,h,v);

IF NOT Visible(iconRect) THEN GOTO 1;

ClipContent(obj^^.container);
objKind := obj^^.kind;

TextFont(shapeFont);
TextMode(srcBic);
MoveTo(h,v);
DrawChar(mask);         { use mask to punch a hole in the screen }
TextMode(srcOr);

CASE obj^^.state OF

   openState,limbo,placeHolder:  { draw ltGray or white }
      BEGIN
      IF thePort = filerFolder THEN GOTO 1;  { use white image }

      PenPat(gray);
      PenMode(patXor);
      PaintRect(iconRect);       { xor some gray onto the screen }
      MoveTo(h,v);
      DrawChar(mask);            { draw the icon mask }
      PaintRect(iconRect);       { gray the mask and restore the rest }
      PenNormal;
      GOTO 1;
      END;

   normal,hilited:
      BEGIN
      MoveTo(h,v);
      DrawChar(data);
      END;
END;

IF overlay <> CHR(noIcon) THEN   { OR on the overlay }
   BEGIN
   TextFont(faceFont);
   MoveTo(h,v);
   DrawChar(overlay);
   END;

IF obj^^.state = hilited THEN    { use mask to invert the icon }
   BEGIN
   TextFont(shapeFont);
   MoveTo(h,v);
   TextMode(srcXor);
   DrawChar(mask);
   END;

1:
SetPort(savePort);
END;



{$S flrDm1 }
PROCEDURE DupContents{* obj: ObjectHandle; whichState: ObjectState *};

{ duplicate all whichState objects in the list, bringing new copies to front }
{ Note: the copy of disk files represented by the objects is postponed until }
{ the duplicate(s) are moved to their destination }

LABEL 1, 2;
VAR son,prevSon,diskObj,listHead,lastObject,newObj: ObjectHandle;
    newLoc,newHomeLoc: Point;
    name: FmaxStr;
    devHdl: TentryHdl;
    dDevHdl: TentryHdl;
    sDevHdl: TentryHdl;
    err: INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('DupContents',WriteName(obj));

IF copyMode THEN EXIT(DupContents);  {*** FI302 ***}

EndEdit;

IF OneDiskSelected(diskObj) THEN
   BEGIN
     { if selected icons in open disk window then can't duplicate disk }
   IF diskObj = activeObject THEN
      BEGIN
      listHead := obj^^.contents;
      son := listHead^^.prev;
      WHILE son <> listHead DO
         BEGIN
         IF son^^.state = whichState THEN GOTO 2;
         son := son^^.prev;
         END;
      END;

   devHdl := diskObj^^.volHdl^^.devHdl;
   sDevHdl := NIL;
   dDevHdl := NIL;
   ArgAlert(1,devHdl^^.userNmHdl^^);
   CASE diskObj^^.kind OF
     priamKind: CASE AskAlert(flrAlert, 316) OF
                  1: EXIT(DupContents);
                  2: sDevHdl := devHdl;          { backup }
                  3: dDevHdl := devHdl;          { restore }
                  END;
     diskKind:  IF ForeignDisk(diskObj) THEN
                   BEGIN
                   StopAlert(flrAlert,339);      { can't duplicate }
                   EXIT(DupContents);
                   END
                ELSE IF AskAlert(flrAlert,335) = 2 THEN
                   sDevHdl := devHdl             { backup diskette }
                ELSE
                   GOTO 2;
     OTHERWISE  GOTO 2;                          { no special handling req'd }
     END;
  IF NOT CleanupDisk(diskObj, TRUE) THEN EXIT(DupContents);
  BackupVol(err,sDevHdl,dDevHdl);
  diskObj^^.volHdl := devHdl^^.volHdl;
  IF diskObj^^.volHdl = NIL THEN
     BEGIN
     KillObject(diskObj,TRUE,TRUE);
     devHdl^^.objHdl := ORD(NIL);
     END
  ELSE BEGIN
     devHdl^^.objHdl := ORD(diskObj);
     IF RestoreDesktop(diskObj^^.volHdl,FALSE,diskObj) THEN;
     END;
  EXIT(DupContents);
  END;

2:
listHead := obj^^.contents;

  { first draw all in normal state }
son := listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state = whichState THEN
      BEGIN
      son^^.state := normal;
      DrawTheIcon(son);
      son^^.state := whichState;
      END;
   son := son^^.prev;
   END;

  { Now make the duplicates in the hilited state }
lastObject := listHead^^.next;
son := listHead;
prevSon := son^^.prev;

WHILE son <> lastObject DO
   BEGIN
   son := prevSon;
   prevSon := son^^.prev;

   IF son^^.state = whichState THEN
      BEGIN
      copyMode := TRUE;
      GetStrg(son^^.nameHdl,name);

      WITH son^^ DO
         BEGIN           { determine location for the duplicate }
         newLoc.h := loc.h + icon2Width;
         IF newLoc.h + iconWidth > obj^^.objWindow^.portRect.right THEN
            newLoc.h := newLoc.h - iconWidth;

         newLoc.v := loc.v + icon2Ht;
         IF newLoc.v + iconHt > obj^^.objWindow^.portRect.bottom THEN
            newLoc.v := newLoc.v - iconHt;

         newObj := MakeObject(obj,name,kind,toolNumber,newLoc,windowRect,hilited,
                              viewMode,volHdl,catRID,nullInt4,nullInt4,size,
                              split,passworded);
         END;

      IF newObj = NIL THEN  { heap is full, back out }
         BEGIN
         KillDuplicates(obj);
         GOTO 1;
         END;

      son^^.state := normal;

      newObj^^.toBeCopied := TRUE;     { postpone actual copy }
      IF obj^^.viewMode = spatialView THEN DrawObject(newObj);
      END;
   END;

1:
IF obj^^.viewMode <> spatialView THEN
   BEGIN
   SortContents(obj,obj^^.viewMode);
   DrawContents(obj);  { redraw list }
   END;

AutoScroll(obj,hilited);   { make the selection visible };
END;



{$S flrAll }
PROCEDURE EditCommands{* menuItem: INTEGER *};
{ handles commands from the "Edit" menu }
VAR err,lastEditCmd: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('EditComands');

err := 0;
CASE menuItem OF
   mUndoLast:
      BEGIN
      lastEditCmd := uInfo.lastOp;
      IF (editObject = nilObject) OR (lastEditCmd = noOp) THEN
         StopAlert(flrAlert,103 )
      ELSE
         BEGIN
         UndoEdit(hCurFld,hCurFstate,err);
         IF (err = 0) AND ((lastEditCmd = cutOp) OR (lastEditCmd = copyOp)) THEN
            UndoInheritScrap(err);
         END;
      END;
   mCopy,mCut:
      CutCopyField(hCurFld,hCurFstate,(menuItem=mCut),TRUE,err);
   mCopyRef:
      ReferenceIcons(activeObject, hilited);
   mPaste:
      IF scrapRef IN currScrapSet THEN
         PasteIcons
      ELSE
         PasteField(hCurFld,hCurFstate,err,FALSE,fMaxStrLen);
   mSelectAll:
      SelAllObjects(activeObject);
   END;

IF err = 0 THEN
   BEGIN
   IF menuItem IN [mUndoLast,mCopy,mCut,mPaste] THEN
      SetTimeout(0);   { force field to be redrawn }
   END
ELSE
   FldEditError(err);

IF trcFiler THEN
   IF (err <> 0) THEN WRITELN('field editor error: ',err:1);
END;



{$S flrDm1 }
PROCEDURE EditName{* obj: ObjectHandle; pt: Point *};
{ called when a button down occurs in the name of the object setup for editing }
VAR savePort: GrafPtr;
    dataPtr: PtrData;
    nbrHood: Rect;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('EditName',WriteName(obj));
IF obj^^.toBeCopied THEN EXIT(EditName);       { can't name until created }
IF obj <> editObject THEN EXIT(EditName);
IF hCurFld^^.curLen = 0 THEN EXIT(EditName);

pt := curEvent.where;
LocalToGlobal(pt);

GetPort(savePort);
SetPort(obj^^.container^^.objWindow);

GlobalToLocal(pt);   { convert mouse pt to local coords for this window }
ClipName(obj);

IF curEvent.shiftKey THEN
   GrowSel(pt,hCurFld,hCurFstate,nbrHood)   { extend the selection }
ELSE
   BEGIN
   HilightSel(hCurFld,hCurFstate,FALSE);   { turn off current selection }
   CASE clickCount OF
      1: Select(pt,hCurFld,hCurFstate,nbrHood,timeoutInterval);
      2: SelectWord(pt,hCurFld,hCurFstate,nbrHood,timeoutInterval);
      OTHERWISE
         BEGIN
         ExitField(hCurFld,hCurFstate);
         SelectAll(hCurFld,hCurFstate,timeoutInterval);
         END;
      END;
   END;

{ grow the selection while the button is down }
WHILE StillDown DO
   IF clickCount < 3 THEN
      BEGIN
      GetMouse(pt);
      IF NOT PtInRect(pt,nbrHood) THEN
         GrowSel(pt,hCurFld,hCurFstate,nbrHood);
      END;

{ Set the timeout to blink the caret if appropriate }
IF TextSelected THEN
   timeoutInterval := noTimeout
ELSE
   StartBlink(timeoutInterval);

ObscureCursor;
SetTimeout(timeoutInterval);

SetPort(savePort);
END;



{$S flrCold }
FUNCTION EmptyGridSpot{* container: ObjectHandle; gridSpot: INTEGER): BOOLEAN *};
{ Returns TRUE if no object occupies the exact coords of the grid spot }
VAR gridPt: Point;
    listHead,son: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
listHead := container^^.contents;
son := listHead ^^.next;
GridToPt(container,gridSpot,gridPt);

WHILE son <> listHead DO
   BEGIN
   IF son^^.loc.h = gridPt.h THEN
      IF son^^.loc.v = gridPt.v THEN
         BEGIN
         EmptyGridSpot := FALSE;
         EXIT(EmptyGridSpot);
         END;
   son := son^^.next;
   END;

EmptyGridSpot := TRUE;
END;



{$S flrOpen }
FUNCTION EmptyTrashCan{* volHdl: TentryHdl; diskAlso, showAlert: BOOLEAN): BOOLEAN *};
{ destroys all closed objects in the trash can on the given volume }
LABEL 1;
VAR obj,nextObj,listHead: ObjectHandle;
    size: LongInt;
    err: INTEGER;
    pCatRec: PtrCatRec;
    devName: FmaxStr;
    wasDestroyed: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('EmptyTrashCan');
EmptyTrashCan := TRUE;
wasDestroyed  := TRUE;
IF volHdl^^.volState <> sMounted THEN EXIT(EmptyTrashCan);  {*** FI 279 ***}

   { check if anything in trash can }

IF diskAlso THEN
   BEGIN
   posApprox.fatherId := trashCatRID.uniqueID;
   PosCatRec(err,volHdl,posApprox,pCatRec);
   IF err = endOfCat THEN EXIT(EmptyTrashCan);   { It's already empty }
   IF showAlert THEN
      BEGIN
      devName := volHdl^^.devHdl^^.userNmHdl^^;
      ArgAlert(1,devName);
      WaitAlert(flrAlert,123);   { emptying trash can ... }
      END;
   END;

  { Remove the icons and possibly destroy the corresponding disk files }

IF trashObject^^.isOpen THEN   { destroy icons if trash can is open }
   BEGIN
   listHead := trashObject^^.contents;
   obj := listHead^^.next;
   WHILE obj <> listHead DO
      BEGIN
      nextObj := obj^^.next;
      IF (obj^^.volHdl = volHdl) AND (obj^^.state IN [normal,hilited]) THEN
         BEGIN
         IF diskAlso THEN
            BEGIN                { delete the O/S files }
            wasDestroyed := ShredObject(volHdl,obj^^.catRID,TRUE,FALSE);
            IF NOT wasDestroyed THEN GOTO 1;
            volHdl^^.flush := TRUE;
            obj^^.dirty := FALSE;                    { skip catalog update }
            obj^^.updateLabel := FALSE;              { skip label update }
            END;
         KillObject(obj,TRUE,TRUE);                  { remove the icon }
         END;
      obj := nextObj;
      END;
   END
ELSE   { trash can is closed.  Just destroy disk structures }
   IF diskAlso THEN
      wasDestroyed := ShredContents(volHdl,trashCatRID,TRUE,FALSE);


   { Recompute the sizes for the trash can and any remaining docs/folders }
1:
FlushVols;                                           { In case of crash }
IF diskAlso THEN
   BEGIN
   EmptyTrashCan := wasDestroyed AND NOT UserAbort;  { Acknowledge possible abort }
   size := RecompFolderSize(volHdl,trashCatRID);     { Adjust size of trash }
   IF trashObject^^.isOpen AND NOT wasDestroyed THEN
      UpdateAttributes(obj,FALSE);                   { in case partly destroyed }
   EndWaitAlert;
   END;
END;



{$S flrAll  }
PROCEDURE EndEdit;
{ terminates editing of current field }
VAR savePort: GrafPtr;
    newName: FmaxStr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('EndEdit of',WriteName(editObject));
IF editObject = nilObject THEN EXIT(EndEdit);


GetPort(savePort);
SetPort(editObject^^.container^^.objWindow);

IF NOT hCurFstate^^.valid THEN
   UpdateField;             { make sure field has been updated before exiting }

ClipName(editObject);
ExitField(hCurFld,hCurFState);

SetPort(savePort);

GetStrg(editObject^^.nameHdl,newName);
IF newName <> prevName THEN
   BEGIN
   editObject^^.dirty := TRUE;
   FlushObject(editObject);           { record change in catalog now }
   editObject^^.updateLabel := TRUE;  { set flag to write label when icon killed }
   END;

uInfo.lastOp := noOp;  { end undo capability for this field }

editObject := nilObject;
edit2Object := nilObject;
SetTimeout(noTimeout);
SetStdCursor(icrsInactive);
END;



{$S flrDskIn }
PROCEDURE EraseDisk{* diskObj: ObjectHandle *};
{ reinitializes a disk }
VAR err: INTEGER;
    catRec: TcatRec;
    deviceType: Tdevice;
    deviceName,diskName: FMaxStr;
    devHdl,newVolHdl: TentryHdl;
    iconName: FMaxStr;
    newName: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('EraseDisk',WriteName(diskObj));
IF NOT (diskObj^^.kind IN diskSet) THEN EXIT(EraseDisk);

devHdl := diskObj^^.volHdl^^.devHdl;
WITH devHdl^^ DO
   BEGIN
   deviceName := userNmHdl^^;
   deviceType := device;
   END;

IF diskObj^^.volHdl = bootVol THEN
   BEGIN
   ParamAlert (deviceName,'','');
   StopAlert(flrAlert,112);    { Can't erase startup disk ... }
   EXIT(EraseDisk);
   END;

{ Put everything away before asking for confirmation
               so that user can see what will be destroyed }
IF NOT CleanupDisk(diskObj,FALSE) THEN EXIT(EraseDisk);

{ ask user if s/he really wants to do this }
GetObjTitle(diskObj,TRUE,diskName);
ParamAlert (diskName,deviceName,'');
IF AskAlert(flrAlert, 228) = 1 THEN EXIT(EraseDisk);

UpdateAll;   { repaint under alert box }

newName := ForeignDisk(diskObj);

ParamAlert(deviceName,'','');
IF NOT UnmountAvolume(deviceType,FALSE {don't eject},FALSE,FALSE,234) THEN
   BEGIN
   EndWaitAlert;
   EXIT(EraseDisk);
   END;

ReinitializeVol(err,deviceType,newVolHdl);
diskObj^^.volHdl := newVolHdl;
diskObj^^.dirty := TRUE;   { update default name in catalog with user's name }

IF err > 0 THEN
   BEGIN   { failed.  Remove disk icon and eject the disk }
   KillObject(diskObj,TRUE,TRUE);
   devHdl^^.objHdl := ORD(NIL);  { invalidate hdl to object }
   DismountVol(deviceType,TRUE {eject},TRUE {resume docs});
   EXIT(EraseDisk);
   END;

IF diskObj^^.volHdl^^.volState = sMounted THEN DrawTheIcon(diskObj);

IF newName THEN
   BEGIN
   IF err <= 0 THEN    { change icon name if it was a foreign disk }
      BEGIN
      GetCatRec(err,newVolHdl,diskCatRID,catRec);
      IF err <= 0 THEN
         BEGIN
         ExtObjName(catRec,iconName);
         ChangeName(diskObj,iconName);
         END;
      END
   ELSE
      BEGIN
      newVolHdl^^.volState := sNoFileSystem;
      iconName := '';
      ChangeName(diskObj,iconName);
      END;
   END;

EndWaitAlert;
END;



{$S flrDraw }
PROCEDURE EraseObject(obj: ObjectHandle);
{ removes an object from it's container list and adjusts screen }
VAR container: ObjectHandle;
    isSpatial: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('EraseObject',WriteName(obj));
container := obj^^.container;
isSpatial := InSpatialView(obj);

IF isSpatial THEN ValidObject(obj,FALSE);

obj^^.visible := FALSE;

{ redisplay }
IF isSpatial THEN
   UpdateObject(container,FALSE)
ELSE
   DrawContents(container);

obj^^.visible := TRUE;
END;



{$S flrNever }
PROCEDURE FailedAlert;
{ Called by alert manager when an error occurs using the alert manager package }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF dbgFiler THEN WRITELN('Alert manager error = ',alertError);
StopAlert(flrAlert,2);   { Problem reading startup disk ... }
END;



{$S flrMisc }
FUNCTION FindToolNode{* toolNumber: LongInt; makeOne: BOOLEAN): HdlToolNode *};
LABEL 1;
VAR toolNode: HdlToolNode;
    toolNum: LongInt;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('FindToolNode for tool: ',toolNumber:1);
toolNode := toolList;
WHILE toolNode <> NIL DO
   BEGIN
   IF toolNode^^.toolnum = toolNumber THEN GOTO 1;
   toolNode := toolNode^^.next;
   END;

IF makeOne THEN
   BEGIN
   IF trcFiler THEN WRITELN('   Creating new tool entry');
   toolNode := Pointer(ORD(NewHdl(SIZEOF(toolNode^^))));
   IF toolNode = NIL THEN EXIT(FindToolNode);

   WITH toolNode^^ DO
      BEGIN
      toolNum        := toolNumber;
      tryToOpen      := TRUE;
      usesStationery := TRUE;
      whichVol       := NIL;
      font           := noFont;
      bbox           := iconBoxes[toolKind];
      next           := toolList;
      END;
   toolList := toolNode;
   END;

1:
FindToolNode := toolNode;
END;



{$S flrClose }
PROCEDURE FindVisHome{* obj: ObjectHandle; VAR visHome: ObjectHandle;
                                           VAR visPt: Point *};
{ Returns the first visible ancestor of obj.  "visPt" is the global coordinates
  of obj in it's container (if visHome is open) OR of visHome itself }
VAR savePort: GrafPtr;
    theObj: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('FindVisHome',WriteName(obj));
GetPort(savePort);

IF obj^^.container <> deskObject THEN
   theObj := obj
ELSE
   theObj := GetPlaceHolder(obj);  { Is the object's placeholder visible? }

IF theObj <> nilObject THEN
   BEGIN
   IF trcFiler THEN WRITELN('   found place holder, use it''s location');
   visHome := theObj^^.container;
   GetVisLoc(theObj,TRUE,visPt);    { return location within container }
   SetPort(visHome^^.objWindow);
   END
ELSE
   BEGIN
   IF trcFiler THEN WRITELN('   no place holder, look for parent');
   FindVisParent(obj,visHome);
   IF visHome = deskObject THEN EXIT(FindVisHome);
   GetVisLoc(visHome,TRUE,visPt);     { return location of closed parent }
   SetPort(visHome^^.container^^.objWindow);
   END;

IF trcFiler THEN WRITELN('   visPt = ',visPt.h,visPt.v);

{ convert visPt to global }
LocalToGlobal(visPt);
SetPort(savePort);
END;



{$S flrDm1 }
PROCEDURE FindVisParent{* obj: ObjectHandle; VAR visParent: ObjectHandle *};
{ climbs object tree looking for first visible parent }
VAR whichVol: TentryHdl;
    recID,fatherRecID: TcatRID;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('FindVisParent',WriteName(obj));

IF obj^^.kind IN putBackSet THEN
   BEGIN
   whichVol := obj^^.volHdl;
   recID := obj^^.catRID;

   { search for first visible ancestor }
   REPEAT
      ClimbTree(whichVol,recID,fatherRecID,visParent);
      recID := fatherRecID;
   UNTIL visParent <> nilObject;
   END
ELSE
   visParent := deskObject;
END;



{$S flrNever }
PROCEDURE FldEditError{* err: INTEGER *};
{ reports (via an alert box) any errors as result of editing text }
VAR numStr: NumberStr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
CASE err OF
   fldFull:
      BEGIN
      IF (NOT InDialog) THEN
         BEGIN
         IntToStr(hCurFld^^.maxLen,numStr);
         ArgAlert(1,numStr);
         StopAlert(flrAlert,118);       { too many characters ... }
         UpdateText;
         END
      ELSE
         BEGIN
         IntToStr (diBox.curSel^^.info.fieldHdl^^.maxLen, numStr);
         ArgAlert (1, numStr);
         StopAlert (flrAlert, 331);     { Alert: You cannot enter more than <1> characters in this field }
         END;
      END; {of CASE ITEM fldFull}
   fldProtected:
      StopAlert(flrAlert,119);          { this name cannot be changed ... }
   nullSelect,
   invScrapType: { these errors cannot occur due to menu disabling }
      ;
   invOpType:
      StopAlert(flrAlert,103);          { cannot undo ... }
   END;
END;



{$S flrAll }
PROCEDURE FlushObject{* obj: ObjectHandle *};
{ updates catalog from memory structures }
VAR err: INTEGER;
    theVol: TentryHdl;
    theRID: TcatRID;
    catRec: TcatRec;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

IF ForeignDisk(obj) THEN EXIT(FlushObject);

WITH obj^^ DO
   BEGIN
   theVol := volHdl;
   theRID := catRID;
   END;

IF (theVol <> NIL) AND obj^^.dirty THEN
   BEGIN
   IF trcFiler THEN WRITELN('FlushObject',WriteName(obj));
   GetCatRec(err,theVol,theRID,catRec);
   IF ErrorFound(warnError,1003,err,theVol^^.devHdl) THEN EXIT(FlushObject);

   UpdateRec(obj,catRec);
   UpdCatRec(err,theVol,posCurrent,catRec);
   IF ErrorFound(warnError,1004,err,theVol^^.devHdl) THEN EXIT(FlushObject);
   obj^^.updateLabel := TRUE;
   END;
END;



{$S flrAll}
PROCEDURE FlushTypeAhead{* toFront: BOOLEAN *};
{ flushes the input queue of user input, enables/disables bring to front }
VAR info: WindowInfo;
    saveOkFront: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF NOT toFront AND (activeFolder <> NIL) THEN
   BEGIN
   GetWindInfo(activeFolder,info);
   saveOkFront := info.okFront;
   info.okFront := FALSE;
   SetWindInfo(activeFolder,info);
   END;

FlushInputs(NIL);

IF NOT toFront AND (activeFolder <> NIL) THEN
   BEGIN
   info.okFront := saveOkFront;
   SetWindInfo(activeFolder,info);
   END;
END;



{$S flrDm  }
PROCEDURE FlushVols;
{ Scans through volume list and flushes the object catalog to disk for all marked
  volumes.  Volumes are typically marked as needing flushing after a move or copy
  operation.  This is done to keep the object catalog (unique id generator in
  particular) and the O/S directory in sync in case of a crash. }
VAR volHdl: TentryHdl;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
volHdl := firstVol;
WHILE volHdl <> NIL DO
   BEGIN
   IF volHdl^^.flush THEN
      BEGIN
      FlushCat(volHdl);
      volHdl^^.flush := FALSE;
      END;
   volHdl := volHdl^^.nextHdl;
   END;
END;



{$S flrDm }
FUNCTION  ForeignDisk{obj: ObjectHandle): BOOLEAN};
{ Checks to see if the object is a disk and, if so, if has an open filer catalog }
BEGIN
ForeignDisk := FALSE;
IF obj^^.volHdl <> NIL THEN
   IF obj^^.kind IN diskSet THEN
      IF obj^^.volHdl^^.volstate <> sMounted THEN ForeignDisk := TRUE;
END;



{$S flrDm }
FUNCTION GenContents{* obj: ObjectHandle): BOOLEAN *};
{ produces the contents list for an object }
{ objects are read from catalog in alphabetical order }
LABEL 1;
VAR catRID   : TcatRID;
    objID    : IDType;
    whichVol : TentryHdl;
    pCatRec  : PtrCatRec;
    son      : ObjectHandle;
    err      : INTEGER;
    objName  : FmaxStr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GenContents',WriteName(obj));

GenContents := TRUE;
IF NOT IsContainer(obj) THEN EXIT(GenContents);
IF ForeignDisk(obj) THEN EXIT(GenContents);

GenContents := FALSE;
whichVol := obj^^.volHdl;
objID    := obj^^.catRID.uniqueID;

{ position to first record of contents }
posApprox.fatherID := objID;
PosCatRec(err,whichVol,posApprox,pCatRec);

{ create an object node for each record }
WHILE (err = 0) AND (pCatRec^.parentID = objID) DO
   WITH pCatRec^ DO
      BEGIN
      ExtObjName(pCatRec^,objName);
      catRID.fatherID := parentID;
      catRID.uniqueID := selfID;
      son := MakeObject(obj,objName,objKind,toolId,closedPt,openRect,normal,
                        view,whichVol,catRID,created,modified,objSize,
                        split<>nullInt2,props[iconPassWd]);
      IF son = NIL THEN GOTO 1;
      IF OnDesktop(whichVol,selfId) THEN son^^.state := placeHolder;
      PosCatRec(err,whichVol,posNext,pCatRec);
      END;

IF (err = 0) OR (err = endOfCat) THEN
   GenContents := TRUE
ELSE
   IF ErrorFound(warnError,1005,err,whichVol^^.devHdl) THEN;

1:
IF (obj^^.viewMode <> spatialView) AND (obj^^.viewMode <> alphaView) THEN
   SortContents(obj,obj^^.viewMode);
END;



{$S flrMisc }
PROCEDURE GenTrashContents;
{ produces union of trash on all volumes }
LABEL 1;
VAR whichVol: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('GenTrashContents');
whichVol := firstVol;
WHILE whichVol <> NIL DO
   BEGIN
   IF whichVol^^.catOpen THEN
      BEGIN
      trashObject^^.volHdl := whichVol;
      IF NOT GenContents(trashObject) THEN GOTO 1;
      END;
   whichVol := whichVol^^.nextHdl;
   END;
1:
trashObject^^.volHdl := bootVol;   { restore proper volHdl }
END;



{$S dmMain }
PROCEDURE GetContentRect{* obj: ObjectHandle; VAR r: Rect *};
{ returns the content rectangle }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GetContentRect',WriteName(obj));
r := obj^^.objWindow^.portRect;
WITH r DO
   BEGIN
   IF IsContainer(obj) AND (obj^^.viewMode <> spatialView) THEN
      top := top + lineHt;                 { adjust for column titles }
   IF obj <> deskObject THEN               { adjust for scrollbars }
      BEGIN
      right := right - dhSbox + 1;
      bottom := bottom - dvSbox + 1;
      END;
   END;
END;



{$S flrDm }
PROCEDURE GetFldStr{* hFld: HndField; hFstate: HndFstate; VAR strg: FMaxStr *};
{ extracts the current value of a field }
VAR i,fldLength: INTEGER;
    dataPtr: PtrData;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
{$R-}
fldLength := MIN(hFld^^.curLen,SIZEOF(strg)-1);
IF hFstate = NIL THEN
   BEGIN
   dataPtr := @strg;
   MoveLeft(hFld^^.curValue^^,dataPtr^[1],fldLength);
   END
ELSE
   BEGIN
   FOR i := 0 TO fldLength-1 DO
      strg[i+1] := CHR(hFld^^.curValue^^[ExpandedLp(i,hFld,hFstate)]);
   END;

strg[0] := CHR(fldLength);

{$IFC flrDebug }
   {$R+}
{$ENDC }

IF trcFiler THEN WRITELN('GetFldStr "',strg,'"');
END;



{$S flrMisc }
PROCEDURE GetHomeLoc(obj: ObjectHandle; VAR homeLoc: Point);
{ fetches an objects spatial location in it's filing home }
VAR err: INTEGER;
    catRec: TcatRec;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GetHomeLoc for',WriteName(obj));

IF IsFather(obj,obj^^.container) THEN
   BEGIN
   homeLoc := obj^^.loc;
   EXIT(GetHomeLoc);
   END;

GetCatRec(err,obj^^.volHdl,obj^^.catRID,catRec);
IF ErrorFound(warnError,1006,err,obj^^.volHdl^^.devHdl) THEN
   SetPt(homeLoc,10,10)   { choose arbitrary value }
ELSE
   homeLoc := catRec.closedPt;
END;



{$S flrMisc }
FUNCTION GetHomeObj{* obj: ObjectHandle): ObjectHandle *};
{ returns a the filing home of obj, nilObject if not visible }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GetHomeObj',WriteName(obj));
GetHomeObj :=
   SearchContents(deskObject,obj^^.volHdl,obj^^.catRID.fatherId,TRUE,TRUE);
END;



{$S dmMain }
PROCEDURE GetIconRect{* obj: ObjectHandle; VAR bbox: Rect *};
{ returns the bounding box of icon mask within its char cell }
VAR toolInfo: TtoolInfo;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF (obj^^.kind = toolKind) AND (obj^^.toolNumber > maxKnownTool) THEN
   BEGIN
   IF GetToolInfo(obj,toolInfo) THEN
      bbox := toolInfo.bbox
   ELSE
      bbox := iconBoxes[toolKind];
   END
ELSE
   bbox := iconBoxes[obj^^.kind]
END;



{$S flrAll }
PROCEDURE GetIcons{* obj: ObjectHandle; VAR shapeFont: Tfam; VAR mask,data: CHAR
                                        VAR faceFont: Tfam;  VAR overlay: CHAR;
                                        VAR iconBBox: Rect *};
{ returns the font and char codes for drawing an icon }
VAR toolNum: LongInt;
    kind: ObjectKind;
    toolInfo: TtoolInfo;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
toolNum := obj^^.toolNumber;
kind    := obj^^.kind;

shapeFont := fIconFont;
faceFont  := fIconFont;
mask      := iconMask[kind];
data      := iconData[kind];
overlay   := CHR(noIcon);
iconBBox   := iconBoxes[kind];

IF ForeignDisk(obj) THEN
   CASE obj^^.volHdl^^.volState OF
      sMacDisk: overlay := CHR(84);
      OTHERWISE overlay := CHR(85);
      END;

IF toolNum <= maxKnownTool THEN
   BEGIN
   IF toolNum > deskTool THEN
      overlay := iconOverlay[toolNum];     { lookup std tool overlay in table }
   END
ELSE IF GetToolInfo(obj,toolInfo) THEN
   BEGIN
   IF (kind = toolKind) AND (NOT toolInfo.usesStationery) THEN
      BEGIN
      shapeFont := toolInfo.font;          { use tool shape in tool's font }
      data      := CHR(dataCode);
      mask      := CHR(maskCode);
      iconBBox  := toolInfo.bbox;
      END
   ELSE
      BEGIN                                { use std shapes }
      faceFont := toolInfo.font;           { use overlay in tool's font }
      overlay  := CHR(overlayCode);
      END;
   END;
END;


{$S flrMisc }
PROCEDURE GetListPos{* obj: ObjectHandle; tinyIcon: BOOLEAN; VAR pt: Point *};
{ returns an object's list view icon position }
VAR objNum,vPos: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GetListPos',WriteName(obj));
objNum := NumFromObj(obj);
vPos := (objNum+1)*lineHt;
SetPt(pt,10,vPos-botToBaseLn-13);

IF NOT tinyIcon THEN
   WITH pt DO   { adjust pt so that large icon is centered over tiny icon }
      BEGIN
      h := h - 12;
      v := v - 12;
      END;
END;


{$S flrAll }
PROCEDURE GetNameLoc{* obj: ObjectHandle; VAR fldPt: Point *};
{ returns the point below the icon about which the title is drawn }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GetNameLoc');
WITH obj^^.loc DO
   BEGIN
   fldPt.h := h + icon2Width;
   fldPt.v := v + iconHt + iconFntInfo.ascent + 1;
   END;
END;



{$S dmMain }
PROCEDURE GetObjTitle{* obj: ObjectHandle; addQuotes: BOOLEAN; VAR title: FmaxStr *};
{ returns the name to be used in the window title or alert message }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GetObjTitle',WriteName(obj));
IF obj^^.nameHdl = NIL THEN
   title := ''
ELSE
   GetStrg(obj^^.nameHdl,title);

IF LENGTH(title) = 0 THEN
   GetDefName(ORD(obj^^.kind),title)
ELSE
   BEGIN
   IF addQuotes THEN QuoteName(title);
   END;
END;



{$S flrAll }
FUNCTION GetPlaceHolder{* obj: ObjectHandle): ObjectHandle *};
{ searches for the placeholder for obj }
VAR son,placeObj,listHead: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GetPlaceHolder for',WriteName(obj));
GetPlaceHolder := nilObject;
IF obj^^.toBeCopied THEN EXIT(GetPlaceHolder);
IF obj^^.container <> deskObject THEN EXIT(GetPlaceHolder);

listHead := deskObject^^.contents;
son := listHead^^.next;

{ search all the containers on the desktop for the placeholder }
WHILE son <> listHead DO
   BEGIN
   IF IsContainer(son) THEN
      BEGIN
      placeObj := SearchContents(son,obj^^.volHdl,obj^^.catRID.uniqueId,FALSE,TRUE);
      IF placeObj^^.state = placeHolder THEN
         BEGIN
         GetPlaceHolder := placeObj;
         IF trcFiler THEN WRITELN('   found placeholder in',
                                      WriteName(placeObj^^.container));
         EXIT(GetPlaceHolder);
         END;
      END;
   son := son^^.next;
   END;
IF trcFiler THEN WRITELN('   placeholder not found');
END;



{$S flrCat }
FUNCTION GetToolInfo{* obj: ObjectHandle; VAR toolInfo: TtoolInfo): BOOLEAN *};
{ retrieves info about non-std tools }
LABEL 1;
VAR toolNode: HdlToolNode;
    font: Tfam;
    toolNum: LongInt;
    objVol,volHdl: TentryHdl;
    err: INTEGER;
    pCatRec: PtrCatRec;
    bbox: Rect;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GetToolInfo for',WriteName(obj));
GetToolInfo := FALSE;
toolNum := obj^^.toolNumber;
objVol := obj^^.volHdl;

toolNode := FindToolNode(obj^^.toolNumber,TRUE);
IF toolNode = NIL THEN EXIT(GetToolInfo);  { no heap space }

IF (toolNode ^^.font = noFont) AND toolNode^^.tryToOpen THEN
   BEGIN
   IF obj^^.kind = toolKind THEN
      BEGIN
      PosCatRec(err,objVol,obj^^.catRID,pCatRec);
      toolNode^^.usesStationery := NOT pCatRec^.props[noDocs];
      END;

   IF NOT OpenFont(objVol,toolNum,font) THEN  { look on same vol for font }
      BEGIN
      volHdl := firstVol;
      WHILE volHdl <> NIL DO      { try other volumes }
         BEGIN
         IF volHdl <> objVol THEN
            IF OpenFont(volHdl,toolNum,font) THEN  GOTO 1;
         volHdl := volHdl^^.nextHdl;
         END;
      font := noFont;
      END;

   1:
   IF obj^^.kind = toolKind THEN
      BEGIN
      toolNode^^.bbox := iconBoxes[toolKind];   { default }
      IF (NOT toolNode^^.usesStationery) AND (font <> noFont) THEN
         BEGIN
         CalcBBox(font,CHR(maskCode),bbox);
         toolNode^^.bbox := bbox;
         END;
      END;

   toolNode^^.font := font;
   toolNode^^.tryToOpen := FALSE;
   END;

toolInfo := toolNode^^;
GetToolInfo := (toolNode^^.font <> noFont);
IF trcFiler THEN WRITELN('   font to use is ',toolInfo.font:1);
END;


{$S dmMain }
PROCEDURE GetVisLoc{* obj: ObjectHandle; withinContainer: BOOLEAN; VAR pt: Point *};
{ Returns the object's current location either spatial or list.  "withinContainer"
  => constrain the point returned to the current container boundaries }
VAR contentRect: Rect;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF InSpatialView(obj) THEN
   pt := obj^^.loc
ELSE
   GetListPos(obj,FALSE,pt);

IF withinContainer THEN
   BEGIN
   GetContentRect(obj^^.container,contentRect);
   WITH pt,contentRect DO
      BEGIN
      h := MAX(h,left-icon2Width); h := MIN(h,right);
      v := MAX(v,top-icon2Ht);     v := MIN(v,bottom);
      END;
   END;
END;



{$S flrMisc }
PROCEDURE GridToPt{* container: ObjectHandle; gridSpot: INTEGER; VAR pt: Point *};
{ converts a grid number into a window location }
LABEL 1;
VAR row,col,nGridCols: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF container = deskObject THEN
   BEGIN
   FOR row := nDeskRows-1 DOWNTO 0 DO
      FOR col := nDeskCols-1 DOWNTO 0 DO
         IF gridTable[row,col] = gridSpot THEN GOTO 1;
   1:
   END
ELSE WITH container^^.objWindow^.portRect DO
   BEGIN
   nGridCols := NumGridCols(container);
   row := gridSpot DIV nGridCols;
   col := gridSpot MOD nGridCols;
   END;

pt.h := hGridStart + col*hGrid;
pt.v := vGridStart + row*vGrid;
IF trcFiler THEN
   WRITELN('GridToPt ',gridSpot:1,'  row,col: ',row:4,col:4,'  pt:',pt.h:4,pt.v:4);
END;



{$S flrDm1 }
FUNCTION GrowHeap{* hz: Thz; bytesNeeded: INTEGER): INTEGER *};
{ Note: when growing the heap, the heap must be 256 bytes smaller than
  the heap otherwise copying a short string, located near the upper edge
  of the heap, to a long string might cause a bus error because the
  number of bytes copied is the length of the receiving string.  }

LABEL 1;
CONST hzIncrement = 2048;
VAR err: INTEGER;
    memSize,diskSize,
    newMemSize,newDiskSize,
    delta1DiskSize,delta1MemSize,delta2DiskSize,delta2MemSize,
    curHzSize,niceHzSize,minHzSize: LongInt;
    dsInfo: DsInfoRec;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('GrowHeap');
GrowHeap := 0;

Info_DataSeg(err,flrHeapRefnum,dsInfo);
IF ErrorFound(warnError,1039,err,NIL) THEN EXIT(GrowHeap);

memSize  := dsInfo.mem_size;  diskSize := dsInfo.disc_size;
curHzSize := CbOfHz(hz);

IF dbgFiler THEN WRITELN('"',fnameHeap,'" is full.',
                         '  size: ',curHzSize:1,
                         '  needed: ',bytesNeeded:1,
                         '  dsMemSize: ',memSize:1,
                         '  dsDiskSize: ',diskSize:1);

(***  don't do this test until alert mgr handles out of space
IF fakeNoHeap THEN
   BEGIN
   WRITELN('Fake no heap available');
   EXIT(GrowHeap);
   END;
***)

minHzSize  := curHzSize + bytesNeeded + 256;  { the 256 pads for string moves }
niceHzSize := ((minHzSize + hzIncrement - 1) DIV hzIncrement)*hzIncrement;

{ can we expand the heap within the current segment memory size? }
IF minHzSize <= memSize THEN
   BEGIN
   IF dbgFiler THEN WRITELN('  expanded Hz to memSize.  Skipped Size_DataSeg.');
   GrowHeap := memSize - curHzSize;  { expand heap to full mem segment size }
   newMemSize := memSize;
   GOTO 1;
   END;

{ can we avoid increasing the disk size of the data segment? }
IF minHzSize < diskSize THEN
   BEGIN
   delta1DiskSize := 0;
   delta1MemSize  := MIN(niceHzSize - memSize,diskSize - memSize);
   delta2DiskSize := 0;
   delta2MemSize  := minHzSize - memSize;
   IF dbgFiler THEN WRITELN('  increased segment memory size');
   END
ELSE       { must increase the data segment disk size }
   BEGIN
   delta1DiskSize := niceHzSize - diskSize;   { first choice }
   delta1MemSize  := niceHzSize - memSize;
   delta2DiskSize := minHzSize  - diskSize;   { second choice }
   delta2MemSize  := minHzSize  - memSize;
   IF dbgFiler THEN WRITELN('  increased segment disk size');
   END;

Size_DataSeg(err,flrHeapRefNum,delta1MemSize,newMemSize,delta1DiskSize,newDiskSize);
IF err <> 0 THEN
   BEGIN      { try for minimum }
   Size_DataSeg(err,flrHeapRefNum,delta2MemSize,newMemSize,delta2DiskSize,newDiskSize);
   IF err <> 0 THEN
      BEGIN       { try to free some space }
      IF ReclaimDiskSpace(bootVol,0 {all}) > 0 THEN
         Size_DataSeg(err,flrHeapRefNum,delta2MemSize,newMemSize,delta2DiskSize,newDiskSize);
      IF ErrorFound(warnError,1040,err,NIL) THEN EXIT(GrowHeap);
      END;
   END;


GrowHeap := newMemSize - curHzSize - 256;  { keep 256 bytes outside the heap for string moves }

1:
IF dbgFiler THEN WRITELN('  new heap size = ',newMemSize:1);
END;



{$S flrDm }
PROCEDURE HandleWhyActivated{* event : EventRecord *};
{ handles the "why" field for activate events }
VAR whichWindow: WindowPtr;
    whichObject,homeObj: ObjectHandle;
    putBack: BOOLEAN;
    title,fatherTitle: FmaxStr;
    btn: INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('HandleWhyActivated');
CASE event.why OF

   whyNot: ;    { nothing special about this activate }

   whyClick:    { window mgr sends this when user buttons down in window }
      BEGIN
      UpdateAll;          { process any updates first }
      clickTime := event.when + clickDelay;  { set dbl click time since no btn up }
      DoBtnDownEvent;     { act as though button down }
      END;

   whyFind:     { window mgr sends this when item selected from desktop menu }
      BEGIN
      whichObj := deskList[event.userData];
      IF whichObj = NIL THEN EXIT(HandleWhyActivated);

      IF whichObj^^.kind in padSet THEN     { if it's a pad, make new doc and open it }
         IF NOT TearOffObject(whichObj,whichObj) THEN EXIT(HandleWhyActivated);

      IF whichObj^^.isOpen THEN
         MakeFldrActive(whichObj^^.objWindow, whyNot)
      ELSE
         IF OpenObject(whichObj, TRUE) THEN MakeObjActive(whichObj);
      END;

   whyClose:    { window mgr sends this when a window is to be closed (dbl click)}
      BEGIN
      whichWindow := Pointer(event.userData);      { the window to be closed }
      whichObject := ObjFromWindow(whichWindow);   { object that owns window }
      putBack := whichObject^^.container <> deskObject;

   (* IF putBack AND LiveObject(whichObject) THEN
         BEGIN
         GetObjTitle(whichObject,TRUE,title);
         GetObjTitle(whichObject^^.container,TRUE,fatherTitle);
         ParamAlert(title,fatherTitle,'');
         btn := AskAlert(flrAlert,128);  { put on desk or back in container? }
         UpdateAll;
         CASE btn OF
            1: BEGIN    { cancel }
               IF whichObject^^.objWindow = curEvent.fromFolder THEN { was active }
                  MakeObjActive(whichObject);
               EXIT(HandleWhyActivated);
               END;
            2: putBack := FALSE;
            3: putBack := TRUE;
            END;
         END; *)

      IF CloseObject(whichObject,FALSE,putBack,FALSE) THEN;
      END;

   whyDied:     { application sends this via "ImDying" }
      BEGIN
      FinishTerminating;
      UpdateAll;
      MakeObjActive(ObjFromWindow(TopWindow));
      END;

   whyHitOrphan: { Desk sends this to itself so that the orphan window is not }
      BEGIN      { active when it is restarted.  Apps can't be created active. }
      HitOrphan(orphanObject);
      END;



   { These come from applications when an item from the first menu is chosen }

   cmdClose:
      BEGIN
      IF CloseObject(ObjFromWindow(event.fromFolder),FALSE,FALSE,FALSE) THEN;
      END;

   cmdClosAll:
      BEGIN
      IF CloseContents(deskObject,FALSE,FALSE) THEN;
      END;

   OTHERWISE
      BEGIN
      {$IFC flrDebug }
      WRITELN('Desk activated with unknown why = ',event.why:1);
      {$ENDC }
      END;

   END;  { case why }
END;



{$S flrAll }
PROCEDURE HideScroll{* obj: ObjectHandle *};
{ erases scroll bar contents but leaves border }
VAR window: WindowPtr;
    savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('HideScroll');

window := obj^^.objWindow;
IF (window = filerFolder) OR (window = NIL) THEN EXIT(HideScroll);

GetPort(savePort);
ScrollEnvironment(obj);
HideSborder(window^.portRect);
NormalEnvironment(obj);
SetPort(savePort);
END;



{$S flrAll }
PROCEDURE HitContainer{* obj: ObjectHandle *};

{ Handles button down events in container windows (including desktop) }
{ Handles selection of objects.  Decides what to do after objects have }
{ been dragged }

LABEL 1,2;
VAR newPt,downPt: Point;
    pointAt,targetIcon,targetContainer,diskObj,topObject: ObjectHandle;
    targetMatch:  BOOLEAN;
    hitRect,groupRect,windRect,contentRect: Rect;
    dh,dv: INTEGER;
    tallyCount:INTEGER;   { how many things are selected }
    tallySet: KindSet;    { what kinds are selected }
    tallyBBox: Rect;
    maxDh,maxDv,minDh,minDv:  INTEGER;
    partial: BOOLEAN;
    savePort: GrafPtr;
    splitflag,joinflag:  BOOLEAN;
    srcIsList,dstIsList: BOOLEAN;
    hitName: BOOLEAN;
    overlap: BOOLEAN;
    allMoved: BOOLEAN;
    window: WindowPtr;


   {$S flrAll }
   PROCEDURE RefuseMove;
   { rejects move attempt by moving remaining icons back to starting point }
   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
   IF trcFiler THEN WRITELN('RefuseMove');
   UpdateAll;                                   { cleanup screen before animation }
   XorContents(obj,limbo,xorDh,xorDv,xorWindow);{ erase final xor }
   WalkContents(obj,limbo,xorDh,xorDv,0,0);     { animate back }
   ChangeContents(obj,limbo,hilited,0,0,TRUE);  { hilite those left }
   END;


   {$S flrAll }
   PROCEDURE MoveToWindow;
   { moves selected icons to an open object (possibly same container) }
   VAR iconRect: Rect;
   BEGIN
   IF trcFiler THEN WRITELN('MoveToWindow');
   IF copyMode AND (targetContainer = trashObject) THEN {*** FI 234 ***}
      BEGIN            { ignore duplicates moved to the trash }
      XorContents(obj,limbo,xorDh,xorDv,xorWindow);{ erase final xor }
      KillDuplicates(obj);
      EXIT(MoveToWindow);
      END;

   IF targetContainer = obj THEN     { changed location in same container }
      BEGIN
      IF copyMode THEN
         BEGIN
         IF pointAt^^.kind IN diskSet THEN EXIT(MoveToWindow);
         ValidContents(obj,limbo,FALSE);
         IF CopyContents(obj,limbo,dh,dv,(obj = deskObject)) THEN allMoved := TRUE;
         END
      ELSE IF srcIsList THEN
         EXIT(MoveToWindow)
      ELSE
         BEGIN
         ValidContents(obj,limbo,FALSE);                    { invalidate at old }
         GetIconRect(pointAt,iconRect);
         WITH iconRect DO
            overlap := (ABS(dh) < (right-left)) AND (ABS(dv) < (bottom-top));
         XorContents(obj,limbo,dh,dv,xorWindow);            { erase dim images }
         ChangeContents(obj,limbo,hilited,dh,dv,NOT overLap);
         IF overlap THEN
            BEGIN
            ValidContents(obj,hilited,FALSE);               { invalidate at new }
            UpdateObject(obj,FALSE);                        { erase old, draw new }
            END;
         allMoved := TRUE;
         END;
      AdjustContents(obj,hilited);    { move to non-overlapping positions }
      END
                                    { moved to a different window }
   ELSE IF Match(targetContainer,tallySet,tallyCount) THEN
      BEGIN
      { don't move disk icon to open disk ?? }
      IF tallySet*diskSet <> [] THEN EXIT(MoveToWindow);

      IF targetContainer^^.kind IN diskSet THEN
         IF targetContainer^^.volHdl^^.volState <> sMounted THEN
            BEGIN                   { can't move stuff to a foreign disk }
            StopAlert (flrAlert, 314);
            EXIT (MoveToWindow);
            END;

      allMoved :=
         MoveContents(obj,limbo,hilited,dh,dv,targetContainer,dstIsList,TRUE,
                      splitflag,joinflag);
      IF NOT splitflag THEN
         BEGIN
         IF allMoved AND (NOT ClickedNewWindow) THEN
            BEGIN
            MakeObjActive(targetContainer);
            AdjustContents(targetContainer,hilited);    { move to non-overlapping positions }
            IF tallyCount = 1 THEN SelectName(pointAt,FALSE);
            END
          ELSE
             ChangeContents(targetContainer,hilited,normal,0,0,TRUE);
          END;
      END;
   END;



   {$S flrAll }
   PROCEDURE MoveToIcon;
   { Moves selected objects to a closed object }
   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
   IF trcFiler THEN WRITELN('MoveToIcon');
   IF NOT targetMatch THEN EXIT(MoveToIcon);

   { don't allow copy into self }
   IF (pointAt^^.volHdl = targetIcon^^.volHdl) AND
      (pointAt^^.catRID.uniqueID = targetIcon^^.catRID.uniqueID) THEN EXIT(MoveToIcon);

   { special case moving disks => backup operation }
   IF (pointAt^^.kind IN diskSet) AND (targetIcon^^.kind IN diskSet) THEN
      BEGIN
      IF ForeignDisk (pointAt) THEN
         BEGIN
         StopAlert(flrAlert, 315);
         EXIT(MoveToIcon);
         END;
      BackupDisk(pointAt,targetIcon);
      RefuseMove;              { return source disk to its desk location }
      KillDuplicates(obj);
      IF pointAt^^.volHdl = NIL THEN KillObject(pointAt,TRUE,TRUE);
      IF targetIcon^^.volHdl = NIL THEN KillObject(targetIcon,TRUE,TRUE);
      END
   ELSE
      BEGIN
      IF ForeignDisk(targetIcon) THEN
         BEGIN                { can't move stuff to a foreign disk except for backup }
         StopAlert (flrAlert, 314);
         EXIT(MoveToIcon);
         END;

      { blink and hilite target icon if transfer accepted }
      BlinkObject(targetIcon);

      IF MoveContents(obj,limbo,hilited,dh,dv,targetIcon,TRUE,TRUE,splitflag,joinflag)
      THEN
         BEGIN
         allMoved := TRUE;
         IF NOT ClickedNewWindow AND NOT splitflag THEN
            BEGIN
            SelectObject(targetIcon,FALSE);
            MakeObjActive(targetContainer);
            END;
         END;
      END;
   END;


{$S flrAll }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('HitContainer',WriteName(obj));
IF NOT IsContainer(obj) THEN EXIT(HitContainer);

splitflag := FALSE;
joinflag := FALSE;
window := obj^^.objWindow;
IF window = NIL THEN EXIT(HitContainer);

SetPort(window);

IF clickCount > 1 THEN  { for multi-click, use pt of first click, in case of }
   downPt := clickLoc   {    auto-scroll }
ELSE
   downPt := curEvent.where;

GetContentRect(obj,contentRect);
targetContainer := nilObject;

IF NOT PtInRect(downPt,contentRect) THEN EXIT(HitContainer);

ClipRect(contentRect);
srcIsList := (obj^^.viewMode <> spatialView);

{ determine which object was pointed at }
WITH downPt DO SetRect(hitRect,h-3,v-2,h+3,v+2);
pointAt := WhichObject(obj,hitRect,FALSE,hitName);

{ If in copy mode then exit if didn't point at a blinking duplicate }
IF copyMode THEN
   IF pointAt^^.toBeCopied THEN
      GOTO 1
   ELSE
      BEGIN
      IF InCopyMode THEN;              { give user a chance to cancel duplicate }
      IF copyMode THEN EXIT(HitContainer); { didn't cancel }
      END;

{ Stop current editing if pointed at an object other than that currently being edited }
IF pointAt <> editObject THEN EndEdit;

{ check if pointed at name }
IF hitName THEN
   BEGIN
   IF pointAt = editObject THEN        { clicked in name set up for editing }
      EditName(pointAt,curEvent.where)
   ELSE IF curEvent.shiftKey THEN      { Shift clicked in name of different icon }
      ToggleObject(pointAt)
   ELSE                                { clicked in name of different icon }
      SelectObject(pointAt,TRUE);
   WHILE StillDown DO;                 { wait for button up. avoids Ibeam cursor }
   GOTO 2;
   END;

{ if pointed in empty space then drag out a rectangle for a group selection }
IF pointAt = nilObject THEN
   BEGIN
   IF NOT curEvent.shiftKey THEN
      ChangeContents(obj,hilited,normal,0,0,TRUE);  { de-select all }
   IF NOT srcIsList THEN
      BEGIN
      DragRect(obj,downPt,groupRect);
      SelectContents(obj,groupRect);
      END;
   GOTO 2;
   END;

{ ignore clicks on ghost icons }
IF pointAt^^.state IN [openState,placeHolder] THEN EXIT(HitContainer);

{ if double click then open an icon or tear off from pad }
IF clickCount = 2 THEN
   BEGIN
   EndEdit;
   TallyContents(obj,hilited,FALSE,partial,tallyCount,tallySet,tallyBBox,topObject);
   IF tallySet <= padSet THEN      { if pads only then create new objects }
      TearOffContents(obj,hilited)
   ELSE IF NOT copyMode THEN       { if only non-pads (& not dup's) then open }
      IF tallyset <= openSet THEN OpenContents(obj,hilited);
   GOTO 2;
   END;

{ if shift-click then toggle the selection state of the object pointed at }
IF curEvent.shiftKey THEN
   BEGIN
   EndEdit;
   ToggleObject(pointAt);
   GOTO 2;
   END;

{ none of the above, so just select the object pointed at if not already selected }
IF pointAt^^.state = normal THEN SelectObject(pointAt,FALSE);

1:

{ put in a little hysteresis to minimize flashing if just selecting }
REPEAT
   GetMouse(newPt);
   dh := ABS(newPt.h-downPt.h);
   dv := ABS(newPt.v-downPt.v);
   IF NOT StillDown THEN GOTO 2;
UNTIL (dh > 3) OR (dv > 2);


{ Moved a little. Prepare to move the selection }

{ scan the selection }
TallyContents(obj,hilited,FALSE,partial,tallyCount,tallySet,tallyBBox,topObject);

{ make bounding box of selection global and set up maxDeltas for dragging }
GetPort(savePort);
SetPort(curEvent.who);
LocalToGlobal(tallyBBox.topLeft);
LocalToGlobal(tallyBBox.botRight);
SetPort(savePort);

maxDh := screenWidth - tallyBBox.right;
maxDv := screenHt - tallyBBox.bottom;
minDh := 0 - tallyBBox.left;
minDv := menuHt - tallyBBox.top;

{ change the selection to ghosts }
ChangeContents(obj,hilited,limbo,0,0,TRUE);

{ drag the selection around, hilighting valid targets under it }
DragContents(obj,limbo,tallySet,tallyCount,downPt,pointAt,targetContainer,targetIcon,
             targetMatch,dh,dv,maxDh,maxDv,minDh,minDv);

{ Redraw xor images clipped to targetContainer, save xor location info }
xorSrcObj := obj;
xorDstObj := targetContainer;
xorDh := dh;
xorDv := dv;
xorWindow := targetContainer^^.objWindow;
ClipContent(targetContainer);
XorContents(obj,limbo,dh,dv,xorWindow);

dstIsList := (targetContainer^^.viewMode <> spatialView);
allMoved := FALSE;

{ try to move the icons }
IF targetIcon = nilObject THEN       { over empty space in a window }
   MoveToWindow
ELSE                                 { over another icon }
   MoveToIcon;

IF allMoved THEN
   copyMode := FALSE                 { terminate possible copyMode if all copied }
ELSE
   IF NOT joinflag THEN RefuseMove;  { return any that were not transferred }

IF abort THEN KillDuplicates(obj);

xorSrcObj := nilObject;
xorDstObj := nilObject;
xorObj    := nilObject;
xorWindow := NIL;


2:
   { ensure that the selection is visible }
IF NOT joinflag THEN
   AutoScroll(obj,hilited);
IF NOT splitflag THEN
   AutoScroll(targetContainer,hilited);

END;


{$S flrDraw }
PROCEDURE HitGrowIcon{* obj: ObjectHandle; ptDown: Point *};

{ change the size of the active window }

VAR window: WindowPtr;
    newBotRight: Point;
    width,height,minH,minV,maxH,maxV,newRight,newBottom: INTEGER;
    needUpdate: BOOLEAN;
    savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('HitGrowIcon',WriteName(obj));
IF curEvent.what <> buttonDown THEN EXIT(HitGrowIcon);

window := obj^^.objWindow;

GetPort(savePort);
SetPort(window);

ptDown.h := ptDown.h - window^.portRect.left;  { convert pt to zero origin }
ptDown.v := ptDown.v - window^.portRect.top;

{ drag XOR frame with scrollbars until mouse button is released }
ScrollEnvironment(obj);
DragFrame(ptDown,TRUE,newBotRight);
newRight := newBotRight.h;
newBottom := newBotRight.v;

WITH window^.portRect DO
   IF (newBottom <> bottom) OR (newRight <> right) THEN
      BEGIN
      width := MAX(dhSbox,newRight - left);
      height := MAX(dvSbox,newBottom - top);
      needUpdate := (newRight > right) OR (newBottom > bottom);
      KillScroll(window,needUpdate);     { erase and invalidate old scroll bars }
      FolderSize(window,width,height,needUpdate);
      NormalEnvironment(obj);
      ScrollLimits(obj,minH,minV,maxH,maxV);
      obj^^.hThumbPos := ThumbHpos(obj,minH,maxH);
      obj^^.vThumbPos := ThumbVpos(obj,minV,maxV);
      ShowScroll(obj);
      END;

NormalEnvironment(obj);
SetPort(savePort);
END;



{$S dmMain }
PROCEDURE HitMenuBar;
{ determines the menu selection and invokes the proper command }
VAR theMenu,theItem: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('HitMenuBar');
IF InCopyMode THEN IF copyMode THEN EXIT(HitMenuBar);
AdjustMenus;                                { enable/disable menus }
MenuSelect(curEvent.where,theMenu,theItem); { find which menu & item }
MenuCommand(theMenu,theItem);               { do the job }
HiLiteMenu(0);                              { un-highlight the menu title }
END;



{$S flrDm1 }
PROCEDURE HitOrphan{* obj: ObjectHandle *};

{ Handles button down events in orphans.  When a button down event is detected in
  an orphan (meaning restart this document) the orphan hit is saved in the global
  "orphanObject."  The deskObject is then made active before calling this routine
  to restart the orphan.  This is done so that the restarted application won't be
  handed an already active document (something it can't tolerate).

  An orphan is a document window that is temporarily being managed by the Desk.
  Some ways in which orphans come about are: a tool crashes, a diskette is removed
  which has code for a document whose data is still online, etc. }

VAR
   docHdl : TentryHdl;
   savePort: GrafPtr;
   thePassword: E_Name;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('HitOrphan',WriteName(obj));

   { Is this one of our orphans? }
docHdl := WindowToDocEntry(obj^^.objWindow);
IF docHdl = NIL THEN EXIT (HitOrphan);

GetPort(savePort);

IF NOT GetPassword(obj^^.volHdl,obj^^.catRID,docHdl^^.docPassword) THEN
   EXIT(HitOrphan);

StartDoc(docHdl,FALSE);

SetPort(savePort);
MakeObjActive(obj);  { activate it with the fast protocol }
END;



{$S flrDm1 }
PROCEDURE HitScrap;
{ handles button down in scrap }
BEGIN
IF curEvent.what <> buttonDown THEN EXIT(HitScrap);
StopAlert(flrAlert,117);   { can't edit scrap ... }
END;



{$S flrDraw }
PROCEDURE HitScrollBar{* obj: ObjectHandle; whichSb: THsb; whichIcon: TIcon *};
{ handles vertical and horizontal scrolling of containers }
VAR savePort: GrafPtr;
    newThumb: INTEGER;
    pt: Point;
    longThumb: LongInt;  { used to coerce long arithmetic (avoid overflow) }
    window: WindowPtr;
    contentRect: Rect;
    dh,dv,minH,minV,maxH,maxV,newLeft,newTop: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('HitScrollBar',WriteName(obj));
IF curEvent.what <> buttonDown THEN EXIT(HitScrollBar);

ScrollLimits(obj,minH,minV,maxH,maxV);  { determine scroll limits }
GetContentRect(obj,contentRect);
UpdateObject(obj,FALSE);  { ensure that window is updated before scrolling }

window := obj^^.objWindow;
GetPort(savePort);
SetPort(window);

dh := 0;
dv := 0;
pt.h := curEvent.where.h - window^.portRect.left;  { convert pt to zero origin }
pt.v := curEvent.where.v - window^.portRect.top;

ScrollEnvironment(obj);

CASE whichIcon OF

   iconThumb:
      BEGIN
      DragThumb(whichSb,pt,newThumb);
      NormalEnvironment(obj);

      IF trcFiler THEN WRITELN('   thumb to: ',newThumb:1);
      longThumb := newThumb;
      WITH contentRect DO
         IF whichSb = hsbH THEN
            BEGIN
            newLeft := MAX(minH,longThumb*(maxH-(right-left)) DIV maxThumb);
            dh := left - newLeft;
            obj^^.hThumbPos := newThumb;
            END
         ELSE
            BEGIN
            newTop := MAX(minV,longThumb*(maxV-(bottom-top)) DIV maxThumb);
            dv := top - newTop;
            obj^^.vThumbPos := newThumb;
            END;

      ScrollContents(obj,dh,dv,minH,minV,maxH,maxV,FALSE);
      END;

   iconArwA,iconArwB:
      BEGIN
      PaintArw(whichSb,whichIcon,TRUE);
      NormalEnvironment(obj);

      IF whichSb = hsbH THEN
         dh := hScrollInc
      ELSE
         dv := lineHt;

      IF whichIcon = iconArwB THEN
         BEGIN
         dh := -dh;
         dv := -dv;
         END;

      REPEAT
         ScrollContents(obj,dh,dv,minH,minV,maxH,maxV,TRUE)
      UNTIL NOT StillDown;

      ScrollEnvironment(obj);
      PaintArw(whichSb,whichIcon,FALSE);
      END;

   iconPagA,iconPagB:
      BEGIN
      PaintArw(whichSb,whichIcon,TRUE);
      NormalEnvironment(obj);

      WITH contentRect DO
         BEGIN
         IF whichSb = hsbH THEN
            BEGIN
            dh := right - left;
            IF dh > hScrollInc THEN dh := dh - hScrollInc;   { leave some context }
            END
         ELSE
            BEGIN
            dv := bottom - top;
            IF dv > lineHt THEN dv := dv - lineHt;     { leave context line }
            END;
         END;

      IF whichIcon = iconPagB THEN
         BEGIN
         dh := -dh;
         dv := -dv;
         END;

      REPEAT
         ScrollContents(obj,dh,dv,minH,minV,maxH,maxV,TRUE)
      UNTIL NOT StillDown;

      ScrollEnvironment(obj);
      PaintArw(whichSb,whichIcon,FALSE);
      END;
   END;

NormalEnvironment(obj);
SetPort(savePort);
END;



{$S dmMain }
PROCEDURE IdleTasks;
{ called when no events are available, keeps cursor, caret, text, etc.  updated }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF copyMode THEN BlinkContents(activeObject,hilited);
UpdateCursor;
UpdateText;     { draw chars, blink caret }
END;



{$S flrAll}
FUNCTION IgnoreDeactivate{* : BOOLEAN *};
{ Returns TRUE if the deactivate event just received should be ignored.  Currently
  deactivates are refused only if in copy mode. }

VAR volHdl: TentryHdl;
    nextEvent: EventRecord;
    foundDiskEvent: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IgnoreDeactivate := copyMode;
IF NOT copyMode THEN EXIT(IgnoreDeactivate);

FlushTypeAhead(TRUE);    { flush typeahead & re-establish keyWindow, keyProcess }

  { For certain disk events, ignore the deactivate and allow the following disk
    event to pass through }

foundDiskEvent := FALSE;

IF PeekEvent(nextEvent) THEN
   IF nextEvent.what = diskEvent THEN
      BEGIN
      foundDiskEvent := TRUE;
      CASE nextEvent.keyCap OF
         microInCode,
         disk1InCode,
         disk2InCode,
         mouseCode:                  { Can ignore it for these }
            EXIT(IgnoreDeactivate);
         microOutCode,
         disk1OutCode,
         disk2OutCode:               { OK to eject disk not involved in copy }
            BEGIN
            IF nextEvent.keyCap = disk1OutCode THEN
               volHdl := uTwigHdl^^.volHdl
            ELSE
               volHdl := lTwigHdl^^.volHdl;
            IF NOT VolInContents(activeObject,hilited,volHdl) THEN EXIT(IgnoreDeactivate);
            END;
         END;

      GetEvent(nextEvent);   { pull out the disk event }
      END;

   { Give the user the choice of canceling or continuing the duplicate mode }

IF InCopyMode THEN;

   { If user said to cancel copy mode, allow operation to continue }

IF NOT copyMode THEN
   BEGIN
   MakeFldrActive(curEvent.fromFolder,curEvent.why);   { re-queue deactivate }
   IF foundDiskEvent THEN
      SendEvent(nextEvent,filerProcess);               { re-queue disk event }
   END;
END;



{$S dmMain }
FUNCTION InCopyMode{* : BOOLEAN *};
{ Checks if in "copy" mode (blinking duplicates).  If so then returns TRUE, asks
  user if s/he wants to abort or continue. }
VAR saveEvent: EventRecord;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
InCopyMode := copyMode;
IF copyMode THEN
   IF AskAlert(flrAlert,130) = 1 THEN KillDuplicates(activeObject);
END;



{$S flrAll  }
FUNCTION InGrowIcon{* obj: ObjectHandle; pt: Point): BOOLEAN *};
{ Returns TRUE if pt is in the grow icon of obj }
VAR window: WindowPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InGrowIcon');
InGrowIcon := FALSE;
IF obj = deskObject THEN EXIT(InGrowIcon);

window := obj^^.objWindow;
IF window = NIL THEN EXIT(InGrowIcon);

SetPort(window);
pt.h := pt.h - window^.portRect.left;  { convert pt to zero origin }
pt.v := pt.v - window^.portRect.top;
SetOrigin(0,0);
InGrowIcon := FGrowHit(pt);
SetOrigin(obj^^.scrollDh,obj^^.scrollDv);
END;



{$S  }
PROCEDURE InitFldStuff;
VAR modifier: TModifier;
    r: Rect;
    fntInfo: FontInfo;
    wordSelStuff: Tstr;
    timeFmt,dateFmt: TTimeStr;
    err: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InitFldStuff');
GetString(707,@wordSelStuff);
FEInit(theHeap,@wordSelStuff,err);
IF ErrorFound(fatalError,1034,err,NIL) THEN;

{ create field to be used by drawing procedure "ShowFldAt" & "ShowFld" }
SetRect(r,0,0,0,0);
hShowFld := CreateField(r,fMaxStrLen,0,center,2{pad},1{runs},0,iconNamFont,FALSE);         { protected field }
DisposeHandle(Pointer(ORD(hShowFld^^.curValue)));  { Not needed. Will pt to data }

{ create field to be used for editing }
hCurFld := CreateField(r,fMaxStrLen,0,center,2{pad},1{runs},0,iconNamFont,FALSE);         { protected field }
hCurFstate := Pointer(ORD(NewHdl(SizeOf(hCurFstate^^))));
IF hCurFstate = NIL THEN CantInit(9,nullErr);

TextFont(iconNamFont);
GetFontInfo(iconFntInfo);  { fetch font size information }
IF trcFiler THEN
   WITH iconFntInfo DO
      WRITELN('  icon font ascent: ',ascent:1,'  descent: ',descent:1);

TextFont(sysText);
dateWidth := StringWidth(' 99/99/99');
timeWidth := StringWidth('99:99 am');

GetAlert(flrAlert,10,@timeFmt);
GetAlert(flrAlert,11,@dateFmt);
InitTime(timeFmt,dateFmt);

GetFontInfo(fntInfo);
WITH fntInfo DO
  BEGIN
  lineHt := MAX(ascent+descent+leading,15);
  lineHt := ((lineHt+3) DIV 4)*4;        { must be multiple of 4 }
  botToBaseLn := descent + ((lineHt - (ascent+descent) + 1) DIV 2);
  END;

SetTimeout(noTimeout);      { no timeouts for now }
END;



{$S  }
PROCEDURE InitFlrHeap;

{ Initialize the heap for Desk objects, quick draw temporaries, menus }

CONST dsSize = $5000;   { 20K bytes for now }

VAR err:                INTEGER;
    openErrNum:         INTEGER;
    dsAddr:             LongInt;
    dsName:             PathName;
    dsInfo:             DsInfoRec;
    newMemSize:         LongInt;
    newDiskSize:        LongInt;
    lfntid:             TlFntId;
    pCharStyle:         TpCharStyle;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InitFlrHeap');
dsName := fnameHeap;
Open_DataSeg(openErrNum,dsName,flrHeapRefnum,dsAddr,flrHeapLDSN);

IF openErrNum <= 0 THEN
   BEGIN                 { Dataseg already exists.  Set access and size }
   SetAccess_DataSeg(err,flrHeapRefnum,FALSE);    { allow write access }
   Info_DataSeg(err,flrHeapRefnum,dsInfo);        { how big is it? }
   Size_Dataseg(err,flrHeapRefnum,                { set it to its initial size }
                dsSize - dsInfo.mem_Size, newMemSize,
                dsSize - dsInfo.disc_size, newDiskSize);
   IF err <> 0 THEN
      BEGIN
      IF dbgFIler THEN
         WRITELN('InitFlrHeap failed on Size_Dataseg.  err = ',err:1);
      CantInit(4,err);
      END;
   END
ELSE
   BEGIN                 { Dataseg not there or bad.  Create a new one }
   Kill_DataSeg(err,dsName);
   Make_DataSeg(err,dsName,dsSize,dsSize,flrHeapRefnum,dsAddr,flrHeapLDSN,
                ds_shared);   { shared to guarantee space }
   IF err <> 0 THEN
      BEGIN
      IF dbgFiler THEN
         WRITELN('InitFlrHeap failed on Make_DataSeg. err = ',err);
      CantInit(5,err);
      END
   END;


InitHeap(Pointer(dsAddr),Pointer(dsAddr+dsSize),@GrowHeap);


{ the following is a hack to get at the font manager's heap zone for debugging }

{$IFC flrDebug }
WITH lfntId DO
   BEGIN
   fam := sysText;
   seteface := [];
   dev := devScreen;
   END;
pCharStyle := FMSwapFont(lfntId,err);   { swap in system font }
fmHeap := HzFromH(pCharStyle^.hks);     { determine the heap from the handle }
{$ENDC }

END;



PROCEDURE InitGridTable;
{ initializes the table used for desktop compaction algorithm }
VAR movingLeft: BOOLEAN;
    row,col,n,numSweeps,maxGridSpots: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
movingLeft := TRUE;
n := 0;
numSweeps := 1;
row := nDeskRows-1;
col := nDeskCols-1;
maxGridSpots := nDeskRows*nDeskCols;

WHILE n < maxGridSpots DO
   BEGIN
   gridTable[row,col] := n;
   IF movingLeft THEN   { move along bottom, left to right }
      BEGIN
      col := col - 1;
      IF col < 0 THEN
         BEGIN
         movingLeft := FALSE;
         col := nDeskCols - numSweeps;
         row := row - 1;
         END
      END
   ELSE                 { move along right, bottom to top }
      BEGIN
      row := row - 1;
      IF row < 0 THEN
         BEGIN
         movingLeft := TRUE;
         numSweeps := numSweeps + 1;
         row := nDeskRows - numSweeps;
         col := col - 1;
         END;
      END;
   n := n + 1;
   END;

END;



{$S  }
PROCEDURE Initialize;

VAR answer:    STRING[5];
    copyRight: String[60];
    devName:   E_Name;
    diskObj:   ObjectHandle;
    err:       INTEGER;
    excepName: T_Ex_Name;
    myInfo:    ProcInfoRec;
    numStr:    NumberStr;
    path:      Pathname;
    theTime:   Time_Rec;
    volInfo:   Fs_Info;

   PROCEDURE InitLibraries;
   VAR logo,copyRight,apple: STRING[1];
       alertNum,
       pmInitErr: INTEGER;
       fontID:    TlFntID;
       i:         INTEGER;
       menuString:FMaxStr;
       pt:        Point;
       strPtr:   ^Str255;
       menuSize:  TC;
   BEGIN
   { Initialize parameter memory manager }
   PMInit(pmInitErr);                          { once-only call by shell }

   InitGraf(@thePort);                     { each process must init this }
   InitCursor;

   InitWM;                                     { once-only call by shell }

   WITH fontID DO BEGIN
     seteFace := [];
     dev      := devScreen;
     fam      := fIconFont;
     END;
   FMLockFont (fontID,TRUE,err);

   InitMenus;                                  { once-only call by shell }

   InitWmlCrs(err);                            { each process calls this }
   IF dbgFiler THEN IF err > 0 THEN WRITELN('InitWmlCrs err = ',err:1);

   InitFlrHeap;                                { each process must init 'theHeap' }
   {$IFC flrDebug }
   fakeNoHeap := FALSE;
   theHeap^.fCheck := FALSE;
   theHeap^.fScramble := FALSE;
   wmHeap^.fCheck := FALSE;
   wmHeap^.fScramble := FALSE;
   fmHeap^.fCheck := FALSE;
   fmHeap^.fScramble := FALSE;
   skipFlushing := TRUE;
   {$ENDC }

   InitObjects;                                { initialize object tree }

   {$IFC flrJrnl }
      InitJournal;                             { See if journal wanted }
   {$ENDC }

   InitMP(theHeap,fnameAlerts,@FailedAlert,2,@flrMenus[firstFlrMenu],flrAlert,err);
   IF err > 0 THEN
      BEGIN
      IF dbgFiler THEN WRITELN('InitAlerts error = ',err);
      CantInit(6,err);
      END;

   { copy base desktop menu to globally accessable desktopMenu in the window manager }
(* strPtr := POINTER(ORD(flrMenus[xDesktop].menuData^));  { insert the desktop menu icon }
   IF strPtr^[1] = '^' THEN strPtr^[1] := CHR(14); *)     { substitute apple for europe }
   menuSize := CbDataOfH(theHeap,flrMenus[xDesktop].menuData);
   desktopMenu[1].menuData := HAllocate(wmHeap,menuSize);
   MoveLeft(flrMenus[xDesktop].menuData^^,desktopMenu[1].menuData^^,menuSize);
   DisposeHandle (flrMenus[xDesktop].menuData);  { don't need it any more }
   CalcMenuSize (desktopMenu[1]);  { kludge to force title width into menus.menuLeft[0] }

   { make local copies of changing menu strings from xtra menu }
   FOR i := 1 TO xLast DO
      BEGIN
      GetItem(flrMenus[xtraMenu],i,@menuString);
      XtraStrgs[i] := NewStrg(menuString);
      END;

   {$IFC flrDebug }
   CheckItem(flrMenus[specialMenu],mTrcEvents,eventDebug);
   CheckItem(flrMenus[specialMenu],mTrcFEntry,trcFEntry);
   CheckItem(flrMenus[specialMenu],mTrcCatalog,trcCatalog);
   CheckItem(flrMenus[specialMenu],mTrcFDocCtrl,trcFDocCtrl);
   CheckItem(flrMenus[specialMenu],mTrcFVolCtrl,trcFVolCtrl);
   CheckItem(flrMenus[specialMenu],mTrcFiler,trcFiler);
   CheckItem(flrMenus[specialMenu],mTrcDialog,trcDialog);
   CheckItem(flrMenus[specialMenu],mTrcAttribute,trcAttribute);
   CheckItem(flrMenus[stressMenu],mFlushing,NOT skipFlushing);
   CheckItem(flrMenus[stressMenu],mTestIOerr,testIOerr);
   CheckItem(flrMenus[stressMenu],mFakeNoHeap,fakeNoHeap);
   CheckItem(flrMenus[stressMenu],mFlushing,NOT skipFlushing);
   CheckItem(flrMenus[stressMenu],mCheckHeap,theHeap^.fCheck);
   CheckItem(flrMenus[stressMenu],mCheckWmHeap,wmHeap^.fCheck);
   CheckItem(flrMenus[stressMenu],mCheckFmHeap,fmHeap^.fCheck);
   CheckItem(flrMenus[stressMenu],mMixHeap,theHeap^.fScramble);
   CheckItem(flrMenus[stressMenu],mMixWmHeap,wmHeap^.fScramble);
   CheckItem(flrMenus[stressMenu],mMixFmHeap,fmHeap^.fScramble);
   CheckItem(flrMenus[stressMenu],mTraceCalls, trcCalls);
   {$ENDC }

   SetScreenKeybd(priScrn);          { Switch to graphics screen }

   { Check boot disk to see if crashed last time up }
   Lookup(err,path,volInfo);         { path set for Set_Working_Dir }
   IF NOT ErrorFound(warnError,1036,err,NIL) THEN
      IF volInfo.vol_left_mounted THEN  { must have crashed last time up }
         BEGIN
         volInfo.vol_left_mounted := FALSE;
         PSet_Vol_Info(err,path,volInfo);
         IF AskAlert(flrAlert,104) = 2 THEN EXIT(Desk);   { power off }
         END;

   { warn user if problem with parameter memory }
   IF pmInitErr < 0 THEN  { only negative errors (warnings) are returned }
      BEGIN
      CASE pmInitErr OF
         -620: alertNum := 124;       { memory good, disk bad }
         -621: alertNum := 125;       { memory bad, disk good }
         OTHERWISE alertNum := 126;   { both bad }
         END;
      NoteAlert(flrAlert,alertNum);
      END;

   { tell user to wait for startup }
   logo          := ' ';
   copyright     := ' ';
   apple         := ' ';
   logo[1]       := CHR(15);
   copyright[1]  := CHR(ccCopy);
   apple[1]      := CHR(14);
   ArgAlert(1,logo);
   ArgAlert(2,version);
   ArgAlert(3,copyright);
   ArgAlert(4,apple);
   WaitAlert(flrAlert,210);

   { Initialize the printing package }
   PrGlobalInit;                                 { once-only call by shell }


   InitFldStuff;                   { Initialize field editor & related structures }

   InitScrap(err);                              { once-only call by shell }
   IF ErrorFound(askError,1016,err,NIL) THEN;

   InitWmlSb;   { Init scrollbar routines }     { each process calls this }
   InitSbList(sbList,theHeap);   { create the scrollbar list descriptor }
   hSbV := SbCreate(sbList,hsbNil,tyvhV,pt,0);  { allocate scroll bar structures }
   hSbH := SbCreate(sbList,hsbNil,tyvhH,pt,0);
   maxThumb := 1000;
   scrollRgn := NewRgn;

   { Init the print mgr dialog routines }
   PrMgrInit;                                           { each process calls this }

   InitInternational(err);  { Always returns 0, why have it? }

   InitFC;

   END;


BEGIN
copyRight := 'Copyright 1983, 1984, Apple Computer Inc.';  { force copyright into code }
Sched_Class(err, TRUE{non-preemptive});              { all apps must do this first }

   { Set up debugging/NMI }

IF EnableDbg(TRUE) THEN;            { If the user has LisaBug, he should know what to do }
SetNMIKey(theNMIKey);               { For in-house Lisa 1 machines }

   { Direct WRITELN's to the alternate screen }

BlockIOinit;    { Once only call by shell  }
MoveConsole(err,alScreen);


   { Initialize debug flags }

{$IFC flrDebug }

   {$IFC FLDDEBUG }
   SetFldTest(debugStartup);
   {$ENDC }

   {$IFC fDbgOK }
   fTstStd       := FALSE;
   fTstHz        := FALSE;
   {$ENDC }

   eventDebug    := debugStartup;   { W/M tracing flag }
   trcFEntry     := debugStartup;
   trcCatalog    := debugStartup;
   trcFDocCtrl   := debugStartup;
   trcFVolCtrl   := debugStartup;
   trcFiler      := debugStartup;
   trcDialog     := debugStartup;
   trcAttribute  := debugStartup;
   testIOerr     := FALSE;
   fakeNoHeap    := FALSE;
   skipFlushing  := FALSE;
   trcCalls      := debugStartup;

   AInitTrCalls;

{$ENDC}

   { Check that the Desk is executing from the boot volume }

OsBootVol (err, devName);
Info_Process (err, My_ID, myInfo);
IF POS(devName, myInfo.progPathname) <> 2 THEN CantInit(1,nullErr);

   { insure the working directory points at the boot volume }

path := CONCAT('-', devName);
Set_Working_Dir (err, path);

   { setup globals that terminate exception handler uses }

startingUp := TRUE;   { initializing.  Don't do auto restart if TRUE }
firstVol   := NIL;    { no volumes mounted yet }
appleOff   := FALSE;  { apple key not held down }


   { Set up the terminate exception handler }

excepName := 'SYS_TERMINATE';
Declare_Excep_Hdl(err, excepName,@LastWishes);
IF err <> 0 THEN
   BEGIN
   IF dbgFiler THEN WRITELN (' Declar_Excep_Hdl error: ',err);
   CantInit(2,err);
   END;

InitLibraries;                    { intialize the intrinsic libraries }

   { Initialize global variables }

SetPort(filerFolder);
takingPicture := FALSE;
diBox.active  := FALSE;                 { no dialog box to start with }
copyMode      := FALSE;
menuForScrap  := FALSE;
specialUp     := FALSE;
printProcess  := prNILProcess;
clickCount    := 0;
clickTime     := 0;
toolList      := NIL;

diskSet    := [diskKind,disk1Kind,disk2Kind,profileKind,drawerKind,priamKind];
containerSet:=[diskKind,disk1Kind,disk2Kind,profileKind,drawerKind,priamKind,  {all of diskSet}
               folderKind,folderPad,trashKind,trayKind,
               letterKind,letterPad,inBox1Kind,inBox2Kind,outBox1Kind,outBox2Kind];
putBackSet := [docKind,folderKind,docPad,folderPad,
               toolKind,calcKind,clockKind,letterKind,letterPad];
dupSet     := putBackSet;
padSet     := [docPad,folderPad,letterPad];
docToolSet := [docKind,toolKind,calcKind,clockKind,computerKind,comp2Kind,printKind];
allKindsSet:= [nilKind..lastKind];
openSet    := allKindsSet - padSet;
allStates  := [openState,normal,hilited,limbo];

{ clear my update region, so that WM doesn't send update at startup }
ValidWindow(filerFolder,TRUE);

InitMatchTable;
InitGridTable;
InitFentry(err);
IF err <> 0 THEN IF ErrorFound(fatalError,1041,nullErr,NIL) THEN;
InitCat(err);
IF ErrorFound(fatalError,1007,err,NIL) THEN;
InitDocCtrl;
InitVolCtrl;                      { open the object catalog on the boot volume }

{ Start the background printing process }
MakePrintProcess(err);
IF err > 0 THEN
   BEGIN
   IntToStr(err,numStr);
   ArgAlert(1,numStr);
   StopAlert(flrAlert, 148);
   END;

{ restore the desktop of the boot volume }
EndWaitAlert;                     { remove wait alert before restoring desktop }
IF NOT RestoreDesktop(bootVol,TRUE{newDisk},diskObj) THEN CantInit(3,nullErr);
IF MountAll(TRUE) THEN;           { attempt to mount other volumes }

UpdateAll;                        { repaint under alert box now }
InstallMenus;                     { created active, so put up my menus }
SetStdCursor(icrsInactive);       { make sure the cursor is displayed }
MakeTopActive;                    { activate topmost window }

{ Check to make sure the clock is set }
Get_Time(err,theTime);
IF (err > 0) OR ((err <= 0) AND (theTime.year < 1984)) THEN
   NoteAlert(flrAlert,145);       { the clock is not set ... }

startingUp := FALSE;              { finished initializing }
END;


{$IFC flrJrnl }
{$S  }
PROCEDURE InitJournal;
{ Sets journal action according to text file }
CONST modeValues =  'Enter journal mode (0-3).';
      modeDesc =
           '0 = slow/exact, 1 = fast/exact,  2 = slow/inexact, 3 = fast/inexact. ';
VAR f: TEXT;
    playName,recordName: PathName;
    playMode,recordMode: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InitJournal');
RESET(f,fnameJrnlFiles);
IF IOResult = 0 THEN
   BEGIN
   READLN(f,playName);
   IF playName <> '' THEN READLN(f,playMode);
   READLN(f,recordName);
   IF recordName <> '' THEN READLN(f,recordMode);
   END
ELSE
   BEGIN
   WRITE('Enter PLAYBACK journal name (return for none). ');
   READLN(playName);
   IF playName <> '' THEN
      BEGIN
      WRITELN(modeValues);
      WRITE(modeDesc);
      READLN(playMode);
      END;
   WRITE('Enter RECORD journal name (return for none). ');
   READLN(recordName);
   IF recordName <> '' THEN
      BEGIN
      WRITELN(modeValues);
      WRITE(modeDesc);
      READLN(recordMode);
      END;
   END;

IF playName <> '' THEN StartPlayback(playName,playMode);
IF recordName <> '' THEN StartRecord(recordName,recordMode);
END;
{$ENDC }


{$S  }
PROCEDURE InitMatchTable;
{ which kinds of source are legal for each kind of destination }
VAR i: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InitMatchTable');
FOR i := nilKind TO lastKind DO matchTable[i] := [];

matchTable[folderkind]  := putBackSet;
matchTable[trashKind]   := putBackSet;
matchTable[trayKind]    := putBackSet;
matchTable[letterKind]  := putBackSet;
matchTable[trayKind]    := putBackSet;
matchTable[outBox1Kind] := [letterKind];
matchTable[outBox2Kind] := [letterKind];

matchTable[diskKind]    := putBackSet + diskSet;
matchTable[disk1Kind]   := putBackSet + diskSet;
matchTable[disk2Kind]   := putBackSet + diskSet;
matchTable[profileKind] := putBackSet + diskSet;
matchTable[priamKind]   := putBackSet + diskSet;
matchTable[drawerKind]  := putBackSet + diskSet;
matchTable[deskKind]    := [fileKind..lastKind];
END;



{$S  }
PROCEDURE InitObjects;
{ initializes object tree.  Creates the initial objects }
VAR diskObj: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InitObjects');

{ create the "nil" object.  Lists are terminated by pointing to this object }
nilObject := Pointer(ORD(NewHdl(SizeOf(ObjectRecord))));
IF nilObject = NIL THEN CantInit(10,nullErr);

WITH nilObject^^ DO
   BEGIN
   nameHdl    := Nil;
   prev       := nilObject;
   next       := nilObject;
   loc.h      := 0;
   loc.v      := 0;
   kind       := nilKind;
   toolNumber := deskTool;
   volHdl     := NIL;
   state      := nilState;
   isOpen     := FALSE;
   dirty      := FALSE;
   wasOpened  := FALSE;
   toBeCopied := FALSE;
   visible    := FALSE;
   updateLabel:= FALSE;
   container  := nilObject;
   contents   := nilObject;
   objWindow  := NIL;
   scrollDh   := 0;
   scrollDv   := 0;
   hThumbPos  := 0;
   vThumbPos  := 0;
   listSeqNum := 0;
   created    := 0;
   modified   := 0;
   size       := 0;
   viewMode   := spatialView;
   SetRect(nameRect,0,0,0,0);
   END;

{ Create the "Desk" object.  This is the root of the object tree, father of all }
deskObject := Pointer(ORD(NewHdl(SizeOf(ObjectRecord))));
IF deskObject = NIL THEN CantInit(11,nullErr);
deskObject^^ := nilObject^^;
WITH deskObject^^ DO
   BEGIN
   nameHdl    := NIL;
   kind       := deskKind;
   isOpen     := TRUE;
   objWindow  := filerFolder;
   END;

editObject   := nilObject;    { nothing being edited }
edit2Object  := nilObject;
orphanObject := nilObject;
activeObject := deskObject;   { Desk is initially active }

xorSrcObject := nilObject;
xorDstObject := nilObject;
xorObj       := nilObject;
xorWindow    := NIL;
END;



{$S flrAll }
FUNCTION InScrollBar{* obj: ObjectHandle; pt: Point; VAR whichSb: THsb;
                                                   VAR whichIcon: TIcon): BOOLEAN *};
{ Returns TRUE if pt is in the scrollbar of obj.  Returns scrollbar & icon hit }
VAR window: WindowPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
InScrollBar := FALSE;
IF obj = deskObject THEN EXIT(InScrollBar);

window := obj^^.objWindow;
IF window = NIL THEN EXIT(InScrollBar);

SetPort(window);
pt.h := pt.h - window^.portRect.left;  { convert pt to zero origin }
pt.v := pt.v - window^.portRect.top;
SetOrigin(0,0);      { scroll bars are at fixed origin }
InScrollBar := FSbHit(sbList,pt,whichSb,whichIcon);
SetOrigin(obj^^.scrollDh,obj^^.scrollDv);
END;



{$S flrAll }
FUNCTION InListView{* obj: ObjectHandle): BOOLEAN *};
{ Returns TRUE if "obj's" container is in the spatial view mode }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
InListView := NOT InSpatialView(obj);
END;



{$S dmMain }
FUNCTION InSpatialView{* obj: ObjectHandle): BOOLEAN *};
{ Returns TRUE if "obj's" container is in the spatial view mode }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
InSpatialView := obj^^.container^^.viewMode = spatialView;
END;



{$S flrAll }
PROCEDURE InstallMenus;
{ Puts the appropriate menus into the menu bar & draws it }
VAR i: INTEGER;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InstallMenus');
ClearMenuBar;

IF activeObject = scrapObject THEN
   BEGIN
   InsertMenu(flrMenus[scrapMenu],0);   { single menu for the scrap }
   menuForScrap := TRUE;
   END
ELSE
   BEGIN
   FOR i := firstFlrMenu to housekeepingMenu DO InsertMenu(flrMenus[i],0);
   menuForScrap := FALSE;
   END;

IF specialUp THEN
   BEGIN
   InsertMenu(flrMenus[specialMenu],0);  { debug menu wanted? }
   InsertMenu(flrMenus[stressMenu],0);
   END;
DrawMenuBar;
END;



{$S flrDm1 }
PROCEDURE InvertContents{* obj: ObjectHandle; whichState; ObjectState *};
{ Invert contents of obj matching "whichState" }
VAR son,listHead: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InvertContents',WriteName(obj));
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state = whichState THEN InvertObject(son);
   son := son^^.next;
   END;
END;



{$S flrDraw }
PROCEDURE InvertObject{* obj: ObjectHandle *};
VAR savePort : GrafPtr;
    shapeFont,faceFont: INTEGER;
    mask,data,overlay: CHAR;
    iconRect: Rect;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('InvertObject',WriteName(obj));
GetPort(savePort);
SetPort(obj^^.container^^.objWindow);
IF InSpatialView(obj) THEN
   BEGIN
   ClipContent(obj^^.container);
   GetIcons(obj,shapeFont,mask,data,faceFont,overlay,iconRect);
   TextFont(shapeFont);
   TextMode(srcXor);
   MoveTo(obj^^.loc.h,obj^^.loc.v);
   DrawChar(mask);
   END
ELSE
   DrawTinyObject(obj,TRUE);
SetPort(savePort);
END;



{$S dmMain }
FUNCTION IsContainer{* obj: ObjectHandle): BOOLEAN *};
{ Returns TRUE if obj will accept any other objects }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('IsContainer',WriteName(obj));
IsContainer := (matchTable[obj^^.kind] <> []);
END;



{$S flrAll }
FUNCTION IsFather{* obj,aContainer: ObjectHandle): BOOLEAN *};
{ Returns TRUE if "aContainer" is the filing home of "obj" }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('IsFather');
IF aContainer = deskObject THEN
   IsFather := NOT (obj^^.kind IN putBackSet)
ELSE
   IsFather := ((obj^^.volHdl = aContainer^^.volHdl) OR
                (aContainer = trashObject)) AND
               (obj^^.catRID.fatherId = aContainer^^.catRID.uniqueId);
END;



{$S flrMisc }
FUNCTION IsIn(whichVol: TentryHdl; obj,theContainer: ObjectHandle): BOOLEAN;
{ returns TRUE if "obj" is a descendant of "aContainer" }
VAR recID,fatherRecID: TcatRID;
    fatherObj: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('IsIn',WriteName(obj),' ',WriteName(theContainer));
IsIn := FALSE;
IF obj^^.volHdl <> theContainer^^.volHdl THEN EXIT(IsIn);

recID := obj^^.catRID;

WHILE (recID.fatherID <> idNil)  DO
   BEGIN
   IF recID.fatherID = theContainer^^.catRID.uniqueID THEN
      BEGIN
      IsIn := TRUE;
      EXIT(IsIn);
      END;
   ClimbTree(whichVol,recID,fatherRecID,fatherObj);
   recID := fatherRecID;
   END;
END;



{$S flrDm1 }
FUNCTION IsOrphan{* obj: ObjectHandle): BOOLEAN *};
{ Returns TRUE if this is an app window currently managed by the Desk }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IsOrphan := FALSE;
IF obj^^.wasOpened THEN
   IF obj^^.kind IN docToolSet THEN
      IF MyWindow(obj^^.objWindow) THEN IsOrphan := TRUE;
END;



{$S flrDm1 }
PROCEDURE KillContents{* obj: ObjectHandle; sonsAlso,erase: BOOLEAN *};
{ Kills all descendants of obj.  Frees storage }
VAR son,nextSon,listHead: ObjectHandle;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('KillContents',WriteName(obj));
IF obj^^.state = placeHolder THEN EXIT(KillContents);
listHead := obj^^.contents;
IF listhead = nilObject THEN EXIT(KillContents);

son := listHead^^.next;
WHILE son <> listHead DO   { kill all brothers }
   BEGIN
   IF sonsAlso THEN KillContents(son,TRUE,erase);     { kill any sons first}
   nextSon := son^^.next;
   KillObject(son,sonsAlso,erase);
   son := nextSon;
   END;

KillStrg(listHead^^.nameHdl);
DisposeHandle(POINTER(ORD(listHead)));

obj^^.contents := nilObject;
END;



{$S flrAll }
PROCEDURE KillDuplicates{* container: ObjectHandle *};
{ aborts duplicate mode by removing, blinking duplicates }
VAR son,nextSon,listHead: ObjectHandle;
    killedSome,isSpatial: BOOLEAN;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('KillDuplicates',WriteName(container));
IF NOT copyMode THEN EXIT(KillDuplicates);

killedSome := FALSE;
isSpatial := (container^^.viewMode = spatialView);
listHead := container^^.contents;
son := listHead^^.next;

WHILE son <> listHead DO
   BEGIN
   nextSon := son^^.next;
   IF son^^.toBeCopied THEN
      BEGIN
      KillObject(son,TRUE,isSpatial {erase});
      killedSome := TRUE;
      END;
   son := nextSon;
   END;

IF killedSome AND NOT isSpatial THEN DrawContents(container);

copyMode := FALSE;
END;



{$S flrDm1 }
PROCEDURE KillObject{* obj: ObjectHandle; sonsAlso,erase: BOOLEAN *};
{ Frees storage.  Records info in catalog if appropriate }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('KillObject',WriteName(obj));
IF obj = nilObject THEN EXIT(KillObject);

IF sonsAlso THEN KillContents(obj,TRUE,erase);  { take care of sons }
IF obj = editObject THEN EndEdit;               { terminate editing }
IF CloseObject(obj,FALSE,TRUE,FALSE) THEN;      { close it }
IF obj^^.state <> placeholder THEN
   BEGIN
   FlushObject(obj);                               { update catalog if necessary }
   WriteLabel(obj);
   END;
IF erase THEN EraseObject(obj);                 { erase from screen }

{ remove from list }
WITH obj^^ DO
   BEGIN
   prev^^.next := next;
   next^^.prev := prev;

   IF (kind IN diskSet) THEN
      IF (volHdl <> NIL) AND (NOT toBeCopied) THEN
         volHdl^^.devHdl^^.objHdl := ORD(NIL);  { invalidate hdl to this object }
   END;

IF obj = activeObject THEN activeObject := nilObject;

KillStrg(obj^^.nameHdl);

{ set up trap for dangling handles to this object }
WITH obj^^ DO
   BEGIN
   nameHdl := NIL;
   next := NIL;
   prev := NIL;
   container := NIL;
   contents := NIL;
   objWindow := NIL;
   END;

DisposeHandle(POINTER(ORD(obj)));
END;



{$S flrDraw }
PROCEDURE KillScroll{* window : WindowPtr; needUpdate: BOOLEAN *};
{ open up clipping, erase and invalidate both scroll bars. }
VAR hRect,vRect,growRect: Rect;
    savePort: GrafPtr;
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('KillScroll');
IF (window = filerFolder) THEN EXIT(KillScroll);

GetPort(savePort);
SetPort(window);
ClipRect(window^.portRect);
FlushRects(hRect,vRect);
GetGrowRect(growRect);
UnionRect(growRect,vRect,vRect);
EraseRect(vRect);
EraseRect(hRect);
IF needUpdate THEN ValidScrollBars(window,FALSE);

SetPort(savePort);
END;



{$S flrNever }
PROCEDURE LastWishes{* environPtr : P_env_blk; excepDataPtr : P_term_ex_data *};

   { The Sys_Terminate exception handler.  Gets called when the program terminates
     normally (i.e., last statement executed) or abnormally (e.g., bus error).

     In the event of an abnormal termination the Desk attempts to save its most
     critical data structure - the object catalog.

     When the Desk terminates (by exiting this procedure) the O/S will signal
     the terminate exception to all the sons (applications) of the Desk.  Each
     son will then enter it's terminate exception handler and try to save its
     state.

     NOTE: If an exception occurs within the exception handler, the process is
           terminated by the O/S without reentering the handler.  Therefore cleanup
           is done in priority order.

   }

VAR err: INTEGER;
    crashed: BOOLEAN;
    volHdl,
    nextHdl: TentryHdl;
    deathReason: INTEGER;
    msgToFather: S_EventBlk;
    strg1,strg2,strg3: NumberStr;
    bigStrg: FMaxStr;
    crashPC: LONGINT;
    diskObj: ObjectHandle;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('LastWishes');

deathReason := excepDataPtr^.excep_kind;
crashed := deathReason <> ended;


   { close the object catalog on all volumes }

volHdl := firstVol;
WHILE volHdl <> NIL DO
   BEGIN
   nextHdl := volHdl^^.nextHdl; { save nextHdl since CloseCat deallocates volHdl }
   IF volHdl^^.saveRefnum <> noFile { state not saved } THEN
      BEGIN
      diskObj := Pointer(volHdl^^.devHdl^^.objHdl);
      IF diskObj <> NIL THEN SaveDesktop(diskObj);
      END;
   CloseCat(err,volHdl);
   volHdl := nextHdl;
   END;


   { form crash message to user }

IF crashed AND (deathReason <> call_term {Halt}) THEN
   BEGIN
   IntToStr(1033,strg1);
   IntToStr(deathReason,strg2);
   bigStrg := CONCAT('/',strg2);

   WITH excepDataPtr^ DO
      CASE deathReason OF
         bus_error,addr_error:
            crashPC := pc_error;
         def_range,def_str_index:
            crashPC := return_pc;
         OTHERWISE
            crashPC := 0;
         END;

   IF crashPC <> 0 THEN
      BEGIN
      IntToStr(crashPC,strg3);
      bigStrg := CONCAT(bigStrg,'/',strg3);
      END;

   ParamAlert(strg1,bigStrg,'');
   StopAlert(flrAlert, 200);
   WaitAlert(flrAlert, 207);
   END;

   { Shut down intrinsic stuff }

(*        *** remove comment brackets for rel 19.0 ***
Close_Object(err,cRefnumLib);               { font.lib }
Close_Object(err,scrap1Figures_Refnum);     { scrap1.figures }
Close_Object(err,scrap2Figures_Refnum);     { scrap2.figures }
Close_Object(err,scrap1Lotus_Refnum);       { scrap1.lotus }
Close_Object(err,scrap2Lotus_Refnum);       { scrap2.lotus }
*)
HideCursor;
BlockIOdisInit;   { PasLib call for shells only.  Who knows what this does??? }


   { Tell the selector shell what to do next }

IF crashed THEN
{ possibilities: 1: restart me, 2: go to selector shell, 3: start another shell,
                 4: power off, 5: reboot
  Because of possibility of error during startup/shut down which causes looping behavior,
  we always reboot to give the user the chance to interceed, i.e. interrupt the startup sequence.  }
   BEGIN               { Crashed or detected a fatal error }
   IF startingUp THEN
      msgToFather[1] := 5      { alternative: go back to selector shell }
   ELSE
      msgToFather[1] := 5;     { alternative: restart me }
   END
ELSE
   BEGIN               { Power button was pushed }
   IF appleOff THEN
      msgToFather[1] := 2      { go back to selector shell }
   ELSE
      msgToFather[1] := 4;     { power off }
   END;

Terminate_Process(err,@msgToFather);
END;



{$S flrDm1 }
FUNCTION LiveObject{* obj: ObjectHandle): BOOLEAN *};
{ returns true if the object's window is managed by an app process }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFiler THEN WRITELN('LiveObject',WriteName(obj));
LiveObject := FALSE;
IF obj^^.objWindow <> NIL THEN
   IF obj^^.kind IN docToolSet THEN
      IF NOT MyWindow(obj^^.objWindow) THEN LiveObject := TRUE;
END;



{$I ApDm/Desk2.text }



