{ ApDm/Vol.text  17-Oct-83} { Copyright 1983, 1984, Apple Computer Inc. }

UNIT DmVol;

{ This UNIT contains the procedures that mount, dismount, and otherwise control
  Lisa volumes. It is generally called by the dialog box unit and usually calls
  FDocCtrl to manage the opening, closing, and copying of documents on the
  volume. }

{ The system error number range for this module is 900-999.
  The highest number used is 951. }

INTERFACE

USES {$U HwInt        } HwInt,
     {$U LibOS/SysCall      } SysCall,
     {$U LibOS/PSysCall     } PSysCall,
     {$U UnitStd      } UnitStd,
     {$U UnitHz       } UnitHz,
     {$U Storage      } Storage,
     {$U QuickDraw    } QuickDraw,
     {$U FontMgr      } FontMgr,
     {$U WM.Events    } Events,
     {$U WM.Menus     } Menus,
     {$U WM.Windows   } Windows,
     {$U WM.Folders   } Folders,
     {$U AlertMgr     } AlertMgr,
     {$U dbenv        } dbenv,
     {$U dbdecl1      } dbdecl1,
     {$U Pooler       } Pooler,
     {$U PMDecl       } PMDecl,
     {$U FilerComm    } FilerComm,
     {$U Scrap        } Scrap,

     {$U ApDm/Globals } DmGlobals,
     {$IFC flrDebug}
     {$U apdm/tracecalls.obj}  tracecalls,
     {$ENDC}
     {$U ApDm/Time    } DmTime,
     {$U ApDm/Entry   } DMEntry,
     {$U ApDm/Cat     } DmCat,
     {$U ApDm/Doc     } DmDoc;


CONST
      { errors }

     fCatErr      =  7;       { Filer catalog error when opened }
     fMountNew    =  5;       { Need a new destination volume   }
     fNewlyInited = -1;       { WARNING: Disk just initialized  }
     fNotBackedup =  4;       { The data transfer was not done  }
     fNotInit     =  1;       { The volume is not initialized   }
     fNotMounted  =  3;       { The volume cannot be mounted    }
     fNotRepaired =  6;       { The volume was not repaired     }
     fUnreadable  =  2;       { The volume is broken            }

     lisaGuide    = 'guide';  { Volume name of the LisaGuide diskette }


TYPE
     SaveStateRec = RECORD        { record format for SaveDesktop file (disk structure) }
                    recID:     TcatRID;    { catalog id }
                    deskLoc:   Point;      { desktop location }
                    filedFlag: BOOLEAN;    { was it opened from it's container }
                    openFlag:  BOOLEAN;    { was it left opened }
                    END;


VAR  bootOut:   BOOLEAN;

PROCEDURE AnotherDiskette (VAR err: INTEGER; devHdl: TentryHdl; theOp: TuserOp; diskCt: INTEGER;
                           seqNum: INTEGER; eraseDisk: BOOLEAN);

{ This proc is used by GetNextDiskette to mount a new diskette. It is also used
  when rebuilding a large document or file from diskettes. }

PROCEDURE BackupVol (VAR err: INTEGER; sDevHdl: TentryHdl; dDevHdl: TentryHdl);

{ This proc copies the contents of the source device to the destination
  device. The source volume must already be mounted. If the destination device
  is larger than the source device, the unused portion of the destination
  device is available for storing documents and tools.  If the source
  device is larger than the destination volume, this proc will release the
  destination diskette and ask the user to insert another diskette when the
  destination device is full. If for any reason the source device's complete
  contents cannot be copied to a destination device, fNotBackedup
  is returned.

  Errors: fNoErr, fNotBackedup }

PROCEDURE DismountVol (device: Tdevice; eject: BOOLEAN; resume: BOOLEAN);

{ This proc causes all open documents to be suspended, all tools on the
  volume to be terminated, and the volume closed.  If it is a diskette,
  and "eject" is TRUE then it is ejected.  If resume is TRUE ResumeDocs
  will be called to try to find and start processes for open documents.  }

FUNCTION GetNextDiskette (VAR err: INTEGER; devHdl, sVolHdl: TentryHdl;
                          VAR diskCt: INTEGER; xferOp: TuserOp ) : BOOLEAN;

{ This proc is called by XferObj during ProFile backup to request the
  replacement of a full diskette with another diskette.  The name of the sVol
  and the diskCt is used to rename the volume to indicate its position within
  the sequence.  If TRUE is returned, a new diskette has been mounted, if FALSE,
  the user has aborted the backup.  }

PROCEDURE InitVolCtrl;

{ This proc readies the UNIT for use. It should be called once at program
  startup or restart. }

PROCEDURE MountVol (VAR err: INTEGER; device: Tdevice; VAR volHdl: TentryHdl);

{ This proc requests the O/S to mount a volume, asks for initialization or
  scavenging if required.

  Errors: fNoErr, fNotInit, fNotMounted, fUnreadable }

PROCEDURE PowerItDown;

{ This proc handles the power down sequence, suspending all docs, closing
  all tools, and releasing all disks. }

PROCEDURE ReinitializeVol (VAR err: INTEGER; device: Tdevice; VAR vol: TentryHdl);

{ This proc is used to reinitialize a disk(ette). All diskfiles on the volume
  are destroyed. The volume will have the name 'Unnamed'. This proc assumes the
  disk is 'OS unmounted'. After initialization the disk is mounted and a new
  vol entry is created and returned. If reinitialization is not successful, the
  disk is left 'unmounted', the err fNotMounted is returned and vol is NIL.

  Errors: fNoErr, fNotMounted }

PROCEDURE ReleaseDisk (devHdl: TentryHdl; eject: BOOLEAN);

{ This proc closes the volume catalog, any disk files that are still open,
  and ejects the disk (except for the boot disk).  }

PROCEDURE RepairVol (VAR err: INTEGER; device: Tdevice; VAR vol: TentryHdl);

{ This proc calls the O/S scavenger to attempt the repair of a broken volume.
  After repair, the caller must mount the volume. Since the volume must be
  dismounted before scavenging, a new vol will be returned after remounting.
  If it could not be repaired, the disk is left unmounted, the err 'fNotMounted'
  is returned, and vol is NIL.

  Errors: fNoErr, fNotMounted }
FUNCTION SaveSomeSpace (devHdl: TentryHdl) : {err} INTEGER;

{ This function is called by GetNextDiskette, DocBackup, and FcopyDiskFile to
  reserve space on the disk.  }


IMPLEMENTATION

{$IFC FlrSymbols }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

{$IFC FlrDebug }
{$R+ }
{$ELSEC }
{$R- }
{$ENDC }

CONST

     catDBName      = '{!Catalog}';
     catRecoverName = '{#Catalog}';
     redundSuffix   = '$R';

     incOffset      = 1000;       { the incremental fsInfo.vol_Sequence offset }


TYPE Tactivity =  (actNothingSpecial, actMounting, actPoweringDown,
                   actReiniting, actBackingUpDisk);

VAR  passwd:       E_Name;
     volActivity:  Tactivity;   { Special state, if any                   }


{**************************************************************************}
{                        External Procedures                               }
{**************************************************************************}
FUNCTION   MountAVolume(device: Tdevice) : BOOLEAN;                  EXTERNAL;
FUNCTION   UnmountAvolume(device: Tdevice; eject, restartDocs,
            recordDesktop: BOOLEAN; alertNum: INTEGER): BOOLEAN;     EXTERNAL;
PROCEDURE  UpdateAll;                                                EXTERNAL;

{**************************************************************************}
{                        Internal Procedures                               }
{**************************************************************************}

PROCEDURE CreateVolEntry (devHdl: TentryHdl; state: TVolState;
                          VAR volHdl: TentryHdl);                   FORWARD;
FUNCTION  EjectDiskette (devName: E_Name) : BOOLEAN;                FORWARD;
PROCEDURE EraseVol (VAR err: INTEGER; devHdl: TentryHdl);           FORWARD;
PROCEDURE FinishPowerDown;                                          FORWARD;
PROCEDURE FormatDisk (VAR err: INTEGER; devHdl: TentryHdl);         FORWARD;
PROCEDURE InitNewVol (VAR err: INTEGER; devHdl: TentryHdl;
                      VAR volHdl: TentryHdl);                       FORWARD;
PROCEDURE JustMount (VAR err: INTEGER; device: Tdevice;
                     VAR volHdl: TentryHdl; askUser: BOOLEAN;
                     forceRepair: BOOLEAN);                         FORWARD;
PROCEDURE ScavengeDevice (VAR err: INTEGER; devHdl: TentryHdl);     FORWARD;
PROCEDURE ToolsAreCopies (devHdl: TentryHdl);                       FORWARD;
FUNCTION  UnmountVol (devHdl: TentryHdl) : BOOLEAN;                 FORWARD;
FUNCTION  UserAborted (VAR err: INTEGER) : BOOLEAN;                 FORWARD;
FUNCTION  VerifyCat (devHdl: TentryHdl) : BOOLEAN;                  FORWARD;


{**************************************************************************}

{$S DmBackup }

PROCEDURE AnotherDiskette {VAR err: INTEGER; devHdl: TentryHdl; theOp: TuserOp; diskCt: INTEGER;
                           seqNum: INTEGER; eraseDisk: BOOLEAN};
LABEL  99;
VAR activetools: BOOLEAN;                 {*** Sally Rhodes ***}
    alertNum:    INTEGER;
    alertStr:    Str255;
    deviceName:  Str255;
    devInfo:     Fs_Info;
    devName:     FMaxStr;
    devPathName: PathName;
    diskNum:     INTEGER;
    diskNumStr:  NumberStr;
    isBootDev:   BOOLEAN;                  {*** Sally Rhodes ***}
    newVolHdl:   TentryHdl;
    newVolName:  FMaxStr;
    nextVolNum:  INTEGER;
    permitInit:  BOOLEAN;

  PROCEDURE CheckAbort;
  BEGIN
  IF Abort
  THEN BEGIN
    IF err <> fUserAbort
    THEN BEGIN
      err := fUserAbort;
      WaitAlert (flrAlert, 263);
      END;
    IF trcFVolCtrl THEN WRITELN ('   exit AnotherDiskette: user aborted, err is ',
                                  err:1);
    EXIT (AnotherDiskette);
    END;
  END;

  PROCEDURE IsUserCancelling;
  BEGIN
  IF AskAlert (flrAlert, 238) = 1
  THEN BEGIN                            { User is cancelling backup     }
    UpdateAll;
    err := aborted;
    IF trcFVolCtrl
    THEN WRITELN ('   exit AnotherDiskette: user cancelled operation, err is ',
                   err:1);
    EXIT (AnotherDiskette);
    END
  ELSE BEGIN                            { Backup not cancelled          }
    UpdateAll;
    AnotherDiskette (err, devHdl, theOp, diskCt, seqNum, eraseDisk);
    IF trcFVolCtrl THEN WRITELN ('   exit AnotherDiskette: err is ',err:1);
    EXIT (AnotherDiskette);
    END;
  END;

BEGIN
IF trcFVolCtrl THEN WRITELN ('AnotherDiskette: dev = ',devHdl^^.nameHdl^^,', diskCt = ', diskCt);
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

CheckAbort;

err := 0;
devName := devHdl^^.userNmHdl^^;

IF NOT (devHdl^^.removable)            { Check for floppy disk }
THEN BEGIN
  ParamAlert (devName,'','');
  IF AskAlert (flrAlert, 213) = 1      { 'Reuse the fixed disk?...'     }
  THEN err := fNotMounted;
  GOTO 99;
  UpdateAll;
  END;

CheckAbort;

   { Be sure the slot is clear  }
IF diskCt > 0
THEN DismountVol (devHdl^^.device, TRUE, FALSE)
ELSE IF UnmountAvolume (devHdl^^.device,TRUE, FALSE, TRUE, 131) THEN;

IF trcFVolCtrl THEN WRITELN ('   requesting diskette from user');
ArgAlert (1, devHdl^^.userNmHdl^^);
IF theOp = opRebuild
THEN BEGIN
   diskNum := ABS(seqNum);
   IF seqNum < 0
   THEN BEGIN
     IF diskNum > incOffset
     THEN BEGIN
       err := aborted;                { last incremental diskette processed }
       GOTO 99;
       END;
     IF AskAlert (flrAlert, 308) = 1  { ask for first incremental diskette }
     THEN BEGIN
       err := aborted;
       GOTO 99;
       END;
     nextVolNum := 1 + incOffset;
     END
   ELSE IF diskNum = 0
   THEN BEGIN                         { backup disks are old and not sequenced }
     IF AskAlert (flrAlert, 276) = 1
     THEN BEGIN
       err := aborted;
       GOTO 99;
       END;
     nextVolNum := 0;
     END
   ELSE BEGIN                         { ask for next diskette in sequence }
     IF diskNum < incOffset
     THEN alertNum := 425
     ELSE BEGIN
       alertNum := 426;
       diskNum := diskNum - incOffset;
       END;
     GetAlert (flrAlert, alertNum, @alertStr);
     IntToStr (diskNum+1, diskNumStr);
     ArgAlert (2, diskNumStr);
     ArgAlert (3, alertStr);
     IF AskAlert (flrAlert, 309) = 1
     THEN BEGIN                             { User said that he is finished  }
       err := aborted;
       GOTO 99;
       END;
     nextVolNum := seqNum+1;
     END;
  permitInit := FALSE;
  END
ELSE BEGIN
  IF eraseDisk
  THEN alertNum := 313
  ELSE alertNum := 229;
  IF NOT CautionAlert (flrAlert, alertNum)
  THEN IsUserCancelling;                 { Always exits AnotherDiskette   }
  permitInit := TRUE;
  END;
IF diskCt > 0 THEN UpdateAll;             {*** Changed for large doc backup ***}
CheckAbort;

IF trcFVolCtrl THEN WRITELN ('   mounting the inserted diskette');
IF eraseDisk
THEN EraseVol (err, devHdl)
ELSE
   JustMount (err, devHdl^^.device, newVolHdl, permitInit, FALSE);

CASE err OF
  0,
  fNewlyInited:
      BEGIN
      IF devHdl^^.volHdl^^.volState <> sMounted
      THEN BEGIN
         AnotherDiskette (err, devHdl, theOp, diskCt, seqNum, eraseDisk);
         EXIT (AnotherDiskette);
         END;
      IF theOp = opRebuild
      THEN BEGIN
         devPathName := CONCAT('-', devHdl^^.nameHdl^^);
         Lookup(err,devPathname,devInfo);
         IF NOT ((devInfo.copy_Thread = copyThread)
                 AND ((devInfo.backup_VolID.a = volBackedup.a)
                      AND (devInfo.backup_VolID.b = volBackedup.b)))
         THEN NoteAlert (flrAlert, 271)
         ELSE IF ABS(devInfo.volNum) <> nextVolNum
         THEN NoteAlert (flrAlert, 310)
         ELSE GOTO 99;
         UpdateAll;
         AnotherDiskette(err, devHdl, theOp, diskCt, seqNum, eraseDisk);
         END;
      END;

  aborted: AnotherDiskette (err, devHdl, theOp, diskCt, seqNum, eraseDisk);

  OTHERWISE BEGIN
     IF trcFVolCtrl THEN WRITELN ('   unable to mount/erase destination disk - err = ',err:1);
     ArgAlert (1, devHdl^^.userNmHdl^^);
     StopAlert (flrAlert, 218);
     IF NOT eraseDisk THEN
       BEGIN
       err := fCantRead;
       GOTO 99;
       END;
     AnotherDiskette (err, devHdl, theOp, diskCt, seqNum, eraseDisk);
     END;
  END;
CheckAbort;

99:
IF trcFVolCtrl THEN WRITELN ('   exit AnotherDiskette: err is ',err:1);
END;

{**************************************************************************}

{$S flrDskIn }

PROCEDURE BootVolRemounted;
VAR  err:      INTEGER;
     fontRec:  TLfntid;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFDocCtrl THEN WRITELN ('BootVolRemounted');

IF trcFDocCtrl THEN WRITELN ('   unlocking code segments');
UnlockSegs (err);
IF dbgFiler THEN WRITELN ('ERROR unlocking code segments: ',err:1);

IF trcFDocCtrl THEN WRITELN ('   unbinding the copy data seg');
UnbindCopyDataSeg;

IF trcFDocCtrl THEN WRITELN ('   unlocking alerts');
UnlockAlerts;

IF trcFDocCtrl THEN WRITELN ('   unlocking fonts');
WITH fontRec
DO BEGIN
  fam := sysPat;
  setEface := [];
  dev := devScreen;
  END;
FMLockFont (fontRec, FALSE, err);
fontRec.fam := sysCursor;
FMLockFont (fontRec, FALSE, err);
fontRec.fam := iconNamFont;
FMLockFont (fontRec, FALSE, err);

bootOut := FALSE;

IF trcFDocCtrl THEN WRITELN ('   exit BootVolRemounted: bootOut is ',bootOut);
END;


{**************************************************************************}

{$S flrDskOut }

PROCEDURE CreateVolEntry {devHdl: TentryHdl; state: TVolState; VAR volHdl: TentryHdl};
VAR volName: STRING[1];
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('   creating vol entry for device ',devHdl^^.nameHdl^^,
                             ', state is ',ORD(state):1);
IF devHdl^^.volHdl = NIL
THEN BEGIN
  CreateEntry  (vol, POINTER(ORD(@volname)), volHdl);
  volHdl^^.volState := state;
  devHdl^^.volHdl := volHdl;
  volHdl^^.devHdl := devHdl;
  END;
END;



{**************************************************************************}

{$S flrClose }

FUNCTION EjectDiskette {devName: E_Name) : BOOLEAN};

VAR err:        INTEGER;
    fsParams:   Ut_Parmt;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('EjectDiskette: ', devName);

fsParams.command := eject;
fsParams.dev_Name := devName;
FS_Utilities (err, fsParams);

IF (err <= 0) OR (err = 614 {no disk present})
THEN EjectDiskette := TRUE
ELSE BEGIN
  EjectDiskette := FALSE;
  IF dbgFiler THEN WRITELN ('ERROR: diskette not ejected - ',ORD(err):1);
  END;

IF trcFVolCtrl THEN WRITELN ('   exit EjectDiskette');
END;

{**************************************************************************}

{$S flrDskIn }

PROCEDURE EraseVol {VAR err: INTEGER; devHdl: TentryHdl};

VAR devPathname: Pathname;
    fsInfo:      Fs_Info;
    volHdl:      TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('EraseVol: ',devHdl^^.nameHdl^^);

ParamAlert (devHdl^^.UserNmHdl^^,'','');
WaitAlert (flrAlert, 265);               { 'Initializing...'            }

DismountVol (devHdl^^.device, FALSE, FALSE);
InitNewVol (err, devHdl, volHdl);
IF volHdl = NIL THEN CreateVolEntry (devHdl, sNoFileSystem, volHdl);

IF trcFVolCtrl
THEN BEGIN
  IF volHdl^^.volState = sMounted
  THEN BEGIN
    devPathname := CONCAT ('-',devHdl^^.nameHdl^^);
    Lookup (err, devPathname, fsInfo);
    WRITELN ('   exit EraseVol: fs_Size = ',fsInfo.fs_Size:1,
                                 ', free_Count = ',fsInfo.freeCount:1);
    END
  ELSE WRITELN ('   exit EraseVol: volState = ',ORD(volHdl^^.volState):1);
  END;
END;


{**************************************************************************}

{$S flrDskIn }

PROCEDURE FormatDisk {VAR err: INTEGER; devHdl: TentryHdl};
VAR dateStr:     TTimeStr;
    devInfo:     Fs_Info;
    devName:     E_Name;
    devPathname: Pathname;
    fsParams:    Ut_Parmt;
    schedErr:    INTEGER;
    timeStr:     TTimeStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('FormatDisk: device = ',devHdl^^.nameHdl^^);

TimeToStr (TRUE, 0, dateStr, timeStr);
devName := devHdl^^.nameHdl^^;
devPathname := CONCAT('-',devName);
Lookup (err, devPathname, devInfo);
IF trcFVolCtrl THEN WRITELN('   initializing ',devName);
WITH fsParams DO BEGIN
  command := initVol;
  idev_Name := devName;
  pages := 0;
(*newVolName := CONCAT ('AOS ',timeStr,' ',dateStr);*)
  newVolName := 'AOS 3.0';
  newPassword := '';
  max_Sfiles := devInfo.vol_Size DIV 7; { Big enough SList to fill disk w/ 6 block files }
  END;
Sched_Class (schedErr, FALSE);         { Permit background processes to run }
FS_Utilities (err, fsParams);
IF err = 1214 THEN err := 0;           { Its ok if can't write the boot tracks }
Sched_Class (schedErr, TRUE);          { Make me non-premptable again       }

IF trcFVolCtrl THEN WRITELN ('   exit FormatDisk: err = ',err:1);
END;


{**************************************************************************}

{$S flrDskIn }

PROCEDURE InitNewVol {VAR err: INTEGER; devHdl: TentryHdl; VAR volHdl: TentryHdl};

{ This proc takes a (possibly) new volume, formats it if necessary, and
  makes it ready to store documents and tools. The volume is mounted and the
  volHdl returned to the caller.

  If the volume cannot be initialized or an icon catalog created, the OS/DB error is
  returned, volHdl is NIL, and the volume is left unmounted.  }

LABEL 99;

VAR bytesWritten:LONGINT;
    devName:     E_Name;
    saveFile:    Pathname;
    saveRec:     SaveStateRec;
    saveRefnum:  INTEGER;
    temp:        INTEGER;
    volName:     E_Name;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('InitNewVol: device = ',devHdl^^.nameHdl^^);

volHdl := NIL;
FormatDisk (err, devHdl);
IF err > 0 THEN GOTO 99;

devName := devHdl^^.nameHdl^^;
Mount (err, volName, passwd, devName);
IF err > 0 THEN GOTO 99;

CreateCat (err, devHdl);
IF err > 0 THEN BEGIN
  Unmount (err, devName);
  KillEntry (devHdl^^.volHdl);
  devHdl^^.volHdl := NIL;
  GOTO 99;
  END;

volHdl := devHdl^^.volHdl;
volHdl^^.volState := sMounted;

 { reserve space for a savedesktop file - copied from Desk.SaveDesktop }
saveFile := CONCAT('-',devName,'-',desktopFile);
Make_File (temp, saveFile, 0);
IF temp = 0 THEN Open (err, saveFile, saveRefnum, [dWrite]);
IF temp = 0 THEN BEGIN
  saveRec.recID.fatherID := -1;
  Write_Date (temp, saveRefnum, ORD(@saveRec), SIZEOF(saveREc), bytesWritten, sequential, 0);
  Close_object (temp, saveRefnum);
  END;

99:
IF trcFVolCtrl THEN WRITELN ('   exit InitNewVol: err is ',err:1);
END;

{**************************************************************************}

{$S flrCat }

PROCEDURE JustMount {VAR err: INTEGER; device: Tdevice;
                     VAR volHdl: TentryHdl; askUser: BOOLEAN; forceRepair: BOOLEAN};
LABEL 33, 34, 99, 96;
CONST
    askW    = 1;  { Values for 'which' param, Proc InitOrRepair }
    repairW = 3;
    initW   = 4;
    RecovW  = 5;

VAR answer:     STRING [5];
    askAnswer:  INTEGER;
    devCtrl:    DcType;
    devHdl:     TentryHdl;
    devInfo:    Fs_Info;
    devName:    E_Name;
    devPathname:Pathname;
    diskName:   FMaxStr;
    field:      TfieldVar;
    mountErr:   INTEGER;
    numStr:     NumberStr;
    osErr:      INTEGER;
    fs_Params:  Ut_Parmt;
    volName:    E_name;

  FUNCTION InitOrRepair (VAR err: INTEGER; which: INTEGER; alertNum: INTEGER;
                         state: TVolState) : BOOLEAN;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFVolCtrl THEN WRITELN ('InitOrRepair: which is ',which:1,', alert ',alertNum:1);
  ParamAlert (devHdl^^.userNmHdl^^, '', '');
  IF which = askW THEN which := AskAlert (flrAlert, alertNum);
  UpdateAll;
  InitOrRepair := FALSE;
  IF trcFVolCtrl THEN WRITELN ('   which is now ',which:1);
  CASE which OF
    1: BEGIN
       CreateVolEntry (devHdl, state, volHdl);
       err := fNotMounted;             { Release disk                 }
       END;
    2: BEGIN                           { keep disk                    }
       IF volHdl = NIL
       THEN CreateVolEntry (devHdl, state, volHdl)
       ELSE volHdl^^.volState := state;
       err := 0;
       END;

    3: BEGIN                         { Attempt repair               }
       IF askUser
       THEN BEGIN
         ParamAlert (devHdl^^.userNmHdl^^,'','');
         WaitAlert (flrAlert, 221);
         END;
       DismountVol (devHdl^^.device, FALSE, FALSE);
                                     { Clean up any hanging entries }
       ScavengeDevice (err, devHdl);
       IF err <= 0
       THEN BEGIN
         forceRepair := TRUE;
         JustMount (err, device, volHdl, askUser, forceRepair);
         END
       ELSE BEGIN
         CreateVolEntry (devHdl, state, volHdl);
         ParamAlert (devHdl^^.userNmHdl^^,'','');
         IF askUser THEN IF AskAlert (flrAlert, 220) = 2 THEN err := 0;
         END;
       END;


    4: BEGIN                           { Initialize                   }
       IF askUser
       THEN BEGIN
         ParamAlert (devHdl^^.userNmHdl^^,'','');
         WaitAlert (flrAlert, 215);  { 'Initializing...'            }
         END;
       InitNewVol (err, devHdl, volHdl);
       IF err > 0
       THEN BEGIN
         CreateVolEntry (devHdl, sNoFileSystem, volHdl);
         ParamAlert (devHdl^^.userNmHdl^^,'','');
         IF askUser THEN IF AskAlert (flrAlert, 219) = 2 THEN err := 0;
         END;
       IF volHdl^^.volState = sMounted THEN err := fNewlyInit;
       END;

    5: BEGIN                         { Try to recover catalog       }
       IF askUser
       THEN BEGIN
         ParamAlert (devHdl^^.userNmHdl^^,'','');
         WaitAlert (flrAlert, 221);
         END;
       RecoverCat (err, devHdl);
       IF err > 0 THEN IF askUser
       THEN BEGIN
         ParamAlert (devHdl^^.userNmHdl^^,'','');
         IF AskAlert (flrAlert, 220) = 2       { Disk was not repaired     }
         THEN err := 0;
         END;
       END;
    END;

  IF volHdl <> NIL THEN IF volHdl^^.volState = sMounted THEN InitOrRepair := TRUE;
  IF trcFVolCtrl THEN WRITELN ('   exit InitOrRepair: err is ',err:1);
  END;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('JustMount: device = ',ORD(device.slot):1);

volHdl := NIL;

field.fieldType := dDevice;                { Get the device entry         }
field.device := device;
GetEntry (dev, NIL, NIL, field, devHdl);

IF bootOut AND (devHdl = bootVol^^.devHdl)
THEN BEGIN                                 { Check if this is the boot disk}
  IF trcFVolCtrl THEN WRITELN ('   attempting boot disk remount');
  fs_Params.command := boot_Remount;
  Fs_Utilities (err, fs_Params);
  IF err <= 0
  THEN BEGIN                               { Boot disk remounted          }
    BootVolRemounted;
    volHdl := bootVol;
    IF trcFVolCtrl THEN WRITELN ('   exit JustMount: boot disk remounted');
    END
  ELSE BEGIN
    IF trcFVolCtrl THEN WRITELN ('   exit JustMount: boot disk NOT remounted; err = ',err:1);
    err := fNotMounted;
    END;
  EXIT (JustMount);
  END;

devName := devHdl^^.nameHdl^^;             { Mount the volume             }
IF trcFVolCtrl THEN WRITELN ('    device name: ', devName);
devPathname := CONCAT('-',devName);
33:
volName := '';
Mount (mountErr, volName, passwd, devName);
IF trcFVolCtrl THEN WRITELN ('   Mount err: ',mountErr:1);

CASE mountErr OF
   0,                                      { Mounted without error        }
  -626,  {*** huh? OS bug ***}
  -1059,                                   { Bad block table nearly full  }
  -1060,                                   { Its a temp unmounted boot disk }
  -1174,                                   { Mounted, but was open at crash}
  -1175: BEGIN                             { Mounted, scavenger has altered}
34:     devHdl^^.devState := devOnline;
        Lookup (err, devPathname, devInfo);
        IF devInfo.scavenged_Flag = TRUE   { Reset if left over from previous mount }
        THEN BEGIN
          devInfo.scavenged_Flag := FALSE;
          PSet_Vol_Info (err, devPathname, devInfo);
          END;
        IF devInfo.vol_left_mounted
        THEN BEGIN
          devInfo.vol_left_mounted := FALSE;
          PSet_Vol_Info (err, devPathname, devInfo);
          ParamAlert (devHdl^^.userNmHdl^^,'','');
          IF AskAlert (flrAlert, 242) = 2  { 'Do you want to scavenge?'   }
          THEN BEGIN                       { Default                      }
            ParamAlert (devHdl^^.userNmHdl^^,'','');
            WaitAlert (flrAlert, 245);     { 'Verifying...'               }
            Unmount (osErr, devName);      { Unmount always succeeds      }
            IF trcFVolCtrl THEN IF osErr <> 0
            THEN WRITELN ('   osErr ',osErr:1,' from Unmount');
            ScavengeDevice (osErr, devHdl);
            IF osErr <= 0
            THEN BEGIN
              forceRepair := TRUE;
              GOTO 33;                     { Mount again                  }
              END;
            ParamAlert (devHdl^^.userNmHdl^^,'','');
            IF askUser THEN IF AskAlert (flrAlert, 220) = 2 THEN err := 0;
            GOTO 96;
            END
          ELSE NoteAlert (flrAlert, 243);  { 'Suggest you backup the disk...' }
          UpdateAll;
          END;

        { Verify that backup disk master tools have been marked as copies }
        IF devInfo.copy_Flag THEN ToolsAreCopies (devHdl);

        IF forceRepair
        THEN BEGIN
          RecoverCat (err, devHdl);
          volHdl := devHdl^^.volHdl;
          END
        ELSE BEGIN
          IF NOT (devHdl^^.removable)
          THEN IF VerifyCat (devHdl) THEN;
          OpenCat (err, devHdl);
          volHdl := devHdl^^.volHdl;
          CASE err OF
            DBVersionMisMatch: BEGIN
                ArgAlert (1,devHdl^^.userNmHdl^^);
                CASE AskAlert (flrAlert, 297) OF   { 'Old version, convert?' }
                  1: ;
                  2: BEGIN
                     err := 0;
                     GOTO 96;
                     END;
                  3: BEGIN
                     UpdateAll;
                     ArgAlert (1, devHdl^^.userNmHdl^^);
                     WaitAlert (flrAlert, 301);
                     RecoverCat (err, devHdl);
                     IF err <= 0
                     THEN EndWaitAlert
                     ELSE IF AskAlert (flrAlert, 298) = 2
                          THEN BEGIN
                            err := 0;
                            GOTO 96;
                            END;
                     UpdateAll;
                     END;
                  4: BEGIN
                     DismountVol (devHdl^^.device, FALSE, FALSE);
                     IF InitOrRepair (err, initW, 0, sOldCatalog) THEN;
                     END;
                  END;
                IF err > 0
                THEN BEGIN
                  err := fNotMounted;
                  GOTO 99;
                  END;
                END;
            DBTooOld: BEGIN
                ArgAlert (1,devHdl^^.userNmHdl^^);
                IF AskAlert (flrAlert, 299) = 2
                THEN BEGIN
                  err := 0;
                  GOTO 96;
                  END;
                err := fNotMounted;
                GOTO 99;
                END;
            DBTooNew: BEGIN
                ArgAlert (1,devHdl^^.userNmHdl^^);
                IF AskAlert (flrAlert, 300) = 2
                THEN BEGIN
                  err := 0;
                  GOTO 96;
                  END;
                err := fNotMounted;
                GOTO 99;
                END;
            END;
          END;
        IF volHdl^^.volState <> sMounted
        THEN BEGIN
          IF forceRepair
          THEN BEGIN
            err := 0;
            GOTO 99;
            END;
          IF askUser
          THEN BEGIN
            ParamAlert (devHdl^^.userNmHdl^^,'','');
            askAnswer := AskAlert (flrAlert, 211); { 'Repair disk?'...    }
            UpdateAll;
            END
          ELSE askAnswer := 3;               { Fake a 'repair' yes answer }
          CASE askAnswer OF
            1: BEGIN
               IF trcFVolCtrl THEN WRITELN ('   exit JustMount: user said don''t repair');
               err := aborted;
               END;
            2: BEGIN
               IF err = 948
               THEN CreateVolEntry (devHdl, sNoCatalog, volHdl)
               ELSE CreateVolEntry (devHdl, sBadCatalog, volHdl);
               err := 0;
               GOTO 96;
               END;
            3: BEGIN
               IF NOT ((err > 100) AND (err < 2000)) { DB (NOT OS) err on open }
               THEN IF InitOrRepair (err, recovW, 0, sNoCatalog) THEN;
               IF err > 0                            { OS err or recovW failed }
               THEN IF NOT InitOrRepair (err, repairW, 0, sBadCatalog) THEN;
               END;
            4: BEGIN
               DismountVol (devHdl^^.device, FALSE, FALSE);
               IF InitOrRepair (err, initW, 0, sBadCatalog) THEN;
               END;
            END;
          END;

        IF volHdl^^.volState = sMounted
        THEN BEGIN                         { Filer catalog opened w/o err }
          err := fNoErr;
          GetObjName (volHdl, diskCatRID, diskName);

          IF devInfo.scavenged_Flag = TRUE
          THEN BEGIN
            IF askUser
            THEN BEGIN
              ParamAlert (diskName,'','');
              NoteAlert (flrAlert, 241);       { 'Scavenger has altered disk...' }
              END;
            devInfo.scavenged_Flag := FALSE;
            PSet_Vol_Info (err, devPathname, devInfo);
            END;

          IF mountErr = -1059
          THEN BEGIN
            ParamAlert (diskName,devHdl^^.userNmHdl^^,'');
            NoteAlert (flrAlert, 272);       { 'Disk deteriorating... '}
            END;
          UpdateAll;
          IF trcFVolCtrl THEN WRITELN ('   ',volHdl^^.nameHdl^^,' mounted on ',
                                       volHdl^^.devHdl^^.nameHdl^^,
                                       ' (',ORD(volHdl^^.devHdl^^.device.slot),')');
          END;
        END;

        { no disk in place }
   609,
   614,
   1062: err := fNotMounted;

        { no OS file system }
   606,                                    { New disk, not formatted, maybe }
   617,                                    { checksum error, not initialized}
   866,                                    { not an OS file system          }
   1054,                                   { bad block directory - not OS disk}
   1197: BEGIN                             { not formatted or cannot be read}
         IF askUser THEN IF InitOrRepair (err, askW, 214, sNoFileSystem) THEN;
         END;

        { insufficient memory available }
   864,
   870,
   872: BEGIN                              { OS needs memory space        }
        err := fNotMounted;
        ArgAlert (1, devHdl^^.userNmHdl^^);
        StopAlert (flrAlert, 302);
        UpdateAll;
        END;

        { no such device, device is off }
   660,
   666,
   1885,
   1051: BEGIN
         err := fNotMounted;
         END;

        { something already mounted }
   1052: BEGIN
         IF trcFVolCtrl THEN WRITELN ('Something mounted on ',devHdl^^.nameHdl^^,'. Retrying.');
         devHdl^^.devState := devOnline;
         DismountVol (devHdl^^.device, FALSE, FALSE); { Clean up any hanging entries }
         Lookup (err, devPathname, devInfo);
         IF (NOT devInfo.mounted) AND (err <= 0) { Might not have been able to unmount it }
         THEN JustMount (err, devHdl^^.device, volHdl, askUser, forceRepair)
         ELSE BEGIN
           ArgAlert (1, devHdl^^.userNmHdl^^);
           StopAlert (flrAlert, 294);
           err := fNotMounted;
           END;
         END;

        { Diskette has a write protect tag on it }
   1820: BEGIN
         IF EjectDiskette (devname) THEN;
         StopAlert (flrAlert, 281);
         err := fNotMounted;
         END;

        { Unuseable OS file system }
   OTHERWISE BEGIN                         { Unknown OS 'Mount' err       }
        IF dbgFiler THEN WRITELN ('ERROR ',mountErr:1,' mounting disk');
        IF err < 0 THEN GOTO 34;           { just a warning }
        IF InitOrRepair (err, askW, 222, sNoFileSystem) THEN;
        END;
   END;

96:
EndWaitAlert;
UpdateAll;

99:
IF volHdl = NIL THEN CreateVolEntry(devHdl, sNoFileSystem, volHdl);
IF trcFVolCtrl THEN WRITELN ('   exit JustMount');
END;

{**************************************************************************}

{$S flrDskOut }

PROCEDURE FinishPowerDown;
LABEL 99;
VAR err:        INTEGER;
    termEvBlk:  S_EventBlk;
    nextVolHdl,
    toolHdl,
    volHdl:     TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('FinishPowerDown');

IF volActivity <> actPoweringDown THEN GOTO 99;

CloseCat (err, bootVol);
TermCat;

99:
IF trcFVolCtrl THEN WRITELN ('   exit FinishPowerDown');
END;


{**************************************************************************}

{$S DmBackup }

PROCEDURE RenameBackupVol (volHdl: TentryHdl; name: FMaxStr; diskCt: INTEGER;
                           backupTime: LONGINT);
LABEL 99;
VAR alertNum:      INTEGER;
    catErr:        INTEGER;
    catRec:        TcatRec;
    dateStr:       TTimeStr;
    here:          INTEGER;
    intStr:        NumberStr;
    newName:       Str255;
    oldPathname:   Pathname;
    timeStr:       TTimeStr;
    volNameExt:    FMaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('RenameBackupVol: name - ',name,' diskCt = ',diskCt:1,
                             ' backup year = ',backupTime:1);

IF name[1] = '"'
THEN BEGIN
  Delete (name, 1, 1);
  Delete (name, LENGTH(name), 1);
  END;

IF backupTime <> 0
THEN BEGIN                               { Format is 'name (Backup n disk m)'}
  IF fullBackup
  THEN alertNum := 427
  ELSE alertNum := 428;
  GetAlert (flrAlert, alertNum, @volNameExt);
  here := POS ('{',volNameExt);          { Insert the date }
  Delete (volNameExt,here,1);
  TimeToStr (FALSE, backupTime, dateStr, timeStr);
  Insert (dateStr,volNameExt,here);
  here := POS ('}',volNameExt);
  Delete (volNameExt,here,1);
  IntToStr (diskCt, intStr);
  Insert (intStr,volNameExt,here);
  newName := CONCAT(name, volNameExt);
  name := COPY(newName,1,MIN(LENGTH(newName),SIZEOF(name)));
  END;

GetCatRec (catErr, volHdl, diskCatRID, catRec);
IF ErrorFound (warnError, 941, catErr, volHdl^^.devHdl) THEN GOTO 99;
InsObjName (catRec, name);
UpdCatRec (catErr, volHdl, diskCatRID, catRec);
IF ErrorFound (warnError, 942, catErr, volHdl^^.devHdl) THEN ;

99:
IF trcFVolCtrl THEN WRITELN ('   exit RenameBackupVol: new name is ',name);
END;


{**************************************************************************}

{$S DmBackup }

FUNCTION SaveSomeSpace {devHdl: TentryHdl) : INTEGER};

VAR actual:      LONGINT;
    err:         INTEGER;
    dfPathname:  Pathname;
    dfRefnum:    INTEGER;
    osErr:       INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('SaveSomeSpace: device is ',devHdl^^.nameHdl^^);

dfPathname := CONCAT('-',devHdl^^.nameHdl^^,'-',saveSpace);
Make_File (err, dfPathname, 0);
CASE err OF
   890:  err := 0;
   OTHERWISE BEGIN
      IF err <= 0 THEN Open (err, dfPathname, dfRefnum, [dWrite, append]);
      IF err <= 0 THEN Allocate (err, dfRefnum, TRUE, sizeSpace, actual);
      END;
END;
Close_Object (osErr, dfRefnum);
SaveSomeSpace := err;

IF trcFVolCtrl THEN WRITELN ('   exit SaveSomeSpace: err is ',err:1);
END;

{**************************************************************************}

{$S flrDskOut }

PROCEDURE ScavengeDevice {VAR err: INTEGER; devHdl: TentryHdl};
LABEL 33;
VAR devName:  E_Name;
    fsParams: Ut_Parmt;
    schedErr: INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('ScavengeDevice: device is ',devHdl^^.nameHdl^^);

devName := devHdl^^.nameHdl^^;
fsParams.command := fsScavenge;
fsParams.sDev_Name := devName;
fsParams.sOptions := [];
33:
Sched_Class (schedErr, FALSE);         { Permit background processes to run }
Fs_Utilities (err, fsParams);
Sched_Class (schedErr, TRUE);
IF dbgFiler THEN IF err > 0 THEN WRITELN ('Scavenge failed: ',err:1);
UpdateAll;

IF trcFVolCtrl THEN WRITELN ('   exit ScavengeDevice: err = ',err:1);
END;


{**************************************************************************}

{$S DmBackup }

PROCEDURE ToolsAreCopies {devHdl: TentryHdl};
LABEL 99;
VAR devPathname:  Pathname;
    dfInfo:       Fs_Info;
    dfName:       E_Name;
    dfPathname:   Pathname;
    dfPrefix:     E_Name;
    err:          INTEGER;

  PROCEDURE CheckErr (location: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF err > 0 THEN IF ErrorFound (warnError, location, err, devHdl)
  THEN BEGIN
    IF trcFVolCtrl THEN WRITELN ('   exit ToolsAreCopies: err = ',err:1);
    EXIT (ToolsAreCopies);
    END;
  END;


BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('ToolsAreCopies: device is ',devHdl^^.nameHdl^^);

devPathname := CONCAT ('-', devHdl^^.nameHdl^^);
Lookup (err, devPathname, dfInfo);
CheckErr (937);
Reset_Catalog (err, devPathname);
CheckErr (938);
dfPrefix := '{T';
Get_Next_Entry (err, dfPrefix, dfName);
WHILE err <= 0 DO BEGIN
  Downshift (@dfName);
  IF POS('}obj',dfName) > 0
  THEN BEGIN
    dfPathname := CONCAT (devPathname, '-', dfName);
    Lookup (err, dfPathname, dfInfo);
    IF dfInfo.protected AND dfInfo.master_File
    THEN BEGIN
      IF trcFVolCtrl THEN WRITELN ('   found a master : ',dfPathname,
                                   ', machine_ID is ',dfInfo.machine_ID:1);
      IF dfInfo.machine_ID = 0
      THEN BEGIN
        ZapPassword (dfPathname);
        Kill_Object (err, dfPathname);
        END
      ELSE Protect (err, dfPathname, FALSE, dfInfo.machine_ID);
      END;
    END;
  Get_Next_Entry (err, dfPrefix, dfName);
  END;

IF trcFVolCtrl THEN WRITELN ('   resetting the volume ''copy'' flag');
Lookup (err, devPathname, dfInfo);
CheckErr (939);
dfInfo.copy_Flag := FALSE;
dfInfo.master := TRUE;
PSet_Vol_Info (err, devPathname, dfInfo);
CheckErr (940);

99:
IF trcFVolCtrl THEN WRITELN ('   exit ToolsAreCopies');
END;


{**************************************************************************}

{$S flrClose }

FUNCTION UnmountVol {devHdl: TentryHdl) : BOOLEAN};
LABEL 33;
VAR devName:   E_Name;
    dfInfo:    OpenRec;
    DfRefInfo: fs_Info;                 {*** added for large document backup ***}
    err:       INTEGER;
    field:     TfieldVar;
    refNum:    LONGINT;
    reply:     FReason;
    procID:    LONGINT;
    toolHdl:   TentryHdl;


  PROCEDURE CheckErr (location: INTEGER);
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF ErrorFound (warnError, location, err, devHdl)
  THEN BEGIN
    UpdateAll;
    UnmountVol := TRUE;           { Unmount always succeeeds even if errors }
    IF dbgFiler THEN WRITELN ('   exit UnmountVol: unmount failed, err = ',err:1);
    EXIT (UnmountVol);
    END;
  END;


{------------------------- KillTheProcess -----------------------------------}

  PROCEDURE KillTheProcess;
  VAR prInfo:  ProcInfoRec;
  BEGIN                      { Proc did not close refnum so kill the process }
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFVolCtrl THEN WRITELN ('KillTheProcess: ',dfInfo.procID);

  IF toolHdl <> NIL                        { Ask user if we should kill proc }
  THEN ArgAlert (1,toolHdl^^.nameHdl^^)
  ELSE BEGIN
    Info_Process (err, dfInfo.procID, prInfo);
    IF ErrorFound (warnError, 934, err, devHdl)
    THEN ArgAlert (1, 'some tools')
    ELSE ArgAlert (1, prInfo.progPathname);
    END;
  ArgAlert (2, devHdl^^.userNmHdl^^);
  WaitAlert (flrAlert, 225);               { 'Need to Kill process to unmount...'}
  IF toolHdl <> NIL THEN toolHdl^^.toolState := sTerminating;
  Kill_Process (err, dfInfo.procID);
  REPEAT
    LetOthersRun;                          { Give the proc a chance to die }
    Activate_Process (err, dfInfo.procID, FALSE);
    UNTIL err > 0;
  FinishTerminating;
  EndWaitAlert;
  UpdateAll;

  IF trcFVolCtrl THEN WRITELN ('   exit KillTheProcess');
  END;

{------------------------- UnmountVol ---------------------------------------}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('UnmountVol: ',devHdl^^.nameHdl^^);

UnmountVol := TRUE;                        { Most always succeeds          }
devName := devHdl^^.nameHdl^^;

33:
Unmount(err, devName);
IF trcFVolCtrl THEN IF (err > 0) AND (err <> 1062) AND (err <> 1061)
THEN WRITELN ('   Unmount err ',err:1);
CASE err OF
  0,
  1061,
  1062: ;                                  { sucessfull or nothing mounted }

  1196: BEGIN                              { Diskfiles are still open      }
        IF devHdl^^.devstate = devEmpty THEN EXIT(UnmountVol);
        Get_Open_List (err, devName, dfInfo);
        IF err = 1133              { An O/S timing err, wait and try again }
        THEN BEGIN
          LetOthersRun;
          GOTO 33;
          END;
        CheckErr (951);
        WHILE err <= 0 DO BEGIN             { Close each open diskfile      }
          IF trcFVolCtrl THEN WITH dfInfo
          DO WRITELN ('   dfInfo: procID ',procID:1,', refnum ',refnum:1,
                      ', refnumType ',ORD(refnType):1,', global refnum ',globalrefn);

          procID := dfInfo.procID;
          refNum := dfInfo.refnum;
          IF dfInfo.globalRefn
          THEN BEGIN                       { Filer closes any global objects}
            IF trcFVolCtrl THEN WRITELN ('   closing global refnum');
            CASE dfInfo.refnType OF
              fRefnum:  Close_Object (err, dfInfo.refnum);
              dsRefnum: Close_DataSeg (err, dfInfo.refnum);
              ecRefnum: Close_Event_Chn (err, dfInfo.refnum);
              END;
            CheckErr (935);
            END

          ELSE IF procID = filerProcess    { OOPS! its the Filer's file     }
          THEN BEGIN
            IF dbgFiler THEN BEGIN
               Info(err,dfInfo.refnum,DfRefInfo);
               WRITELN('UnmountVol: filer has open file ',DfRefInfo.dir_path,DfRefInfo.name);
               END;
            Close_Object (err, dfInfo.refnum);
            END

          ELSE BEGIN                       { Ask proc to close local refnums}
            IF trcFVolCtrl THEN WRITELN ('   closing private refnum');
            field.fieldType := tProcID;
            field.procID := procID;
            GetEntry (tool, NIL, NIL, field, toolHdl);
            IF toolHdl = NIL
            THEN BEGIN
              IF trcFvolCtrl THEN WRITELN ('   diskfile does not belong to son');
              KillTheProcess;
              END
            ELSE BEGIN
              IF trcFvolCtrl THEN WRITELN ('   asking son to close diskfile');
              IF toolHdl^^.toolState <> sTerminating
              THEN SendFilerEvent (err, procID, NIL, fcDfClose, '', refnum, '', '', reply);
              Get_Open_List (err, devName, dfInfo);
              IF  (err <= 0)
              AND ((dfInfo.refnum = refnum) AND (dfInfo.procID = procID))
              THEN KillTheProcess;          { Its wasn't closed           }
              END;
            END;

          Get_Open_List (err, devName, dfInfo); { Get next open diskfile  }
          END;

        UnmountVol := UnmountVol (devHdl);  { Try again                    }

        END;

  OTHERWISE CheckErr (931);
  END;

IF trcFVolCtrl THEN WRITELN ('   exit UnmountVol');
END;


{**************************************************************************}

{$S flrCold }

FUNCTION UserAborted {VAR err: INTEGER) : BOOLEAN };
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF Abort
THEN BEGIN
  IF err <> fUserAbort THEN WaitAlert (flrAlert, 263);
  err := fUserAbort;
  UserAborted := TRUE;
  END
ELSE UserAborted := FALSE;
END;


{**************************************************************************}

{$S flrDskIn }

FUNCTION VerifyCat {devHdl: TentryHdl) : BOOLEAN};

{ This proc checks a disk for a special catalog name that indicates the hard disk was
  manipulated by the Office System 1 diskette.  If the special catalog is found, it is
  renamed as the normal catalog and verified using the RecoverCatalog procedure. FALSE is
  returned if the special catalog is found but cannot be verified.  }

VAR   catPathname:     Pathname;
      err:             INTEGER;
      realCatName:     E_Name;
      realCatPathname: Pathname;
      verified:        BOOLEAN;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('VerifyCat: ',devHdl^^.nameHdl^^);

verified := TRUE;
catPathname := CONCAT ('-',devHdl^^.nameHdl^^,'-',catRecoverName);
realCatPathname := CONCAT ('-',devHdl^^.nameHdl^^,'-',catDBName);
realCatName := catDBName;
Rename_Entry (err, catPathname, realCatName);   { fastest way to see if recovery cat is on disk }
IF trcFVolCtrl THEN IF ((err <> 1022) AND (err <> 1092))
THEN WRITELN ('   renaming ',catPathname,' to ',realCatName,': err is ',err:1);
IF err = 1024
THEN BEGIN                         { both catalogs exist, kill the old one and rename }
  ZapPassword (realCatPathname);
  Kill_Object (err, realCatPathname);
  Rename_Entry (err, catPathname, realCatName);
  IF err > 0 THEN verified := FALSE;
  END;
IF err <= 0                        { recovery catalog was found and renamed }
THEN BEGIN
  catPathname := CONCAT (catPathname,redundSuffix);
  realCatName := CONCAT (realCatName,redundSuffix);
  realCatPathname := CONCAT (realCatPathname, redundSuffix);
  ZapPassword (realCatPathname);
  Kill_Object (err, realCatPathname);
  Rename_Entry (err, catPathname, realCatName);
  IF trcFVolCtrl THEN IF ((err <> 1022) AND (err <> 1092))
  THEN WRITELN ('   renaming ',catPathname,' to ',realCatName,': err is ',err:1);
  ParamAlert (devHdl^^.userNmHdl^^,'','');
  WaitAlert (flralert, 304);
  RecoverCat(err, devHdl);
  EndWaitAlert;
  IF err > 0 THEN verified := FALSE;
  END;

VerifyCat := verified;

IF trcFVolCtrl THEN WRITELN ('   exit VerifyCat: ',verified,', err = ',err:1);
END;

{**************************************************************************}
{*                         External Procedures                            *}
{**************************************************************************}

{$S DmBackup }

PROCEDURE BackupVol {VAR err: INTEGER; sDevHdl, dDevHdl: TentryHdl};
LABEL 99;
VAR dateStr:       TTimeStr;
    destHdl:       TentryHdl; {volHdl}
    dVolName:      E_Name;
    dUserVolName:  FMaxStr;
    dDevName:      E_Name;
    dDevPathname:  Pathname;
    dfInfo:        Fs_Info;
    dfName:        E_Name;
    dfPathname:    Pathname;
    dfPrefix:      E_Name;
    diskCt:        INTEGER;
    fsParams:      Ut_Parmt;
    machine_ID:    INTEGER;
    masterDfs:     BOOLEAN;
    nothingActive: BOOLEAN;
    numDigits:     INTEGER;
    osErr:         INTEGER;
    response:      INTEGER;
    sourceHdl:     TentryHdl; {volHdl}
    sDevName:      E_Name;
    sDevPathname:  Pathname;
    sFsInfo:       Fs_Info;
    sinceDate:     LONGINT;
    sVolName:      E_Name;
    sUserVolName:  FMaxStr;
    theOp:         TuserOp;
    timeStr:       TTimeStr;
    toolID:        LONGINT;
    unlockDriver:  BOOLEAN;

 {------------------------------------------------------------------------}

{$S DmBackup }
  FUNCTION BackupFinished (xferResult: INTEGER) : BOOLEAN;
  VAR ourErr:  INTEGER;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFVolCtrl THEN WRITELN ('BackupFinished: xferResult = ',xferResult:1);

  IF (xferResult = fNoErr) OR (xferResult = aborted) OR (xferResult = fUserAbort)
  THEN BEGIN
    backupFinished := TRUE;
    END
  ELSE BEGIN
    IF dbgFiler THEN WRITELN ('ERROR during backup: ',xferResult:1);
    IF AskAlert (flrAlert, 231) = 2   { 'Backup failed. Try again?        }
    THEN BEGIN
      AnotherDiskette (ourErr, dDevHdl, theOp, diskCt, 0, TRUE);
      destHdl := dDevHdl^^.volHdl;
      CASE ourErr OF
        fNoErr:       BackupFinished := FALSE;
        fNotMounted:  BackupFinished := FALSE; { Fixed disk, try again    }
        aborted,
        fUserAbort:   BackupFinished := TRUE;
        END;
      END
    ELSE BEGIN
      UpdateAll;
      backupFinished := TRUE;         { User gives up                     }
      err := aborted;
      END;
    END;

  IF trcFVolCtrl THEN WRITELN ('   exit BackupFinished');
  END;

 {------------------------------------------------------------------------}

{$S DmBkDoc }
  PROCEDURE DocBackup (VAR err: INTEGER; sinceDate: LONGINT);
  LABEL 88, 99;
  VAR catRec:      TcatRec;
      dDfPathname: Pathname;
      lastUpdate:  LONGINT;
      osErr:       INTEGER;
      saveDfName:  Pathname;
      sDfPathname: Pathname;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFVolCtrl THEN WRITELN ('DocBackup');

  theOp := opBackup;
  ParamAlert (dUserVolName, dDevHdl^^.userNmHdl^^,'');
  IF AskAlert (flrAlert, 228) = 1 THEN GOTO 99;{ 'Erase disk...?'           }
  UpdateAll;
  IF UserAborted (err) THEN GOTO 99;

  volID := sFsInfo.volID;                 { get backup info to mark backup diskettes }
  copyThread := sFsInfo.copy_Thread;
  IF sinceDate = nullInt4
  THEN BEGIN                              { Full backup, reset backup info  }
    fullBackup := TRUE;
    dtvb := TimeStamp;
    copyThread := copyThread+1;
    END
  ELSE BEGIN
    dtvb := sFsInfo.dtvb;
    fullBackup := FALSE;
    END;

  REPEAT
    EraseVol (err, dDevHdl);
    UpdateAll;
    IF UserAborted (err) THEN GOTO 88;
    IF err <= 0 THEN err := SaveSomeSpace (dDevHdl);
    WHILE err > 0 DO BEGIN
      IF UserAborted (err) THEN GOTO 88;
      ArgAlert (1, dDevHdl^^.userNmHdl^^);
      StopAlert (flrAlert, 218);
      AnotherDiskette (err, dDevHdl, opBackup, diskCt, 0, TRUE);
      destHdl := dDevHdl^^.volHdl;
      IF err > 0 THEN GOTO 88;
      err := SaveSomeSpace (dDevHdl);
      END;

    destHdl := dDevHdl^^.volHdl;          { New volume on the diskette     }

    IF UserAborted (err) THEN GOTO 88;
    ParamAlert (sUserVolName,sDevHdl^^.userNmHdl^^,dDevHdl^^.userNmHdl^^);
    WaitAlert (flrAlert, 236);            { 'Backing up...'                }
    diskCt := 1;

       { copy over the current catalog }
    IF trcFVolCtrl THEN WRITELN ('   copying the filer catalog');
    sDfPathname := CONCAT(sDevPathname,'-',catDbName);
    dDfPathname := CONCAT(dDevPathname,'-',catRecoverName);
    CloseCat (err, sourceHdl);            { opened privately by the db intrinsics }
    FCopyDiskFile (err, sDfPathname, dDfPathname, sourceHdl, destHdl, diskCatRID, diskCatRID,
                   copyDsAddr, copyDsMemSize, fcDocMove, theOp, osErr,
                   diskCt,FALSE, FALSE);     {***using diskCatRID instead of nil CatRID***}
    IF trcFVolCtrl THEN IF osErr > 0 THEN WRITELN ('   ',sDfPathname,' not copied, osErr = ',osErr:1);
    sDfPathname := CONCAT(sDfPathname,redundSuffix);
    dDfPathname := CONCAT(dDfPathname,redundSuffix);
    FCopyDiskFile (err, sDfPathname, dDfPathname, sourceHdl, destHdl, diskCatRID, diskCatRID,
                   copyDsAddr, copyDsMemSize, fcDocMove, theOp, osErr,
                   diskCt, FALSE, FALSE);     {***using diskCatRID instead of nil CatRID***}
    IF trcFVolCtrl THEN IF osErr > 0 THEN WRITELN ('   ',sDfPathname,' not copied, osErr = ',osErr:1);

    OpenCat (err, sDevHdl);
    sourceHdl := sDevHdl^^.volHdl;
    IF sinceDate = nullInt4
    THEN XferSysFiles (err, sourceHdl, destHdl, theOp, FALSE, diskCt, TRUE);
    destHdl := dDevHdl^^.volHdl;
    IF UserAborted (err) THEN GOTO 88;
    IF err <= 0 THEN XferObj (err, diskCatRID, diskCatRID, sourceHdl, destHdl,
                             FALSE, opBackup, TRUE, diskCt, sinceDate);

    saveDfName := CONCAT('-',dDevHdl^^.nameHdl^^,'-',saveSpace);
    ZapPassword (saveDfName);
    Kill_Object (osErr, saveDfName);
    destHdl := dDevHdl^^.volHdl;
    UNTIL BackupFinished (err);

88:
  IF err <= 0
  THEN BEGIN
    IF sinceDate = nullInt4
    THEN BEGIN
      IF trcFVolCtrl THEN WRITELN ('   setting full backup info');
      sFsInfo.DTVB := dtvb;
      sFsInfo.copy_Thread := copyThread;
      PSet_Vol_Info (osErr, sDevPathname, sFsInfo);
      END;
    IF trcFVolCtrl THEN WRITELN ('   setting backup info for last diskette');
    dfInfo.backup_VolID := volID;
    dfInfo.copy_Thread := copyThread;
    dfInfo.DTCC := dtvb;
    IF fullBackup
    THEN dfInfo.volNum := -diskCt
    ELSE dfInfo.volNum := -(diskCt + incOffset);
    PSet_Vol_Info (osErr, dDevPathname, dfInfo);
    RenameBackupVol (destHdl, sUserVolName, diskCt, sFsInfo.DTVB);
    END;

  IF dDevHdl <> NIL THEN IF dDevHdl^^.removable
  THEN DismountVol (dDevHdl^^.device, TRUE, FALSE);

99:
  IF trcFVolCtrl THEN WRITELN ('   exit DocBackup: err = ', err:1)
  END;

 {------------------------------------------------------------------------}

{$S DmBkTrak }
  PROCEDURE TrackBackup (VAR err: INTEGER);
  LABEL 99;
  VAR fsParams:    Ut_Parmt;
      schedErr:    INTEGER;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFVolCtrl THEN WRITELN ('TrackBackup');

  ParamAlert (dUserVolName, dDevHdl^^.userNmHdl^^,'');
  IF AskAlert (flrAlert, 228) = 1 THEN GOTO 99;{ 'Erase disk...?'           }
  UpdateAll;
  IF UserAborted (err) THEN GOTO 99;

    { Backup the disk until successful or the user says quit }
  REPEAT
    ParamAlert (sUserVolName,sDevHdl^^.userNmHdl^^,dDevHdl^^.userNmHdl^^);
    WaitAlert (flrAlert, 236);
    DismountVol (dDevHdl^^.device, FALSE, FALSE);
    IF sDevHdl^^.volHdl = bootVol                { Must OS dismount to track backup}
    THEN WITH fsParams DO BEGIN
      command := boot_Unmount;
      level := 1;
      Fs_Utilities (err, fsParams);
      IF err <= 0
      THEN bootOut := TRUE;                      { Flag for JustMount              }
      END
    ELSE DismountVol (sDevHdl^^.device, FALSE, FALSE);

    WITH fsParams DO BEGIN                       { Do the backup                   }
      command := copy_volume;
      from_dev := sDevName;
      to_dev := dDevName;
      buffAddr := copyDsAddr;
      buffSize := copyDsMemSize;
      END;
    Sched_Class (schedErr, FALSE);         { Permit background processes to run }
    Fs_Utilities (err, fsParams);
    Sched_Class (schedErr, TRUE);

    IF bootOut
    THEN BEGIN                                   { boot must be remounted immediately }
      fsParams.command := boot_Remount;
      Fs_Utilities (osErr, fsParams);
      bootOut := FALSE;
      IF osErr <= 0 THEN BootVolRemounted;
      Mount (osErr, dVolName, passwd, dDevName);{ Reset leftMounted flag        }
      IF osErr <= 0 THEN Lookup (osErr, dDevPathname, dfInfo);
      IF osErr <= 0
      THEN BEGIN
        dfInfo.vol_Left_Mounted := FALSE;
        PSet_Vol_Info (osErr, dDevPathname, dfInfo);
        END;
      Unmount (osErr, dDevName);
      END
    ELSE JustMount (osErr, sDevHdl^^.device, sourceHdl, FALSE, FALSE);

    UNTIL BackupFinished (err);

     { Mark all protected diskfiles as copies }
  JustMount (osErr, dDevHdl^^.device, destHdl, FALSE, FALSE);
  IF masterDfs AND (err <= 0) AND (osErr <= 0)
  THEN ToolsAreCopies (dDevHdl); { If error, 'ToolsAre...' called when next mounted}

  sFsInfo.DTVB := TimeStamp;
  sFsInfo.copy_Thread := sFsInfo.copy_Thread+1;
  PSet_Vol_Info (osErr, sDevPathname, sFsInfo);
  dfInfo.backup_VolID := sFsInfo.volID;
  dfInfo.copy_Thread := sFsInfo.copy_Thread;
  dfInfo.DTCC := sFsInfo.DTVB;
  PSet_Vol_Info (osErr, dDevPathname, dfInfo);

99:
  IF trcFVolCtrl THEN WRITELN ('   exit TrackBackup: err = ',err:1);
  END;

{------------------------------------------------------------------------}

{$S DmBkRstr }
  PROCEDURE UpdateVol;                                  { Reconstruction to hard disk }
  LABEL 33, 88, 99;
  VAR diskCt:      INTEGER;
      posBackup:   INTEGER;
      alertNum:    INTEGER;
      diskNum:     INTEGER;
      diskNumStr:  NumberStr;
      alertStr:    Str255;

  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFVolCtrl THEN WRITELN ('UpdateVol');

  diskCt := 1;

  IF sFsInfo.backup_VolID.b = 0          { Backup or Rebuild?             }
  THEN theOp := opBackup
  ELSE BEGIN
    IF (sFsInfo.volNum = 1) OR (sFsInfo.volNum = 0)
    THEN BEGIN
      theOp := opRebuild;
      copyThread := sFsInfo.copy_Thread;
      volBackedup := sFsInfo.backup_VolID;
      END
    ELSE BEGIN
      diskNum := ABS(sFsInfo.volNum);
      IF diskNum < incOffset
      THEN alertNum := 425
      ELSE BEGIN
        alertNum := 426;
        diskNum := diskNum - incOffset;
        END;
      GetAlert (flrAlert, alertNum, @alertStr);
      IntToStr (diskNum, diskNumStr);
      ParamAlert (dDevHdl^^.userNmHdl^^,alertStr,diskNumStr);
      StopAlert (flrAlert, 307);
      err := aborted;
      GOTO 99;
      END;
    END;

  ParamAlert (dUserVolName, dDevHdl^^.userNmHdl^^,'');
  IF AskAlert (flrAlert, 228) = 1 THEN GOTO 99;{ 'Erase disk...?'           }
  UpdateAll;
  IF UserAborted (err) THEN GOTO 99;
  EraseVol (err, dDevHdl);
  destHdl := dDevHdl^^.volHdl;            { New volume on the profile      }
  IF err > 0 THEN
    BEGIN
    ArgAlert (1, dDevHdl^^.userNmHdl^^);
    StopAlert (flrAlert, 218);
    GOTO 99;
    END;

33:
  IF theOp = opBackup
  THEN BEGIN
    ParamAlert (sUserVolName,sDevHdl^^.userNmHdl^^,dDevHdl^^.userNmHdl^^);
    WaitAlert (flrAlert, 236);            { 'Backing up...'                }
    END
  ELSE BEGIN
    ParamAlert (dDevHdl^^.userNmHdl^^, sDevHdl^^.userNmHdl^^,'');
    WaitAlert (flrAlert, 270);            { 'Rebuilding...'                }
    theOp := opRebuild;
    END;
  IF UserAborted (err) THEN GOTO 99;
  IF sinceDate = nullInt4
  THEN XferSysFiles (err, sourceHdl, destHdl, theOp, FALSE, diskCt, FALSE);
  IF UserAborted (err) THEN GOTO 99;
  IF err <= 0
  THEN XferObj (err, diskCatRID, diskCatRID, sourceHdl, destHdl, FALSE, theOp,
                TRUE, diskCt, sinceDate);
  IF UserAborted (err) THEN GOTO 99;
  IF (theOp = opBackup) OR (NOT sDevHdl^^.removable)
  THEN GOTO 88;                           { Only one source disk }
  REPEAT                     { do this only if rebuilding from diskettes }
    IF UserAborted (err) THEN GOTO 99;
    Lookup (err, sDevPathname, sFsInfo);
    AnotherDiskette (err, sDevHdl, opRebuild, diskCt, sFsInfo.volNum, FALSE);
    IF (err = aborted) OR (err = fUserAbort) THEN GOTO 99;
    sourceHdl := sDevHdl^^.volHdl;
    IF err <= 0
    THEN BEGIN
      Lookup (err, sDevPathname, sFsInfo);
      IF ErrorFound (warnError, 947, err, sDevHdl)
      THEN BEGIN
        err := aborted;
        EXIT (UpdateVol);
        END;
      GOTO 33;
      END;
    UNTIL err > 0;
88:

  { Restoring backup, set fs_info  }
  IF theOp = opRebuild
  THEN BEGIN
    dfInfo.copy_Thread := sFsInfo.copy_Thread;
    dfInfo.volID := sFsInfo.backup_VolID;
    dfInfo.dtvb := sFsInfo.dtcc;
    PSet_Vol_Info (err, dDevPathname, dfInfo);
    posBackup := POS('(Backup', sUserVolName);
    IF posBackup > 0                           { Strip off the '(Backup xx ...)'}
    THEN sUserVolName := Copy(sUserVolName, 1, posBackup-1);
    END
  ELSE BEGIN
    sFsInfo.dtvb := TimeStamp;
    sFsInfo.copy_Thread := sFsInfo.copy_Thread+1;
    PSet_Vol_Info (osErr, sDevPathname, sFsInfo);
    dfInfo.backup_VolID := sFsInfo.volID;
    dfInfo.copy_Thread := sFsInfo.copy_Thread;
    dfInfo.dtcc := sFsInfo.dtvb;
    PSet_Vol_Info (err, dDevPathname, dfInfo);
    END;
  diskCt := 0;
  RenameBackupVol (destHdl, sUserVolName, diskCt, 0);

99:
  IF trcFVolCtrl THEN WRITELN ('   exit UpdateVol: err = ',err:1);
  END;

{------------------------------------------------------------------------}

{$S DmBkDisk }
  PROCEDURE BackupDiskette;
  LABEL 33, 34, 99;
  VAR dbRefnum:        INTEGER;
      blocksCopied:    LONGINT;
      blocksRemaining: LONGINT;
      bufferBlocks:    LONGINT;
      bufferSize:      LONGINT;
      curCode:         LONGINT;
      dataSpace:       LONGINT;
      deltaMemSize:    LONGINT;
      dVolID:          UID;
      fsParams:        Ut_Parmt;
      maxCode:         LONGINT;
      MDDFblock:       ARRAY [0..270] OF INTEGER;
      MDDFoffset:      LONGINT;
      newDiskSize:     LONGINT;
      pE_Name:        ^E_Name;
      pUID:           ^UID;
      startBlock:      LONGINT;
      sVolID:          UID;
      swapSpace:       LONGINT;
      totalSize:       LONGINT;

  BEGIN
  IF trcFVolCtrl THEN WRITELN ('BackupDiskette: block size is ',sFsInfo.vol_Size:1);

  WaitAlert (flrAlert, 340);                { reading }

  { set volIDs }
  WITH fsParams DO BEGIN                    { get the device number }
    gp_Parm := 0;
    command := gp;
    funct   := 3;
    pE_Name := @parm_Array;
    pE_Name^:= sDevHdl^^.nameHdl^^;
    END;
  Fs_Utilities (err, fsParams);             { puts devnum in parm1 }
  IF err > 0 THEN
    BEGIN
    IF dbgFiler THEN WRITELN ('   error getting backup device number: ',err:1);
    GOTO 99;
    END;
  MDDFoffset := sFsInfo.vol_Size - sFsInfo.fs_Size;
  UnitIO (err, fsParams.parm1, ORD(@MDDFblock[0]), 1, MDDFoffset, blocksCopied, raw_IO, readOp);
  IF trcFVolCtrl THEN WRITELN ('   MDDF fsversion is ',MDDFblock[12]:1);
  pUID := @MDDFblock[13];
  sVolID := pUID^;
  dVolID.a := Timestamp;                    { create the new volume's volid }
  Get_Serial_No (err, dVolID.b);

  { set the dataseg size }
  DismountVol (sDevHdl^^.device, FALSE, FALSE);  { prevents 'disk in use' when mounting }
  Info_LDSN (err, DBLDSN, dbRefnum);
  Unbind_Dataseg (err, dbRefnum);
  totalSize := sFsInfo.vol_Size * sFsInfo.blockSize;  { bytes on the disk }
  Mem_Info (err, swapSpace, dataSpace, curCode, maxCode);
  deltaMemSize := swapSpace - dataSpace - $FFFF;
  IF totalSize < deltaMemSize THEN deltaMemSize := totalSize;
  REPEAT
    IF deltaMemSize < 0 THEN GOTO 99;
    IF trcFVolCtrl THEN WRITELN ('   sizing dataseg: ',deltaMemSize:1);
    Size_DataSeg (err, copyDsRefnum, deltaMemSize, copyDsMemSize, 0, newDiskSize);
    IF trcFVolCtrl THEN IF err > 0 THEN WRITELN ('   SizeDataseg err: ',err:1);
    deltaMemSize := deltaMemSize - $FFF;
    UNTIL err <= 0;
  bufferBlocks := copyDsMemSize DIV sFsInfo.blockSize;
  IF trcFVolCtrl THEN WRITELN ('   disk size: ',totalSize:1,', dataseg size: ',copyDsMemSize:1,
                               ', bufferBlocks: ',bufferBlocks:1);

  { copy the diskette }
  startBlock := 0;
  blocksRemaining := sFsInfo.vol_Size - 1;       { counting starts at zero }

  REPEAT

    { read the data }
    bufferBlocks := MIN(bufferBlocks, blocksRemaining);
    IF trcFVolCtrl THEN WRITELN ('   reading ',bufferBlocks:1,' starting at ',startBlock:1);
    UnitIO (err, fsParams.parm1, copyDsAddr, bufferBlocks, startBlock,
            blocksCopied, raw_IO, readOp);
    IF EjectDiskette (sDevHdl^^.nameHdl^^) THEN;
    IF err = 625 THEN err := 0;                   { don't let bad data stop the backup }
    IF err > 0 THEN BEGIN
      IF dbgFiler THEN WRITELN ('   error on read: ',err:1);
      StopAlert (flrAlert, 342);
      GOTO 99;
      END;

    { switch to the copy diskette }
33: IF AskAlert (flrAlert, 336) = 1 THEN GOTO 99; { 'please insert copy disk... }
    UnitIO (err, fsParams.parm1, ORD(@MDDFblock[0]), 1, MDDFoffset, blocksCopied, raw_IO, readOp);
    IF err = 614 THEN GOTO 33;                         { no diskette in place }
    IF startBlock = 0
    THEN BEGIN
      IF (sVolID.a = pUID^.a) AND (sVolID.b = pUID^.b)   { reinserted original diskette }
      THEN BEGIN
        IF EjectDiskette (sDevHdl^^.nameHdl^^) THEN;
        NoteAlert (flrAlert, 357);
        GOTO 33;
        END;
      END
    ELSE                                                 { startblock > 0 }
      IF (dVolID.a <> pUID^.a) OR (dVolID.b <> pUID^.b)  { didn't insert copy diskette  }
      THEN BEGIN
        IF EjectDiskette (sDevHdl^^.nameHdl^^) THEN;
        IF (sVolID.a = pUID^.a) AND (sVolID.b = pUID^.b) { reinserted original diskette }
        THEN NoteAlert (flrAlert, 357)
        ELSE NoteAlert (flrAlert, 359);
        GOTO 33;
        END;

    { write the data }
    WaitAlert (flrAlert, 341);                    { writing }
    IF trcFVolCtrl THEN WRITELN ('   writing ',bufferBlocks:1,' starting at ',startBlock:1);
    UnitIO (err, fsParams.parm1, copyDsAddr, bufferBlocks, startBlock,
            blocksCopied, raw_IO, writeOp);
    IF (err > 0) AND (startblock = 0)           { dest disk may not be formatted }
    THEN BEGIN
      ArgAlert (1, sDevHdl^^.userNmHdl^^);
      FormatDisk (err, sDevHdl);
      UnitIO (err, fsParams.parm1, copyDsAddr, bufferBlocks, startBlock,
              blocksCopied, raw_IO, writeOp);
      END;
    IF (startBlock = 0) AND (err <= 0)
    THEN BEGIN                                    { set new volID }
      UnitIO (err, fsParams.parm1, ORD(@MDDFblock[0]), 1, MDDFoffset, blocksCopied, raw_IO, readOp);
      pUID^ := dVolID;
      IF err <= 0
      THEN UnitIO (err, fsParams.parm1, ORD(@MDDFblock[0]), 1, MDDFoffset, blocksCopied, raw_IO, writeOp);
      END;
    IF err > 0 THEN BEGIN
      IF dbgFiler THEN WRITELN ('   error on write: ',err:1);
      IF EjectDiskette (sDevHdl^^.nameHdl^^) THEN;
      StopAlert (flrAlert, 343);
      GOTO 99;
      END;

    startBlock := startBlock + bufferBlocks;
    blocksRemaining := blocksRemaining - bufferBlocks;

    { switch to the original diskette }
    IF blocksRemaining > 0
    THEN BEGIN
      IF EjectDiskette (sDevHdl^^.nameHdl^^) THEN;
34:   IF AskAlert (flrAlert, 337) = 1 THEN GOTO 99;
      UnitIO (err, fsParams.parm1, ORD(@MDDFblock[0]), 1, MDDFoffset, blocksCopied, raw_IO, readOp);
      IF err = 614 THEN GOTO 34;                { no diskette in the drive, I think }
      IF (sVolID.a <> pUID^.a) OR (sVolID.b <> pUID^.b)
      THEN BEGIN                              { didn't insert original diskette  }
        IF EjectDiskette (sDevHdl^^.nameHdl^^) THEN;
        IF (dVolID.a = pUID^.a) AND (dVolID.b = pUID^.b)
        THEN NoteAlert (flrAlert, 358)
        ELSE NoteAlert (flrAlert, 359);
        GOTO 34;
        END;
      WaitAlert (flrAlert, 340);              { reading }
      END;
    UNTIL blocksRemaining <= 0;
  Size_DataSeg (err, copyDsRefnum, copyDsSize, copyDsMemSize, 0, newDiskSize);

  { Mark all protected diskfiles as copies }
  Bind_Dataseg (err, dbRefnum);
  JustMount (osErr, sDevHdl^^.device, sourceHdl, FALSE, FALSE);
  IF masterDfs AND (osErr <= 0) THEN ToolsAreCopies (dDevHdl);

  { mark the backup information }
  dfInfo := sFsInfo;
  sFsInfo.DTVB := TimeStamp;
  sFsInfo.copy_Thread := sFsInfo.copy_Thread+1;
  dfInfo.backup_VolID := sFsInfo.volID;
  dfInfo.copy_Thread := sFsInfo.copy_Thread;
  dfInfo.DTCC := sFsInfo.DTVB;
  PSet_Vol_Info (osErr, sDevPathname, dfInfo);
  DismountVol (sDevHdl^^.device, TRUE, FALSE);
  IF AskAlert (flrAlert, 337) = 1 THEN GOTO 99;
  WaitAlert (flrAlert, 338);
  JustMount (osErr, sDevHdl^^.device, sourceHdl, FALSE, FALSE);
  IF osErr <= 0
  THEN PSet_Vol_Info (osErr, sDevPathname, sFsInfo)
  ELSE DismountVol (sDevHdl^^.device, TRUE, FALSE);
  EndWaitAlert;

99:
  UpdateAll;
  Bind_Dataseg (err, dbRefnum);
  IF trcFVolCtrl THEN WRITELN ('   exit BackupDiskette: err = ',err:1);
  END;

{------------------------------------------------------------------------}

{$S DmBkPrim }
  PROCEDURE BackupPriam;
  { This proc copies the contents of a priam to/from the attached archive
    tape.  The code is a modified version of the Workshop archiver program. }

  CONST Version        = '1.6';          {current Archiver version number}
        TapeFormatVer  = 1;              {format version of tapes}

        RewindTape     = 1;              {tape op - rewind tape}
        EraseTape      = 2;              {tape op - erase tape}
        RetensionTape  = 3;              {tape op - retension tape}
        AdvanceTMs     = 4;              {tape op - advance n tape marks}
        WriteTMs       = 5;              {tape op - write n tape marks}
        Read1TM        = 6;              {tape op - read one tape mark}
        ReadStatus     = 7;              {tape op - read drive status}
        CopyTape       = 8;              {tape op - copy disk to tape/tape to disk}
        ResumeCopy     = 9;              {tape op - resume copy operation}
        AbortCopy      = 10;             {tape op - abort copy operation}
        IssuePkt       = 11;             {tape op - issue packet}
        ResumePkt      = 12;             {tape op - resume packet}
        AbortPkt       = 13;             {tape op - abort packet}

        DiskToTape     = 0;              {copy direction to copy disk to tape}
        TapeToDisk     = 1;              {copy direction to copy tape to disk}

        Resumable      = -1840;          {copy or pkt command ended resumable}

        TapeId1        = $FFFF0000;      {these are used to identify Archiver tapes}
        TapeId2        = $0000FFFF;      {they are the 1st 4 fields in tape header }
        TapeId3        = $10101010;
        TapeId4        = $01010101;

        TapeTitle      = 'Archiver PRIAM Streamer Tape'; {put into tape header}


   VAR alertNum:      INTEGER;
       CopyOk:        Boolean;
       DCplist:       DCType;           {device control parameter list}
       devHdl:        TentryHdl;
       Direction:     DiskToTape..TapeToDisk; {copy direction}
       DiskChannel:   Integer;          {io channel for the disk}
       DiskDevNbr:    Integer;          {disk device number}
       Header:        RECORD            {tape header layout}
                         CASE Integer OF
                            0:
                               (Block:         PACKED ARRAY [0..511] OF Char);
                            1:
                               (Id1, Id2, Id3, Id4: LongInt;
                                Title:         String[80];
                                FmtVersion:    Integer;
                                ProgVersion:   String[10];
                                dateTime:      String[20];
                                SeqNbr:        Integer;
                                UserTitle:     Str255;
                                Group:         String[20]);
                      END;
       i:             INTEGER;
       NbrOfTMs:      Integer;          {nbr of TM's to advance or write}
       numStr:        NumberStr;
       schedErr:      INTEGER;
       SeqNo:         Integer;
       TapeName:      E_Name;           {slot name of the tape}
       TapePathname:  Pathname;
       TapeVolName:   E_Name;           {volume name of the mounted tape}
       TapeChannel:   Integer;          {io channel for the tape}
       TapeDevNbr:    Integer;          {tape device number}
       TD:            String[20];       {time and data of execution and tape tag}
       UserLabel:     Str255;           {user's private label}


   PROCEDURE TapeIO(VAR err: INTEGER; Control: Integer);
   {TapeIO - all the tape I/O functions are performed here.  It is up to
    the *caller* to interpret the DCplist.DCData array. For the controls AdvanceTMs
    and WriteTMs, the number of TM's to advance is determined from the global
    NbrOfTMs which is preset to be 1. For IssuePkt it is assumed DCplist.DCData is
    already set up by the caller.}

   BEGIN
   IF trcFVolCtrl THEN WRITELN ('TapeIO: control is ',control:1);

   WITH DCplist DO BEGIN
      DCCode := Control; {DCVersion is already set}
      IF (Control=AdvanceTMs) OR (Control=WriteTMs) THEN
         DCData[0] := NbrOfTMs
      ELSE IF Control=CopyTape THEN
         BEGIN
         DCData[0] := TapeChannel;
         DCData[1] := TapeDevNbr;
         DCData[2] := DiskChannel;
         DCData[3] := DiskDevNbr;
         DCData[4] := Direction;
         END;
      END; {with}

   Device_Control(err, TapePathname, DCplist);

   IF trcFVolCtrl THEN WRITELN ('   exit TapeIO: err is ',err:1);
   END; {TapeIO}

   {*------------------------------------------------------------------------------------------*}

   PROCEDURE UnmountTape;

   BEGIN {UnmountTape}
   IF trcFVolCtrl THEN WRITELN ('UnmountTape');

   TapeIO(err, RewindTape);     {make sure tape is rewound}
   Unmount(err, TapeName);

  IF trcFVolCtrl THEN WRITELN ('   exit UnmountTape: err = ',err:1);
   END; {UnmountTape}

   {*----------------------------------------------------------------------------------------*}

   PROCEDURE AbortPTCopy (alertNum: INTEGER);
   BEGIN
   IF trcFVolCtrl THEN WRITELN ('AbortPTCopy');
   IF dbgFiler THEN WRITELN ('   err is ',err:1,', ',DCPlist.DCData[0]:1,' sectors copied');

   IF alertNum > 0 THEN StopAlert (flrAlert, alertNum);
   UpdateAll;
   TapeIO(err, AbortCopy);
   UnmountTape;
   IF devHdl^^.volHdl = NIL THEN JustMount (err, devHdl^^.device, sourceHdl, FALSE, FALSE);
   err := aborted;
   IF trcFVolCtrl THEN WRITELN ('   exit BackupVol');
   EXIT(BackupVol);

   END;

   {*----------------------------------------------------------------------------------------*}

   PROCEDURE MountTape (VAR err: INTEGER);
   {MountTape - this mounts the tape and sets up all the device info for the tape and
    disk. }
   LABEL 33;
   VAR Delim: Char;
       Mounted: Boolean;
       Password: E_Name;
       Attributes: FS_Info;

   BEGIN
   IF trcFVolCtrl THEN WRITELN ('MountTape');

   TapeName := devHdl^^.nameHdl^^;
   TapeName[4] := '3';
   TapePathname := CONCAT('-',TapeName);
33:
   IF trcFVolCtrl THEN WRITELN ('   mounting ',tapeName);
   Mount(err, TapeVolName, Password, TapeName);
   IF NOT ((err<=0) OR (err=1052 {device already mounted} ))
   THEN BEGIN
     IF dbgFiler THEN WRITELN ('   mount err ',err:1);
     AbortPTCopy (353);
     END;

   LookUp(err, TapePathname, Attributes);
   IF Direction = DiskToTape
   THEN BEGIN
     DiskChannel := sFsInfo.IOChannel;
     DiskDevNbr := sFsInfo.DeviceNumb;
     END
   ELSE BEGIN
     DiskChannel := dfInfo.IOChannel;
     DiskDevNbr := dfInfo.DeviceNumb;
     END;
   IF trcFVolCtrl THEN WRITELN ('   disk channel is ',diskChannel:1);
   IF trcFVolCtrl THEN WRITELN ('   disk device is  ',DiskDevNbr:1);
   TapeChannel := Attributes.IOChannel;
   IF trcFVolCtrl THEN WRITELN ('   tape channel is ',TapeChannel:1);
   TapeDevNbr := Attributes.DeviceNumb;
   IF trcFVolCtrl THEN WRITELN ('   tape device is  ',TapeDevNbr:1);
   IF trcFVolCtrl THEN WRITELN ('   direction is    ',direction:1);

   IF trcFVolCtrl THEN WRITELN ('   exit MountTape: err is ',err:1);
   END;

   {*----------------------------------------------------------------------------------------*}

   PROCEDURE HdrBlockIO (SeqNo: INTEGER);
   LABEL 33;
   VAR RefNum:   Integer;
       Actual:   LongInt;
       Filename: Pathname;
       dateStr:  TTimeStr;
       timeStr:  TTimeStr;
       dummyErr: INTEGER;
       curTapeNumStr: NumberStr;

      FUNCTION ValidHdr: Boolean;
      BEGIN {ValidHdr}
         ValidHdr := False;
         WITH Header DO
            IF Id1=TapeId1 THEN
               IF Id2=TapeId2 THEN
                  IF Id3=TapeId3 THEN
                     IF Id4=TapeId4 THEN
                        IF Title=TapeTitle THEN ValidHdr := True;
      END; {ValidHdr}

   BEGIN
   IF trcFVolCtrl THEN WRITELN ('HdlBlockIO: seqNo is', seqNo:1);

   { read/write header }
   Filename := Concat(TapePathname, '-Header');
   IntToStr (seqNo, numStr);
   REPEAT                     { ask user to insert the tape }
     IF seqNo = 1
     THEN alertNum := 317
     ELSE BEGIN
       IF Direction = TapeToDisk
       THEN alertNum := 319
       ELSE alertNum := 318;
       ArgAlert (1, numStr);
       END;
33:  IF askAlert (flrAlert, alertNum) = 1 THEN AbortPTCopy (0);
     UpdateAll;
     TapeIO(err, RewindTape);
     IF err > 0 THEN
        BEGIN alertNum := 344;
        GOTO 33;
        END;
     UNTIL err <= 0;
   IF Direction = TapeToDisk THEN
      BEGIN                                           {read header from tape}
      IF trcFVolCtrl THEN WRITELN ('   tape to disk');
      Open(err, Filename, RefNum, [Dread]);
      IF err <= 0 THEN Read_Data(err, RefNum, Ord4(@Header), 512, Actual, Sequential, 0);
      Close_Object (dummyErr, RefNum);

      WITH Header DO                                  { verify header }
         BEGIN
         IF NOT (ValidHdr OR (FmtVersion = TapeFormatVer)) THEN
            BEGIN
            ArgAlert (1, numStr);
            alertNum := 347;
            TapeIO(dummyErr, RewindTape);  { rewind before 'remove tape' alert }
            GOTO 33;
            END;
         IF seqNo <> seqNbr THEN
            BEGIN
            IntToStr (Header.SeqNbr, curTapeNumStr);
            ParamAlert (curTapeNumStr, numStr, '');
            alertNum := 348;
            TapeIO(dummyErr, RewindTape);  { rewind before 'remove tape' alert }
            GOTO 33;
            END;
         IF seqNo = 1 THEN
            BEGIN                          { tell user the date on the tape }
            ArgAlert (1, Group);
            IF AskAlert (flrAlert, 354) = 1 THEN
               BEGIN
               alertNum := 319;
               TapeIO(dummyErr, RewindTape);  { rewind before 'remove tape' alert }
               GOTO 33;
               END;
            END;
         END;

      TapeIO(err, Read1TM);
      END {reading header}

   ELSE                                                     {Direction = DiskToTape}
      BEGIN                                                 {write header to the tape}
      IF trcFVolCtrl THEN WRITELN ('   disk to tape');

      { Check for an archive header.  If none retension the 'new' tape }
      Open(err, Filename, RefNum, [Dread, Dwrite]);
      IF err <= 0 THEN Read_Data(err, RefNum, Ord4(@Header), 512, Actual, Sequential, 0);
      TapeIO(dummyErr, RewindTape);
      IF ((err <= 0) AND ValidHdr) THEN WITH Header DO
         BEGIN
         IF (seqNo > 1) AND (Group = TD) AND (seqNbr < seqNo) THEN
            BEGIN
            Close_Object (dummyErr, RefNum);
            IntToStr (seqNbr, curTapeNumStr);
            ArgAlert(1, curTapeNumStr);
            alertNum := 352;
            TapeIO(dummyErr, RewindTape);  { rewind before 'remove tape' alert }
            GOTO 33;
            END;
         END
      ELSE
         BEGIN
         IF trcFVolCtrl THEN WRITELN ('   invalid hdr or unable to read(err ',err:1,')');
         WaitAlert (flrAlert, 349);
         TapeIO(err, RetensionTape);
         EndWaitAlert;
         UpDateAll;
         END;

      { write the header }
      IF trcFVolCtrl THEN WRITELN ('   writing the header');
      WITH Header DO
         BEGIN
         Id1 := TapeId1; Id2 := TapeId2; Id3 := TapeId3; Id4 := TapeId4;
         Title := TapeTitle;
         UserTitle := UserLabel;
         ProgVersion := Version;
         FmtVersion := TapeFormatVer;
         SeqNbr := SeqNo;
         TimeToStr (TRUE, 0, dateStr, timeStr);
         dateTime := CONCAT(dateStr,' ',timeStr);
         IF SeqNo = 1 THEN TD := dateTime;
         Group := TD;
         END;
      Write_Data (err, RefNum, Ord4(@Header), 512, Actual, Sequential, 0);
      Close_Object (dummyErr, RefNum);
      IF err <= 0 THEN TapeIO(err, WriteTMs);
      IF err > 0 THEN
         BEGIN
         alertNum := 344;
         TapeIO(dummyErr, RewindTape);  { rewind before 'remove tape' alert }
         GOTO 33;
         END;
      END; {writing header}

   err := 0;
   IF trcFVolCtrl THEN WRITELN ('   exit HdrBlockIO');
   END; {HdrBlockIO}

{*--------------------------------------------------------------------------------*}

  BEGIN
  IF trcFVolCtrl THEN WRITELN ('BackupPriam');

  DCplist.DCVersion := 2; {always}
  NbrOfTMs := 1;
  FOR i := 0 TO 511 DO Header.Block[i] := Chr(0);
  FOR i := 0 TO SIZEOF(UserLabel)-1 DO UserLabel[i] := Chr(0);
  IF sDevHdl = NIL
  THEN BEGIN
    direction := tapeToDisk;
    devHdl := dDevHdl;
    END
  ELSE BEGIN
    direction := diskToTape;
    devHdl := sDevHdl;
    END;

  { copy }
  DismountVol (devHdl^^.device, FALSE, FALSE);
  MountTape (err);
  SeqNo := 1;
  copyOk   := FALSE;
  REPEAT
     HdrBlockIO (seqNo);
     ParamAlert (devHdl^^.userNmHdl^^, numStr, Header.Group);
     IF Direction = DiskToTape
     THEN alertNum := 350
     ELSE alertNum := 351;
     WaitAlert (flrAlert, alertNum);

     Sched_Class (schedErr, FALSE);         { Permit background processes to run }
     IF SeqNo = 1
     THEN TapeIO(err, CopyTape)
     ELSE TapeIO(err, ResumeCopy);
     Sched_Class (schedErr, TRUE);
     IF err > 0 THEN AbortPTCopy (345);
     copyOK := NOT (err = resumable);

     IF Direction = DiskToTape THEN TapeIO(err, WriteTMs);
     TapeIO(err, RewindTape);
     SeqNo := SeqNo + 1;
     UNTIL copyOK;
  UnmountTape;

  JustMount (err, devHdl^^.device, sourceHdl, FALSE, FALSE);
  IF err <= 0
  THEN BEGIN
    IF Direction = DiskToTape
    THEN BEGIN                       { Set backup info }
      alertNum := 356;
      sFsInfo.DTVB := TimeStamp;
      sFsInfo.copy_Thread := sFsInfo.copy_Thread+1;
      PSet_Vol_Info (osErr, sDevPathname, sFsInfo);
      END
    ELSE alertNum := 355;
    ArgAlert (1, devHdl^^.userNmHdl^^);
    NoteAlert (flrAlert, alertNum);  { 'done...' }
    END;

  IF trcFVolCtrl THEN WRITELN ('   exit BackupPriam: err = ',err:1);
  END;

{------------------------------------------------------------------------}

{$S DmBackup }
  FUNCTION MasterCheck : BOOLEAN;

    FUNCTION ToolFound (pToolCatRec: PtrCatRec; pDfInfo: PtrFs_Info) : BOOLEAN;
    BEGIN
    {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
    IF trcFDocCtrl THEN WRITELN ('ToolFound: tool is ',pToolCatRec^.toolID:1);

    WITH pDfInfo^ DO
    IF protected AND master AND (machine_ID = 0)
    THEN BEGIN
      masterDfs := TRUE;
      ToolFound := NOT DeflowerMasterTool (pToolCatRID^.toolID, sDevHdl);
                                    { Abort if not deflowered            }
      END
    ELSE ToolFound := FALSE;

    IF trcFDocCtrl THEN WRITELN ('ToolFound');
    END;

  BEGIN
  IF trcFDocCtrl THEN WRITELN ('MasterCheck');

  masterDfs := FALSE;
  IF sDevHdl = NIL
  THEN MasterCheck := TRUE
  ELSE BEGIN
    Lookup (err, sDevPathname, dfInfo);     { Check for master disk           }
    MasterCheck := NOT ToolCheck (sourceHdl, diskCatRID, ToolFound);
    END;

  IF trcFDocCtrl THEN WRITELN ('   exit MasterCheck');
  END;

{------------------------------------------------------------------------}

{$S DmBackup }
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('BackupVol');

unlockDriver := FALSE;
IF dDevHdl = NIL
THEN BEGIN
  destHdl      := NIL;
  dDevName     := '';
  dDevPathname := '';
  END
ELSE BEGIN
  IF trcFVolCtrl THEN WRITELN ('   destination: ',dDevHdl^^.userNmHdl^^);
  destHdl := dDevHdl^^.volHdl;
  GetObjName (destHdl, diskCatRID, dUserVolName);
  dDevName := dDevHdl^^.nameHdl^^;
  dDevPathname := CONCAT('-',dDevHdl^^.nameHdl^^);
  END;
IF sDevHdl = NIL
THEN BEGIN
  sourceHdl    := NIL;
  sDevName     := '';
  sDevPathname := '';
  END
ELSE BEGIN
  IF trcFVolCtrl THEN WRITELN ('   source: ',sDevHdl^^.userNmHdl^^);
  sourceHdl := sDevHdl^^.volHdl;
  GetObjName (sourceHdl, diskCatRID, sUserVolName);
  sDevName := sDevHdl^^.nameHdl^^;
  sDevPathname := CONCAT('-',sDevHdl^^.nameHdl^^);
  END;

IF destHdl = bootVol
THEN BEGIN
  ParamAlert (sUserVolName, dUserVolName, '');
  StopAlert (flrAlert, 291);
  err := aborted;
  EXIT (BackupVol);
  END;

IF (sourceHdl = bootVol) AND (destHdl <> NIL)
THEN BEGIN                { lock down the destination device driver }
  WITH fsParams DO BEGIN
    gp_Parm := 0;
    command := gp;
    funct   := 4;
    MoveLeft (dDevName, parm_Array, LENGTH(dDevName)+1);
    parm1   := 1;
    END;
  Fs_Utilities (err, fsParams);
  unlockDriver := TRUE;
  END;

volActivity := actBackingUpDisk;
sinceDate := nullInt4;

IF NOT MasterCheck THEN GOTO 99;
IF UserAborted (err) THEN GOTO 99;

IF trcFVolCtrl THEN WRITELN ('   beginning actual backup');
err := 0;
IF dDevHdl <> NIL THEN Lookup (err, dDevPathname, dfInfo);
IF ErrorFound (warnError, 1125, err, dDevHdl)
THEN BEGIN
  err := aborted;
  EXIT (BackupVol);
  END;
IF sDevHdl <> NIL THEN Lookup (err, sDevPathname, sFsInfo);
IF ErrorFound (warnError, 1124, err, sDevHdl)
THEN BEGIN
  err := aborted;
  EXIT (BackupVol);
  END;

BindCopyDataSeg;

IF dDevHdl = NIL
THEN BEGIN                { Backing up a priam or diskette to self }
  IF sDevHdl^^.removable
  THEN BackupDiskette
  ELSE BackupPriam;
  GOTO 99;
  END
ELSE IF sDevHdl = NIL
THEN BEGIN                { Restoring the priam }
  BackupPriam;
  GOTO 99;
  END;

  { normal backup }
IF sFsInfo.vol_Size > dfInfo.vol_Size

  { Backup large disk to small disk     }
THEN BEGIN
  IF trcFVolCtrl THEN WRITELN ('   source is larger');
  IF sDevHdl^^.removable                 { If the source is removable...  }
  OR NOT dDevHdl^^.removable             { ... or the dest is not removable}
  THEN BEGIN                             { Don't backup                   }
    ParamAlert (dDevHdl^^.userNmHdl^^, sDevHdl^^.userNmHdl^^, '');
    StopAlert (flrAlert, 305);
    err := aborted;
    GOTO 99;
    END;
  IF sFsInfo.DTVB <> 0
  THEN BEGIN                             { Disk was previously backup up  }
    TimeToStr (FALSE, sFsInfo.DTVB, dateStr, timeStr);
    ParamAlert (sUserVolName, CONCAT(timeStr,' ',dateStr) ,'');
    CASE AskAlert (flrAlert, 232) OF     { 'Full or Partial backup?...'   }
      1: BEGIN
         err := aborted;
         GOTO 99;
         END;
      2: ;
      3: sinceDate := sFsInfo.DTVB;      { Partial backup                 }
      END;
    UpdateAll;
    END;
  IF UserAborted (err) THEN GOTO 99;
  DocBackup (err, sinceDate);
  END

  { Identical media                }
ELSE IF sFsInfo.vol_Size = dfInfo.vol_Size
  THEN BEGIN
    IF trcFVolCtrl THEN WRITELN ('   disks are of same type');
    TrackBackup (err);
    END

  { Backup small disk or diskette to large disk}
ELSE BEGIN
  IF trcFVolCtrl THEN WRITELN ('   source is smaller');
  UpdateVol;                             { Handles both backup and rebuild}
  END;

99:
IF unlockDriver THEN
  BEGIN
  fsParams.parm2 := fsParams.parm1;
  Fs_Utilities (err, fsParams);
  END;

UnbindCopyDataSeg;
volActivity := actNothingSpecial;
EndWaitAlert;
UpdateAll;
SetFadeDelay (FadeDelay);

IF trcFVolCtrl THEN WRITELN ('   exit BackupVol: sourceHdl = ',ORD(sourceHdl):1,
                             ', destHdl = ',ORD(destHdl):1,', err = ',err:1);
END;


{**************************************************************************}

{$S flrClose }

PROCEDURE DismountVol {device: Tdevice; eject: BOOLEAN; resume: BOOLEAN};

VAR devHdl:      TentryHdl;
    devName:     E_Name;
    err:         INTEGER;
    field:       TfieldVar;
    activeTools: BOOLEAN;
    volHdl:      TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('DismountVol: device = ',ORD(device.slot):1,
                             ', eject = ',ORD(eject):1);

field.fieldType := dDevice;              { Get the device entry            }
field.device := device;
GetEntry (dev, NIL, NIL, field, devHdl);

IF devHdl^^.volHdl = NIL                 { Bullet proofing                 }
THEN BEGIN                               { Doesn't appear to be a vol mounted}
  IF trcFVolCtrl THEN WRITELN ('   device entry has NIL volHdl');
  field.fieldType := vDevHdl;            { Check for a vol entry for device}
  field.devHdl := devHdl;
  GetEntry (vol, NIL, NIL, field, volHdl);
  IF volHdl <> NIL
  THEN BEGIN                             { Found one                       }
    IF trcFVolCtrl THEN WRITELN ('   Oops! found a vol entry');
    devHdl^^.volHdl := volHdl;           { Patch things up and try to go on}
    END
  ELSE BEGIN                             { We have no record but O/S might }
    IF trcFVolCtrl THEN WRITELN ('   no vol entry found for device either');
    ReleaseDisk (devHdl, eject);
    IF trcFVolCtrl THEN WRITELN ('   exit DismountVol: no volume on device');
    EXIT (DismountVol);
    END;
  END;

IF devHdl^^.volHdl^^.volState = sMounted
THEN BEGIN
  IF eject                          { Record the eject request        }
  THEN devHdl^^.volHdl^^.volState := sEjecting
  ELSE devHdl^^.volHdl^^.volState := sDismounting;
  TermTools (devHdl^^.volHdl, activeTools);{ Everything is OK, close normally}
  END
ELSE BEGIN                              { Foreign disk, cat won't kill   }
  KillEntry (devHdl^^.volHdl);
  devHdl^^.volHdl := NIL;
  END;

IF devHdl^^.volHdl <> bootVol
THEN ReleaseDisk (devHdl, eject)
ELSE FinishPowerDown;                    { Dismounts boot vol if ready   }

SetFadeDelay (FadeDelay);

IF trcFVolCtrl THEN WRITELN ('   exit DismountVol');
END;


{**************************************************************************}

{$S DmBackup }

FUNCTION GetNextDiskette {VAR err: INTEGER; devHdl, sVolHdl: TentryHdl;
                          VAR diskCt: INTEGER; xferOp: TuserOp ) : BOOLEAN};
LABEL  33, 99;
VAR dDevPathname: Pathname;
    dFsInfo:      Fs_Info;
    osErr:        INTEGER;
    saveDfName:   Pathname;
    timeRec:      LONGINT;
    volName:      FMaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('GetNextDiskette: device = ', devHdl^^.userNmHdl^^,
                             ' diskCt = ',diskCt:1);

GetNextDiskette := FALSE;
err := 1;

GetObjName (sVolHdl, diskCatRID, volName);
IF diskCt = 0
THEN timeRec := 0
ELSE timeRec := dtvb;
IF xferOp = opBackup
THEN BEGIN
  dDevPathname := CONCAT('-',devHdl^^.nameHdl^^);
  Lookup (osErr, dDevPathname, dFsInfo);
  dFsInfo.backup_VolID := volID;
  dFsInfo.copy_Thread := copyThread;
  dFsInfo.DTCC := dtvb;
  IF fullBackup
  THEN dFsInfo.volNum := diskCt
  ELSE dFsInfo.volNum := diskCt + incOffset;
  PSet_Vol_Info (osErr, dDevPathname, dFsInfo);
  RenameBackupVol (devHdl^^.volHdl, volName, diskCt, timeRec);
  END;

saveDfName := CONCAT('-',devHdl^^.nameHdl^^,'-',saveSpace);
ZapPassword (saveDfName);
Kill_Object (osErr, saveDfName);

IF NOT (devHdl^^.removable)
THEN GOTO 99;

REPEAT
33:
  AnotherDiskette (err, devHdl, xferOp, diskCt, 0, TRUE);
  CASE err OF
    0,
    fNewlyInited:  BEGIN
        err := SaveSomeSpace (devHdl);
        IF err > 0
        THEN BEGIN
          ParamAlert (devHdl^^.userNmHdl^^,'','');
          StopAlert (flrAlert, 218);        { 'Unuseable...'                 }
          UpdateAll;
          END;
        END;

    aborted,
    fUserAbort: BEGIN
        GetNextDiskette := FALSE;
        IF trcFVolCtrl THEN WRITELN ('   exit GetNextDiskette: err is ',err:1,
                                     ', diskCt = ',diskCt:1);
        GOTO 99;
        END;

    OTHERWISE BEGIN
        ParamAlert (devHdl^^.userNmHdl^^,'','');
        StopAlert (flrAlert, 218);            { 'Unuseable...'                 }
        UpdateAll;
        END;
    END;
  UNTIL err <= 0;

GetNextDiskette := TRUE;
diskCt := diskCt + 1;

99:
IF trcFVolCtrl THEN WRITELN ('   exit GetNextDiskette: err = ', err:1,
                             ', diskCt = ',diskCt:1);
END;


{**************************************************************************}

{$S  }

PROCEDURE InitVolCtrl;
VAR devHdl:      TentryHdl;
    devInfo:     Fs_Info;
    devPathname: Pathname;
    err:         INTEGER;
    fsParams:    Ut_Parmt;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
{ Init configuration information } { To be defined by the O/S}
IF trcFVolCtrl THEN WRITELN ('InitFVolCtrl');

  { Initialize module's globals }
bootOut := FALSE;
scrapTool := 0;
passwd := '';
volActivity := actNothingSpecial;

devHdl := bootVol;
devPathname := CONCAT ('-',devHdl^^.nameHdl^^);
Lookup (err, devPathname, devInfo);
IF NOT ErrorFound (fatalError, 943, err, devHdl) THEN;

IF devInfo.scavenge_Flag
THEN BEGIN
  devInfo.scavenge_Flag := FALSE;
  PSet_Vol_Info (err, devPathname,devInfo);
  IF ErrorFound (warnError, 950, err, devHdl) THEN ;
  END;

IF trcFVolCtrl THEN WRITELN ('   Opening catalog on device ', devHdl^^.nameHdl^^);
IF VerifyCat (devHdl)
THEN BEGIN
  OpenCat (err, devHdl);                    { Creates the bootvol entry        }
  IF err > 0
  THEN BEGIN
    IF AskAlert (flrAlert, 247) = 2         { 'Boot disk is broken...          }
    THEN BEGIN
      ParamAlert (devHdl^^.userNmHdl^^,'','');
      WaitAlert (flralert, 221);
      RecoverCat(err, devHdl);
      EndWaitAlert;
      END;
    END;
  END
ELSE err := 1;                              { Force a restart w/ another disk }

IF err > 0
THEN BEGIN                                  { Restart w/ another disk...      }
  ParamAlert (devHdl^^.userNmHdl^^,'','');
  NoteAlert (flrAlert, 212);
  IF alertError > 0 THEN WRITELN ('Alert err ',err:1,' in InitVolCtrl');
  HALT;
  END;

IF trcFVolCtrl THEN WRITELN ('   catalog opened');
bootVol := devHdl^^.volHdl;
bootVol^^.volState := sMounted;

EndWaitAlert;

IF trcFVolCtrl THEN WRITELN ('   exit InitFVolCtrl');
END;


{**************************************************************************}

{$S flrCat }

PROCEDURE MountVol {VAR err: INTEGER; device: Tdevice; VAR volHdl: TentryHdl};

VAR fsInfo:      Fs_Info;
    osErr:       INTEGER;
    volPathname: Pathname;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('MountVol');

JustMount (err, device, volHdl, TRUE, FALSE);{ Tell O/S about the new volume}
CASE err OF
  fNoErr: BEGIN                             { Mounted without error        }
      IF trcFVolCtrl THEN WRITELN ('   mounted w/o error');

         { check for lisaguide diskette }
      volPathname := CONCAT('-',volHdl^^.devHdl^^.nameHdl^^);
      Lookup (osErr, volPathname, fsInfo);
      IF trcFVolCtrl THEN IF err > 0 THEN WRITELN ('    osErr ',osErr:1,' looking up ',volPathname);
      DownShift (@fsInfo.volName);
      IF fsInfo.volName = lisaGuide THEN IF AskAlert (flrAlert, 293) = 1
      THEN BEGIN                            { Eject LisaGuide diskette     }
        UpdateAll;
        DismountVol (device, TRUE, FALSE);
        err := fNotMounted;
        END
      ELSE UpdateAll;
 (*** ResumeDocs (NIL);  ***)               { Startup needed volume tools  }
      END;
  fNewlyInited: BEGIN
      err := fNoErr;
      END;
  OTHERWISE BEGIN
      IF trcFVolCtrl THEN WRITELN ('   volume not mounted: err = ',err:1);
      END;
  END;
SetFadeDelay (FadeDelay);

IF trcFVolCtrl THEN WRITELN ('   exit MountVol: err = ',err:1);
END;


{**************************************************************************}

{$S flrCold }

PROCEDURE PowerItDown;
VAR
     err:           INTEGER;
     nextHdl:       TentryHdl;
     nothingActive: BOOLEAN;
     volHdl:        TentryHdl;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('PowerItDown');

IF volActivity = actPoweringDown
THEN BEGIN
  IF trcFVolCtrl THEN WRITELN ('   exit PowerItDown: already doing it');
  EXIT (PowerItDown);
  END;

volActivity := actPoweringDown;           { Flag for SonTerminated         }

TermTools (bootVol, nothingActive);       { Shut down the boot volume      }
IF nothingActive
THEN FinishPowerDown;                     { Only if no processes are running}

IF trcFVolCtrl THEN WRITELN ('   exit PowerItDown');
END;


{**************************************************************************}

{$S flrDskIn }

PROCEDURE ReinitializeVol {VAR err: INTEGER; device: Tdevice; VAR vol: TentryHdl};

VAR devHdl:   TentryHdl;
    diskCt:   INTEGER;
    diskName: FMaxStr;
    field:    TfieldVar;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('ReinitializeVol: device = ',ORD(device.slot):1);

field.fieldType := dDevice;
field.device := device;
GetEntry (dev, NIL, NIL, field, devHdl);
IF devHdl = NIL
THEN BEGIN
  IF ErrorFound (warnError, 930, nullErr, NIL) THEN err := fNotMounted;
  END
ELSE BEGIN
  ParamAlert (devHdl^^.userNmHdl^^,'','');
  WaitAlert (flrAlert, 215);  { 'Initializing...'            }
  ReleaseDisk (devHdl, FALSE);
  InitNewVol (err, devHdl, vol);
  SetFadeDelay (FadeDelay);
  IF err > 0
  THEN BEGIN
    CreateVolEntry (devHdl, sNoFileSystem, vol);
    ParamAlert (devHdl^^.userNmHdl^^,'','');
    IF AskAlert (flrAlert, 219) = 2 THEN err := 0;
    END;
  END;

IF trcFVolCtrl THEN WRITELN ('   exit ReinitializeVol: err = ',err:1);
END;


{**************************************************************************}

{$S flrClose }

PROCEDURE ReleaseDisk {devHdl: TentryHdl; eject: BOOLEAN};
LABEL 99;
VAR deviceName:  E_name;
    err:         INTEGER;

  PROCEDURE CantReleaseDisk;
  BEGIN
  {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
  IF trcFVolCtrl THEN WRITELN ('CantReleaseDisk');
  IF dbgFiler THEN WRITELN ('ERROR ',err:1,' trying to release disk ',
                            devHdl^^.userNmHdl^^);
  devHdl^^.devState := devOnline;
  IF eject THEN devHdl^^.objHdl := ORD(NIL);
  ArgAlert (1, devHdl^^.userNmHdl^^);
  StopAlert (flrAlert, 294);
  UpdateAll;
  EXIT (ReleaseDisk);
  IF trcFVolCtrl THEN WRITELN ('   exit CantReleaseDisk and ReleaseDisk');
  END;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('ReleaseDisk on ',devHdl^^.nameHdl^^,
                             ' eject is ',eject);

IF devHdl^^.volHdl <> NIL
THEN WITH devHdl^^ DO BEGIN                  { Close down the catalog       }
  IF volHdl^^.volState <> sDismounting       { Flag is only a default       }
  THEN eject := TRUE
  ELSE eject := FALSE;
  CloseCat (err, volHdl);                    { Kills the volume entry       }
  END;

IF trcFVolCtrl THEN WRITELN ('   doing unmount');
deviceName := devHdl^^.nameHdl^^;
IF UnmountVol (devHdl)
THEN BEGIN
  IF eject
  THEN BEGIN
    devHdl^^.objHdl := ORD(NIL);
    IF devHdl^^.removable
    THEN IF NOT EjectDiskette (deviceName) THEN CantReleaseDisk;
    END;
  devHdl^^.devState := devEmpty;
  END;

99:
IF trcFVolCtrl THEN WRITELN ('   exit ReleaseDisk');
END;


{**************************************************************************}

{$S flrDskOut }

PROCEDURE RepairVol {VAR err: INTEGER; device: Tdevice; VAR vol: TentryHdl};
LABEL 99;
VAR devHdl:    TentryHdl;
    field:     TfieldVar;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};
IF trcFVolCtrl THEN WRITELN ('RepairVol: ',ORD(device.slot):1);

vol := NIL;

field.fieldType := dDevice;
field.device := device;
GetEntry (dev, NIL, NIL, field, devHdl);
IF devHdl = NIL THEN IF ErrorFound (warnError, 927, nullErr, NIL)
THEN BEGIN
  err := aborted;
  GOTO 99;
  END;

ParamAlert (devHdl^^.userNmHdl^^,'','');
WaitAlert (flrAlert, 221);

ScavengeDevice (err, devHdl);
IF err <= 0
THEN JustMount (err, device, vol, FALSE, TRUE);
SetFadeDelay (FadeDelay);

IF vol <> NIL THEN IF vol^^.volState = sMounted
THEN BEGIN                                       { Disk was repaired      }
  ParamAlert (devHdl^^.userNmHdl^^,'','');
  NoteAlert (flrAlert, 241);
  UpdateAll;
  GOTO 99;
  END;

ParamAlert (devHdl^^.userNmHdl^^,'','');
IF AskAlert (flrAlert, 220) = 2                  { Disk was not repaired  }
THEN BEGIN
  CreateVolEntry (devHdl, sNoCatalog, vol);
  err := 0;
  END;
UpdateAll;

99:
IF trcFVolCtrl THEN WRITELN ('   exit RepairVol: err = ',err:1);
END;

{

 10-Jan-83  A4 Release
  2-Feb-83  JustMount: added InitOrRepair to improve 606/866 err handling.

 }


END.

