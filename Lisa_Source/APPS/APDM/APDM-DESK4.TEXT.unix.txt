{apdm/desk4.text 5-Dec-83} {Copyright 1983, Apple Computer Co.}

{Contains the dialog box specific routines for putting up a particular dialog box}

{**** Modification Log ****}
{Created the new file : 12/5/83}
{Multiple mods : 12/6/83 to 12/13/83}
{Splitting stored on/stored in line, adding ClipDiName call : 12/14/83}
{Cleaning up interface, setting real diInfo fields, does split doc info : 12/15/83}
{Added password checking, new password record defs, real button code : 12/20/83}
{Re-wrote most of the display code (no notepad, what a drag) : 12/30/83}
{GetToolName call : 1/25/84}
{Calls to reset password values, cleanup of password states : 3/14/84}

{**************************************************************************************************}
{**************************************************************************************************}
{$S flrAtt}
PROCEDURE AttCancelBtn;
{called when the 'Cancel' button is pushed in the password box, cleans up password stuff}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
ShowDiBtn(diPassword.cancelBtnPanel, TRUE{selected});

IF (diPassword.state = Verified) THEN
   diPassword.state := safe;

ProtAttDiBox;                 { make sure that everything is displayed correctly }

ResetPwdFields;

ShowDiBtn(diPassword.cancelBtnPanel, FALSE);
END; {of PROC AttCancelBtn}

{**************************************************************************************************}
PROCEDURE AttDoneBtn;
{called when the 'Done' button is pushed in the main dialog panel.  Dismisses the
 dialog box, should also check for inconsistant password change/set state }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
CASE (diPassword.state) OF
   Safe, Unprotected:
      BEGIN
      {verify that the post file is set correctly}
      IF (NOT VerifyPassword(diBox.obj^^.volHdl, diBox.obj^^.catRID)) THEN
         FixPassword(diBox.obj^^.volHdl, diBox.obj^^.catRID);
      END; {of CASE ITEM safe}
   OTHERWISE BEGIN END;
   END; {of CASE block}

StopDiBox;

END; {of PROC AttDoneBtn}

{**************************************************************************************************}
PROCEDURE AttEnterBtn;
{called when the 'Enter' button is pushed in the password panel of the dialog box.
 Sets the global password string to 'Delts' (for testing only).  Should eventually
 set the password value, check for validity, call SetObjPwd, etc.}

VAR
   err      : INTEGER;
   numStr   : NumberStr;
   tempStr  : FmaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
ShowDiBtn(diPassword.enterBtnPanel, TRUE{selected});

{set up name to use for the alert, we know that diBox.obj exists}
GetStrg (diPassword.iconName, tempStr);
QuoteName (tempStr);
ArgAlert (1, tempStr);

CASE (diPassword.state) OF
   safe:
      BEGIN
      IF GetPassField THEN
         BEGIN
         {get the password entered here and stuff into the old field}
         diPassword.old := diPassword.entered;
         Verify_Password (err, diPassword.path, diPassword.old);
         IF (err > 0) THEN
            BEGIN
            StopAlert (flrAlert, 327);
            ResetPwdFields;
            END
         ELSE
            BEGIN
            {old password has been verified}
            diPassword.state := verified;
            END; {of IF ELSE block}
         END; {of IF THEN block}
      END; {of CASE ITEM safe}

   Verified, Unprotected:               {  doc/tool, enter of new password }
      BEGIN
      IF GetPassField THEN
         BEGIN
         diPassword.new := diPassword.entered;
         IF (diPassword.state = Unprotected) THEN
            diPassword.old := '';
         SetObjPwd (err, diBox.obj^^.volHdl, diBox.obj^^.catRID, dipassword.old, diPassword.new);
         IF (err > 0) THEN
            BEGIN
            IF (NOT VerifyPassword(diBox.obj^^.volHdl, diBox.obj^^.catRID)) THEN
               FixPassword(diBox.obj^^.volHdl, diBox.obj^^.catRID)
            ELSE
               BEGIN
               IntToStr (err, numStr);
               ArgAlert (2, '1220/');
               ArgAlert (3, numStr);
               StopAlert (flrAlert, 325);
               END;
            ResetPwdFields;
            END
         ELSE
            BEGIN
            diBox.obj^^.password := TRUE;
            diPassword.passworded := TRUE;
            diPassword.validpasswd := TRUE;
            diPassword.state := safe;
            END;
         END {of IF THEN block}
      ELSE {getting the password failed}
         ResetPwdFields;
      END; {of CASE ITEM verified, unprotected}
   END; {of CASE block}

ProtAttDiBox;

ShowDiBtn(diPassword.enterBtnPanel, FALSE{not selected});

IF (diPassword.state = Verified) THEN
   BEGIN
   ClearDiField (diPassword.passwdPanel);
   {now make sure that the field is ready for typing}
   diPassword.passwdPanel^^.info.active := TRUE;
   diPassword.passwdPanel^^.selected := TRUE;
   diPassword.passwdPanel^^.changed := TRUE;
   END
ELSE
   ResetPwdFields;

END; {of PROC AttEnterBtn}

{**************************************************************************************************}
PROCEDURE AttNoPassBtn;

{procedure to be executed when the user is changing the password on a protected file and
 clicks on the 'No Password' button}

VAR
   err      : INTEGER;
   numStr   : NumberStr;
   tempStr  : FmaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC};

ShowDiBtn(diPassword.noPassBtnPanel, TRUE{selected});

{set up name to use for the alert, we know that diBox.obj exists}
GetStrg (diPassword.iconName, tempStr);
QuoteName (tempStr);
ArgAlert (1, tempStr);

{we know that the password state is (verified), otherwise button would not have
 been visible, so take it from there}
SetObjPwd (err, diBox.obj^^.volHdl, diBox.obj^^.catRID, dipassword.old, '');
IF (err > 0) THEN
   IF (NOT VerifyPassword(diBox.obj^^.volHdl, diBox.obj^^.catRID)) THEN
      FixPassword(diBox.obj^^.volHdl, diBox.obj^^.catRID)
   ELSE
      BEGIN
      IntToStr (err, numStr);
      ArgAlert (2, '1221/');
      ArgAlert (3, numStr);
      StopAlert (flrAlert, 333);
      END
ELSE
   BEGIN
   diBox.obj^^.password := FALSE;
   diPassword.state := UnProtected;
   END;

ProtAttDiBox;                 { make sure that everything is displayed correctly }

ResetPwdFields;

ShowDiBtn(diPassword.noPassBtnPanel, FALSE{not selected});

END; {of PROC AttNoPassBtn}

{**************************************************************************************************}
FUNCTION AttError {* myError, error: INTEGER) : BOOLEAN *};

{standard OS error check for attributes code}

VAR
   numStr   : NumberStr;
   tempStr  : FmaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN
   IF (error <> 0) THEN WRITELN ('[AttError], entry: error = ',error:1);

AttError := TRUE;          {make it a major error to start with}
IF (error <= 0) THEN
   AttError := FALSE
ELSE
   BEGIN
   IF (myError = AttCatError) THEN
      DisplayError (myError, error, diBox.obj^^.volHdl^^.devHdl)
   ELSE
      BEGIN                                  {display the error in a StopAlert}
      GetStrg (diBox.obj^^.nameHdl, tempStr);
      QuoteName (tempStr);
      ArgAlert (1, tempStr);
      IntToStr (myError, numStr);
      tempStr := CONCAT(numStr,'/');
      ArgAlert (2, tempStr);
      IntToStr (error, numStr);
      ArgAlert (3, numStr);
      StopAlert (flrAlert, 326);
      END;
   END;

END; {of FUNCTION AttError}

{**************************************************************************************************}
FUNCTION AttObjInfo {* obj: ObjectHandle; VAR diInfo: dialogInfo) : BOOLEAN *};

{loads diInfo with as much relevant information as possible, available from obj & the structures it
 references.  Returns TRUE only if no errors were encountered (ie. OS calls, etc).}

LABEL 99;

CONST
   {values for number of text lines in each area}
   CalcTop     = 2;
   CalcInfo    = 3;
   DiskTop     = 2;
   DiskInfo    = 4;
   DocTop      = 2;
   DocInfo     = 4;
   FolderTop   = 2;
   FolderInfo  = 3;
   PrefTop     = 2;
   PrefInfo    = 3;
   ToolTop     = 3;
   ToolInfo    = 3;
   TrashTop    = 2;
   TrashInfo   = 1;


VAR
   alertNum    : INTEGER;
   alertStr    : FmaxStr;
   catRec      : TcatRec;
   deviceName  : E_Name;
   diskFsInfo  : fs_Info;
   err         : INTEGER;
   fileInfo    : fs_Info;
   noDiskFiles : BOOLEAN;
   oldVersDisk : BOOLEAN;
   pName       : Pathname;
   tempDocHdl  : TentryHdl;
   tempStr     : FmaxStr;
   volName     : Pathname;
   wasSetAside : BOOLEAN;

{--------------------------------------------------------------------------------------------------}
PROCEDURE MakeToolName (kind: INTEGER; VAR path: PathName);

VAR
   entry    : E_Name;
   numStr   : NumberStr;
   prefix   : E_Name;
   tempId   : INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
CASE (kind) OF
   calcKind: tempId := calcTool;
   clockKind: tempId := clockTool;
   computerKind,
   comp2Kind: tempId := configTool;
   toolKind: tempId := obj^^.toolNumber;
   END; {of CASE block}
IntToStr (tempId, numStr);
path := CONCAT('-',obj^^.volHdl^^.devHdl^^.nameHdl^^);
Reset_Catalog (err, path);
IF AttError (AttOsError, err) THEN
   GOTO 99;
prefix := CONCAT('{T',numStr,'}obj');
Get_Next_Entry (err, prefix, entry);
IF AttError (AttOsError, err) THEN
   GOTO 99;
path := CONCAT(path,'-',entry);

IF trcAttribute THEN WRITELN ('   [MakeToolName], exit: tool pathname = ',path);
END; {of PROC MakeToolName}

{--------------------------------------------------------------------------------------------------}
PROCEDURE SetInChain;

LABEL 99;

VAR
   keepGoing   : BOOLEAN;
   nameStr     : FmaxStr;
   newcatRID   : TcatRID;
   newCatRec   : TcatRec;
   onSecond    : BOOLEAN;
   saveStr     : FmaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[SetInChain], entry');

newCatRID.uniqueId := catRec.parentId;
newCatRID.fatherId := 0;                  {don't give this value}
tempStr := '';
saveStr := '';
onSecond := FALSE;
keepGoing := TRUE;
WHILE (keepGoing) DO
   BEGIN
   GetCatRec (err, obj^^.volHdl, newcatRID, newCatRec);
   IF AttError(AttCatError, err) THEN
      BEGIN
      tempStr := '';
      GOTO 99;
      END;
   IF (newCatRec.objKind <> folderKind) THEN { must be a disk now, so bail out }
      keepGoing := FALSE
   ELSE
      BEGIN
      GetObjName (obj^^.volHdl, newCatRID, nameStr);
      ClipDiName (nameStr, 15, TRUE{all ready quoted});
      GetString (900, @alertStr);
      nameStr := CONCAT(alertStr,' ',nameStr,' ');
      {nameStr = 'in_"xxxxxx"_'}
      IF ((LENGTH(tempStr) + LENGTH(nameStr)) >= FmaxStrLen) THEN
         IF (onSecond) THEN
            keepGoing := FALSE
         ELSE
            BEGIN
            onSecond := TRUE;
            saveStr := tempStr;
            tempStr := nameStr;
            END
      ELSE
         tempStr := CONCAT(tempStr, nameStr);
         {tempStr = 'in_"xxxxxx"_in_"yyyyyyyy"_'}
      IF (keepGoing) THEN
         newCatRID.uniqueId := newCatRec.parentId;
      END; {of IF ELSE block}
   END; {of WHILE block}

99:
IF (saveStr <> '') THEN
   BEGIN
   diInfo.storeIn1 := NewStrg(saveStr);
   diInfo.storeIn2 := NewStrg(tempStr);
   diInfo.topLines := diInfo.topLines + 1;
   END
ELSE IF (tempStr <> '') THEN
   diInfo.storeIn1 := NewStrg(tempStr);

IF trcAttribute THEN WRITELN ('   [SetInChain], exit');
END; {of PROC SetInChain}

{--------------------------------------------------------------------------------------------------}
PROCEDURE SetSplit;

{is the object split? Could be doc/docpad/tool/calculator/clock.  Remember, must have set up
 diInfo.kindLbl1/2 first, otherwise bombs out...}

VAR
   count    : LongInt;
   labelRec : LabelFmt;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF (catRec.split <> nullInt2) THEN
   BEGIN
   diInfo.split := TRUE;
   diInfo.splitNum := catRec.split;
   Read_Label (err, pName, ORD(@labelRec), SizeOf(labelRec), count);
   IF AttError (AttOsError, err) THEN
      GOTO 99;
   diInfo.splitSize := labelRec.TotalSize;
   diInfo.infoLines := diInfo.infoLines + 1;
   IF (diInfo.kindLbl2 = nil) THEN
      tempStr := diInfo.kindLbl1^^
   ELSE
      tempStr := diInfo.kindLbl2^^;
   tempStr := COPY(tempStr,1,Length(tempStr)-1);   { clean off the '.' at the end }
   GetString (901, @alertStr);
   tempStr := CONCAT(tempStr,' ',alertStr);
   IF (diInfo.kindLbl2 = nil) THEN
      diInfo.kindLbl1 := NewStrg(tempStr)
   ELSE
      diInfo.kindLbl2 := NewStrg(tempStr);
   END
ELSE
   diInfo.split := FALSE;
END; {of PROC SetSplit}

{--------------------------------------------------------------------------------------------------}
PROCEDURE SetStoredOn;

{does Lookup, then does the StoredOn string for diInfo}

LABEL 33;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
noDiskFiles := TRUE;
IF (diInfo.kind IN [toolKind, calcKind, clockKind, computerKind, comp2Kind]) THEN
   BEGIN
   MakeToolName (diInfo.kind, pName);
   err := 0;
   END
ELSE IF (diInfo.kind IN [docKind, docPad]) THEN
   GetADocName(err, obj^^.CatRID.uniqueId, obj^^.toolNumber, obj^^.volHdl, pName)
ELSE IF (diInfo.kind IN [folderKind, folderPad]) THEN
   GetAFldrName(err, obj^^.CatRID.uniqueId, obj^^.volHdl, pName)
ELSE
   GOTO 33; {must be a disk or Wastebasket/scrap}

IF (err <> 0) THEN
   IF (err <> 848) THEN
      BEGIN
      IF AttError(AttOsError, err) THEN
         GOTO 99;
      END
   ELSE {must be a stationary pad, document, folder, folder pad with no files behind it}
ELSE {no error, has files found}
   noDiskFiles := FALSE;

GetObjName(obj^^.volHdl, diskCatRID, tempStr);
diInfo.storedOn := NewStrg(tempStr);

33:
END; {of PROC SetStoredOn}

{--------------------------------------------------------------------------------------------------}
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN
   BEGIN
   WRITELN ('[AttObjInfo], entry: obj handle = ',ORD(obj));
   WRITELN ('   kind: ',obj^^.kind:1,' w/size: ',obj^^.size:1);
   END; {of IF THEN block}

AttObjInfo := FALSE;

GetCatRec (err, obj^^.volHdl, obj^^.catRID, catRec);
IF AttError(AttCatError, err) THEN
   GOTO 99;

tempStr := obj^^.nameHdl^^;
IF (tempStr = '') THEN
   tempStr := ' ';                  { add a space to a null length icon name }
diInfo.name := NewStrg(tempStr);

WITH diInfo DO
   BEGIN
   kind := obj^^.kind;
   size := obj^^.size;
   created := obj^^.created;
   storedOn := nil;
   storeIn1 := nil;
   storeIn2 := nil;
   kindLbl1 := nil;
   kindLbl2 := nil;
   SetStoredOn;               { sets up storedOn info }

   IF (NOT noDiskFiles) THEN
      BEGIN
      diPassword.path := pName;
      LookUp (err, pName, fileInfo);
      IF AttError(AttOsError, err) THEN
         GOTO 99;                         {*** bail out to end ***}
      modified := fileInfo.DTM;
      END {of IF THEN block}
   ELSE
      BEGIN
      {no disk file behind object, so set modified to created}
      modified := created;
      diPassword.path := '';
      END;

   {now set up for the old-disk flag check}
   volName := CONCAT('-',obj^^.volHdl^^.devHdl^^.nameHdl^^);
   IF trcAttribute THEN WRITELN ('   disk pathname = ',volName);
   LookUp (err, volName, diskFsInfo);
   IF AttError(AttOsError, err) THEN
      GOTO 99;                         {*** bail out to end ***}
   IF (diskFsInfo.fsversion < currentFsVersion) THEN
      oldVersDisk := TRUE
   ELSE
      oldVersDisk := FALSE;

   IF (kind IN [folderKind, calcKind, clockKind, toolKind, docKind]) THEN
      BEGIN
      {set up objState value}
      protected := FALSE;     {until proven otherwise}
      wasSetAside := FALSE;
      IF (kind = docKind) THEN
         IF (obj^^.wasOpened) THEN
            BEGIN
            tempDocHdl := WindowToDocEntry(obj^^.objWindow);
            IF (tempDocHdl <> nil) THEN
               {object is a doc w/window that was opened previously}
               IF (tempDocHdl^^.state IN [opened, toolOpened]) THEN
                  wasSetAside := TRUE;
            END;
      IF (oldVersDisk) THEN
         objState := oldDisk
      ELSE IF (noDiskFiles) THEN
         objState := noFiles
      ELSE IF (wasSetAside) THEN
         BEGIN
         objState := setAside;
         protected := fileInfo.passwd_present;
         END
      ELSE
         BEGIN
         objState := protectable;
         protected := fileInfo.passwd_present;
         END;
      END {of IF THEN block}
   ELSE
      BEGIN
      {the object isn't a protectable entity}
      objState := notProt;
      protected := FALSE;
      END;

   CASE kind OF
      profileKind, diskKind, disk1Kind, disk2Kind, drawerKind, priamKind:
         BEGIN
         topLines := DiskTop;
         infoLines := DiskInfo;
         IF (obj^^.volHdl = bootVol) THEN
            {'startup'}
            GetString (949, @tempStr)
         ELSE
            GetString(902, @tempStr);
         tempStr := CONCAT(tempstr,' ');
         kindLbl1 := NewStrg(tempStr);
         {'is the (startup) disk attached to the upper connector, expansion slot 3'}
         kindLbl2 := obj^^.volHdl^^.devHdl^^.userNmHdl;
         backedUp := diskFsInfo.dtvb;
         free := diskFsInfo.freeCount;
         size := diskFsInfo.fs_size;      {over-ride the size}
         version := diskFsInfo.fsversion;
         END; {of CASE ITEM profileKind, ..}

      folderKind, folderPad:
         BEGIN
         topLines := FolderTop;
         infoLines := FolderInfo;
         IF (kind = folderKind) THEN
            alertNum := 903
         ELSE
            alertNum := 904;
         GetString (alertNum, @alertStr);
         kindLbl1 := NewStrg(alertStr);
         SetInChain;
         SetSplit;
         END; {of CASE ITEM folderKind}

      trashKind, clipBdKind:
         BEGIN
         topLines := TrashTop;
         infoLines := TrashInfo;
         CASE (kind) OF
            trashKind: alertNum := 905;
            clipBdKind: alertNum := 906;
            END; {of CASE block}
         GetString (alertNum, @alertStr);
         kindLbl1 := NewStrg(alertStr);
         END; {of CASE ITEM trashKind}

      calcKind, clockKind:
         BEGIN
         topLines := CalcTop;
         infoLines := CalcInfo;
         version := fileInfo.build_info.revision_level;
         CASE (kind) OF
            calcKind: alertNum := 907;
            clockKind: alertNum := 908;
            END; {of CASE block}
         GetString (alertNum, @alertStr);
         kindLbl1 := NewStrg(alertStr);
         SetInChain;
         SetSplit;
         END; {of CASE ITEM calcKind}

      computerKind,
      comp2Kind:  { preferences }
         BEGIN
         topLines := PrefTop;
         infoLines := PrefInfo;
         {now make sure no 'stored on: ...' line for attributes box}
         storedOn := nil;
         GetString (909, @alertStr);
         kindLbl1 := NewStrg(alertStr);
         version := fileInfo.build_info.release_number;
         END; {of CASE ITEM computerKind, comp2Kind}

      toolKind:
         BEGIN
         topLines := ToolTop;
         infoLines := ToolInfo;
         version := fileInfo.build_info.revision_level;
         {get the 'LisaWrite' string}
         GetToolName (err, obj^^.toolNumber, obj^^.volHdl^^.devHdl, tempStr);
         IF AttError(AttCatError, err) THEN
            GOTO 99;
         GetString (960, @alertStr);
         tempStr := CONCAT(alertStr,' ',tempStr);
         GetString (910, @alertStr);
         tempStr := CONCAT(tempStr,alertStr);
         kindLbl1 := NewStrg (tempStr);
         SetInChain;
         SetSplit;
         END; {of CASE ITEM toolKind}

      docKind, docPad:
         BEGIN
         topLines := DocTop;
         infoLines := DocInfo;
         GetToolName (err, obj^^.toolNumber, obj^^.volHdl^^.devHdl, tempStr);
         IF AttError(AttCatError, err) THEN
            GOTO 99;
         IF (kind = docKind) THEN
            BEGIN
            GetString (940, @alertStr);
            alertNum := 911;
            END
         ELSE
            BEGIN
            GetString(959, @alertStr);
            alertNum := 912;
            END;
         tempStr := CONCAT(alertStr,' ',tempStr);
         GetString (alertNum, @alertStr);
         tempStr := CONCAT(tempStr, alertStr);
         kindLbl1 := NewStrg (tempStr);
         SetInChain;
         SetSplit;
         END; {of CASE ITEM docKind}

      OTHERWISE            {unknown object type}
         BEGIN
         topLines := 1;
         infoLines := 1;
         tempStr := 'is an unknown icon object.';
         kindLbl1 := NewStrg (tempStr);
         END; {of CASE ITEM OTHERWISE}

      END; {of CASE block}
   END; {of WITH block}
AttObjInfo := TRUE;              { made it to here without any problems, so go for it }

99:
IF trcAttribute THEN WRITELN ('   [AttObjInfo], exit');
END; {of PROC AttObjInfo}

{**************************************************************************************************}
PROCEDURE BreakInTwo {* source: FmaxStr; maxSize: INTEGER; VAR firstStr, secondStr: FmaxStr *};

{takes the source string and splits into two parts (on a space character), with the first part
 shorter in length than maxSize}

VAR
   tempStr  : FmaxStr;
   spaceLoc : INTEGER;
   breakLoc : INTEGER;
   keepLooking : BOOLEAN;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
tempStr := source;
spaceLoc := 0;
breakLoc := 0;
keepLooking := TRUE;
WHILE (keepLooking) DO
   BEGIN
   spaceLoc := POS (' ',source);
   IF (spaceLoc + breakLoc > maxSize) OR (spaceLoc = 0) THEN
      keepLooking := FALSE
   ELSE
      BEGIN
      breakLoc := breakLoc + spaceLoc;
      tempStr := COPY (tempStr, spaceLoc + 1, Length(tempStr) - spaceLoc);
      END;
   END; {of WHILE block}
IF (breakLoc <= 1) THEN
   BEGIN
   firstStr := source;
   secondStr := '';
   END
ELSE
   BEGIN
   firstStr := COPY (source, 1, breakLoc - 1);
   secondStr := COPY (source, breakLoc + 1, Length(source) - breakLoc);
   END;

END; {of PROC BreakInTwo}

{**************************************************************************************************}
PROCEDURE GetADocName {* VAR error: INTEGER; selfIdent: IdType; toolIdent: tToolId; volHdl: TEntryHdl;
             VAR path: Pathname *};

{If ok, pathname is set to the OS pathname for some part of the object,
 eg. -slot3chan1-(D114T6)$R might be returned  if the $R extension file was the
 first one found on slot3chan1}

LABEL 99;

VAR
   docName  : E_Name;
   entry    : E_Name;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
error := 0;
BuildDocName (selfident, toolIdent, docName);
path := CONCAT('-',volHdl^^.devHdl^^.nameHdl^^);
Reset_Catalog (error, path);
IF (error > 0) THEN
   GOTO 99;
Get_Next_Entry (error, docName, entry);
IF (error > 0) THEN
   GOTO 99;
path := CONCAT(path,'-',entry);

99:
END; {of Proc GetADocName}

{**************************************************************************************************}
PROCEDURE GetAFldrName {* VAR error: INTEGER; selfIdent: IdType; volHdl: TEntryHdl;
                          VAR path: Pathname *};
{If ok, pathname is set to the OS pathname for the Folder, eg. -slot3chan1-(F118) might be returned}

VAR
   entry    : E_Name;
   prefix   : E_Name;
   tempNum  : NumberStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
error := 0;
IntToStr (selfIdent, tempNum);
prefix := CONCAT('{F',tempNum,'}');
path := CONCAT('-',volHdl^^.devHdl^^.nameHdl^^);
Reset_Catalog (error, path);
IF (error > 0) THEN
   BEGIN
   path := '';
   EXIT (GetAFldrName);
   END;

Get_Next_Entry (error, prefix, entry);
IF (error > 0) THEN
   BEGIN
   path := '';
   EXIT (GetAFldrName);
   END
ELSE
   BEGIN
   path := CONCAT(path,'-',entry);
   error := 0;
   END;

END; {of Proc GetAFldrName}

{**************************************************************************************************}
FUNCTION GetPassField {* : BOOLEAN *};

VAR
   goodPasswd  : BOOLEAN;
   index       : INTEGER;
   tempChar    : CHAR;
   tempPass    : FmaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
GetPassField := FALSE;
WITH diPassword DO
   GetFldStr (passwdPanel^^.info.fieldHdl, passwdPanel^^.info.fStateHdl, tempPass);
IF (LENGTH (tempPass) = 0) THEN
   BEGIN
   diPassword.entered := '';
   EXIT (GetPassField);
   END {of ELSE THEN block}
ELSE
   BEGIN
   goodPasswd := TRUE;
   FOR index := 1 to LENGTH(tempPass) DO
      BEGIN
      tempChar := tempPass[index];
      IF ((ORD(tempChar) < ORD('!')) OR (ORD(tempChar) = 127)) THEN
         goodPasswd := FALSE;
      END; {of FOR block}
   IF (NOT goodPasswd) THEN
      BEGIN
      diPassword.entered := '';
      StopAlert (flrAlert, 332);
      END
   ELSE
      BEGIN
      diPassword.entered := tempPass;
      GetPassField := TRUE;
      END;
   END; {of IF ELSE block}

END; {of FUNC GetPassField}

{**************************************************************************************************}
{$S flrDm1 }
FUNCTION GetPassword {* volHdl: TEntryHdl; CatRID: TCatRID; VAR passwd: E_Name) : BOOLEAN *};

{ Displays the password dialog box, queries the user, tests the entered password for validity.
  If the password is good, sets password and returns TRUE; if bad or the user decides to 'Cancel'
  the password dialog, the password is set to nil and the function returns FALSE.  The password
  is tested with the OS Valid_Password call.}

LABEL 99;

VAR
   catRec   : TcatRec;
   err      : INTEGER;
   errorFree : BOOLEAN;
   savePort : GrafPtr;              { temporary storage for the Filer grafPort }

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[GetPassword], entry');

{ set up drawing to the dialog window }
GetPort (savePort);
SetPort (dialogFolder);

{do early password checking}
GetPassword := FALSE;

GetCatRec (err, volHdl, CatRID, catRec);
IF (err > 0) THEN
   GOTO 99;

IF (CatRec.props[iconPassWd] <> TRUE) THEN
   BEGIN
   GetPassword := TRUE;
   passwd := '';
   GOTO 99;
   END;

IF NOT (CatRec.objKind IN [docKind, folderKind, toolKind, calcKind, clockKind]) THEN
   BEGIN
   passwd := '';
   GOTO 99;
   END;

InitDiBox;                          { initialize a dialog box }
SetPassDiBox (volHdl, catRec, errorFree);    { then set up the panels for it }
IF (NOT errorFree) THEN             { bailing out, error in setting up things }
   GOTO 99;
CloseDiBox;                         { wrap around the panel pointers, draw the picture }
UseDiBox;                           { handle events, etc. }
RmvDiBox;                           { then take it down }

IF (diPassword.entered <> '') THEN  { user entered a valid password (was checked and everything) }
   BEGIN
   GetPassword := TRUE;
   passwd := diPassword.entered;
   END;

99:
SetPort(savePort);                  { reset the filer port }

IF trcAttribute THEN WRITELN ('[GetPassword], exit');
END; {of PROC GetPassword}

{**************************************************************************************************}
{$S flrAtt}
PROCEDURE InitPwdFields;
{resets the diPassword record fields to a null state}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
WITH diPassword DO
   BEGIN
   state       := noProt;
   oldState    := noProt;
   old         := '';
   new         := '';
   entered     := '';
   path        := '';
   iconName    := nil;
   enterBtnPanel := nil;
   cancelBtnPanel := nil;
   noPassBtnPanel := nil;
   passwdPanel := nil;
   pwdLine1    := nil;
   upwdLine1   := nil;
   pwdinit     := nil;
   pwdVerified := nil;
   upwdinit    := nil;
   validPasswd := FALSE;
   passworded  := FALSE;
   END; {of WITH block}
END; {of PROC InitPwdFields}

{**************************************************************************************************}
PROCEDURE PassCancelBtn;

{called if user 'pushed' the 'Cancel' button in the password dialog box.  Should set password flag
 to nil (for testing in main GetPassword routine)}

VAR
   err   : INTEGER;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[PassCancelBtn], entry');

ResetPwdFields;

StopDiBox;

IF trcAttribute THEN WRITELN ('   [PassCancelBtn], entry');
END; {of PROC PassCancelBtn;

{**************************************************************************************************}
PROCEDURE PassEnterBtn;
{password is entered (either through the user typing <Return>, <Enter>
 or pushing the 'Enter' button).}

LABEL    99;

VAR
   err      : INTEGER;
   tempStr  : FmaxStr;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[PassEnterBtn], entry');

ShowDiBtn (diPassword.enterBtnPanel, TRUE{selected});

IF (NOT GetPassField) THEN
   GOTO 99;

Verify_Password (err, diPassword.path, diPassword.entered);
IF (err > 0) THEN
   BEGIN
   ResetPwdFields;
   GetStrg (diPassword.iconName, tempStr);
   ArgAlert (1, tempStr);
   StopAlert (flrAlert, 327);
   END
ELSE
   StopDiBox;

99:
ShowDiBtn (diPassword.enterBtnPanel, FALSE{not selected});
IF InDialog THEN
   SelDiField(diPassword.passwdPanel, TRUE{draw now});

IF trcAttribute THEN WRITELN ('   [PassEnterBtn], exit');
END; {of PROC PassEnterBtn;

{**************************************************************************************************}
PROCEDURE ProtAttDiBox;

{makes sure that the correct panels in the protection box are visible, based on diPassword.state}

LABEL 99;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF (diPassword.state = diPassword.oldState) THEN
   GOTO 99;                         {**** bail out, nothing has changed since last call to ProtAttDiBox}

WITH diPassword DO
   BEGIN
   CASE state OF
      safe:       {previous state = [verified, unprotected]}
         BEGIN
         CASE diPassword.oldState OF
            Verified:
               BEGIN
               pwdVerified^^.visible := FALSE;
               pwdVerified^^.changed := TRUE;
               noPassBtnPanel^^.visible := FALSE;
               noPassBtnPanel^^.changed := TRUE;
               END; {of CASE ITEM Verified}
            Unprotected:
               BEGIN
               upwdLine1^^.visible := FALSE;
               upwdLine1^^.changed := TRUE;
               upwdInit^^.visible := FALSE;
               upwdInit^^.changed := TRUE;
               END; {of CASE ITEM Unprotected}
            NoProt:
               BEGIN
               END;
            OTHERWISE
               BEGIN
               WRITELN ('ERROR...Bad passwd state, new = ',ORD(diPassword.state),
                        ', old = ',ORD(diPassword.oldState));
               END;
            END; {of CASE block}

         pwdLine1^^.visible := TRUE;
         pwdLine1^^.changed := TRUE;
         pwdInit^^.visible := TRUE;
         pwdInit^^.changed := TRUE;
         END; {of CASE ITEM Safe}

      Verified:   {previous state = [safe]}
         BEGIN
         CASE (diPassword.oldState) OF
            Safe:
               BEGIN
               pwdInit^^.visible := FALSE;
               pwdInit^^.changed := TRUE;
               END;
            NoProt:
               BEGIN
               END;
            OTHERWISE
               BEGIN
               WRITELN ('ERROR...Bad passwd state, new = ',ORD(diPassword.state),
                        ', old = ',ORD(diPassword.oldState));
               END;
            END; {of CASE block}

         pwdVerified^^.visible := TRUE;
         pwdVerified^^.changed := TRUE;
         noPassBtnPanel^^.visible := TRUE;
         noPassBtnPanel^^.changed := TRUE;
         END;

      Unprotected:   {previous state = [verified, unprotected]}
         BEGIN
         CASE (diPassword.oldState) OF
            Verified:   {selecting 'no password' after current password was verified}
               BEGIN
               pwdLine1^^.visible := FALSE;
               pwdLine1^^.changed := TRUE;
               pwdVerified^^.visible := FALSE;
               pwdVerified^^.changed := TRUE;
               noPassBtnPanel^^.visible := FALSE;
               noPassBtnPanel^^.changed := TRUE;
               END;
            NoProt, Unprotected:
               BEGIN
               END;
            OTHERWISE
               BEGIN
               WRITELN ('ERROR...Bad passwd state, new = ',ORD(diPassword.state),
                        ', old = ',ORD(diPassword.oldState));
               END;
            END; {of CASE block}

         upwdLine1^^.visible := TRUE;
         upwdLine1^^.changed := TRUE;
         upwdInit^^.visible := TRUE;
         upwdInit^^.changed := TRUE;
         END;

      NoProt:        {not a protectable object}
         BEGIN
         END;
      END; {of CASE block}
   END; {of WITH block}

diBox.drawMode := DiErase;
ShowDiBox;  { erase unwanted labels }
diBox.drawMode := DiNormal;
ShowDiBox;  { draw new labels }

diPassword.oldState := diPassword.state;  { reset the changed marker }

99:
END; {of PROC ProtAttDiBox}

{**************************************************************************************************}
PROCEDURE ResetPwdFields;
{clears the password field, resets the diPassword strings}

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
WITH diPassword DO
   BEGIN
   entered := '';
   validPasswd := FALSE;
   passworded := (state IN [Safe, Verified]);
   IF (state = Verified) THEN
      BEGIN
      state := Safe;
      ProtAttDiBox;           {redisplay the correct panels}
      END;
   ClearDiField(passwdPanel);
   IF (passwdPanel <> nil) THEN
      IF (passwdPanel^^.info.active) THEN
         SelDiField (passwdPanel, TRUE{draw it})
      ELSE
         BEGIN
         {password panel no longer active, so reset the string entries}
         old := '';
         new := '';
         END;
   END;
END; {of PROC ResetPwdFields}

{**************************************************************************************************}
PROCEDURE SetAttDiBox {* obj: ObjectHandle; VAR noError: BOOLEAN *};

{Sets up the panels for the attribute dialog box, also the size of box.}
{noError = TRUE => OK to show dialog box, otherwise bail out}
{Note: diBox.firstPanel always points to the first panel in the panel list, lastPanel points to the
 last one (amazing how that works).  ThePanel always points to the current working panel, the one
 that we're stuffing with data.  The call to AddDiPanel places a new panel in the diBox panel list,
 sets lastPanel correctly, then returns a handle pointing to this new last panel.}

LABEL 99;                           { end of procedure jump position }

CONST

   { Panel location constants }
   HalfWayH       = 360;      { 1/2 of total screen width }
   PixPerLine     = 15;       { number of vertical pixels to offset for every line of text }
   ProtHeight     = 120;      { height of the protection box if the object is protectable }
   MsgHeight      = 105;      { Protection box height with a message in it (6 lines of text) }
   NoProtHeight   = 45;       { TopGapV + BotGapV (size of box with one line of text) }
   TopGapV        = 20;       { gap between dividing line and first line of text that follows it }
   BotGapV        = 10;       { gap between last line of text (or bottom of box) and next dividing line }
   BtnOffV        = 10;       { extra vertical gap between two lines if second line is a button }
   FldOffV        = 10;       { extra gap between two lines if second line is a field }

   { Information box constants }
   {horizontal offsets are from 0, vertical offsets are from topHeight}
   InfoRecLeft    = 10;
   InfoRecRight   = 360;

   {text offsets (horiz) inside of box, offset from the left side of the box}
   LeftColH = 10;
   RiteColH = 170;      { start of second column of numbers }

   { Protection box offsets }
   {horizontal offsets are from 0, vertical offsets are from topHeight}
   ProtRecLeft    = 370;            { less than 2/3rds of the screen }
   ProtRecRight   = 710;

   {horizontal offsets from ProtRecLeft}
   ProtNamH       = 10;

VAR
   alertNum : INTEGER;              { used for calls to GetString }
   alertStr : Str255;               { ditto }
   currentV : INTEGER;              { keeps track of the text line position }
   diInfo   : dialogInfo;           { information about the object }
   nameStr  : FmaxStr;              { object name string }
   topHeight   : INTEGER;           { height of the top portion of the dialog box }
   botHeight   : INTEGER;           { height of the bottom portion of the dialog box }
   topWidth : INTEGER;              { width of top of box }
   tempHeight  : INTEGER;
   tempstr  : FmaxStr;              { string used for temporary storage of text }
   tempLoc  : Point;                { temporary location of panel }
   tempLoc2 : Point;                { for line drawing (the other endpoint }
   tempProc : TProc;
   tempRect : rect;
   thePanel : PanelHandle;          { the current panel being stuffed with the right values }

{forward inner procedure/function declarations}
PROCEDURE SetAttProt;
  FORWARD;

{--------------------------------------------------------------------------------------------------}
PROCEDURE SetAttInfo;

VAR
   garbage  : INTEGER;     { so compiler doesn't flame out on the extra nested procedures }

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetDisk (postH, postV : INTEGER);

   {draws labels for top panel of an attributes dialog box for a disk object.  Should eventually
    do the title line as well.}

   VAR
      dateStr  : TTimeStr;
      sizeStr  : NumberStr;
      timeStr  : TTimeStr;

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   IF trcAttribute THEN WRITELN ('[SetDisk], entry');

   currentV := postV + TopGapV;

   {first the free blocks}
   SetPt (tempLoc, postH + LeftColH, currentV);
   IntToStr (diInfo.free, sizeStr);
   GetString (913, @alertStr);
   tempStr := CONCAT(alertStr,' ', sizeStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   {now the Total blocks}
   SetPt (tempLoc, postH + LeftColH, currentV);
   GetString (914, @alertStr);
   IntToStr (diInfo.size, sizeStr);
   tempStr := CONCAT(alertStr,' ', sizeStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   {next the file system version}
   SetPt (tempLoc, postH + LeftColH, currentV);
   GetString (915, @alertStr);
   IntToStr (diInfo.version, sizeStr);
   tempStr := CONCAT(alertStr,' ', sizeStr);
   IF (diInfo.version < currentFSversion) THEN
      BEGIN
      GetString(950, @alertStr);
      tempStr := CONCAT(tempStr,' ',alertStr);
      END;
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   {now the backed up string}
   SetPt (tempLoc, postH + LeftColH, currentV);
   GetString (916, @tempStr);
   IF (diInfo.backedUp = 0) THEN
      {Backed up : 'Never'}
      BEGIN
      GetString (706, @dateStr);
      tempStr := CONCAT(tempStr,' ',dateStr);
      END
   ELSE
      BEGIN
      TimeToStr(FALSE, diInfo.backedUp, dateStr, timeStr);
      tempStr := CONCAT(tempStr,' ',timeStr,' ',dateStr);
      END;
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});

   IF trcAttribute THEN WRITELN ('[SetDisk], entry');
   END; {of PROC SetDisk}

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetNoInfo (postH, postV : INTEGER);

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   SetPt (tempLoc, postH + LeftColH, postV + TopGapV);
   GetString (918, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});

   END; {of PROC SetNoInfo}

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetNotDisk (postH, postV : INTEGER);

   {draws all the info box text for tools, docs, folders, pads}

   VAR
      dateStr  : TTimeStr;
      sizeStr  : NumberStr;
      timeStr  : TTimeStr;

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   IF trcAttribute THEN WRITELN ('[SetNotDisk], entry');

   currentV := postV + TopGapV;

   {first the created info}
   SetPt (tempLoc, postH + LeftColH, currentV);
   TimeToStr(FALSE, diInfo.created, dateStr, timeStr);
   GetString (919, @alertStr);
   tempStr := CONCAT (alertStr,' ',timeStr,' ',dateStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   {next the 'modified' or 'Version' field}
   SetPt (tempLoc, postH + LeftcolH, currentV);
   IF (obj^^.kind IN [toolKind, calcKind, clockKind]) THEN
      BEGIN
      GetVersion (diInfo.version, tempStr);
      GetString (920, @alertStr);
      tempStr := CONCAT (alertStr,' ',tempStr);
      END {of IF THEN block}
   ELSE
      BEGIN
      TimeToStr(FALSE, diInfo.modified, dateStr, timeStr);
      GetString (921, @alertStr);
      tempStr := CONCAT (alertStr,' ',timeStr,' ',dateStr);
      END; {of IF ELSE block}
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   {next the size}
   SetPt (tempLoc, postH + LeftColH, currentV);
   IntToStr (diInfo.size, sizeStr);
   IF (diInfo.split) THEN
      alertNum := 922
   ELSE
      alertNum := 923;
   GetString (alertNum, @alertStr);
   tempStr := CONCAT(alertStr,' ',sizeStr);
   GetString (924, @alertStr);
   tempStr := CONCAT (tempStr,' ',alertStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});

   {maybe the 'split document/tool' field}
   IF (diInfo.split) THEN
      BEGIN
      thePanel := AddDiPanel;
      currentV := currentV + PixPerLine;
      {tempLoc.h is already set correctly}
      tempLoc.v := currentV;
      IntToStr (diInfo.splitSize, sizeStr);
      GetString (925, @tempStr);
      GetString (924, @alertStr);
      tempStr := CONCAT (tempStr,' ',sizeStr,' ',alertStr);
      SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});

      currentV := currentV + PixPerLine;

      thePanel := AddDiPanel;
      SetPt (tempLoc, postH + LeftColH, currentV);
      IntToStr (ABS(diInfo.splitNum), sizeStr);
      GetString (926, @alertStr);
      tempStr := CONCAT(alertStr,' ',sizeStr);
      IF (diInfo.splitNum < 0) THEN                { negative => last piece }
         BEGIN
         GetString (927, @alertStr);
         tempStr := CONCAT(tempStr,' ',alertStr);
         END;
      SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
      END; {of IF THEN block}

   IF trcAttribute THEN WRITELN ('[SetNotDisk], exit');
   END; {of PROC SetNotDisk}

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetPrefInfo (postH, postV : INTEGER);

   {takes care of info for the preferences box}

   VAR
      err         : INTEGER;
      firstPeriod : INTEGER;           { location of first period in version string }
      machineNum  : LongInt;           { From call to get the machine serial number }
      preRelease  : BOOLEAN;           { TRUE => pre-release version number }
      secondPeriod: INTEGER;           { location of second period in version string }
      tempNum     : NumberStr;
      testStr     : FmaxStr;           { for parsing the version string }

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   currentV := postV + TopGapV;

   Get_Serial_No (err, machineNum);
   IF (err <= 0) THEN
      IntToStr(machineNum, tempNum)
   ELSE
      tempNum := '0';
   GetString(951, @alertStr);
   tempStr := CONCAT(alertStr,' ',tempNum);
   SetPt (tempLoc, postH + LeftColH, currentV);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, postH + LeftColH, currentV);
   GetVersion (diInfo.version, tempStr);                    {we have the version eg. '8.12.4'}
   preRelease := FALSE;
   firstPeriod := POS('.',tempStr);
   testStr := COPY(tempStr, firstPeriod+1, LENGTH(tempStr)-firstPeriod);
   secondPeriod := POS('.',testStr) + firstPeriod;
   testStr := COPY(tempStr, secondPeriod+1, LENGTH(tempStr)-secondPeriod);
   IF (testStr <> '0') THEN
      preRelease := TRUE
   ELSE
      tempStr := COPY (tempStr, 1, secondPeriod-1);
   GetString (928, @testStr);
   IF (NOT preRelease) THEN
      testStr := CONCAT(testStr,' ',tempStr);
   SetDiLabel (thePanel, tempLoc, testStr, [], sysText, TRUE{visible});

   IF (preRelease) THEN
      BEGIN
      thePanel := AddDiPanel;
      tempLoc.v := tempLoc.v + PixPerLine;
      GetString (929, @alertStr);
      testStr := CONCAT('     ',alertStr,' ',tempStr);
      SetDiLabel (thePanel, tempLoc, testStr, [], sysText, TRUE{visible});
      END;

   END; {of PROC SetPrefInfo}

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
{main body of SetAttInfo}
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[SetAttInfo], entry');


{ draw the information box }
tempRect.left := InfoRecLeft;
tempRect.right := InfoRecRight;
tempRect.top := topHeight + TopGapV;
tempRect.bottom := topHeight + botHeight - BotGapV;
SetDiRect (thePanel, tempRect, TRUE{visible});
thePanel := AddDiPanel;

SetPt (tempLoc, InfoRecLeft, topHeight + PixPerLine);
GetString (930, @tempStr);
SetDiLabel (thePanel, tempLoc, tempStr, [bold], sysText, TRUE{visible});
thePanel := AddDiPanel;

IF (diInfo.kind IN [profileKind, diskKind, disk1Kind, disk2Kind, drawerKind, priamKind]) THEN
   SetDisk (InfoRecLeft, topHeight + TopGapV)
ELSE IF (diInfo.kind IN [folderKind, folderPad, docKind, docPad, toolKind, calcKind, clockKind]) THEN
   SetNotDisk (InfoRecLeft, topHeight + TopGapV)
ELSE IF (diInfo.kind IN [computerKind, comp2Kind]) THEN
   SetPrefInfo (InfoRecLeft, topHeight + TopGapV)
ELSE
   SetNoInfo (InfoRecLeft, topHeight + TopGapV);

IF trcAttribute THEN WRITELN ('[SetAttInfo], exit');
END; {of PROCEDURE SetAttInfo}

{--------------------------------------------------------------------------------------------------}
PROCEDURE SetAttProt;

{draws the protection box, sets up the fields, etc}

CONST
   FitOnOne       = 20;             { max chars that will fit into a protection box line }

VAR
   docName  : E_Name;
   temp2Str : FmaxStr;
   titleStr : FmaxStr;

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetNoProt (title: FmaxStr; postH, postV: INTEGER);

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   currentV := postV + TopGapV;
   SetPt (tempLoc, postH + ProtNamH, currentV);
   QuoteName (title);
   ClipDiName (title, FitOnOne, TRUE{has quotes already});
   GetString (931, @alertStr);
   tempStr := CONCAT(title,' ',alertStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});

   diPassword.state := noProt;

   END; {of PROC SetNoProt}

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetNoFiles (title: FmaxStr; postH, postV: INTEGER);
   {document/folder with no disk files yet, gives a 4 line message in the Protection box}

   VAR
      alertNum : INTEGER;

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   currentV := postV + TopGapV;
   SetPt (tempLoc, postH + ProtNamH, currentV);
   QuoteName (title);
   ClipDiName (title, FitOnOne, TRUE{has quotes already});
   GetString (932, @alertStr);
   tempStr := CONCAT(title,' ',alertStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   GetString (933, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   IF (diInfo.kind = folderKind) THEN
      alertNum := 958
   ELSE
      alertNum := 934;
   GetString (alertNum, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   GetString (935, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});

   diPassword.state := NoProt;

   END; {of PROC SetNoFiles}

   {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetNotNow (title: FmaxStr; postH, postV: INTEGER);
   {document that has been set aside}

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   currentV := postV + TopGapV;
   SetPt (tempLoc, postH + ProtNamH, currentV);
   QuoteName (title);
   ClipDiName (title, FitOnOne, TRUE{has quotes already});

   IF (diInfo.protected) THEN
      GetString (936, @alertStr)
   ELSE
      GetString (937, @alertStr);
   {'Untitled is (protected/not protected)'}
   tempStr := CONCAT(title,' ',alertStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   GetString (955, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   GetString (956, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   GetString (957, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});

   diPassword.state := NoProt;

   END; {of PROC SetNotNow}

   {++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetOldDisk (title: FmaxStr; postH, postV: INTEGER);
   {document on an old format disk}

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   currentV := postV + TopGapV;
   SetPt (tempLoc, postH + ProtNamH, currentV);
   QuoteName (title);
   ClipDiName (title, FitOnOne, TRUE{has quotes already});
   GetString (932, @alertStr);
   {'Kens doc cannot currently be'}
   tempStr := CONCAT(title,' ',alertStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   GetString (952, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   GetString (953, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine;

   SetPt (tempLoc, tempLoc.h, currentV);
   GetString (954, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});

   diPassword.state := NoProt;

   END; {of PROC SetOldDisk}

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE SetProt (title: FmaxStr; postH, postV: INTEGER);
   {setting up the protection box when the object can be protectable}

   LABEL 99;

   CONST
      {positive horizontal/vertical offsets from postH, postV}
      ProtFldH       = 30;
      ProtEntH       = 45;
      ProtEntV       = 85;
      ProtCnlH       = 200;
      ProtCnlV       = 85;
      ProtnpsH       = 100;

   BEGIN
   {$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
   {all of the following label panels are first set to invisible.  The call to ProtAttDiBox will
    make the proper panels become visible, based on what diPassword.state is set to}

   currentV := postV + TopGapV;

   SetPt (tempLoc, postH + ProtNamH, currentV);
   QuoteName (title);
   ClipDiName (title, FitOnOne, TRUE{has quotes already});

   {pwdLine1}
   GetString (936, @alertStr);
   tempStr := CONCAT(title,' ',alertStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, FALSE{invisible});
   diPassword.pwdLine1 := thePanel;
   thePanel := AddDiPanel;

   {upwdLine1}
   {tempLoc is the same as before}
   GetString (937, @alertStr);
   tempStr := CONCAT(title,' ',alertStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, FALSE{invisible});
   diPassword.upwdLine1 := thePanel;
   thePanel := AddDiPanel;

   {the remaining label setup is for the second line in the protection box.  All possible
    cases are covered, with each label being set 'invisible'.  The first call to ProtAttDiBox
    will set the correct panels to 'visible', based on diPassword.state.}

   currentV := currentV + PixPerLine;
   SetPt (tempLoc, postH + ProtNamH, currentV);

   {pwdInit}
   {'to change, enter the current password'}
   GetString (938, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, FALSE{invisible});
   diPassword.pwdInit := thePanel;
   thePanel := AddDiPanel;

   {pwdVerified}
   {'Enter the new password'}
   GetString (939, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, FALSE{invisible});
   diPassword.pwdVerified := thePanel;
   thePanel := AddDiPanel;

   {upwdInit}
   {'To protect, enter the new password'}
   GetString (941, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, FALSE{invisible});
   diPassword.upwdInit := thePanel;
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine + FldOffV;

   {now the password field}
   SetPt (tempLoc, postH + ProtFldH, currentV);
   tempStr := '';
   SetDiField (thePanel, tempLoc, tempStr, [], sysText, MaxPasswd, TRUE{visible});
   diPassword.passwdPanel := thePanel;
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine + BtnOffV;

   {do the three buttons}
   SetPt (tempLoc, postH + ProtEntH, currentV);
   GetString (942, @tempStr);
   tempProc := @AttEnterBtn;
   SetDiButton (thePanel, tempLoc, tempstr, [bold], sysText, 1{penwidth}, 90{btn width},
                TRUE{visible}, tempProc);
   diPassword.enterBtnPanel := thePanel;
   thePanel := AddDiPanel;

   SetPt (tempLoc, postH + ProtCnlH, currentV);
   GetString (943, @tempStr);
   tempProc := @AttCancelBtn;
   SetDiButton (thePanel, tempLoc, tempstr, [bold], sysText, 1{penwidth}, 90{btn width},
                TRUE{visible}, tempProc);
   diPassword.cancelBtnPanel := thePanel;
   thePanel := AddDiPanel;

   currentV := currentV + PixPerLine + BtnOffV;

   SetPt (tempLoc, postH + ProtnpsH, currentV);
   GetString (944, @tempStr);
   tempProc := @AttNoPassBtn;
   SetDiButton (thePanel, tempLoc, tempstr, [bold], sysText, 1{penwidth}, 120{btn width},
                FALSE{not visible}, tempProc);
   diPassword.noPassBtnPanel := thePanel;

   99:
   IF (diInfo.objState = protectable) THEN
      IF (diInfo.protected) THEN
         BEGIN
         diPassword.state := Safe;
         diPassword.passworded := TRUE;
         END
      ELSE
         BEGIN
         diPassword.state := Unprotected;
         diPassword.passworded := FALSE;
         END
   ELSE
      diPassword.state := noProt;

   SelDiField (diPassword.passwdPanel, FALSE{dont draw now});

   END; {of PROC SetProt}

{++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
{start of main body of proc SetAttProt}
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[SetAttProt], entry');

{draw the protection box}
tempRect.left := ProtRecLeft;
tempRect.right := ProtRecRight;
tempRect.top := topHeight + TopGapV;
tempRect.bottom := topHeight + botHeight - BotGapV;
SetDiRect (thePanel, tempRect, TRUE{visible});
thePanel := AddDiPanel;

{draw the 'Prot' label}
SetPt (tempLoc, ProtRecLeft, topHeight + PixPerLine);
GetString (945, @tempStr);
SetDiLabel (thePanel, tempLoc, tempStr, [bold], sysText, TRUE{visible});
thePanel := AddDiPanel;

{set up for the title line in the protection box}
GetStrg(diInfo.name, titleStr);
CASE (diInfo.objState) OF
   protectable:  SetProt (titleStr, ProtRecLeft, topHeight + TopGapV);
   oldDisk:      SetOldDisk (titleStr, ProtRecLeft, topHeight + TopGapV);
   noFiles:      SetNoFiles (titleStr, ProtRecLeft, topHeight + TopGapV);
   setAside:     SetNotNow (titleStr, ProtRecLeft, topHeight + TopGapV);
   notProt:      SetNoProt (titleStr, ProtRecLeft, topHeight + TopGapV);
   END; {of CASE block}

IF trcAttribute THEN WRITELN ('   [SetAttProt], exit');
END; {of PROC SetAttProt}

{--------------------------------------------------------------------------------------------------}
PROCEDURE SetAttTop;
{draws the top panel of the dialog box}

CONST
   TopGapH  = 20;       {gap to left of text}
   DoneBtnH = 610;      {loc (horiz) of the done button}

   StoredOnMax = 20;    {max length of the volume name for 'stored on'}
   StoredInMax = 60;    {max length of this string}

   TitleMax    = 50;    {max length of name in first line for dialog box}

VAR
   nameRect : rect;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
currentV := TopGapV;

{ first set up the object name label, save with nameRect }
SetPt (tempLoc, TopGapH, currentV);
GetStrg (diInfo.name, tempStr);
diPassword.iconName := NewStrg(tempStr);
QuoteName(tempStr);
ClipDiName(tempStr, TitleMax, TRUE{quoted});
SetDiLabel(thePanel, tempLoc, tempStr, [bold], sysText, TRUE{visible});
nameRect := thePanel^^.outline;        { use it to position the rest of the title text }
thePanel := AddDiPanel;

{ now set up for the object info line label }
TextFace([]);                          { get ready for CharWidth call (uses current face, font }
TextFont(sysText);
tempLoc.h := nameRect.right + CharWidth(' ');
tempLoc.v := TopGapV;
GetStrg(diInfo.kindLbl1, tempStr);
SetDiLabel(thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
thePanel := AddDiPanel;

IF (diInfo.kindLbl2 <> nil) THEN
   BEGIN
   {we have a long first string (must be showing disk attributes), so add second panel}
   tempLoc.h := nameRect.right + CharWidth(' ') + StringWidth(tempStr);
   GetStrg(diInfo.kindLbl2, tempStr);
   SetDiLabel(thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;
   END;

currentV := currentV + PixPerLine;

{next the 'stored on' info}
IF (NOT (diInfo.StoredOn = nil)) THEN
   BEGIN
   SetPt (tempLoc, TopGapH, currentV);
   tempStr := diInfo.StoredOn^^;
   ClipDiName (tempStr, StoredOnmax, TRUE{quoted});
   GetString (946, @alertStr);
   tempStr := CONCAT(alertStr,' ',tempStr);
   {tempStr = 'Stored on "xxxxxx"'}
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   IF NOT (diInfo.StoreIn1 = nil) THEN
      BEGIN
      SetPt(tempLoc, TopGapH + StringWidth(tempStr) + CharWidth(' '), currentV);
      tempStr := diInfo.StoreIn1^^;
      SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
      thePanel := AddDiPanel;
      END;

   IF NOT (diInfo.storeIn2 = nil) THEN
      BEGIN
      currentV := currentV + PixPerLine;
      SetPt(tempLoc, TopGapH, currentV);
      tempStr := diInfo.storeIn2^^;
      SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
      thePanel := AddDiPanel;
      END;

   END; {of IF THEN block}

{ put the done button up }
SetPt (tempLoc, DoneBtnH, (topHeight DIV 2) + 4);
GetString (947, @tempStr);
tempProc := @AttDoneBtn;
SetDiButton (thePanel, tempLoc, tempstr, [bold], sysText, 2{penwidth}, 80{btn width},
             TRUE{visible}, tempProc);
thePanel := AddDiPanel;

{ add the separating line }
SetPt (tempLoc, 0, topHeight);
SetPt (tempLoc2, ScreenWidth, topHeight);
SetDiLine (thePanel, tempLoc, tempLoc2, 1{pen width}, gray{pattern}, TRUE{visible});

END; {of PROC SetAttTop}

{--------------------------------------------------------------------------------------------------}
{main body of PROC SetAttDiBox}
BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[SetAttDiBox], entry');

noError := TRUE;                             { set to FALSE for any major OS error }
thePanel := diBox.firstPanel;                { set up the panel to use for info stuffing }
diBox.obj := obj;                            { set up the desk object that the dialog box is displaying }
diBox.finishProc := @AttDoneBtn;             { executed when DoDiFinished is called }

{reset the diPassword record values}
InitPwdFields;

{ get the object info }
IF (NOT AttObjInfo (obj, diInfo)) THEN
   BEGIN
   noError := FALSE;
   GOTO 99;
   END; {of IF THEN block}

topHeight := TopGapV + BotGapV + ((diInfo.topLines - 1) * PixPerLine);
CASE (diInfo.objState) OF
   protectable : tempHeight := ProtHeight;
   notProt     : tempHeight := NoProtHeight;
   OTHERWISE     tempHeight := MsgHeight;
   END; {of CASE block}
botHeight := TopGapV + BotGapV + max(tempHeight, TopGapV + BotGapV + ((diInfo.infoLines-1) * PixPerLine));
diBox.height := topHeight + botHeight;

SetAttTop;
thePanel := AddDiPanel;

{draw the information box}
SetAttInfo;
thePanel := AddDiPanel;

{draw the protection box}
SetAttProt;

99:
IF trcAttribute THEN WRITELN ('   [SetAttDiBox], exit');
END; {of PROC SetAttDiBox}

{**************************************************************************************************}
PROCEDURE SetPassDiBox {* volHdl: TentryHdl; catRec: TcatRec; VAR noError: BOOLEAN *};
{Sets up the panels for the attribute dialog box, also the size of box, also the diPassword fields.}

LABEL 99;

CONST
   PasswdDiHeight    = 80;
   CnclBtnW          = 100;
   EntrBtnW          = CnclBtnW;

   { Panel location constants }
   CnclBtnH       = 600;         { on the far right of the screen }
   CnclBtnV       = 30;
   EntrBtnH       = CnclBtnH;
   EntrBtnV       = 60;
   TitlLblH       = 20;
   TitlLblV       = 25;
   PassLblH       = TitlLblH;
   PassLblV       = 50;

VAR
   alertNum : INTEGER;
   alertStr : FmaxStr;
   docName  : E_Name;               { for getting the entry pathname }
   err      : INTEGER;
   tempLoc  : Point;                { temporary location of panel }
   tempProc : TProc;
   tempRect : rect;
   tempStr  : FmaxStr;              { string used for temporary storage of text }
   thePanel : PanelHandle;          { the current panel being stuffed with the right values }
   toolName : E_Name;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[SetPassDiBox], entry');

noError := FALSE;
diBox.obj := nil;                               { no object for password checking }
diBox.finishProc := @PassEnterBtn;              { finish things off proc }

{reset the diPassword record}
InitPwdFields;

WITH diBox DO
   BEGIN
   height := PasswdDiHeight;
   thePanel := firstPanel;                      { set up the panel to use for info stuffing }

   {set up 'Enter' and 'Cancel' buttons}
   GetString (943, @tempStr);
   SetPt (tempLoc, CnclBtnH, CnclBtnV);
   tempProc := @PassCancelBtn;
   SetDiButton (thePanel, tempLoc, tempstr, [bold], sysText, 1{penwidth}, CnclBtnW,
                TRUE{visible}, tempProc);
   diPassword.cancelBtnPanel := thePanel;
   thePanel := AddDiPanel;

   GetString (942, @tempStr);
   SetPt (tempLoc, EntrBtnH, EntrBtnV);
   tempProc := @PassEnterBtn;
   SetDiButton (thePanel, tempLoc, tempstr, [bold], sysText, 1{penwidth}, EntrBtnW,
                TRUE{visible}, tempProc);
   diPassword.enterBtnPanel := thePanel;
   thePanel := AddDiPanel;

   {draw the title bar}
   SetPt (tempLoc, TitlLblH, TitlLblV);
   ExtObjName (catRec, tempStr);
   diPassword.iconName := NewStrg(tempStr);
   QuoteName (tempStr);
   SetDiLabel (thePanel, tempLoc, tempstr, [bold], sysText, TRUE{visible});
   tempRect := thePanel^^.outline;              { use it to position the rest of the title text }
   thePanel := AddDiPanel;

   {add the rest of the text}
   TextFont (sysText);
   TextFace ([]);
   tempLoc.v := TitlLblV;
   tempLoc.h := tempRect.right + CharWidth(' ');
   GetString (936, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempstr, [], sysText, TRUE{visible});
   thePanel := AddDiPanel;

   {do the 'Enter Password' stuff}
   SetPt (tempLoc, PassLblH, PassLblV);
   GetString (948, @tempStr);
   SetDiLabel (thePanel, tempLoc, tempStr, [], sysText, TRUE{visible});
   tempRect := thePanel^^.outline;
   thePanel := AddDiPanel;

   {add the field area}
   TextFont (sysText);
   TextFace ([]);
   tempLoc.v := PassLblV;
   tempLoc.h := tempRect.right + (8 * CharWidth(' '));
   tempStr := '';
   SetDiField (thePanel, tempLoc, tempStr, [], SysText, MaxPasswd, TRUE{visible});
   diPassword.passwdPanel := thePanel;
   END; {of WITH block}

CASE (catRec.objKind) OF
   docKind: GetADocName(err, catRec.selfId, catRec.toolId, volHdl, diPassword.path);
   folderKind: GetAFldrName(err, catRec.selfId, volHdl, diPassword.path);
   toolKind, calcKind, clockKind:
      BEGIN
      BuildToolName (catRec.toolId, toolName);
      diPassword.path := CONCAT('-',volHdl^^.devHdl^^.nameHdl^^,'-',toolName,'obj');
      err := 0;
      END;
   OTHERWISE GOTO 99;
   END; {of CASE block}

IF (err > 0) THEN
   GOTO 99;

noError := TRUE;

{now set up so that user can type immediately}
SelDiField(diPassword.passwdPanel, FALSE{dont draw now});

99:
IF trcAttribute THEN WRITELN ('   [SetPassDiBox], exit');
END; {of PROC SetPassDiBox}

{**************************************************************************************************}
PROCEDURE ShowAttributes {* obj: ObjectHandle *};

{ Displays the attributes dialog box for obj)}

LABEL 99;

VAR
   savePort    : GrafPtr;              { temporary storage for the Filer grafPort }
   errorFree   : BOOLEAN;

BEGIN
{$IFC flrDebug } IF trcCalls THEN ALogCall; {$ENDC}
IF trcAttribute THEN WRITELN ('[ShowAttributes], entry');

GetPort (savePort);
SetPort (dialogFolder);             { set up drawing to the dialog window }
InitDiBox;                          { initialize a dialog box }
SetAttDiBox (obj, errorFree);       { then set up the panels for it }
IF (NOT errorFree) THEN
   GOTO 99;                         { error occured, alert already displayed, so just bail out }

CloseDiBox;                         { wrap around the panel pointers, draw the picture }
ProtAttDiBox;                       { make sure that the correct panels are visible/invisible }
UseDiBox;                           { handle events, etc. }
RmvDiBox;                           { then take it down }

99:
SetPort(savePort);                  { reset the filer port }

IF trcAttribute THEN WRITELN ('   [ShowAttributes], exit');
END; {of PROC ShowAttributes}


