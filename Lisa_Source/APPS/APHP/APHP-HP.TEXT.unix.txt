

                            {'Copyright 1983, 1984, Apple Computer Inc.'}

program calculator;

uses (*$U UnitStd.obj *)                UnitStd,
     (*$U UnitHz.obj *)                 UnitHz,
     (*$U Storage.obj *)                Storage,
     (*$U QuickDraw.obj *)              QuickDraw,
     (*$U Fontmgr.obj *)                FontMgr,
     (*$U dbenv.obj *)                  dbenv,
     (*$U FEdec.obj *)                  FEdec,
     (*$U fld.obj *)                    fieldedit,
     (*$U teenv.obj *)                  teenv,

     (*$U libos/SysCall.obj    *)       Syscall,
     (*$U FPlib.obj *)                  FPlib,
     (*$U PMDecl *)                     PMDecl,
     (*$U PrStdInfo *)                  PrStdInfo,
     (*$U PrPublic.obj *)               PrPublic,

     (*$U wm.events.obj *)              events,
     (*$U wm.folders.obj *)             folders,
     (*$U wm.menus.obj *)               menus,
     (*$U AlertMgr.obj *)               AlertMgr,

     (*$U WMLstd.obj  *)                WMLstd,
     (*$U WMlCrs.obj  *)                WMlCrs,
     (*$U WMlsb.obj   *)                WMlsb,
     (*$U WMLgrow.obj *)                WMLgrow,
     (*$U scrap.obj *)                  Scrap,
     (*$U Lcut.obj *)                   Lcut,
     (*$U aplc/FilerComm.obj *)         filerComm,
     (*$U Mathlib.obj *)                MathLib;

{$SETC CALCProduction := NOT FDbgOK }
{$SETC RangeChk := not CALCProduction }
{ SETC CALCProduction := false }
{ SETC RangeChk := true }
{$SETC CALCSym := FSymOk }
{$SETC CALCdebug := NOT CALCProduction  }

const

      sCopyRight      = 'Copyright 1983, 1984 Apple Computer Inc.';

      mFilePrint   = 2;                 {menus constants - all menu items are referredto by these constants}
         mCloseAll    = 1;
         mClose       = 2;
         mBlank1      = 3;
         mPutBack     = 4;
         mBlank2      = 5;
         mIntend      = 6;
         mPrint       = 7;
         mMonitor     = 8;

      mEdit        = 3;
         mUndo        = 1;
         mBlank3      = 2;
         mCut         = 3;
         mCopy        = 4;
         mPaste       = 5;
         mBlank4      = 6;
         mClearAll    = 7;
         mClearTape   = 8;

      mFormat      = 4;
         mDefault     = 1;
         mZeroDec     = 2;
         mOneDec      = 3;
         mTwoDec      = 4;
         mThreeDec    = 5;
         mFourDec     = 6;
         mblank5      = 7;
         mRoundon     = 8;
         mRoundOff    = 9;
         mAuto        = 10;
         mKeyed       = 11;

      mCustomize   = 5;
         mPolish      = 1;
         mAlgebraic   = 2;
         mBusiness    = 3;
         mBlank6      = 4;
         mShowTape    = 5;
         mHideTape    = 6;
         mAdvTape     = 7;
         mBlank7      = 8;
         mShowRegs    = 9;
         mHideRegs    = 10;

      mBuzzWords   = 6;
         mSubTotal    = 1;
         mClrAll      = 2;
         mClear       = 3;
         mMclear      = 4;
         mXwithY      = 5;
         mXwithM      = 6;
         mMRecall     = 7;
      maxTapePhrases = 7;
      minTapeWord    = 8;
         mTotal       = 8;
         mEnter       = 9;
         mS           = 10;
         mPercent     = 11;
         mMsub        = 12;
         mMadd        = 13;
         mMmul        = 14;
         mMdiv        = 15;
         mInv         = 16;
         mNumSign     = 17;
         mChs         = 18;
         mEquals      = 19;
         mX           = 20;
         mY           = 21;
         mM           = 22;
         mDiamond     = 23;
         mPTotal      = 24;
         mSqrt        = 25;
         mAdd         = 26;
         mSub         = 27;
         mMul         = 28;
         mDiv         = 29;
      maxTapeWords = 29;
         mTPolish     = 30;
         mTAlgebraic  = 31;
         mTBusiness   = 32;
         mBlank       = 33;

      mScrap       = 7;
         mSCloseAll   = 1;
         mSClose      = 2;
         mBlank8      = 3;
         mSMonitor    = 4;

      mBuzz2Words  = 8;
        {1..3 reserved for calculator names}
         FEtriples    = 4;
         mCloseMsg    = 5;
         mMemory      = 6;
         mError       = 7;
         mPINF        = 8;
         mMINF        = 9;
         mOVERFLOW    = 10;
         mStrip       = 11;

      mDebug       = 9;
         mClearTrace  = 1;
         mTraceEvents = 2;
         mTraceProg   = 3;
         mdebugflag   = 4;
         mPxHz        = 5;
         mDebugging   = 6;
         mBound       = 7;
         mShowEntry   = 8;
         mShowData    = 9;
         mShowMem     = 10;
         mHideMem     = 11;
         mStatus      = 12;

      mWouldAlert  = 10;
         mWType       = 1;
        {2..9 reserved for menu names}
         mWtape       = 10;

      lastMenu     = 10;

      debugReg     = 10;
      curVerStamp  = 103;
      alertVerNum  = 1001;
      maxHeapSize  = 4000;
      fieldFont    = p10tile;
      tapeFont     = p15tile;
      formFont     = p15tile;
      printLDSN    = 1;
      segLDSN      = 2;
      maxDigits    = 14;
      maxSizeField = 30;
      maxMemCells  = 0;
      maxRegisters = 3;
      sopMin       = '!';
      sopMax       = '|';
      invDelay     = 20;
      padVDisp     = 30;
      padHDisp     = 6;
      dispWid      = 14;
      sKeyWid      = 17;
      keyHeight    = 20;
      keyWidth     = 33;
      keyHSpacing  = 6;
      keyVSpacing  = 4;
      sUKeyHeight  = 5;
      dispToEntry  = 6;
      MaxFPString  = 80;

      leftCHIndent = 9;
      topCHIndent  = 3;
      botCHIndent  = 4;


      chEnter      = 3;                         {real keyboard constants}
      chBack       = 8;
      chEscape     = 27;
      chLeft       = 28;
      chRight      = 29;
      chUp         = 30;
      chPercent    = 37;
      chDash       = 45;
      chZero       = 48;
      chOne        = 49;
      chFour       = 52;
      chSeven      = 55;

      chAdd        = chLeft;                    {Virtual keyboard constants}
      chSub        = chDash;
      chMul        = chRight;
      chDiv        = chUp;
      chBackSpace  = chBack;
      chEnterVal   = chEnter;
      chClearEntry = chEscape;
      chXfromM     = chSeven;
      chXfromY     = chOne;
      chInv        = chFour;
      chCHS        = chZero;
      chSQRT       = chPercent;

      calcWidth    = 171;         { size of the calculator }
      calcHeight   = 138;

      cPicGEDwg    = 100;
      cPicTxtBegin = 101;
      cPicTxtEnd   = 102;
      cPicGrpBegin = 103;
      cPicGrpEnd   = 104;
      cPicForeGnd  = 108;
      cPicBackGnd  = 109;
      picScrapType = ScrapUG;

(*$IFC calcProduction *)
      showdebug    = false;
      debugging    = false;
      tracing      = false;
      statusMsg    = false;
      debugflag    = false;
      showdata     = false;
(*$ENDC *)

type

      sopRange    = sopMin..sopMax;
      regRange    = 0..maxRegisters;
      memRange    = 0..maxMemCells;
      padSet      = set of 0..127;

      calcStr     = string[20];

      FPString    = string[MaxFPString];

      alias       = (twdlDee, twdlDye, twdlDoe, twdlDue, twdlDum);

      letterClass = (cDecPt, cLetter, cDigit, cSops, cClear, cClearAll, cEnterVal, cBackSpace, cJunk, cLock);

      symbol      = (sMULop, sDIVop, sADDop, sSUBop, sPERCENTop, sINVop, sNothing, sCHSop, sSQRTop);

      calcModes   = (Polish, Algebraic, Business, noCalc);

      tDisplays   = set of (dMem, dRegs, dTape, dATape);

      tGen        = (gNormal, gReg0, gReg1, gMem, gOp, gItem, gDiamond, gSubTot, gEqual0, gEqual1,
                     gCalc, gNone, gSDiamond, gClrAll, gClrEntry, gPaste);

      butLegends  = (bFirst,
                              bMclear, bMsub,  bMadd,  bMMul,
                              bClear,  bSub,   bAdd,   bMul,
                     bXwithM, bSeven,  bEight, bNine,  bDiv,     bMdiv,
                     bInv,    bFour,   bFive,  bSix,   bPercent, bSqrt,
                     bXwithY, bOne,    bTwo,   bThree, bEnter,   bMRecall,
                     bCHS,    bZero,   bZero2, bDecPt, bEnter2,
                     bLast
                    );

      dataItem    = Double;
      ptrLongInt  = ^longint;
      hndLongInt  = ^ptrLongInt;

      butType     = record
                       ch      : char;
                       shifted : boolean;
                       coords  : rect;
                    end;

      SelectInfo  = record
                       startRow : integer;
                       oldStart : integer;
                       endRow   : integer;
                       oldEnd   : integer
                     end;

      FileStamp   = record
                       case alias of
                          twdlDee : (stamp   : integer);
                          twdlDye : (reserve : array [0..13] of byte)
                       end;

      PrintStamp  = record
                       case alias of
                          twdlDee : (config  : TprRec);
                          twdlDye : (reserve : array [0..111] of byte)
                       end;

      fileHeader  = packed record
                       password   : integer;
                       version    : FileStamp;
                       printer    : PrintStamp;
                       suspended  : boolean;
                       entryLine  : calcStr
                    end;

      tapeInfo    = packed record
                       tFormat     : integer;
                       tnumber     : dataItem;
                       tMessage    : integer;
                       tcalcStyle  : calcModes;
                       tRoundMode  : RoundDir;
                    end;

      PcalcInfo   = ^calcInfo;
      calcInfo    = record
                       header      : fileHeader;
                       calcStyle   : calcModes;
                       showMem     : boolean;
                       showRegs    : boolean;
                       showTape    : boolean;
                       subTotal    : boolean;
                       clrKey      : boolean;
                       Rounding    : boolean;
                       AutoDecimal : boolean;
                       chsSign     : boolean;
                       pad1        : boolean;
                       pad2        : boolean;
                       userDecimal : boolean;
                       firstChr    : boolean;
                       roundMode   : RoundDir;
                       dispFormat  : integer;
                       tapeCnt     : integer;
                       topTapeEntry: integer;
                       bSelect     : integer;
                       eSelect     : integer;
                       pendCalcOp  : symbol;
                       secondOp    : symbol;
                       butPressed  : butLegends;
                       scrollPos   : integer;
                       entryDisp   : integer;
                       regsDisp    : integer;
                       memDisp     : integer;
                       lockDisp    : boolean;
                       enterkeyHit : boolean;
                       operPending : boolean;
                       valueEnterd : boolean;
                       regs        : array [regRange] of dataItem;
                       memory      : array [memRange] of dataItem;
                       tapeValues  : array [0..0] of tapeInfo;
                    end;

var

   theEvent    : EventRecord;  { holds the last event received }
   myWindow    : WindowPtr;    { passed to me by filer in "OpenDoc" event }
   keyPad      : padSet;
   mainPad     : padSet;

   calcZone    : array [0..maxHeapSize] of integer;
   myMenus     : array [2..lastMenu] of MenuInfo;
   chrClass    : array [char] of LetterClass;
   sopChar     : array [sopRange] of symbol;
   buttons     : array [butLegends] of butType;
   spaces      : str40;
   toldToDie   : boolean;
   useDefaults : boolean;
   procsInited : boolean;
   inDownEvent : boolean;
   genScrapPic : boolean;
   butInvert   : boolean;
   tapePortRect: rect;
   undoOp      : record
                    menu : integer;
                    item : integer;
                 end;
   clickTime   : longint;
   clickCount  : integer;
   StartUpAlert: integer;
   tapePspacing: integer;
   segPtr      : longint;
   segRefNum   : integer;
   copyRight   : integer;
   numLinesVis : integer;

   fontHeight  : integer;
   formHeight  : integer;
   tapeHeight  : integer;

   sErrNum     : integer;
   sufTapeLen  : integer;
   defTapeWidth: integer;
   VofLesser   : dataItem;
   nullSel     : SelectInfo;
   entryFSH    : hndFstate;
   entryFLD    : hndField;
   CommentHnd  : hndLongInt;
   sbList      : TSBList;
   hsbV, hsbH  : THsb;
   c           : PcalcInfo;
   tapeFId     : TLfntid;
   tapeChrWid  : integer;
   allAlerts   : TAlertFile;

   genPrintPic : boolean;
   printRect   : rect;
   pRPrintable : rect;
   pStartEntry : integer;
   pStopEntry  : integer;

(*$IFC CALCdebug *)
   myKeys      : keySet;
   debugging   : boolean;
   showdata    : boolean;
   showDebug   : boolean;
   tracing     : boolean;
   statusMsg   : boolean;
   debugflag   : boolean;
(*$ENDC *)


   { All procedures are declared forward to allow alphabetical ordering }


(*$IFC CALCSym *)
(*$D+ *)
(*$ELSEC *)
(*$R- *)
(*$D- *)
(*$ENDC *)


procedure ClrEntry;
   FORWARD;
procedure ClrMem(regNum : memRange);
   FORWARD;
procedure ClrReg(regNum : regRange);
   FORWARD;
PROCEDURE CommandKey;
   FORWARD;
function  DecptInEntry(var position : integer) : boolean;
   FORWARD;
procedure DISPfromFP(number : dataItem; var result : calcStr; var error : boolean);
   FORWARD;
procedure doOperation(calculation : symbol; drawResult : boolean; doSwap : boolean);
   FORWARD;
PROCEDURE DrawContents(window: WindowPtr; doInvert, deActive : boolean);
   FORWARD;
procedure DrawEntry;
   FORWARD;
procedure DrawFormula(display : tdisplays);
   FORWARD;
procedure DrawOperString(strng : str255);
   FORWARD;
procedure DrawReg(regNum : regRange; inScrap : boolean; cutField : boolean);
   FORWARD;
PROCEDURE DrawScrollBars(window : WindowPtr);
   FORWARD;
procedure DrawTape(newTopEntry : integer; sInfo : SelectInfo; doNotErase, dim, drawSelCels, drawSelection, drawLonly : boolean);
   FORWARD;
function  entryCH(index : integer) : char;
   FORWARD;
function  entryLen : integer;
   FORWARD;
PROCEDURE Initialize;
   FORWARD;
PROCEDURE InitNewDoc(window : WindowPtr);
   FORWARD;
procedure insertAChr(ch : char; userInput : boolean; doRoll : boolean);
   FORWARD;
procedure invertbut(but : butLegends);
   FORWARD;
procedure invertDisplay(unInvert : boolean; alertNum : integer);
   FORWARD;
PROCEDURE LastWishes(environPtr : P_env_blk; excepDataPtr : P_ex_data);
   FORWARD;
procedure MakeTapeEntry(newEntry : boolean; generate : tGen; dispRegs : boolean);
   FORWARD;
PROCEDURE MenuCommand(menu,item: integer);
   FORWARD;
PROCEDURE MouseInWindow(window : WindowPtr; pt : Point; upEvent : boolean);
   FORWARD;
procedure NormalTapeEntry;
   FORWARD;
FUNCTION  OutOfHeapSpace(hz : THz; bytesNeeded : integer) : integer;
   FORWARD;
procedure pressKey(ch : char; shifted : boolean);
   FORWARD;
procedure PrintTapeSelection;
   FORWARD;
procedure processKey(class : letterclass; ch : char; shifted : boolean);
   FORWARD;
PROCEDURE ProcessTheEvent;
   FORWARD;
PROCEDURE PutUpMenus;
   FORWARD;
function  RegdispLines(style : calcModes) : integer;
   FORWARD;
procedure RegToEntry(regNum : regRange; doRounding : boolean; doRoll : boolean);
   FORWARD;
procedure removeAchr;
   FORWARD;
PROCEDURE RemoveScrollBars(window : WindowPtr);
   FORWARD;
PROCEDURE RemoveSelection(redraw : boolean);
   FORWARD;
procedure ScrollTape(pt : point; myhsbHit : THsb; myIconHit : TIcon; forced, auto : boolean);
   FORWARD;
procedure setMaxNumParamAlert(flag : boolean);
   FORWARD;
procedure SfromEntry(var strg : calcStr);
   FORWARD;
procedure SfromN(var answer : calcStr; num : longint; base : integer; alphabet : char);
   FORWARD;
procedure ShowDecimal(ch : char; doInsert : boolean);
   FORWARD;
procedure showEntry(entryNum, topEntry : integer; finfo : FontInfo;
                    nextMessage, drawOnTape, dim, drawSelection, drawLonly : boolean; var operStr : str255);
   FORWARD;
procedure ShowSelection(dim, reDraw : boolean);
   FORWARD;
procedure StrToDataItem(regNum : integer; shoError : boolean; var error : boolean);
   FORWARD;


{--------------------------------------------------------------------------------------------------
   The following routines are used to generate the universal text version of a selection on the
   tape.  This routines are called via procedure pointers by the "writeLCut" routine that generates
   the actual universal text.  The "writeLCut" routine was originally written with a table
   application in mind.  The calculator, not having a table, views the tape as a single column of
   a table.  Thus the `colId` parameter to the routines are always 1.  The routines access to the
   tape based on this tablelike view of the tape.

        "CellBlank"     returns true if the indicated tape entry is a blank line
        "CellInfo"      returns a format record for the indicated tape entry
        "CellValue"     returns the actual text value for the indicated tape entry.
        "FinalDataSnip"
        "GetSnipId"
        "RgInScrap"
        "SnipWidth"
        "SwitchTable"
 -------------------------------------------------------------------------------------------------}
(*$S        *)
function CellBlank(rowId, colId : idType) : boolean;
begin
(*$R- *)
   CellBlank := (c^.tapeValues[rowId-1].tMessage = mBlank)
(*$IFC RangeChk *)
(*$R+ *)
(*$ENDC *)
end;


(*$S        *)
procedure CellInfo
  (parName      : cellParType;       {which parameter to read/write}
   mode         : IOModeType;        {reading/writing mode flag; it is always read}
   rowId, colId : idType;            {location of cell}
   var cellRec  : cellRecord         {record to be read/written}
  );
begin
   cellRec.align := right;
(*$R- *)
   if c^.tapeValues[rowId-1].tMessage = mNumSign then cellRec.align := left;
(*$IFC RangeChk *)
(*$R+ *)
(*$ENDC *)
   cellRec.hiLite    := false;
   cellRec.dim       := false;
   cellRec.numRuns   := 0;
   cellRec.protected := false;
   cellRec.font      := tapeFId
end;


(*$S        *)
procedure CellValue
  (mode         : IOModeType;        {reading/writing mode flag}
   rowId, colId : idType;            {location of cell}
   value        : ptrData;           {ptr to where chrs are to go}
   wideFlg      : boolean;           {format for wide angle display? }
   var numBytes,                     {max # of chrs /actual # chrs returned}
       status   : integer            {error status number}
  );
var operStr  : str255;
    x        : integer;
    ch       : char;
    fInfo    : FontInfo;
begin
   status := 0;

   {set up the font information}
   TextFont(tapeFont);
   TextFace([]);
   GetFontInfo(fInfo);

   {get the text for the tape entry into `operStr`}
   ShowEntry(rowId-1, C^.bSelect-1, fInfo, false, false, false, false, false, operStr);
   if length(operStr) < numbytes then numbytes := length(operStr);

(*$R- *)
   {change any of the funny characters that are on the tape (like the diamond) to something
    that is available in the font
   }
   for x := 0 to numBytes - 1 do begin
      ch := operStr[x+1];
      case ch of
         '|' : ch := '/';       {divide sign}
         'Á' : ch := '/';       {slash}
         'Æ' : ch := 'Æ'        {diamond}
      end;
      value^[x] := ord(ch)
   end
(*$IFC RangeChk *)
(*$R+ *)
(*$ENDC *)


(*$IFC CalcDebug *)
;if debugging then writeln(rowId:1,'  CellValue(',length(operStr):1,'): ',operStr);
(*$ENDC *)
end;


(*$S        *)
function FinalDataSnip(aKind: SnipKind) : idType;
begin
   with C^ do begin
      if aKind = colKind then FinalDataSnip := 1
      else if tapeCnt < eSelect then FinalDatasnip := tapeCnt + 1
      else FinalDataSnip := eSelect
   end
end;


(*$S        *)
procedure GetSnipId
  (snip       : snipKind;            {type of information desired: row or column}
   mode       : idModeType;          {mode of information desired: first/last...}
   position   : fract;               {position in [0 .. 1000] for fraction oper}
   refId      : idType;              {reference snip for next/prior oper}
   var snipId : idType               {resulting snip information}
  );
var lowSnip  : integer;
    highSnip : integer;
    temp     : longint;
begin
   if snip = rowKind then begin
      lowSnip  := 1;
      highSnip := FinalDataSnip(colKind)
   end
   else begin
           lowSnip  := 1;
           highSnip := 1
        end;

   case mode of
      mmfirst    : snipId := lowSnip;
      mmlast     : snipId := highSnip;
      mmnext     : if refId = mInfSnip then snipId := lowSnip
                   else if refId = pInfSnip then snipId := pInfSnip
                   else if refId < highSnip then snipId := refId + 1
                   else snipId := pInfSnip;
      mmprior    : if refId = mInfSnip then snipId := mInfSnip
                   else if refId = pInfSnip then snipId := highSnip
                   else if refId > lowSnip then snipId := refId - 1
                   else snipId := mInfSnip;
      mmfraction : begin
                      temp := Cmin(Cmax(position, 1), 1000);
                      temp := highSnip * temp div 1000;
                      if temp < 1 then temp := 1;
                      snipId := temp
                   end
   end
end;


(*$S        *)
procedure RginScrap(var rg : range);
begin
   rg.rKind := aRectRg;
   rg.loRow := C^.bSelect;
   rg.hiRow := FinalDataSnip(rowKind);
   rg.loCol := 1;
   rg.hiCol := 1
end;


{--------------------------------------------------------------------------------------------------
 -------------------------------------------------------------------------------------------------}
(*$S        *)
function  SnipWidth
  (snip   : snipKind;                {type of information desired}
   snipId : idType                   {snip for which the data is desired}
  ) : integer;                       {width of the snip}
begin
   if snip = rowKind then SnipWidth := tapeHeight
   else SnipWidth := defTapeWidth
end;


{--------------------------------------------------------------------------------------------------
 -------------------------------------------------------------------------------------------------}
(*$S        *)
procedure SwitchTable
  (ScrapTable    : boolean;        {table to switch to}
   var tableInfo : tableRecord       {table information for that table}
  );
begin
end;


{--------------------------------------------------------------------------------------------------
   ChgGray - sets a specific menu item to gray.  This saves a little code.  The menu/item to be
             grayed is passed through `menuXXX` and `menuitem`.  If `FGray` is true, the menuitem
             will appear gray the next time the menu is pulled down.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure ChgGray(menuXXX: integer; menuItem: Integer; FGray: Boolean);
{ grays/ungrays one menu item according to the FGray boolean}
begin
   if FGray Then DisableItem(myMenus[menuXXX], menuItem)
            Else EnableItem(myMenus[menuXXX], menuItem)
end;


{--------------------------------------------------------------------------------------------------
   ChkItem - sets a specific menu item to be checked.  This saves a little code.  The menu/item to
             be checked is passed through `menuxx` and `menuitem`.  If `FCheck` is true, the
             menuitem will appear checked the next time the menu is pulled down.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure ChkItem(menuXXX, menuItem : integer; FCheck : boolean);
begin
   CheckItem(myMenus[menuXXX], menuItem, FCheck)
end;


{--------------------------------------------------------------------------------------------------
   ChkEditMenu - determines what menuitems in the edit menu are to be grayed.  The graying is
                 based on what is in the universal scrap.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure ChkEditMenu;
var sKind    : ScrapType;
    scrapPtr : Th;
    sPlace   : TB;
begin
   with C^ do begin
      GetScrap(sKind, scrapPtr);
      GetCSScrap(sPlace);
      ChgGray(mEdit, mPaste, not(((sKind = ScrapFE) or (sPlace <> 0)) and (bSelect = 0)));
      ChgGray(mEdit, mCut, (bSelect <> 0));
      ChgGray(mEdit, mCopy, (bSelect < 0))
   end
end;


{--------------------------------------------------------------------------------------------------
   ClrEntry - clears the entry field leaving no characters present.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure ClrEntry;
var status : integer;
begin
   ClearField(entryFLD, entryFSH, status);
end;


{--------------------------------------------------------------------------------------------------
   ClrMem - sets the specified memory cell to 0.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure ClrMem{regNum : memRange};
var
  temp : extended;
begin
   I2X (0, temp);
   X2D(temp, c^.memory[regNum]);
end;


{--------------------------------------------------------------------------------------------------
   ClrReg - sets the specified register to 0.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure ClrReg{regNum : regRange};
var
  temp : extended;
begin
   I2X (0, temp);
   X2D(temp, c^.regs[regNum]);
end;


{--------------------------------------------------------------------------------------------------
   CommandKey - Command something was pressed.  Do appropriate command if any.  Otherwise, invert
                the display to signal an error.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure CommandKey;
var minTime : LongInt;
    theMenu : integer;
    theItem : integer;
begin
   MenuKey(theEvent.ascii, theMenu, theItem);
   if (theMenu <> mBuzzWords) and (theMenu <> mBuzz2Words) and (theMenu <> 0) then begin
      HiliteMenu(theMenu);
      minTime := time + invDelay;
      MenuCommand(theMenu, theItem);
      repeat until time > minTime;
      HiliteMenu(0)
   end
(*$IFC CALCdebug *)
   else if (theEvent.shiftKey) and (theEvent.ascii = '~') then begin
           showDebug := not showDebug;
           PutUpMenus
        end
(*$ENDC *)
   else InvertDisplay(true, 100)
end;


{--------------------------------------------------------------------------------------------------
   DecptInEntry - returns true if a decimal point is present in the entry field.  Note: only one
                  decimal point is expected to be found and `position` will be its position within
                  the entry field.
 -------------------------------------------------------------------------------------------------}
function DecptInEntry{var position : integer) : boolean };
var x : integer;
begin
   DecPTinEntry := false;
   position     := 0;
   for x := 1 to entryLen do
      if entryCH(x) = '.' then begin
         position := x;
         DecPtinEntry := true
      end
end;


{--------------------------------------------------------------------------------------------------
   DISPfromFP - formats the `dataItem` found in the FP register and returns the text version of it
                via `result`.  The style of formatting is dictated by `c^.dispFormat`.  If an
                error occured while formatting the FP register, `error` will be true.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure DISPfromFP{number : dataItem; var result : calcStr; var error : boolean};
var myFormat   : free_format;
    myDecForm  : DecForm;
    FPKind     : NumClass;
    sgn        : integer;
    spot       : integer;
    xNumber    : extended;
    after      : integer;
    tempStr    : DecStr;
    width      : integer;
    menuStr    : str255;
    errorNum   : integer;
    formatNum  : integer;
begin
   D2X(number, xNumber);
   FPKind    := ClassX (xNumber, sgn);
   width     := maxDigits - ord(sgn = 0);
   formatNum := C^.dispFormat;
   if formatNum = mDefault then begin           {was FP_Lisa}
      with myFormat do begin
        maxsig      := 14;
        trail_point := false;
        int_eform   := false;
        plus_eform  := false;

        {this is a Kludge in order to determine if number >= 1}
        spot := xNumber[0];
        if spot < 0 then spot := spot + $8000;        {remove sign of x}
        spot := spot - $3fff;                         {remove bias}
        sig_fform := (spot >= 0)
     end;
     fp_free_ascii(xNumber, width, myFormat, tempStr)
  end
  else begin                                  {was FP_f}
          with myDecForm do begin
             after := formatNum - 2;
             style := FixedDecimal;
             digits:= after
          end;
          X2Str (myDecForm, Xnumber, tempStr)
       end;
   error    := true;
   errorNum := 0;
   case FPkind of
      infinite  : if sgn = 1 then errorNum := mMINF
                  else errorNum := mPINF;
      SNan,QNan : errorNum := mError;
      zero      : begin
                   case formatNum of
                      mZeroDec,
                      mDefault  : tempStr := '0';
                      mOneDec   : tempStr := '0.0';
                      mTwoDec   : tempStr := '0.00';
                      mThreeDec : tempStr := '0.000';
                      mFourDec  : tempStr := '0.0000'
                   end;
                   error := false
                end;
      otherwise begin
                   error := ((pos('e', tempStr) <> 0) or(pos('E', tempStr) <> 0)) and not debugFlag;
                   if error or (length(tempStr) > width) then errorNum := mOverFlow
                   else if formatNum = mZeroDec then tempStr := copy(tempStr, 1, length(tempStr)-1);

                   if tracing then begin
                      write('FPmoveP: f,w,b,a,nF,err: ',formatNum:1,',',width:1,',',
                            after:1,',');
                            (*
                            case nFormat of
                               FP_lisa : write('FP_Lisa');
                               FP_e    : write('FP_e');
                               FP_i    : write('FP_i');
                               FP_f    : write('FP_f');
                               FP_free : write('FP_free');
                               FP_iround: write('FP_iround');
                               otherwise  write('Unk: ',ord(nFormat))
                            end;
                            *)
                      writeln('  FPresult(',length(tempStr):1,'): ',tempStr,'  ',error)
                   end
                end;
   end;
   if errorNum <> 0 then begin
      GetItem(myMenus[mBuzz2Words], errorNum, @menustr);
      tempStr := menuStr
   end;
   result := tempStr
end;


{--------------------------------------------------------------------------------------------------
   DoDispSelection - make a selection out of the x register if the mouse in pointing at it.  An
                     `alertnum` will be returned which signals which alert, if any, that should be
                     displayed.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure DoDispSelection(pt : Point; var alertNum : integer);
begin
   alertNum := 0;
   if PtInRect(pt, entryFLD^^.coords) then
      with C^ do
         if lockDisp then alertNum := 104
         else begin
                 RemoveSelection(true);
                 bSelect := 0;
                 eSelect := 0;
                 ChkEditMenu;
                 ShowSelection(false, false)
              end
   else alertNum := 113
end;


{--------------------------------------------------------------------------------------------------
   DoHiLiteRect - places a hilite in the rectangle given.  The hilite will appear dimly lite if
                  `dim` is set to true.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure DoHiLiteRect(hiLiteRect : rect; dim : boolean);
var oldPnPat : pattern;
    oldPnMode : integer;
begin
   oldPnPat  := thePort^.pnPat;
   oldPnMode := thePort^.pnMode;

   { old dim highlight code - removed 1/30/84
   if dim then StuffHex(@thePort^.pnPat, '8800220088002200')
   else}

   PenPat(black);
   PenMode(patXor);
   PaintRect(hiLiteRect);
   PenPat(oldPnPat);
   PenMode(oldPnMode)
end;


{--------------------------------------------------------------------------------------------------
   doOperation - performs the calculation given by `calculation`.  The registers used in the
                 calculation will be 0 & 1, with the result placed in register 0.  The calculated
                 result will be forced to be displayed if `daraResult` is true.  Register 1 will
                 not be changed by the calculations.  `doSwap` signals if the data in the
                 registers are to be swapped before the calculation is done.  If the calculated
                 result underflows, less than `VofLesser`, a zero will be returned.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure doOperation{calculation : symbol; drawResult : boolean; doSwap : boolean};
var
  FP0, FP1 : extended;     { temporaries }

  procedure FPswap;
  var
    temp : extended;
  begin
    temp := FP0;
    FP0  := FP1;
    FP1  := temp;
  end;

begin
   with C^ do begin
      D2X (regs[0], FP0);
      D2X (regs[1], FP1);
     case calculation of
         sMULop     : MulX (FP1, FP0);               { FP0 <-- FP0 * FP1 }
         sADDop     : AddX (FP1, FP0);               { FP0 <-- FP0 + FP1 }
         sSUBop     : begin
                         if doSwap then FPswap;
                         SubX (FP1, FP0);
                      end;
         sDIVop     : begin
                         if doSwap then FPswap;
                         DivX (FP1, FP0);
                      end;
         sSQRTop    : SqrtX (FP0);
         sPERCENTop : with c^ do begin
                         D2X (regs[0], FP1);        { FP1 <-- reg[0] }
                         I2X (100, FP0);            { FP0 <-- 100 }
                         DivX (FP0, FP1);           { FP1 <-- reg[0]/100 }
                         D2X (regs[1], FP0);        { FP0 <-- reg[1] }
                         case calcStyle of
                            Business,
                            Algebraic : case pendCalcop of
                                           sADDop : begin
                                                       MulX (FP0, FP1);  { FP1 <-- reg[1] * reg[0]/100 }
                                                       AddX (FP1, FP0);  { FP0 <-- reg[1] +
                                                                                   reg[1] * reg[0]/100 }
                                                    end;
                                           sSUBop : begin
                                                       MulX (FP0, FP1);  { FP1 <-- reg[1] * reg[0]/100 }
                                                       SubX (FP1, FP0);  { FP0 <-- reg[1] -
                                                                         {         reg[1] * reg[0]/100 }
                                                    end;
                                           sMULop : begin
                                                       MulX (FP1, FP0);  { FP0 <-- reg[1] * reg[0]/100 }
                                                    end;
                                           sDIVop : begin
                                                       DivX (FP1, FP0);  { FP0 <-- reg[1] / reg[0]/100 }
                                                    end
                                        end;
                            Polish    : begin
                                           MulX (FP1, FP0);              { FP0 <-- reg[1] * reg[0]/100 }
                                        end
                         end
                      end;
         sCHSop     : NegX (FP0);
         sINVop     : begin
                         X2X (FP0, FP1);                                 { FP1 <-- reg[0] }
                         I2X (1, FP0);                                   { FP0 <-- 1 }
                         DivX (FP1, FP0);                                { FP0 <-- 1/reg[0] }
                      end
       end;
      X2D (FP0, regs[0]);
      AbsX (FP0);
      D2X (VofLesser, FP1);
      if (RelX (FP0, FP1) = LT) then ClrReg(0);
      if drawResult then DrawReg(0, false, false)
   end
end;


{--------------------------------------------------------------------------------------------------
   DoSetPort - Set the graf port and clipping area to be `window`.  `erase` signals if the portrect
               of the graf port is to be erased.  This routine is mainly to save code space.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure DoSetPort(window : grafPtr; erase : boolean);
begin
   SetPort(window);
   with window^ do begin
      ClipRect(portrect);
      if erase then EraseRect(portRect)
   end
end;


{--------------------------------------------------------------------------------------------------
   DoTapeSelection - make a selection on the tape if the mouse in pointing in it.  An `alertnum`
                     will be returned which signals which alert, if any, that should be displayed.
                     The user is allowed to select a single line on the tape by clicking once.
                     Multiple lines of the tape may be selected by clicking and dragging the mouse;
                     the screen will automatically scroll to show uncovered portions of the tape.
                     The entire tape maybe selected by clicking twice or three times.  The selection
                     on the tape maybe extended by using the shift-click convention.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure DoTapeSelection(pt : Point; var alertNum : integer);
var sInfo       : selectInfo;
    origRow     : integer;
    newRow      : integer;
    lastLine    : integer;
    beats       : integer;
    IconHit     : TIcon;
begin
   with C^, sInfo do begin
      if lockDisp then alertNum := 104
      else begin
              if bSelect <= 0 then begin
                 clickTime  := time;
                 clickCount := 1
              end
              else if clickCount > 2 then begin
                      clickCount := 1;
                      clickTime  := time
                   end
              else clickCount := clickCount + 1;
              beats := (time - clickTime) div clickDelay;
              if ((beats > 1) and (clickCount <= 2)) or (beats > 2) then begin
                 clickTime  := time;
                 clickCount := 1
              end;
              SetPort(myWindow);
              ClipRect(tapePortRect);

              if theEvent.shiftKey then origRow  := bSelect - 1
              else origRow  := (pt.v - tapeHeight div 2) div tapeHeight + topTapeEntry;
              startRow := origRow;
              endRow   := startRow;
              oldStart := -1;
              oldEnd   := -1;

              RemoveSelection(true);
              ChgGray(mEdit, mCopy, false);
              ChgGray(mEdit, mPaste, true);
              ChgGray(mEdit, mCut, true);

              if clickCount <= 1 then
                 repeat
                    newRow  := (pt.v - tapeHeight div 2) div tapeHeight + topTapeEntry;
                    IconHit := IconThumb;
                    if pt.v < 0 then begin
                       if (endRow > topTapeEntry) and (endRow > origRow) then newRow := endRow -1
                       else IconHit := IconArwA
                    end
                    else if pt.v > tapePortRect.bottom then begin
                            if (startRow < topTapeEntry + numLinesVis) and (startRow < origRow) then
                                newRow := startRow + 1
                            else IconHit := IconArwB
                         end;
                    if IconHit <> IconThumb then ScrollTape(pt, hsbV, IconHit, false, true);
                    case IconHit of
                       IconArwA : begin
                                     startRow := topTapeEntry;
                                     endRow   := origRow
                                  end;
                       IconArwB : begin
                                     if startRow < origRow then begin
                                        if origRow >= topTapeEntry + numLinesVis  then begin
                                           startRow := topTapeEntry + numLinesVis;
                                           endRow   := origRow
                                        end
                                        else begin
                                                endRow  := origRow;
                                                origRow := StartRow
                                             end
                                     end
                                     else begin
                                             startRow := origRow;
                                             endRow   := topTapeEntry + numLinesVis
                                          end;
                                     if oldEnd > endRow - 2 then oldEnd := endRow - 2;
                                     if oldEnd < 0 then oldEnd := 0;
                                     if oldEnd < oldStart then oldStart := oldEnd
                                  end;
                       otherwise  begin
                                     if newRow <= startRow then begin
                                        startRow := newRow;
                                        endRow   := origRow;
                                     end
                                     else begin
                                             startRow := origRow;
                                             endRow   := newRow
                                          end;
                                     if startRow > endRow then begin
                                        newRow   := StartRow;
                                        startRow := endRow;
                                        endRow   := newRow
                                     end
                                  end;
                    end;
                    DrawTape(topTapeEntry, sInfo, false, false, false, true, false);
                    oldStart := startRow;
                    oldEnd   := endRow;
                    GetMouse(pt)
                 until not stillDown;

              if clickCount > 1 then begin
                 startRow := 0;
                 endRow   := tapeCnt
              end;
              bSelect := startRow + 1;
              eSelect := endRow + 1;
              ChgGray(mFilePrint, mPrint, false);
              if clickCount > 1 then ShowSelection(false, false);
(*$IFC CalcDebug *)
              if debugging then
                 Writeln('DoTapeSelection: ',bSelect:1,',',eSelect:1,'  alert: ',alertNum:1,
                         '  ',clickcount:1,' ',clickDelay:1,',',beats:1);
(*$ENDC *)
              alertNum := 0
           end
   end
end;


{--------------------------------------------------------------------------------------------------
   doUpdateEvent - causes the grafport `window` to be updated.  The updated make be a normal
                   update generated by uncovering portions of the window or a forced one done by
                   the calculator.
 -------------------------------------------------------------------------------------------------}
(*$S     *)
procedure doUpdateEvent(normal : boolean; window : grafPtr);
begin
   if normal then BeginUpdate(window);          { sets visRgn to updateRgn }
   DrawContents(window, not normal, false);
   if activeFolder = window then DrawScrollBars(window)
   else RemoveScrollBars(window);
   if normal then EndUpdate(window);            { restores visRgn and clears updateRgn }
end;


{------------------------------------------------------------------------------
   DrawContents - displays current window contents.
 -----------------------------------------------------------------------------}
(*$S     *)
procedure DrawContents{window : WindowPtr; doInvert, deActive : boolean};
var tempRect     : Rect;
    sKind        : ScrapType;
    scrapPtr     : Th;
    sPlace       : TB;
    errNum       : integer;
    displacement : integer;
begin
   if window <> ScrapFolder then begin
      doSetPort(window, true);
      displacement := c^.memDisp + c^.regsDisp + c^.entryDisp;

      textfont(calcFont);
      textface([]);
      MoveTo(PadHDisp, PadVDisp + displacement - keyheight);
      DrawString('3456');                                       {    M-  M+  M*  }

      MoveTo(PadHDisp, PadVDisp + displacement);
      if c^.calcStyle = Business then DrawString('A;<D')
      else DrawString('ABCD');                                  { ce/c  -  +  *  }

      MoveTo(PadHDisp, PadVDisp + keyHeight + displacement);
      DrawString('EFGH');                                       { 7   8   9   /  }

      MoveTo(PadHDisp, PadVDisp + 2*keyHeight + displacement);
      DrawString('IJKL');                                       { 4   5   6   %  }

      MoveTo(PadHDisp, PadVDisp + 3*keyHeight + displacement);
      case c^.calcStyle of
         Algebraic : DrawString('MNO2');
         Polish    : DrawString('MNOP');
         Business  : DrawString('9NO7')
      end;                                                      { 1   2   3  ent }

      MoveTo(PadHDisp, PadVDisp + 4*keyHeight + displacement);
      case c^.calcStyle of
         Algebraic : DrawString('QRS1');
         Polish    : DrawString('QRST');
         Business  : DrawString('QRS8')
      end;                                                      {     0   .   er }

      SetRect(tempRect, dispWid, dispToEntry + displacement, calcWidth - dispWid - 6,
                        displacement + dispToEntry + FontHeight);
      SetFCoords(entryFLD, entryFSH, tempRect);
      PenNormal;
      insetrect(temprect, -2, -2);
      framerect(tempRect);
      if entryLen > 0 then DrawEntry
      else DrawReg(0, false, false);

      doSetPort(window, false);
      PenNormal;
      if c^.showTape then begin
         PenSize(tapePspacing, 1);
         MoveTo(calcWidth, 0);
         LineTo(calcWidth, myWindow^.portrect.bottom)
      end;

      if deActive or (ActiveFolder <> myWindow) then DrawFormula([dMem, dRegs, dATape])
      else DrawFormula([dMem, dRegs, dTape]);
      if c^.bSelect = 0 then ShowSelection(deActive or (ActiveFolder <> myWindow), doInvert);

      if butInvert then begin
         with buttons[C^.butPressed] do PressKey(ch, shifted);
         butInvert := true
      end

   end
   else begin
           { Draw the scrap }
           GetScrap(sKind, scrapPtr);
           GetCSScrap(sPlace);
           doSetPort(scrapFolder, true);
           if sKind = picScrapType then DrawUscrap(errNum)
           else if (sKind = ScrapFE) or (sPlace <> 0) then DrawScrap(errNum);
           if activeFolder = scrapFolder then DrawScrollBars(ScrapFolder)
           else RemoveScrollBars(ScrapFolder);
        end;
end;


{------------------------------------------------------------------------------
   DrawEntry - draw in the entry field in the entry window.
 -----------------------------------------------------------------------------}
(*$S     *)
procedure DrawEntry;
begin
   doSetPort(myWindow, false);
   DrawField(entryFLD, entryFSH, false, true)
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure DrawFormula{display : tDisplays};
var tempRect : rect;
    result   : calcStr;
    sCH      : string[10];
    error    : boolean;
    menuStr  : str255;
    leftEdge : integer;
    rightEdge: integer;
    rNameEdge: integer;
    x        : integer;
    tFormat  : integer;

    lines    : array [1..3] of integer;
    start    : longint;

    procedure DrawRightString(dv : integer; str : str255);
    begin
       moveto(rightEdge - StringWidth(str) - 2, dv);
       DrawString(str)
    end;


    procedure GetOperString;
    var opItem  : integer;
    begin
       case c^.pendCalcop of
          sADDop     : opItem := mAdd;
          sSUBop     : opItem := mSub;
          sMULop     : opItem := mMul;
          sDIVop     : opItem := mDiv;
          sSQRTop    : opItem := mSqrt;
          otherwise    exit(GetOperString)
       end;
       TextFont(fieldFont);
       GetItem(myMenus[mBuzzWords], opItem, @menuStr);
       DrawOperString(menuStr);
       TextFont(formFont);
    end;


    procedure setUpedges;
    begin
       leftEdge  := tempRect.left + 2;
       rightEdge := tempRect.right;
       rNameEdge := tempRect.right + CharWidth(spaces[1]);
       lines[3]  := tempRect.bottom - 2 * formHeight - 2;
       lines[2]  := tempRect.bottom - formHeight - 2;
       lines[1]  := tempRect.bottom - 2;
       insetrect(temprect, -2, -1);
       eraseRect(tempRect);
       frameRect(tempRect);
       insetrect(temprect, 2, 1);
       tempRect.left  := rNameEdge;
       tempRect.right := tempRect.left + StringWidth('YY');
       EraseRect(tempRect)
    end;


begin
   doSetPort(myWindow, false);
   TextFont(formFont);
   textface([]);
   PenNormal;

   with c^ do begin
      tFormat := dispFormat;
      dispFormat := mDefault;
      if showdata then begin
         SetRect(tempRect, dispWid, 2, calcWidth - dispWid - 6, entryDisp-2);
         SetUpEdges;

         for x := 0 to maxRegisters+debugReg do begin
            if x = 0 then DISPfromFP(memory[0], result, error)
            else if x > debugReg-1 then DISPfromFP(regs[x-debugReg], result, error)
            else result := '';
            moveTo(dispWid+2, formHeight * (x+1) + 2);
            case x of
               0       : menustr := 'Memory: ';
               1       : begin
                            case pendCalcop of
                               sADDop  : menustr := 'P: Add  ';
                               sSUBop  : menustr := 'P: Sub  ';
                               sMULop  : menustr := 'P: Mul  ';
                               sDIVop  : menustr := 'P: Div  ';
                               otherwise menustr := 'P: None  '
                            end;
                            case secondOp of
                               sADDop  : menustr := concat(menuStr, 'S: Add');
                               sSUBop  : menustr := concat(menuStr, 'S: Sub');
                               sMULop  : menustr := concat(menuStr, 'S: Mul');
                               sDIVop  : menustr := concat(menuStr, 'S: Div');
                               sPERCENTop : menustr := concat(menuStr, 'S: %');
                               sSQRTop : menustr := concat(menuStr, 'S: Ã');
                               sCHSop : menustr := concat(menuStr, 'S: +/-');
                               otherwise menustr := concat(menuStr, 'S: None: ')
                            end
                         end;
               2       : if enterKeyHit then menustr := 'EnterKeyHit = True'
                         else menustr := 'EnterKeyHit = false';
               3       : if operpending then menustr := 'operpending = True'
                         else menustr := 'operpending = false';
               4       : if valueenterd then menustr := 'valueEnterd = True'
                         else menustr := 'valueEnterd = false';
               5       : if subtotal then menustr := 'subtotal = True'
                         else menustr := 'subtotal = false';
               6       : if clrKey then menustr := 'clrKey = True'
                         else menustr := 'clrKey = false';
               7       : if firstchr then menustr := 'firstchr = True'
                         else menustr := 'firstchr = false';
               8       : if userDecimal then menustr := 'userDecimal = True'
                         else menustr := 'userDecimal = false';
               9       : begin
                            SfromEntry(result);
                            menuStr := 'Entry: '
                         end;
               otherwise begin
                            menustr := 'Reg(0): ';
                            menustr[5] := chr(x-debugReg+48)
                         end;
            end;
            DrawString(concat(menustr, result))
         end;
         start := time + 100;
         repeat until time > start
      end;

      if dMem in display then begin
         if showMem then begin
            SetRect(tempRect, dispWid, entryDisp  + dispToEntry, calcWidth - dispWid - 6, 0);
            tempRect.bottom := tempRect.top + formHeight;
            SetUpEdges;
            DISPfromFP(memory[0], result, error);
            moveTo(leftEdge, lines[1]);
            GetItem(myMenus[mBuzz2Words], mMemory, @menuStr);
            DrawString(concat(menuStr, ': ', result));
            MoveTo(rNameEdge, lines[1]);
            if showRegs then DrawChar('M')
         end
      end;

      if dRegs in display then begin
         if showRegs then begin
            tempRect := entryFLD^^.coords;
            tempRect.left  := tempRect.right + CharWidth(spaces[1]);
            tempRect.right := tempRect.left + stringWidth('X');
            eraseRect(tempRect);
            MoveTo(tempRect.left, tempRect.bottom - 3);
            if showRegs then DrawChar('X')
            else DrawChar(spaces[1]);


            SetRect(tempRect, dispWid, entryDisp + dispToEntry + memDisp, calcWidth - dispWid - 6, 0);
            tempRect.bottom := tempRect.top + RegDispLines(calcStyle) * formHeight;
            SetUpEdges;

            case calcStyle of
               Algebraic : if enterKeyHit then begin
                              if pendCalcOp = sMulOp then begin
                                 sCH := 'YK';
                                 x   := 2
                              end
                              else begin
                                      sCH := 'KY';
                                      x   := 3
                                   end;
                              DISPfromFP(regs[x], result, error);
                              DrawRightString(lines[2], result);
                              if pendCalcOp = sMulOp then x := 3
                              else x := 2;
                              DISPfromFP(regs[x], result, error);
                              DrawRightString(lines[1], result);
                              Moveto(leftEdge, lines[1]);
                              GetOperString;
                              if pendCalcOp <> sMulOp then begin
                                 MoveTo(rNameEdge, lines[1]);
                                 DrawChar(sCH[1])
                              end;
                              MoveTo(rNameEdge, lines[2]);
                              DrawChar(sCH[2]);
                              if pendCalcOp = sMulOp then DrawChar(sCH[1])
                           end
                           else begin
                                   DISPfromFP(regs[1], result, error);
                                   DrawRightString(lines[2], result);
                                   moveTo(leftedge, lines[1]);
                                   GetOperString;
                                   MoveTo(rNameEdge, lines[2]);
                                   DrawChar('Y');
                                   if not operPending then begin
                                      DispFromFP(regs[3], result, error);
                                      case secondOp of
                                         sPercentOp : sCH := '%';
                                         sCHSop     : sCH := '+/-';
                                         otherwise    sCH := '';
                                      end;
                                      if sCH <> '' then DrawRightString(lines[1], concat(result, sCH))
                                   end
                                end;
               Polish    : begin
                              sCH := 'YZT';
                              for x := 1 to maxRegisters do begin
                                 DISPfromFP(regs[x - ord(firstChr)], result, error);
                                 DrawRightString(lines[x], result);
                                 MoveTo(rNameEdge, lines[x]);
                                 DrawChar(sCH[x])
                              end
                           end;
               Business  : begin
                              GetItem(myMenus[mBuzzWords], mSubTotal, @menuStr);
                              if subTotal then x := 2
                              else x := 0;
                              DISPfromFP(regs[x], result, error);
                              moveTo(leftEdge, lines[1]);
                              DrawOperString(concat(menuStr, ': ', result));
                              MoveTo(rNameEdge, lines[1]);
                              DrawOperString('×')
                           end
            end
         end
      end;

      if dTape in display then DrawTape(topTapeEntry, nullSel, false, false, false, false, false)
      else if dATape in display then DrawTape(topTapeEntry, nullSel, false, true, false, false, false);
      dispFormat := tFormat;

   end;
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S         *)
procedure DrawGraphics;
var scrErr     : integer;
    rectAll    : rect;
    cPicHandle : PicHandle;
    saveHeap   : THz;
    sPlace     : TB;
begin
   (* Make the scrap mine and get rid of the old data *)
   InheritScrap(True);
   EraseScrapData(scrErr);
{$IFC CalcDebug }
   if scrErr <> 0 then writeln('EraseScrapData returned: ', scrErr:1);
{$ENDC }

   (* Save away the current heap zone, install the scrap's heap zone *)
   GetHeap(saveHeap);
   SetHeap(HzofScrap);
   StartPutScrap(scrErr);
{$IFC CalcDebug }
   if scrErr <> 0 then writeln('Startputscrap returned: ', scrErr:1);
{$ENDC }

   (* Turn on the cut flag and draw the graph. All the picture records go into the scrap heap *)
   rectAll.top    := 0;
   rectAll.left   := 0;
   rectAll.right  := defTapeWidth;
   rectAll.bottom := tapeHeight * (C^.eSelect - C^.bSelect + 1);
   genScrapPic    := true;
   cPicHandle := OpenPicture(RectAll);
   PicComment(cPicGeDwg, 0, nil);
   DrawTape(C^.bSelect - 1, nullSel, false, false, true, false, false);
   ClosePicture;
   genScrapPic    := false;

   (* Install the handle into the scrap data structures. *)
   PutScrap(picScrapType, pointer(ord(cPicHandle)), scrErr);
{$IFC CalcDebug }
   if scrErr <> 0 then writeln('putscrap returned: ', scrErr:1);
{$ENDC }

   PutGrScrap(pointer(ord(cPicHandle)), scrErr);
{$IFC CalcDebug }
   if scrErr <> 0 then writeln('putGrscrap returned: ', scrErr:1);
{$ENDC }

   EndPutScrap(scrErr);

   (* Draw the universal graphics picture in the scrap *)
   DrawUScrap(ScrErr);
{$IFC CalcDebug }
   if scrErr <> 0 then writeln('DrawUScrap returned: ', scrErr:1);
{$ENDC }
   SetHeap(saveHeap);
   WritelCut(tapeChrWid, tapeFid, scrErr);
(*$IFC CALCdebug *)
   if tracing or statusMsg then begin
      writeln('WriteLCut: ',scrErr:1);
      GetCSScrap(sPlace);
      writeln('GetCSScrap: ',sPlace:1)
   end
(*$ENDC *)
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure DrawOperString{strng : str255};
var pt      : point;
    fInfo   : FontInfo;
    x,y     : integer;
    chWid   : integer;
    hChWid  : integer;
begin
   GetFontInfo(fInfo);
   chWid := charWidth('/');
   for x := 1 to length(strng) do
      if strng[x] = 'Á' then strng[x] := '/';
   drawString(strng)
end;


{------------------------------------------------------------------------------
   DrawReg - the register # REGNUM should be displayed in the entry
             window.  The value for the register is converted to a
             string which is displayed.
 -----------------------------------------------------------------------------}
(*$S     *)
procedure DrawReg{regNum : regRange; inScrap : boolean; cutField : boolean};
var status    : integer;
    entryLine : calcStr;
    x         : integer;
begin
   SfromEntry(entryLine);

   if (entryLen = 0) or not inScrap then RegtoEntry(regNum, true, true) ;

   {if data is to goto the scrap, select the entire field and cut/copy it.  Otherwise
    display the register in the entry line
   }
   if inScrap then begin
      SelectAll(entryFld, entryFSH, status);
      SetRunFormat(entryFLD, nil, fieldFont, setNormal, status);
      CutCopyField(entryFLD, entryFSH, cutField, true, status);
      SetRunFormat(entryFLD, nil, fieldFont, setbold, status);
      ExitField(entryFLD, entryFSH);
      RemoveScrollBars(ScrapFolder);
      ShowSelection(false, false);
      entryLine := '';
   end
   else if length(entryLine) <> 0 then DrawEntry;

   ClrEntry;
   for x := 1 to length(entryLine) do InsertAChr(entryLine[x], false, true)

end;


{------------------------------------------------------------------------------
   DrawScrollBars -  Paints the scroll bars.  Sets clipping to protect them.
 -----------------------------------------------------------------------------}
procedure DrawScrollBars{window : WindowPtr};
var rH,rV : rect;
begin
   if (window = myWindow) and not c^.showTape then exit(DrawScrollBars);

   doSetPort(window, false);

      { get rectangles for scroll bars }
   FlushRects(rH,rV);

   SetSbRect(hsbV, rV);                 { set the rectangular area to be drawn }
   if window = myWindow then begin
       SetSbIcons(hsbV, [iconArwA, iconPagA, iconThumb, iconPagB, iconArwB]);
       rH.left := TapePortRect.left
   end
   else SetSbIcons(hsbV, []);
   SetSbRect(hsbH, rH);

   PaintSb(hsbV);               { display the scroll bars and grow icon }
   PaintSb(hsbH);
   if window <> myWindow then begin
      PaintGrow;

      {reset scroll structure to that of the main folder}
      if myWindow <> nil then begin
         doSetPort(myWindow, false);
         FlushRects(rH,rV);
         SetSbIcons(hsbV, [iconArwA, iconPagA, iconThumb, iconPagB, iconArwB]);
         SetSbRect(hsbV, rV);
         rH.left := TapePortRect.left;
         SetSbRect(hsbH, rH)
      end
   end
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure DrawTape{newTopEntry : integer; sInfo : SelectInfo; doNotErase, dim, drawSelCels, drawSelection,
                   drawLonly : boolean};
var diff        : integer;
    stopScroll  : integer;
    startScroll : integer;
    entryNum    : integer;
    scrollUp    : boolean;
    doDisplay   : boolean;
    inOldSel    : boolean;
    inNewSel    : boolean;
    shoSel      : boolean;
    fInfo       : FontInfo;
    operStr     : str255;
    temp        : rect;
    myFntId  : TLfntId;
    fontOk   : boolean;
    fError   : integer;
begin
   if c^.showTape then begin
      if not genPrintPic then SetPort(myWindow);
      if genScrapPic then begin
         temp := myWindow^.portRect;
         temp.right  := temp.left + defTapeWidth;
         temp.bottom := tapeHeight * (C^.eSelect - C^.bSelect + 1) + 1;
         insetrect(temp, -2, -2);
         ClipRect(temp);
         PenNormal;
         FrameRect(temp)
      end
      else if genPrintPic then begin
(*$IFC CalcDebug *)
              if tracing then
                 with pRPrintable do
                     writeln('pRPrintable: ',top:1,',',left:1,'  ',bottom:1,',',right:1,
                             '   pStartEntry:',pStartEntry:1,'   pStopEntry:',pStopEntry:1);
(*$ENDC *)
              ClipRect(pRPrintable);
              EraseRect(pRPrintable);
              PenNormal;
              FrameRect(pRPrintable)
           end
      else ClipRect(tapePortRect);
      if drawSelCels then begin
         if genPrintPic then begin
            startScroll := pStartEntry;
            stopScroll  := pStopEntry;
         end
         else begin
                 startScroll := C^.bSelect - 1;
                 stopScroll  := C^.eSelect - 1;
              end
      end
      else begin
              diff        := newTopEntry - c^.topTapeEntry;
              scrollUp    := (diff < 0);
              if (diff = 0) or (abs(diff) > numLinesVis) then begin
                 if doNotErase and (diff = 0) then begin
                    startScroll := c^.tapeCnt;
                    stopScroll  := c^.tapeCnt
                 end
                 else begin
                         startScroll := newTopEntry;
                         stopScroll  := startScroll + numLinesVis;
                         if not(drawSelection or drawLonly) then EraseRect(tapePortRect)
                      end
              end
              else begin
                      if scrollUp then begin
                         startScroll:= newTopEntry;
                         if doNotErase then stopScroll := startScroll + numLinesVis + 1
                         else stopScroll := startScroll + abs(diff) - 1
                      end
                      else begin
                              startScroll := c^.topTapeEntry + numLinesVis;
                              stopScroll  := startScroll + abs(diff)
                           end;
                      ScrollRect(tapePortRect, 0, -diff * tapeHeight, thePort^.clipRgn);
                      ClipRect(tapePortRect)
                   end;
              c^.topTapeEntry := newTopEntry
           end;

      TextFont(tapeFont);
      TextFace([]);
      GetFontInfo(fInfo);
      if genPrintPic then begin
         PrLfntid(C^.header.printer.config, tapeFont, [], myFntId);
         fontOk := FMFontMetrics(myFntId, fInfo, ferror)
      end;

(*$IFC CalcDebug *)
      if debugging then begin
         writeln('Up: ',scrollUp,'  diff: ',diff:1,'  b/e: ',startScroll:1,',',stopScroll:1,
                 '  top/new: ',C^.topTapeEntry:1,',',newTopEntry:1);
         writeln('sInfo: ',sinfo.startRow:1,',',sinfo.endRow:1,' ',sinfo.oldStart:1,',',sinfo.oldEnd:1);
      end;
(*$ENDC *)
      for entryNum := startScroll to stopScroll do
         if entryNum <= c^.tapeCnt then begin
            doDisplay := true;
            shoSel    := false;
            if drawSelection then begin
               inOldSel := (entryNum >= sInfo.oldStart) and (entryNum <= sInfo.oldEnd);
               inNewSel := (entryNum >= sInfo.startRow) and (entryNum <= sInfo.endRow);
               if inOldSel then begin
                  if inNewSel then doDisplay := false
               end
               else begin
                       shoSel    := true;
                       doDisplay := inNewSel;
                    end;
            end;
            if doDisplay then
               ShowEntry(entryNum, newTopEntry, fInfo, (entryNum = stopScroll) or drawSelection,
                         true, dim, shoSel, drawLonly, operStr)
         end;
      if c^.dispFormat <> mDefault then SetRnd (c^.roundmode)
      else SetRnd (TONEAREST)
   end
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
function entryCH{index : integer) : char};
var ch : char;
begin
   if (index > 0) and (index <= entryFLD^^.curLen) then
(*$R- *)
      ch := chr(entryFLD^^.curValue^^[index-1])
(*$IFC RangeChk *)
(*$R+ *)
(*$ENDC *)
   else ch := chr(255);
   entryCH := ch;
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
function entryLen{ : integer};
begin
   entryLen := entryFLD^^.curlen;
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure failedAlert;
begin
   StopAlert(allalerts, 2);
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S initCode *)
procedure Initialize;
var dfPathname  : Pathname;
    i,err,ioerr : integer;
    pcInfo      : ProcInfoRec;
    menuFile    : text;         { used for reading the menu text file }
    ptTopLeft   : Point;
    class       : letterclass;
    ch          : char;
    triplesStr  : Tstr;
    tempRect    : rect;
    TexcepName  : T_Ex_Name;
    myKeys      : keySet;
    menuStr     : str255;
    sCh         : string[1];
    aRefNum     : integer;
    FP0,FP1     : extended;

    function GetFontHeight(family : integer) : integer;
    var sFInfo : FontInfo;       { Font Metrics about the system font        }
        sFntid : TLfntid;      { Font Mgr long font ID for the system font }
    begin
       with sFntId do begin               {Init the system font & table font}
          Fam      := family;
          seteface := [];
          dev      := devScreen
       end;

       if not FMFontMetrics(sFntId, sFInfo, err) then
          if err <> 0 then  begin
(*$IFC CALCdebug *)
             if tracing or statusMsg then writeln('Unable to open system font  err = ',err:1);
(*$ENDC *)
             TellFiler (err, initFailed, noDiskSpace, nil);
             halt
          end;
       GetFontHeight := sFInfo.ascent + sFInfo.descent + sFInfo.leading
    end;


begin

      { Set up the O/S terminate exception handler }
      { This should be the first thing done, in case of a crash in initialization }

   TexcepName := 'SYS_TERMINATE';
   Declare_Excep_Hdl(err, TexcepName, @LastWishes);
   if err <> 0 then begin
(*$IFC CALCdebug *)
      if tracing or statusMsg then writeln(My_Id:1,' Declar_Excep_Hdl error: ',err:1);
(*$ENDC *)
      TellFiler (err, initFailed, noMemory, nil);{ insures someone else is OS active }
      halt
   end;

   InitLCutProcs                        {init procedure pointers for LCut}
     (@CellBlank,
      @CellInfo,
      @CellValue,
      @FinalDataSnip,
      @GetSnipId,
      @RgInScrap,
      @SnipWidth,
      @SwitchTable
     );

   toldToDie    := false;   { set to TRUE on "fcTerminate".  Flags abnormal death }
   procsInit    := false;   { set to TRUE on "fcTerminate".  Flags abnormal death }
   myWindow     := nil;
   spaces       := '';
   sCh          := ' ';
   sCh[1]       := chr(202);
   for i := 1 to 40 do spaces := concat(spaces, sCh);

   InitHeap(@calcZone[0], @calcZone[maxHeapSize], @OutOfHeapSpace);

   Sched_Class(sErrNum, false);
   Info_Process(err, My_ID, pcInfo);
   Sched_Class(sErrNum, true);

   InitMp(theHeap, concat(copy(pcInfo.ProgPathName, 1, pos('-{',pcInfo.progPathName)-1), '-{t12}'), @failedAlert, alertVerNum, @mymenus, allAlerts, ioerr);
   if ioerr <> 0 then begin
(*$IFC CALCdebug *)
      writeln('while reading alert/menu file "',concat(copy(pcInfo.ProgPathName, 1, pos('-{',pcInfo.progPathName)-1), '-{t12}'),'": ',ioerr:1);
(*$ENDC *)
      halt
   end;
   PrMgrInit;

(*$IFC CALCdebug *)
   GetKeys(myKeys);
   debugging    := eventDebug or ((126 in myKeys) and (104 in myKeys));
   tracing      := eventDebug or (debugging and (127 in myKeys));
   statusMsgs   := debugging or TRUE;
   showdebug    := false;
   debugflag    := false;
   showdata     := false;
   if tracing or debugging then writeln('Welcome to the calculator');
   if debugging then begin
      writeln('Hold down ''right option'' key to continue');
      repeat
         getkeys(myKeys)
      until 78 in myKeys
   end;
(*$ENDC *)

   ChgGray(mFilePrint, mBlank1, true);
   ChgGray(mFilePrint, mBlank2, true);
   ChgGray(mEdit, mBlank3, true);
   ChgGray(mEdit, mBlank4, true);
   ChgGray(mFormat, mBlank5, true);
   ChgGray(mCustomize, mBlank6, true);
   ChgGray(mCustomize, mBlank7, true);
   ChgGray(mScrap, mBlank8, true);
   GetItem(myMenus[mBuzz2Words], FEtriples, @menuStr);
   triplesStr := menuStr;

   FEinit(theHeap, @triplesStr, err);
   if err <> 0 then begin
(*$IFC CALCdebug *)
      writeln('Error #',err:1,' while doing FEinit');
(*$ENDC *)
      TellFiler (err, initFailed, noDiskSpace, nil);
      halt
   end;

   InitWmlCrs(err);              {Init cursors and scroll boxes}
   if err <> 0 then begin
{$IFC CALCdebug }
      writeln(chr(7),'InitWmlCrs - error: ',err:1);
{$ENDC }
      TellFiler (err, initFailed, noDiskSpace, nil);
      halt
   end;

   InitWmlSb;                           { initialize the scrollbar library }
   InitSbList(sbList,theHeap);          { intialize the scroll bar list descriptor }
   SetPt(ptTopLeft, 0, 0);              { set the topLeft pt to some arbitrary value }

      { allocate the scroll bar data strucutures in the heap }
   hsbV := sbCreate(sbList, hsbNil, tyvhV, ptTopLeft, 0);
   hsbH := sbCreate(sbList, hsbNil, tyvhH, ptTopLeft, 0); { h scroll bar is now first }
   SetSbIcons(hsbH,[]);

   TextFont(tapeFont);
   Textface([]);
   with tapeFid do begin               {Init the tape font id}
      Fam      := tapeFont;
      seteface := [];
      dev      := devScreen
   end;
   tapeChrWid := CharWidth('M');
   GetItem(myMenus[mBuzzWords], mEnter, @menuStr);
   deftapeWidth := StringWidth(concat(copy(spaces, 1, 1),copy('-12345678901234567890', 1, maxDigits),copy(spaces, 1, 1),menuStr));
   sufTapeLen   := 0;
   for i := 1 to maxTapeWord do begin
      GetItem(myMenus[mBuzzWords], i, @menuStr);
      deftapeWidth := Cmax(deftapeWidth, StringWidth(concat(copy(spaces, 1, 2),menuStr,copy(spaces, 1, 2))));
      if (i >= minTapeWord) and (i <= maxTapeWord) then
         sufTapeLen   := Cmax(sufTapeLen, length(concat(copy(spaces, 1, 2),menuStr,copy(spaces, 1, 1))));
   end;
   TextFont(fieldFont);
   Textface([]);
   tapePSpacing        := CharWidth(spaces[1]);
   tapePortRect.top    := 0;
   tapePortRect.bottom := calcHeight - dVSBox + 1 + 1;
   tapePortRect.left   := calcWidth + tapePSpacing;
   tapePortRect.right  := tapePortRect.left + defTapeWidth;

   formHeight  := GetFontHeight(formFont);
   fontheight  := GetFontHeight(fieldFont);
   tapeHeight  := GetFontHeight(tapeFont);
   numLinesVis := (TapePortRect.bottom -  TapePortRect.top + 1) div tapeHeight - 1;

   SetRect(tempRect, 0, 0, 0, 0);
   entryFLD := createField(tempRect, maxSizeField, 0, right, 4, 1, 0, fieldFont, false);
   entryFSH := pointer(ord(newHandle(sizeof(fieldstate))));
   CommentHnd := pointer(ord(newHandle(sizeof(longint))));

   InitFstate(entryFLD, entryFSH);
   SetRunFormat(entryFLD, nil, fieldFont, setbold, err);


   SetPort(deskPort);            { To assure a default grafport, to be done in OpenWM }

    for ch := chr(0) to chr(255) do begin
      class := cJunk;
      if ch in ['0'..'9'] then class := cDigit
      else if ch in ['a'..'z', 'A'..'Z'] then class := cLetter
      else class := cJunk;
      if (ch >= sopMin) and (ch <= sopMax) then sopChar[ch]  := sNothing;
      chrclass[ch] := class
   end;

   chrclass[chr(chEnterVal)]   := cEnterVal;
   chrclass[chr(chClearEntry)] := cClear;
   chrclass[chr(chBackSpace)]  := cBackSpace;
   chrclass['.']               := cDecPt;

   sopchar['%'] := sPercentOp;          chrclass['%'] := cSops;
   sopchar['+'] := sADDop;              chrclass['+'] := cSops;
   sopchar['-'] := sSUBop;              chrclass['-'] := cSops;
   sopchar['*'] := sMULop;              chrclass['*'] := cSops;
   sopchar['/'] := sDIVop;              chrclass['/'] := cSops;

              {20..2F, 4D, 49}
   keyPad  := [32..47, 73, 77];
              {40..46, 48, 4C, 4E, 50..7C   7E..7F}
   mainPad := [64..70, 72, 76, 78, 80..124, 126..127];

   ClrEntry;

   dfPathname := CONCAT(COPY(pcInfo.progPathname,1,POS('-{',pcInfo.progPathname)-1), '-{t12}data segment');
   if tracing then Kill_Object(err, dfPathname);

   Sched_Class(sErrNum, false);
   Open_DataSeg(err, dfPathName, segRefNum, segPtr, segLDSN);
   Sched_Class(sErrNum, true);

   if (err <> 0) and (err <> -321) then begin
(*$IFC CALCdebug *)
      if tracing or statusMsg or debugging then writeln('Unable to open the dataseg: err = ',err:1);
(*$ENDC *)
      Sched_Class(sErrNum, false);
      Close_DataSeg(err, segRefNum);
      Kill_Object(err, dfPathname);
      Make_DataSeg(err, dfPathname, sizeof(calcInfo), sizeof(calcInfo), segRefNum, segPtr, segLDSN, ds_shared);
      Sched_Class(sErrNum, true);

      if err <> 0 then begin
(*$IFC CALCdebug *)
         if tracing or statusMsg or debugging then writeln('Unable to make the dataseg: err = ',err:1);
(*$ENDC *)
         TellFiler (err, initFailed, noDiskSpace, NIL);
         halt
      end
      else err := -321
   end;

   StartUpAlert := 0;
   useDefaults  := (err < 0);
   if useDefaults then StartUpAlert := 121;

   Sched_Class(sErrNum, false);
   SetAccess_DataSeg(err, segRefNum, false);
   Sched_Class(sErrNum, true);

  if err <> 0 then begin
(*$IFC CALCdebug *)
      if tracing or statusMsg or debugging then writeln('Unable to make the dataseg: err = ',err:1);
(*$ENDC *)
      TellFiler (err, initFailed, noDiskSpace, NIL);
      halt
   end;
   c := pointer(segPtr);
   if not useDefaults then
      if c^.header.version.stamp < curVerStamp then begin
         StartUpAlert := 122;
         useDefaults  := true
      end;

   I2X (1,FP0);
   I2X (10,FP1);
   for i := 1 to maxDigits - 2 do DivX (FP1, FP0);
   X2D (FP0, VofLesser);
   undoOp.menu      := 0;
   nullSel.startRow := -1;
   nullSel.oldStart := -1;
   nullSel.endRow   := -1;
   nullSel.oldEnd   := -1;
   inDownEvent      := false;
   genScrapPic      := false;
   genPrintPic      := false;
   procsInited      := true;

end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S OpenCode *)
procedure InitNewDoc{window : WindowPtr};
var calcItem : integer;
    dispItem : integer;
    tapeItem : integer;
    regsItem : integer;
    memItem  : integer;
    x,y      : integer;
    row, col : integer;
    keyTops  : calcStr;
    tempRect : rect;
    butRect  : rect;
    but      : butLegends;
begin
   myWindow  := theEvent.who;
   TakeWindow(myWindow);
   for but := succ(bFirst) to pred(bLast) do
      with buttons[but] do begin
         setRect(coords, 0, 0, 0, 0);
         ch      := chr(255);
         shifted := false
      end;

   buttons[bMclear].ch  := chr(chClearEntry);   buttons[bMclear].shifted := true;
   buttons[bMsub].ch    := '-';                 buttons[bMsub].shifted   := true;
   buttons[bMadd].ch    := '+';                 buttons[bMadd].shifted   := true;
   buttons[bMmul].ch    := '*';                 buttons[bMmul].shifted   := true;

   buttons[bClear].ch   := chr(chClearEntry);
   buttons[bSub].ch     := '-';
   buttons[bAdd].ch     := '+';
   buttons[bMul].ch     := '*';

   buttons[bXwithM].ch  := '7';                 buttons[bXwithM].shifted := true;
   buttons[bSeven].ch   := '7';
   buttons[bEight].ch   := '8';
   buttons[bNine].ch    := '9';
   buttons[bDiv].ch     := '/';
   buttons[bMdiv].ch    := '/';                 buttons[bMdiv].shifted   := true;

   buttons[bInv].ch     := '4';                 buttons[bInv].shifted    := true;
   buttons[bFour].ch    := '4';
   buttons[bFive].ch    := '5';
   buttons[bSix].ch     := '6';
   buttons[bPercent].ch := '%';
   buttons[bSqrt].ch    := '%';                 buttons[bSqrt].shifted   := true;

   buttons[bXwithY].ch  := '1';                 buttons[bXwithY].shifted := true;
   buttons[bOne].ch     := '1';
   buttons[bTwo].ch     := '2';
   buttons[bThree].ch   := '3';
   buttons[bEnter].ch   := chr(chEnterVal);
   buttons[bMRecall].ch := chr(chEnterVal);     buttons[bMRecall].shifted := true;

   buttons[bCHS].ch     := '0';                 buttons[bCHS].shifted     := true;
   buttons[bZero].ch    := '0';
   buttons[bDecPt].ch   := '.';

   keyTops := ' -+*789/456%123   . ';
   keyTops[1] := chr(chClearEntry);
   for row := 0 to 4 do
         for col := 0 to 3 do begin
            with tempRect do begin
               left   := sKeyWid + col * KeyWidth + PadHDisp;
               top    := PadVDisp + sUKeyHeight + row * KeyHeight;
               right  := left + keyWidth - keyHSpacing - 1;
               bottom := top + KeyHeight - keyVSpacing;
            end;

            for but := succ(bFirst) to pred(bLast) do
               with buttons[but] do
                  if ch = keyTops[row * 4 + col+1] then begin
                     coords := tempRect;
                     if shifted then
                        if row = 0 then begin
                           coords.top    := PadVDisp - keyVspacing - 2;
                           coords.bottom := coords.top + SUKeyHeight + 4
                        end
                        else if (col = 0) and (row > 0) then begin
                                coords.left  := 1;
                                coords.right := sKeyWid + PadHDisp - 1
                             end
                        else if (col = 3) and (row > 0) then begin
                                coords.left  := coords.right + 2;
                                coords.right := coords.left + sKeyWid + 1
                             end
                  end
         end;


   tempRect.top   := tempRect.top - KeyHeight;
   buttons[bEnter].coords := tempRect;
   butRect := tempRect;

   tempRect.top    := tempRect.top + 9;
   tempRect.bottom := tempRect.top + keyHeight - keyVSpacing;
   tempRect.left   := tempRect.right + 2;
   tempRect.right  := tempRect.left + sKeyWid + 1;
   buttons[bMRecall].coords := tempRect;

   tempRect       := butRect;
   tempRect.top   := tempRect.top + KeyHeight;
   tempRect.left  := tempRect.left - 3 * KeyWidth;
   tempRect.right := tempRect.right - 2 * KeyWidth;
   buttons[bZero].coords := tempRect;

   tempRect.left  := 1;
   tempRect.right := sKeyWid + PadHDisp - 1;
   buttons[bCHS].coords := tempRect;


   with c^ do begin
     PrPrfDefault(header.printer.config);
     if useDefaults then begin
         header.suspended     := false;
         header.version.stamp := curVerStamp;
         calcStyle    := Algebraic;
         showMem      := true;
         showRegs     := false;
         showTape     := false;
         subTotal     := false;
         clrKey       := false;
         Rounding     := false;
         AutoDecimal  := false;
         chsSign      := false;
         pad1         := false;
         pad2         := false;
         userDecimal  := false;
         firstchr     := false;
         roundMode    := TONEAREST;
         bSelect      := -1;
         eSelect      := -1;
         dispFormat   := mDefault;
         topTapeEntry := 0;
         tapeCnt      := -1;
         pendCalcOp   := sNothing;
         butPressed   := bLast;
         scrollPos    := 0;
         entryDisp    := 0;
         regsDisp     := 0;
         memdisp      := 0;
         lockDisp     := false;
         enterKeyHit  := false;
         operPending  := false;
         valueEnterd  := false;
         header.entryLine := '';
         processKey(cClearAll, ' ', true)
      end;

      entryDisp    := 0;
      regsDisp     := 0;
      memdisp      := 0;
      butInvert    := false;
      ClrEntry;

      if header.suspended then begin
         SetPort(myWindow);
         SetupMvThumb(hsbV);
         SetThumb(hsbV, scrollPos);
         for x := 1 to length(header.entryLine) do insertAchr(header.entryLine[x], false, false)
      end
      else begin
              header.entryLine := '';
              bSelect      := -1;
              eSelect      := -1;
              lockDisp     := false;
              processKey(cClearAll, ' ', true);
              topTapeEntry := 0;
              tapeCnt      := -1;
              butPressed   := bLast;
              scrollPos    := 0
           end;

      case calcStyle of
         Algebraic : calcItem := mAlgebraic;
         Polish    : calcItem := mPolish;
         Business  : calcItem := mBusiness
      end;
      if showTape then tapeItem := mShowTape
      else tapeItem := mHideTape;
      if showRegs then begin
         showRegs := false;
         regsItem := mShowRegs
      end
      else regsItem := 0;
      if showMem then begin
         showMem := false;
         memItem := mShowMem
      end
      else memItem := 0;
      dispItem := dispFormat;

      calcStyle   := noCalc;
      showTape    := (tapeItem = mShowTape);
      dispFormat  := 0;

      useDefaults := false;
      undoOp.menu := 0;
      doSetPort(MyWindow, false);
      ClipRect(MyWindow^.portRect);

      SetRnd (roundMode);
      MenuCommand(mFormat, dispItem);
      MenuCommand(mDebug, memItem);
      MenuCommand(mCustomize, calcItem);
      MenuCommand(mCustomize, regsItem);
      MenuCommand(mCustomize, tapeItem);

      FolderSize(myWindow, tapePortRect.right + dHSBox * ord(showTape), tapePortRect.bottom + dVSBox, false);
      ValidRect(myWindow^.portRect);
      doUpdateEvent(false, myWindow);
      if showTape and not header.suspended then MakeTapeEntry(true, gCalc, false)
   end
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure insertAChr{ch : char; userInput : boolean; doRoll : boolean};
var temp       : boolean;
    status     : integer;
    decPtPos   : integer;
    numXdigits : integer;
    x          : integer;
begin
   decPtPos := 0;
   case c^.dispFormat of
      mOneDec   : numXdigits := 2;
      mTwoDec   : numXdigits := 3;
      mThreeDec : numXdigits := 4;
      mFourDec  : numXdigits := 5;
      otherWise   numXdigits := 0
   end;

   if userInput then begin
      temp := DecPtinEntry(decPtPos);
      if ch = '.' then
         if temp and (c^.userDecimal or not c^.AutoDecimal) then exit(insertAchr)
         else decPtPos := -1;
      if entryLen = 1 then
         if entryCH(1) = '0' then
            if ch = '0' then exit(insertAchr)
            else removeAchr
   end;
   if c^.AutoDecimal and userInput and (c^.dispFormat <> mDefault) and not c^.UserDecimal then ShowDecimal(ch, true)
   else if not userInput or (entryLen + 1 <= maxDigits - numXdigits * ord(decPtPos = 0) - 1) then begin
           InsCh(ch, entryFLD, entryFSH, status);
(*$IFC CALCdebug *)
           if tracing or statusMsg then
              if status <> 0 then writeln('Error in InsCh: ',status:1);
(*$ENDC *)
           if doRoll then DrawEntry
        end
   else if userInput then begin
           setMaxNumParamAlert(decPtPos = 0);
           if decPtPos = 0 then x := 106
           else x := 102;
           StopAlert(allAlerts, x)
        end
end;


{------------------------------------------------------------------------------
   invertBut - the user has pressed a button.  Invert the display to
               press the button.
 -----------------------------------------------------------------------------}
(*$S     *)
procedure invertBut{but : butLegends};
var tempRect : rect;
begin
   doSetPort(myWindow, false);
   tempRect := buttons[but].coords;
   InvertRoundRect(tempRect, 6, 6)
end;


{------------------------------------------------------------------------------
   invertDisplay - the user has entered something unrecongiziable.  Invert
                   the display to inform the user of the mistake.
 -----------------------------------------------------------------------------}
(*$S     *)
procedure invertDisplay{unInvert : boolean; alertNum : integer};
var tempRect : rect;
    myKeys   : keySet;
    start    : longint;
    keyboard : padSet;
begin
   doSetPort(myWindow, false);
   tempRect := entryFLD^^.coords;
   insetrect(temprect, -4, -4);
   if alertNum > 0 then begin
      StopAlert(allalerts, alertNum);
      if alertNum <> 108 then doUpdateEvent(true, myWindow)
   end
   else invertrect(tempRect);
   if unInvert then begin

      {the keyboard will be keys from the main pad, numeric pad, minus the command/shift/option keys}
      keyboard    := mainPad + keypad - [127, 126, 124, 78];
      start       := time + invDelay;
      inDownEvent := false;
      repeat
         getKeys(mykeys);
      until eventavail or ((time > start) and (myKeys * keyboard = []));
      if alertNum <= 0 then invertrect(tempRect)
   end
end;


{------------------------------------------------------------------------------}
(*$S         *)
procedure LastWishes{environPtr : P_env_blk; excepDataPtr : P_ex_data};
   { The Sys_Terminate exception handler.  Gets called when the program terminates
     normally (i.e., last statement executed) or abnormally (e.g., bus error)    }
begin
   ImDying;
   if excepDataPtr^[0] <> 7 then
      if procsInited and (myWindow <> nil) and not toldToDie then c^.header.suspended := true;

(*$IFC CALCdebug *)
   if tracing or statusMsg then begin
      writeln('LastWishes: ',excepDataPtr^[0]:1);
      if not toldToDie then writeln('   Abnormal death.');
      writeln('Halting')
   end;
(*$ENDC *)

   FeTerminate;
   Halt
end;


{------------------------------------------------------------------------------}
(*$S         *)
procedure MenuCommand{menu, item: integer};
label 3,4;
   { handles all menu commands }
var temp         : boolean;
    updateTape   : boolean;
    updateWindow : boolean;
    updateCoords : boolean;
    pasteError   : boolean;
    NewDiskSize  : longint;
    NewMemSize   : longint;
    pt           : point;
    x            : integer;
    status       : integer;
    disp         : integer;
    entryLine    : calcStr;
    y            : butLegends;
    oldStyle     : calcModes;
    tempRect     : rect;
    didUndo      : boolean;
    StyleChanged : boolean;
begin
   updateWindow := false;
   updateCoords := false;
   updateTape   := false;
   didUndo      := false;
   if (menu <> mEdit) or (item <> mUndo) then undoOp.item := 0;
   if (activeFolder = myWindow) and c^.lockDisp and (menu in [mCustomize, mEdit]) then begin
      if (menu <> mEdit) or (item <> mClearAll) then begin
         InvertDisplay(true, 104);
         exit(MenuCommand)
      end
   end;

   WouldAlert(myMenus[mWouldAlert], menu);
   case menu of
      mScrap    : case item OF
                      mSCloseAll : DoFilingCmd(cmdClosAll);
                      mSClose    : DoFilingCmd(cmdClose);
                      mSMonitor  : PrBgdDlg;
                   end;
      mFilePrint : case item OF
                      mCloseAll : DoFilingCmd(cmdClosAll);
                      mClose    : DoFilingCmd(cmdClose);
                      mPutBack  : with C^ do begin
                                     SfromEntry(entryLine);
                                     header.suspended := false;
                                     header.entryLine := entryLine;

                                     Sched_Class(sErrNum, false);
                                     Size_DataSeg(status, segRefNum, sizeof(calcInfo)*2, NewMemSize,
                                                  sizeof(calcInfo)*2, NewDiskSize);
                                     Sched_Class(sErrNum, true);

                                     TellFiler(status, docClosd, docPutback, myWindow);
                                     FeTerminate;
                                     myWindow := nil
                                  end;
                      mIntend   : PrPrfDlg(c^.header.printer.config, StyleChanged, true);
                      mPrint    : PrintTapeSelection;
                      mMonitor  : PrBgdDlg;
                   end;
       mEdit     : case item of
                      mUndo     : with c^ do begin
                                     case undoOp.menu of
                                        mEdit      : if undoOp.item <> 0 then begin
                                                        case  undoOp.item of
                                                           mCut    : begin
                                                                        SfromEntry(entryLine);
                                                                        ClrEntry;
                                                                        PasteField(entryFLD, entryFSH, status, false, maxSizeField);
                                                                     end;
                                                           mPaste  : begin
                                                                        item := mCut;
                                                                        goto 4
                                                                     end;
                                                           otherwise UndoEdit(entryFLD, entryFSH, status)
                                                        end;
(*$IFC CALCdebug *)
                                                        if tracing or statusMsg then
                                                           if status <> 0 then writeln('Error in UndoEdit: ',status:1);
(*$ENDC *)
                                                        if status = 0 then begin
                                                           if undoOp.item <> mPaste then UndoInheritScrap(status);
                                                           didUndo := true;
                                                           if undoOp.item = mCut then begin
                                                              undoOp.item := mPaste;
                                                              goto 3
                                                           end;
(*$IFC CALCdebug *)
                                                           if tracing or statusMsg then
                                                              if status <> 0 then writeln('Error in UndoInHeriitScrap',status:1);
(*$ENDC *)
                                                        end
                                                     end;
                                        mCustomize,
                                        mFormat    : if undoOp.item <> 0 then begin
                                                        MenuCommand(undoOp.menu, undoOp.item);
                                                        didUndo := true
                                                     end;
                                     end;
                                     if not didUndo then InvertDisplay(true, 109);
                                     ChkeditMenu
                                  end;
                      mClearAll : processKey(cClearAll, ' ', false);
                      mClearTape: with c^ do begin
                                     RemoveSelection(not lockDisp);
                                     tapeCnt      := -1;
                                     topTapeEntry := 0;
                                     scrollPos    := 0;
                                     SetupMvThumb(hsbV);
                                     MoveThumb(scrollPos);

                                     Sched_Class(sErrNum, false);
                                     Size_DataSeg(status, segRefNum, sizeof(calcInfo)*2, NewMemSize,
                                                  sizeof(calcInfo)*2, NewDiskSize);
                                     Sched_Class(sErrNum, true);

                                     if activeFolder = myWindow then begin
                                        MakeTapeEntry(true, gCalc, false);
                                        DrawFormula([dTape])
                                     end;
                                  end;
                      mCut,
                      mCopy     : begin
                                  4: with C^ do begin
                                        undoOp.item := item;
                                        if bSelect > 0 then begin
                                           if (bSelect-1 < topTapeEntry) or (bSelect-1 > topTapeEntry + numLinesVis) then
                                              ScrollTape(pt, hsbv, IconArwA, true, false);
                                           DrawGraphics;
                                           ChgGray(mEdit, mPaste, true)
                                        end
                                        else if bSelect = 0 then begin
                                                DrawReg(0, true, item = mCut);
                                                if item = mCut then processKey(cClear, ' ', false);
                                                ChgGray(mEdit, mPaste, false);
                                             end
                                        else begin
                                                undoOp.item := 0;
                                                StopALert(allAlert, 118)
                                             end
                                     end
                                  end;
                      mPaste    : with c^ do begin
                                     SfromEntry(entryLine);
                                     ClrEntry;
                                     PasteField(entryFLD, entryFSH, status, false, maxSizeField);
(*$IFC CALCdebug *)
                                     if tracing or statusMsg then
                                        if status <> 0 then writeln('Error in PasteField: ',status:1);
(*$ENDC *)
                                     if status = 0 then begin
                                        undoOp.item  := 0;
                                     3: with c^ do begin
                                           StrToDataItem(0, true, pasteError);
                                           if pasteError then
                                              for x := 1 to length(entryLine) do
                                                 InsertAChr(entryLine[x], false, false)
                                           else begin
                                                   if bSelect <> 0 then RegToEntry(0, false, false);
                                                   MakeTapeEntry(true, gPaste, true);
                                                   DrawEntry;
                                                   x := 0;
                                                   doDispSelect(entryFld^^.coords.topLeft, x);
                                                   firstChr     := valueEntered;
                                                   valueEntered := true;
                                                   enterKeyHit  := false;
                                                end
                                        end
                                     end
                                     else begin
                                             case status of
                                                fldProtected : x := 105;
                                                fldFull      : begin
                                                                  SetMaxNumParamAlert(false);
                                                                  x := 114;
                                                               end;
                                                nullSelect   : x := 107;
                                                invScrapType : x := 108;
                                                invOpType    : x := 109
                                             end;
                                             InvertDisplay(true, x)
                                          end
                                  end;
                   end;
      mFormat    : with c^ do begin
                      if item in [mAuto, mKeyed, mRoundOn, mRoundOff] then begin
                         if (activeFolder = myWindow) and lockDisp then InvertDisplay(true, 104)
                         else case item of
                                 mAuto       : begin
                                                  if not autoDecimal then undoOp.item := mKeyed;
                                                  autoDecimal := true
                                               end;
                                 mKeyed      : begin
                                                  if autoDecimal then undoOp.item := mAuto;
                                                  autoDecimal  := false
                                               end;
                                 mRoundOn    : begin
                                                  if not Rounding then undoOp.item := mRoundOff;
                                                  Rounding  := true;
                                                  roundMode := TONEAREST
                                               end;
                                 mRoundOff   : begin
                                                  if Rounding then undoOp.item := mRoundOn;
                                                  Rounding := false
                                               end
                              end;
                      end
                      else begin
                              undoOp.item := dispFormat;
                              dispFormat  := item;
                              temp := (dispFormat = mDefault);
                              for x := mDefault to mFourDec do ChkItem(mFormat, x, (x = dispFormat));
                              ChgGray(mFormat, mRoundOn, temp);
                              ChgGray(mFormat, mRoundOff, temp);
                              ChgGray(mFormat, mKeyed, temp);
                              ChgGray(mFormat, mAuto, temp);
                              if activeFolder = myWindow then begin
                                 if entryLen = 0 then begin
                                    C^.lockDisp := false;
                                    DrawReg(0, false, false)
                                 end;
                                 DrawFormula([dMem, dRegs])
                              end
                           end;
                      temp := (dispFormat <> mDefault);
                      if rounding and (dispFormat <> mDefault) then SetRnd (roundMode)
                      else SetRnd (TONEAREST);
                      ChkItem(mFormat, mRoundOn, temp and Rounding and (roundMode = TONEAREST));
                      ChkItem(mFormat, mRoundOff, temp and not Rounding);
                      ChkItem(mFormat, mAuto, temp and autoDecimal);
                      ChkItem(mFormat, mKeyed, temp and not autoDecimal)
                   end;
      mCustomize : with c^ do begin
                      oldStyle := calcStyle;
                      case item of
                         mPolish     : calcStyle := Polish;
                         mBusiness   : calcStyle := Business;
                         mAlgebraic  : calcStyle := Algebraic;
                         mShowTape   : if not showTape then begin
                                          updateWindow := true;
                                          updateTape   := true;
                                          showTape     := true;
                                          if activeFolder = myWindow then MakeTapeEntry(true, gCalc, false);
                                       end;
                         mHideTape   : if showTape then begin
                                          MenuCommand(mEdit, mClearTape);
                                          updateWindow := true;
                                          updateTape   := true;
                                          showTape     := false;
                                       end;
                         mAdvTape    : MakeTapeEntry(true, gNone, false);
                         mShowRegs   : if not showRegs then begin
                                          upDateWindow := true;
                                          upDateCoords := true;
                                          showRegs     := true;
                                          undoOp.item  := mHideRegs;
                                          disp := regDispLines(calcStyle) * FormHeight + 6;
                                          regsDisp := disp
                                       end;
                         mHideRegs   : if showRegs then begin
                                          upDateWindow := true;
                                          upDateCoords := true;
                                          undoOp.item  := mShowRegs;
                                          showRegs     := false;
                                          disp     := -(regDispLines(calcStyle) * FormHeight + 6);
                                          regsDisp := 0
                                       end;
                      end;
                      if (oldStyle <> calcStyle) and (item in [mPolish, mBusiness, mAlgebraic]) then begin
                         case oldStyle of
                            Algebraic : undoOp.item := mAlgebraic;
                            Polish    : undoOp.item := mPolish;
                            Business  : undoOp.item := mBusiness
                         end;
                         if activeFolder = myWindow then begin
                            processKey(cClearAll, ' ', true);
                            MakeTapeEntry(true, gCalc, false);
                         end;
                         if regsDisp <> 0 then begin
                            upDateCoords := true;
                            disp := (regDispLines(calcStyle) - regDispLines(oldStyle)) * FormHeight;
                            regsDisp := regsDisp + disp
                         end;
                         updateWindow := true;
                         for x := mPolish to mBusiness do
                            ChkItem(mCustomize, x, (x-mPolish = ord(calcStyle)));
                      end;
                      temp := (calcStyle = Business);
                      ChgGray(mEdit, mClearTape, not ShowTape);
                      ChgGray(mCustomize, mAdvTape, not ShowTape);
                      ChkItem(mCustomize, mShowTape, showTape);
                      ChkItem(mCustomize, mHideTape, not showTape);
                      ChkItem(mCustomize, mShowRegs, showRegs);
                      ChkItem(mCustomize, mHideRegs, not showRegs);
                   end;
       mDebug    : begin
                      case item of
(*$IFC CALCdebug *)
                         mPxHz        : PxHz(theHeap);
                         mDebugging   : debugging := not debugging;
                         mTraceEvents : begin
                                           eventDebug := not eventDebug;
                                           temp := eventDebug
                                        end;
                         mStatus      : begin
                                           statusMsgs := not statusMsgs;
                                           temp := statusMsgs
                                        end;
                         mTraceProg   : begin
                                           tracing := not tracing;
                                           temp := tracing
                                        end;
                         mdebugflag  : begin
                                           debugflag := not debugflag;
                                           temp := debugflag
                                        end;
                         mClearTrace  : begin
                                           debugging  := false;
                                           statusMsgs := true;
                                           eventDebug := false;
                                           tracing    := false;
                                           debugflag  := false;
                                           temp       := false;
                                        end;
                         mBound       : for y := succ(bFirst) to pred(bLast) do
                                           InvertRect(buttons[y].coords);
                         mShowEntry   : if showdata then begin
                                           showdata := false;
                                           disp := -((debugReg+5) * formHeight);
                                           c^.entryDisp := 0;
                                           upDateCoords := true;
                                           updateWindow := true
                                        end;
                         mShowData    : if not showdata then begin
                                           showdata := true;
                                           disp := (debugReg+5) * formHeight;
                                           c^.entryDisp := disp;
                                           upDateCoords := true;
                                           updateWindow := true
                                        end;
(*$ENDC *)
                         mShowMem     : if not c^.showMem then begin
                                           upDateWindow := true;
                                           upDateCoords := true;
                                           c^.showMem    := true;
                                           disp := formHeight + 6;
                                           c^.memDisp := disp
                                        end;
                         mHideMem     : if c^.showMem then begin
                                           upDateWindow := true;
                                           upDateCoords := true;
                                           c^.showMem    := false;
                                           disp := -(formHeight + 6);
                                           c^.memDisp := 0
                                        end;
                      end;
(*$IFC CALCdebug *)
                      ChkItem(mDebug, mShowMem, c^.showMem);
                      ChkItem(mDebug, mHideMem, not c^.showMem);
                      ChkItem(mDebug, mShowEntry, not showData);
                      ChkItem(mDebug, mShowData, showdata);
                      ChkItem(mDebug, mDebugging, debugging);
                      ChkItem(mDebug, mTraceProg, tracing);
                      ChkItem(mDebug, mStatus, statusMsgs);
                      ChkItem(mDebug, mdebugflag, debugflag);
                      ChkItem(mDebug, mTraceEvents, eventDebug);
(*$ENDC *)
                   end
   end;
   if upDateWindow then begin
      if updateCoords then begin
         for y := succ(bFirst) to pred(bLast) do
            with buttons[y].coords do begin
               top    := top + disp;
               bottom := bottom + disp
            end;
      end;
      with c^ do begin
         if updateCoords or updateTape then begin
            if showTape then tapePortRect.right := tapePortRect.left + defTapeWidth + 1
            else tapePortRect.right :=  tapePortRect.left - tapePSpacing;
            tapePortRect.bottom := calcHeight + memDisp + entryDisp + regsDisp - dVSBox + 1 + 1;
            numLinesVis := (TapePortRect.bottom -  TapePortRect.top + 1) div tapeHeight - 1
         end;
         if activeFolder = myWindow then begin
            FolderSize(myWindow, tapePortRect.right+dHSBox*ord(showTape), tapePortRect.bottom + dVSBox, false);
            ScrollTape(pt, hsbv, IconThumb, true, false);
            invalRect(myWindow^.portRect)
         end
      end
   end;
   if not didUndo then undoOp.menu := menu;
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure MouseInWindow{pt : point; window : WindowPtr; pt : Point; upEvent : boolean};
var x           : butLegends;
    rh, rv      : rect;
    newBotRight : Point;
    myHsbHit    : THsb;
    myIconHit   : TIcon;
    alertNum    : integer;
begin
   doSetPort(window, false);
   alertNum := 0;
   if window = myWindow then begin
      if c^.showTape and FSBHit(sbList, pt, myHsbHit, myIconHit) then begin
         if not upEvent then
            if TyvhOfSb(myHsbHit) = V then ScrollTape(pt, myHsbHit, myIconHit, false, false)
            else alertNum := 110;
         c^.butPressed := bLast
      end
      else if upEvent then begin
              if c^.butPressed <> bLast then
                 with buttons[c^.butPressed] do begin
                    ProcessKey(chrClass[ch], ch, shifted);
                    PressKey(ch, shifted)
                 end
           end
           else begin
                  for x := succ(bFirst) to pred(bLast) do
                     with buttons[x] do
                        if PtinRect(pt, coords) then begin
                           PressKey(ch, shifted);
                           exit(MouseInWindow)
                        end;
                  c^.butPressed := bLast;
                  if fGrowHit(pt) then alertNum := 111
                  else if PtinRect(pt, tapePortRect) and c^.showTape then DoTapeSelection(pt, alertNum)
                  else DoDispSelect(pt, alertNum)
               end
   end
   else if not upEvent then begin
              { Test for button down in "Grow" icon }
           if fGrowHit(pt) then begin
              SetPort(ScrapFolder);
              FlushRects(rh, rv);                               {invalidate old scroll bars area}
              InvalRect(rh);
              InvalRect(rv);
              GetGrowRect(rV);
              InvalRect(rV);

              DragFrame(pt, true, newBotRight);                 { let user determine new size }
              SubPt(window^.portRect.topLeft, newBotRight);     { compute new size }

                 { resize folder }
              FolderSize(window, newBotRight.h, newBotRight.v, true);

              SetPort(ScrapFolder);                             {invalidate new scroll bar area and}
              FlushRects(rh, rv);                               {let the update event do the drawing}
              InvalRect(rh);
              InvalRect(rv);
              GetGrowRect(rV);
              InvalRect(rV)
           end
           else StopALert(allAlert, 101)
        end;
   if alertNum <> 0 then InvertDisplay(true, alertNum)
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure NormalTapeEntry;
begin
   MakeTapeEntry(true, gNormal, false)
end;


{-------------------------------------------------------------------------}
(*$S         *)
function OutOfHeapSpace{hz : THz; bytesNeeded : integer) : integer};
begin
(*$IFC CALCdebug *)
   if tracing or statusMsg then writeln('OutOfHeapSpace:  needed: ',bytesNeeded:1);
(*$ENDC *)
   OutOfHeapSpace := 0
end;


{-------------------------------------------------------------------------}
{-------------------------------------------------------------------------}
(*$S         *)
procedure PressKey{ch : char; shifted : boolean};
var x : butLegends;
begin

(*$IFC CalcDebug *)
   if tracing then writeln('PressKey: ord(',ord(ch):1,') ',shifted,'  :',ch);
(*$ENDC *)

   for x := succ(bFirst) to pred(bLast) do
      if (shifted = buttons[x].shifted) and (ch  = buttons[x].ch) then begin
         c^.butPressed := x;
         InvertBut(x);
         butInvert := not butInvert
      end
end;


{-------------------------------------------------------------------------}
(*$S         *)
procedure processKey{class : letterclass; ch : char; shifted : boolean};
var x             : integer;
    temp0         : dataItem;
    temp1         : dataItem;
    temp          : dataItem;
    mulDivResult  : boolean;
    addSubResult  : boolean;
    percentResult : boolean;
    e             : boolean;
    entryLine     : calcStr;

    procedure PushRegs;
    var x : integer;
    begin
       with c^ do begin
          if valueEnterd then
             if operPending and (calcStyle = Polish) then
                for x := maxRegisters downto 1 do regs[x] := regs[x-1];
          StrToDataItem(0, false, e)
       end
    end;

begin
   if c^.lockDisp and (shifted or not(class in [cClearAll, cClear])) then class := cLock
   else begin
           RemoveSelection(C^.lockDisp);
           WouldAlert(myMenus[mWouldAlert], mWType)
        end;
   undoOp.menu := 0;
   if (class <> cDigit) or (ord(ch) <> chCHS) or not shifted then c^.chsSign := false;
   case class of
      cClear,
      cClearAll  : with c^ do begin
                      if shifted and (class = cClear) then begin
                         ClrMem(0);
                         NormalTapeEntry;
                         DrawFormula([dMem]);
                      end
                      else begin
                              if ((calcStyle = Algebraic) and ((entryLen = 0) or not operPending)) or
                                 (class = cClearAll) or clrKey then begin
                                 for x := 0 to maxRegisters do ClrReg(x);
                                 operPending := false;
                                 firstChr    := false;
                                 pendCalcOp  := sNothing;
                                 subTotal    := false;
                                 clrKey      := false;
                              end
                              else begin
                                      ClrReg(0);
                                      clrKey := true
                                   end;
                              lockDisp    := false;
                              enterKeyHit := false;
                              valueEnterd := false;
                              userDecimal := false;
                              secondOp    := sNothing;
                              if calcStyle = polish then operPending := false;
                              ClrEntry;
                              if shifted then for x := 0 to maxMemCells do ClrMem(x)
                              else begin
                                      if clrKey then MakeTapeEntry(true, gClrEntry, false)
                                      else MakeTapeEntry(true, gClrAll, false);
                                      DrawReg(0, false, false);
                                      DrawFormula([dMem, dRegs])
                                   end;
                           end
                        end;
      cDecpt,
      cDigit     : with c^ do
                      if shifted and (ch in ['7', '4', '1', '0']) then begin
                         SfromEntry(entryLine);
                         if (ord(ch) <> chCHS) or not valueEntered then PushRegs;
                         case ord(ch) of
                            chXfromY : if calcStyle = Business then begin
                                          SubTotal := true;
                                          regs[2]  := regs[0];
                                          if valueEntered then begin
                                             MakeTapeEntry(true, gItem, false);
                                             for x := 1 to length(entryLine) do
                                                InsertAChr(entryLine[x], false, false)
                                          end
                                          else MakeTapeEntry(true, gSubTot, false);
                                          DrawFormula([dRegs]);
                                          exit(ProcessKey)
                                       end
                                       else begin
                                               temp0   := regs[0];
                                               regs[0] := regs[1];
                                               regs[1] := temp0;
                                               NormalTapeEntry;
                                               MakeTapeEntry(true, gReg0, true);
                                               MakeTapeEntry(true, gReg1, true);
                                               DrawReg(0, false, false);
                                            end;
                            chXfromM : begin
                                          temp0     := regs[0];
                                          regs[0]   := memory[0];
                                          memory[0] := temp0;
                                          NormalTapeEntry;
                                          MakeTapeEntry(true, gReg0, true);
                                          MakeTapeEntry(true, gMem, true);
                                          DrawReg(0, false, false);
                                          Drawformula([dMem])
                                       end;
                            chINV    : begin
                                          NormalTapeEntry;
                                          doOperation(sINVop, true, true);
                                          MakeTapeEntry(true, gSDiamond, false);
                                          if calcStyle = Polish then operPending := true;
                                       end;
                            chCHS    : begin

                                          temp0 := regs[0];
                                          StrToDataItem(0, false, e);
                                          doOperation(sCHSop, not valueEnterd, true);
                                          if valueEnterd then begin
                                             x          := dispformat;
                                             dispFormat := mDefault;
                                             RegToEntry(0, false, false);
                                             regs[0]   := temp0;
                                             dispFormt := x
                                          end
                                          else begin
                                                  chsSign  := not chsSign;
                                                  secondOp := sCHSop;
                                                  MakeTapeEntry(false, gNormal, false);
                                                  DrawFormula([dRegs]);
                                               end;
                                          exit(ProcessKey)
                                       end
                         end;
                         enterKeyHit := false;
                         firstChr    := false;
                         valueEnterd := (calcStyle <> Polish);
                         DrawFormula([dRegs])
                      end
                      else begin
                              if (calcStyle = Polish) and operPending and not(valueEnterd or clrKey) then begin
                                 firstChr := true;
                                 DrawFormula([dRegs])
                              end;
                              enterkeyHit := false;
                              clrKey      := false;
                              valueEnterd := true;
                              if entryLen = 0 then userDecimal := false;
                              insertAchr(ch, true, true)
                           end;
      cBackSpace : removeAchr;
      cLock      : invertDisplay(true, 104);
      cLetter,
      cJunk      : invertDisplay(true, 103);

      cEnterVal  : with c^ do begin
                      if not shifted then begin
                         PushRegs;
                         case calcStyle of
                            Algebraic : begin
                                           if operPending and not enterKeyHit then begin
                                              if pendCalcOp = sMULop then begin
                                                 regs[3] := regs[0];
                                                 regs[2] := regs[1]
                                              end
                                              else begin
                                                      regs[2] := regs[0];
                                                      regs[3] := regs[1]
                                                   end;
                                              if pendCalcOp <> sNothing then NormalTapeEntry;
                                           end
                                           else begin
                                                   regs[1] := regs[2];
                                                   regs[3] := regs[0];
                                                   if pendCalcOp <> sNothing then begin
                                                      if pendCalcOp = sMulOp then begin
                                                         regs[0] := regs[2];
                                                         regs[1] := regs[3]
                                                      end;
                                                      MakeTapeEntry(valueEntered or (pendCalcOp = sMulOp), gOp, false);
                                                      MakeTapeEntry(true, gEqual1, false);
                                                      if pendCalcOp = sMulOp then begin
                                                         regs[0] := regs[3];
                                                         regs[1] := regs[2]
                                                      end
                                                   end
                                                end;
                                           doOperation(pendCalcOp, true, operPending and not enterKeyHit);
                                           if pendCalcOp <> sNothing then MakeTapeEntry(true, gReg0, false)
                                           else MakeTapeEntry(true, gSDiamond, false);
                                           secondOp := sNothing;
                                        end;
                            Polish    : begin
                                           NormalTapeEntry;
                                           for x := maxRegisters downto 1 do regs[x] := regs[x-1];
                                        end;
                            Business  : begin
                                           regs[0] := regs[1];
                                           DrawReg(0, false, false);
                                           NormalTapeEntry;
                                           SubTotal := false;
                                           for x := 1 to maxRegisters do ClrReg(x);
                                        end;
                         end;
                         operPending  := false;
                         valueEnterd  := false;
                         firstChr     := false;
                         enterkeyHit  := true;
                         DrawFormula([dRegs])
                      end
                      else begin
                              PushRegs;
                              if calcStyle = Polish then
                                 for x := maxRegisters downto 1 do regs[x] := regs[x-1];
                              regs[0] := memory[0];
                              NormalTapeEntry;
                              MakeTapeEntry(true, gSDiamond, false);
                              DrawReg(0, false, false);
                              enterKeyHit := false;
                              firstChr    := false;
                              valueEnterd := (calcStyle <> Polish);
                              DrawFormula([dRegs]);
                           end
                   end;

      cSops      : if not shifted then begin
                       mulDivResult  := false;
                       addSubResult  := false;
                       percentResult := false;
                       case c^.calcStyle of
                          Business,
                          Algebraic : with c^ do begin
                                         if calcStyle = Business then begin
                                            case sopChar[ch] of
                                               sMULop,
                                               sDIVop : if operPending then
                                                           case pendCalcOp of
                                                              sADDop,
                                                              sSUBop : addSubResult := true;
                                                              sMULop,
                                                              sDIVop : begin
                                                                          regs[1] := regs[0];
                                                                          regs[0] := regs[3];
                                                                          valueEntered := true
                                                                       end
                                                           end;
                                               sADDop,
                                               sSUBop : if not operPending then begin
                                                           pendCalcOp    := sopChar[ch];
                                                           operPending   := true;
                                                           valueEntered  := true;
                                                           percentResult := (secondOp = sPERCENTop);
                                                           if secondOp = sNothing then ClrReg(1)
                                                        end
                                                        else case pendCalcOp of
                                                                sMULop,
                                                                sDIVop : begin
                                                                            regs[1] := regs[0];
                                                                            regs[0] := regs[3];
                                                                            valueEntered := true;
                                                                            mulDivResult := true
                                                                         end;
                                                                sSUBop,
                                                                sADDop : begin
                                                                            if (pendCalcOp = sopChar[ch]) and not valueEntered then begin
                                                                               regs[1] := regs[0];
                                                                               regs[0] := regs[3]
                                                                            end;
                                                                            valueEntered := true;
                                                                            pendCalcOp := sopChar[ch]
                                                                         end
                                                             end
                                            end
                                         end;

                                         if valueEntered then begin
                                            StrToDataItem(0, false, e);
                                            if mulDivResult then MakeTapeEntry(true, gEqual0, false)
                                            else NormalTapeEntry;
                                            regs[3] := regs[0];
                                            if operPending then
                                               if sopChar[ch] = sPERCENTop then begin
                                                  secondOp := sPERCENTop;
                                                  doOperation(sPERCENTop, true, true);
                                                  MakeTapeEntry(true, gSDiamond, false);
                                                  if calcStyle = Algebraic then begin
                                                     if pendCalcOp = sDIVop then regs[2] := regs[3]
                                                     else regs[2] := regs[1]
                                                  end
                                               end
                                               else doOperation(pendCalcOp, true, true);
                                            if mulDivResult then MakeTapeEntry(true, gSDiamond, false)
                                            else if percentResult then MakeTapeEntry(true, gDiamond, false);
                                         end
                                         else begin
                                                 if addSubResult then MakeTapeEntry(true, gSDiamond, false);
                                                 MakeTapeEntry(addSubResult or (secondOp <> sNothing), gNormal, false)
                                              end;

                                         if sopChar[ch] <> sPERCENTop then begin

                                            if mulDivResult then begin
                                               pendCalcOp  := sNothing;
                                               operPending := false
                                            end
                                            else begin
                                                    pendCalcOp := sopChar[ch];
                                                    operPending := true
                                                 end;
                                            secondOp    := sNothing;
                                            regs[1]     := regs[0];
                                         end
                                         else operpending := false;
                                         enterKeyHit := false;
                                         valueEnterd := false;
                                      end;
                          Polish    : with c^ do begin
                                         PushRegs;
                                         pendCalcOp := sopChar[ch];

                                         NormalTapeEntry;
                                         doOperation(pendCalcOp, true, true);
                                         if pendCalcOp <> sPERCENTop then
                                            for x := 1 to maxRegisters - 1 do regs[x] := regs[x+1];
                                         MakeTapeEntry(true, gDiamond, false);
                                         operPending := true;
                                         firstChr    := false;
                                         valueEnterd := false;
                                         enterKeyHit := false;
                                      end;
                       end;
                       DrawFormula([dRegs]);
                    end
                    else if sopChar[ch] = sPercentOp then begin
                            with c^ do begin
                               PushRegs;
                               if calcStyle = Polish then begin
                                  operPending := true;
                                  pendCalcOp  := sSQRTop
                               end;
                               firstChr    := false;
                               enterKeyHit := false;
                               valueEnterd := (calcStyle <> Polish);
                               NormalTapeEntry;
                               doOperation(sSQRTop, true, true);
                               MakeTapeEntry(true, gSDiamond, false);
                               DrawFormula([dRegs])
                            end
                         end
                    else with c^ do begin
                            PushRegs;
                            temp0     := regs[0];
                            temp1     := regs[1];
                            regs[1] := memory[0];
                            NormalTapeEntry;
                            doOperation(sopChar[ch], false, true);
                            MakeTapeEntry(true, gSDiamond, false);
                            memory[0] := regs[0];
                            regs[0]   := temp0;
                            regs[1]   := temp1;
                            valueEnterd  := (calcStyle <> Polish);
                            EnterKeyHit  := false;
                            firstChr     := false;
                            clrKey       := false;
                            if calcStyle <> Polish then DrawFormula([dMem])
                            else begin
                                    OperPending := true;
                                    DrawFormula([dMem, dRegs])
                                 end
                         end
   end
end;



{-------------------------------------------------------------------------}
(*$S         *)
procedure ProcessTheEvent;
label 2;
var x           : integer;
    theMenu     : integer;
    theItem     : integer;
    myKeys      : keySet;
    myPort      : GrafPtr;
    filerParams : FilerExt;
    filerError  : integer;
    errNum      : integer;
    ch          : char;
    titleTab    : str255;
    closeStr    : str255;
    entryLine   : calcStr;
    NewMemSize  : longint;
    NewDiskSize : longint;
    start       : longint;
    startRow    : integer;
    endRow      : integer;
begin
   if tracing then begin
      write('ProcessTheEvent:  ');
      case theEvent.what of
         abortEvent       : writeln('abortEvent');
         diedEvent        : writeln('diedEvent');
         nilEvent         : writeln('nilEvent');
         folderUpdate     : writeln('folderUpdate');
         folderDeactivate : writeln('folder Deactivate');
         folderActivate   : writeln('folder Activate');
         FolderMoved      : writeln('folder Moved');
         keyDown          : begin
                               writeln;
                               writeln('  key event: cap: ',ord(theEvent.keycap):1,
                                       '  ascii: ',ord(theEvent.ascii):1,
                                       '  shifted: ',theEvent.shiftKey);
                               writeln('  option: ',theEvent.applekey,
                                       '  on keypad: ',theEvent.keycap in keypad,
                                       '  in Down: ',inDownEvent)
                            end;
         ButtonDown       : writeln('ButtonDown');
         ButtonUp         : writeln('ButtonUp');
         filerEvent       : writeln('filerEvent');
         otherwise          writeln('unknown')
      end
   end;

   if debugging then
      writeln('Calculator: wmHeap ok: ',FCheckHzOK(wmHeap, errnum),'  # blocks: ',errnum:1);


   case theEvent.what of
      buttonDown       : begin
                            inDownEvent := true;
                            if theEvent.who = menuFolder then begin
                               GetFldrTitle(myWindow, titleTab);
                               GetItem(myMenus[mBuzz2Words], mCloseMsg, @CloseStr);
                               CloseStr := concat(CloseStr, ' "',titleTab,'"');
                               SetItem(myMenus[mFilePrint], mClose, @CloseStr);

                               GetFldrTitle(scrapFolder, titleTab);
                               GetItem(myMenus[mBuzz2Words], mCloseMsg, @CloseStr);
                               CloseStr := concat(CloseStr, ' "',titleTab,'"');
                               SetItem(myMenus[mScrap], mSclose, @CloseStr);

                               MenuSelect(theEvent.where, theMenu, theItem);   { find which one }
                               if (theMenu <> 0) and (theItem <> 0) then
                                  MenuCommand(theMenu, theItem);               { do the job }
                               HiliteMenu(0);  { Turn off menu hiliting }
                            end
                            else MouseInWindow(theEvent.who, theEvent.where, false);
                         end;

      buttonUp         : begin
                            inDownEvent := false;
                            MouseInWindow(theEvent.who, theEvent.where, true)
                         end;

      filerEvent       : begin
                            GetAddParams(filerError, theEvent, filerParams);
                            if tracing then
                               writeln('Process ',My_Id:1,': fcOp = ', ord(filerParams.theFlrOp):1);
                            case filerParams.theFlrOp of

(*$IFC CALCdebug *)
                               fcResume,
(*$ENDC *)
                               fcNone      : begin
                                                InitNewDoc(theEvent.who);
                                                if activeFolder = myWindow then goto 2
                                             end;
(*$IFC not CALCdebug *)
                               fcResume    : TellFiler(filerError, docClosd, internalError, theEvent.who);
(*$ENDC *)

                               fcClose,
                               fcSuspend,
                               fcShred     : with C^ do begin
                                                myWindow := nil;
                                                SfromEntry(entryLine);
                                                header.suspended := (filerParams.theFlrOp = fcSuspend);
                                                header.entryLine := entryLine;

                                                Sched_Class(sErrNum, false);
                                                if not header.suspended then
                                                   Size_DataSeg(errNum, segRefNum,
                                                                sizeof(calcInfo)*2, NewMemSize,
                                                                sizeof(calcInfo)*2, NewDiskSize);
                                                Sched_Class(sErrNum, true);

                                                TellFiler(filerError, docClosd, allOK, theEvent.who)
                                             end;

                               fcCopy,
                               fcPut       : TellFiler(filerError, docNotXfered, internalerror, theEvent.who);

                               fcDfClose   : TellFiler(filerError, dfClosed, allOK, theEvent.who);

                               fcTerminate : begin
                                                toldToDie := true;

                                                Sched_Class(sErrNum, false);
                                                Close_dataseg(errNum, segRefNum);
                                                Sched_Class(sErrNum, true)

                                             end;
                            end
                         end;

      keyDown          : if (theEvent.who = myWindow) and not(theEvent.repeatKey or inDownEvent) then begin
                            undoOp.menu := 0;
                            if theEvent.appleKey then CommandKey
                            else begin
                                    ch := theEvent.ascii;

                                    {change the characters returned by the numeric key pad}
                                    case ord(ch) of
                                       chDiv : ch := '/';     {up arrow is always divide symbol}
                                       chAdd : ch := '+';     {left arrow is always add symbol}
                                       chMul : ch := '*';     {right arrow is always multiply symbol}
                                       chSub : ch := '-';     {tab arrow is always subtract symbol}
                                    end;

                                    {down arrow is always the percent key}
                                    if theEvent.keyCap = 43 then ch := '%';
                                    if theEvent.applekey then ch := ' ';

                                    obscureCursor;
                                    start := time + invDelay div 2;

                                    PressKey(ch, theEvent.shiftKey and (theEvent.keycap in keyPad));

                                    processKey(chrClass[ch], ch,
                                               theEvent.shiftKey and (theEvent.keycap in keyPad));
                                    repeat
                                       GetKeys(myKeys);
                                    until (time > start) and not (theEvent.keycap in myKeys);
                                    PressKey(ch, theEvent.shiftKey and (theEvent.keycap in keyPad));
                                 end
                         end
                         else if theEvent.who = ScrapFolder then StopAlert(allalerts, 101);


      folderActivate   : begin
                            TakeControl(theEvent, false, false);   { standard "activate" protocol }
2:                          with c^ do begin
                               PutUpMenus;
                               DrawScrollBars(theEvent.who);
                               if theEvent.who = myWindow then begin
                                  if StartUpAlert <> 0 then begin
                                     case calcStyle of
                                        Algebraic : theItem := mTAlgebraic;
                                        Polish    : theItem := MTPolish;
                                        Business  : theItem := mTBusiness
                                     end;
                                     GetItem(myMenus[mBuzz2Words], theItem - maxTapeWords, @titleTab);
                                     ParamAlert(titleTab, '', '');
                                     NoteAlert(allAlerts, StartUpAlert)
                                  end;
                                  ShowSelection(false, true);
                                  inDownEvent  := false;
                                  StartUpAlert := 0
                               end;
                               undoOp.menu   := 0;
                               butInvert     := false;
                               ChkEditMenu
                            end
                         end;


      folderDeactivate : begin

                            if myWindow = theEvent.who then ShowSelection(true, true);
                            if theEvent.fromProcess <> My_ID then begin
                               if myWindow <> nil then begin
                                  WMOpenPicture(myWindow);
                                  DrawContents(myWindow, true, true);
                                  RemoveScrollBars(myWindow);
                                  SetPort(myWindow);
                                  WMClosePicture
                               end;

                               if ScrapProcess = my_ID then begin
                                  WMOpenPicture(ScrapFolder);
                                  DrawContents(ScrapFolder, true, false);
                                  RemoveScrollBars(ScrapFolder);
                                  SetPort(ScrapFolder);
                                  WMClosePicture
                               end;
                               FeTerminate
                            end;

                            RemoveScrollBars(theEvent.who);
                            { Should move scrap record, if valid, to the scrap. }
                            GiveControl(theEvent);              { standard "deactivate" protocol }
                         end;


      folderUpdate     : doUpdateEvent(true, theEvent.who)
   end;  { case theEvent }
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure PutUpMenus;
var x : integer;
begin
   { install my menus }
   ClearMenuBar;
   if theEvent.who = myWindow then begin
       for x := mFilePrint to mCustomize do InsertMenu(myMenus[x], 0);
       if showDebug then InsertMenu(myMenus[mDebug], 0)
   end
   else InsertMenu(myMenus[mScrap], 0);
   DrawMenuBar;
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
function RegdispLines{style : calcModes) : integer };
begin
   case Style of
      Algebraic : RegdispLines := 2;
      Polish    : RegdispLines := 3;
      Business  : RegdispLines := 1
   end;
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure RegToEntry{regNum : regRange; doRounding : boolean; doRoll : boolean};
var error     : boolean;
    next      : integer;
    x         : integer;
    entryLine : FPstring;
    tempEntry : calcStr;
    dispErr   : boolean;
    doShow    : boolean;
    myDecimal : Decimal;
begin
   with C^ do begin
      DISPfromFP(regs[regNum], tempEntry, dispErr);
      doShow := false;
      if doRounding and dispErr and not lockdisp then begin
         RemoveSelection(true);
         lockDisp := true;
         bSelect  := 0;
         eSelect  := 0;
         doShow   := true
      end;
      entryLine := tempEntry;

      {if in rounding mode, convert display back to a number}
      if Rounding and doRounding and (dispFormat <> mDefault) and not lockDisp then begin
         next := 1;
         Str2Dec(entryLine, next, myDecimal, dispErr);
         Dec2D(myDecimal, regs[regnum]);
      end;

      {create text image of register in the entry field}
      for x := 1 to length(entryLine) do InsertAChr(entryLine[x], false, doRoll);
      if not doRoll then DrawEntry;
      if doShow then ShowSelection(false, false)
   end
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure removeAchr;
var status : integer;
begin
   if entryLen > 0 then
      with C^ do begin
         if AutoDecimal and (dispFormat <> mDefault) and not userDecimal then ShowDecimal(' ', false)
        else begin
                BackSpace(entryFLD, entryFSH, status);
                DrawEntry
             end
      end
end;


{------------------------------------------------------------------------------
   RemoveScrollBars - called when an document is deactivated.  Takes down the
                      scroll bars
 -----------------------------------------------------------------------------}
procedure RemoveScrollBars{window : WindowPtr};
var rH : Rect;
begin
   if (window = myWindow) and not c^.showTape then exit(RemoveScrollBars);
   doSetPort(window, false);
   if window = myWindow then begin
      rH := tapePortRect;
      rH.right  := rH.right + dHSBox;
      rH.bottom := rH.bottom + dVSBox;
      HideSBorder(rH)
   end
   else HideSBorder(window^.portrect);
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
procedure RemoveSelection{redraw : boolean};
var sInfo : selectInfo;
begin
   ChgGray(mEdit, mCopy, true);
   ChgGray(mEdit, mCut, true);
   ChgGray(mFilePrint, mPrint, true);
   sInfo.startRow := -1;
   sInfo.endRow   := -1;
   sInfo.oldStart := C^.bSelect - 1;
   sInfo.oldEnd   := C^.eSelect - 1;
   C^.bSelect := -1;
   C^.eSelect := -1;
   case sInfo.oldStart + 1 of
      -1      : ;
      0       : if redraw then begin
                   doSetPort(myWindow, false);
                   DrawReg(0, false, false)
                end;
      otherwise begin
                   DrawTape(C^.topTapeEntry, sInfo, false, false, false, true, false);
                end;
   end
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
procedure ScrollTape{pt : point; myhsbHit : THsb; myIconHit : TIcon; forced, auto : boolean};
var newThumb       : TC;
    numTapeEntries : integer;
    newEntry       : integer;
begin
   numTapeEntries := Cmax(0, c^.tapeCnt - numLinesVis div 4);
   doSetPort(myWindow, false);
   if not forced then WouldAlert(myMenus[mWouldAlert], mWTape);

   case myIconHit of
      IconThumb : with c^ do begin
                     if forced then begin
                        newThumb := 1000;
                        SetupMvThumb(myHsbHit);
                        MoveThumb(newThumb);
                        if tapeCnt > numLinesVis then newEntry := tapeCnt - numLinesVis
                        else newEntry := 0
                     end
                     else begin
                             DragThumb(myHsbHit, pt, NewThumb);
                             SetThumb(myHsbHit, NewThumb);
                             newEntry := ord4(newThumb) * numTapeEntries div 1000
                          end;
                     scrollPos := newThumb;
                     if forced or (newEntry <> topTapeEntry) then
                        DrawTape(newEntry, nullSel, forced, false, false, false, false);
                  end;
      IconArwA,
      IconArwB,
      IconPagA,
      IconPagB  : with c^ do begin
                     if not forced then PaintArw(myHsbHit, myIconHit, true);
                     SetupMvThumb(myHsbHit);
                     repeat
                        if forced then newEntry := bSelect
                        else case myIconHit of
                                IconPagA : newEntry := Cmax(0, topTapeEntry - numLinesVis);
                                IconPagB : newEntry := Cmin(numTapeEntries, topTapeEntry + numLinesVis);
                                IconArwA : newEntry := Cmax(0, topTapeEntry - 1);
                                IconArwB : newEntry := Cmin(numTapeEntries, topTapeEntry + 1)
                             end;
                        if newEntry <> topTapeEntry then begin
                           DrawTape(newEntry, nullSel, false, false, false, false, false);
                           doSetPort(myWindow, false);
                           if numTapeEntries = 0 then NewThumb := 0
                           else newThumb := ord4(newEntry) * 1000 div numTapeEntries;
                           SetUpMvThumb(myHsbHit);
                           MoveThumb(newThumb);
                           scrollPos := newThumb
                        end;
                     until auto or not stilldown;
                     if not forced then PaintArw(myHsbHit, myIconHit, false)
                  end;
   end;
end;


(*$S       *)
{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
 procedure SetMaxNumParamAlert{flag : boolean};
 var menuStr  : str255;
     digitStr : calcStr;
     x        : integer;
 begin
   GetItem(myMenus[mFormat], c^.dispFormat, @menuStr);

    case c^.dispFormat * ord(flag) of
       mOneDec   : x := maxDigit - 3;
       mTwoDec   : x := maxDigit - 4;
       mThreeDec : x := maxDigit - 5;
       mFourDec  : x := maxDigit - 6;
       otherwise   x := maxDigit - 1
    end;
    SfromN(digitStr, x, 10, '0');
    ParamAlert(menuStr, digitStr, '')
 end;


{------------------------------------------------------------------------------
   SfromEntry - copies bytes from entry field to strg and sets the length of strg
 -----------------------------------------------------------------------------}
(*$S       *)
procedure SfromEntry{var strg : calcStr};
var x   : integer;
    sCH : string[1];
begin
   strg := '';
   sCH  := ' ';
   for x := 1 to entryLen do begin
      sCH[1] := entryCH(x);
      if (sCH[1] = chr(202)) or (sCH[1] = ' ') then exit(SfromEntry)
      else strg := concat(strg, sCH)
   end
end;


(***************************************.*******.************************************
   SfromN - base is 10 or 26; alphabet is '1' or 'A'. Converts the number num to
            a string in radix base ala LisaCalc row and column headings
****************************************.*******.***********************************)
(*$S     *)
procedure SfromN(* var answer : calcStr; num : longint; base : integer; alphabet : char *);
var absNum  : longint;
    tempStr : string[9];
    chrStr  : string[1];
begin
   if num = 0 then answer := '0'
   else begin
           absNum  := abs(num);
           tempStr := '';
           chrStr  := '$';
           while absNum > 0  do begin
              chrStr[1] := chr(((absNum - ord(base = 26)) mod base)+ord(alphabet));
              tempStr := concat(chrStr, tempStr);
              absNum  := (absNum - ord(base = 26)) div base
           end;
           if num < 0 then tempStr := concat('-', tempStr)
        end;
   answer := tempStr
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S       *)
procedure ShowDecimal{ch : char; doInsert : boolean};
var sCH       : string[1];
    entryLine : calcStr;
    pt        : integer;
    x         : integer;
    status    : integer;
    numDigits : integer;
begin
   if entryLen + ord(doInsert) <= maxDigits - 1 then begin
      SfromEntry(entryLine);
      x  := pos('.', entryLine);
      if x > 0 then delete(entryLine, x, 1);
      if doInsert then begin
         if ch = '.' then sCH := ''
         else begin
                 sCH := ' ';
                 sCH[1] := ch
              end
      end
      else begin
              sCH := '';
              entryLine := copy(entryLine, 1, length(entryLine)-1)
           end;

      pt := 0;
      for x := length(entryLine) downto 1 do
         if entryLine[x] <> '0' then pt := x;

      if pt = 0 then entryLine := sCH
      else entryLine := concat(copy(entryLine, pt, length(entryLine) - pt + 1), sCH);

      numDigits := c^.dispFormat - 2;
      if length(entryLine) <= numDigitis then
          entryLine := concat(copy('0000000000', 1, numdigits - length(entryLine) + 1), entryLine);

      clrEntry;
      for x:= 1 to length(entryLine) do begin
         InsCH(entryLine[x], entryFLD, entryFSH, status);
         if x = length(entryLine) - numDigits then InsCH('.', entryFLD, entryFSH, status)
      end;
(*$IFC CALCdebug *)
      if tracing or statusMsg then
         if status <> 0 then writeln('Error in InsCH: ',status:1);
(*$ENDC *)
      DrawEntry;
      if ch = '.' then C^.userDecimal := true
   end
   else begin
           setMaxNumParamAlert(true);
           StopAlert(allAlerts, 106)
        end
end;


{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S       *)
procedure showEntry{entryNum, topEntry : integer; finfo : FontInfo; nextMessage, drawOnTape, dim,
                    drawSelection, drawLonly : boolean; var operStr : str255};
var tFormat    : integer;
    nextFormat : integer;
    sgn        : integer;
    tapeEntry  : tapeInfo;
    result     : calcStr;
    error      : boolean;
    tempRect   : rect;

    procedure doUnderLine(message, STlinePos : integer);
    var leftEdge : integer;
    begin
       if message in [mS, mTotal, mEquals] then begin
          PenNormal;
          operStr  := copy(spaces, 1, maxDigits + sufTapeLen + 1);
          leftEdge := tempRect.right - StringWidth(operstr) - 2;
          if message = mEquals then begin
             if tapeEntry.tcalcStyle = Business then PenPat(ltGray);
             moveTo(leftEdge, tempRect.bottom - 1)
          end
          else begin
                  moveTo(leftEdge, STlinePos);
                  if message = mS then PenPat(gray)
               end;
          line(StringWidth(copy(operStr, 1, length(operStr) - sufTapeLen + 1)), 0);
          PenNormal
       end
    end;


begin
(*$R- *)
   tapeEntry  := C^.tapeValues[entryNum];
   nextFormat := 0;
   if nextMessage then begin
      if entryNum + 1 <= C^.tapeCnt then begin
         nextFormat := C^.tapeValues[entryNum + 1].tMessage;
         if nextFormat = mEquals then nextFormat := 0
      end
   end;
(*$IFC RangeChk *)
(*$R+ *)
(*$ENDC *)
   if not drawLonly then begin
      PicComment(cPicGrpBegin, 0, nil);
      SetRnd (tapeEntry.tRoundMode);
      tFormat := c^.dispFormat;
      c^.dispFormat := tapeEntry.tformat;
      DISPfromFP(tapeEntry.tnumber, result, error);
      c^.dispFormat := tFormat;
      case tapeEntry.tMessage of
         0,
         mBlank     : operStr := copy(spaces, 1, 1);
         mTPolish,
         mTAlgebraic,
         mTBusiness : GetItem(myMenus[mBuzz2Words], tapeEntry.tMessage - maxTapeWords, @operStr);
         otherwise    GetItem(myMenus[mBuzzWords], tapeEntry.tMessage, @operStr)
      end;

      if tapeEntry.tMessage = mNumSign then
         result := copy(concat(result, spaces), 1, maxDigits+1);

      if tapeEntry.tMessage <> mBlank then
         if (tapeEntry.tMessage = 0) or ((tapeEntry.tMessage >= minTapeWord) and (tapeEntry.tMessage <= maxTapeWord)) then begin
            operStr := concat(copy(spaces, 1, 2), operStr, spaces);
            operStr := concat(result, copy(operStr, 1, sufTapeLen))
         end
   end;

   if drawOnTape then begin
      tempRect := tapePortrect;
      if genPrintPic then tempRect := printRect;
      if genScrapPic then begin
         tempRect.left  := 0;
         tempRect.right := defTapeWidth
      end;
      tempRect.bottom := (entryNum - topEntry + 1) * tapeHeight + fInfo.descent + tempRect.top;
      tempRect.top    := tempRect.bottom - tapeHeight;

      if not drawSelection then begin
         if not drawLOnly then begin
            if genPrintPic then begin
               if ord(ClassD(tapeEntry.tnumber, sgn)) >= 0 then
                  if (sgn = 1) or ((tapeEntry.tMessage = mSub) and (tapeEntry.tCalcStyle <> Algebraic)) then begin
                     ForeColor(redColor);
                     CommentHnd^^ := redColor;
                     PicComment(cPicForeGnd, 4, pointer(ord(CommentHnd)))
                  end
            end
            else eraseRect(tempRect);
            moveTo(tempRect.right - StringWidth(operstr) - 2, tempRect.bottom - fInfo.descent);
            DrawOperString(operstr);
            if genPrintPic then begin
               ForeColor(blackColor);
               CommentHnd^^ := blackColor;
               PicComment(cPicForeGnd, 4, pointer(ord(CommentHnd)))
            end
         end;
         doUnderLine(tapeEntry.tMessage, tempRect.top - 1);
         if nextMessage then doUnderLine(nextFormat, tempRect.bottom - 1)
      end
   end;
   if not(drawLonly or genScrapPic or genPrintPic) and ((C^.bSelect > 0) or DrawSelection) then
      if ((entryNum + 1 >= C^.bSelect) and (entryNum +1 <= C^.eSelect)) or DrawSelection then
         DoHiLiteRect(tempRect, dim);
   PicComment(cPicGrpEnd, 0, nil)
end;

{------------------------------------------------------------------------------
 -----------------------------------------------------------------------------}
(*$S     *)
procedure ShowSelection{dim, reDraw : boolean};
var sInfo : selectInfo;
begin
   case C^.bSelect of
      -1      : ;
      0       : begin
                   doSetPort(myWindow, false);
                   if redraw then DrawReg(0, false, false);
                   DoHiLiteRect(entryFld^^.coords, dim)
                end;
      otherwise begin
                   sInfo.startRow := C^.bSelect - 1;
                   sInfo.endRow   := C^.eSelect - 1;
                   sInfo.oldStart := -1;
                   sInfo.oldEnd   := -1;
                   DrawTape(C^.topTapeEntry, sInfo, false, dim, false, not reDraw, false)
                end;
   end;
end;


{------------------------------------------------------------------------------
   StrToDataItem - converts a number found in ENTRYLINE to a value.  The
                   value is stored in the register # REGNUM.  If
                   the conversion cannot be done (ie, nothing in ENTRYLINE or just
                   a decimal point), the register will not be changed.
 -----------------------------------------------------------------------------}
(*$S     *)
procedure StrToDataItem{regNum : integer; shoError : boolean; var error : boolean};
var next      : integer;
    entryLine : calcStr;
    temp      : FPstring;
    tempNum   : DataItem;
    sCh       : string[2];
    status    : integer;
    FP0       : extended;
    myDecimal : Decimal;
begin
   SfromEntry(entryLine);
   if shoError then begin
     next := 0;
      while next < length(entryLine) do begin
         next := next + 1;
         if entryline[next] = chr(202) then delete(entryline, next, 1)
      end
   end;
   ClearXcps;
   temp  := entryline;
   error := false;
   if temp = '' then error := true
   else begin
           next := 1;
           Str2Dec(temp, next, myDecimal, error);
           error := false;
           Dec2X (myDecimal, FP0)
        end;

(*$IFC CALCDEBUG *)
   if debugging then writeln(entryline,'  ',error,'  next: ',next:1);
(*$ENDC *)
   X2D (FP0, tempNum);
   if error or (next <= length(entryLine)) or TestXcp(OVERFLOW) then begin
      if shoError then invertDisplay(true, 108);
      error := true
   end
   else c^.regs[regnum] := tempNum;
   if debugging then  DrawFormula([dMem, dRegs]);

   ClrEntry
end;


procedure MakeTapeEntry{newEntry : boolean; generate : tGen; dispReg : boolean};
var result      : calcStr;
    error       : boolean;
    SegSize     : longint;
    errNum      : integer;
    dsInfo      : dsinfoRec;
    tapeEntry   : tapeInfo;
    NewMemSize  : longint;
    NewDiskSize : longint;
    pt          : point;
begin
   with c^ do begin
      if not showTape then exit(MakeTapeEntry);

      Sched_Class(sErrNum, false);
      Info_DataSeg(errNum, segRefNum, dsInfo);
      Sched_Class(sErrNum, true);

      if (dsinfo.mem_size - sizeof(calcInfo)) div sizeof(tapeInfo) < tapeCnt + ord(newEntry) then begin

         Sched_Class(sErrNum, false);
         Size_DataSeg(errNum, segRefNum, 2048, NewMemSize, 2048, NewDiskSize);
         Sched_Class(sErrNum, true);

(*$IFC CALCdebug *)
         writeln('segsize: ',dsInfo.disc_size:1,' ',(dsinfo.mem_size - sizeof(calcInfo)) div sizeof(tapeInfo));
(*$ENDC *)
         if errNum <> 0 then begin
            StopAlert(allAlerts, 123);
            exit(MakeTapeEntry)
         end
      end;

      tapeEntry.tNumber    := regs[0];
      tapeEntry.tFormat    := dispformat;
      tapeEntry.tcalcStyle := calcStyle;
      if dispFormat <> mDefault then tapeEntry.tRoundMode := roundMode
      else tapeEntry.tRoundMode := TONEAREST;

      case generate of
         gNormal : case butPressed of
                      bMclear  : tapeEntry.tMessage := mMclear;
                      bMsub    : tapeEntry.tMessage := mMsub;
                      bMadd    : tapeEntry.tMessage := mMadd;
                      bMmul    : tapeEntry.tMessage := mMmul;
                      bClear   : if clrKey then tapeEntry.tMessage := mClear
                                 else tapeEntry.tMessage := mClrAll;
                      bSub     : tapeEntry.tMessage := mSub;
                      bAdd     : tapeEntry.tMessage := mAdd;
                      bMul     : tapeEntry.tMessage := mMul;
                      bXwithM  : tapeEntry.tMessage := mXwithM;
                      bDiv     : tapeEntry.tMessage := mDiv;
                      bMdiv    : tapeEntry.tMessage := mMdiv;
                      bInv     : tapeEntry.tMessage := mInv;
                      bPercent : tapeEntry.tMessage := mPercent;
                      bSqrt    : tapeEntry.tMessage := mSqrt;
                      bXwithY  : if calcStyle = business then begin
                                    if valueEntered then tapeEntry.tMessage := mNumSign
                                    else tapeEntry.tMessage := mSubTotal
                                 end
                                 else tapeEntry.tMessage := mXwithY;
                      benter2,
                      bEnter   : case calcStyle of
                                    Algebraic : tapeEntry.tMessage := mEquals;
                                    Business  : tapeEntry.tMessage := mTotal;
                                    Polish    : tapeEntry.tMessage := mEnter;
                                 end;
                      bChs     : if chsSign then tapeEntry.tMessage := mChs
                                 else tapeEntry.tMessage := 0;
                      bMRecall : tapeEntry.tMessage := mMRecall
                   end;
         gReg0   : if dispRegs then tapeEntry.tMessage := mX
                   else tapeEntry.tMessage := 0;
         gReg1   : begin
                      if dispRegs then tapeEntry.tMessage := mY
                      else tapeEntry.tMessage := 0;
                      tapeEntry.tNumber  := regs[1]
                   end;
         gMem    : begin
                      if dispRegs then tapeEntry.tMessage := mM
                      else tapeEntry.tMessage := 0;
                      tapeEntry.tNumber  := memory[0]
                   end;
         gNone   : tapeEntry.tMessage := mBlank;
         gItem   : begin
                      tapeEntry.tMessage := mNumSign;
                      tapeEntry.tFormat  := mDefault
                   end;
         gClrAll : tapeEntry.tMessage := mClrAll;
         gClrEntry:tapeEntry.tMessage := mClear;
         gSDiamond,
         gDiamond: tapeEntry.tMessage := mDiamond;
         gCalc   : case calcStyle of
                      Algebraic : tapeEntry.tMessage := mTAlgebraic;
                      Polish    : tapeEntry.tMessage := MTPolish;
                      Business  : tapeEntry.tMessage := mTBusiness
                   end;
         gSubTot : begin
                      tapeEntry.tMessage := mS;
                      if subTotal then tapeEntry.tNumber := regs[2]
                   end;
         gOp     : case pendCalcOp of
                      sSUBop : tapeEntry.tMessage := mSub;
                      sADDop : tapeEntry.tMessage := mAdd;
                      sMULop : tapeEntry.tMessage := mMul;
                      sDIVop : tapeEntry.tMessage := mDiv
                   end;
         gPaste  : tapeEntry.tMessage := mPTotal;
         gEqual0 : tapeEntry.tMessage := mEquals;
         gEqual1 : begin
                      tapeEntry.tMessage := mEquals;
                      tapeEntry.tNumber  := regs[1]
                   end
      end;

      tapeCnt := tapeCnt + ord(newEntry);

(*$R- *)
      tapeValues[tapeCnt] := tapeEntry;
(*$IFC RangeChk *)
(*$R+ *)
(*$ENDC *)
   end;
   ScrollTape(pt, hsbv, IconThumb, true, false);
   if generate = gSDiamond then MakeTapeEntry(true, gNone, false);
end;


(*$S        *)
procedure PrintTapeSelection;
var thePrPort   : TPrPort;
    fInfo       : FontInfo;
    IndeedPrint : boolean;
    IsNewStyle  : boolean;
    numCols     : integer;
    numPages    : integer;
    tapeWidth   : integer;
    pageCnt     : integer;
    colCnt      : integer;
    pageIndex   : integer;
    colIndex    : integer;
    numLinesVis : integer;
    myFntId     : TLfntId;
    fontOk      : boolean;
    fError      : integer;
    PTapeH      : integer;
    PTapeW      : integer;
    stripCnt    : integer;
    stripStr    : str255;
    result      : calcStr;
    dStripCnt   : dataItem;
    xStripCnt   : extended;
    stripForm   : integer;
begin
   with c^ do begin
      IndeedPrint := FPrInsDlg(header.printer.config, IsNewStyle, ePRDialogSuppress);
      if IndeedPrint then begin

         PrLfntid(C^.header.printer.config, tapeFont, [], myFntId);
         fontOk       := FMFontMetrics(myFntId, fInfo, ferror);
         PTapeH       := tapeHeight;
         PTapeW       := deftapeWidth;
         tapeHeight   := fInfo.ascent + fInfo.descent + fInfo.leading;
         deftapeWidth := (deftapeWidth div tapeChrWid) * finfo.widMax;
         pRPrintable  := header.printer.config.prInfo.rPrintable;
         if tracing then
             writeln('printer: ', tapeHeight:1,'   tapeHeight: ',PTapeH:1,'  deftapeWidth: ',PTapeW:1,'  new: ',deftapeWidth:1);

         with pRPrintable do begin
            left        := leftChIndent * finfo.widMax;
            top         := topChIndent * tapeHeight;
            bottom      := bottom - botChIndent * tapeHeight;
            numLinesVis := (bottom -  top + 1 - tapePSpacing) div tapeHeight;
            tapeWidth   := deftapeWidth + tapePSpacing * 3;
            numCols     := (right - left - tapePSpacing) div tapewidth;
            numPages    := ((eSelect - bSelect + 1) div (numCols * numLinesVis)) + 1;
         end;

(*$IFC CALCdebug *)
         if tracing then begin
            with header.printer.config.prInfo.rPrintable do
               writeln('rPrintable: ',top:1,',',left:1,'  ',bottom:1,',',right:1,'  tapeWidth: ',tapeWidth:1,'  numCols:',numCols:1);
            writeln('bselect: ',bSelect:1,',  eSelect: ',eselect:1,'  numLinesVis: ',numLinesVis:1,'  numPages: ',numPages:1);
         end;
(*$ENDC *)

         (* tell the printing unit in PrProcs to start a document                  *)
         if PrDocStart(header.printer.config, thePrPort, printLdsn, true) then begin

            ForeColor(BlackColor);
            CommentHnd^^ := BlackColor;
            PicComment(cPicForeGnd, 4, pointer(ord(CommentHnd)));
            BackColor(WhiteColor);
            CommentHnd^^ := WhiteColor;
            PicComment(cPicBackGnd, 4, pointer(ord(CommentHnd)));

            pageCnt  := 1;
            stripCnt := 1;
            repeat
               pageIndex := (pageCnt - 1) * (numCols * numLinesVis);
               if PrPageStart(header.printer.config, thePrPort) then begin
                  TextFont(tapeFont);
                  TextFace([]);

                  genPrintPic := true;
                  for colCnt := 0 to numCols - 1 do begin
                     colIndex     := colCnt * numLinesVis;
                     pStartEntry  := bSelect - 1 + pageIndex + colIndex;
                     pStopEntry   := pStartEntry + numLinesVis - 1;
                     if eSelect -  1 < pStopEntry then pStopEntry := eSelect -  1;

                     if tracing then writeln('pStartEntry: ',pStartEntry:1,'  pStopEntry: ',pStopEntry:1);

                     if pstartEntry <= eSelect - 1 then begin
                        pRPrintable        := header.printer.config.prInfo.rPrintable;
                        ClipRect(pRPrintable);
                        pRPrintable.left   := leftChIndent * finfo.widMax + colCnt * tapeWidth;
                        pRPrintable.right  := pRPrintable.left + tapeWidth;
                        pRPrintable.top    := topChIndent * tapeHeight;
                        pRPrintable.bottom := pRPrintable.bottom - botChIndent * tapeHeight;
                        if pStopEntry <> pStartEntry + numLinesVis - 1 then
                           pRPrintable.bottom := pRPrintable.bottom - (numLinesVis - (pStopEntry - pStartEntry + 1)) * tapeHeight;

                        stripForm  := dispFormat;
                        dispFormat := mZeroDec;
                        I2X(stripCnt , xStripCnt);
                        X2D(xStripCnt, dStripCnt);
                        DispFromFP(dStripCnt, result, fontOk);
                        dispFormat := stripForm;
                        GetItem(myMenus[mBuzz2Words], mStrip, @stripStr);
                        stripStr := concat(stripStr,' ',result);
                        MoveTo(pRPrintable.right - (tapeWidth + StringWidth(stripStr)) div 2, pRPrintable.bottom + tapeHeight);
                        DrawString(stripStr);

                        PrintRect := pRPrintable;
                        InsetRect(PrintRect, tapePSpacing div 2, tapePSpacing div 2);

                        if tracing then
                           with printrect do
                              writeln('printRect: ',top:1,',',left:1,'  ',bottom:1,',',right:1,
                                      '   pStartEntry:',pStartEntry:1,'   pStopEntry:',pStopEntry:1);
                        DrawTape(pStartEntry, nullSel, false, false, true, false, false);
                        stripCnt := stripCnt + 1
                     end
                  end
               end;
               pageCnt := pageCnt + 1
            until PrPageEnd(header.printer.config, thePrPort) or (pageCnt > numPages)
         end;

         PrDocEnd(header.printer.config, thePrPort);
         genPrintPic  := false;
         tapeHeight   := PTapeH;
         deftapeWidth := PTapeW
      end
   end
end;


{------------------------------------------------------------------------------}
(*$S         *)
begin   { main program }

   InitGraf(@thePort);           { Init LisaGraf.  Should be done by each process }
   OpenWm;                           { give W/M addressability to shared heap }

      { If any error conditions are encountered, 'TellFiler (..., initFailed, ...}

   Initialize;
   copyRight := length(copy(sCopyright, 1, length(sCopyright)));

   repeat  { Main Program Loop }

     while not (ImActive OR toldToDie) do begin
        GetEvent(theEvent);  { may suspend me }
        ProcessTheEvent
     end;

     while ImActive and not toldToDie do begin
(*$IFC CALCdebug *)
        getKeys(myKeys);
        if (78 in myKeys) and (126 in myKeys) then DrawFormula([dRegs, dMem]);
(*$ENDC *)
        if EventAvail then begin
           if myWindow <> nil then doSetPort(mywindow, false);
           GetEvent(theEvent);
           ProcessTheEvent
        end
        else LetOthersRun
     end;
   until toldToDie;
end.
ÿ