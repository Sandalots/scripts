(* ********************************************************************* *)

(* CopyRight 1983,1984 Apple Computer Inc. *)
(* GE Menu Command Routines *)

(* ********************************************************************* *)

UNIT Cmd;

(* Segment CMD *)
INTERFACE
USES
    (*$U UNITSTD*)     UnitStd,     (* interface dependency  *)
    (*$U UNITHZ*)      UnitHz,
    (*$U STORAGE*)     Storage,
    (*$U QUICKDRAW*)   QuickDraw,
    (*$U FONTMGR*)     FontMgr,
    (*$U LibOS/syscall *)   Syscall,
    {$U LibPm/PmDecL}      PmDecL,
    {$U PrStdInfo}     PrStdInfo,
    {$U PrPublic}      PrPublic,
    (*$U ApLd/HDR*)    Hdr,
    {$IFC sampcalls}
    {$U apld/tracecalls.obj}  tracecalls,
    {$ENDC}
                                    (* implementation unit   *)
    (*$U WM.EVENTS*)   Events,
    (*$U WM.MENUS*)    Menus,
    (*$U WM.FOLDERS*)  Folders,
    (*$U WMLSTD*)      WMLStd,
    (*$U WMLSB*)       WMLSB,
    (*$U WMLCRS*)      WMLCrs,
    (*$U ApLd/DMGR*)   DMgr,
    (*$U ApLd/UTL*)    Utl,
    (*$U ApLd/DAT*)    Dat,
    (*$U ALERTMGR*)    AlertMgr,
    (*$U ApLd/DBX*)      Dbx,
    (*$U ApLd/SEL*)      Sel,
    (*$U ApLd/PRT*)      Prt,
    (*$U ApLd/UOP*)      UOp,
    (*$U ApLd/DRW*)      Drw,
    (*$U ApLd/SCP*)      Scp,
    (*$U ApLd/SCR*)      Scr,
    (*$U ApLd/TRK*)      Trk,
    (*$U ApLd/TXT*)      Txt,
    (*$U ApLd/FIO*)      Fio;

VAR
    quitFlag:   Boolean;
    firstChar:  Boolean;
    curPenFlag: Boolean;

    {Font style and size arrays and varialbe to remember style}
    fontStyle: Array[iFontStart..iFontEnd] of Integer;
    fontSize:  Array[iFontStart..iFontEnd] of Integer;
    fontIndex: Array[iFontModern..iFontClassic,iFntSzStart..iFntSzEnd]
                       of Integer;
    curStyle: Integer;  {Takes on values iFontClassic and iFontModern}


    (* File/Print Menu *)
    procedure LoadCmd(refNum: Integer; needAlert: Boolean; var errNum: Integer);
    procedure SaveCmd(refNum: Integer; needAlert: Boolean; var errNum: Integer);

    (* Edit Menu *)
    procedure UndoCmd;
    procedure CutCmd;
    procedure CopyCmd;
    procedure PasteCmd(item: Integer);
    procedure DupCmd;
    procedure ClearCmd;
    procedure SelAllCmd;
    procedure RotateCmd(item: Integer);
    procedure ReshapeCmd;
    procedure SmoothCmd(item: Integer);
    procedure DupKnobCmd;
    procedure DeleteKnobCmd;
    procedure RndCmd(doItFlag: Boolean);
    (* Arrange Menu *)
    procedure TopCmd;
    procedure BottomCmd;
    procedure GroupCmd;
    procedure UnGroupCmd;
    procedure GridObjCmd;
    procedure LineUpCmd(dir: Integer);
    procedure LockCmd(item: Integer);
    (*PenStyle, FillStyle, Color, LineStyle Menu *)
    procedure PenStyleCmd(item: Integer);
    procedure FillStyleCmd(item: Integer);
    procedure ColorCmd( item: Integer );
    procedure LineStyleCmd(item: Integer);
    (* TypeStyle, TextStyle Menu *)
    procedure TxtCaseCmd(nCase: Integer);
    procedure TxtSelCmd(talign: Integer; frcCtr: Boolean );
    procedure TxtFmtCmd(face,font: Integer);
    (* Layout Menu *)
    procedure RlrZeroCmd(lclPt: Point);
    procedure RlrOnOffCmd(item: Integer);
    procedure SizeCmd    (item: Integer);
    procedure PaperCmd   (item: Integer);
    procedure ZoomCmd    (item: Integer);
    procedure PageBrkCmd (item: Integer);
    procedure RlrCmd(doItFlag: Boolean);
    procedure DwgCmd(doItFlag: Boolean);
    (* Miscellaneous *)
    Function  ExpMiscMem(op,hSiz,pSiz: Integer): Boolean;
    Function  ExpTrfoMem(op: Integer): Boolean;
    function  ObjInSLst(objKind: Integer; VAR notLocked: Boolean): Boolean;
    procedure SetTraceCmd(var flag: boolean; FlagName: String80);
    procedure TxtClkCmd(this2D: Point2D; shFlagOn,sameFmt: Boolean);
    procedure CkTxtBounds(op: Integer);
    procedure CkCaretLoc;
    procedure InitCmd;

(* ********************************************************************* *)

IMPLEMENTATION


(* ********************************************************************* *)

CONST
    iZoomNormal = 0;
    iZoomRToFit = 1;
    iZoom70PerCent = 2;
    dxDup = 12.00;
    dyDup =  8.00;

    (* scrap types from Unit Scrap *)
    scrapNil    = 0;
    scrapFE     = 2;
    scrapDwg    = 6;
Type
    TObjSet     = Set of iObjNil..iObjGroup;
VAR
    dup2D:  Point2D;
    grafObj,fPatObj,lineObj,anyObj: TObjSet;
    mapMToRot: Array[1..4] of TPByte;
    saveRlrOn: Boolean;


(* ********************************************************************* *)

(*$S Arrange*)
    procedure AddToFBh(obj: TObjPtr);
    Var size,newSize: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('AddToFBh(',ord(obj):8,')');
        {Check for room}
        size := CbDataOfH(HzFromH(Pointer(Ord(fallInBh))),Pointer(Ord(fallInBh)));
        newSize := SizeOf(TUndoLst) + (fallInNm+1)*SizeOf(TObjPtr);
        If size < newSize then
            ChangeSizeH(HzFromH(Pointer(Ord(fallInBh))),Pointer(Ord(fallInBh)),
            newSize + cSelGrow);
        fallInNm := fallInNm + 1;
        (*$R-*)
        fallInBh^^[fallInNm] := obj^.fLink;
        (*$IfC rangeOn *)(*$R+*)(*$EndC *)
    end;{AddToFBh}


    (* ***************************************************************** *)

(*$S Arrange*)
    procedure ResetFBh;
    Var size: Integer;

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        fallInNm := 0;
        {Free up memory in fallInBh}
        size := CbDataOfH(HzFromH(Pointer(Ord(fallInBh))),Pointer(Ord(fallInBh)));
        If size > cSelGrow then
            ChangeSizeH(HzFromH(Pointer(Ord(fallInBh))),Pointer(Ord(fallInBh)),
            cSelGrow);
    end;{ResetFBh}

(*****************************************************************************)

(*$S Arrange*)
    procedure TxtToTop;
    Var thisObj: TObjPtr;
              i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        ResetFBh;
        For i := curDoc.sLst^^.sCnt downto 1 do begin
            thisObj := CurSelObj(i);
            AddToFBh(thisObj);
            With thisObj^ do begin
                If (oDat.kind = iObjText) AND (pSel=iSelGpy) then begin
                    SubFmOLst(curDoc.oLst,thisObj);
                    AddToOBeg(curDoc.oLst,thisObj);
                end;
            end;
        end;
    end; {TxtToTop}

(*****************************************************************************)

(*$S Arrange*)
    procedure TxtToTxt;
    Var thisObj: TObjPtr;
              i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('TxtToTxt.');
        For i := outPlLst^^.sCnt downto 1 do begin
            thisObj := GetSelObj(outPlLst,i);
            AddToOBeg(curDoc.oLst,thisObj);
        end;
        InitSLst(outPlLst);
    end; {TxtToTxt}

(*****************************************************************************)

(*$S Arrange*)
    procedure ObjToObj;
    Var thisObj: TObjPtr;
              i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('ObjToObj.');
        For i := 1 to outPlLst^^.sCnt do begin
            thisObj := GetSelObj(outPlLst,i);
            AddToOEnd(curDoc.oLst,thisObj);
        end;
        InitSLst(outPlLst);
    end; {ObjToObj}


    (* ***************************************************************** *)

(*$S Arrange*)
    procedure ResetGBE;
    Var size: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        groupNum := 0;
        {Free up memory in groupBeg and groupEnd}
        size := CbDataOfH(HzFromH(Pointer(Ord(groupBeg))),Pointer(Ord(groupBeg)));
        If size > cSelGrow then
            ChangeSizeH(HzFromH(Pointer(Ord(groupBeg))),Pointer(Ord(groupBeg)),
            cSelGrow);
        size := CbDataOfH(HzFromH(Pointer(Ord(groupEnd))),Pointer(Ord(groupEnd)));
        If size > cSelGrow then
            ChangeSizeH(HzFromH(Pointer(Ord(groupEnd))),Pointer(Ord(groupEnd)),
            cSelGrow);
    end;{ResetGBE}

    (* ***************************************************************** *)

(*$S Arrange*)
    procedure GroupLoc(Var nextObj: TObjPtr);{Finds the location to
                                                insert a new group}
    Var iMax, i: Integer;
        thisObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        {Find the upper most unlocked geometrical object if any in curDoc.sLst}
        With curDoc.sLst^^ do begin
            If sCnt > 0 then begin
                iMax := 0;
                For i := 1 to sCnt do begin
                    thisObj := CurSelObj(i);
                    If (thisObj^.oDat.kind<>iObjText) AND
                    (NOT ObjLocked(thisObj)) then
                        iMax := i;
                end;
                If iMax = 0 then
                    nextObj := curDoc.oLst.tBeg {put just behind the text objects}
                else begin
                    thisObj := CurSelObj(iMax);
                    nextObj := thisObj^.fLink;
                end;
            end;
        end;
    end; {GroupLoc}

(**********************************************************************)
(*$S Core2*)
    function  ObjInSLst(* objKind: Integer; VAR notLocked: Boolean): Boolean *);
    var haveObj: Boolean;
        thisObj: TObjPtr;
        i:  Integer;
        tSel: TSelLst;

    (* ***************************************************************** *)

        procedure CkObj(obj: TObjPtr; VAR notLocked,haveObj: Boolean);
        var grpLst,trfoObj: TObjPtr;
            thisKind: Integer;
        begin
            haveObj := FALSE;
            notLocked := FALSE;
            If (lastOp.op=iOpSmo) OR (lastOp.op=iOpUnS) then begin
                trfoObj :=  CkObjTrfo(obj);
                thisKind := trfoObj^.oDat.kind;
            end else begin
                thisKind := obj^.oDat.kind;
            end;
            With obj^.oDat do begin
                if thisKind=objKind then begin
                    notLocked := NOT ObjLocked(obj);
                    haveObj   := TRUE;
                end else if thisKind=iObjGroup then begin
                    grpLst := grp.lBeg;
                    while grpLst<>NIL do begin
                        CkObj(grpLst,notLocked,haveObj);
                        if notLocked then
                            grpLst := NIL
                        else
                            grpLst := grpLst^.fLink;
                    end;
                end;
            end;
        end; (* CkObj *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* see if there is an unlocked objKind in current selection *)
        (* if not, then alert *)
        haveObj   := FALSE;
        notLocked := FALSE;
        tSel := curDoc.sLst^^;
        if tSel.sState=objKind then begin
            thisObj   := CurSelObj(1);
            notLocked := NOT ObjLocked(thisObj);
            haveObj   := TRUE;
        end else if (tSel.sState=iSStGrp) OR (tSel.sState=iObjGroup) then begin
            for i := 1 to tSel.sCnt do begin
                thisObj := CurSelObj(i);
                CkObj(thisObj,notLocked,haveObj);
                if notLocked then
                    i := tSel.sCnt;
            end;
        end;
        ObjInSLst := haveObj;
    end; (* ObjInSLst *)

(* ********************************************************************* *)

(*$S Ring*)
    function  SLstNotLocked: Boolean;
    var lockFlag,opFlag: Boolean;
        i: Integer;
        tSel: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* see if the current selection is unLocked *)
        (* if not, then alert *)
        tSel := curDoc.sLst^^;
        if (tSel.sState=iSStPrt) OR (tSel.sState=iObjNil) then
            lockFlag := FALSE
        else begin
            opFlag := lastOp.op in [iOpLck,iOpUnl];
            lockFlag := TRUE;
            for i := 1 to tSel.sCnt do
                if NOT ObjLocked(CurSelObj(i)) then begin
                    lockFlag := FALSE;
                    i := tSel.sCnt;
                end;
        end;
        SLstNotLocked := NOT lockFlag;
        if lockFlag then
            GEAlert(iStopLock);
    end; (* SLstNotLocked *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure CkObjVis(objKind: TObjSet; VAR scrollFlag: Boolean);
    var scrollPt: Point;
        thisObj,validObj: TObjPtr;
        objVis: Boolean;
        thisRect: Rect;
        i,sCnt: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* see if there is a visible unlocked objKind in current selection *)
        scrollFlag := FALSE;
        objVis  := FALSE;
        validObj := NIL;
        sCnt    := curDoc.sLst^^.sCnt;
        for i := 1 to sCnt do begin
            thisObj := CurSelObj(i);
            if lastOp.op in [iOpMov,iOpStr] then
                thisObj := CkObjTrfo(thisObj);
            with thisObj^,oDat do
            if kind in objKind then
                if NOT ObjLocked(thisObj) then begin
                    validObj := thisObj;
                    if thisObj=trfoObj then
                        validObj := trfoRef;
                    if SectRect(bBox,dwgLBox,thisRect) then begin
                        i := sCnt;
                        objVis  := TRUE;
                    end;
                end;
        end;
        (* if no valid obj, then scroll to one *)
        if NOT objVis then
            if validObj<>NIL then begin
                ScrollObj(thisObj);
                scrollFlag := TRUE;
            end;
    end; (* CkObjVis *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure CheckVis(objKind: TObjSet);
    var scrollFlag: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        CkObjVis(objKind,scrollFlag);
    end; (* CheckVis *)

(* ********************************************************************* *)

(*$S Core2*)
    Function  CkMemSize(op: Integer; siz: LongInt): Boolean;
    const
       pHzOverhead = 2;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* check to see if we exceed the empirical limit *)
        CkMemSize := TRUE;
        with curDoc do
        if (siz+oLst.lst.lSiz + oLst.lst.lTot*pHzOverhead)
           >cMaxTotDataSize then begin
            CkMemSize := FALSE;
            GECmdAlert(iStopMem,op);
        end;
    end; (* CkMemSize *)

(* ********************************************************************* *)

(*$S Core2*)
    procedure CkSiz(VAR siz: LongInt);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if siz>0 then
            if siz<512 then
                siz := 512;
    end; (* CkSiz *)

(* ********************************************************************* *)

(*$S Core2*)
    Function  ExpMiscMem(* op,hSiz,pSiz: Integer): Boolean *);
    var errNum: Integer;
        hLSiz,pLSiz: LongInt;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        ExpMiscMem := FALSE;
        hLSiz := hSiz;
        pLSiz := pSiz;
        CkSiz(hLSiz);
        CkSiz(pLSiz);
        if CkMemSize(op,hLSiz+pLSiz) then begin
            (* see if we can expand heaps by pstSize *)
            ExpandMem(hLSiz,pLSiz,errNum);
            if errNum>0 then
                GECmdAlert(errNum,op)
            else
                ExpMiscMem := TRUE;
        end;
    end; (* ExpMiscMem *)

(* ********************************************************************* *)

(*$S Core2*)
    Function  ExpTrfoMem(* op: Integer): Boolean *);
    var i,errNum: Integer;
        maxSize,size,hSiz,pSiz: LongInt;
        maxObj,obj: TObjPtr;
        sLst: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* find the largest currently selected object *)
        sLst := curDoc.sLst^^;
        for i := 1 to sLst.sCnt do begin
            obj  := curSelObj(i);
            size := sizeOfObj(obj);
            if (maxSize<SizeOfObj(obj)) OR (i=1) then begin
                maxObj := obj;
                maxSize := size;
            end;
        end;
        (* decompose maxSize into hSize,pSize *)
        pSiz := SizeOf(TObjRec);
        with  maxObj^.oDat do
        if maxObj^.oDat.kind=iObjGroup then begin
            pSiz := (grp.lTot+1)*pSiz;
            hSiz := grp.lSiz-pSiz;
        end else
            hSiz := SizeOfObj(maxObj)-pSiz;
        ExpTrfoMem := ExpMiscMem(op,hSiz,pSiz);
    end; (* ExpTrfoMem *)

(* ********************************************************************* *)
(*$S Ring*)
    Function  ExpSLstMem(op: Integer): Boolean;
    var thisStat: TStatRec;
        hSiz,pSiz: LongInt;
        errNum: Integer;
        okToGo: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* called from DupCmd and GroupCmd to check for locked selection,
           and enough memory *)
        ExpSLstMem := FALSE;
        (* see if any objects are not locked *)
        okToGo := TRUE;
        If op = iCItmGrp then okToGo := SLstNotLocked;
        If okToGo then
            (* see if there is enough room *)
            if CkMemSize(op,curDoc.sLst^^.sSiz) then begin
                (* see if we can expand heaps by size of current selection *)
                GetSLstStats(curDoc.sLst,thisStat);
                GetStatSiz(thisStat,hSiz,pSiz);
                CkSiz(hSiz);
                CkSiz(pSiz);
                ExpandMem(hSiz,pSiz,errNum);
                if errNum>0 then
                    GECmdAlert(errNum,op)
                else
                    ExpSLstMem := TRUE;
            end;
    end; (* ExpSLstMem *)

(* ********************************************************************* *)

(* File/Print Menu Commands *)

(* ********************************************************************* *)
(*$S IO*)
    procedure LoadCmd(* refNum: Integer; needAlert: Boolean; var errNum: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('LoadCmd(',refNum:2,')');

        (* make state consistent *)
        SetPort(curDoc.fldr);
        CommitLastOp;
        (* Reset Ops in Progress *);
        ResetPoly;
        ResetAutoDrw;
        ResetEdit;
        ResetCurSel;
        (* load dwg AND reset atr *)
        DltAll(curDoc.oLst);
        {if needAlert then
            GEAlert(iWaitLoad);}
        SetPort(curDoc.fldr);
        LoadGEFile(refNum,errNum);
        (* write message *)
        {if needAlert AND fActive then
            HideFolder(alertFolder);}
        if errNum>0 then begin
            if (errNum<>iStopMem) AND (errNum<>iStopDisk) then
                GEAlert(errNum);
        end else begin
            SetGEBox(TRUE);
            SetThumb(hSBox,DwgThumbPos(iDirLft));
            SetThumb(vSBox,DwgThumbPos(iDirTop));
        end;
    end; (* LoadCmd *)

(* ********************************************************************* *)

(*$S IO*)
    procedure SaveCmd(* refNum: Integer; needAlert: Boolean; var errNum: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('SaveCmd(',refNum:2,')');

        (* make state consistent *)
        SetPort(curDoc.fldr);
        (* Reset Ops in Progress *);
        CommitLastOp;
        ResetTxt;
        ResetPoly;
        ResetAutoDrw;
        if (curDoc.edtState<>iObjNil) AND curDoc.edtStart then
            GetBBox(curDoc.edtObj);
        (* save the file *)
        if needAlert then
            GEAlert(iWaitSave);
        SaveGEFile(refNum,errNum);
        if needAlert AND fActive then
            EndWaitAlert;
            {HideFolder(alertFolder);}
        if errNum>0 then
            GEAlert(errNum);
    end; (* SaveCmd *)

(* ********************************************************************* *)

(* Edit Menu Commands *)

(* ********************************************************************* *)

(*$S Undo*)
    procedure UndoCmd;
    var oldRect,thisRect,nBox,pBox: Rect;
        scrollFlag: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if lastOp.op=iOpNil then
            GEAlert(iStopUndo)
        else if lastOp.op<>iOpNOP then begin
            With lastOp,curDoc do begin
                (* undo of text ops *)
                If (op=iOpTxt) OR (op=iOpTCut) OR (op=iOpTCpy)
                OR ((op=iOpUnd) AND ((oldOp=iOpTxt) OR (oldOp=iOpTCut)
                OR (oldOp=iOpTCpy)))
                then begin
                    (* force text mode *)
                    SetCurProto(iObjText,TRUE);
                    UndoLastOp(scrollFlag);
                    oldRect := curDoc.txtObj^.bBox;
                    TxtUndo;
                    thisRect := curDoc.txtObj^.bBox;
                    txtObj^.cSel := iSelEdt;
                    ReShowUnion(oldRect,thisRect);
                    (* undo scrap if cut or copy *)
                    If ((op=iOpUnd) AND ((oldOp=iOPTCut) OR (oldOp=iOpTCpy)))
                    OR ((op=iOpTCut) OR (op=iOpTCpy)) then
                        UndoGEScrap;
                (* undo of graphical ops *)
                end else begin
                    ResetAutoDrw;
                    ResetEd1;
                    ResetTxt;
                    HiliteSel(OFF);
                    SetCurProto(iObjNil,TRUE);
                    (* undo the op *)
                    UndoLastOp(scrollFlag);
                    (* if the op undone was undo of reshape, then restore edt state *)
                    if (op=iOpEdt)
                    OR ((op=iOpUnd) AND (oldOp=iOpEdt)) then begin
                        edtObj    := CurSelObj(1);
                        edtState  := edtObj^.oDat.kind;
                        edtStart  := FALSE;
                        edtObj^.cSel := iSelEdt;
                    end;
                    If ((op=iOpUnd) AND ((oldOp=iOpCpy) OR (oldOp=iOpCut))) then
                        UndoGEScrap;
                    If op=iOpRdo then
                        RedoCmd
                    else begin
                        UndoOLst;
                        If scrollFlag then
                            with scrollPt do
                                ScrollTo(h,v)
                        else begin
                            pBox := pSLst^^.sBBox;
                            if SectRect(pBox,nBox,thisRect) then begin
                                UnionRect(pBox,nBox,thisRect);
                                ReShowInset(thisRect);
                            end else begin
                                ReShowInset(pBox);
                                ReShowInset(nBox);
                            end;
                        end;
                    end;
                    curDoc.edtStart := FALSE;
                end;
            end;
        end;
    end; (* UndoCmd *)
(* ********************************************************************* *)

(*$S BasicOps*)
    function TextSelected(Var unlocked:Boolean): Boolean;
          {Assumes that an object is selected}
    Var trfoObj: TObjPtr;
    begin
        trfoObj := CkObjTrfo(CurSelObj(1));
        With trfoObj^.oDat,inf do begin
            unlocked := locked=0;
            TextSelected  := tDat<16;
        end;
    end;{TextSelected}

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure CutCmd;
    var thisRect: Rect;
        sel2D: Point2D;
        thisSel,nextSel: TSelPtr;
        sState: Integer;
        txtSelected: Boolean;
        unlocked: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('CutCmd.');

        scpShPat := curDoc.showPats;            {set scrap show paterns or color
                                                  initials}
        sState := curDoc.sLst^^.sState;
        txtSelected := FALSE;
        if sState=iObjText then
            txtSelected := TextSelected(unlocked);
        If txtSelected then txtSelected := unlocked;

        if (sState=iObjNil) then
            GECmdAlert(iStopSel,iCItmCut)
        else if ((curDoc.proto=iObjText) AND curDoc.fldSet)
        OR  txtSelected then begin
            CommitLastOp;
            if NOT curDoc.fldSet then
                TxtSelAll(curSelObj(1));
            CheckVis([iObjText]);
            SetLastOp(iOpTCut);
            thisRect := curDoc.txtObj^.bBox;
            TxtCut;
            ReShow(thisRect);
        end else if (sState=iSStGrp) OR (sState>iObjNil) then
            if SLstNotLocked then begin
                CheckVis(anyObj);

                (* Reset Ops in Progress *);
                ResetEdit;
                ResetPoly;
                ResetAutoDrw;
                ResetTxt;

                CommitLastOp;
                GetSelRect(curDoc.sLst,thisRect);
                if PutGEScrap then begin
                    (* remember lastOp *)
                    SetLastOp(iOpCut);
                    dupCtrFlag := OFF;
                    (* redraw *)
                    SetPort(scrapFolder);
                    InvalRect(scrapFolder^.portRect);
                    SetPort(curDoc.fldr);
                    ReShow(thisRect);

                    (* remember center of selection as pastePt *)
                    pasteState := TRUE;
                    with thisRect do
                    SetPt(pastePt,(left+right) div 2, (top+bottom) div 2);
                end else begin
                    SetLastOp(iOpNOP);
                    GECmdAlert(iStopSSize,iCItmCut);
                end;
            end;
    end; (* CutCmd *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure CopyCmd;
    var sel2D: Point2D;
        thisSel: TSelPtr;
        nObj: TObjPtr;
        sState: Integer;
        unlocked: Boolean;
        txtSelected: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('CopyCmd.');

        scpShPat := curDoc.showPats;             {set scrap show paterns or color
                                                  initials}
        sState := curDoc.sLst^^.sState;
        txtSelected := FALSE;   {initialize}
        if sState=iObjText then
            txtSelected := TextSelected(unlocked);
        if ((curDoc.proto=iObjText) AND curDoc.fldSet)
        OR txtSelected then begin
            CommitLastOp;
            if NOT curDoc.fldSet then
                TxtSelAll(curSelObj(1));
            SetLastOp(iOpTCpy);
            TxtCopy;
        end else if (sState=iObjNil) then
            GECmdAlert(iStopSel,iCItmCpy)
        else if (sState=iSStGrp) OR (sState>iObjNil) then begin
            (* Reset Ops in Progress *);
            ResetAutoDrw;
            CommitLastOp;
            if PutGEScrap then begin
                (* remember LastOp *)
                SetLastOp(iOpCpy);
                SetPort(scrapFolder);
                InvalRect(scrapFolder^.portRect);
                SetPort(curDoc.fldr);
            end else begin
                SetLastOp(iOpNOP);
                GECmdAlert(iStopSSize,iCItmCpy);
            end;
        end;
    end; (* CopyCmd *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure GetPst2D(default2D: Point2D; oldsBBox: Rect; VAR p2D: Point2D);
    var sLst: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        sLst := curDoc.sLst^^;
        p2D := default2D;
        with sLst do
        if (sState=iSStPrt) OR (sState=iObjNil) then begin
            (* if nothing selected, then use pastePt or dwg ctr *)
            if pasteState then
                ScrnToWld(pastePt,p2D)
        end else
            (* if something selected then use center of selection *)
            RectCtr2D(oldsBBox,p2D);
    end;{GetPst2D}

(* ********************************************************************* *)

(*$S Ring*)
    procedure PasteCmd(* item: Integer *);
    var pst2D:       Point2D;
        pstBBox:     Rect;
        pstGBox:     Rect2D;
        hSiz,pSiz:   LongInt;
        tempPt:      Point;
        tempSLst:    TSelLst;
        i,scrapType: Integer;
        tempOp:      Integer;
        oldsBBox:    Rect;
        sState:      Integer;
        sStateOK:     Boolean;

(* ********************************************************************* *)

        procedure GtPst2D(default2D: Point2D; oldsBBox: Rect; VAR p2D: Point2D);
        var sLst: TSelLst;
        begin
            {$IFC sampcalls} ALogCall; {$ENDC}
            sLst := curDoc.sLst^^;
            p2D := default2D;
            If sStateOK then begin
                (* if nothing selected, then use pastePt or dwg ctr *)
                If pasteState then ScrnToWld(pastePt,p2D);
            end else begin
                (* if something selected then use center of selection *)
                RectCtr2D(oldsBBox,p2D);
            end;
        end;{GtPst2D}

        (* ***************************************************************** *)

        procedure GetPstLoc(thisBBox: Rect; thisGBox: Rect2D; VAR this2D: Point2D);
        var ctr2D,dwgCtr2D,scrp2D,scrpTL,newTL: Point2D;
            ctrPt: Point;
            tempSLst: TSelLst;
            tempGBox: Rect2D;
            i,scrapType: Integer;
        begin
            {$IFC sampcalls} ALogCall; {$ENDC}
            if traceCmd then begin
                WlnRect('    GetPstLoc bBox:',thisBBox);
                with thisGBox do
                Writeln('             gBox:',xL:6:2,',',yT:6:2,',',
                                             xR:6:2,',',yB:6:2);
            end;

            (* get ctr of dwgLBox in case pst ctr is not visible *)
            RectCtr2D(dwgLBox,dwgCtr2D);

            (* get center of paste *)
            tempSLst := curDoc.sLst^^;
            GtPst2D(dwgCtr2D,oldsBBox,ctr2D);
            with tempSLst do
            if (sState=iSStGrp) OR (sState>iObjNil) then with oldsBBox do begin
                (* if pasteBBox is same size as selBBox, then offset *)
                if ((right-left)=(thisBBox.right-thisBBox.left)) AND
                   ((bottom-top)=(thisBBox.bottom-thisBBox.top)) then
                    if curDoc.atr.grdOn then
                        AddPt2D(curDoc.atr.grdSz2D,ctr2D)
                    else begin
                        ctr2D.x := ctr2D.x+dxDup;
                        ctr2D.y := ctr2D.y+dyDup;
                    end;
            end;
            WldToScrn(ctr2D,ctrPt);

            (* make sure paste pt is visible *)
            if NOT PtInRect(ctrPt,dwgLBox) then
                ctr2D := dwgCtr2D;

            (* get center of scrap *)
            with thisBBox do
            SetPt2D(scrp2D,(left+right)/2,(top+bottom)/2);

            (* get preliminary pstPt *)
            this2D := ctr2D;
            SubPt2D(scrp2D,this2D);

            (* make sure pasteRect is in SizeLBox bounds *)
            ScrnToWld(thisBBox.topLeft,tempGBox.topLeft);
            ScrnToWld(thisBBox.botRight,tempGBox.botRight);
            AddPt2D(this2D,tempGBox.topLeft);
            AddPt2D(this2D,tempGBox.botRight);
            if tempGBox.xL<sizeLBox.left then
                this2D.x := this2D.x+sizeLBox.left-tempGBox.xL
            else if tempGBox.xR>sizeLBox.right then
                this2D.x := this2D.x+sizeLBox.right-tempGBox.xR;
            if tempGBox.yT<sizeLBox.top then
                this2D.y := this2D.y+sizeLBox.top-tempGBox.yT
            else if tempGBox.yB>sizeLBox.bottom then
                this2D.y := this2D.y+sizeLBox.bottom-tempGBox.yB;

            (* align to grid *)
            scrpTL := thisGBox.topLeft;
            AddPt2D(this2D,scrpTL);
            newTL := scrpTL;
            GridP2D(newTL);
            AddPt2D(newTL,this2D);
            SubPt2D(scrpTL,this2D);

            if traceCmd then
                Writeln('    GetPstLoc=',this2D.x:8:2,',',this2D.y:8:2);
        end; (* GetPstLoc *)

    (* ***************************************************************** *)

        procedure GetOLstGBox(lst: TObjPtr; VAR gBox: Rect2D);
        var thisG: Rect;
        begin
            thisG := nilRect;
            While lst<>NIL do begin
                If lst^.cSel=iSelNml then begin
                    GetGBox(lst,thisG);
                    lst := NIL;
                end else begin
                    lst := lst^.fLink;
                end;
            end;
            With thisG do begin
                SetRect2D(gBox,left,top,right,bottom);
            end;
        end; (* GetOLstGBox *)

    (* ***************************************************************** *)

        Function  ExpScpMem(hSiz,pSiz: LongInt): Boolean;
        var errNum: Integer;
        begin
            (* called from PasteCmd to check for enough memory *)
            ExpScpMem := FALSE;
            (* see if there is enough room *)
            if CkMemSize(iCItmPst,hSiz+pSiz) then begin
                (* see if we can expand heaps by pstSize *)
                ExpandMem(hSiz,pSiz,errNum);
                if errNum>0 then
                    GECmdAlert(errNum,iCItmPst)
                else
                    ExpScpMem := TRUE;
            end;
        end; (* ExpScpMem *)

    (* ***************************************************************** *)

    begin{PasteCmd}
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('PasteCmd.');
        {Get sLst state before it changes}
        sState := curDoc.sLst^^.sState;
        sStateOK := (sState=iSStPrt) OR (sState=iObjNil);

        scrapType := PeekGEScrap(pstBBox,hSiz,pSiz);
        if scrapType=scrapNil then
            GEAlert(iStopNil)
        else if NOT (scrapType in [scrapFE,scrapDwg]) then
            GEAlert(iStopSType)
        else if ExpScpMem(hSiz,pSiz) then begin
            (* finish pending lastOp *)
            CommitLastOp;
            if scrapType=scrapFE  then begin
                if NOT curDoc.fldSet then
                    TxtSelCmd(curDoc.align,TRUE);
                pstBBox := curDoc.txtObj^.bBox;
                SetLastOp(iOpTxt);
                if NOT TxtPaste then
                    GEAlert(iStopTSize);
                CkTxtBounds(iOpPstT);
                CkCaretLoc;
                ReShowUnion(curDoc.txtObj^.bBox,pstBBox);
                (* update sBBox *)
                curDoc.sLst^^.sBBox := curDoc.txtObj^.bBox;
                lastOp.nBox         := curDoc.txtObj^.bBox;
            end else begin
                SetCurProto(iObjNil,TRUE);
                ResetAutoDrw;
                ResetTxt;

                (* check limits of pstBBox wrt sizeLBox *)
                with sizeLBox do
                if  ((right-left)<(pstBBox.right-pstBBox.left)) OR
                    ((bottom-top)<(pstBBox.bottom-pstBBox.top)) then
                    { NOTE: should make the dwg bigger!! }
                    GEAlert(iStopPaste)
                (* do the paste *)
                else begin

                    CopySLst(curDoc.sLst,prPstLst); {Remember old sLst.}

                    {Determine paste location object to paste in front of}
                    With curDoc, oLst.lst do begin
                        If item=1 then               {Paste  (on Top) }
                            pstLcObj := lEnd
                        else if item=2 then begin    {Paste in Front}
                            If sLst^^.sCnt>0 then
                                pstLcObj := CurSelObj(sLst^^.sCnt)
                            else
                                pstLcObj := lEnd; {paste on top when nothing is
                                                    selected}
                        end else {item=3} begin           {Paste Behind}
                            If sLst^^.sCnt>0 then begin
                                pstLcObj := CurSelObj(1);
                                pstLcObj := pstLcObj^.bLink;
                            end else
                                pstLcObj := NIL;  {paste on bottom when nothing is
                                                    selected}
                        end;
                    end;

                    {Determine TxtToTxt vs. ObjToObj}
                    txtTTpFl := TRUE;
                    If pstLcObj<>NIL then
                        If pstLcObj^.oDat.kind=iObjText then
                            txtTTpFl := FALSE;            {objects out of place}

                    oldsBBox := curDoc.sLst^^.sBBox; {For GetPst2D}

                    (* disable autoDraw, turn off current selection *)
                    autoDrwFlag := FALSE;
                    HiliteSel(OFF);
                    MarkCSel(curDoc.sLst,iSelNil);

                    (* get the scrap data *)
                    scrapType := GetGEScrap(pstBBox);

                    {Add in out of place lst of objects}
                    If txtTTpFl then
                        TxtToTxt
                    else
                        ObjToObj;

                    MakeSLst;

                    (* get paste point2D offset *)
                    GetOLstGBox(curDoc.oLst.lst.lBeg,pstGBox);
                    GetPstLoc(pstBBox,pstGBox,pst2D);

                    (* offset the new selection to pastePt *)
                    for i := 1 to curDoc.sLst^^.sCnt do
                        OffsetObj(CurSelObj(i),pst2D.x,pst2D.y);
                    OffsetRect(pstBBox,Round(pst2D.x),Round(pst2D.y));

                    (* remember LastOp *)
                    If item=1 then
                        tempOp := iOpPstT
                    else if item=2 then
                        tempOp := iOpPstF
                    else
                        tempOp := iOpPstB;
                    SetLastOp(tempOp);

                    (* show and hilite new sel *)
                    GetSelRect(curDoc.sLst,pstBBox);
                    ReShow(pstBBox);

                    (* set up dupCtr *)
                    dupCtrFlag := ON;
                end;
            end;
        end;
    end; (* PasteCmd *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure DupCmd;
    var selRect: Rect;
        dupPt:   Point;
        thisSel: TSelPtr;
        nObj,tObj: TObjPtr;
        this2D:  Point2D;
        scrollFlag,dupHndFlag: Boolean;
        i: Integer;
        tSel: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then with dupSame2D do
            writeln('DupCmd(',dupCtrFlag,',',Round(x):4,Round(y):4,')');

        dupHndFlag := FALSE;
        If (curDoc.edtState=iObjPoly) OR (curDoc.edtState=iObjSPoly) then begin
            If curDoc.edtObj^.cSel=iSelEdt then begin
                dupHndFlag := TRUE;
                DupKnobCmd;
            end;
        end;
        If NOT dupHndFlag then begin
            ResetTxt;
            SetCurProto(iObjNil,TRUE);
            tSel := curDoc.sLst^^;
            if (tSel.sState=iObjNil) then
                GECmdAlert(iStopSel,iCItmDup)
            else if (tSel.sState=iSStGrp) OR (tSel.sState>iObjNil) then
                (* see if we can actually expand memory *)
                if ExpSLstMem(iCItmDup) then begin
                    (* unHiLite curSLst *)
                    autoDrwFlag := FALSE;
                    HiliteSel(OFF);
                    MarkCSel(curDoc.sLst,iSelNil);
                    if curDoc.edtState<>iObjNil then begin
                        if curDoc.edtStart then begin
                            GetBBox(curDoc.edtObj);
                            ReShow(curDoc.edtObj^.bBox);
                        end;
                        curDoc.edtObj := NIL;
                        curDoc.edtState := iObjNil;
                        curDoc.edtStart := FALSE;
                    end;

                    CommitLastOp;

                    (* get dup offset *)
                    if dupCtrFlag then begin
                        this2D := dupSame2D;
                        {if (Abs(dupSame2D.x)>=1.0) <> (Abs(dupSame2D.y)>=1.0) then
                            this2D := dupSame2D
                        else
                            this2D := dup2D;}
                    end else begin
                        if curDoc.atr.grdOn then
                            dup2D := curDoc.atr.grdSz2D
                        else
                            SetPt2D(dup2D,dxDup,dyDup);
                        if tSel.sState=iObjRLin then begin
                            tObj := CurSelObj(1);
                            with tObj^.oDat do begin
                                if p1.x=p2.x then
                                    dup2D.y := 0.0
                                else
                                    dup2D.x := 0.0;
                            end;
                        end;
                        this2D := dup2D;
                    end;
                    (* constrain dup offset to be within sizeLBox *)
                    WldToScrn(this2D,dupPt);
                    OffsetRect(tSel.sBBox,dupPt.h,dupPt.v);
                    if tSel.sBBox.left<sizeLBox.left then
                        this2D.x := dxDup
                    else if tSel.sBBox.right>sizeLBox.right then
                        this2D.x := -dxDup;
                    if tSel.sBBox.top<sizeLBox.top then
                        this2D.y := dyDup
                    else if tSel.sBBox.bottom>sizeLBox.bottom then
                        this2D.y := -dyDup;
                    (* remember dup2D *)
                    dup2D      := this2D;
                    dupSame2D  := this2D;

                    (* duplicate each sel, one at a time so don't double *)
                    (* amount of dynamically allocated TSelRecs *)
                    (* assume no pending LastOp *)
                    CopySLst(curDoc.sLst,prPstLst);
                    MarkPSel(prPstLst,iSelNil);
                    for i := 1 to tSel.sCnt do begin
                        tObj := CurSelObj(i);
                        (* get new obj, add to curSLst *)
                        DupObj(tObj,nObj);
                        nObj^.oDat.locked := 0;  {Allow locked objs to be duplicated.}
                        OffsetObj(nObj,this2D.x,this2D.y);
                        nObj^.cSel := iSelNml;
                        {AddToOEnd(curDoc.oLst,nObj);}
                        InsertFt(nObj,tObj);
                    end;

                    (* hiLite new sel *)
                    MakeSLst;
                    SetLastOp(iOpDup);
                    CopySLst(curDoc.sLst,lastOp.pSLst);
                    GetSelRect(curDoc.sLst,selRect);
                    CkObjVis(anyObj,scrollFlag);
                    if NOT scrollFlag then
                        ShowRFrom(selRect,CurSelObj(1));
                    (* set up dupCtr *)
                    dupCtrFlag := ON;
                end;
        end;
    end; (* DupCmd *)

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure SelAllCmd;
    var obj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetCurProto(iObjNil,TRUE);
        (* Reset Ops in Progress *);
        ResetEdit;
        ResetCurSel;
        ResetAutoDrw;
        (* select everything *)
        ResetOLst(iLDirFwd,obj);
        while obj <> NIL do begin
            AddToSEnd(curDoc.sLst,obj);
            GetNxtObj(iLDirFwd,obj);
        end;
        MarkCSel(curDoc.sLst,iSelNml);
        HiliteSel(ON );
    end; (* SelAllCmd *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure ClearCmd;
    var thisRect: Rect;
        sState: Integer;
        clearHndFlag: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('ClearCmd');
        clearHndFlag := FALSE;
        If (curDoc.edtState=iObjPoly) OR (curDoc.edtState=iObjSPoly) then begin
            If curDoc.edtObj^.cSel=iSelEdt then begin
                clearHndFlag := TRUE;
                DeleteKnobCmd;
            end;
        end;
        If NOT clearHndFlag then begin
            sState := curDoc.sLst^^.sState;
            if (sState=iObjNil) then
                GECmdAlert(iStopSel,iCItmClr)
            else if (sState=iSStGrp) OR (sState>iObjNil) then begin
                if SLstNotLocked then begin
                    CheckVis(anyObj);

                    (* remember selRect *)
                    GetSelRect(curDoc.sLst,thisRect);

                    (* Reset Ops in Progress *);
                    ResetEdit;
                    ResetPoly;
                    ResetAutoDrw;
                    ResetTxt;

                    CommitLastOp;

                    (* remember lastOp *)
                    SetLastOp(iOpClr);
                    dupCtrFlag := OFF;
                    (* redraw *)
                    ReShow(thisRect);

                    (* remember center of selection as pastePt *)
                    pasteState := TRUE;
                    with thisRect do
                        SetPt(pastePt,(left+right) div 2, (top+bottom) div 2);
                end;
            end;
        end;
    end; (* ClearCmd *)

(* ********************************************************************* *)

(*$S Arrange*)
    procedure RotateCmd(* item: Integer *);
    var tSel: TSelLst;
        r: Rect;
        ctr2D: Point2D;
        tBox: Rect;
        size: Point;
        offset2D: Point2D;
        amount: Integer;
        tObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('RotateCmd(',item,')');

        (* item can be 1,2,3,4:
                1 = Rotate Left  => 270 degrees
                2 = Rotate Right =>  90 degrees
                3 = Flip Horizontal
                4 = Flip Hertical
        *)

        tSel := curDoc.sLst^^;
        if (tSel.sState=iSStGrp) OR (tSel.sState>iObjNil) then
            if SLstNotLocked then begin
                ResetTxt;
                ResetEd1;
                ResetPoly;
                ResetAutoDrw;
                CommitLastOp;

                (* map the item to rotation amount *)
                amount := mapMToRot[item];

                { figure out where to put the center }
                tBox := tSel.sBBox;
                if tSel.sState=iObjText then begin
                    tObj := CurSelObj(1);
                    ctr2D := tObj^.oDat.tLoc;
                    aspRatio := 1.0;
                end else begin
                    RectCtr2D(tBox,ctr2D);
                    GridP2D(ctr2D);
                end;
                RotateBox(tBox,ctr2D,amount);
                aspRatio := cScreenRatio;
                { make sure the rotated selection doesn't go off edge of paper }
                grid2D := curDoc.atr.grdSz2D;
                SetPt2D(offset2D,0,0);
                if tBox.left<0 then
                    offset2D.x := -tBox.left+grid2D.x
                else if tBox.right>sizeLBox.right then
                    offset2D.x := sizeLBox.right-tBox.right-grid2D.x;
                if tBox.top<0 then
                    offset2D.y := -tBox.top+grid2D.y
                else if tBox.bottom>sizeLBox.bottom then
                    offset2D.y := sizeLBox.bottom-tBox.bottom-grid2D.y;
                AddPt2D(offset2D,ctr2D);
                GridP2D(ctr2D);

                (* see if the rotated objects will fit in dwg *)
                size := tBox.botRight;
                SubPt(tBox.topLeft,size);
                if (size.h>cHDwgMax) or (size.v>cVDwgMax) then
                    GEAlert(iStopRSize)
                (* see if enough memory to handle largest trfo obj *)
                else if ExpTrfoMem(iCItmRot) then begin
                    if (size.h>curDoc.atr.dwgSz.h) OR (size.v>curDoc.atr.dwgSz.v) then begin
                        { make the drawing size bigger }
                    end;


                    With lastOp do begin
                        iDat1 := amount;
                        rDat3 := ctr2D.x;
                        rDat4 := ctr2D.y;
                    end;
                    SetLastOp(iOpRot);
                    If tSel.sState=iObjText then  curDoc.fldSet := FALSE;
                    SetWrkOrigin;
                    UnionRect(tSel.sBBox,curDoc.sLst^^.sBBox,tSel.sBBox);
                    ReShowInset(tSel.sBBox);
                end;
            end else
                GEAlert(iStopLock);
    end; (* RotateCmd *)

(* ********************************************************************* *)

(*$S Reshape*)
    procedure  ResetVrtLst(vrtLst: THndVrtLst);
    Var i: Integer;
        edtObj,trfoObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        If (curDoc.edtState=iObjPoly) OR (curDoc.edtState=iObjSPoly) then begin
            edtObj := CurSelObj(1);
            trfoObj := CkObjTrfo(edtObj);
            With vrtLst^^ do begin
                vCnt := trfoObj^.oDat.cLst^^.crdCnt;
                For i := 0 to maxNumP1 do
                    vertex[i] := -1;
            end;
        end;
    end;{ResetVrtLst}

(* ********************************************************************* *)

(*$S Reshape*)
    procedure ReshapeCmd;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.edtState=iObjNil then begin
            SetCurProto(iObjNil,TRUE);
            if curDoc.sLst^^.sState in [iObjArc,iObjPoly,iObjSPoly,iObjFHnd] then
                if SLstNotLocked then begin
                    ResetPoly;
                    ResetAutoDrw;
                    {XXX 6/15/83 go ahead and CommitLastOp so don't have
                     to worry about CkObjTrfo}
                    CommitLastOp;
                    CheckVis([iObjArc,iObjPoly,iObjSPoly,iObjFHnd]);
                    curDoc.edtObj    := CurSelObj(1);
                    curDoc.edtState  := curDoc.edtObj^.oDat.kind;
                    curDoc.edtStart  := FALSE;

                    HiLiteObj(curDoc.edtObj,OFF);
                    ResetVrtLst(curVrtLst);
                    curDoc.edtObj^.cSel := iSelEdt;
                    HiLiteObj(curDoc.edtObj,ON);
                end;
        end;
    end; (* ReshapeCmd; *)

(* ********************************************************************* *)

(*$S Reshape*)
    procedure SmoothCmd(* item: Integer *);
    var iOp: Integer;
        thisSel: TSelPtr;
        notLocked: Boolean;
        haveObj: Boolean;
        objKind: TObjSet;
        smoothOp: Boolean;
        tSel: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* item ranges from 1 to 2: 1=Smooth, 2=UnSmooth *)
        smoothOp := item=1;
        (* Reset Ops in Progress *);
        RestartEdit;
        ResetPoly;
        ResetAutoDrw;
        haveObj := ObjInSLst(iObjFHnd,notLocked);
        If haveObj then ResetEdit;
        objKind := [iObjFHnd];
        if smoothOp then begin
            If NOT (haveObj AND notLocked) then begin
                haveObj := ObjInSLst(iObjPoly,notLocked);
                objKind := [iObjPoly];
            end;
        end else begin
            if NOT (haveObj AND notLocked) then begin
                haveObj := ObjInSLst(iObjSPoly,notLocked);
                objKind := [iObjSPoly];
            end;
        end;
        If haveObj then
            If notLocked then begin
                CheckVis(objKind);
                CommitLastOp;
                tSel := curDoc.sLst^^;
                If smoothOp then begin
                    iOp := iOpSmo;
                    If NOT (curDoc.sLst^^.sState=iSStGrp) then
                        curDoc.sLst^^.sState := iObjSPoly;
                end else begin
                    iOp := iOpUnS;
                    If NOT (curDoc.sLst^^.sState=iSStGrp) then
                        curDoc.sLst^^.sState := iObjPoly;
                end;
                SetLastOp(iOp);
                ReShowUnion(tSel.sBBox,curDoc.sLst^^.sBBox);
            end else
                GEAlert(iStopLock);
    end; (* SmoothCmd *)

(* ************************************************************************* *)

(*$S Reshape*)
    procedure GetCntRmd(Var count,remainder,total: Integer);
    Var i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        count := 0; {Initialize}
        With curVrtLst^^ do begin
            For i := 0 to vCnt do begin
                If vertex[i]=1 then count := count + 1;
            end;
            remainder := vCnt - count;
            total := vCnt + count;
        end;
    end;{GetCntRmd}

(* ************************************************************************* *)

(*$S Reshape*)
    procedure DupKnobCmd;
    Var count,remainder,total: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('DupKnobCmd');
        GetCntRmd(count,remainder,total);
        If count=0 then begin
            GECmdAlert(iStopSel,iCItmAKnob); {Duplicate handles}
        end else if total>maxCrdCnt then begin
            GEAlert(iStopAHnd);   { Const iStopAHnd = 319}
                               { You cannot add this many handles to this object.}
        end else begin
            CheckVis(anyObj);
            {HiliteSel(OFF); I don't think that this is needed}
            CommitLastOp;
            SetLastOp(iOpAKnob);  {index of Operation Add Knobs}
            ResetVrtLst(curVrtLst);
            RSSel(FALSE); {ReShowSel with hilite off}
            HiliteVrtSel(TRUE,FALSE);
        end;
    end; (* DupKnobCmd *)

(* ************************************************************************* *)

(*$S Reshape*)
    procedure DeleteKnobCmd;
    Var count,remainder,total: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GetCntRmd(count,remainder,total);
        If remainder<2 then begin
            {Put up warning that you cannot remove this many handles}
            GEAlert(iStopSHnd);    {Const iStopSHnd = 318}
                                {You must leave at least three handes.}
        end else if count=0 then begin
            GECmdAlert(iStopSel,iCItmSKnob); {Delete handles}
        end else begin
            CheckVis(anyObj);
            {HiliteVrtSel(TRUE); I don't think that this is needed}
            CommitLastOp;
            SetLastOp(iOpSKnob);  {index of Operation Subtract Knobs}
            ResetVrtLst(curVrtLst);
            RSSel(FALSE); {ReShowSel with hilite off}
            HiliteVrtSel(TRUE,FALSE);
        end;
    end;{DeleteKnobCmd}

(* ********************************************************************* *)

(*$S Reshape*)
    procedure RndCmd(* doItFlag: Boolean *);
    var rIndex,doRects: Integer;
        form: TCkFormHnd;
        tSel: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('RndCmd(',doitFlag,')');

        form := geRndForm;
        if doItFlag then begin
            (* get new rnd index *)
            form := Pointer(Ord(theDBox.inData));
            (*$R-*)
            rIndex := form^^.ckBoxLst[1]^^.curCkItm-1;
            doRects := form^^.ckBoxLst[2]^^.curCkItm;
            (*$IfC rangeOn *)
            (*$R+*)
            (*$EndC *)

            SetPort(curDoc.fldr);
            (* command applies to proto *)
            tSel := curDoc.sLst^^;
            if tSel.sState=iSStPrt then
                curDoc.rndR := rIndex
            (* command applies to selection *)
            else if tSel.sState<>iObjNil then
                if SLstNotLocked then begin
                    CommitLastOp;
                    (* see if enough memory to handle largest trfo obj *)
                    if ExpMiscMem(iCItmRnd,0,40) then begin
                        With lastOp do begin
                            iDat1 := rIndex;
                            iDat2 := doRects;
                        end;
                        SetLastOp(iOpRnd);
                        SetWrkOrigin;
                        GEMapRect(tSel.sBBox);
                        InvalRect(tSel.sBBox);
                    end;
                end;
        end;
        (* restore screen *)
        ClearDBox;
        SetStdCursor(iCrsEscape);
        SetStdCursor(iCrsInactive);
    end; (* RndCmd *)

(*$I ApLd/CM1.text *)

END. (* unit *)

