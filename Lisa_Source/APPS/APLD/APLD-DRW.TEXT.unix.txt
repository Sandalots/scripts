(* ********************************************************************* *)

(* CopyRight 1983,1984  Apple Computer Inc. *)
(* GE Drawing Routines *)

(* ********************************************************************* *)

UNIT Drw;

(* Segment DRW *)
INTERFACE
USES
    (*$U UNITSTD*)     UnitStd,        (* interface dependency  *)
    (*$U UNITHZ*)      UnitHz,
    (*$U STORAGE*)     Storage,
    (*$U QUICKDRAW*)   QuickDraw,
    (*$U FONTMGR*)     FontMgr,
    (*$U LibOS/Syscall *)    Syscall,
    {$U LibPm/PmDecL}      PmDecL,
    {$U PrStdInfo}     PrStdInfo,
    {$U PrPublic}      PrPublic,
    (*$U ApLd/HDR*)    Hdr,

    {$IFC sampcalls}
    {$U apld/tracecalls.obj}  tracecalls,
    {$ENDC}
                                      (* used only for ElapsTime *)
    (*$U WM.EVENTS*)   Events,

    (*$U GRAFUTIL*)    GrafUtil,       (* implementation units  *)
    (*$U ApLd/UTL*)    Utl,
    (*$U ApLd/TXT*)    Txt,
    (*$U ApLd/DAT*)    Dat;

Const
    sPolySize = 6530;
    cPicBSPoly  = 105;
    cPicCSPoly  = 106;
    cPicESPoly  = 107;
    cPicFgClr   = 108;
    cPicBgClr   = 109;

var
    polyObj:    TObjPtr;
    polyStart:  Boolean;
    polyOSet:   Point;
    polyPen:    PenState;
    drwMnuFlag: Boolean;


    (* misc *)
    procedure GEMove  (pt: Point);
    procedure GELine  (pt: Point);
    procedure GEMoveTo(pt: Point);
    procedure GELineTo(pt: Point);

    (* objects  *)
    procedure Smooth(polyObj: TObjPtr;Var smoothPoly:PolyHandle;
                      zoomFlag,needPrep:Boolean);
    procedure DrwLine (begPt,endPt: Point; pnSiz,oldPn,arrows: Integer);
    procedure DrwCLst (cLst: TCLstHnd);
    procedure DrwObj  (obj: TObjPtr);
    procedure ShowObj (obj: TObjPtr);
    procedure EraseObj(obj: TObjPtr);
    procedure HiliteVrtSel(allVrt,switchFlag: Boolean);
    procedure HiLiteObj(obj: TObjPtr; sVal: Boolean);

    (* drawing aids *)
    procedure DrwTick(r: Rect);
    procedure DrwPgBreak(r: Rect);
    procedure XorKnob(where: Point);
    procedure DrwCaret(where: Point; bBox: Rect);

    (* misc  *)
    function  OkFillPoly(poly:PolyHandle):Boolean;
    procedure SetPenToObj(obj: TObjPtr);
    procedure DrwPLine(p1,p2: Point);
    procedure InitDrw;

(* ********************************************************************* *)

IMPLEMENTATION


(* ********************************************************************* *)
Type
    TPtrLInt = ^LongInt;
    THndLInt = ^TPtrLInt;

var (* world to screen translation vars *)
    (* caret vars *)
    caretBMp:   BitMap;
    caretBits:  Array[0..15] of Integer;
    caretHSpot: Point;
    (* pen pattern for grid *)
    tickPat1:   Pattern;
    tickPat2:   Pattern;
    pagePat:    Pattern;
    picComHnd:  THndLInt;

(* ********************************************************************* *)

(* objects *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GEMapSize(VAR siz: Point);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GEMapPt(siz);
        siz.h := CMax(siz.h,1);
        siz.v := CMax(siz.v,1);
    end; (* GEMapSize *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GEPenSize(pnSiz: Point);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GEMapSize(pnSiz);
        PenSize(pnSiz.h,pnSiz.v);
    end; (* GEPenSize *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GERndSize(dat: Integer; VAR rnd: Point);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        rnd := rndSizes[curDoc.atr.rlrUnit,dat];
        (* QD has a bug in the oval/arc/roundrect algorithm that
           makes gaps/thick lines when aspect ratio approaches
           boundary conditions, e.g. h=1, v>1, etc. due to working
           with squared numbers.  Workaround is to detect (1,n>1)
           corner radii and force to (1,1)
        *)
        if (rnd.h=1) or (rnd.v=1) then
            SetPt(rnd,1,1);
        GEMapSize(rnd);
    end; (* GERndSize *)

(* ********************************************************************* *)
(*$S Reshape*)
    procedure GEMove(* pt: Point *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GEMapPt(pt);
        Move(pt.h,pt.v);
    end; (* GEMove *)

(* ********************************************************************* *)
(*$S Reshape*)
    procedure GELine(* pt: Point *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GEMapPt(pt);
        Line(pt.h,pt.v);
    end; (* GELine *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GEMoveTo(* pt: Point *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GEMapPt(pt);
        MoveTo(pt.h,pt.v);
    end; (* GEMoveTo *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GELineTo(* pt: Point *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GEMapPt(pt);
        LineTo(pt.h,pt.v);
    end; (* GELineTo *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GetSKnob(where: Point; VAR r: Rect);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetRect(r,where.h-dhKnob,where.v-dvKnob,
                  where.h+dhKnob,where.v+dvKnob);
    end; (* GetSKnob *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwArrow(VAR begPt,endPt: Point; pnSiz,oldPn: Integer);
    const
        deltaArc = 24;
        arcAngle = 48;
    var
        aRect,sRect: Rect;
        ah,av: Integer;
        m,start: Integer;
        tempPt: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('DrwArrow(',begPt.h:2,',',begPt.v:2,',',
                                endPt.h:2,',',endPt.v:2,',',pnSiz:1);
        (* get arc rect *)
        if pnSiz=iPenVar then begin
            if oldPn=1 then
                av := 9
            else if oldPn=2 then
                av := 6
            else
                av := 4;
            ah := av*penSizes[iPenArw].h;
            av := av*penSizes[iPenArw].v;
            SetRect(aRect,-ah,-av,ah,av);
            OffsetRect(aRect,endPt.h,endPt.v);
        end else
            GetArrwRect(endPt,pnSiz,aRect);

        (* get arc angles relative to slope of line *)
        PtToAngle(aRect,begPt,m);
        start := m-deltaArc;

        (* draw the arrow as an arc *)
        sRect := aRect;
        If NOT DrwMnuFlag then GEMapRect(sRect);
        OffsetRect(sRect,1,0); {A pragmatic shift}
        PaintArc(sRect,start,arcAngle);

        (* get offset *)
        InsetRect(aRect,2,1);
        AngleToPt(aRect,m,endPt);
        endPt.h := endPt.h{-1};  {See if this fixes vertical arrows.}

        if traceCmd then begin
            Write('    PtToAngle(');
            wrtRect(aRect);
            Writeln(', ',begPt.h:2,',',begPt.v:2,', ',m:2);
        end;
    end; (* DrwArrow *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwLine(* begPt,endPt: Point; pnSiz,oldPn,arrows: Integer *);
    var pSiz,ePt,dist:  Point;
        aRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* draw arrows *)
        If pnSiz<>iPenVar then oldPn := pnSiz;
        if arrows<>0 then begin
            dist := endPt;
            SubPt(begPt,dist);
            (* don't draw arrow if bigger than length of line *)
            SetPt(ePt,0,0);
            GetArrwRect(ePt,oldPn,aRect);
            if (Abs(dist.h)>aRect.right)
            or (Abs(dist.v)>aRect.bottom) then begin
                ePt := endPt;
                DrwArrow(begPt,endPt,pnSiz,oldPn);
                if arrows=2 then
                    DrwArrow(ePt,begPt,pnSiz,oldPn);
            end;
        end;
        (* offset endpoints by pen size *)
        with penSizes[pnSiz] do
        SetPt(pSiz,h Div 2,v Div 2);
        SubPt(pSiz,begPt);
        SubPt(pSiz,endPt);
        (* draw the line *)
        If DrwMnuFlag then begin
            MoveTo(begPt.h,begPt.v);
            LineTo(endPt.h,endPt.v);
        end else begin
            GEMoveTo(begPt);
            GELineTo(endPt);
        end;
    end; (* DrwLine *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwGECLst(cLst: TCLstHnd; cancelFlag: Boolean);
    var i: integer;
        begPt,crdPt,halfPnSize: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* offset the start pt *)
        WldToScrn(cLst^^.beg2D,begPt);
        SetPt(halfPnSize,thePort^.pnSize.h Div 2,thePort^.pnSize.v Div 2);
        SubPt(halfPnSize,begPt);
        {begPt.h := begPt.h-(thePort^.pnSize.h Div 2);}
        {begPt.v := begPt.v-(thePort^.pnSize.v Div 2);}
        crdPt := begPt;
        (* draw the cLst *)
        GEMoveTo(begPt);
        With cLst^^ do begin
            For i := 1 to crdCnt do begin
                If crdKind=iObjFHnd then begin
                    GetNode(cLst,i,crdPt);
                end else begin
                    {$R-}
                    WldToScrn(c2DLst[i],crdPt);
                    {$IfC rangeOn} {$R+} {$EndC}
                    SubPt(halfPnSize,crdPt);
                end;
                GELineTo(crdPt);
                if cancelFlag then
                    Line(0,0);
            end;
            (* close the cLst *)
            if cLst^^.cClose=iCLstUsr then
                GELineTo(begPt);
            Line(0,0);
        end;
        If traceHeap then CkGEHz('DrwGECLst');
    end; (* DrwGECLst *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwCLst(* cLst: TCLstHnd *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* called in SEL to create a hittest region *)
        DrwGECLst(cLst,FALSE);
    end; (* DrwCLst *)

(* ********************************************************************* *)
(*$S PageLayout*)
    procedure OutLineTxt(obj: TObjPtr);
    var thisBBox: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        thisBBox := obj^.bBox;
        GEMapRect(thisBBox);
        if (thisBBox.bottom-thisBBox.top)<=1 then
            thisBBox.bottom := thisBBox.top+2;
        PenSize(1,1);
        PenPat(black);
        FrameRect(thisBBox);
    end;

(* ********************************************************************* *)
(*$S Core*)
    procedure Smooth(*polyObj: TObjPtr;Var smoothPoly:PolyHandle;
                      zoomFlag,needPrep:Boolean*);
                                     {Replace tempPt by a Quick Draw polygon
                                      rounded 4 times.}

    Const maxNumP2 = 102;
    Type
        TSpclInteger = record
                           case Integer of
                               1: (longInt1: LongInt);
                               2: (integer1,integer2: Integer);
                               3: (byte1,byte2,byte3,byte4: QDByte);
                       end;
       TSpclPoint = record
                        h: TSpclInteger;
                        v: TSpclInteger;
                    end;

    Var i,j,k,count,tempInt: Integer;
        pt,helpPt,delta,delta2: TSpclPoint;
        tempPt: Array[0..maxNumP2] of Point;
        zoomOn: Boolean;
        thisPt: Point;
        halfPnSize: Point;

    procedure GetGdPt;
    begin
        {pt2D := beg2D + c2DLst[1]*(17/32);}
        helpPt.h.longInt1 := tempPt[1].h - tempPt[0].h;
        pt.h.longInt1 := helpPt.h.longInt1;
        pt.h.longInt1 := pt.h.longInt1 * 256;
        pt.h.longInt1 := pt.h.longInt1 * 128;
        helpPt.h.longInt1 := helpPt.h.longInt1*64;
        helpPt.h.longInt1 := helpPt.h.longInt1*32;
        pt.h.longInt1 := pt.h.longInt1 + helpPt.h.longInt1;
        pt.h.integer1 := pt.h.integer1 + tempPt[0].h;

        helpPt.v.longInt1 := tempPt[1].v - tempPt[0].v;
        pt.v.longInt1 := helpPt.v.longInt1;
        pt.v.longInt1 := pt.v.longInt1 * 256;
        pt.v.longInt1 := pt.v.longInt1 * 128;
        helpPt.v.longInt1 := helpPt.v.longInt1*64;
        helpPt.v.longInt1 := helpPt.v.longInt1*32;
        pt.v.longInt1 := pt.v.longInt1 + helpPt.v.longInt1;
        pt.v.integer1 := pt.v.integer1 + tempPt[0].v;

    end;{GetGdPt}

    begin{Smooth}
        {$IFC sampcalls} ALogCall; {$ENDC}
        zoomOn := (curDoc.atr.zoomOn<>0) AND zoomFlag;
        With smoothPoly^^,polyObj^,oDat.cLst^^ do begin
            (*$R-*)

            {thisPt.h := Round(c2DLst[0].x);
            thisPt.v := Round(c2DLst[0].y);
            thisPt.h := thisPt.h - (thePort^.pnSize.h Div 2);
            thisPt.v := thisPt.v - (thePort^.pnSize.v Div 2);
            tempPt[0] := thisPt;
            If zoomOn then
                GEMapPt(tempPt[0]);}

            If cClose = iCLstUsr then
                count := crdCnt+2
            else
                count := crdCnt;
            halfPnSize.h := thePort^.pnSize.h Div 2;
            halfPnSize.v := thePort^.pnSize.v Div 2;
            For i := 0 to count do begin
                tempPt[i].h := Round(c2DLst[i].x) - halfPnSize.h;
                tempPt[i].v := Round(c2DLst[i].y) - halfPnSize.v;
                If zoomOn then
                    GEMapPt(tempPt[i]);
            end;
            polyBBox := bBox; {could get a better box for hit testing}
            If zoomOn then
                GEMapRect(polyBBox);
            k := 0;
            If cClose<> iCLstUsr then begin

                If needPrep then begin
                    tempInt := tempPt[0].h;
                    tempPt[0].h := tempInt + tempInt - tempPt[1].h;

                    tempInt := tempPt[0].v;
                    tempPt[0].v := tempInt + tempInt - tempPt[1].v;

                    tempInt := tempPt[crdCnt].h;
                    tempPt[crdCnt].h := tempInt + tempInt - tempPt[crdCnt-1].h;

                    tempInt := tempPt[crdCnt].v;
                    tempPt[crdCnt].v := tempInt + tempInt - tempPt[crdCnt-1].v;
                end;

                {polyPoint[0] := (tempPt[0] + tempPt[1])/2}
                helpPt.h.longInt1 := tempPt[0].h + tempPt[1].h;
                helpPt.h.longInt1 := helpPt.h.longInt1*256;
                helpPt.h.longInt1 := helpPt.h.longInt1*128;
                polyPoints[0].h := helpPt.h.integer1;

                helpPt.v.longInt1 := tempPt[0].v + tempPt[1].v;
                helpPt.v.longInt1 := helpPt.v.longInt1*256;
                helpPt.v.longInt1 := helpPt.v.longInt1*128;
                polyPoints[0].v := helpPt.v.integer1;

                GetGdPt;
                k :=  k + 1;
                polyPoints[k].h := pt.h.integer1;
                polyPoints[k].v := pt.v.integer1;
                count := crdCnt-1;
            end else if cClose=iCLstUsr then begin
                GetGdPt;
                polyPoints[0].h := pt.h.integer1;
                polyPoints[0].v := pt.v.integer1;
                count := crdCnt+1;
            end;
            delta.h.longInt1 := tempPt[1].h - tempPt[0].h;
            delta.h.longInt1 := delta.h.longInt1*64;
            delta.h.longInt1 := delta.h.longInt1*64;

            delta.v.longInt1 := tempPt[1].v - tempPt[0].v;
            delta.v.longInt1 := delta.v.longInt1*64;
            delta.v.longInt1 := delta.v.longInt1*64;

            For i := 1 to count do begin
                tempInt := tempPt[i].h;

                delta2.h.longInt1 := (tempPt[i+1].h - tempInt) -
                             (tempInt-tempPt[i-1].h);

                {delta2.h.longInt1 := delta2.h.longInt1*2^8;}
                delta2.h.longInt1 := delta2.h.longInt1*256;
                {delta2.h.byte1 := delta2.h.byte2;
                delta2.h.byte2 := delta2.h.byte3;
                delta2.h.byte3 := delta2.h.byte4;
                delta2.h.byte4 := 0;}

                tempInt := tempPt[i].v;

                delta2.v.longInt1 := (tempPt[i+1].v - tempInt) -
                             (tempInt-tempPt[i-1].v);
                {delta2.v.longInt1 := delta2.v.longInt1*2^8;}
                delta2.v.longInt1 := delta2.v.longInt1*256;
                {delta2.v.byte1 := delta2.v.byte2;
                delta2.v.byte2 := delta2.v.byte3;
                delta2.v.byte3 := delta2.v.byte4;
                delta2.v.byte4 := 0;}
                For j := 1 to 16 do begin
                    delta.h.longInt1 := delta.h.longInt1 + delta2.h.longInt1;
                    delta.v.longInt1 := delta.v.longInt1 + delta2.v.longInt1;

                    pt.h.longInt1 := pt.h.longInt1 + delta.h.longInt1;
                    pt.v.longInt1 := pt.v.longInt1 + delta.v.longInt1;

                    k :=  k + 1;
                    polyPoints[k].h := pt.h.integer1;
                    polyPoints[k].v := pt.v.integer1;
                end;{j}
            end;{i}
            polysize := 14 + 4*k; {The first point is polyPoints[0]}
            If cClose<>iCLstUsr then begin
                pt.h.longInt1 := pt.h.longInt1 - (delta.h.longInt1 DIV 2);
                pt.v.longInt1 := pt.v.longInt1 - (delta.v.longInt1 DIV 2);
                polyPoints[k].h := pt.h.integer1;
                polyPoints[k].v := pt.v.integer1;
            end;

            (*$IfC rangeOn *) (*$R+*) (*$EndC*)
        end;
    end;{Smooth}

(* ********************************************************************* *)
(*$S Core*)
    procedure DrawSPoly(sPolyObj: TObjPtr);
    Var thisPoly: PolyHandle;
        count,j: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        {Allocate room for thisPoly}
        thisPoly := Pointer(ord(HAllocate(geHHz,sPolySize)));

        Smooth(sPolyObj,thisPoly,TRUE,TRUE);  {TRUE means zoomFlag is On}
                                              {Second TRUE mean needPrep}
        With sPolyObj^.oDat.inf do begin
            If pnPat<>iPenClear then begin
                {FramePoly(thisPoly);}
                With thisPoly^^ do begin
                    MoveTo(polyPoints[0].h,polyPoints[0].v);
                    count := (polySize - 14) Div 4;
                    For j := 1 to count do begin
                        {$R-}
                        LineTo(polyPoints[j].h,polyPoints[j].v);
                        {$IfC rangeOn} {$R+} {$EndC}
                        Line(0,0);
                    end;
                end;
            end;
        end;

        {Deallocate room for thisPoly}
        FreeH(geHHz,Pointer(ord(thisPoly)));
    end;{DrawSPoly}

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwGEObj(obj: TObjPtr);
    var grpObj: TObjPtr;
        drwRect: Rect;
        tp1,tp2,rnd: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat,inf do begin
            Case kind of
                iObjRLin,iObjSLin:
                    begin
                        WldToScrn(p1,tp1);
                        WldToScrn(p2,tp2);
                        DrwLine(tp1,tp2,pnSiz,flPat,dat);
                    end;
                iObjArc:
                    with arc^^ do begin
                        GetDrwRect(aR2D,pnSiz,drwRect);
                        FrameArc(drwRect,aStart,aAngle);
                    end;
                iObjRect,iObjRndR,iObjOval:
                    begin
                        GetDrwRect(r2D,inf.pnSiz,drwRect);
                        if kind=iObjRect then
                            FrameRect(drwRect)
                        else if kind=iObjRndR then begin
                            GERndSize(inf.dat,rnd);
                            If (rnd.h<=1) OR (rnd.v<=1)  then
                                FrameRect(drwRect)
                            else
                                FrameRoundRect(drwRect,rnd.h,rnd.v);
                        end else
                            FrameOval(drwRect);
                    end;
                iObjFHnd,iObjPoly:
                    DrwGECLst(cLst,TRUE);
                iObjSPoly:
                    DrawSPoly(obj);
                iObjText:
                    if curDoc.atr.zoomOn<>0 then
                        OutlineTxt(obj)
                    else
                        TxtDraw(obj);
                iObjGroup:
                    begin
                        grpObj := grp.lBeg;
                        while grpObj<>NIL do begin
                            DrwObj(grpObj);
                            grpObj := grpObj^.fLink;
                        end;
                    end;
            end; (* case *)
        end;
    end; (* DrwGEObj *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwObj(* obj: TObjPtr *);
    var grpObj: TObjPtr;
        drwRect: Rect;
        tp1,tp2: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('DrwObj(',Ord(obj):8,',',obj^.oDat.kind:2,')');


        penPats[iPenWhite] := black;
        SetPenToObj(obj);
        DrwGEObj(obj);
        penPats[iPenWhite] := white;
        ForeColor(blackColor);
        BackColor(whiteColor);
    end; (* DrwObj *)

(* ********************************************************************* *)
(*$S Core*)
    procedure FillObj(obj: TObjPtr;fPattern: Pattern);
    var drwRect: Rect;
        rnd: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do
        if inf.flPat<>iFillClear then begin
            case kind of
                iObjRect,iObjRndR,iObjOval:
                    begin
                        GetDrwRect(r2D,inf.pnSiz,drwRect);
                        if kind=iObjRect then
                            FillRect(drwRect,fPattern)
                        else if kind=iObjRndR then begin
                            GERndSize(inf.dat,rnd);
                            If (rnd.h<=1) OR (rnd.v<=1)  then
                                FillRect(drwRect,fPattern)
                            else
                                FillRoundRect(drwRect,rnd.h,rnd.v,fPattern);
                        end else
                            FillOval(drwRect,fPattern);
                    end;
                iObjArc:
                    with obj^.oDat.arc^^ do begin
                        GetDrwRect(aR2D,inf.pnSiz,drwRect);
                        FillArc(drwRect,aStart,aAngle,fPattern);
                    end;
            end; (* case *)
        end;
    end; (* FillObj *)
(* ********************************************************************* *)
(*$S Core*)
    function OkFillPoly(*poly:PolyHandle*);
    Var
        i,polyCnt,a,b,min: Integer;
        pt,lastPt: Point;
        iPts: LongInt;
    begin
        { check to see how much memory is required to fill the poly }
        polyCnt := (poly^^.polySize - 10) DIV 4;
        iPts := 0;
        { count the number of inversion points }
        With poly^^ do begin
            lastPt := polyPoints[0];
            {$R-}
            For i := 1 to polyCnt-1 do begin
                pt := polyPoints[i];
                SubPt(pt,lastPt);
                a := ABS(lastPt.h);
                b := ABS(lastPt.v);
                If a<b then
                    min := a
                else
                    min := b;
                iPts := iPts + min + 1;
                lastPt := pt;
            end;
            {$IfC rangeOn} {$R+} {$EndC}
        end;
        { 2 inversion pts per jaggie, 4 bytes per point 32K limit 100 bytes slop}
        If 8*iPts<22000 then  {A pragmatic number<32K that worked}
            OkFillPoly := TRUE
        else
            OkFillPoly := FALSE;
    end;{OkFillPoly}

(* ********************************************************************* *)

(*$S Core*)
    procedure GEFillPoly(poly:PolyHandle; pat: Pattern);
    begin
        If OkFillPoly(poly) then
            FillPoly(poly,pat);
    end;{GEFillPoly}

(* ********************************************************************* *)
(*$S Core*)
    procedure ShowCLst(pnPat,flPat: Integer; cLst: TCLstHnd;fPattern: Pattern);
    var thisPoly: PolyHandle;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        thisPoly := OpenPoly;
        DrwGECLst(cLst,FALSE);
        ClosePoly;
        If flPat<>iFillClear then GEFillPoly(thisPoly,fPattern);
        If pnPat<>iPenClear then FramePoly(thisPoly);
        KillPoly(thisPoly);
    end; (* ShowCLst *)



(* **************************************************************************** *)
(*$S Core*)
procedure ShowSPoly(sPolyObj: TObjPtr; fPattern: Pattern);
Var thisPoly: PolyHandle;
    objSize,cLstSize: Integer;
    thisHnd: ^TObjPtr;
begin
    {$IFC sampcalls} ALogCall; {$ENDC}
    {Allocate room for thisPoly}
    thisPoly := Pointer(ord(HAllocate(geHHz,sPolySize)));
    Smooth(sPolyObj,thisPoly,TRUE,TRUE);
    If makingScpPic then begin
        cLstSize := SizeOfCLst(sPolyObj^.oDat.cLst);
        PicComment(cPicCSPoly,cLstSize,Pointer(Ord(sPolyObj^.oDat.cLst)));
        objSize := SizeOf(TObjRec);
        thisHnd := Pointer(Ord(HAllocate(curDoc.hHz,objSize)));
        thisHnd^^ := sPolyObj^;
        PicComment(cPicBSPoly,objSize,Pointer(Ord(thisHnd)));
        FreeH(curDoc.hHz,Pointer(Ord(thisHnd)));
    end;
    With sPolyObj^.oDat.inf do begin
        If flPat<>iFillClear then
            GEFillPoly(thisPoly,fPattern);
        If pnPat<>iPenClear then
            FramePoly(thisPoly);
    end;
    PicComment(cPicESPoly,0,NIL);
    {Deallocate room for thisPoly}
    FreeH(geHHz,Pointer(Ord(thisPoly)));
end;{ShowSPoly}

(* ********************************************************************* *)
(*$S Core*)
    procedure ShowObj(* obj: TObjPtr *);
    var savePen: PenState;
        grpObj: TObjPtr;
        fPattern: Pattern;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('ShowObj(',Ord(obj):8,')');

        (* set pen *)
        GetPenState(savePen);
        PenMode(patCopy);
        SetPenToObj(obj);

        (* show obj *)
        with obj^.oDat do begin
            If kind <> iObjGroup then
                If printing or (scpClrFl and scpShPat)
                    or((not scpClrFl) and curDoc.showPats)  then
                    fPattern := fillPats[inf.flPat]
                else fPattern := initPat[inf.bgClr];
            If kind=iObjText then begin
                if curDoc.atr.zoomOn<>0 then
                    OutlineTxt(obj)
                else
                    TxtShow(obj)
            end else if kind in [iObjPoly,iObjFHnd] then
                ShowCLst(inf.pnPat,inf.flPat,cLst,fPattern)
            else if kind=iObjSPoly then
                ShowSPoly(obj, fPattern)
            else if kind=iObjGroup then begin
                grpObj := grp.lBeg;
                while grpObj<>NIL do begin
                    ShowObj(grpObj);
                    grpObj := grpObj^.fLink;
                end;
            end else begin
                FillObj(obj, fPattern);
                If inf.pnPat<>iPenClear then
                    DrwGEObj(obj);
            end;
        end;

        (* restore pen *)
        SetPenState(savePen);
        ForeColor(blackColor);
        BackColor(whiteColor);
    end; (* ShowObj *)

(* ********************************************************************* *)
(*$S Core*)
    procedure EraseObj(* obj: TObjPtr *);
    var savePen: PenState;
        thisRect: Rect;
        i: Integer;
        knobs: TKnobs;
        knobSize: Point;

    (* ***************************************************************** *)

        procedure ErsKnob(pt: Point);
        var knobRect: Rect;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            GEMapPt(pt);
            GetSKnob(pt,knobRect);
            FillRect(knobRect,white);
        end; (* ErsKnob *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do
        if (kind=iObjSLin) and (inf.dat=0) then begin
            GetPenState(savePen);
            with penSizes[inf.pnSiz] do
            PenSize(h,v);
            PenPat(black);
            PenMode(patBic);
            DrwGEObj(obj);
            GetObjKnobs(obj,knobs);
            with knobs do
            for i := 1 to knobCnt do
                ErsKnob(knobInfo[i]);
            SetPenState(savePen);
        end else begin
            thisRect := bBox;
            if kind<>iObjText then
                InsetRect(thisRect,-zoomKnobSz.h,-zoomKnobSz.v)
            else if cSel=iSelEdt then
                TxtHiLite(OFF);
            GEMapRect(thisRect);
            FillRect(thisRect,white);
        end;
    end; (* EraseObj *)

(* ********************************************************************* *)
(*$S Core*)
    procedure HiLiteText(obj: TObjPtr; sVal: Boolean);
    var scrnPt: Point;
        thisBBox: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* hilite the text *)
        with obj^,oDat do
            if cSel=iSelEdt then
                TxtHiLite(sVal)
            else if cSel=iSelNml then
                if inf.tLen>0 then begin
                    thisBBox := bBox;
                    GEMapRect(thisBBox);
                    InvertRect(thisBBox);
                    (* only draw caret for non-rotated text *)
                    if inf.tDat<16 then
                        if curDoc.atr.zoomOn=0 then begin
                            GetTxtPt(inf.tDat,tloc,scrnPt);
                            DrwCaret(scrnPt,bBox);
                        end;
                end;
    end; (* HiLiteText *)
 (* ********************************************************************* *)

    function  CurSelObj(sIndx: Integer): TObjPtr;
    EXTERNAL; {in sel}

    function CkObjTrfo(obj: TObjPtr): TObjPtr;
    EXTERNAL; {in uop}


(* ********************************************************************* *)
(*$S Reshape*)
    procedure HiliteVrtSel(*allVrt,switchFlag: Boolean *);
    Var  i,a,b: Integer;
      knobRect: Rect;
      where,lastWhere:    Point;
      obj,trfoObj:      TObjPtr;
      savePnState: PenState;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GetPenState(savePnState);
        PenMode(patXor);
        PenPat(black);
        PenSize(1,1);
        obj := CurSelObj(1);
        trfoObj := CkObjTrfo(obj);

        SetPt(lastWhere,0,0);

        For i := 0 to curVrtLst^^.vCnt do begin
            With trfoObj^.oDat.cLst^^ do begin
                {$R-}
                WldToScrn(c2DLst[i],where);
                {$IfC rangeOn} {$R+} {$EndC}
                If where.h>0 then begin
                    GEMapPt(where);
                    GetSKnob(where,knobRect);
                    With curVrtLst^^ do begin
                        a := vertex[i];
                        If i>0 then begin
                            b := vertex[i-1];
                        end else begin
                            b := 0;
                        end;
                    end;
                    If (NOT EqualPt(where,lastWhere)) OR (a<>b) then begin
                        If a=1 then begin
                            If switchFlag then begin
                                InsetRect(knobRect,1,1);
                                PaintRect(knobRect);
                            end else begin
                                FrameRect(knobRect);
                            end;
                        end else if allVrt then begin
                            PaintRect(knobRect);
                        end;
                    end;
                    lastWhere := where;
                end;
            end;
        end;
        SetPenState(savePnState);
    end;{HiliteVrtSel}

(* ********************************************************************* *)
(*$S Reshape*)
    procedure HiLiteCLst(cLst: TCLstHnd);
    var knob: Integer;
        crdPt: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        If (curDoc.edtState=iObjPoly) OR (curDoc.edtState=iObjSPoly) then
            HiliteVrtSel(TRUE,FALSE)  {TRUE means allvrt,FALSE means
                                        don't switch}
        else     {iObjFHnd}
            for knob := 0 to cLst^^.crdCnt do begin
                GetNode(cLst,knob,crdPt);  { Ben: here he is converting to integers }
                XorKnob(crdPt);
            end;
    end; (* HiLiteCLst *)


(* ********************************************************************* *)
(*$S Core*)
    procedure HiLiteObj(* obj: TObjPtr; sVal: Boolean *);
    var knobs: TKnobs;
        i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then with obj^,oDat do
            writeln('    HiLiteObj(',Ord(obj):8,', kind=',kind:4,
                           ', cSel=',cSel:4,',',sVal,')');
        If (NOT (obj=polyObj)) OR polyStart then begin
            with obj^,oDat do
            if ((kind=iObjPoly) OR (kind=iObjFHnd) OR (kind=iObjSPoly))
                AND (cSel=iSelEdt) then
                HiLiteCLst(cLst)
            else if kind=iObjText then
                HiLiteText(obj,sVal)
            else begin
                GetObjKnobs(obj,knobs);
                with knobs do
                for i := 1 to knobCnt do
                    XorKnob(knobInfo[i]);
            end;
        end;
    end; (* HiLiteObj *)

(* ********************************************************************* *)

(* drawing aids *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwGrdLines(r:Rect; d2D: Point2D; zeroPt: Point);
    var i: Integer;
        tick2D,end2D: Point2D;
        tickPt,numLines: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* only draw grdLines that are more than 1/4" apart *)
        WldToScrn(d2D,tickPt);
        GEMapPt(tickPt);
        if tickPt.h>(xInchDots/4) then begin
            (* get starting and ending points of area to draw in *)
            ScrnToWld(r.topLeft,tick2D);
            ScrnToWld(r.botRight,end2D);
            (* get numLines to draw, add 2 to allow for roundoff errors *)
            SetPt(numLines,2+Round((end2D.x-tick2D.x)/d2D.x),
                           2+Round((end2D.y-tick2D.y)/d2D.y));
            (* get offset so line up with rlrZeroPt *)
            tickPt.h := zeroPt.h Div Round(d2D.x);
            tickPt.v := zeroPt.v Div Round(d2D.y);
            tickPt.h := zeroPt.h - tickPt.h*Round(d2D.x);
            tickPt.v := zeroPt.v - tickPt.v*Round(d2D.y);
            (* get start, either before or equal to start of r *)
            with tick2D do begin
                x := tickPt.h+Trunc(x/d2D.x)*d2D.x;
                y := tickPt.v+Trunc(y/d2D.y)*d2D.y;
            end;
            (* draw the lines *)
            GEMapRect(r);
            for i := 1 to CMax(numLines.h,numLines.v) do begin
                WldToScrn(tick2D,tickPt);
                GEMapPt(tickPt);
                MoveTo(r.left,tickPt.v);
                LineTo(r.right,tickPt.v);
                MoveTo(tickPt.h,r.top);
                LineTo(tickPt.h,r.bottom);
                AddPt2D(d2D,tick2D);
            end;
        end;
    end; (* DrwGrdLines *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwTick(* r: Rect *);
    var
        savePen: PenState;
        subTck2D: Point2D;
        zeroPt: Point;
        numDvs: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            WlnRect('DrwTick:',r);

        (* assume that we are already clipped to r, draw number
           of ticks that exactly fit in r plus two, starting at
           tick less than or equal to start of r to prevent too
           few lines being drawn due to roundoff errors.
        *)
        GetPenState(savePen);
        PenMode(patOr);
        PenPat(tickPat1);
        PenSize(1,1);
        (* tick lines *)
        with curDoc.atr,rlrFmts[rlrUnit,rlrKind] do begin
            zeroPt := rlrZero[rlrUnit,rlrKind];
            DrwGrdLines(r,tckSz2D,zeroPt);
            (* draw sub tick marks if major division spacing > one inch *)
            numDvs := rlrInfo[iDvs].dvs;
            if tckSz2D.x>=xInchDots then
                if (numDvs Mod 2)=0 then begin
                    SetPt2D(subTck2D,tckSz2D.x/2,tckSz2D.y/2);
                    if tckSz2D.x>=2*xInchDots then
                        if (numDvs Mod 4)=0 then
                            SetPt2D(subTck2D,tckSz2D.x/4,tckSz2D.y/4);
                    PenPat(tickPat2);
                    DrwGrdLines(r,subTck2D,zeroPt);
                end;
        end;
        SetPenState(savePen);
    end; (* DrwTick *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwPgBreak(* r: Rect *);
    var savePen: PenState;
        pgSz2D: Point2D;
        zeroPt,pnSiz: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            WlnRect('DrwPgBreak:',r);

        (* assume that we are already clipped to r, draw number *)
        (* of ticks that exactly fit in r plus two, starting at *)
        (* tick less than or equal to start of r to prevent too *)
        (* few lines being drawn due to roundoff errors.*)
        GetPenState(savePen);
        PenMode(patOr);
        PenPat(pagePat);
        SetPt(pnSiz,3,2);
        GEPenSize(pnSiz);
        (* page break lines *)
        with curDoc.atr do
        SetPt2D(pgSz2D,pageSz.h,pageSz.v);
        SetPt(zeroPt,0,0);
        DrwGrdLines(r,pgSz2D,zeroPt);
        SetPenState(savePen);
    end; (* DrwPgBreak *)

(* ********************************************************************* *)
(*$S Core*)
    procedure XorKnob(* where: Point *);
    var knobRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        {
        if traceTrk and traceCmd then
            Writeln('XorKnob:',where.h:1,',',where.v:1);
        }

        if where.h>0 then begin
            GEMapPt(where);
            GetSKnob(where,knobRect);
            InvertRect(knobRect);
        end;
    end; (* XorKnob *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwCaret(* where: Point; bBox: Rect *);
    var dstRect:   Rect;
        thisPort:  GrafPtr;
        saveClip: RgnHandle;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* we need to clip to the text bbox so that when we DrwCaret,
           it does not exceed *)
        saveClip := NewRgn;
        GetClip(saveClip);
        ClipRect(bBox);
        SectRgn(saveClip,thePort^.clipRgn,thePort^.clipRgn);
        (* set up dst rect *)
        SetRect(dstRect,0,0,16,16);
        with caretHSpot do
        OffSetRect(dstRect,where.h-h,where.v-v);
        (* blt bits *)
        GetPort(thisPort);
        with thisPort^ do
        CopyBits(caretBMp,portBits,caretBMp.Bounds,dstRect,srcXor,NIL);
        {REPLACING
         XferRect(caretBMp,portBits,caretBMp.Bounds,dstRect,srcXor,black);}
        (* restore clip *)
        SetClip(saveClip);
        DisposeRgn(saveClip);
    end; (* DrwCaret *)

(* ********************************************************************* *)

(* misc drawing routines *)

(* ********************************************************************* *)
(*$S Core*)
    procedure SetPenToObj(* obj: TObjPtr *);
    var pSiz: Point;

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^.oDat,inf do begin
            If printing then begin
                ForeColor(clrPrCod[inf.fgClr]);
                BackColor(clrPrCod[inf.bgClr]);
            end else begin
                ForeColor(blackColor);
                BackColor(whiteColor);
                If makingScpPic then begin
                    If inf.fgClr<iClrMix then begin
                        picComHnd^^ := clrPrCod[inf.fgClr];
                        PicComment(cPicFgClr,4,Pointer(Ord(picComHnd)));
                    end;
                    If inf.bgClr<iClrMix then begin
                        picComHnd^^ := clrPrCod[inf.bgClr];
                        PicComment(cPicBgClr,4,Pointer(Ord(picComHnd)));
                    end;
                end;
            end;
            if kind<>iObjText then begin
                GEPenSize(penSizes[inf.pnSiz]);
                {If printing then
                    If (kind=iObjRLin) OR (kind=iObjSLin) then
                        If NOT(pnPat=iPenBlack) then
                            If pnSiz=1 then
                                If curDoc.hPrRec^^.prInfo.hRes>140 then
                                    GEPenSize(penSizes[2]); Erric is making a
                                          better fix.}
                PenPat(penPats[inf.pnPat]);
            end;
        end;
    end; (* SetPenToObj *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure DrwPLine(* p1,p2: Point *);
    var thisPen: PenState;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* set all of pen except mode *)
        GetPenState(thisPen);
        SetPenState(polyPen);
        PenMode(thisPen.pnMode);
        (* offset the line by half penSize *)
        SubPt(polyOSet,p1);
        SubPt(polyOSet,p2);
        GEMoveTo(p1);
        GELineTo(p2);
        SetPenState(thisPen);
    end; (* DrwPLine *)

(* ********************************************************************* *)
(*$S Init*)

    procedure InitDrw;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('InitDrw');
        putScpFlag := FALSE;
        PenNormal;
        makingScpPic := FALSE;
        picComHnd := Pointer(Ord(HAllocate(geHHz,4)));
        StuffHex(@tickPat1,'8844221188442211');
        StuffHex(@tickPat2,'8040201008040201');
        StuffHex(@pagePat,'CC663399CC663399');
        (* set up caret bitMap *)
        with caretBMp do begin
            rowBytes := 2;
            SetRect(bounds,0,0,16,16);
            baseAddr := @caretBits;
        end;
        StuffHex(@caretBits[0],'000000000000000000000100038007C0');
        StuffHex(@caretBits[8],'0FE01FF03FF87FFCFFFE000000000000');
        setpt(caretHSpot,7,6);

        clrPrCod[1] :=  whiteColor;  {White}   {These are the printing codes}
        clrPrCod[2] :=  blackColor;  {Black}
        clrPrCod[3] :=  yellowColor;  {Yellow}
        clrPrCod[4] :=  greenColor;  {Green}
        clrPrCod[5] :=  redColor;  {Red}
        clrPrCod[6] :=  magentaColor;  {Manenta}
        clrPrCod[7] :=  blueColor;  {Blue}
        clrPrCod[8] :=  cyanColor;  {Cyan}
    end; (* InitDrw *)

END. (* unit *)


ÿ