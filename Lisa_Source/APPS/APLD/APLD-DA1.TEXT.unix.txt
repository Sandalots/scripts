(* ********************************************************************* *)

(* CopyRight 1983, Apple Computer Inc. *)
(* GE Unit DAT Include File: Obj Trafo Misc Routines  *)

(* ********************************************************************* *)

(* Object Transformations *)

(* ********************************************************************* *)



(*$S Reshape*)
    procedure SetObjRnd(* obj: TObjPtr; rnd: Integer *);
    var grpObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do
        if locked=0 then begin
            if kind=iObjGroup then begin
                grpObj := grp.lBeg;
                while grpObj<>NIL do begin
                    SetObjRnd(grpObj,rnd);
                    grpObj := grpObj^.fLink;
                end;
            end else if kind=iObjRndR then
                inf.dat := rnd;
        end;
    end; (* SetObjRnd *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure SetInf(* VAR inf: TObjInf; kind,size,pPat,fPat,pDat:Integer;
        frgdClr, bkgdClr: TPByte *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if fPat<>0 then
            inf.flPat := fPat
        else if bkgdClr<>0 then begin
            inf.bgClr := bkgdClr;
            If inf.flPat=iFillClear then
                inf.flPat := iFillWhite;
        end else if frgdClr<>0 then
            inf.fgClr := frgdClr
        else if kind<>iObjText then begin
            if size<>0 then
                inf.pnSiz := size
            else if pPat<>0 then
                inf.pnPat := pPat
            else if pDat<>0 then
                if kind in [iObjRLin,iObjSLin] then
                    inf.dat := pdat-1;
        end;
    end; (* SetInf *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure SetObjInf(* obj: TObjPtr; size,pPat,fPat,pDat:Integer;
        frgdClr, bkgdClr: TPByte *);
    var grpObj: TObjPtr;
        grpBBox: Rect;
        startFlag: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do
        if locked=0 then begin
            SetInf(inf,kind,size,pPat,fPat,pDat,frgdClr, bkgdClr);
            if kind=iObjGroup then begin
                startFlag := TRUE;
                grpObj := grp.lBeg;
                while grpObj <> NIL do begin
                SetObjInf(grpObj,size,pPat,fPat,pDat,frgdClr,bkgdClr);
                    if startFlag then  begin
                        grpBBox := grpObj^.bBox;
                        startFlag := FALSE;
                    end else
                        UnionRect(grpBBox,grpObj^.bBox,grpBBox);
                    grpObj := grpObj^.fLink;
                end;
                bBox := grpBBox;
            end;
            if (size<>0) or (pDat<>0) or (kind<>iObjGroup) then
                GetBBox(obj);
        end;
    end; (* SetObjInf *)

(* ********************************************************************* *)
(*$S Core*)
    procedure SetObjFmt(* obj: TObjPtr; face,font: Integer *);
    var grpObj: TObjPtr;
        grpBBox: Rect;
        startFlag: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do
        if locked=0 then begin
            if kind=iObjText then
                TxtFmt(obj,face,font)
            else if kind=iObjGroup then begin
                startFlag := TRUE;
                grpObj := grp.lBeg;
                while grpObj<>NIL do begin
                    SetObjFmt(grpObj,face,font);
                    if startFlag then begin
                        grpBBox := grpObj^.bBox;
                        startFlag := FALSE;
                    end else
                        UnionRect(grpBBox,grpObj^.bBox,grpBBox);
                    grpObj := grpObj^.fLink;
                end;
                bBox := grpBBox;
            end;
        end;
    end; (* SetObjFmt *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure SetObjCase  (* obj: TObjPtr; nCase: Integer *);
    type
        TCharHnd = ^TCharPtr;
        TCharPtr = ^TCharArray;
        TCharArray= packed Array[0..255] of Char;
    var grpObj: TObjPtr;
        grpBBox: Rect;
        startFlag: Boolean;
        charHnd: TCharHnd;
        ch: Char;
        i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do
        if locked=0 then begin
            if kind=iObjText then begin
                TxtCase(obj,nCase);
                GetBBox(obj);
            end else if kind=iObjGroup then begin
                startFlag := TRUE;
                grpObj := grp.lBeg;
                while grpObj<>NIL do begin
                    SetObjCase(grpObj,nCase);
                    if startFlag then begin
                        grpBBox := grpObj^.bBox;
                        startFlag := FALSE;
                    end else
                        UnionRect(grpBBox,grpObj^.bBox,grpBBox);
                    grpObj := grpObj^.fLink;
                end;
                bBox := grpBBox;
            end;
        end;
    end; (* SetObjCase *)

(* ********************************************************************* *)
(*$S Reshape*)
    procedure UpdateCLst(*srcCLst,dstCLst: TCLstHnd;delta:Point2D;
                          vrtLst:THndVrtLst*);
    Var i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        If (curDoc.edtState=iObjPoly) OR (curDoc.edtState=iObjSPoly) then begin
            With srcCLst^^,vrtLst^^ do begin
                dstCLst^^.crdCnt := crdCnt;   {Because of where this procedure
                                               is used more information is not
                                               need to be transfered.EditObj,
                                               EditCLstCmd}
                dstCLst^^.cClose := cClose;
                For i := 0 to crdCnt do begin
                    {$R-}
                    dstCLst^^.c2DLst[i] := c2DLst[i];
                    If vertex[i]=1 then begin
                        AddPt2D(delta,dstCLst^^.c2DLst[i]);
                    end;
                end;
                {Update helper points}
                If cClose=iCLstUsr then begin
                    dstCLst^^.c2DLst[crdCnt+1] := dstCLst^^.c2DLst[0];
                    dstCLst^^.c2DLst[crdCnt+2] := dstCLst^^.c2DLst[1];
                end;
                dstCLst^^.beg2D := dstCLst^^.c2DLst[0];
                {$IfC rangeOn } {$R+} {$EndC}
            end;
        end;
    end;{UpdateCLst}

(* ********************************************************************* *)
(*$S Reshape*)
    procedure EditObj(* obj: TObjPtr; start,angle: Integer; r1,r2,r3,r4: Real *);
    (* Note: does not recompute BBox *)
    var crdPt: Point;
        delta: Point2D;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do
        if locked=0 then begin
            if kind=iObjArc then with arc^^ do begin
                aStart := start;
                aAngle := angle;
            end else if (kind=iObjFHnd) then begin
                (* stretch crds *)
                if start=0 then with cLst^^.beg2D do begin
                    x := x+r1;
                    y := y+r2;
                end else begin
                    SetPt(crdPt,Round(r1),Round(r2));
                    GetNode(cLst,start,crdPt);
                    SetNode(cLst,start,crdPt.h,crdPt.v);
                end;
                if start<cLst^^.crdCnt then begin
                    SetPt(crdPt,-Round(r1),-Round(r2));
                    GetNode(cLst,start+1,crdPt);
                    SetNode(cLst,start+1,crdPt.h,crdPt.v);
                end;
            end else if (kind=iObjPoly) OR (kind=iObjSPoly) then begin
                SetPt2D(delta,r1,r2);
                UpdateCLst(obj^.oDat.cLst,obj^.oDat.cLst,delta,prvVrtLst);
            end;
            GetBBox(obj);
        end;
    end; (* EditObj *)

(* ********************************************************************* *)
(*$S Arrange*)
    procedure GridObj(* obj: TObjPtr *);
    var thisObj: TObjPtr;
        save2D,wP1,wP2: Point2D;

    (* ***************************************************************** *)

        procedure GridCLst(cLst: TCLstHnd);
        var
            i: Integer;
            crd2D: Point2D;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            With cLst^^ do begin
                For i := 0 to crdCnt do begin
                    {$R-}
                    crd2D := c2DLst[i];
                    GridP2D(crd2D);
                    c2DLst[i] := crd2D;
                    {$IfC rangeOn} {$R+} {$EndC}
                end;
            end;
        end; (* GridCLst *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do
        if locked=0 then begin
            case kind of
                iObjRLin,iObjSLin,iObjRect,iObjRndR,iObjOval:
                    begin
                        GridP2D(p1);
                        GridP2D(p2);
                    end;
                iObjText:
                    with bBox do begin
                        (* put on 1/2 grid *)
                        SetPt2D(wP1,tLoc.x,(top+bottom)/2.0);
                        wP2 := wP1;
                        save2D := curDoc.atr.grdSz2D;
                        curDoc.atr.grdSz2D.x := curDoc.atr.grdSz2D.x/2.0;
                        curDoc.atr.grdSz2D.y := curDoc.atr.grdSz2D.y/2.0;
                        GridP2D(wP2);
                        curDoc.atr.grdSz2D := save2D;
                        SubPt2D(wP1,wP2);
                        AddPt2D(wP2,tLoc);
                    end;
                iObjGroup:
                    begin
                        ScrnToWld(bBox.topLeft,wP1);
                        {
                        GetG2DBox(obj,r2D);
                        wp1 := r2D.topLeft;
                        }
                        wP2 := wP1;
                        GridP2D(wp2);
                        OffsetObj(obj,wP2.x-wP1.x,wP2.y-wP1.y);
                    end;
                iObjArc:  { GridArc };
                iObjFHnd: { GridP2D(cLst^^.beg2D) };
                iObjPoly: GridCLst(cLst);
            end; (* case *)
            if kind<>iObjGroup then
                GetBBox(obj);
        end;
    end; (* GridObj *)

(* ********************************************************************* *)
(*$S Arrange*)
    procedure AlignObj(* obj: TObjPtr; dir: Integer; xA,yA: Real *);
    var delPt:    Point;
        del2D:    Point2D;
        gBox:     Rect;
        oFlag:    Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* this routine should really case out each object and offset *)
        (* the difference between grid2D and obj crd2D, but that is   *)
        (* a lot of code and this should work. *)

        with obj^,oDat do
        if locked=0 then begin
            (* get the lineUp offset *)
            SetPt2D(del2D,xA,yA);
            WldToScrn(del2D,delPt);
            GetGBox(obj,gBox);
            with gBox do begin
                if (dir=iDirLft) or (dir=iDirTop) then
                    SubPt(topLeft,delPt)
                else if (dir=iDirRgt) or (dir=iDirBot) then
                    SubPt(botRight,delPt)
                else if (dir=iDirCtH) or (dir=iDirCtV) then begin
                    delPt.h := delPt.h-((right+left) Div 2);
                    delPt.v := delPt.v-((top+bottom) Div 2);
                end;
                ScrnToWld(delPt,del2D);
            end;
            case dir of
                iDirLft,iDirCtH,iDirRgt: del2D.y := 0;
                iDirTop,iDirCtV,iDirBot: del2D.x := 0;
            end; (* case *)

            (* text object: set alignment *)
            oFlag := TRUE;
            if kind=iObjText then
                if (dir=iDirLft) OR (dir=iDirCtH) OR (dir=iDirRgt) then
                    (* only align non-rotated text *)
                    if inf.tDat<16 then begin
                        oFlag := FALSE;
                        (* offset the text obj by setting tLoc *)
                        tLoc.x := xA;
                        case dir of
                            iDirLft: inf.tDat := 1;
                            iDirCtH: inf.tDat := 3;
                            iDirRgt: inf.tDat := 2;
                        end; (* case *)
                        GetBBox(obj);
                    end;
            (* offset the object *)
            if oFlag then
                OffsetObj(obj,del2D.x,del2D.y);
        end;
    end; (* AlignObj *)

(* ********************************************************************* *)

    Function  MapRotate(oldAmount,newAmount: Integer): Integer; EXTERNAL;

(* ********************************************************************* *)
(*$S Ring*)
    procedure RotateObj(* obj: TObjPtr; ctr2D: Point2D; amount: Integer *);
    var grpObj: TObjPtr;
        tAmount: Integer;

        procedure RotateCLst;
        var i: Integer;
             crd2D,rCrd2D,lastRCrd2D:Point2D;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            SetPt2D(crd2D,0,0);
            lastRCrd2D := crd2D;
            with obj^.oDat,cLst^^ do
                for i := 0 to crdCnt do begin
                    GetNode2D(cLst,i,crd2D);
                    rCrd2D := crd2D;
                    Rotate2D(rCrd2D,ctr2D,amount);
                    SetNode(cLst,i,rCrd2D.x-lastRCrd2D.x,rCrd2D.y-lastRCrd2D.y);
                    lastRCrd2D := rCrd2D;
                end;
        end;

        procedure RotateC2DLst;
        var i,count: Integer;
            rCrd2D:  Point2D;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            With obj^.oDat.cLst^^ do begin
                If cClose=iCLstUsr then
                    count := crdCnt+2
                else
                    count := crdCnt;
                For i := 0 to count do begin
                    {$R-}
                    rCrd2D := c2DLst[i];
                    Rotate2D(rCrd2D,ctr2D,amount);
                    c2DLst[i] := rCrd2D;
                    {$IfC rangeOn} {$R+} {$EndC}
                end;
                beg2D := c2DLst[0];
            end;
        end;{RotateC2DLst}
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('RotateObj(',Ord(obj):10,',',Round(ctr2D.x):4,Round(ctr2D.y):4,
                                amount:2,')');

        (* direction can be 1,3,4,5
                1 =  90 degrees
                2 = 270 degrees
                4 = flip horizontal
                5 = flip vertical
        *)

        with obj^,oDat do
        if locked=0 then begin
            case kind of
                iObjText:
                    begin
                        Rotate2D(tLoc,ctr2D,amount);
                        tAmount := MapRotate((inf.tDat DIV 16),amount);
                        if traceCmd then writeln('    mapRotate=',tAmount:2);
                        inf.tDat := (inf.tDat MOD 16) + tAmount*16;
                    end;
                iObjRLin,iObjSLin:
                    begin
                        Rotate2D(p1,ctr2D,amount);
                        Rotate2D(p2,ctr2D,amount);
                    end;
                iObjRect,iObjRndR,iObjOval:
                    RotateR2D(r2D,ctr2D,amount);
                iObjArc:
                    with arc^^ do begin
                        RotateR2D(aR2D,ctr2D,amount);
                        if amount=1 then
                            aStart := aStart+90
                        (*
                        else if amount=2 then
                            aStart := aStart+180
                        *)
                        else if amount=3 then
                            aStart := aStart+270
                        else if amount=4 then
                            aStart := -aStart
                        else if amount=5 then
                            aStart := -(aStart+180);
                        if amount>3 then
                            aAngle := -aAngle;
                        (* keep within 0..360 bounds *)
                        if aStart>360 then aStart := aStart-360
                        else if aStart<0 then aStart := aStart+360;
                    end;
                iObjFHnd:
                    RotateCLst;
                iObjPoly,iObjSPoly:
                    RotateC2DLst;
                iObjGroup:
                    begin
                        grpObj := grp.lBeg;
                        while grpObj <> NIL do begin
                            RotateObj(grpObj,ctr2D,amount);
                            grpObj := grpObj^.fLink;
                        end;
                    end;
            end; (* case *)
            if kind=iObjText then begin
                aspRatio := 1.0;
                GetTxtBBox(obj);
                aspRatio := cScreenRatio;
            end else
                RotateBox(obj^.bBox,ctr2D,amount);
        end;
    end; (* RotateObj *)

(* ********************************************************************* *)
(*$S Core*)
    procedure OffsetObj(* obj: TObjPtr; dx,dy: real *);
    var wld2D,old2D,new2D: Point2D;
        oldPt,newPt: Point;
        dh,dv: Integer;
        grpObj: TObjPtr;
        grpBBox: Rect;
        startFlag: Boolean;

    (* ***************************************************************** *)

        procedure GetOffset(obj: TObjPtr; dx,dy: Real; var dh,dv: Integer);
        var wld2D,old2D,new2D: Point2D;
            oldPt,newPt: Point;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with obj^,oDat do
            if (kind=iObjFHnd) OR (kind=iObjPoly) OR (kind=iObjSPoly)
                then begin
                (* get bBox offset, compensate for roundoff error *)
                SetPt2D(wld2D,dx,dy);
                old2D := cLst^^.beg2D;
                new2D := old2D;
                AddPt2D(wld2D,new2D);
                WldToScrn(old2D,oldPt);
                WldToScrn(new2D,newPt);
                SubPt(oldPt,newPt);
                dh := newPt.h;
                dv := newPt.v;
            end;
        end; (* GetOffset *)

    (* ***************************************************************** *)
        procedure OffSetCLst(cLst: TCLstHnd);
        var i,count: Integer;
            rCrd2D:  Point2D;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            With cLst^^ do begin
                If cClose=iCLstUsr then
                    count := crdCnt+2
                else
                    count := crdCnt;
                For i := 0 to count do begin
                    {$R-}
                    rCrd2D := c2DLst[i];
                    AddPt2D(wld2D,rCrd2D);
                    c2DLst[i] := rCrd2D;
                    {$IfC rangeOn} {$R+} {$EndC}
                end;
                beg2D := c2DLst[0];
            end;
        end;{OffSetCLst}

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('OffsetObj(',ord(obj):10,',',Round(dx):4,',',Round(dy):4,')');

        with obj^,oDat do
        if locked=0 then begin
            SetPt2D(wld2D,dx,dy);
            case kind of
                iObjRLin,iObjSLin,iObjRect,iObjRndR,iObjOval:
                    begin
                        AddPt2D(wld2D,p1);
                        AddPt2D(wld2D,p2);
                    end;
                iObjArc:
                    with arc^^.aR2D do begin
                        AddPt2D(wld2D,topLeft);
                        AddPt2D(wld2D,botRight);
                    end;
                iObjFHnd:
                    AddPt2D(wld2D,cLst^^.beg2D);
                iObjPoly,iObjSPoly:
                    OffSetCLst(cLst);
                iObjText:
                    AddPt2D(wld2D,tLoc);
                iObjGroup:
                    begin
                        startFlag := TRUE;
                        grpObj := grp.lBeg;
                        while grpObj <> NIL do begin
                            OffsetObj(grpObj,dx,dy);
                            if startFlag then begin
                                grpBBox := grpObj^.bBox;
                                startFlag := FALSE;
                            end else
                                UnionRect(grpBBox,grpObj^.bBox,grpBBox);
                            grpObj := grpObj^.fLink;
                        end;
                        bBox := grpBBox;
                    end;
            end; (* case *)
            (* update bBox, handle arc,fHnd,poly separately since *)
            (* they are hard to calculate  *)
            if kind in [iObjFHnd,iObjPoly,iObjSPoly] then begin
                GetOffset(obj,dx,dy,dh,dv);
                OffsetRect(bBox,dh,dv)
            end else if kind<>iObjGroup then
                GetBBox(obj);
        end;
    end; (* OffsetObj *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure ScaleObj(* obj: TObjPtr; ctr2D: Point2D; hScl,vScl: Real *);

    (* Note: does not recompute BBox, too expensive for curves *)

    (* 4/27/83 added ckSize parameter to only do min size constraint
                on interactive stretching, not when printing or in FIO
      11/29/83 took out min size constraints all together, isn't a
                useful feature
    *)

    var dx,dy: Real;
        thisR2D: Rect2D;
        grpObj: TObjPtr;

    (* ***************************************************************** *)

        procedure Scale2D(var p: Point2D);
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with p do begin
                x := (x-ctr2D.x)*hScl+ctr2D.x;
                y := (y-ctr2D.y)*vScl+ctr2D.y;
            end;
        end; (* Scale2D *)

    (* ***************************************************************** *)

        procedure ScaleR2D(var thisR2D: Rect2D);
        var thisP1,thisP2: Point2D;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            thisP1 := thisR2D.topLeft;
            thisP2 := thisR2D.botRight;
            Scale2D(thisP1);
            Scale2D(thisP2);
            R2DFmP2D(thisP1,thisP2,thisR2D);
        end; (* ScaleR2D *)

    (* ***************************************************************** *)

        procedure ScaleArc;
        var pt: Point;
            t1,t2,t3: Point2D;
            oRect,aRect: Rect;
            a1,a2: Integer;

            oldArc: TArcRec;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with obj^.oDat,arc^^ do begin
                oldArc := arc^^;
                GetAngles(aStart,aAngle,a1,a2);
                aStart := a1;
                aAngle := a2-a1;

                (* scale arc rect *)
                ScaleR2D(aR2D);

                (* NOTE: because of the way arcs work, scaling should not
                   affect the angles other than direction and 180 degree
                   transformations *)
                if (hScl<0) AND (vScl>=0) then
                    aStart := -aStart
                else if (vScl<0) AND (hScl>=0) then
                    aStart := -(aStart+180)
                else if (vScl<0) AND (hScl<0) then
                    aStart := aStart+180;

                (* see if need to change sign of aAngle *)
                if (hScl<0)<>(vScl<0) then
                    aAngle := -aAngle;

                if traceCmd then  begin
                    writeln('ScaleArc:',oldArc.aStart:4,',',oldArc.aAngle:4);
                    writeln('     new:',aStart:4,',',aAngle:4);
                    writeln('     old:',t2.x:7:2,t2.y:7:2);
                    writeln('     new:',t3.x:7:2,t3.y:7:2);
                end;
            end;
        end; (* ScaleArc *)

    (* ********************************************************************* *)

        procedure ScaleCLst;
        var i: Integer;
            d2D:     Point2D;
            crd2D:   Point2D;           (* node *)
            last2D:  Point2D;
            sCrd2D:  Point2D;           (* scaled node *)
            nCLst:   TCLstHnd;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            (* it is possible to end up with more nodes than we started with in a FHndCLst,
               since maximum dh,dv is a byte offset, so we stretch the cLst into a new cLst
               and return the handle to it.  PutNode takes care of delta > 128.
            *)

            with obj^,oDat do begin
                OpenCLst(HzFromH(Pointer(Ord(cLst))),nCLst,cLst^^.crdCnt*2,iObjFHnd);
                with cLst^^ do begin
                    crd2D := beg2D;
                    Scale2D(beg2D);
                    sCrd2D := beg2D;
                    nCLst^^.beg2D := sCrd2D;
                    for i := 1 to crdCnt do begin
                        last2D := sCrd2D;
                        (* get old crd2D *)
                        GetNode2D(cLst,i,crd2D);
                        (* stretch crd *)
                        sCrd2D := crd2D;
                        Scale2D(sCrd2D);
                        (* get scrn offset *)
                        d2D := sCrd2D;
                        SubPt2D(last2D,d2D);
                        PutNode(ncLst,d2D.x,d2D.y);
                    end;
                end;
                CloseCLst(nCLst);
                FreeCLst(cLst);
                cLst := nCLst;
            end;
        end; (* ScaleCLst *)

    (* ********************************************************************* *)

        procedure ScaleC2DLst;
        var i,count: Integer;
            rCrd2D:  Point2D;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            With obj^.oDat.cLst^^ do begin
                If cClose=iCLstUsr then
                    count := crdCnt+2
                else
                    count := crdCnt;
                For i := 0 to count do begin
                    {$R-}
                    rCrd2D := c2DLst[i];
                    Scale2D(rCrd2D);
                    c2DLst[i] := rCrd2D;
                    {$IfC rangeOn} {$R+} {$EndC}
                end;
                beg2D := c2DLst[0];
            end;
        end;{ScaleC2DLst}

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC} (* ScaleObj *)
        if traceCmd then
            writeln('ScaleObj(',Ord(obj):10,',',Round(ctr2D.x):4,Round(ctr2D.y):4,
                                Round(hScl*100):4,Round(vScl*100):4,')');

        with obj^,oDat do
        if locked=0 then begin
            case kind of
                iObjText:
                    Scale2D(tLoc);
                iObjRLin,iObjSLin:
                    begin
                        Scale2D(p1);
                        Scale2D(p2);
                    end;
                iObjArc:
                    ScaleArc;
                iObjRect,iObjRndR,iObjOval:
                    ScaleR2D(r2D);
                iObjFHnd:
                    ScaleCLst;
                iObjPoly,iObjSPoly:
                    ScaleC2DLst;
                iObjGroup:
                    begin
                        grpObj := grp.lBeg;
                        while grpObj <> NIL do begin
                            ScaleObj(grpObj,ctr2D,hScl,vScl);
                            grpObj := grpObj^.fLink;
                        end;
                    end;
            end; (* case *)
        end;
    end; (* ScaleObj *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GetBBox(* obj: TObjPtr *);
    var pt1,pt2: Point;
        grpObj: TObjPtr;

    (* ***************************************************************** *)

        procedure InsetBBox;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with obj^,oDat,bBox,inf do begin
                left   := left  -penSizes[pnSiz].h Div 2;
                top    := top   -penSizes[pnSiz].v Div 2;
                right  := right +(penSizes[pnSiz].h+1) Div 2;
                bottom := bottom+(penSizes[pnSiz].v+1) Div 2;
            end;
        end; (* InsetBBox *)

    (* ***************************************************************** *)

        procedure GetWldBBox(thisR2D: Rect2D);
        var zoomWasOn: Integer;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            zoomWasOn := curDoc.atr.zoomOn;
            curDoc.atr.zoomOn := 0;
            with obj^,oDat do GetDrwRect(thisR2D,inf.pnSiz,bBox);
            curDoc.atr.zoomOn := zoomWasOn;
        end;

    (* ***************************************************************** *)

        procedure ArrwBBox;
        var ph,pv,dh,dv,ckAngle: integer;
            ckRect: Rect;
            ckPt1,ckPt2: Point;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            if traceCmd then
                writeln('ArrwBBox');

            with obj^,bBox,oDat do begin
                (* the angle used to draw the arrow arc is +-24 degrees,
                   see if the angle of the line is less than +-24 degrees
                   from vertical or horizontal.  If it is, then compensate
                   for the overhang of the arrow arc from the line bBox *)

                (* get arrw half-width and half-height *)
                ph := arrwSz[inf.pnSiz].h;
                pv := arrwSz[inf.pnSiz].v;

                (* check to see if angle of line is less than angle of arrw *)
                WldToScrn(p1,ckPt1);
                WldToScrn(p2,ckPt2);
                GetArrwRect(ckPt1,inf.pnSiz,ckRect);
                PtToAngle(ckRect,ckPt2,ckAngle);
                (* see if between 90+-deltaArc *)
                if ((ckAngle>= 66) and (ckAngle<=114))
                or ((ckAngle>=246) and (ckAngle<=294)) then begin
                    top   := top   -pv;
                    bottom:= bottom+pv;
                (* see if between 180+-deltaArc *)
                end else if ((ckAngle>=336) and (ckAngle<= 384))
                         or ((ckAngle>=-24) and (ckAngle<= 24))
                         or ((ckAngle>=156) and (ckAngle<=204)) then begin
                    left  := left  -ph;
                    right := right +ph;
                end;
                {
                (* get bBox width and height *)
                dh := right-left;
                dv := bottom-top;
                (* check to see if bBox width is less than arrw width *)
                if dh<2*ph then begin
                    dh := (right+left) Div 2;
                    left := dh-ph;
                    right := dh+ph;
                end;
                (* check to see if bBox height is less than arrw height *)
                if dv<2*pv then begin
                    dv := (top+bottom) Div 2;
                    top := dv-pv;
                    bottom := dv+pv;
                end;
                }
            end;
        end; (* ArrwBBox *)

    (* ***************************************************************** *)

        procedure ArcBBox;
        var a1,a2: Integer;
            ctrPt: Point;

        (* ************************************************************* *)

            function  InBounds(i,minB,maxB: Integer): Boolean;
            begin
        {$IFC sampcalls} ALogCall; {$ENDC}
                InBounds := (i>=minB) AND (i<=maxB);
            end; (* InBounds *)

        (* ************************************************************* *)

        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with obj^,oDat,arc^^ do begin
                GetWldBBox(aR2D);
                if ABS(aAngle)<180 then begin
                    GetAngles(aStart,aAngle,a1,a2);
                    a2 := a2 Mod 360;
                    SetPt(ctrPt,(bBox.left+bBox.right) div 2,
                                (bBox.top+bBox.bottom) div 2);
                    if InBounds(a1,0,180) and InBounds(a2,0,180) then
                        bBox.left := ctrPt.h
                    else if (InBounds(a1,180,360) or (a1=0)) and
                            (InBounds(a2,180,360) or (a2=0)) then
                        bBox.right := ctrPt.h;
                    if (InBounds(a1,270,360) or InBounds(a1,0,90)) and
                       (InBounds(a2,270,360) or InBounds(a2,0,90)) then
                        bBox.bottom := ctrPt.v
                    else if InBounds(a1,90,270) and InBounds(a2,90,270) then
                        bBox.top := ctrPt.v;
                end;
            end;
        end; (* ArcBBox *)

    (* ***************************************************************** *)

        procedure CLstBBox;
        var node,hL,hR,vT,vB: integer;
            crdPt: Point;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with obj^,oDat,cLst^^ do begin
                If crdKind=iObjPoly then begin
                    WldToScrn(c2DLst[0],crdPt);
                    hL := crdPt.h;
                    vT := crdPt.v;
                    hR := crdPt.h;
                    vB := crdPt.v;
                    For node := 1 to crdCnt do begin
                        {$R-}
                        WldToScrn(c2DLst[node],crdPt);
                        {$IfC rangeOn} {$R+} {$EndC}
                        hL := CMin(hL,crdPt.h);
                        hR := CMax(hR,crdPt.h);
                        vT := CMin(vT,crdPt.v);
                        vB := CMax(vB,crdPt.v);
                    end;
                end else for node := 0 to crdCnt do begin
                    GetNode(cLst,node,crdPt);
                    if node=0 then begin
                        hL := crdPt.h;
                        vT := crdPt.v;
                        hR := crdPt.h;
                        vB := crdPt.v;
                    end else begin
                        hL := CMin(hL,crdPt.h);
                        hR := CMax(hR,crdPt.h);
                        vT := CMin(vT,crdPt.v);
                        vB := CMax(vB,crdPt.v);
                    end;
                end;
                SetRect(bBox,hL,vT,hR,vB);
            end;
        end; (* CLstBBox *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC} (* GetBBox *)
        with obj^,oDat do
        case kind of
            iObjText:
                GetTxtBBox(obj);
            iObjRLin,iObjSLin:
                begin
                    WldToScrn(p1,pt1);
                    WldToScrn(p2,pt2);
                    Pt2Rect(pt1,pt2,bBox);
                    InsetBBox;
                    if inf.dat>0 then
                        if inf.pnSiz>0 then
                            if inf.pnSiz<=4 then
                                ArrwBBox;
                end;
            iObjArc:
                ArcBBox;
            iObjRect,iObjRndR,iObjOval:
                GetWldBBox(r2D);
            iObjFHnd,iObjPoly,iObjSPoly:
                begin
                    CLstBBox;
                    InsetBBox;
                end;
            iObjGroup:
                begin
                    grpObj := grp.lBeg;
                    GetBBox(grpObj);
                    bBox := grpObj^.bBox;
                    grpObj := grpObj^.fLink;
                    while grpObj<>NIL do begin
                        GetBBox(grpObj);
                        UnionRect(bBox,grpObj^.bBox,bBox);
                        grpObj := grpObj^.fLink;
                    end;
                end;
        end; (* case *)
        {
        GetG2DBox(obj,r2D);
        GetDrwRect(r2D,pnSiz,bBox);
        }
    end; (* GetBBox *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GetGBox(* obj: TObjPtr; VAR gBox: Rect *);
    var thisObj: TObjRec;
        grpObj:  TObjPtr;
        tBox:    Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^.oDat do
        if kind=iObjGroup then begin
            grpObj := grp.lBeg;
            GetGBox(grpObj,gBox);
            grpObj := grpObj^.fLink;
            while grpObj<>NIL do begin
                GetGBox(grpObj,tBox);
                UnionRect(tBox,gBox,gBox);
                grpObj := grpObj^.fLink;
            end;
        end else begin
            thisObj := obj^;
            if kind<>iObjText then
                thisObj.oDat.inf.pnSiz := 0;
            GetBBox(@thisObj);
            gBox := thisObj.bBox;
        end;
    end; (* GetGBox *)

(* ********************************************************************* *)

(* Knobs *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure GetDKnobRect(* pt: Point; VAR r: Rect *);
    var dh,dv: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        dh := zoomKnobSz.h DIV 2;
        dv := zoomKnobSz.v DIV 2;
        SetRect(r,pt.h-dh,pt.v-dv,pt.h+dh,pt.v+dv);
    end; (* GetKnobRect *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GetObjKnobs(* obj: TObjPtr; var knobs: TKnobs *);
    var thisRect: Rect;
        pSiz,k1,k2,kSave:  Point;
        thisObj: TObjRec;
        i: Integer;
        thisBox: Rect;

    (* ***************************************************************** *)

        procedure LinKnob(i1,i2: Integer; VAR i3,i4: Integer);
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            if i3<i4 then begin
                i3 := i1;
                i4 := i2;
            end else if i3>i4 then begin
                i3 := i2;
                i4 := i1;
            end;
        end; (* LinKnob *)

    (* ***************************************************************** *)

        procedure GetRectKnobs(* bBox: Rect; hideOK: Boolean; var knobs: TKnobs *);
        var dh,dv: Integer;
            hideKnob: Point;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with knobs,obj^.bBox do begin
                knobCnt := 8;
                dh := (right-left) div 2;
                dv := (bottom-top) div 2;

                SetPt(knobInfo[1],left,top);
                SetPt(knobInfo[2],left+dh,top);
                SetPt(knobInfo[3],right,top);
                SetPt(knobInfo[4],right,top+dv);
                SetPt(knobInfo[5],right,bottom);
                SetPt(knobInfo[6],right-dh,bottom);
                SetPt(knobInfo[7],left,bottom);
                SetPt(knobInfo[8],left,top+dv);

                (* hide knobs if size is too small *)
                    SetPt(hideKnob,-hKnob,-vKnob);
                    if (right-left)<4*zoomKnobSz.h then begin
                        knobInfo[2] := hideKnob;
                        knobInfo[6] := hideKnob;
                    end;
                    if (bottom-top)<4*zoomKnobSz.v then begin
                        knobInfo[4] := hideKnob;
                        knobInfo[8] := hideKnob;
                    end;

            end;
        end; (* GetRectKnobs *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        knobs.knobCnt := 0;
        with knobs do
        with obj^,oDat do
        if cSel=iSelNml then begin
            case kind of
                iObjText:
                    knobCnt := 0;
                iObjRLin,iObjSLin:
                    begin
                        knobCnt := 2;
                        WldToScrn(p1,k1);
                        WldToScrn(p2,k2);
                        kSave := k2;
                        if inf.dat<2 then begin
                            (* make sure the knobs lie on the bBox of line
                               to reduce cancelling effect; only works for
                               end of line without arrows  *)
                            thisRect := bBox;
                            if inf.dat=1 then begin
                                thisObj := obj^;
                                thisObj.oDat.inf.dat := 0;
                                GetBBox(@thisObj);
                                thisRect := thisObj.bBox;
                            end;
                            with thisRect do begin
                                LinKnob(top,bottom,k1.v,k2.v);
                                LinKnob(left,right,k1.h,k2.h);
                            end;
                            if inf.dat=1 then
                                k2 := kSave;
                        end;
                        knobInfo[1] := k1;
                        knobInfo[2] := k2;
                    end;
                otherwise
                    GetRectKnobs
            end; (* case *)
        end else if (cSel=iSelEdt) and (kind=iObjArc) then with arc^^ do begin
            knobCnt := 2;
            GetDrwRect(aR2D,inf.pnSiz,thisRect);
            GEUnMapRect(thisRect);
            AngleToPt(thisRect,aStart,k1);
            AngleToPt(thisRect,aStart+aAngle,k2);
            knobInfo[1] := k1;
            knobInfo[2] := k2;
        end;

        if traceCmd then with knobs do begin
            with obj^,oDat do
            writeln('        GetObjKnobs(',Ord(obj):7,kind:4,cSel:4,')=',knobCnt:4);
            write('        knobs: ');
            for i := 1 to knobCnt do
                write(knobInfo[i].h:2,',',knobInfo[i].v:2,';  ');
            writeln;
        end;
    end; (* GetObjKnobs *)

(* ********************************************************************* *)

(* Miscellaneous *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GetArrwRect(* endPt: Point; pnSiz: Integer; Var aRect: Rect *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        aRect := arrwRects[pnSiz];
        OffsetRect(aRect,endPt.h{+1},endPt.v);
    end; (* GetArrwRect *)


(* ********************************************************************* *)
(*$S Ring*)
    procedure CkBBox(* pt: Point; pnSiz: Integer; var bBox: Rect *);
    var thisRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        thisRect.topLeft  := pt;
        thisRect.botRight := pt;
        GetPenRect(pnSiz,thisRect);
        with bBox do begin
            if thisRect.left<left then
                left := thisRect.left;
            if thisRect.right>right then
                right := thisRect.right;
            if thisRect.top<top then
                top := thisRect.top;
            if thisRect.bottom>bottom then
                bottom := thisRect.bottom;
        end;
    end; (* CkBBox *)


(* ********************************************************************* *)
    (*$S Init*)

    procedure InitDat;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('InitDat');


        (* set up arrow arc rects *)
        SetRect(arrwRects[1],- 9,- 6, 9, 6);
        SetRect(arrwRects[2],-18,-12,18,12);
        SetRect(arrwRects[3],-27,-18,27,18);
        SetRect(arrwRects[4],-36,-24,36,24);

        (* half width and height of horiz and vertical arcs *)
        SetPt(arrwSz[1], 4, 3);
        SetPt(arrwSz[2], 8, 6);
        SetPt(arrwSz[3],12, 9);
        SetPt(arrwSz[4],16,12);

        (* object data lists *)
        InitODB(curDoc.oLst);

        (* curves *)
        {InitCrv;}
    end; (* InitDat *)


ÿ