(* ********************************************************************* *)

(* CopyRight 1983, Apple Computer Inc. *)
(* GE Unit TRK Include File: Stretch, Move, Select and Misc Routines  *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure GetTSel(hitObj: TObjPtr; VAR tempSLst: TSelHnd);
    const
        maxSel  = 15;
    var
        i: Integer;
        tObj: TObjPtr;
        thisSLst: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        thisSLst := curDoc.sLst^^;
        tempSLst := NewSLst(geHHz);
        (* if we have more than maxSel objects selected, then track
           the one we hit on and the bBox of them all *)
        if thisSLst.sTot>maxSel then begin
            if hitObj^.oDat.kind<>iObjGroup then begin
                DupObj(hitObj,tObj);
                AddToSEnd(tempSLst,tObj);
            end;
            tObj := NewObj(iObjRect);
            with tObj^,oDat do begin
                bBox := thisSLst.sBBox;
                SetRect2D(r2D,bBox.left,bBox.top,bBox.right,bBox.bottom);
            end;
            AddToSEnd(tempSLst,tObj);
        end else begin
            CopySLst(curDoc.sLst,tempSLst);
            for i := 1 to thisSLst.sCnt do begin
                DupObj(CurSelObj(i),tObj);
                (*$R-*)
                SetSelObj(tempSLst,i,tObj);
                (*$IfC rangeOn*)(*$R+*)(*$EndC*)
            end;
        end;
    end; (* GetTSel *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure FreeTSel(VAR tempSLst: TSelHnd);
    var i: Integer;
        tObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        for i := 1 to tempSLst^^.sCnt do begin
            tObj := GetSelObj(tempSLst,i);
            FreeObj(tObj);
        end;
        FreeSLst(tempSLst);
    end; (* FreeTSel *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure DrawTSel(tempSLst: TSelHnd);
    var i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        for i := 1 to tempSLst^^.sCnt do
            DrwObj(GetSelObj(tempSLst,i));
    end; (* DrawTSel *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure ShowObjSize(obj: TObjPtr);
    var gRect: Rect;
        thisPt: Point;
        thisObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        {
        if traceTrk then
            writeln('ShowObjSize, lastPt=',thisPt.h:2,',',thisPt.v:2,
                               ', gridPt=',gridPt.h:2,',',gridPt.v:2);
        }
        if curDoc.atr.msrOn then begin
            (* if haven't moved then show dist *)
            GetMouse(thisPt);
            if  (Abs(thisPt.h-wrkPt.h)<hKnob)
            and (Abs(thisPt.v-wrkPt.v)<vKnob) then begin
                thisObj := obj;
                (* only trfo if geometry has changed *)
                if lastOp.Op in [iOpEdt,iOpStr,iOpSt1,iOpMov,iOpAlG,iOpAlO] then
                    thisObj := CkObjTrfo(obj);
                with thisObj^.oDat do begin
                    if kind in [iObjRLin,iObjSLin] then begin
                        if kind=iObjRLin then
                            trkHoriz := p1.y=p2.y;
                        tlSz2D := p1;
                        brSz2D := p2;
                        if tlSz2D.x>brSz2D.x then begin
                            tlSz2D.x := p2.x;
                            brSz2D.x := p1.x;
                        end;
                        if tlSz2D.y>brSz2D.y then begin
                            tlSz2D.y := p2.y;
                            brSz2D.y := p1.y;
                        end;
                    end else if kind in [iObjRect..iObjOval] then begin
                        tlSz2D := p1;
                        brSz2D := p2;
                    end else begin
                        GetGBox(thisObj,gRect);
                        ScrnToWld(gRect.topLeft,tlSz2D);
                        ScrnToWld(gRect.botRight,brSz2D);
                    end;
                    TurnOnDist(kind,tlSz2D,brSz2D);
                end;
            end;
        end;
    end; (* ShowObjSize *)

(* ********************************************************************* *)

(* Stretching Routines *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure StrSelCmd(* thisObj: TObjPtr; thisKnob: Integer *);
    var lastPt:     Point;
        lmtRect:    Rect;
        gRect:      Rect;
        knobs:      TKnobs;
        dummyFlag:  Boolean;
        (* stretching vars *)
        center2D:   Point2D;
        centerPt:   Point;
        hFixed:     Boolean;
        vFixed:     Boolean;
        dxStart:    Real;
        dyStart:    Real;
        xScale:     Real;
        yScale:     Real;
        sLinObj:    TObjRec;
        tObj:       TObjPtr;

        thisTime:  LongInt;
        waitFlag:  Boolean;
        startFlag: Boolean;

        tempSLst:  TSelHnd;
        knobPt:    Point;

    (* ***************************************************************** *)

        procedure CnstrObj(obj: TObjPtr);
        var g2DBox: Rect2D;

        (* ************************************************************* *)

            procedure CnstrLin;
            var dx,dy: Boolean;
            begin
        {$IFC sampcalls} ALogCall; {$ENDC}
                with obj^.oDat do begin
                    if kind=iObjRLin then begin
                        hFixed := p1.x=p2.x;
                        vFixed := not hFixed;
                    end else begin
                        hFixed := Abs(p1.x-p2.x)<1;
                        vFixed := Abs(p1.y-p2.y)<1;
                    end;
                    case thisKnob of
                        1:  begin center2D := p2; grid2D := p1; end;
                        2:  begin center2D := p1; grid2D := p2; end;
                    end; (* case *)
                end;
            end; (* CnstrLin *)

        (* ************************************************************* *)

            procedure CnstrRect(r2D: Rect2D);
            begin
        {$IFC sampcalls} ALogCall; {$ENDC}
                hFixed := (thisKnob=2)or(thisKnob=6);
                vFixed := (thisKnob=4)or(thisKnob=8);

                if thisKnob in [1,2,3] then begin
                    grid2D.y   := r2D.yT;
                    center2D.y := r2D.yB;
                end else if thisKnob in [5,6,7] then begin
                    grid2D.y   := r2D.yB;
                    center2D.y := r2D.yT;
                end else begin
                    grid2D.y   := (r2D.yT+r2D.yB)/2;
                    center2D.y := grid2D.y;
                end;

                if thisKnob in [3,4,5] then begin
                    grid2D.x   := r2D.xR;
                    center2D.x := r2D.xL;
                end else if thisKnob in [7,8,1] then begin
                    grid2D.x   := r2D.xL;
                    center2D.x := r2D.xR;
                end else begin
                    grid2D.x   := (r2D.xL+r2D.xR)/2;
                    center2D.x := grid2D.x;
                end;
            end; (* CnstrRect *)

        (* ************************************************************* *)

            procedure GetG2DBox(obj: TObjPtr; VAR thisR2D: Rect2D);
            var tempR2D: Rect2D;
                startFlag: Boolean;
                grpObj: TObjPtr;
                node: Integer;
                crd2D,ctr2D: Point2D;
                a1,a2: Integer;

            (* ********************************************************* *)

                function RMax(a,b: Real): Real;
                begin
        {$IFC sampcalls} ALogCall; {$ENDC}
                    if a>b then
                        RMax := a
                    else
                        RMax := b;
                end;

            (* ********************************************************* *)

                function  InBounds(i,minB,maxB: Integer): Boolean;
                begin
        {$IFC sampcalls} ALogCall; {$ENDC}
                    InBounds := (i>=minB) and (i<=maxB);
                end; (* InBounds *)

            (* ********************************************************* *)

            begin
        {$IFC sampcalls} ALogCall; {$ENDC}
                (* this routine should really go into DAT,
                   GetBBox should call it and then R2DToRect the result
                   9/21/83 MAC
                *)
                (* default for text, fHnd *)
                with obj^.bBox do
                SetRect2D(thisR2D,left,top,right,bottom);
                (* handle all other objects *)
                with obj^,oDat do
                if kind in [iObjRLin,iObjSLin] then
                    R2DFmP2D(p1,p2,thisR2D)
                else if kind in [iObjRect,iObjRndR,iObjOval] then
                    thisR2D := r2D
                else if kind=iObjArc then with arc^^ do begin
                    thisR2D := aR2D;
                    if ABS(aAngle)<180 then begin
                        GetAngles(aStart,aAngle,a1,a2);
                        a2 := a2 Mod 360;
                        SetPt2D(ctr2D,(aR2D.xL+aR2D.xR) / 2,
                                      (aR2D.yT+aR2D.yB) / 2);
                        if InBounds(a1,0,180) and InBounds(a2,0,180) then
                            thisR2D.xL := ctr2D.x
                        else if (InBounds(a1,180,360) or (a1=0)) and
                                (InBounds(a2,180,360) or (a2=0)) then
                            thisR2D.xR := ctr2D.x;
                        if (InBounds(a1,270,360) or InBounds(a1,0,90)) and
                           (InBounds(a2,270,360) or InBounds(a2,0,90)) then
                            thisR2D.yB := ctr2D.y
                        else if InBounds(a1,90,270) and InBounds(a2,90,270) then
                            thisR2D.yT := ctr2D.y;
                    end;
                end else if (kind=iObjPoly) OR (kind=iObjSPoly)
                    then with cLst^^ do begin
                    crd2D := beg2D;
                    thisR2D.topLeft  := crd2D;
                    thisR2D.botRight := crd2D;
                    for node := 1 to crdCnt do begin
                        (*$R-*)
                        crd2D.x := c2DLst[node].x;
                        crd2D.y := c2DLst[node].y;
                        (*$IfC rangeOn *)
                        (*$R+*)
                        (*$EndC *)
                        thisR2D.xL := RMin(crd2D.x,thisR2D.xL);
                        thisR2D.xR := RMax(crd2D.x,thisR2D.xR);
                        thisR2D.yT := RMin(crd2D.y,thisR2D.yT);
                        thisR2D.yB := RMax(crd2D.y,thisR2D.yB);
                    end;
                end else if kind=iObjGroup then begin
                    grpObj := grp.lBeg;
                    startFlag := TRUE;
                    while grpObj<>NIL do begin
                        GetG2DBox(grpObj,tempR2D);
                        if startFlag then begin
                            startFlag := FALSE;
                            thisR2D := tempR2D;
                        end else begin
                            {UnionR2D(thisR2D,r2D);}
                            thisR2D.xL := RMin(tempR2D.xL,thisR2D.xL);
                            thisR2D.xR := RMax(tempR2D.xR,thisR2D.xR);
                            thisR2D.yT := RMin(tempR2D.yT,thisR2D.yT);
                            thisR2D.yB := RMax(tempR2D.yB,thisR2D.yB);
                        end;
                        grpObj := grpObj^.fLink;
                    end;
                end;
            end; (* GetG2DBox *)

        (* ************************************************************* *)

        begin
        {$IFC sampcalls} ALogCall; {$ENDC} (* CnstrObj *)
            hFixed := FALSE;
            vFixed := FALSE;
            with obj^,oDat do
            case kind of
                iObjRLin,iObjSLin:
                    CnstrLin;
                otherwise
                    begin
                        GetG2DBox(obj,g2DBox);
                        CnstrRect(g2DBox);
                    end;
            end; (* case *)
        end; (* CnstrObj *)

    (* ***************************************************************** *)

        procedure StrTSel;
        var i: Integer;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            if not hFixed then
                xScale := (grid2D.x-center2D.x)/dxStart;
            if not vFixed then
                yScale := (grid2D.y-center2D.y)/dyStart;
            for i := 1 to tempSLst^^.sCnt do
                ScaleObj(GetSelObj(tempSLst,i),center2D,xScale,yScale);
        end; (* StrTSel; *)

    (* ***************************************************************** *)

        procedure MkStrSel;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            {
            if traceTrk then
                Writeln('MkStrSel(',Round(grid2D.x):4,Round(grid2D.y):4,
                                    Round(center2D.x):4,Round(center2D.y):4,')');
            }
            (* erase sel *)
            if NOT startFlag then
                DrawTSel(tempSLst);

            FreeTSel(tempSLst);
            GetTSel (thisObj,tempSLst);

            startFlag := FALSE;
            (* stretch sel *)
            StrTSel;
            (* draw sel *)
            AutoScroll(FALSE);
            DrawTSel(tempSLst);
        end; (* MkStrSel *)

    (* ***************************************************************** *)

        procedure GetLimit(pt: Point; var r: Rect);
        var s1,s2,b:    Point2D;

        (* ************************************************************* *)

            Function  LmtSize(s,c,d,b: Real): Real;
            var lmt: Real;
            begin
        {$IFC sampcalls} ALogCall; {$ENDC}
                if Abs(b-c)<1 then
                    lmt := s
                else
                    lmt := c+d*(s-c)/(b-c);
                (* lmt := center +
                          dStart * (sizeLBox-center)/(point-center) *)
                {
                if traceTrk then
                    Writeln('        LmtSize(',Round(s):4,Round(c):4,
                                               Round(d):4,Round(b):4,
                                               ')=',Round(lmt):4);
                }
                LmtSize := lmt;
            end; (* LmtSize *)

        (* ************************************************************* *)

        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            {
            if traceTrk then
                Writeln('    GetLimit(',pt.h:2,',',pt.v:2,')');
            }
            ScrnToWld(pt,b);
            ScrnToWld(sizeLBox.topLeft,s1);
            ScrnToWld(sizeLBox.botRight,s2);
            SetPt2D(s1,LmtSize(s1.x,center2D.x,dxStart,b.x),
                       LmtSize(s1.y,center2D.y,dyStart,b.y));
            SetPt2D(s2,LmtSize(s2.x,center2D.x,dxStart,b.x),
                       LmtSize(s2.y,center2D.y,dyStart,b.y));
            WldToScrn(s1,r.topLeft);
            WldToScrn(s2,r.botRight);
            Pt2Rect(r.topLeft,r.botRight,r);
        end; (* LimitSize *)

    (* ***************************************************************** *)

        procedure MkStrSLin;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            DrwObj(@sLinObj);
            AutoScroll(FALSE);
            with sLinObj.oDat do begin
                if thisKnob=1 then
                    p1 := grid2D
                else
                    p2 := grid2D;
            end;
            DrwObj(@sLinObj);
        end; (* MkStrSLin *)

    (* ***************************************************************** *)

        procedure TurnOnStrDist;
        var p12D,p22D: Point2D;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            p12D := center2D;
            p22D := grid2D;
            if hFixed then begin
                p12D.x := tlSz2D.x;
                p22D.x := brSz2D.x;
            end else if vFixed then begin
                p12D.y := tlSz2D.y;
                p22D.y := brSz2D.y;
            end;
            TurnOnDist(thisObj^.oDat.kind,p12D,p22D);
        end; (* TurnOnStrDist *)

    (* ***************************************************************** *)

        procedure TrkStrDist;
        var this2D: Point2D;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            this2D := grid2D;
            if hFixed then
                this2D.x := brSz2D.x
            else if vFixed then
                this2D.y := brSz2D.y;
            TrkDist(this2D);
        end; (* TrkStrDist *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC} (* StrSelCmd *)
        if traceTrk or traceCmd then with gridPt do
            Writeln('StrSelCmd(',h:2,',',v:2,')');

        (* turn knob off for feedback *)
        knobPt := wrkPt;
        XorKnob(knobPt);

        ShowObjSize(thisObj);

        if StartTrk then begin
            CommitLastOp;
            if NOT ObjLocked(thisObj) then begin
                (* check to see if there is room to handle trfo object *)
                if ExpTrfoMem(iCItmStr) then begin
                    (* see if we are stretching a single SLin *)
                    if curDoc.sLst^^.sState=iObjSLin then begin
                        (* get min size constraint *)
                        with curDoc.atr do

                        (* draw ghost *)
                        HideDist;
                        ReDrwSel;

                        (* get center of stretch *)
                        tObj := CurSelObj(1);
                        sLinObj := tObj^;
                        with sLinObj.oDat do
                        if thisKnob=1 then
                            center2D := p2
                        else
                            center2D := p1;
                        WldToScrn(center2D,centerPt);

                        (* set up size around center *)
                        TurnOnDist(iObjSLin,center2D,grid2D);

                        (* always track with black *)
                        penPats[iPenWhite] := black;

                        (* track the mouse *)
                        while StillDown do begin
                            lastPt := gridPt;
                            GetWrkMse;
                            TrkDist(grid2D);
                            if not EqualPt(lastPt,gridPt) or NeedScroll then
                                MkStrSLin;
                        end;
                        if PeekPt then
                            MkStrSLin;

                        (* finish stretch *)
                        penPats[iPenWhite] := white;
                        TurnOffDist;
                        if not EqualPt(anchorPt,gridPt) then begin
                            (* set lastOp *)
                            with sLinObj.oDat do
                            if thisKnob=1 then
                                center2D := p1
                            else
                                center2D := p2;
                            With lastOp do begin
                                iDat1 := thisKnob;
                                rDat1 := center2D.x;
                                rDat2 := center2D.y;
                            end;
                            SetLastOp(iOpSt1);
                            dupCtrFlag := OFF;
                        end else
                            SetLastOp(iOpNOP);
                        ReShowSel;

                    (* stretch other than single line *)
                    end else begin
                        (* set up stretch *)

                        (* get center of stretch *)
                        CnstrObj(thisObj);
                        WldToScrn(center2D,centerPt);

                        (* set up stretching parameters *)
                        dxStart := grid2D.x-center2D.x;
                        dyStart := grid2D.y-center2D.y;
                        if dxStart=0 then dxStart := 1;
                        if dyStart=0 then dyStart := 1;
                        xScale := 1.0;
                        yScale := 1.0;

                        (* get stretch limits *)
                        (* find farthest most stretchable point from center2D *)
                        GetSGBox(curDoc.sLst,gRect);
                        GetLimit(gRect.topLeft,lmtRect);
                        GetLimit(gRect.botRight,gRect);
                        dummyFlag := SectRect(lmtRect,gRect,lmtRect);
                        (* grid lmtRect, making sure that it is inset *)
                        lastPt := lmtRect.topLeft;
                        GridPoint(lastPt);
                        with lmtRect do begin
                            if lastPt.h<left then
                                left := lastPt.h+Round(curDoc.atr.grdSz2D.x);
                            if lastPt.v<top  then
                                top := lastPt.v+Round(curDoc.atr.grdSz2D.y);
                        end;
                        lastPt := lmtRect.botRight;
                        GridPoint(lastPt);
                        with lmtRect do begin
                            if lastPt.h>right then
                                right := lastPt.h-Round(curDoc.atr.grdSz2D.x);
                            if lastPt.v>bottom then
                                bottom := lastPt.v-Round(curDoc.atr.grdSz2D.y);
                        end;
                        SetMseLmt(lmtRect);

                        (* draw sel ghost *)
                        HideDist;
                        EraseSel;

                        (* copy curSel into temp sel *)
                        GetTSel(thisObj,tempSLst);

                        (* set up size around center *)
                        TurnOnStrDist;

                        (* wait 1/5 sec before start tracking *)
                        waitFlag := TRUE;
                        startFlag := TRUE;

                        (* always track in black *)
                        penPats[iPenWhite] := black;

                        (* track the stretch *)
                        while StillDown do begin
                            if waitFlag then begin
                                thisTime := Time;
                                repeat
                                    (* do Nothing *)
                                until Time > thisTime+5;
                                waitFlag := FALSE;
                            end;
                            GetWrkMse;
                            TrkStrDist;
                            if not EqualPt(lastPt,gridPt)
                            or NeedScroll or startFlag then begin
                                lastPt := gridPt;
                                MkStrSel;
                                thisTime := Time;
                            end else if Time>thisTime+5 then begin
                                (* dragging has stopped for > 1/20 sec *)
                                (* wait until dragging starts again *)
                                repeat
                                    GetWrkMse;
                                until NOT (EqualPt(lastPt,gridPt) AND StillDown);
                                (* erase the ghost *)
                                DrawTSel(tempSLst);
                                (* wait 1/20 sec before starting *)
                                waitFlag  := TRUE;
                                startFlag := TRUE;
                            end;
                        end;
                        if PeekPt then
                            MkStrSel;

                        (* erase the ghost *)
                        if NOT startFlag then
                            DrawTSel(tempSLst);
                        (* finish stretch *)
                        penPats[iPenWhite] := white;
                        FreeTSel(tempSLst);
                        TurnOffDist;
                        if not EqualPt(anchorPt,gridPt) then begin
                            (* set lastOp *)
                            ResetEdit;
                            With lastOp do begin
                                rDat1 := xScale;
                                rDat2 := yScale;
                                rDat3 := center2D.x;
                                rDat4 := center2D.y;
                            end;
                            SetLastOp(iOpStr);
                            dupCtrFlag := OFF;
                        end else
                            SetLastOp(iOpNOP);
                        ReShowSel;
                        SetMseLmt(sizeLBox);
                    end;
                end;
            end else begin
                (* object to stretch is locked *)
                GEAlert(iStopLock);
                (* turn knob back on *)
                XorKnob(knobPt);
            end;
        end else
            (* turn knob back on *)
            XorKnob(knobPt);

        TurnOffDist;
    end; (* StrSelCmd *)

(* ********************************************************************* *)

(* Moving Routines *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure MoveSelCmd(* thisObj: TObjPtr *);
    var last2D:    Point2D;
        lastPt:    Point;
        thisPt:    Point;
        lmtRect:   Rect;
        gRect:     Rect;
        xMove:     Real;
        yMove:     Real;
        tObj,sObj: TObjPtr;

        thisTime:  LongInt;
        waitFlag:  Boolean;
        startFlag: Boolean;

        tempSLst:  TSelHnd;

        (* for setting half grid text moves *)
        svGrdFlag: Boolean;
        svGrd2D:   Point2D;
        tSel:      TSelLst;
        i:         Integer;

    (* ***************************************************************** *)

        procedure MovTSel;
        var i: Integer;
            oldXM,oldYM,xDM,yDM: Real;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            oldXM := xMove;
            oldYM := yMove;
            xMove := grid2D.x-last2D.x;
            yMove := grid2D.y-last2D.y;
            xDM := xMove-oldXM;
            yDM := yMove-oldYM;
            for i := 1 to tempSLst^^.sCnt do
                OffsetObj(GetSelObj(tempSLst,i),xDM,yDM);
        end; (* MovTSel; *)

    (* ***************************************************************** *)

        procedure MkMovSel;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            (* erase sel *)
            if NOT startFlag then
                DrawTSel(tempSLst);
            startFlag := FALSE;
            (* stretch sel *)
            MovTSel;
            (* draw sel *)
            AutoScroll(FALSE);
            DrawTSel(tempSLst);
        end; (* MkMovSel *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC} (* MoveSel *)
        if traceTrk or traceCmd then with anchorPt do
            Writeln('MoveSelCmd(',h:2,',',v:2,')');

        ResetTxt;

        (* set up move *)
        lastPt := gridPt;
        last2D := grid2D;

        (* select clicked on object *)
        if (thisObj^.cSel=iSelNil) then begin
            ResetEdit;
            ResetCurSel;
            tObj := CkObjTrfo(thisObj);
            SetCurSel(tObj,iSelNml);
        end else if curDoc.edtState<>iObjNil then begin
            (* Reset EditState *)
            GetBBox(curDoc.edtObj);
            curDoc.edtStart := FALSE;
        end;

        ShowObjSize(thisObj);

        (* move selection *)
        if StartTrk then begin
            CommitLastOp;
            if NOT ObjLocked(thisObj) then begin
                (* check to see if there is room to handle trfo object *)
                if ExpTrfoMem(iCItmMov) then begin
                    (* if grid is on and sel is text then allow half-grid moves *)
                    svGrdFlag := FALSE;
                    if curDoc.atr.grdOn then begin
                        (* see if the selection is entirely text *)
                        svGrdFlag := TRUE;
                        tSel := curDoc.sLst^^;
                        for i := 1 to tSel.sCnt do begin
                            sObj := CurSelObj(i);
                            if sObj^.oDat.kind<>iObjText then begin
                                i := tSel.sCnt;
                                svGrdFlag := FALSE;
                            end;
                        end;
                        if svGrdFlag then begin
                            svGrd2D := curDoc.atr.grdSz2D;
                            curDoc.atr.grdSz2D.x := curDoc.atr.grdSz2D.x/2;
                            curDoc.atr.grdSz2D.y := curDoc.atr.grdSz2D.y/2;
                        end;
                    end;

                    TurnOffDist;
                    (* limit move to sizeLBox *)
                    GetSGBox(curDoc.sLst,gRect);
                    SetRect(lmtRect,gridPt.h-gRect.left  +sizeLBox.left,
                                    gridPt.v-gRect.top   +sizeLBox.top,
                                    gridPt.h-gRect.right +sizeLBox.right-1,
                                    gridPt.v-gRect.bottom+sizeLBox.bottom-1);
                    SetMseLmt(lmtRect);
                    xMove := 0;
                    yMove := 0;

                    (* draw sel ghost *)
                    EraseSel;

                    GetTSel(thisObj,tempSLst);

                    (* wait 1/5 sec before start tracking *)
                    waitFlag := TRUE;
                    startFlag := TRUE;

                    (* always track in black *)
                    penPats[iPenWhite] := black;

                    (* track the move *)
                    while StillDown do begin
                        if waitFlag then begin
                            thisTime := Time;
                            repeat
                                (* do Nothing *)
                            until Time > thisTime+5;
                            waitFlag := FALSE;
                        end;

                        GetWrkMse;
                        if not EqualPt(lastPt,gridPt)
                        or NeedScroll or startFlag then begin
                            lastPt := gridPt;
                            MkMovSel;
                            thisTime := Time;
                        end else if Time>thisTime+5 then begin
                            (* dragging has stopped for > 1/20 sec *)
                            (* wait until dragging starts again *)
                            repeat
                                GetWrkMse;
                            until not (EqualPt(lastPt,gridPt) AND StillDown);
                            (* erase the ghost *)
                            DrawTSel(tempSLst);
                            (* wait 1/20 sec before starting *)
                            waitFlag  := TRUE;
                            startFlag := TRUE;
                        end;
                    end;
                    if PeekPt then
                        MkMovSel;

                    (* if grid is on and sel is text then allow half-grid moves *)
                    if svGrdFlag then
                        curDoc.atr.grdSz2D := svGrd2D;

                    (* erase the ghost *)
                    if NOT startFlag then
                        DrawTSel(tempSLst);
                    (* finish move *)
                    penPats[iPenWhite] := white;
                    FreeTSel(tempSLst);
                    if not EqualPt(anchorPt,gridPt) then begin
                        (* set lastOp *)
                        With lastOp do begin
                            rDat1 := xMove;
                            rDat2 := yMove;
                        end;
                        SetLastOp(iOpMov);
                        with dupSame2D do begin
                            x := x+xMove;
                            y := y+yMove;
                        end;
                        (* check for text *)
                        if curDoc.sLst^^.sState=iObjText then
                            if curDoc.fldSet then
                                if thisObj=curDoc.txtObj then
                                    TxtMove(xMove,yMove);
                    end else
                        SetLastOp(iOpNOP);
                    ReShowSel;
                    SetMseLmt(sizeLBox);
                end;
            end else (* object to move is locked *)
                GEAlert(iStopLock);
        end;
        TurnOffDist;
    end; (* MoveSelCmd *)

(* ********************************************************************* *)

(* Selecting Routines *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure GetSel( r: Rect);
    var thisObj,trfObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if TraceCmd then
            WlnRect('GetSel:',r);

        {InitSLst(tObjSLst);  not necessary because always done after it is used.}
        (* find hit objects *)
        if ((abs(r.left-r.right) < zoomKnobSz.h)
        AND ((r.bottom-r.top) < zoomKnobSz.v)) then begin
            (* find topmost object near pt *)
            if PtOnObj(r.topLeft,thisObj) then
                AddToSEnd(tObjSLst,thisObj);
        end else begin
            (* find all obj's that have bBox entirely within rect *)
            ResetOLst(ilDirFwd,thisObj);
            while thisObj<>NIL do begin
                with thisObj^.bBox do
                if PtInRect(topLeft,r) then
                    if PtInRect(botRight,r) then
                        AddToSEnd(tObjSLst,thisObj);
                GetNxtObj(ilDirFwd,thisObj);
            end;
        end;
    end; (* GetSel *)


    (* ********************************************************************* *)
(*$S Core2*)
    procedure MakeSelCmd(* shFlag,objFlag,noVrtSelected: Boolean *);
    var thisTime: LongInt;
        sStateOn: Boolean;
        lastPt:   Point;
        thisObj:  TObjPtr;
        hvMoved:  Boolean;
        selRect:  Rect;
        i:        Integer;

    (* ********************************************************************* *)

        procedure GetVrtSel;
        Var i: Integer;
            thisPt2D: Point2D;
            thisObj: TObjPtr;
            pt: Point;
        begin
            {$IFC sampcalls} ALogCall; {$ENDC}
            {$R-}
            thisObj := CkObjTrfo(curDoc.edtObj);
            With newVrtLst^^,thisObj^.oDat.cLst^^ do begin
                vCnt := crdCnt;
                For i := 0 to crdCnt do
                    vertex[i] := -1;
                If ((selRect.right-selRect.left) < zoomKnobSz.h) AND
                   ((selRect.bottom-selRect.top) < zoomKnobSz.v) then begin
                   For i := 0 to crdCnt do begin
                       thisPt2D := c2DLst[i];
                       If (Abs(thisPt2D.x-selRect.left) < zoomKnobSz.h) AND
                           (Abs(thisPt2D.y - selRect.top) < zoomKnobSz.v)
                           then begin
                           vertex[i] := 1;
                           noVrtSelected := FALSE;
                       end;
                   end;
                end else begin
                    For i := 0 to crdCnt do begin
                        WldToScr(c2DLst[i],pt);
                        If PtInRect(pt,selRect) then begin
                            vertex[i] := 1;
                            noVrtSelected := FALSE;
                        end;
                    end;
                end;
                If sgnVrtFlag then begin   {Leave only first one on}
                    i := 0;
                    While (vertex[i] = -1) AND (i <= crdCnt) do   {Find first one on}
                        i := i + 1;
                    i := i + 1;
                    If i<=crdCnt then
                        noVrtSelected := FALSE;
                    While i <= crdCnt do
                        vertex[i] := -1;     {Turn rest off}
                end;
            end;
            {$IfC rangeOn} {$R+} {$EndC}
        end;{GetVrtSel}

    (* ********************************************************************* *)

    begin {MakeSelCmd}
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceTrk or traceCmd then
            Writeln('MakeSelCmd(',shFlag,')');
        noVrtSelected := TRUE;
        anchor2D := wrk2D;
        anchorPt := wrkPt;
        with wrkPt do
        SetRect(selRect,h,v,h,v);
        PenNormal;
        PenMode(patXor);
        (* set up blinking *)
        thisTime := Time+5;
        sStateOn := FALSE;
        (* remember if haveMoved *)
        hvMoved := FALSE;

        (* drag blinking selRect *)
        if StartTrk then begin
            (* set up selRect *)
            SetStdCursor(iCrsLFinger);
            (* set up dist *)
            TurnOnDist(iObjRect,grid2D,grid2D);
            hvMoved := TRUE;
            while StillDown do begin
                lastPt := wrkPt;
                GetWrkMse;
                TrkDist(grid2D);
                if not EqualPt(lastPt,gridPt) or NeedScroll then begin
                    (* erase old selRect *)
                    if sStateOn then
                        FrameRect(selRect);
                    AutoScroll(TRUE);
                    (* get new selRect *)
                    Pt2Rect(wrkPt,anchorPt,selRect);
                    (* Draw new selRect *)
                    GEMapRect(selRect);
                    FrameRect(selRect);
                    sStateOn := TRUE;
                end else if Time>thisTime then begin
                    FrameRect(selRect);
                    sStateOn := not sStateOn;
                    thisTime := Time+5;
                end;
            end;
            TurnOffDist;
            (* erase selRect *)
            if sStateOn then
                FrameRect(selRect);
            if PeekPt then
                Pt2Rect(wrkPt,anchorPt,selRect);
            (* FinishSel *)
            SetStdCursor(iCrsInactive);
        end;

        (* calculate new selection *)

        Pt2Rect(wrkPt,anchorPt,selRect);

        If objFlag then begin   {object selcetion}
            ResetTxt;
            ResetEdit;
            GetSel(selRect);
            If shFlag then begin
                (* unHilite the selection *)
                HiliteSel(OFF);
                (* toggle the value of the selection *)
                For i := 1 to tObjSLst^^.sCnt do begin
                    thisObj := GetSelObj(tObjSLst,i);
                    If thisObj^.cSel<>iSelNil then
                        thisObj^.cSel := iSelNil
                    else
                        thisObj^.cSel := iSelNml;
                end;
                (* put all objects that are selected into curSel *)
                InitSLst(curDoc.sLst);
                ResetOLst(ilDirFwd,thisObj);
                While thisObj<>NIL do begin
                    If thisObj^.cSel=iSelNml then
                        AddToSEnd(curDoc.sLst,thisObj);
                    GetNxtObj(ilDirFwd,thisObj);
                end;
                (* turn on hilite *)
                HiliteSel(ON);
                InitSLst(tObjSLst);
                dupCtrFlag := OFF;
            end else begin
                (* unmark and turn off hilite *)
                ResetCurSel;
                (* copy selection to curSel *)
                CopySLst(tObjSLst,curDoc.sLst);
                (* shrink tObjSLst *)
                InitSLst(tObjSLst);
                (* mark and turn on hilite *)
                MarkCSel(curDoc.sLst,iSelNml);
                HiliteSel(ON);
                If (not hvMoved) and (curDoc.sLst^^.sState=iObjNil) then begin
                    pasteState := TRUE;
                    pastePt    := anchorPt;
                end;
            end;
        end else begin   {Vertex selection}
            GetVrtSel;
            (* unHilite the selection *)
            HiliteVrtSel(FALSE,TRUE);
            if shFlag then begin
                (* toggle the value of the selection *)
                For i := 0 to curVrtLst^^.vCnt do
                    If newVrtLst^^.vertex[i]=1 then
                        curVrtLst^^.vertex[i] := -curVrtLst^^.vertex[i];
            end else begin
                (* copy selection to curSel *)
                For i := 0 to curVrtLst^^.vCnt do
                    curVrtLst^^.vertex[i] := newVrtLst^^.vertex[i];
            end;
            (* turn on hilite *)
            HiliteVrtSel(FALSE,TRUE);
            dupCtrFlag := OFF;
        end;
    end; (* MakeSelCmd *)

(* ********************************************************************* *)

(* miscellaneous *)

(* ********************************************************************* *)
(*$S Init*)

    procedure InitTrk;
    var i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('InitTrk');
        (* init pastePt *)
        pasteState := FALSE;
        (* set up tracking *)
        with trackObj do begin
            fLink := NIL;
            bLink := NIL;
        end;

        (* arc quadrant *)
        arcQuad[FALSE,FALSE,FALSE] := 0;
        arcQuad[FALSE,FALSE, TRUE] := 1;
        arcQuad[FALSE, TRUE,FALSE] := 3;
        arcQuad[FALSE, TRUE, TRUE] := 2;
        arcQuad[ TRUE,FALSE,FALSE] := 2;
        arcQuad[ TRUE,FALSE, TRUE] := 3;
        arcQuad[ TRUE, TRUE,FALSE] := 1;
        arcQuad[ TRUE, TRUE, TRUE] := 0;
    end; (* InitTrk *)


ÿ