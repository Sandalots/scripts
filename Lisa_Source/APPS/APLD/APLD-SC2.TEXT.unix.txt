(* ********************************************************************* *)

(* CopyRight 1983, Apple Computer Inc. *)
(* GE Unit SCR Include File - Sel Display, Prototype, Drawing Aids,      *)
(*                            Folder Display, and Misc Routines          *)

(* ********************************************************************* *)

(* Prototype Objects *)


(* ********************************************************************* *)
(*$S Ring*)
    procedure GetPRect(* index: Integer; var r: Rect *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetRect(r,0,0,protoWidth-1,protoHeight-1);
        OffSetRect(r,protoBox.left+1,protoBox.top+1+index*protoHeight);
    end; (* GetPRect *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure HLProto(index: Integer);
    var thisRect: Rect;
        thisPen: PenState;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* set up *)
        SetFldrOrigin;
        GetPenState(thisPen);
        PenPat(ltgray);
        PenMode(patXor);
        (* hilite *)
        GetPRect(index,thisRect);
        PaintRect(thisRect);
        (* restore *)
        SetPenState(thisPen);
        SetWrkOrigin;
    end; (* HLProto *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure ErsPHL;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if pHLStateOn then begin
            HLProto(pHLIndex);
            pHLStateOn := FALSE;
        end;
    end; (* HLProtoOff *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure HiLiteProto(index: Integer);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if (pHLIndex<>index) or not pHLStateOn then begin
            ErsPHL;
            pHLIndex := index;
            HLProto(pHLIndex);
            pHLStateOn := TRUE;
        end;
    end; (* HiLiteProto *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure BlinkProto(* index: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if pHLStateOn then begin
            ErsPHL;
            pHLIndex := index;
        end else
            HiLiteProto(index);
    end; (* BlinkProto *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure ShowProto(* index: Integer; showHiLite: Boolean *);
    var sPt1,sPt2: Point2D;
        x,y:      Real;
        thisRect: Rect;
        arwBMp:   BitMap;
        thisPat:  Integer;
        zoomWasOn: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('ShowProto(',index:2,showHiLite,')');

        zoomWasOn := curDoc.atr.zoomOn;
        curDoc.atr.zoomOn := 0;
        (* reset blinking hilite *)
        pHLStateOn := FALSE;
        (* set main coords *)
        SetFldrOrigin;
        (* clip to proto bBox *)
        GetPRect(index,thisRect);
        thisRect.bottom := CMin(thisRect.bottom,protoBox.bottom-1);

        ClipRect(thisRect);
        FillRect(thisRect,white);
        if fActive then
            if showHiLite then
                if index=curDoc.proto then
                    FillRect(thisRect,ltGray);

        (* draw the proto *)
        if index = iObjNil then begin
            (* set up bitMap *)
            with arwBMp do begin
                rowBytes := 2;
                SetRect(bounds,0,0,16,16);
                with protoObj[iObjNil].bBox do
                    OffsetRect(bounds,left+((right-left-8)div 2),
                                      top+((bottom-top-16)div 2));
                baseAddr := @arrow.data;
            end;
            (* blt bits *)
            with arwBMp do
                CopyBits(arwBMp,curDoc.fldr^.portBits,bounds,bounds,srcOr,NIL);
                {replacing
                XferRect(arwBMp,curDoc.fldr^.portBits,bounds,bounds,srcOr,black);}
        end else if index = iObjRLin then with protoObj[iObjRLin].oDat do begin
            protoObj[iObjRLin].oDat.inf.dat := curDoc.arrw[iObjRLin];
            (* save original points *)
            sPt1 := p1;
            sPt2 := p2;
            (* get x and y rLine coordinates *)
            with penSizes[inf.pnSiz] do begin
                x := (p1.x+p2.x-h) / 2;
                y := (p1.y+p2.y-v) / 2;
            end;
            (* draw vertical line *)
            SetPt2D(p1,x,sPt1.y);
            SetPt2D(p2,x,sPt2.y);
            ShowObj(@protoObj[index]);
            (* draw horizontal line *)
            SetPt2D(p1,sPt1.x,y);
            SetPt2D(p2,sPt2.x,y);
            ShowObj(@protoObj[index]);
            (* restore original points *)
            p1 := sPt1;
            p2 := sPt2;
        end else if index=iObjText then begin
            TxtSetFmt(@protoObj[iObjText],curDoc.fid);
            TextMode(srcOr);
            DrwObj(@protoObj[iObjText]);
            TextMode(srcXor);
            if index=iObjText then
                DrwCaret(txtLoc[curDoc.align],protoObj[iObjText].bBox);
        end else begin
            protoObj[iObjSLin].oDat.inf.dat := curDoc.arrw[iObjSLin];
            ShowObj(@protoObj[index]);
        end;

        (* restore *)
        SetWrkOrigin;
        curDoc.atr.zoomOn := zoomWasOn;
    end; (* ShowProto *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure SetCurProto(* index: Integer; showHiLite: Boolean *);
    var thisObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        ResetPoly;
        if index<>curDoc.proto then begin
            if showHiLite then begin
                ShowProto(curDoc.proto,FALSE);
                curDoc.proto := index;
                ShowProto(curDoc.proto,TRUE);
            end;
            curDoc.proto := index;
            ShowCurPen(curDoc.proto);
            geCrsCur := geCrsVal[curDoc.proto];
            if curDoc.proto=iObjNil then
                if curDoc.sLst^^.sState=iSStPrt then
                    curDoc.sLst^^.sState := iObjNil;
        end;
    end; (* SetCurProto *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure GetProto(* index: Integer; obj: TObjPtr *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        obj^ := protoObj[index];
        with obj^.oDat.inf do begin
            flPat := curDoc.fill[index];
            bgClr := curDoc.fillClr[index];
            fgClr := curDoc.pnClr;
            if index=iObjText then
                tDat := curDoc.align
            else begin
                pnSiz := curDoc.pnSiz;
                pnPat := curDoc.pnPat;
                if index=iObjRndR then
                    dat := curDoc.rndR
                else if (index=iObjRLin) or (index=iObjSLin) then
                    dat := curDoc.arrw[index];
            end;
        end;
    end; (* GetProto *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure DrwProtoBox(r: Rect);
    var i: Integer;
        thisR: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            WLnRect('DrwProtoBox',r);

        if SectRect(protoBox,r,thisR) then begin
            (* set up *)
            SetFldrOrigin;
            ClipRect(thisR);
            (* draw proto Box *)
            PenNormal;
            FillRect(protoBox,white);
            FrameRect(protoBox);
            (* reset HiLite ctrl flag since filled over it with white *)
            pHLStateOn := FALSE;
            (* draw proto shape boxes *)
            for i := iProtoFirst to iProtoLast do begin
                MoveTo(protoBox.left,protoBox.top+(i+1)*protoHeight);
                Line(protoWidth,0);
            end;
            (* draw prototypes *)
            for i := iProtoFirst to iProtoLast do begin
                GetPRect(i,thisR);
                if SectRect(thisR,r,thisR) then
                    ShowProto(i,fActive);
            end;
            (* restore *)
            PenMode(patXor);
            ShowCurPen(curDoc.proto);
        end;
    end; (* DrwProtoBox *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure ShowCurPen(* index: Integer *);
    var thisSize: Point;
        thisRect: Rect;
        thisV,thisPat: Integer;
        thisPen: PenState;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if fActive then begin
            (* set clip *)
            SetFldrOrigin;
            ClipRect(penBox);
            (* erase penBox *)
            FillRect(penBox,White);
            if index<>iObjNil then begin
                GetPenState(thisPen);
                (* draw line *)
                if index<>iObjText then begin
                    PenNormal;
                    thisSize := penSizes[curDoc.pnSiz];
                    PenSize(thisSize.h,thisSize.v);
                    PenPat(penPats[curDoc.pnPat]);
                    (* draw curPen line *)
                    if curDoc.pnPat=iPenWhite then
                        FillRect(penBox,black);
                    (* draw curPen line *)
                    with penBox do begin
                        thisV := top+((bottom-top-thisSize.v) Div 2);
                        MoveTo(left,thisV);     {penpat NONE is ok here because
                                                 it will be white one white}
                        LineTo(right,thisV);
                    end;
                end;
                (* draw pattern *)
                if NOT (index in [iObjRLin,iObjSLin]) then begin
                    thisRect := penBox;
                    if index<>iObjText then with thisRect do
                        left := (right+left+1) Div 2;
                    thisPat := curDoc.fill[index];
                    FillRect(thisRect,fillPats[thisPat]);
                    PenNormal;
                    InsetRect(thisRect,-1,-1);
                    FrameRect(thisRect);
                    if thisPat=iFillClear then with thisRect do begin
                        TextFont(tile12);
                        TextFace([bold]);
                        MoveTo((left+right-CharWidth(clearCh))Div 2, bottom-4);
                        DrawChar(clearCh);
                    end;
                end;
                (* restore pen *)
                SetPenState(thisPen);
            end;
            (* restore clip *)
            SetWrkOrigin;
        end;
    end; (* ShowCurPen *)

(* ********************************************************************* *)

(* Distace *)

(* ********************************************************************* *)
(*$S DeBug*)
    procedure TrkPxlDist(* thisPt: Point *);
    var n1,n2: String6;
        s: String80;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if pxlDist then
            if NOT EqualPt(thisPt,pxlPt) then begin
                (* set up *)
                SetFldrOrigin;
                pxlPt := thisPt;
                (* erase penBox *)
                FillRect(penBox,White);
                (* get strings *)
                IntToStr(thisPt.h,n1);
                IntToStr(thisPt.v,n2);
                s := Concat(n1,',',n2);
                (* draw number strings *)
                TextFont(p15tile);
                TextFace([]);
                TextMode(srcOr);
                with penBox do
                MoveTo((left+right-StringWidth(s)) div 2,top+12);
                DrawString(s);
                TextMode(srcXOr);
                (* restore clip state *)
                SetWrkOrigin;
            end;
    end; (* TrkPxlDist *)

(* ********************************************************************* *)
(*$S Core*)
    procedure DrwMDist;
    const
        p15tileHeight = 12;
    var
        myPt: Point;
        thisStr: String80;
        thisLoc: Point;
        bothHV:  Boolean;
        saveClip: RgnHandle;
        s1,s2:   String[1];
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* set clip *)
        myPt := mDistLoc;
        GEMapPt(myPt);
        saveClip := NewRgn;
        GetClip(saveClip);
        ClipRect(dwgLBox);
        (* set typestyle *)
        TextMode(srcXor);
        TextFont(p15tile);
        TextFace([]);
        (* see if we draw one or two numbers *)
        bothHV := NOT ((mDistKind=iObjRLin) OR (mDistKind=iObjSLin));
        (* set loc of first number *)
        if bothHV then begin
            s1 := ' ';
            s1[1] := Chr(28);
            s2 := ' ';
            s2[1] := Chr(29);
            thisStr := Concat(s1,' ',hMDistStr,' ',s2);
            SetPt(thisLoc,myPt.h+16,myPt.v);
        end else begin
            thisStr := hMDistStr;
            SetPt(thisLoc,myPt.h+20,myPt.v);
        end;
        (* draw the first number *)
        MoveTo(thisLoc.h,thisLoc.v);
        DrawString(thisStr);
        (* draw the second number *)
        if bothHV then begin
            SetPt(thisLoc,myPt.h{-24},myPt.v+p15TileHeight);
            s1 := ' ';
            s1[1] := Chr(30);
            s2 := ' ';
            s2[1] := Chr(31);
            MoveTo(thisLoc.h,thisLoc.v+4);
            DrawString(s1);
            MoveTo(thisLoc.h-10,
                   thisLoc.v+p15tileHeight);
            DrawString(vMDistStr);
            MoveTo(thisLoc.h,thisLoc.v-4+2*p15tileHeight);
            DrawString(s2);
        end;
        (* restore clip *)
        SetClip(saveClip);
        DisposeRgn(saveClip);
    end; (* DrwMDist *)

(* ********************************************************************* *)
(*$S Core*)
    procedure ErsMDist;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if mDistOn then begin
            DrwMDist;
            mDistOn := FALSE;
        end;
    end; (* ErsMDist *)

(* ********************************************************************* *)
(*$S Core*)
    procedure ShowMDist(xDist,yDist: Real; display: Boolean);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        ErsMDist;
        if display then begin
            GetDistStr(xDist,hMDistStr);
            GetDistStr(yDist,vMDistStr);
            mDistOn   := TRUE;
            mDistLoc  := gridPt;
            DrwMDist;
        end;
    end; (* ShowMDist *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure TrkDist(* lcl2D: Point2D *);
    const
        xInchFac  = 0.010416666;       (* 1/xInchDots *)
        yInchFac  = 0.015625;          (* 1/yInchDots *)
        xMtrcFac  = 0.026458333;       (* 1/xCMDots   *)
        yMtrcFac  = 0.0396875;         (* 1/yCMDots   *)
    var xDist,yDist,dist,scale: Real;
        rKind: Integer;
        sSpc:  Real;
        lclPt: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceTrk then begin
            Writeln('    TrkDist(',lcl2D.x:6:2,',',lcl2D.y:6:2,
                         ') kind=',mDistKind:2,
                         ', beg= ',mDistBeg.x:6:2,',',mDistBeg.y:6:2,
                         ', last=',mDistLast.x:6:2,',',mDistLast.y:6:2);
        end;
        WldToScrn(lcl2D,lclPt);
        if mDistKind<>iObjNil then
            if PtInRect(gridPt,dwgLBox) then
                if (lcl2D.x<>mDistLast.x) or (lcl2D.y<>mDistLast.y) then begin

                    mDistLast := lcl2D;
                    (* convert to inch or mtrc coords *)
                    (* get pixel distance *)
                    SubPt2D(mDistBeg,lcl2D);
                    (* get screen inches = pixels*(inches/pixel) *)
                    if curDoc.atr.rlrUnit=iUnitInch then begin
                        xDist := lcl2D.x*xInchFac;
                        yDist := lcl2D.y*yInchFac;
                    end else begin
                        xDist := lcl2D.x*xMtrcFac;
                        yDist := lcl2D.y*yMtrcFac;
                    end;
                    (* get virtual scale = numbering increments/major div spacing *)
                    with curDoc.atr do begin
                        if rlrOn then
                            rKind := rlrKind
                        else
                            rKind := iRlrStd;
                        with rlrFmts[rlrUnit,rKind] do begin
                            if rlrUnit=iUnitMtrc then
                                sSpc := iSpc
                            else
                                sSpc := rlrInfo[iSpc].spc;
                            scale := rlrInfo[iInc].inc/sSpc
                        end;
                    end;
                    (* get virtual inches = screen inches * virtual scale *)
                    xDist := xDist*scale;
                    yDist := yDist*scale;
                    if mDistKind=iObjRLin then begin
                        (* get the one-dimensional distance *)
                        if NOT trkHoriz then
                            xDist := yDist;
                    end else if mDistKind=iObjSLin then
                        (* get the diagonal distance *)
                        xDist := GESqrt(xDist*xDist+yDist*yDist);
                    (* draw the distance *)
                    ShowMDist(xDist,yDist,ON);
                end;
    end; (* TrkDist *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure HideDist;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        ShowMDist(0,0,OFF);
        SetPt2D(mDistLast,0,0);
    end; (* HideDist *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure TurnOnDist(* kind: Integer; beg2D,lcl2D: Point2D *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.atr.msrOn then
            if kind>iObjText then begin
                SetPt2D(mDistLast,0,0);
                mDistKind := kind;
                mDistBeg  := beg2D;
                TrkDist(lcl2D);
            end;
    end; (* TurnOnDist *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure TurnOffDist;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        HideDist;
        mDistKind := iObjNil;
    end; (* TurnOffDist *)

(* ********************************************************************* *)

(* SBar display *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure GetSBarRect(* who: GrafPtr; VAR hRect,vRect: Rect *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        vRect := who^.portRect;
        vRect.left := vRect.right-dhSBox+1;
        hRect := who^.portRect;
        hRect.top  := hRect.bottom-dvSBox+1;
    end; (* GetSBarRect *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure DrwDistBox;
    var thisRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetFldrOrigin;
        PenNormal;
        (* paint curPen *)
        thisRect := penBox;
        InsetRect(thisRect,-1,-1);
        FrameRect(thisRect);
        ShowCurPen(curDoc.proto);
        SetWrkOrigin;
    end; (* DrwDistBox *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure DrwGESBars(* r: Rect *);
    var hRect,vRect,thisRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GetSBarRect(curDoc.fldr,hRect,vRect);
        if SectRect(hRect,r,thisRect) or SectRect(vRect,r,thisRect) then begin
            (* drw the distance/curPen box *)
            DrwDistBox;
            (* scroll bars are in fldr coords *)
            SetFldrOrigin;
            (* make scroll boxes flush with portRect *)
            FlushRects(hSBox^^.r,vSBox^^.r);
            (* adjust hSBox to make room for penBox *)
            AdjSBCorner(hSBox,protoWidth,TRUE);

            (* paint scroll and grow boxes, least to greatest priority order *)
            ClipRect(curDoc.fldr^.portRect);
            PaintSB(hSBox);
            PaintSB(vSBox);
            PaintGrow;

            (* set wrkCoords *)
            PenMode(patXor);
            SetWrkOrigin;
        end;
    end; (* DrwGESBars *)

(* ********************************************************************* *)

(* Folder Display *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure GetScpRect(VAR r: Rect);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        r := scrapFolder^.portRect;
        with r do begin
            right := right-(dhSBox-1);
            bottom := bottom-(dvSBox-1);
        end;
    end; (* SetScrpRect *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure DrwScrpSBars(* r: Rect *);
    var hRect,vRect,thisRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GetSBarRect(scrapFolder,hRect,vRect);
        if SectRect(hRect,r,thisRect) or SectRect(vRect,r,thisRect) then begin
            ClipRect(scrapFolder^.portRect);
            (* make scroll boxes flush with portRect *)
            FlushRects(hSBoxScrp^^.r,vSBoxScrp^^.r);
            (* paint scroll and grow boxes, least to greatest priority order *)
            PaintSB(hSBoxScrp);
            PaintSB(vSBoxScrp);
            (* paint grow box *)
            PaintGrow;
        end;
    end; (* DrwScrpSBars *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure DrwScrpFldr;
    var sRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceFio then with scrapFolder^ do begin
            Writeln('DrwScrpFldr');
            WlnRgn('    vis= ',visRgn);
            WlnRgn('    clip=',clipRgn);
            WLnRect('    port=',portRect);
        end;

        (* show scrap contents *)
        GetScpRect(sRect);
        ShowScrap(sRect);
        (* show sBorder *)
        SetPort(scrapFolder);
        ClipRect(scrapFolder^.portRect);
        if sActive then
            DrwScrpSBars(scrapFolder^.visRgn^^.rgnBBox)
        else
            HideSBorder(scrapFolder^.portRect);
        SetPort(curDoc.fldr);
    end; (* DrwScrpFldr *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure DrwGEFldr;
    var vRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            WlnRect('DrwGEFldr, portRect:',curDoc.fldr^.portRect);

        (* draw folder relative *)
        SetFldrOrigin;
        (* only draw visible things *)
        if fActive then
            vRect := curDoc.fldr^.visRgn^^.rgnBBox
        else
            vRect := curDoc.fldr^.portRect;
        if fActive then
            DrwGESBars(vRect)
        else begin
            ClipRect(curDoc.fldr^.portRect);
            HideSBorder(curDoc.fldr^.portRect);
        end;
        DrwProtoBox(vRect);
        (* draw scroll relative *)
        SetWrkOrigin;
        If curDoc.atr.rlrOn then
            RedrawRlr;
        GEClipRect(wrkLBox);
        ReShow(wrkLBox);
    end; (* DrwGEFldr *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure CkGEUpdate;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        BeginUpdate(curDoc.fldr);
        if Not EmptyRgn(curDoc.fldr^.visRgn) then
            DrwGEFldr;
        EndUpdate(curDoc.fldr);
    end; (* CkGEUpdate *)

(* ********************************************************************* *)

(* Screen Layout *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure SetLclBox;
    var dummyFlag: Boolean;

        procedure LclBox(var r: rect);
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with wrkBox do
            OffsetRect(r,-left,-top);
            GEUnMapRect(r);
            with curDoc.atr.scrollPt do
            OffsetRect(r,h,v);
        end;

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* get offset *)
        wrkLBox    := wrkBox;
        topRlrLBox := topRlrBox;
        lftRlrLBox := lftRlrBox;
        zroRlrLBox := zroRlrBox;
        LclBox(wrkLBox);
        LclBox(topRlrLBox);
        LclBox(lftRlrLBox);
        LclBox(zroRlrLBox);

        (* local dwgBox *)
        dummyFlag := SectRect(wrkLBox,sizeLBox,dwgLBox);

        (* main dwgBox *)
        dwgBox := dwgLBox;
        with curDoc.atr.scrollPt do
        OffsetRect(dwgBox,-h,-v);
        GEMapRect(dwgBox);
        with wrkBox do
        OffsetRect(dwgBox,left,top);
    end; (* SetLclBox *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure SetGEBox(* ckWrkRef: Boolean *);
    var fldrRect,uRect: Rect;
        thisPt: Point;

        (* SetZoom *)
        dwgRatio,portRatio,wrkRatio: Real;
        oldZoom,wrkSz,zoomFit: Point;

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetFldrOrigin;
        fldrRect := curDoc.fldr^.portRect;
        (* work box *)
        wrkBox := fldrRect;
        wrkBox.left := protoWidth;
        with wrkBox do begin
            right := right-(dhSBox-1);
            bottom := bottom-(dvSBox-1);
        end;
        if curDoc.atr.rlrOn then
            AddPt(rlrSize,wrkBox.topLeft);
        (* dist box *)
        SetRect(penBox,0,2-dvSBox,protoWidth-1,0);
        with fldrRect do
        OffsetRect(penBox,left,bottom);
        (* proto box *)
        SetRect(protoBox,-1,-1,protoWidth,penBox.top);
        (* rulers *)
        with rlrSize do begin
            SetRect(zroRlrBox,protoWidth,0,protoWidth+h,v);
            SetRect(topRlrBox,protoWidth+h,0,wrkBox.right,v);
            SetRect(lftRlrBox,protoWidth,v,protoWidth+h,wrkBox.bottom);
        end;

        (* SetZoom *)
        if curDoc.atr.zoomOn=0 then
            curDoc.atr.zoomSz := curDoc.atr.dwgSz
        else with curDoc.atr do begin
            oldZoom  := zoomSz;
            dwgRatio := dwgSz.v / dwgSz.h;
            wrkSz    := wrkBox.botRight;
            SubPt(wrkBox.topLeft,wrkSz);
            wrkRatio := wrkSz.v / wrkSz.h;
            zoomFit  := wrkSz;
            if dwgRatio<wrkRatio then
                (* fit v direction *)
                zoomFit.v := Round(zoomFit.h*dwgRatio)
            else
                (* fit h direction *)
                zoomFit.h := Round(zoomFit.v/dwgRatio);
            if curDoc.atr.zoomOn=1 then begin
                SetPt(curDoc.atr.scrollPt,0,0);
                zoomSz := zoomFit;
            end else if curDoc.atr.zoomOn=2 then begin
                zoomSz.h := CMax(zoomFit.h,zoomSz.h);
                zoomSz.v := CMax(zoomFit.v,zoomSz.v);
            end;
            if NOT EqualPt(oldZoom,zoomSz) then
                InvalRect(curDoc.fldr^.portRect);
        end; (* SetZoom *)
        (* zoom rects *)
        sizeLBox.botRight := curDoc.atr.dwgSz;
        zoomSrcR.botRight := curDoc.atr.dwgSz;
        zoomDstR.botRight := curDoc.atr.zoomSz;
        (* zoom knob *)
        SetPt(zoomKnobSz,hKnob,vKnob);
        GEUnMapPt(zoomKnobSz);

        (* local boxes *)
        SetLclBox;
        (* make sure that excessive gray is not exposed at botRight *)
        if ckWrkRef then begin
            thisPt := curDoc.atr.scrollPt;
            CkScrollPt;
            if NOT EqualPt(thisPt,curDoc.atr.scrollPt) then begin
                SetLclBox;
                SetOrigin(0,0);
                uRect := fldrRect;
                uRect.botRight := wrkBox.botRight;
                InvalRect(uRect);
            end;
        end;
        (* restore Origin *)
        SetWrkOrigin;
        (* make sure thumb pos is set properly *)
        SetThumb(hSBox,DwgThumbPos(iDirLft));
        SetThumb(vSBox,DwgThumbPos(iDirTop));
    end; (* SetGEBox *)

(* ********************************************************************* *)
(*$S DeBug*)

    procedure DumpGEBox;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (*$IfC traceOn *)
        writeln('GE Screen Boxes:');
        with curDoc.atr.scrollPt do
        writeln('    curDoc.scrollPt: ',h:2,',',v:2);
        WLnRect('    fldrRect: ',curDoc.fldr^.portRect);
        WLnRect('    protobox: ',protoBox);
        WLnRect('    wrkBox:   ',wrkBox  );
        WLnRect('    dwgBox:   ',dwgBox  );
        WLnRect('    penBox:   ',penBox );
        WLnRect('    zroRlrBox:',zroRlrBox);
        WLnRect('    topRlrBox:',topRlrBox);
        WLnRect('    lftRlrBox:',lftRlrBox);
        writeln;
        WLnRect('    sizeLBox: ',sizeLBox);
        WLnRect('    wrkLBox:  ',wrkLBox );
        WLnRect('    dwgLBox:  ',dwgLBox );
        WLnRect('    zroRlrLBox:',zroRlrLBox);
        WLnRect('    topRlrLBox:',topRlrLBox);
        WLnRect('    lftRlrLBox:',lftRlrLBox);
        writeln;
        WlnRect('    zoomSrcR:  ',zoomSrcR);
        WlnRect('    zoomDstR:  ',zoomDstR);
        Writeln('    zoomKnob:  ',zoomKnobSz.h:4,',',zoomKnobSz.v:4);
        writeln;
        writeln('curDoc.atr:');
        with curDoc.atr do begin
            writeln('    dwgSz:  ',dwgSz.h:4,',',dwgSz.v:4);
            writeln('    zoomSz: ',zoomSz.h:4,',',zoomSz.v:4);
            writeln('    pageSz: ',pageSz.h:4,',',pageSz.v:4);
            writeln('    grdSz2D:',grdSz2D.x:7:2,',',grdSz2D.y:7:2);
            writeln('    tckSz2D:',tckSz2D.x:7:2,',',tckSz2D.y:7:2);
        end;
        (*$EndC *)
    end; (* DumpGEBox *)

(* ********************************************************************* *)
(*$S Core2*)

    procedure SetFldrOrigin;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetPort(curDoc.fldr);
        SetOrigin(0,0);
        ClipRect(curDoc.fldr^.portRect);
    end; (* SetFldrOrigin *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure SetWrkOrigin;
    var scrnPt: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetPort(curDoc.fldr);
        scrnPt := curDoc.atr.scrollPt;
        GEMapPt(scrnPt);
        with scrnPt do
            SetOrigin(h-wrkBox.left,v-wrkBox.top);
        GEClipRect(dwgLBox);
        PenMode(patXor);
    end; (* SetWrkOrigin *)

(* ********************************************************************* *)

(* mouse *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure TrkMse(* lclPt: Point *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if not EqualPt(trkPt,lclPt) then begin
            trkPt := lclPt;
            if curDoc.atr.msrOn then
                if curDoc.proto=iObjPoly then
                    if not polyStart then
                        TrkDist(grid2D);
            if curDoc.atr.rlrOn then
                ShowRlrHrs(lclPt,ON);
        end;
    end; (* TrkMse *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure SetMseLmt(* r: Rect *);
    Var adjSizeLBox: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            WLnRect('SetMseLmt:',r);
        SetRect(adjSizeLBox,sizeLBox.left,sizeLBox.top,sizeLBox.right-1,
                sizeLBox.bottom-1);
        if not SectRect(r,adjSizeLBox,mseLmtBox) then begin
            mseLmtBox := adjSizeLBox;
            if r.left=r.right then begin
                mseLmtBox.left := r.left;
                mseLmtBox.right := r.right;
            end;
            if r.top=r.bottom then begin
                mseLmtBox.top := r.top;
                mseLmtBox.bottom := r.bottom;
            end;
        end;
    end; (* SetMseLmt *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure GridMse(* var thisPt: Point; var this2D: Point2D *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* LimitMse *)
        if not PtInRect(thisPt,mseLmtBox) then
            with mseLmtBox do begin
                if thisPt.h<left then
                    thisPt.h := left
                else if thisPt.h>right then
                    thisPt.h := right;
                if thisPt.v<top then
                    thisPt.v := top
                else if thisPt.v>bottom then
                    thisPt.v := bottom;
            end;
        ScrnToWld(thisPt,this2D);
        gridPt := thisPt;
        grid2D := this2D;
        if curDoc.atr.grdOn then begin
            GridP2D(grid2D);
            WldToScrn(grid2D,gridPt);
        end;
    end; (* GridMse *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure SetWrkMse(* thisPt: Point *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        msePt := thisPt;
        wldPt := msePt;
        GEUnMapPt(wldPt);
        wrkPt := wldPt;
        GridMse(wrkPt,wrk2D);
        if pxlDist then
            TrkPxlDist(wldPt);
        TrkMse(gridPt);
    end; (* GetWrkMse *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure GetWrkMse;
    var thisPt: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        GetMouse(thisPt);
        SetWrkMse(thisPt);
    end; (* GetWrkMse *)

(* ********************************************************************* *)

(* Miscellaneous *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure SetCurSel(* thisObj: TObjPtr; iSel: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetSLst(curDoc.sLst,thisObj,iSel);
        HiliteSel(ON);
    end; (* SetCurSel *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure ResetTxt;
    var txtObj: TObjPtr;
        thisObj: TObjRec;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('ResetTxt, curDoc.fldSet=',curDoc.fldSet);

        if curDoc.fldSet then begin
            if curDoc.txtObj^.cSel<>iSelEdt then
                Error('ResetTxt, not iSelEdt',0,NONFATAL);
            { 2/4/83 always commit, since lastop can reference txt obj that
              may get deleted below...
            }
                CommitLastOp;
            (* turn edit hilite off *)
            HiLiteObj(CkObjTrfo(curDoc.txtObj),OFF);
            (* set sel state to normal so hiLite is entire field *)
            curDoc.txtObj^.cSel := iSelNml;
            (* remember curDoc.txtObj, CloseCFld sets it to NIL *)
            txtObj  := curDoc.txtObj;
            thisObj := curDoc.txtObj^;
            (* exit the field, losing all memory of txtSel,etc. *)
            CloseCFld;
            (* if the text is 0-length, then remove the object *)
            if txtObj^.oDat.inf.tLen=0 then begin
                InitSLst(curDoc.sLst);
                SubFmOLst(curDoc.oLst,txtObj);
                FreeObj(txtObj);
                (* if tLen before CloseCFld was >0 then Reshow *)
                if thisObj.oDat.inf.tLen>0 then
                    ReShow(thisObj.bBox);
            end else begin
                (* if no erase, then reshow *)
                if txtObj^.oDat.inf.flPat=1 then
                    Reshow(txtObj^.bBox)
                else
                    (* turn normal hilite ON *)
                    HiLiteObj(CkObjTrfo(txtObj),ON);
            end;
        end;
    end; (* ResetTxt *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure ResetAutoDrw;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('ResetAutoDrw, autoDrwFlag=',autoDrwFlag);

        if autoDrwFlag then begin
            MarkCSel(curDoc.sLst,iSelNml);
            HiliteSel(ON);
            SetCurProto(iObjNil,TRUE);
            autoDrwFlag := FALSE;
        end;
    end; (* ResetAutoDrw *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure ResetCSel;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* turn off hiliting *)
        if curDoc.edtState=iObjNil then
            HiliteSel(OFF)
        else begin
            if NOT curDoc.edtStart then
                HiLiteObj(CkObjTrfo(curDoc.edtObj),OFF)
            else
                RSSel(FALSE);
            (* ResetEdit: hiliting is already off *)
            curDoc.edtObj^.cSel := iSelNil;
            curDoc.edtState := iObjNil;
            curDoc.edtStart := FALSE;
            curDoc.edtObj   := NIL;
        end;
        dupCtrFlag := OFF;
    end; (* ResetCSel *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure ResetCurSel;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        ResetTxt;
        ResetCSel;
        ResetSLst(curDoc.sLst);
    end; (* ResetCurSel *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure ResetPoly;
    var crdPt: Point;
        oldcSel: TByte;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('ResetPoly: ',((curDoc.proto=iObjPoly) and not polyStart):2);

        if (curDoc.proto=iObjPoly) and not polyStart then begin
            (* erase the tracking polyLine *)
            with penSizes[curDoc.pnSiz] do
                PenSize(h,v);
            PenPat(penPats[curDoc.pnPat]);
            DrwPLine(polyPt,lastPolyPt);
            (* finish the cLst *)
            polyStart := TRUE;
            CloseCLst(polyCLst);
            (* if only clicked once, then not a valid poly *)
            if polyObj=NIL then
                FreeCLst(polyCLst)
            else begin
                mkObjFlag := TRUE;
                autoDrwFlag := TRUE;
                (* if only one crd, then make it into sLin *)
                if polyCLst^^.crdCnt=1 then with polyObj^.oDat do begin
                    (* erase the poly obj *)
                    DrwObj(polyObj);
                    (* change it into SLin *)
                    kind := iObjSLin;
                    p1 := polyCLst^^.beg2D;
                    WldToScrn(polyCLst^^.beg2D,crdPt);
                    GetNode(polyCLst,1,crdPt);
                    ScrnToWld(crdPt,p2);
                    FreeCLst(polyCLst);
                    with curDoc.sLst^^ do
                    if sCnt=1 then
                        sState := iObjSLin;
                end;
                (* finish polyObj *)
                GetBBox(polyObj);
                GetSBBox(curDoc.sLst);
                (* show new object *)
                oldcSel := polyObj^.cSel;
                MarkCSel(curDoc.sLst,iSelNil);
                ReShow(polyObj^.bBox);
                MarkCSel(curDoc.sLst,iSelNml);
            end;
        end;
    end; (* ResetPoly *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure ResetEd1;
    var sBox: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* Undo Cmd calls this routine so that don't CommitLastOp *)
        if curDoc.edtState<>iObjNil then begin
            GetBBox(curDoc.edtObj);
            HiLiteObj(curDoc.edtObj,OFF);
            curDoc.edtObj^.cSel := iSelNml;
            (* reshow the object *)
            if NOT curDoc.edtStart then
                HiLiteObj(curDoc.edtObj,ON)
            else
                ReShowInset(curDoc.edtObj^.bBox);
            curDoc.edtObj := NIL;
            curDoc.edtStart := FALSE;
            curDoc.edtState := iObjNil;
        end;
    end; (* ResetEd1 *)

(* ********************************************************************* *)
(*$S Core2*)
    procedure ResetEdit;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.edtState<>iObjNil then begin
            CommitLastOp;
            ResetEd1;
        end;
    end; (* ResetEdit *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure RestartEdit;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* called when the edit object has been reshown and is valid *)
        if curDoc.edtState<>iObjNil then
            curDoc.edtStart := FALSE;
    end; (* RestartEdit; *)

(* ************************************************************************* *)
(*$S Init*)

    procedure InitScr;
    var i: Integer;
        item: Str255;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('    InitScr');

        (* pallette state vars *)
        rStateOn   := FALSE;
        pHLStateOn := FALSE;
        (* height of rlr ticks *)
        hRlrTicks[1] := 3;
        hRlrTicks[2] := 6;
        hRlrTicks[3] := 9;
        hRlrTicks[4] := 12;
        vRlrTicks[1] := 4;
        vRlrTicks[2] := 9;
        vRlrTicks[3] := 13;
        vRlrTicks[4] := 18;
        (* invariant screen sizes *)
        SetRect(protoBox,-1,-1,0,0);
        SetPt(rlrSize,rlrWidth,rlrHeight);
        (* starting screen values *)
        GetMouse(wrkPt);
        GridMse(wrkPt,wrk2D);
        SetRect(sizeLBox,0,0,0,0);

        polyStart   := TRUE;
        dupCtrFlag  := OFF;
        autoDrwFlag := FALSE;

        (* values for cursor *)
        geCrsIBeam  := iCrsIBeam;
        geCrsVal[iObjNil]  := iCrsInactive;
        geCrsVal[iObjText] := geCrsIBeam;
        for i := iObjRLin to iObjPoly do
            geCrsVal[i] := iCrsGECross;

        (* scroll directions, state vars *)
        SetPt(dirFactor[iDirLft],-1,0);
        SetPt(dirFactor[iDirRgt], 1,0);
        SetPt(dirFactor[iDirTop], 0,-1);
        SetPt(dirFactor[iDirBot], 0, 1);
        lastDir := iDirLft;

        mDistOn   := FALSE;
        mDistKind := iObjNil;
        (*$IfC traceOn *)
        pxlDist   := FALSE;
        (*$EndC*)

        (* char to put in curPen pallette when shade=NONE *)
        (* gotten from geMenus *)
        GetItem(geMenus[iMnuFill],1,@item);
        clearCh := item[1];
    end; (* InitScr *)


ÿ