(* ********************************************************************* *)

(* CopyRight 1983, Apple Computer Inc. *)
(* GE Unit CMD Include File - FillStyle, LineStyle, TypeStyle, TextStyle,*)
(*                            Layout, and Misc Command Routines          *)

(* ********************************************************************* *)

(* Arrangement Menu Commands *)


(* ********************************************************************* *)

(*$S Arrange*)
    procedure TopCmd;
    var sState,i: Integer;
        thisObj:  TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* Reset Ops in Progress *);
        RestartEdit;
        ResetPoly;
        ResetAutoDrw;
        sState := curDoc.sLst^^.sState;
        if (sState=iObjNil) then
            GECmdAlert(iStopSel,iCItmTop)
        else if (sState=iSStGrp) or (sState>iObjNil) then
            if SLstNotLocked then begin
                CheckVis(anyObj);
                CommitLastOp;
                CopySLst(curDoc.sLst,prPstLst); {Remember old order
                                                     for PutBack.}
                {For each obj in sLst which is not locked I must bring to the
                top, going through sLst in forward direction.  Record where it was,
                if unlocked then subtract from list, and add to end.}
                ResetFBh;
                For i := 1 to curDoc.sLst^^.sCnt do begin
                    thisObj := CurSelObj(i);
                    AddToFBh(thisObj);
                    If NOT ObjLocked(thisObj) then begin
                        SubFmOLst(curDoc.oLst,thisObj);
                        AddToOEnd(curDoc.oLst,thisObj);
                    end;
                end;
                SetLastOp(iOpTop);
                ReShowSel;
            end;
    end; (* TopCmd *)

(* ********************************************************************* *)

(*$S Arrange*)
    procedure BottomCmd;
    var sState,i: Integer;
        thisObj:  TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* Reset Ops in Progress *);
        RestartEdit;
        ResetPoly;
        ResetAutoDrw;
        sState := curDoc.sLst^^.sState;
        if (sState=iObjNil) then
            GECmdAlert(iStopSel,iCItmBot)
        else if (sState=iSStGrp) or (sState>iObjNil) then
            if SLstNotLocked then begin
                CheckVis(anyObj);
                CommitLastOp;
                CopySLst(curDoc.sLst,prPstLst); {Remember old order
                                                     for PutBack.}
                {For each obj in sLst which is not locked I must bring to the
                top, going through sLst in forward direction.  Record where it was,
                if unlocked then subtract from list, and add to end.}
                ResetFBh;
                For i := curDoc.sLst^^.sCnt downto 1 do begin
                    thisObj := CurSelObj(i);
                    AddToFBh(thisObj);
                    If NOT ObjLocked(thisObj) then begin
                        SubFmOLst(curDoc.oLst,thisObj);
                        AddToOBeg(curDoc.oLst,thisObj);
                    end;
                end;
                SetLastOp(iOpBot);
                ReShowSel;
            end;
    end; (* BottomCmd *)


(* ********************************************************************* *)

(*$S Arrange*)
    procedure GroupCmd;
    var grpObj: TObjPtr;
        thisObj: TObjPtr;
        nextObj: TObjPtr;
        thisDB:  TODBLst;
        i,numNotLocked,errNum: Integer;
        tSel: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('GroupCmd');

        (* see if we have non-singular selection to group *)
        tSel := curDoc.sLst^^;
        if tSel.sState=iObjNil then
            GECmdAlert(iStopSel,iCItmGrp)
        else if tSel.sState=iSStGrp then
            (* see if there is enough room to group *)
            if ExpSLstMem(iCItmGrp) then begin
                CheckVis(anyObj);
                (* see that there is two or more unlocked objects *)
                numNotLocked := 0;
                for i := 1 to tSel.sCnt do begin
                    if NOT ObjLocked(CurSelObj(i)) then
                        numNotLocked := numNotLocked+1;
                    if numNotLocked>1 then
                        i := tSel.sCnt;
                end;

                (* group is valid for two or more unlocked objects *)
                if numNotLocked>1 then begin

                    CommitLastOp;
                    CopySLst(curDoc.sLst,prPstLst);

                    (* create new object *)
                    grpObj := NewObj(iObjGroup);
                    grpObj^.cSel := iSelNml;

                    (* put all objects in group *)
                    InitODB(thisDB);
                    GroupLoc(nextObj);
                    ResetFBh;
                    for i := 1 to tSel.sCnt do begin
                        thisObj := CurSelObj(i);
                        AddToFBh(thisObj);
                        if NOT ObjLocked(thisObj) then begin
                            thisObj^.pSel := iSelGpy;
                            SubFmOLst(curDoc.oLst,thisObj);
                            AddToOEnd(thisDB,thisObj);
                        end;
                    end;
                    grpObj^.oDat.grp := thisDB.lst;
                    SetGpClr(grpObj);            {Set group color}
                    GetBBox(grpObj);
                    If nextObj<>NIL then
                        If nextObj^.oDat.kind = iObjText then
                            nextObj := curDoc.oLst.tBeg;
                    InsertBh(grpObj,nextObj);
                    jstGpObj := grpObj;  {Remember grpObj for undo}
                    MakeSLst;  {Creates curDoc.sLst in correct z-order from
                                curDoc.oLst and cSel flags.}
                    SetLastOp(iOpGrp); {Does this set lastOp.pSLst as
                                                    I want it?  Now it does!}
                    ReShowSel;
                end;
            end;
    end; (* GroupCmd *)


(* ********************************************************************* *)

(*$S BasicOps*)
    procedure SwitchArrowsCmd;
    var thisObj: TObjPtr;
        i: Integer;
        thisStat: TStatRec;
        tSel: TSelLst;
        rNotLocked,sNotLocked: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('SwitchArrowsCmd');

        tSel := curDoc.sLst^^;
        If (tSel.sState=iObjNil) then
            GECmdAlert(iStopSel,iCItmSwt)
        else if SLstNotLocked then begin
            CheckVis(lineObj);
            HiliteSel(OFF);
            CommitLastOp;
            SetLastOp(iOpSwt);
            ReShowSel;
        end else
            GeAlert(iStopLock);
    end; (* SwitchArrowsCmd *)

(* ********************************************************************* *)

(*$S Arrange*)
    procedure UnGroupCmd;
    var thisObj: TObjPtr;
        i: Integer;
        thisStat: TStatRec;
        tSel: TSelLst;
        notLocked: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('UnGroupCmd');

        tSel := curDoc.sLst^^;
        If (tSel.sState=iObjNil) then
            GECmdAlert(iStopSel,iCItmUng)

        else if ObjInSLst(iObjGroup,notLocked) then begin
            If NOT notLocked then
                GeAlert(iStopLock)
            else begin

                (* check to see if tot num objects < 8000 *)
                GetSLstStats(curDoc.sLst,thisStat);
                if thisStat.numObj<8000 then begin
                    CheckVis([iObjGroup]);
                    HiliteSel(OFF);
                    CommitLastOp;
                    SetLastOp(iOpUnG);
                    ResetGBE;
                    for i := 1 to tSel.sCnt do begin
                        thisObj := CurSelObj(i);
                        With thisObj^.oDat do
                            If (kind=iObjGroup) and (locked=0) then
                                UngpInPl(thisObj);
                    end;
                    MakeSLst;
                    CopySLst(curDoc.sLst,prPstLst);{Remember this order
                                                     for PutBack}
                    TxtToTop;
                    MarkPSel(curDoc.sLst,iSelNml);  {Get rid of pSel=iSelGpy's}
                    MakeSLst;   {Get sLst in correct order after TxtToTop}
                    SetLastOp(iOpUnG);
                    ReShowSel;
                end else
                    GECmdAlert(iStopSSize,iCItmUng);
            end;
        end else
            GeAlert(iStopUnG);

    end; (* UnGroupCmd *)

(* ********************************************************************* *)

(*$S Arrange*)
    procedure GridObjCmd;
    var tSel: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* Reset Ops in Progress *);
        RestartEdit;
        ResetPoly;
        ResetAutoDrw;
        tSel := curDoc.sLst^^;
        if (tSel.sState=iObjNil) then
            GECmdAlert(iStopSel,iCItmAlO)
        else if (tSel.sState=iSStGrp) or (tSel.sState>iObjNil) then
            if SLstNotLocked then begin
                CommitLastOp;
                (* see if enough memory to handle largest trfo obj *)
                if ExpTrfoMem(iCItmAlO) then begin
                    CheckVis(anyObj);
                    SetLastOp(iOpAlG);
                    ReShowUnion(tSel.sBBox,curDoc.sLst^^.sBBox);
                end;
            end;
    end; (* GridObjCmd *)

(* ********************************************************************* *)

(*$S Arrange*)
    procedure LineUpCmd(* dir: Integer *);
    var lineUpPt: Point;
        gBox: Rect;
        tJus: Integer;
        tSel: TSelLst;

    (* ***************************************************************** *)

        procedure DoLineUp;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            (* set LastOp *)
            CommitLastOp;
            CheckVis(anyObj);
            (* see if enough memory to handle largest trfo obj *)
            if ExpTrfoMem(iCItmAlO) then begin
                With lastOp do begin
                    iDat1 := dir;
                    rDat1 := lineUpPt.h;
                    rDat2 := lineUpPt.v;
                end;
                SetLastOp(iOpAlO);
                (* show translated objects *)
                ReShowUnion(tSel.sBBox,curDoc.sLst^^.sBBox);
            end;
        end; (* DoLineUp *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC} (* LineUpCmd *)
        (* Reset Ops in Progress *);
        RestartEdit;
        ResetPoly;
        ResetAutoDrw;

        if SLstNotLocked then begin
            (* get the lineUp point *)
            GetSGBox(curDoc.sLst,gBox);
            with gBox do
            if (dir=iDirLft) or (dir=iDirTop) then
                lineUpPt := topLeft
            else if (dir=iDirRgt) or (dir=iDirBot) then
                lineUpPt := botRight
            else
                SetPt(lineUpPt,(left+right) Div 2,(top+bottom) Div 2);
            GridPoint(lineUpPt);

            (* get the text counterpart of dir in case text selected *)
            if dir=iDirLft then
                tJus := cAlnLft
            else if dir=iDirCtH then
                tJus := cAlnCtr
            else if dir=iDirRgt then
                tJus := cAlnRgt;

            (* multiple selection: line up objects *)
            tSel := curDoc.sLst^^;
            if tSel.sState=iSStGrp then
                DoLineUp
            (* dir appropriate for text justification *)
            else if dir in [iDirLft,iDirCtH,iDirRgt] then begin
                (* text proto: set fld alignment *)
                if tSel.sState=iSStPrt then begin
                    if curDoc.proto=iObjText then begin
                        curDoc.align := tJus;
                        ShowProto(iObjText,TRUE);
                    end;
                (* text selection: line up objects *)
                end else if tSel.sState=iObjText then begin
                    if not curDoc.fldSet then begin
                        DoLineUp;
                    end else if curDoc.txtObj^.oDat.inf.tLen>0 then begin
                        TxtLineUp(tJus);
                        DoLineUp;
                    end else begin
                        TxtHiLite(OFF);
                        TxtAlign(curDoc.txtObj,tJus);
                        TxtHiLite(ON);
                    end;
                (* nothing to lineup: set up for possible text *)
                end else begin
                    TxtSelCmd(tJus,FALSE);
                    TxtAlign(curDoc.txtObj,tJus);
                end;
            end else
                GECmdAlert(iStopSel,iCItmAlo);
        end;
    end; (* LineUpCmd *)

(* ********************************************************************* *)

(*$S Arrange*)
    procedure LockCmd(* item: Integer *);
    var i,iOp: Integer;
        lockVal: Boolean;
        tSel: TSelLst;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* item ranges from 1 to 2: 1=Lock, 2=UnLock *)
        lockVal := item=1;
        (* Reset Ops in Progress *);
        ResetEdit;
        ResetPoly;
        ResetAutoDrw;
        (* NOTE: need to also check to see if any object is not already *)
        (* of lockVal... *)
        tSel := curDoc.sLst^^;
        if (tSel.sState=iObjNil) then begin
            if lockVal then
                iOp := iCItmLck
            else
                iOp := iCItmUnL;
            GECmdAlert(iStopSel,iOp)
        end else if (tSel.sState=iSStGrp) or (tSel.sState>iObjNil) then begin
            CheckVis(anyObj);
            if lockVal then
                iOp := iOpLck
            else
                iOp := iOpUnL;
            CommitLastOp;
            SetLastOp(iOp);
            ReShowSel;
        end;
    end; (* LockCmd *)

(* ********************************************************************* *)

(* FillStyle, LineStyle  Menu Commands *)

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure SetSelStyle(size,pPat,fPat,pDat: TByte;frgdClr, bkgdClr: TPByte);
    var thisRect,selRect: Rect;
        infFlag: Boolean;
        thisObj: TObjRec;
        i: Integer;
        tSel: TSelLst;

    (* ***************************************************************** *)

        function  CkObjInf(obj: TObjPtr): Boolean;
        var grpObj: TObjPtr;
            ckFlag: Boolean;
            thisInf,trfoInf: TObjInf;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            (* check to see whether it makes sense to change obj pen info *)
            (* to that specified, object is untransformed. *)
            ckFlag := FALSE;
            with obj^,oDat do
            if kind=iObjGroup then begin
                grpObj := grp.lBeg;
                while grpObj<>NIL do begin
                    ckFlag := CkObjInf(grpObj);
                    if ckFlag then
                        grpObj := NIL
                    else
                        grpObj := grpObj^.fLink;
                end;
            end else begin
                thisInf := inf;
                (* performance optimization: *)
                (* we can avoid having to CkObjTrfo by special case of iOpInf *)
                If lastOp.op=iOpInf then
                    If (pSel<>iSelNil) AND (pSel<>iSelGpy) then with lastOp do
                        SetInf(thisInf,kind,iDat1,iDat2,Round(rDat1),Round(rDat2),
                            Round(rDat3),Round(rDat4)); {Last two field for color}

                with thisInf do
                if fPat<>0 then
                    ckFlag := fPat<>flPat
                else if bkgdClr <> 0 then
                    ckFlag := bkgdClr <> bgClr
                else if frgdClr <> 0 then
                    ckFlag := frgdClr <> fgClr
                else if kind<>iObjText then begin
                    if size<>0 then
                        ckFlag := size<>pnSiz
                    else if pPat<>0 then
                        ckFlag := pPat<>pnPat
                    else if kind in [iObjRLin,iObjSLin] then
                        ckFlag := (pDat-1)<>dat
                {XXX what the H is this? try leaving it out
                end else begin
                    if pDat=0 then
                        ckFlag := TRUE;
                }
                end;
            end;
            CkObjInf := ckFlag;
        end; (* CkObjInf *)

    (* ***************************************************************** *)

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('SetSelStyle(',size:2,pPat:2,fPat:2,pDat:2,frgdClr:2,
            bkgdClr:2,')');

        tSel := curDoc.sLst^^;
        if tSel.sState=iObjNil then begin
            if fPat<>0 then
                curTPat := fPat
            else
                GECmdAlert(iStopSel,iCItmInf);
        end else if SLstNotLocked then begin
            (* Reset Ops in Progress *);
            ResetPoly;
            ResetAutoDrw;
            if curPenFlag then begin
                if size<>0 then
                    curDoc.pnSiz := size
                else if pPat<>0 then
                    curDoc.pnPat := pPat;
                ShowCurPen(curDoc.proto);
            end else if tSel.sState=iSStPrt then begin
                GetProto(curDoc.proto,@thisObj);
                if CkObjInf(@thisObj) then with curDoc do begin
                    if fPat<>0 then begin
                        fill[proto] := fPat;
                        if proto=iObjText then
                            curTPat := fPat;
                    end else if bkgdClr<>0 then
                        fillClr[proto] := bkgdClr
                    else if frgdClr<>0 then
                        pnClr := frgdClr
                    else if pDat<>0 then begin
                        if proto in [iObjSLin,iObjRLin] then begin
                            arrw[proto] := pDat-1;
                            ShowProto(proto,TRUE);
                        end;
                    end else if proto<>iObjText then begin
                        if size<>0 then
                            pnSiz := size
                        else
                            pnPat := pPat;
                    end;
                    ShowCurPen(proto);
                end;
            end else if tSel.sState<>iObjNil then begin
                RestartEdit;

                (* see if any sel object doesn't conform with params *)
                infFlag := FALSE;
                For i := 1 to tSel.sCnt do
                    If CkObjInf(CurSelObj(i)) then begin
                        infFlag := TRUE;
                        i := tSel.sCnt;
                    end;

                If infFlag then begin
                    CloseCFld;
                    CommitLastOp;

                    (* see if enough memory to handle largest trfo obj *)
                    If ExpTrfoMem(iCItmInf) then begin
                        if size<>0 then
                            CheckVis(grafObj)
                        else if pPat<>0 then
                            CheckVis(grafObj)
                        else if fPat<>0 then
                            CheckVis(fPatObj)
                        else if bkgdClr<>0 then
                            CheckVis(fPatObj)
                        else
                            CheckVis(lineObj);
                        With lastOp do begin
                            iDat1 := size;
                            iDat2 := pPat;
                            rDat1 := fPat;
                            rDat2 := pDat;
                            rDat3 := frgdClr;
                            rDat4 := bkgdClr;
                        end;
                        SetLastOp(iOpInf);
                        ReShowUnion(tSel.sBBox,curDoc.sLst^^.sBBox);
                    end;
                end else if fPat<>0 then
                    GEAlert(iStopFill)
                else
                    GEAlert(iStopLine);
            end;
        end;
    end; (* SetSelStyle *)

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure PenStyleCmd(* item: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('PenStyleCmd(',item:2,')');

        If (curDoc.sLst^^.sState=iSStPrt) AND (item=iPenClear) then
            GEAlert(iStopPClr)

        else if (item>=1) and (item<=numfStyle) then
            SetSelStyle(0,item,0,0,0,0);
    end; (* PenStyleCmd *)

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure FillStyleCmd(* item: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('FillStyleCmd(',item:2,')');

        if (item>=1) and (item<=numfStyle) then
            SetSelStyle(0,0,item,0,0,0);
    end; (* FillStyleCmd *)

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure ColorCmd(* item: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        With curDoc do begin
            case item of
                1: assFlClr := TRUE;  {Fill Color }
                2: assFlClr := FALSE; {Line/Text Color }
                13: begin
                        ShowPats := TRUE;  {Show Patterns }
                        ReShow(dwgLBox);
                    end;
                14: begin
                        ShowPats := FALSE; {Show Colors by Initials }
                        ReShow(dwgLBox);
                    end;
            end;
            If (4 <= item) and (item <= 11) and not assFlClr then
                SetSelStyle(0,0,0,0,item-3,0);
            If (4 <= item) and (item <= 11) and assFlClr then
                SetSelStyle(0,0,0,0,0,item-3);
        end;
    end;{ ColorCmd }

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure LineStyleCmd(* item: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('LineStyleCmd(',item:2,')');

        case item of
            1,2,3,4:
                SetSelStyle(item,0,0,0,0,0);
            6,7,8:
                SetSelStyle(0,0,0,item-5,0,0);  {Patterns are now gone from this
                                                 menu, but switch is not yet in.}
                9:
                SwitchArrowsCmd;
        end; (* case *)
    end; (* LineStyleCmd *)

(* ********************************************************************* *)

(* TypeStyle, TextStyle Menu Commands *)

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure TxtCaseCmd(* nCase: Integer *);
    var haveObj,notLocked: Boolean;
        oldR: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('TxtCaseCmd(',nCase:2,')');

        (* nCase is numbered from 1 to 3 *)
        (* see if enough memory to handle largest trfo obj *)
        if ExpTrfoMem(iCItmCase) then begin
            (* we are not in text mode, text object is selected *)
            haveObj :=  ObjInSLst(iObjText,notLocked);
            if haveObj AND notLocked then begin
                CheckVis([iObjText]);
                CommitLastOp;
                oldR := curDoc.sLst^^.sBBox;
                if curDoc.fldSet then begin
                    SetObjCase(curDoc.txtObj,nCase);
                    GetSBBox(curDoc.sLst);
                end else begin
                    lastOp.iDat1 := nCase;
                    SetLastOp(iOpCase);
                end;
                ReShowUnion(oldR,curDoc.sLst^^.sBBox);
            end else
                GEAlert(iStopCase);
        end;
    end; (* TxtCaseCmd *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure TxtSelCmd(* tAlign: Integer; frcCtr: Boolean *);
    var this2D:     Point2D;
        thisRect:   Rect;
        thisObj:    TObjPtr;
        penH,sAlign: Integer;
        tSel: TSelLst;
        textFlag: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('TxtSelCmd(',tAlign:1,'), pasteState=',pasteState);

        (* can't undo after this *)
        CommitLastOp;
        (* perform same sequence of events as if user clicked in *)
        (* text proto and then in center of curSel *)
        tSel := curDoc.sLst^^;
        textFlag := FALSE;
        If tSel.sState=iObjText then begin
            thisObj := CurSelObj(1);
            If thisObj^.oDat.inf.tDat<16 then begin
                textFlag := TRUE;
                HiLiteObj(thisObj,OFF);
                TxtSelAll(thisObj);
                thisObj^.cSel := iSelEdt;
                HiLiteObj(thisObj,ON);
            end;
        end;
        If NOT textFlag then begin
            (* no text selected, find tLoc to start new text obj *)
            penH := 1;
            if (tSel.sState=iObjNil) or (tSel.sState=iSStPrt) then begin
                (* nothing is selected, enter text at the pastePt *)
                if pasteState then with pastePt do
                    SetRect(thisRect,h,v,h,v)
                else with dwgLBox do begin
                    thisRect := dwgLBox;
                    thisRect.left := (right+left) Div 2;
                    thisRect.right := thisRect.left;
                end;
            end else begin
                (* something is selected, enter text at bBox center *)
                if (tSel.sState>iObjNil) and (tSel.sState<iObjGroup) then begin
                    thisObj := CurSelObj(1);
                    If thisObj^.oDat.inf.tDat<16 then begin
                        penH := penSizes[thisObj^.oDat.inf.pnSiz].h;
                    end;
                    if frcCtr then
                        tAlign := cAlnCtr;
                end;
                thisRect := tSel.sBBox;
            end;
            with thisRect do begin
                this2D.y := (bottom+top)/2;
                case talign of
                    cAlnLft: this2D.x := left+penH;             (* left *)
                    cAlnRgt: this2D.x := right-penH;            (* right *)
                    cAlnCtr: this2D.x := (right+left)/2;        (* center *)
                end; (* case *)
            end;
            (* Reset Ops in Progress *);
            ResetPoly;
            ResetAutoDrw;
            ResetEdit;
            ResetCurSel;
            if curDoc.proto<>iObjText then
                SetCurProto(iObjNil,TRUE);
            sAlign := curDoc.align;
            curDoc.align := tAlign;
            TxtClkCmd(this2D,FALSE,FALSE);
            curDoc.align := sAlign;
        end;
    end; (* TxtSelCmd *)

(* ********************************************************************* *)

(*$S BasicOps*)
    procedure TxtFmtCmd(* face,font: Integer *);
    var oldBBox: Rect;
        nTxtFlag,notLocked,fPlain: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('TxtFmtCmd(',face:2,',',font:2,')');

        (* face is numbered from 1 to 6,with 7,8,9 commands
           set font,setFontModern, setFontClassic, font from 3 to 10 *)
        If face=iFmtFont then begin
            font := fontIndex[curStyle,font]; {font = size in this case}
        end else if face=8 then begin {SetToModern}
            curStyle := iFontModern;
        end else if face=9 then begin {SetToClassic}
            curStyle := iFontClassic;
        end;
        (* see if enough memory to handle largest trfo obj *)
        if ExpTrfoMem(iCItmFmt) then begin
            nTxtFlag := FALSE;
            (* curFld is set, text object being edited *)
            if curDoc.fldSet then begin
                    oldBBox := curDoc.txtObj^.bBox;

                    CommitLastOp;
                    TxtFmt(curDoc.txtObj,face,font);
                    curDoc.sLst^^.sBBox := curDoc.txtObj^.bBox;
                    SetLastOp(iOpTxt);
                    CkTxtBounds(iOpFmt);

                    ReShowUnion(oldBBox,curDoc.txtObj^.bBox);
            (* we are in text mode *)
            end else if curDoc.proto=iObjText then begin
                (* selection is proto *)
                if curDoc.sLst^^.sState=iSStPrt then begin
                    TxtFmt(@protoObj[iObjText],face,font);
                    GetTxtFid(@protoObj[iObjText],fPlain,curDoc.fid);
                    ShowProto(iObjText,TRUE);
                    curDoc.fldSet := FALSE;
                (* nothing is selected *)
                end else
                    nTxtFlag := TRUE;
            (* we are not in text mode, text object is selected *)
            end else if ObjInSLst(iObjText,notLocked) then begin
                if notLocked then begin
                    CheckVis([iObjText]);
                    CommitLastOp;
                    GetSelRect(curDoc.sLst,oldBBox);
                    With lastOp do begin
                        iDat1 := face;
                        iDat2 := font;
                    end;
                    SetLastOp(iOpFmt);
                    ReShowUnion(oldBBox,curDoc.sLst^^.sBBox);
                end else
                    GEAlert(iStopLock);
            (* we are not in text mode, no text object selected *)
            end else
                nTxtFlag := TRUE;

            (* start a new text field *)
            if nTxtFlag then begin
                TxtSelCmd(curDoc.align,TRUE);
                TxtFmt(curDoc.txtObj,face,font);
            end;
        end;
    end; (* TxtFmtCmd *)

(* ********************************************************************* *)

(* Layout Menu Commands *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure RlrZeroCmd(* lclPt: Point *);
    var thisRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then with lclPt do
            writeln('RlrZeroCmd(',h:2,',',v:2,')');

        UnionRect(topRlrLBox,lftRlrLBox,thisRect);
        with curDoc.atr do
        if PtInRect(lclPt,thisRect)
        and not EqualPt(lclPt,rlrZero[rlrUnit,rlrKind]) then begin
            if PtInRect(lclPt,wrkLBox) then begin
                rlrZero[rlrUnit,rlrKind] := gridPt;
                RedrawRlr;
            end else if PtInRect(lclPt,topRlrLBox) then begin
                rlrZero[rlrUnit,rlrKind].h := gridPt.h;
                RedrawTopRlr;
            end else if PtInRect(lclPt,lftRlrLBox) then begin
                rlrZero[rlrUnit,rlrKind].v := gridPt.v;
                RedrawLftRlr;
            end else if PtInRect(lclPt,zroRlrLBox) then begin
                SetPt(rlrZero[rlrUnit,rlrKind],0,0);
                RedrawRlr;
            end;
            GEClipRect(wrkLBox);
            ReShow(dwgLBox);
            curDoc.hdrChgd := TRUE;
        end;
    end; (* RlrZeroCmd *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure SetCurGrid;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with curDoc.atr,rlrFmts[rlrUnit,rlrKind] do begin
            if rlrUnit=iUnitMtrc then
                SetPt2D(tckSz2D,iSpc*xCMDots,iSpc*yCMDots)
            else
                SetPt2D(tckSz2D,rlrInfo[iSpc].spc*xInchDots,
                                rlrInfo[iSpc].spc*yInchDots);
            with rlrInfo[iDvs] do
            if grdOn then
                SetPt2D(grdSz2D,tckSz2D.x/dvs,tckSz2D.y/dvs)
            else
                SetPt2D(grdSz2D,1,1);
        end;
    end; (* SetCurGrid *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure RlrOnOffCmd(* item: Integer *);
    var thisRect: Rect;
        onOff: Integer;
        fldrFlag,onOffChange,differentRlr: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then with curDoc.fldr^.portRect do
            writeln('RlrOnOffCmd(',not curDoc.atr.rlrOn,') portOrigin= ',left:4,top:4);

        (* item ranges from 1 to 3: 1=ShowStdRlr, 2=ShowCustomRlr, 3=HideRlr *)
        (* onOff ranges from 0 to 2: 0=Off, 1=showStdRlr, 2= showCustomRlr *)
        onOff := 3-item;

        onOffChange := (onOff<>0)<>curDoc.atr.rlrOn;
        differentRlr:= (onOff<>0) and (curDoc.atr.rlrKind<>3-onOff);
        if onOffChange or differentRlr then begin
            curDoc.hdrChgd := TRUE;
            (* reset wrkCoords *)
            fldrFlag := FALSE;
            if onOffChange then begin
                (* reset onOff status flag *)
                curDoc.atr.rlrOn := onOff<>0;
                (* adjust scrollPt since change size of wrkBox *)
                if curDoc.atr.rlrOn then
                    AddPt(rlrSize,curDoc.atr.scrollPt)
                else begin
                    SubPt(rlrSize,curDoc.atr.scrollPt);
                    if (curDoc.atr.scrollPt.h<0) or (curDoc.atr.scrollPt.v<0) then begin
                        (* can't just erase rulers, paper edge would show *)
                        fldrFlag := TRUE;
                        if curDoc.atr.scrollPt.h<0 then
                            curDoc.atr.scrollPt.h := 0;
                        if curDoc.atr.scrollPt.v<0 then
                            curDoc.atr.scrollPt.v :=0;
                    end
                end;
                (* reset all scrollPt dependent vars *)
                SetWrkOrigin;
                SetGEBox(FALSE);
                GEClipRect(wrkLBox);
                (* redraw the sBoxes, since position of thumb changes *)
                DrwGESBars(curDoc.fldr^.portRect);
            end;
            (* redraw the entire folder contents minus protoPanel, *)
            (* since the zeroPt might have changed, affecting tickMarks *)
            if curDoc.atr.rlrOn then begin
                curDoc.atr.rlrKind := 3-onOff;
                RedrawRlr;
            end;
            if differentRlr then
                (* reset the grid, since it depends on rlrKind *)
                SetCurGrid;
            ReShow(dwgLBox);
        end;
    end; (* RlrOnOffCmd *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure SizeCmd(* item: Integer *);
    var onOff: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* item ranges from 1 to 2: 1=turnOn, 2=turnOff *)
        onOff := item=1;
        if onOff<>curDoc.atr.msrOn then begin
            curDoc.hdrChgd := TRUE;
            curDoc.atr.msrOn := onOff;
            SetGEBox(FALSE);
            DrwGESBars(curDoc.fldr^.portRect);
        end;
    end; (* SizeCmd *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure PaperCmd(* item: Integer *);
    var tckWasOn,grdWasOn: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* item ranges from 1 to 3: 1=plainPaper, 2=gridPaper, 3=autoGrid *)

        with curDoc.atr do begin
            tckWasOn := tckOn;
            grdWasOn := grdOn;

            tckOn    := (item=2) or (item=3);
            grdOn    := item=3;

            if (tckWasOn<>tckOn) or (grdWasOn<>grdOn) then begin
                curDoc.hdrChgd := TRUE;

                (* set proper i-beam cursor *)
                if grdOn then
                    geCrsIBeam := iCrsIBeam
                else
                    geCrsIBeam := iCrsGEIBeam;

                (* set ticks and grid to ruler *)
                SetCurGrid;
                if tckWasOn<>tckOn then
                    ReShow(dwgLBox);
            end;
        end;
    end; (* PaperCmd *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure ZoomCmd(* item: Integer *);
    var zoomWasOn: Integer;
        wrkCtr2D,pst2D: Point2D;
        wrkCtr,wrkLSz: Point;
        oldsBBox: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* item ranges from 1 to 3: 1=Normal Size, 2=Reduce To Fit, 3=Reduce 30% *)
        with curDoc,atr do begin
            zoomWasOn := zoomOn;
            zoomOn := item-1;
            If (zoomOn <> 0) and (curDoc.proto = iObjText) then begin
                ResetTxt;
                curDoc.sLst^^.sState := iObjNil;
                SetCurProto(iObjNil,FALSE(*don't hilite*));
                ShowProto(iObjNil,TRUE);
                SetStdCursor(geCrsCur);
            end;
            if zoomOn=0 then begin
                If zoomWasOn>0 then rlrOn := saveRlrOn;
                (* Scroll to 0,0 on Show Normal Size unless pastePt is set *)
                (* get half unzoomed window size *)
                with wrkBox do
                SetPt(wrkCtr,(right-left) DIV 2,(bottom-top) DIV 2);
                ScrnToWld(wrkCtr,wrkCtr2D);
                (* get pstPt *)
                oldsBBox := curDoc.sLst^^.sBBox;
                GetPst2D(wrkCtr2D,oldsBBox,pst2D);
                (* put in integer coords *)
                WldToScrn(pst2D,scrollPt);
                if zoomWasOn=2 then begin
                    (* scroll to pastePt if visible, otherwise, center of window *)
                    wrkLSz := wrkLBox.botRight;
                    SubPt(wrkLBox.topLeft,wrkLSz);
                    if NOT PtInRect(scrollPt,wrkLBox) then begin
                        RectCtr2D(wrkLBox,pst2D);
                        WldToScrn(pst2D,scrollPt);
                    end;
                end;
                (* subtract half unzoomed window size *)
                SubPt(wrkCtr,scrollPt);
            end else begin
                If zoomWasOn=0 then begin
                    saveRlrOn := rlrOn;
                    rlrOn := FALSE;
                    zoomSz := dwgSz;
                end;
                (* reduce zoomDstR by 30% *)
                zoomSz.h := Round(0.7*zoomSz.h);
                zoomSz.v := Round(0.7*zoomSz.v);
            end;
            SetGEBox(TRUE);
            InvalRect(fldr^.portRect);
        end;
    end; (* ZoomCmd *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure PageBrkCmd(* item: Integer *);
    var onOff: Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* item ranges from 1 to 2: 1=turnOn, 2=turnOff *)
        onOff := item=1;
        if onOff<>curDoc.atr.pgBOn then begin
            curDoc.hdrChgd := TRUE;
            curDoc.atr.pgBOn := onOff;
            if curDoc.atr.pgBOn then
                DrwPgBreak(wrkLBox)
            else
                ReShow(dwgLBox);
        end;
    end; (* PageBrkCmd *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure RlrCmd(* doItFlag: Boolean *);
    var thisRlr: TRlrIndx;
        rlrChgd,rlrWasOn,indxChgd:   Boolean;
        oldKind,oldUnit:     Integer;
        updateAll:  Boolean;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then with thisRlr do
            writeln('RlrCmd(',doItFlag,')');

        with curDoc.atr do begin
            rlrChgd  := FALSE;
            rlrWasOn := rlrOn;
            oldKind  := rlrKind;
            oldUnit  := rlrUnit;
            if doItFlag then begin
                (* update curDoc.atr rlr fields from check form *)
                with geRlrForm^^ do begin
                    (*$R-*)
                    rlrOn        := ckBoxLst[iRlrAtr]^^.curOnOff=1;
                    rlrUnit      := ckBoxLst[iRlrAtr]^^.curCkItm-2;
                    rlrKind      := ckBoxLst[iRlrKnd]^^.curCkItm;
                    rlrLock[rlrUnit,rlrKind] := ckBoxLst[iRlrLck]^^.curCkItm=1;
                    thisRlr.iSpc := ckBoxLst[iRlrSpc]^^.curCkItm;
                    thisRlr.iInc := ckBoxLst[iRlrInc]^^.curCkItm;
                    thisRlr.iDvs := ckBoxLst[iRlrDvs]^^.curCkItm;
                    (*$IfC rangeOn *)
                    (*$R+*)
                    (*$EndC *)
                end;

                (* see if ruler has changed *)
                with rlrFmts[rlrUnit,iRlrCustom] do
                indxChgd := (thisRlr.iSpc<>iSpc) or
                            (thisRlr.iInc<>iInc) or
                            (thisRlr.iDvs<>iDvs);
                rlrChgd := indxChgd or (oldKind<>rlrKind)
                           or (oldUnit<>rlrUnit) or (rlrOn<>rlrWasOn);

                (*
                   rlrChgd only tells us if the current setting of the ruler
                   has changed, and thus if the dwg display is affected.
                   it does not tell us if check boxes for the other rlrKind
                   or rlrUnit have changed.  therefore, we always set hdrChgd
                   so state gets written out.
                *)

                {XXX NOTE:
                   there is a bug in rlr dialog! changes to other rlrKind
                   or rlrUnit don't get written through to curDoc!
                   not critical to fix for first release.
                }

                curDoc.hdrChgd := TRUE;

                if rlrChgd then begin
                    (* set rlrIndx *)
                    if indxChgd then
                        rlrFmts[rlrUnit,iRlrCustom] := thisRlr;

                    (* set ticks and grid to ruler *)
                    SetCurGrid;
                    (* restore screen *)
                    updateAll := (rlrChgd and rlrWasOn) or
                                 (rlrChgd and tckOn) or
                                 (rlrWasOn<>rlrOn) or
                                 (oldUnit<>rlrUnit) and tckOn;
                    if updateAll then begin
                        SetGEBox(TRUE);
                        SetMseLmt(sizeLBox);
                        InvalRect(curDoc.fldr^.portRect);
                    end;
                end;
            end;
            ClearDBox;
            SetStdCursor(iCrsEscape);
            SetStdCursor(iCrsInactive);
        end;

        if traceCmd then with thisRlr do
            writeln('RlrCmd(',doItFlag,')=',iSpc:4,iInc:4,iDvs:4);
    end; (* RlrCmd *)

(* ********************************************************************* *)

(*$S PageLayout*)
    procedure DwgCmd(* doItFlag: Boolean *);
    var nDwgSz: Point;
        ratio: Point2D;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('DwgCmd(',doitFlag,')');

        if doItFlag then with curDoc.atr do begin
            (* set dwgSz and pageSz in curDoc.atr according to PrMgr pageSz *)
            SetPt(nDwgSz,CMin(cHDwgMax,curPgCnt.h*pageSz.h),
                         CMin(cVDwgMax,curPgCnt.v*pageSz.v));
            if not EqualPt(nDwgSz,dwgSz) then begin
                curDoc.hdrChgd := TRUE;
                dwgSz := nDwgSz;
                (* reset all dimensions that depend on dwgSz *)
                ratio.x := dwgSz.h/zoomSrcR.right;
                ratio.y := dwgSz.v/zoomSrcR.bottom;
                sizeLBox.botRight := dwgSz;
                zoomSrcR.botRight := dwgSz;
                zoomSz.h := Round(ratio.x*zoomSz.h);
                zoomSz.v := Round(ratio.y*zoomSz.v);
                SetMseLmt(sizeLBox);
                SetGEBox(TRUE);
                SetThumb(hSBox,DwgThumbPos(iDirLft));
                SetThumb(vSBox,DwgThumbPos(iDirTop));
                (* redisplay folder in case edge of drawing or page breaks show *)
                InvalRect(curDoc.fldr^.portRect);
            end;
        end;
        (* restore screen *)
        ClearDBox;
        SetStdCursor(iCrsEscape);
        SetStdCursor(iCrsInactive);
    end; (* DwgCmd *)

(* ********************************************************************* *)

(* Miscellaneous Commands *)

(* ********************************************************************* *)
(*$S DeBug*)
    procedure SetTraceCmd(* var flag: boolean; flagName: String80 *);
    var msg: String80;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (*$IfC traceOn *)
        flag := not flag;
        param1 := flagName;
        if flag then
            Writeln(flagName,' Flag is TRUE')
        else
            Writeln(flagName,' Flag is FALSE')
        (*$EndC *)
    end; (* SetTraceCmd *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure TxtClkCmd(* this2D: Point2D; shFlagOn,sameFmt: Boolean *);
    var gPt,thisPt: Point;
        nFlag,opFlag: Boolean;
        thisObj,trThisObj: TObjPtr;
        tx,ty:   Real;
        lSpace,ascent,descent: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('TxtClkCmd(',this2D.x:6:2,',',this2D.y:6:2,',',sameFmt,')');

        (* start a field at this2D *)

        (* if this2D is on a text obj, then add to it *)
        nFlag := TRUE;
        opFlag := NOT (lastOp.op in [iOpTxt,iOpTCut,iOpTCpy]);
        WldToScrn(this2D,thisPt);
        if PtOnObj(thisPt,thisObj) then begin
            trThisObj := CkObjTrfo(thisObj);
            if (thisObj^.oDat.kind=iObjText) AND (trThisObj^.oDat.inf.tDat<16)
                then begin
                if thisObj<>curDoc.txtObj then begin
                    ResetTxt;
                    (* turn off hilite *)
                    HiliteSel(OFF);
                    (* don't allow undo across text fields *)
                    CommitLastOp;
                    opFlag := FALSE
                end;
                (* track fld selection *)
                TxtSel(thisObj,thisPt,shFlagOn);
                nFlag := FALSE;
            end;
        end;
        (* commit the lastOp so don't have to worry about undo *)
        if opFlag then
            CommitLastOp;
        (* if this2D is not on a text obj, then start a new field *)
        if nFlag then begin
            (* set the paste pt *)
            pasteState := TRUE;
            pastePt    := anchorPt;
            (* round insert pt to 1/2 grid *)
            ty := curDoc.atr.grdSz2D.y/2;
            ty := Round(this2D.y/ty)*ty;
            (* get baseLine offset and center txtbbox around insert pt *)
            GetTxtLSpace(lSpace,ascent,descent);
            GridP2D(this2D);
            WldToScrn(this2D,thisPt);
            thisPt.v := Round(ty-(lSpace/2.0))+ascent;
            (* close out current text *)
            ResetTxt;
            (* turn off hilite *)
            HiliteSel(OFF);
            (* Set txtObj to text prototype *)
            curDoc.txtObj := NewObj(iObjText);
            GetProto(iObjText,curDoc.txtObj);
            with curDoc.txtObj^,oDat do
                ScrnToWld(thisPt,tLoc);
            (* start new field *)
            TxtStart(thisPt,sameFmt);
            AddToOEnd(curDoc.oLst,curDoc.txtObj);
            if NOT PtInRect(thisPt,dwgLBox) then begin
                (* set selection now so scrolling will turn it on/off *)
                curDoc.txtObj^.cSel := iSelEdt;
                (* turn on the caret so don't get it confused *)
                TxtCaretOn;
                ScrollTo(thisPt.h,thisPt.v);
                (* blink the caret again *)
                TxtBlinkCaret;
            end;
        end;
        (* set sel to curText *)
        ResetSLst(curDoc.sLst);
        SetSLst(curDoc.sLst,curDoc.txtObj,iSelEdt);
        HiliteSel(ON);
    end; (* TxtClkCmd *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure CkTxtBounds(* op: Integer *);
    const BSP   = 8;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* check to see that text is in sizeLBox *)
        with curDoc.txtObj^.bBox do
        if (left<sizeLBox.left) or (right>sizeLBox.right) then begin
            if op=iOpTCh then
                TxtCh(Chr(BSP),FALSE,FALSE)
            else
                TxtUndo;
            TxtValid;
            GEAlert(iStopTBnds);
            (* if clear fill, then InsCh erased field, show it *)
            if op=iOpTCh then
                with curDoc.txtObj^,oDat do
                    if inf.flPat=iFillClear then
                        TxtDraw(curDoc.txtObj);
        end;
    end; (* CkTxtBounds *)

(* ********************************************************************* *)

(*$S Ring*)
    procedure CkCaretLoc;
    var thisPt: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* check to see that caret is in sizeLBox *)
        GetCaretLoc(thisPt);
        if NOT PtInRect(thisPt,dwgLBox) then begin
            (* turn on the caret so don't get it confused *)
            TxtCaretOn;
            ScrollTo(thisPt.h,thisPt.v);
            (* blink the caret again *)
            TxtBlinkCaret;
        end;
    end; (* CkCaretLoc *)

(* ********************************************************************* *)

(*$S Init*)
    procedure InitCmd;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            writeln('InitCmd');

        grafObj := [iObjRLin,iObjSLin,iObjRect,iObjRndR,
                    iObjOval,iObjArc,iObjFHnd,iObjPoly,iObjSPoly,iObjGroup];
        fPatObj := [iObjText,iObjRect,iObjRndR,iObjOval,
                    iObjArc,iObjFHnd,iObjPoly,iObjSPoly,iObjGroup];
        lineObj := [iObjRLin,iObjSLin,iObjGroup];
        anyObj  := lineObj+fPatObj;

        (* mapping from menu to rotation amount *)
        mapMToRot[1] := 3;
        mapMToRot[2] := 1;
        mapMToRot[3] := 4;
        mapMToRot[4] := 5;

        (* zoom rects *)
        SetPt(zoomSrcRect.topleft,0,0);
        SetPt(zoomDstRect.topleft,0,0);
        (* NOTE: on new QD:
        zoomSrcRect.topLeft := zeroPt;
        zoomDstRect.topLeft := zeroPt;
        *)
        {Allocate and initialize out of place list for PasteCmd}
        outPlLst := NewSLst(geHHz);
        InitSLst(outPlLst);
    end; (* InitCmd *)



ÿ