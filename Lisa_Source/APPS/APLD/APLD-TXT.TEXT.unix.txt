(* ********************************************************************* *)

(* CopyRight 1983,1984 Apple Computer Inc. *)
(* GE Text Routines *)

(* ********************************************************************* *)

UNIT Txt;

(* Segment CMD *)
INTERFACE
USES
    (*$U UNITSTD *)    UnitStd,    (* interface dependency  *)
    (*$U UNITHZ*)      UnitHz,
    (*$U STORAGE*)     Storage,
    (*$U QUICKDRAW *)  QuickDraw,
    (*$U FONTMGR*)     FontMgr,
    (*$U LibOS/Syscall *)    Syscall,
    {$U LibPm/PmDecL}      PmDecL,
    {$U PrStdInfo}     PrStdInfo,
    {$U PrPublic}      PrPublic,
    (*$U ApLd/HDR*)    Hdr,

                                           (* implementation units  *)
    {$IFC sampcalls}
    {$U apld/tracecalls.obj}  tracecalls,
    {$ENDC}
    (*$U WM.EVENTS*)   Events,
    (*$U DBENV*)       DbEnv,
    (*$U FEDEC*)       FEDec,
    (*$U FLD*)         FieldEdit,
    (*$U ApLd/UTL*)    Utl;
CONST
    iTStNil    = 0;
    iTStCaret  = 1;
    iTStInvert = 2;
    maxTLen    = 255;
    cPicTxtBeg  = 101;
    cPicTxtEnd  = 102;
    cPicRTxt    = 110;
    cPictHnd    = 111;
    cPicfHnd    = 112;

Var savePHz,saveHHz:  THz;
    putScpFlag: Boolean;
    makingScpPic: Boolean;

    (* Text Transformations *)
    procedure TxtCh     (ch: char; shFlag,aplFlag: Boolean);
    procedure TxtCopy;
    procedure TxtCut;
    function  TxtPaste: BOOLEAN;
    procedure TxtUndo;
    procedure TxtMove   (xM,yM: Real);
    procedure TxtFmt    (obj: TObjPtr; face,font: Integer);
    procedure TxtCase   (obj: TObjPtr; ncase: Integer);
    procedure TxtAlign  (obj: TObjPtr; jus: Integer);
    procedure TxtLineUp (jus: Integer);
    procedure GetTxtBBox(obj: TObjPtr);
    procedure TxtCommit;
    (* Text Selection *)
    procedure TxtSel    (obj: TObjPtr; wrkPt: Point; shFlagOn: Boolean);
    procedure TxtSelTrk (wrkPt: Point; shFlagOn: Boolean);
    procedure TxtSelPt  (obj: TObjPtr; wrkPt: Point);
    procedure TxtSelWrd (obj: TObjPtr; wrkPt: Point);
    procedure TxtSelAll (obj: TObjPtr);
    procedure TxtSelFld (obj: TObjPtr);
    (* CurFld *)
    procedure TxtStart  (scrnPt: Point; sameFmt: Boolean);
    procedure CloseCFld;
    procedure SetCFld(obj: TObjPtr);
    (* Txt Display *)
    procedure TxtHiLite(showHiLite: Boolean);
    procedure TxtDraw  (obj: TObjPtr);
    procedure TxtShow  (obj: TObjPtr);
    procedure TxtDrwScrap;
    (* Misc *)
    procedure GetTxtPt(tAlign: Integer; tLoc: Point2D; VAR scrnPt: Point);
    procedure GetTxtFid(obj: TObjPtr; VAR plain: Boolean; VAR fid: TFntid);
    procedure GetTxtInfo;
    procedure GetTxtLSpace(var lSpace,ascent,descent: Integer);
    procedure GetCaretloc(VAR loc: Point);
    procedure GetTxtState(VAR fState: TGEFState);
    procedure SetTxtState(fState: TGEFState);
    procedure TxtSetFmt(obj: TObjPtr; fid: TFntId);
    procedure TxtValid;
    procedure TxtFontSub(dev: Integer);
    function  TxtSelState: Integer;
    function  TxtTimeOut: Boolean;
    procedure TxtTerminate;
    procedure TxtFldTrace(f: Boolean);
    procedure TxtCaretOn;
    procedure TxtBlinkCaret;
    procedure DumpCurFld;
    procedure InitTxt;

(* ********************************************************************* *)

IMPLEMENTATION

(* ********************************************************************* *)

var
    (* curFmt Info *)
    curRun:     Run;
    (* Field State *)
    curFState:  HndFState;
    curTxtFld:  HndField;
    tempFld:    HndField;
    insFlag:    Boolean;
    mRect:      Rect;

(* ********************************************************************* *)

(* Misc Private Txt Routines *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure CkFldErr(s: String80; errNum: Integer);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if rangeOn then
            if errNum <> 0 then begin
                s := Concat('Field Error(',s,')');
                Error(s,errNum,NONFATAL);
            end;
        (* the only one we would possibly want to do something with
           is nullSelect *)
    end; (* InitFld *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure STxtClip(VAR saveClip: RgnHandle);
    var clipR: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* save current clip *)
        saveClip := NewRgn;
        GetClip(saveClip);
        (* set clip to coords *)
        clipR := curTxtFld^^.coords;
        if SectRect(clipR,curDoc.fldr^.clipRgn^^.rgnBBox,clipR) then
            ClipRect(clipR);
    end; (* STxtClip *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure RTxtClip(VAR saveClip: RgnHandle);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* restore clip *)
        SetClip(saveClip);
        DisposeRgn(saveClip);
    end; (* STxtClip *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GetTxtPt(* tAlign: Integer; tLoc: Point2D; VAR scrnPt: Point *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        WldToScrn(tLoc,scrnPt);
        {GEMapPt(scrnPt);}
        if tAlign=left then
            scrnPt.h := scrnPt.h+cTxtPad-1
        else if tAlign=right then
            scrnPt.h := scrnPt.h-cTxtPad+1;
    end; (* GetTxtPt *)

(* ********************************************************************* *)
(*$S Core*)
    procedure TxtBBox(obj: TObjPtr; thisFld: HndField; thisFS: HndFState);
    var scrnPt: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^,oDat do begin
            GetTxtPt(inf.tDat MOD 16,tLoc,scrnPt);
            MoveField(thisFld,thisFS,scrnPt);
            bBox := thisFld^^.coords;
            if inf.tDat>15 then begin
                { NOTE: 11/8/83 take this aspRatio out on new QD with bit scaling }
                aspRatio := 1.0;
                RotateBox(bBox,tLoc,inf.tDat DIV 16);
                aspRatio := cScreenRatio;
            end;
        end;
    end; (* TxtBBox *)

(* ********************************************************************* *)
(*$S Core*)
    procedure SetObjFmFld(obj: TObjPtr; hf: HndField; hfs: HndFState);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    SetObjFmFld(',Ord(obj):8,',',Ord(hf):8,')');

        (* update all info in obj from field *)
        with hf^^,obj^,oDat,inf do begin
           { fgClr    := iClrBlack;   }            {set default colors}
           { bgClr    := iClrWhite;   }
            tLen     := curLen;
            tDat     := (tDat DIV 16) * 16 + align;
            tHnd     := Pointer(Ord(curValue));
            fLen     := curFmts;
            fHnd     := Pointer(Ord(fmtInfo));
        end;
        (* update field coords *)
        TxtBBox(obj,hf,hfs);
    end; (* SetObjFmFld *)

(* ********************************************************************* *)
(*$S Core*)
    procedure SetFldFmObj(obj: TObjPtr; hf: HndField);
    Var
        thisCBData: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    SetFldFmObj(',Ord(obj):8,',',Ord(hf):8,')');

        with obj^,oDat do begin
            With hf^^ do begin
                coords   := bBox;
                growLen  := 8;
                curLen   := inf.tLen;
                align    := inf.tDat MOD 16;
                drawPad  := ctxtPad;
                curValue := Pointer(Ord(tHnd));
                growFmts := 1;
                curFmts  := inf.fLen;
                fmtInfo  := Pointer(Ord(fHnd));
                protect  := FALSE;

                if traceCmd then
                    Writeln('        curLen:',curLen:4,', curFmts:',curFmts:4,
                                  ', maxLen:',maxLen:4,', maxFmts:',maxFmts:4);
            end;
            thisCBData := CbDataOfH(HzFromH(tHnd),tHnd);
            hf^^.maxLen   := thisCBData;
            thisCBData := CBDataOfH(HzFromH(fHnd),fHnd) div runSize;
            hf^^.maxFmts  := thisCBData;
        end;

    end; (* SetFldFmObj *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GetTxtFld(obj: TObjPtr; VAR thisFld: HndField;
                                      VAR thisFS: HndFState);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.fldSet and (obj=curDoc.txtObj) then begin
            thisFld := curTxtFld;
            thisFS  := curFState;
        end else begin
            thisFld := tempFld;
            SetFldFmObj(obj,thisFld);
            thisFS  := NIL;
        end;
    end; (* GetTxtFld *)

(* ********************************************************************* *)
(*$S Core*)
    procedure CloseCFld;
    var dummyFlag: Boolean;
        spFlag: Boolean;
        i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    CloseCFld(',curDoc.fldSet,',',Ord(curDoc.txtObj):8,')');

        if curDoc.fldSet then begin
            (* display field if haven't timed out since last insert *)
            if insFlag then
                dummyFlag := TxtTimeOut;

            (* compact data *)
            ExitField(curTxtFld,curFState);
            CompactField(curTxtFld);
            SetObjFmFld(curDoc.txtObj,curTxtFld,curFState);

            (* check field for all spaces *)
            spFlag := TRUE;
            with curTxtFld^^ do
            (*$R-*)
            for i := 0 to curLen-1 do
                spFlag := spFlag and (curValue^^[i]=Ord(' '));
            (*$IfC rangeOn*) (*$R+*) (*$EndC*)
            if spFlag then
                curDoc.txtObj^.oDat.inf.tLen := 0;

            (* set pointers to nil so don't accidently reference *)
            curDoc.fldSet := FALSE;
            curDoc.txtObj := NIL;
            (* clear the undo state *)
            uInfo.lastOp := noOp;
        end;
    end; (* CloseCFld *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure SetCFld(* obj: TObjPtr *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    SetCFld(',Ord(obj):8,')');

        if obj<>curDoc.txtObj then begin
            CloseCFld;
            SetFldFmObj(obj,curTxtFld);
            InitFState(curTxtFld,curFState);
            curDoc.fldSet := TRUE;
            curDoc.txtObj := obj;
            StartBlink(txtTime);
        end
    end; (* SetCFld *)

(* ********************************************************************* *)

(* Txt Transformations *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtCh(* ch: char; shFlag,aplFlag: Boolean *);
    Const
        BSP = 8;
    var errNum: Integer;
        scrnPt: Point;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* does not update display *)
        (* insert a character *)
        if curDoc.fldSet then begin
            (* turn the caret on *)
            CaretOn(curTxtFld,curFState);
            (* set timeOut to refresh ASAP *)
            txtTime := 0;
            insFlag := TRUE;

            (* if no fill then Xor erase before insert *)
            with curDoc.txtObj^,oDat do
            if inf.flPat=iFillClear then
                if curFState^^.valid then begin
                    GetTxtPt(inf.tDat MOD 16,tLoc,scrnPt);
                    DrawFldAt(curTxtFld,curFState,scrnPt,FALSE,FALSE);
                end;

            if Ord(ch)=BSP then begin
                if shFlag then begin
                    (* see if there is anything to forward space over *)
                    if aplFlag then
                        ForwardWord(curTxtFld,curFState,errNum)
                    else
                        ForwardSpace(curTxtFld,curFState,errNum);
                end else begin
                    if aplFlag then
                        BackWord(curTxtFld,curFState,errNum)
                    else
                        BackSpace(curTxtFld,curFState,errNum);
                end;
            end else
                InsCh(ch,curTxtFld,curFState,errNum);
            (* update bBox *)
            SetObjFmFld(curDoc.txtObj,curTxtFld,curFState);
        end;
    end; (* TxtCh *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtCopy;
    var errNum: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtCopy.');

        (* does not update display *)
        if curDoc.fldSet then begin
            CutCopyField(curTxtFld,curFState,FALSE,TRUE,errNum);
        end;
    end; (* TxtCopy *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtCut;
    var errNum: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtCut.');

        (* does not update display *)
        if curDoc.fldSet then begin
            CutCopyField(curTxtFld,curFState,TRUE,TRUE,errNum);
            { CkFldErr('TxtCut',errNum); }
            (* update bBox *)
            SetObjFmFld(curDoc.txtObj,curTxtFld,curFState);
        end;
    end; (* TxtCut *)

(* ********************************************************************* *)
(*$S Ring*)
    function  TxtPaste(* : BOOLEAN *);
    var errNum: Integer;
        i: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtPaste.');

        (* does not update display *)
        errNum := 0;
        if curDoc.fldSet then begin
            PasteField(curTxtFld,curFState,errNum,TRUE,maxTLen);
            (* check all fmts to make sure we have the font *)
            {
            with curTxtFld^^ do
                for i := 1 to curFmts do
                    if not (fmtInfo^^[i-1].font in
                            [p15tile,p12tile,p12cent,p10tile,p10cent,tile12,
                             cent12,tile18,cent18,tile24,cent24]) then
                        fmtInfo^^[i-1].font := p15Tile;
            }
            if traceOn then CkFldErr('TxtPst',errNum);
            (* update bBox *)
            SetObjFmFld(curDoc.txtObj,curTxtFld,curFState);
            With curDoc.txtObj^,oDat.inf do begin
                fgClr := iClrBlack;
                bgClr := iClrWhite;
                cSel := iSelEdt;
            end;
        end;
        TxtPaste := errNum=0;
    end; (* TxtPaste *)

(* ********************************************************************* *)
(*$S Undo*)
    procedure TxtUndo;
    var errNum: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtUndo');

        (* does not update display *)
        if curDoc.fldSet then begin
            UndoEdit(curTxtFld,curFState,errNum);
            if traceOn then CkFldErr('TxtUndo',errNum);
            (* update bBox *)
            SetObjFmFld(curDoc.txtObj,curTxtFld,curFState);
        end;
    end; (* TxtUndo *)

(* ********************************************************************* *)
(*$S Core*)
    procedure TxtMove(* xM,yM: Real *);
    var loc: Point;
        thisObj: TObjRec;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.fldSet then begin
            thisObj := curDoc.txtObj^;
            with thisObj.oDat,tLoc do
            SetPt2D(tLoc,x+xM,y+yM);
            TxtBBox(@thisobj,curTxtFld,curFState);
        end;
    end; (* TxtMove *)

(* ********************************************************************* *)
(*$S Ring*)
    procedure TxtFmt(* obj: TObjPtr; face,font: Integer *);
    var errNum: Integer;
        thisFld: HndField;
        thisFS:  HndFState;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtFmt(',face:2,',',font:2,')');

        (* does not update display *)
        if obj^.oDat.kind=iObjText then begin
            (* get the field associated with obj *)
            GetTxtFld(obj,thisFld,thisFS);
            (* make the Fmt change *)
            if thisFS=NIL then
                SetRunFormat(thisFld,thisFS,font,face,errNum)
            else begin
                UpdateRun(thisFld,thisFS,font,face,errNum);
                (* we never want to reshow on a timeout *)
                curFState^^.valid := TRUE;
            end;
            (* update bBox *)
            SetObjFmFld(obj,thisFld,thisFS);
        end;
    end; (* TxtFmt *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtCase  (*obj: TObjPtr; ncase: Integer*);
    type
        TCharHnd = ^TCharPtr;
        TCharPtr = ^TCharArray;
        TCharArray= packed Array[0..255] of Char;
    var charHnd: TCharHnd;
        ch: Char;
        i: Integer;
        iFirst,iLast: Integer;
        upperCase,lowerCase,lastQualifies,thisQualifies: Boolean;

        function GEQualifies(ch: Char): Boolean;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            GEQualifies := ((ch>='a') AND (ch<='z') OR (ch>='A') AND (ch<='Z'))
                           OR (ch='-') OR (Ord(ch)=224) OR (Ord(ch)=229);
        end;

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtCase(',ncase:2,')');

        (* does not update display *)
        with obj^.oDat do begin
            iFirst := 0;
            iLast  := inf.tLen-1;
            if obj=curDoc.txtObj then begin
                TxtCommit;
                with curFState^^.select.int do begin
                    iFirst := lpFst;
                    iLast  := lpLim-1;
                end;
            end;
            (* Set Case *)
            charHnd := Pointer(Ord(obj^.oDat.tHnd));
            if iFirst=0 then
                thisQualifies := FALSE
            else
                thisQualifies := GEQualifies(charHnd^^[iFirst-1]);
            for i := iFirst to iLast do begin
                ch := charHnd^^[i];
                lowerCase := nCase=1;
                upperCase := nCase=2;
                if nCase=3 then  begin
                    (*
                    NOTE: 11/7/83 this should use 'definition of a word' same as in field editor:
                    Function Qualifies(ch: Char): Boolean;
                    *)
                    lastQualifies := thisQualifies;
                    thisQualifies := GEQualifies(ch);
                    If (ch='''') and lastQualifies then thisQualifies := TRUE;
                    upperCase := thisQualifies AND NOT lastQualifies;
                end;
                if upperCase then begin
                    if (ch>='a') AND (ch<='z') then
                        ch := Chr(Ord(ch)-Ord('a')+Ord('A'));
                end else begin
                    if (ch>='A') AND (ch<='Z') then
                        ch := Chr(Ord(ch)-Ord('A')+Ord('a'));
                end;
                charHnd^^[i] := ch;
            end;
        end;
    end; (* TxtCase *)

(* ********************************************************************* *)
(*$S Arrange*)
    procedure TxtAlign(* obj: TObjPtr; jus: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtAlign(',jus:2,')');

        (* does not update display *)
        with obj^.oDat do
        if kind=iObjText then
            if (inf.tDat MOD 16)<>jus then begin
                SetCFld(obj);
                inf.tDat := (inf.tDat DIV 16) * 16 + jus;
                SetFAlign(curTxtFld,curFState,jus);
                (* update bBox *)
                SetObjFmFld(curDoc.txtObj,curTxtFld,curFState);
            end;
    end; (* TxtAlign *)

(* ********************************************************************* *)
(*$S Arrange*)
    procedure TxtLineUp(* jus: Integer *);
    var thisSel: TxSel;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.fldSet then begin
            curTxtFld^^.align := jus;
            thisSel := curFState^^.select;
        end;
    end; (* TxtLineUp *)

(* ********************************************************************* *)
(*$S Core*)
    procedure GetTxtBBox(* obj: TObjPtr *);
    var thisFld: HndField;
        thisFS:  HndFState;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    GetTxtBBox(',Ord(obj):8,')');

        if obj^.oDat.kind=iObjText then begin
            (* get the field associated with obj *)
            GetTxtFld(obj,thisFld,thisFS);
            (* compute field bbox *)
            TxtBBox(obj,thisFld,thisFS);
            (* update bBox *)
            SetObjFmFld(obj,thisFld,thisFS);
        end;
    end; (* GetTxtBBox *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtCommit;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* remove any space in the curValue array *)
        if curDoc.fldSet then begin
            (* compact arrays, also turns off hiliting *)
            ExitField(curTxtFld,curFState);
            (* update the text object *)
            SetObjFmFld(curDoc.txtObj,curTxtFld,curFState);
            (* turn hiliting back on *)
            curFState^^.newSel := TRUE;
            HiLightSel(curTxtFld,curFState,TRUE);
        end;
    end; (* TxtCommit *)

(* ********************************************************************* *)

(* Txt Selection *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtSel(* obj: TObjPtr; wrkPt: Point; shFlagOn: Boolean *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtSel(',Ord(obj):8,',',
                    wrkPt.h:4,',',wrkPt.v:4,',',Ord(shFlagOn):2,')');

        if obj^.oDat.kind=iObjText then begin
            if curDoc.fldSet and (curDoc.txtObj=obj) then begin
                if shFlagOn then
                    GrowSel(wrkPt,curTxtFld,curFState,mRect)
                else begin
                    HilightSel(curTxtFld,curFState,FALSE);
                    Select(wrkPt,curTxtFld,curFState,mRect,txtTime);
                end;
            end else begin
                SetCFld(obj);
                Select(wrkPt,curTxtFld,curFState,mRect,txtTime);
            end;
            StartBlink(txtTime);
        end;
    end; (* TxtSel *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtSelTrk(* wrkPt: Point; shFlagOn: Boolean *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtSelTrk(',wrkPt.h:4,',',wrkPt.v:4,',',Ord(shFlagOn):2,')');

        if curDoc.fldSet then begin
            while StillDown do begin
                GetMouse(wrkPt);
                if not PtInRect(wrkPt,mRect) then begin
                    mseMoved := TRUE;
                    GrowSel(wrkPt,curTxtFld,curFState,mRect);
                end;
            end;
            StartBlink(txtTime);
            ObscureCursor;
        end;
    end; (* TxtSelTrk *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtSelPt(* obj: TObjPtr; wrkPt: Point *);
    var mRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtSelWrd.');

        if obj^.oDat.kind=iObjText then begin
            if curDoc.txtObj<>obj then begin
                SetCFld(obj);
                Select(wrkPt,curTxtFld,curFState,mRect,txtTime);
            end;
            StartBlink(txtTime);
        end;
    end; (* TxtSelPt *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtSelWrd(* obj: TObjPtr; wrkPt: Point *);
    var mRect: Rect;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtSelWrd.');

        if (obj^.oDat.kind=iObjText) AND (obj^.oDat.inf.tDat<16) then begin
            if curDoc.txtObj<>obj then begin
                SetCFld(obj);
                Select(wrkPt,curTxtFld,curFState,mRect,txtTime);
            end;
            HilightSel(curTxtFld,curFState,FALSE);
            SelectWord(wrkPt,curTxtFld,curFState,mRect,txtTime);
            StartBlink(txtTime);
        end;
    end; (* TxtSelWrd *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtSelAll(* obj: TObjPtr *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtSelAll.');

        if (obj^.oDat.kind=iObjText) AND (obj^.oDat.inf.tDat<16) then begin
            SetCFld(obj);
            HilightSel(curTxtFld,curFState,FALSE);
            ExitField(curTxtFld,curFState);
            SelectAll(curTxtFld,curFState,txtTime);
            HilightSel(curTxtFld,curFState,FALSE);
            StartBlink(txtTime);
        end;
    end; (* TxtSelAll *)

(* ********************************************************************* *)
(*$S BasicOps*)
    procedure TxtSelFld (* obj: TObjPtr *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        SetCFld(obj);
        SetSel (curTxtFld,curFState,0,curTxtFld^^.curLen,tySelPar);
    end; (* TxtSelFld *)

(* ********************************************************************* *)

(* Txt Display Routines *)

{
(* ********************************************************************* *)

    procedure ZeroBuf(dst: LongInt; size: Integer);
    VAR p: ^Integer;
        i: Integer;
    begin
        for i := 1 to size DIV 2 do begin
            p := Pointer(dst);
            p^ := 0;
            dst := dst+2;
        end;
    end;

(* ********************************************************************* *)

    function BitTst(byteAddr: LongInt; bitNum: LongInt): Boolean;   EXTERNAL;
    procedure BitSet(byteAddr: LongInt; bitNum: LongInt);           EXTERNAL;

(* ********************************************************************* *)

    procedure RotateBuf(src,dst: LongInt; VAR rowBytes,height: Integer; amount: Integer);
    var numWBands,numBBands,rowWords,bufSize,band,row,word,bit,width,dstOSet,thisBit: Integer;
        (*
        srcWord,dstWord: Integer;
        srcAddr,dstAddr: ^Integer;
        minDst,maxDst: LongInt;
        *)
    begin
        if height>0 then begin
            rowWords  := rowBytes DIV 2;
            numWBands := (height+15) DIV 16;            (* dst rowWords *)
            numBBands := numWBands * 2;                 (* dst rowBytes *)
            width     := rowBytes*8;
            bufSize   := numBBands*8*rowBytes;
            dstOSet   := 2;

            (*
            minDst := dst;
            maxDst := dst;
            if traceCmd then begin
                writeln('RotateBuf(',src:8,',',dst:8,',',rowBytes:4,',',height:4,',',amount:4);
                writeln('          ',numWBands:4,',',numBBands:4,',',rowWords:4,',',bufSize:4);
            end;
            *)

            if (amount=3) OR (amount=1) then begin
                if amount=3 then begin
                    dst := dst-numBBands; (* set up dst for first pass *)
                    numBBands := -numBBands;
                end else begin
                    dst     := dst+numBBands-2+bufSize; (* set up dst for first pass *)
                    bufSize := -bufSize;
                    dstOSet := -2;
                end;
                for band := 1 to numWBands do begin
                    for row := 0 to 15 do begin
                        (* point to dst bottom *)
                        dst := dst+bufSize;
                        for word := 1 to rowWords do begin
                            for bit := 0 to 15 do begin
                                if BitTst(src,bit) then begin (*  BitTst(srcAddr,bit) *)
                                    thisBit := row;
                                    if amount=1 then
                                        thisBit := 15-row;
                                    BitSet(dst,thisBit);      (*BitOr( dstWord, thisBit);*)
                                end;
                                (*
                                if dst<minDst then
                                    minDst := dst
                                else if dst>maxDst then
                                    maxDst := dst;
                                *)
                                (* point to next dst word *)
                                dst := dst+numBBands;
                            end; (* bit *)
                            src := src+2;
                        end; (* word *)
                    end; (* row *)
                    dst := dst+dstOSet;
                end; (* band *)
                rowBytes := ABS(numBBands);
                height   := width;
            end else if amount=2 then begin
                dst := dst+bufSize-2;
                for row := 1 to height do begin
                    for word := 1 to rowWords do begin
                        for bit := 0 to 15 do begin
                            if BitTst(src,bit) then
                                BitSet(dst,15-bit);
                            (*
                            if dst<minDst then
                                minDst := dst
                            else if dst>maxDst then
                                maxDst := dst;
                            *)
                        end; (* bit *)
                        src := src+2;
                        dst := dst-2;
                    end; (* word *)
                end; (* row *)
            end;
            (*
            if traceCmd then
                writeln('    minmaxdst=',mindst:8,',',maxdst:8);
            *)
        end; (* height>0 *)
    end; (* RotateBuf *)
}

(* ********************************************************************* *)

    procedure ZeroBuf(dst: LongInt; byteCnt: Integer);
    EXTERNAL;
    procedure RotateBuf(src,dst: LongInt; VAR rowBytes,height: Integer; amount: Integer);
    EXTERNAL;
    procedure CkGEHz(s: String80);
    EXTERNAL;

(* ********************************************************************* *)
(*$S Core*)
    procedure DisplayTxt(obj: TObjPtr; ersFlag,ersForce,showSel: Boolean);
    Type TPtrPByte = ^TPByte;
         THndPByte = ^TPtrPByte;
    var thisHandle: QDHandle;
        scrnPt: Point;
        thisFld: HndField;
        thisFS:  HndFState;
        curRgn: RgnHandle;
        (* for rotation *)
        tempBits,rotBits: LongInt;
        hTempBits,hRotBits: TH;
        tempBMap: BitMap;
        amount,bufSize,bufHeight: Integer;
        savePort: GrafPtr;
        tempPort: GrafPort;
        oldBBox,newBBox: Rect;
        fPattern: Pattern;
        objHandle: ^TObjPtr;
        size:      Integer;
        savePenState: PenState;

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then with obj^,oDat do begin
            Writeln('    DisplayTxt(',Ord(obj):8,'): at',
                                  Round(tLoc.x):4,Round(tLoc.y):4);
            Write  ('              curLen=',inf.tLen:4);
            Write(', curFmts=',inf.fLen:4);
            Writeln(', align=',inf.tDat:4);
        end;

        with obj^,oDat do
        if (kind=iObjText) AND (curDoc.atr.zoomOn=0) then begin
            (* get the field associated with obj *)
            GetTxtFld(obj,thisFld,thisFS);
            (* display the field *)
            if inf.tLen=0 then
                ersFlag := FALSE
            else if ersFlag then begin
                ersFlag := (inf.flPat>iFillClear) {XXX or ersForce};
                {XXX take this out after next build
                     this is in for case where reshow rect that includes
                     entire coords, fld is being edited, results in
                     first part of field drawn without erase, and hence no
                     backPat, and rest of fld with }
                { commented out 11/1/83: see if it works!
                if ersFlag then
                    if thisFS<>NIL then
                        thisFs^^.validLp := 0;
                }
            end;
            GetTxtPt(inf.tDat MOD 16,tLoc,scrnPt);
            (* see if we need to rotate *)
            amount := inf.tDat DIV 16;
            If makingScpPic then begin
                If amount>0 then begin
                    PicComment(cPictHnd,inf.tLen,Pointer(Ord(tHnd)));
                    PicComment(cPicfHnd,inf.fLen*runSize,
                               Pointer(Ord(fHnd)));
                    size := SizeOf(TObjRec);
                    objHandle := Pointer(Ord(HAllocate(
                                         curDoc.hHz,size)));
                    objHandle^^ := obj^;
                    PicComment(cPicRTxt,size,Pointer(Ord(objHandle)));
                    FreeH(curDoc.hHz,Pointer(Ord(objHandle)));
                end  else begin
                    thisHandle := Pointer(Ord(HAllocate(curDoc.hHz,1)));
                    thisHandle^^ := inf.tDat;
                    PicComment(cPicTxtBeg,1,thisHandle);

                    FreeH(curDoc.hHz,Pointer(Ord(thisHandle)));
                end;
            end;
            if amount>0 then begin
                (* get the bBox of the field *)
                MoveField(thisFld,thisFS,scrnPt);
                (* allocate a bitmap to draw into *)
                oldBBox := thisFld^^.coords;
                (* calculate which part of the text will show after rotate *)
                (*
                dummyFlag := SectRect(oldBBox,
                *)
                tempBMap.rowBytes := ((oldBBox.right-oldBBox.left+15) DIV  16)*2; (* has to be even *)
                (* make height a multiple of 16 for efficiency *)
                bufHeight:= ((oldBBox.bottom-oldBBox.top+15) DIV 16)*16;
                bufSize  := tempBMap.rowBytes*bufHeight;
                SetRect(tempBMap.bounds,oldBBox.left,oldBBox.top,
                        oldBBox.left+tempBMap.rowBytes*8,oldBBox.top+bufHeight);
                If putScpFlag then
                    tempBits := ORD(PAllocate(savePHz,bufSize))
                else
                    tempBits := ORD(PAllocate(curDoc.pHz,bufSize));
                ZeroBuf(tempBits,bufSize);
                (*
                if traceCmd then begin
                    writeln('tempBMap,   oldBBox=',oldBBox.left:4,',',oldBBox.top:4,
                                              ',',oldBBox.right:4,',',oldBBox.bottom:4);
                    writeln('           rowBytes=',tempBMap.rowBytes:4,', bufHeight=',bufHeight:4,
                            ' bufSize=',bufSize:4);
                end;
                *)
                tempBMap.baseAddr := Pointer(tempBits);
                (* divert the output to the bitmap *)
                GetPort(savePort);
                OpenPort(@tempPort);
                SetRectRgn(tempPort.visRgn,-30000,-30000,30000,30000);
                SetRectRgn(tempPort.clipRgn,-30000,-30000,30000,30000);
                SetPort(@tempPort);
                SetPortBits(tempBMap);
                tempPort.portRect := tempBMap.bounds;
                tempPort.device   := savePort^.device;
            end;
            If printing or (scpClrFl and scpShPat)
                or((not scpClrFl) and curDoc.showPats)  then
                fPattern := fillPats[inf.flPat]
            else fPattern := initPat[inf.bgClr];
            BackPat(fPattern);
            DrawFldAt(thisFld,thisFS,scrnPt,showSel,ersFlag);
            if amount>0 then begin
                (* restore the output to the screen *)
                SetPort(savePort);
                (*
                if traceCmd then begin
                    CopyBits(tempBMap,thePort^.portBits,tempBMap.bounds,
                           tempBMap.bounds,thePort^.txMode,NIL);
                    FrameRect(tempBMap.bounds);
                    FrameRect(oldBBox);
                end;
                *)
                (* allocate a bitmap to rotate into *)
                If putScpFlag then
                    rotBits := ORD(PAllocate(savePHz,bufSize))
                else
                    rotBits := ORD(PAllocate(curDoc.pHz,bufSize));
                (* zero the buffer *)
                ZeroBuf(rotBits,bufSize);
                (* rotate the bitmap *)
                RotateBuf(tempBits,rotBits,tempBMap.rowBytes,bufHeight,amount);
                tempBMap.baseAddr := Pointer(rotBits);
                (* get the scaled rotated text bbox *)
                newBBox := oldBBox;
                (*
                NOTE: 11/7/83 on new quickdraw:
                RotateBox(newBBox,tLoc,amount);
                *)
                (* get the unscaled rotated text BBox *)
                aspRatio := 1.0;
                RotateBox(oldBBox,tLoc,amount);
                { NOTE 11/7 as above for now:} newBBox := oldBBox;
                RotateBox(tempBMap.bounds,tLoc,amount);
                aspRatio := cScreenRatio;
                (* copy bit map to screen, stretching to proper aspRatio *)
                If thePort^.txMode=srcXor then
                    CopyBits(tempBMap,thePort^.portBits,oldBBox,newBBox,
                             srcXor,NIL)
                else if inf.flPat=iFillClear then
                    CopyBits(tempBMap,thePort^.portBits,oldBBox,newBBox,
                             srcOr,NIL)
                else
                    CopyBits(tempBMap,thePort^.portBits,oldBBox,newBBox,
                             srcCopy,NIL);

                if traceCmd then begin
                    FrameRect(tempBMap.bounds);
                    FrameRect(oldBBox);
                    with tempBMap.bounds do
                    writeln('    tempBMap= ',left:4,',',top:4,',',right:4,',',bottom:4);
                    with newBBox do
                    writeln('    newBBox=  ',left:4,',',top:4,',',right:4,',',bottom:4);
                end;
                (* free the bitmap *)
                If putScpFlag then begin
                    FreeP(savePHz,Pointer(tempBits));
                    FreeP(savePHz,Pointer(rotBits));
                end else begin
                    FreeP(curDoc.pHz,Pointer(tempBits));
                    FreeP(curDoc.pHz,Pointer(rotBits));
                end;
                {DisposeRgn(tempPort.clipRgn); redundant}
                {DisposeRgn(tempPort.visRgn);}
                ClosePort(@tempPort);
            end;
            (* restort the backPat *)
            BackPat(white);
        end;
        If amount=0 then
            PicComment(cPicTxtEnd,0,NIL);
    end; (* DisplayTxt *)


(* ********************************************************************* *)
(*$S Core*)
    procedure TxtDraw(* obj: TObjPtr *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        DisplayTxt(obj,FALSE,FALSE,FALSE);
    end; (* TxtDraw *)

(* ********************************************************************* *)
(*$S Core*)
    procedure TxtShow(* obj: TObjPtr *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        TextMode(srcOr);
        DisplayTxt(obj,TRUE,FALSE,FALSE);
        TextMode(srcXor);
    end; (* TxtShow *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure TxtDrwScrap;
    var errNum: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        DrawScrap(errNum);
        if traceOn then CkFldErr('TxtDrwScrap',errNum);
    end; (* TxtDrwScrap *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure TxtHiLite(* showHiLite: Boolean *);
    var saveClip: RgnHandle;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.fldSet then begin
            STxtClip(saveClip);
            HiLightSel(curTxtFld,curFState,showHiLite);
            RTxtClip(saveClip);
        end;
    end; (* HiLiteCFld *)

(* ********************************************************************* *)

(* CurFld Routines *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure TxtStart(* scrnPt: Point; sameFmt: Boolean *);
    var protoRun: HndRuns;
        mRect: Rect;
        thisHandle: TH;

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtStart(',scrnPt.h:2,',',scrnPt.v:2,')');

        if not sameFmt then begin
            curDoc.fldSet := FALSE;
            GetTxtInfo;
        end;
        (* field info *)
        thisHandle := HAllocate(curDoc.hHz,runSize);
        curTxtFld^^.fmtInfo  := Pointer(Ord(thisHandle));
        thisHandle := HAllocate(curDoc.hHz,8);
        curTxtFld^^.curValue := Pointer(Ord(thisHandle));
        with curTxtFld^^ do begin
            maxLen   := 8;
            growLen  := 8;
            curLen   := 0;
            align    := curRun.lpFst;
            drawPad  := 4;
            maxFmts  := 1;
            growFmts := 1;
            curFmts  := 1;
            protect  := FALSE;
            fmtInfo^^[0] := curRun;
            fmtInfo^^[0].lpFst := 0;
        end;
        (* set the object to match field and bkPat *)
        SetObjFmFld(curDoc.txtObj,curTxtFld,NIL);
        With curDoc,txtObj^.oDat.inf do begin
            flPat  := curTPat;
            fgClr  := pnClr;
            bgClr  := fillClr[iObjText];
        end;
        (* init field state *)
        InitFState(curTxtFld,curFState);
        (* select at scrnPt *)
        Select(scrnPt,curTxtFld,curFState,mRect,txtTime);
        (* start caret blinking *)
        StartBlink(txtTime);
        curDoc.fldSet := TRUE;
    end; (* TxtStart *)

(* ********************************************************************* *)

(* Misc Txt Routines *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure GetTxtFid(* obj: TObjPtr; VAR plain: Boolean; VAR fid: TFntid *);
    var
        thisFld: HndField;
        thisFS:  HndFState;
        thisRun: Run;
        {thisInt: Interval;}
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('GetTxtFid(',Ord(obj):8,')');

        if obj^.oDat.kind=iObjText then begin
            (* get the field associated with obj *)
            GetTxtFld(obj,thisFld,thisFS);
            (* get the Fid *)

            {thisInt.lpFst := 0;}
            {thisInt.lpLim := thisFld^^.curLen;}
            {FmtFromInt(thisFld,thisFS,thisInt,plain,thisRun);}

            thisRun := thisFld^^.fmtInfo^^[0];   {new version 2/13/84}
            fid.fam      := thisRun.font;
            fid.seteface := thisRun.face;
            (* update bBox *)
            SetObjFmFld(obj,thisFld,thisFS);
        end;

        if traceCmd then
            Writeln('    GetTxtFid: plain=',plain:6,', fam=',fid.fam:2,
                    ', NilFace=',(fid.seteFace=[]):6);
    end; (* GetTxtFid *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure TxtInfo(VAR thisRun: Run; VAR thisPat: Integer);
    var fInfo:   hndRuns;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    TxtInfo.');

        (* get fmt and align info *)
        if curDoc.fldSet then with curDoc.txtObj^,oDat do begin
            SetObjFmFld(curDoc.txtObj,curTxtFld,curFState);
            fInfo := Pointer(Ord(fHnd));
            (*$R-*)
            thisRun := fInfo^^[inf.fLen-1];
            thisRun.lpFst := inf.tDat;
            thisPat := inf.flPat;
            (*$IfC rangeOn *) (*$R+*) (*$EndC *)
        end else begin
            thisRun.font  := curDoc.fid.fam;
            thisRun.face  := curDoc.fid.seteface;
            thisRun.lpFst := curDoc.align;
            thisPat := curTPat;
        end;
    end; (* TxtInfo *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure GetTxtInfo;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        TxtInfo(curRun,curTPat);
    end; (* GetTxtInfo *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure GetTxtLSpace(* var lSpace,ascent,descent: Integer *);
    var fInfo:   FontInfo;
        lFid:    TLFntID;
        errNum:  Integer;
        thisRun: Run;
        thisPat: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('    GetTxtLSpace.');

        TxtInfo(thisRun,thisPat);
        (* get new field offset *)
        with lFid do begin
            fam      := thisRun.font;
            seteFace := thisRun.face;
            dev      := devScreen;
        end;
        if FMFontMetrics(lFid,fInfo,errNum) then begin
            ascent  := fInfo.ascent;
            descent := fInfo.descent;
            lSpace  := fInfo.ascent+ fInfo.descent+ fInfo.leading;
        end else if rangeOn then
            Error('GetTxtLSpace - FMFontMetrics is FALSE',0,NONFATAL);
    end; (* GetTxtLSpace *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure GetCaretloc(* VAR loc: Point *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curFState<>NIL then
            loc := curFState^^.selectRect.topLeft;
    end; (* GetCaretloc *)

(* ********************************************************************* *)
(*$S IO*)
    procedure GetTxtState(* VAR fState: TGEFState *);
    var cheat:  ^TByte;
        thisObj: TObjPtr;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.fldSet then with curFState^^ do begin
            fState.lpFst := select.int.lpFst;
            fState.lpLim := select.int.lpLim;
            cheat        := @select.tySel;
            fState.tySel := cheat^;

            (* compact data *)
            thisObj := curDoc.txtObj;
            CloseCFld;
            curDoc.txtObj := thisObj;
            curDoc.fldSet := TRUE;
        end;
    end; (* GetTxtState *)

(* ********************************************************************* *)
(*$S IO*)
    procedure SetTxtState(* fState: TGEFState *);
    var cheatTySel: ^TTySel;
        val: TByte;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.fldSet then begin
            SetFldFmObj(curDoc.txtObj,curTxtFld);
            InitFState(curTxtFld,curFState);
            val := fState.tySel;
            cheatTySel := @val;
            SetSel(curTxtFld,curFState,fState.lpFst,fState.lpLim,cheatTySel^);
        end;
    end; (* SetTxtState *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure TxtSetFmt(* obj: TObjPtr; fid: TFntId *);
    var fInfo:   hndRuns;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        with obj^.oDat do
        if kind=iObjText then begin
            fInfo := Pointer(Ord(fHnd));
            fInfo^^[0].font := fid.fam;
            fInfo^^[0].face := fid.seteface;
        end;
    end; (* TxtSetFmt *)

(* ********************************************************************* *)

    procedure TxtValid;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curFState<>NIL then
            curFState^^.valid := TRUE;
    end; (* TxtValid *)

(* ********************************************************************* *)

    procedure TxtFontSub(* dev: Integer *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        UseSubstituteFont(TRUE,dev);
    end; (* TxtFontSub *)

(* ********************************************************************* *)
(*$S BasicOps*)
    function  TxtSelState(* : Integer *);
    var tState: Integer;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* see if we are replacing characters or inserting them *)
        tState := iTStNil;
        if curDoc.fldSet then begin
            if curFState^^.select.tyHilight=tyHiInvert then
                tState := iTStInvert
            else
                tState := iTStCaret;
        end;
        TxtSelState := tState;
    end; (* TxtSelState *)

(* ********************************************************************* *)
(*$S Ring2*)
    function  TxtTimeOut(* : Boolean *);
    var saveClip: RgnHandle;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd and traceEvt then with curFState^^ do
            Writeln('    TxtTimeOut: ', curDoc.fldSet,valid,selectOn,txtTime:6);

        TxtTimeOut := FALSE;
        if curDoc.fldSet then begin
            insFlag := FALSE;
            if not curFState^^.valid then begin
                TextMode(srcOr);
                DisplayTxt(curDoc.txtObj,TRUE,TRUE,TRUE);
                TextMode(srcXor);
                StartBlink(txtTime);
                TxtTimeOut := TRUE;
            end else if curFState^^.selectOn then begin
                (* txtTime is 0 after BackSpace past beginning *)
                if txtTime=0 then
                    txtTime := caretOnTime;
                (* set the clip rgn so that blink doesn't get out of phase *)
                STxtClip(saveClip);
                BlinkCaret(curTxtFld,curFState,txtTime);
                (* restore clip *)
                RTxtClip(saveClip);
            end;
        end;
    end; (* TxtTimeOut *)

(* ********************************************************************* *)
(*$S IO*)
    procedure TxtTerminate;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        FETerminate;
    end; (* TxtTerminate *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure TxtCaretOn;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if curDoc.fldSet then
            CaretOn(curTxtFld,curFState);
    end; (* TxtCaretOn *)

(* ********************************************************************* *)
(*$S Ring2*)
    procedure TxtBlinkCaret;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        (* start the caret blinking again *)
        if curDoc.fldSet then
            BlinkCaret(curTxtFld,curFState,txtTime);
    end; (* TxtBlinkCaret *)

(* ********************************************************************* *)
(*$S DeBug*)

    procedure TxtFldTrace(* f: Boolean *);
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        {$IFC FLDDEBUG }
        if traceOn then
            SetFldTest(f);
        {$ENDC }
    end; (* TxtFldTrace *)

(* ********************************************************************* *)
(*$S DeBug*)
    procedure DumpCurFld;

        procedure DumpGEFld;
        var i: Integer;
        begin
        {$IFC sampcalls} ALogCall; {$ENDC}
            with curTxtFld^^ do begin
                with coords do
                writeln('CurFld: coords=',left:4,',',top:4,',',
                                          right:4,',',bottom:4);
                writeln('        maxLen=',maxLen:4,', growLen=',growLen:4,
                                 ', curLen=',curLen:4,', align=',align:4,
                                 ', drawPad=',drawPad:4);
                writeln('        maxFmts=',maxFmts:4,', growFmts=',growFmts:4,
                                 ', curFmts=',curFmts:4,', protect=',Ord(protect):4);
                write  ('        txt(',Ord(curValue):8,')="');
                (*$R-*)
                for i := 1 to curLen do
                    write(Chr(curValue^^[i-1]));
                (*$IfC rangeOn*) (*$R+*) (*$EndC*)
                writeln('"');
                write  ('        fmt(',Ord(fmtInfo):8,')=');
                (*$R-*)
                for i := 1 to curFmts do
                    with fmtInfo^^[i-1] do
                        write('(',lpFst:2,',',font:2,{',',Ord(face):2,}')');
                (*$IfC rangeOn*) (*$R+*) (*$EndC*)
                writeln;
            end;
            with curFState^^ do begin
                with select,int do
                writeln('CurFS:  select=',lpFst:2,',',lpLim:2,',',
                                             Ord(tySel):2,',',Ord(tyHilight):2);
                with anchor,int do
                writeln('        anchor=',lpFst:2,',',lpLim:2,',',
                                             Ord(tySel):2,',',Ord(tyHilight):2);
                with selectRect do
                writeln('        selectOn=',Ord(selectOn):2,
                                 ', visCaret=',Ord(visCaret):2,
                                 ', selectR= ',left:4,',',top:4,',',
                                               right:4,',',bottom:4);
                writeln('        bsPtr =',bsPtr:2,
                                 ', space=',space.lpFst:2,',',space.lpLim:2,
                                 ', valid=',Ord(valid):2,
                                 ', validLp=',validLp:2,
                                 ', newSel=',Ord(newSel):2,
                                 ', changed=',Ord(changed):2);
            end;
        end;

    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceOn then begin
            Writeln;
            Writeln('DumpCurFld...cObj=',Ord(curDoc.txtObj):8,
                               ', cFld=',Ord(curTxtFld):8,
                               ', cFS =',Ord(curFState):8);
            if curDoc.fldSet then
                DumpGEFld
            else
                Writeln('    curFld not set');
        end;
    end; (* DumpCurFld *)

(* ********************************************************************* *)
(*$S Init*)

    procedure InitTxt;
    var i: Integer;
        protoRun: HndRuns;
    begin
        {$IFC sampcalls} ALogCall; {$ENDC}
        if traceCmd then
            Writeln('InitTxt');


        (* tell unit DAT how big a run is *)
        runSize   := SizeOf(Run);

        (* init current info *)
        curFState := Pointer(Ord(HAllocate(geHHz,SizeOf(FieldState))));
        curTxtFld := Pointer(Ord(HAllocate(geHHz,SizeOf(Field))));
        tempFld   := Pointer(Ord(HAllocate(geHHz,SizeOf(Field))));

        (* set up text protoObj fmt *)
        protoRun := Pointer(Ord(HAllocate(geHHz,runSize)));
        with protoRun^^[0] do begin
            lpFst := 0;
            font  := tile12;
            face  := [];
        end;
        protoObj[iObjText].oDat.fHnd := Pointer(Ord(protoRun));
        insFlag  := FALSE;
        curTPat  := iFillWhite; (* white *)
    end; (* InitTxt *)

END. (* unit *)


