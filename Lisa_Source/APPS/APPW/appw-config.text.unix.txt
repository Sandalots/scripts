{
cl:config



Gl:config
Obj:config
xiulinker
<xlib:cfglink

config
{{}
{ ---------------------------------------------------------------------- }




Program Preference;

{ WELCOME to the PREFERENCES WINDOW.
  Don't be alarmed by the mess, we're just moving in.

  The author apologizes for the lack of style and elegance exhibited in this code,
  perhaps someday truth and beauty will be mine and I will rewrite it. However,
  if truth and beauty ever does come to me I'll prabably just leave
  and sell reclaimed ski wax in the Dodge Ridge parking lot. See you there!}

{ If you are really intent on reading this code I recomend you read the
  Parameter Memory document and the Preferences Window document }

(********************************CHANGE LOG**************************************)
(*06/03/83  MAN 001   WHEN {T11}BUTTONS NOT FOUND GIVE ERROR MESSAGE ON WORKSHOP*)
(*07/10/83  MAN 002   ADDED PAPER UNIT MENU AND INCH AND METRIC MENUS           *)
(*07/13/83  GJC 002   added routine refresh for use after OPENWM during init.   *)
(*07/14/83  GJC 003   cleared screen (using paslibcall) before final exit       *)
(*07/08/83  MAN 004   deleted WMInit call and added TippeExit                   *)
(*07/08/83  MAN 005   closed all data segments that might be opened             *)
(*08/19/83  MAN 006   made it so you could hear the beep volume on the WorkShop *)
(*08/22/83  MAN 007   removed compile-time skipping of sys2lib stuff for WS     *)
(*09/06/83  MAN 008   BUG #FI178 -- OPENING PREFERENCES DOES NOT DRAW SCROLLBARS*)
(*09/07/83  MAN 009   CORRECT DOT-MATRIX PAPER SIZE SENDS TO PARAMETER MEMORY   *)
(*10/05/83  LAN 010   for PEPSI-eliminate "parallel" from device config menu    *)
(*10/10/83  LAN 011   substitute built-in and diskette for upper and lower      *)
(*                    twiggys in the boot from menu when necessary              *)
(*10/19/83  LAN 012   o.s. now makes this initial Sched_class call when         *)
(*                    starting the process                                      *)
(********************************************************************************)

{$SETC ONWORKSHOP := FALSE}
{$SETC FORINTL := TRUE}

USES
     {$U libos/SysCall    }  SysCall,
     {$U libos/PSysCall   }  PSysCall,
     {$U Obj:UnitStd    }  UnitStd,
     {$U Obj:UnitHz     }  UnitHz,

     {$U Obj:quickdraw  }  quickdraw,
     {$U Obj:FontMgr    }  FontMgr,
     {$U Obj:Storage    }  Storage,

     {$U obj:WM.Events  }  Events,
     {$U obj:WM.Menus   }  Menus,
     {$U obj:WM.Folders }  Folders,
     {$U Obj:WmlStd     }  WmlStd,
     {$U Obj:WmlCrs     }  WmlCrs,
     {$U obj:Wmlsb      }  Wmlsb,
     {$U obj:Wmlgrow    }  Wmlgrow,
     {$U obj:pmdecl     }  pmdecl,
     {$U obj:prStd      }  prStd,
     {$U obj:FilerComm  }  FilerComm,
     {$U libpl/paslibcall }  paslibcall,
     {$U obj:alertMgr   }  alertMgr,                                  (*MAN 006*)
     {$U obj:prMgrutil  }  prMgrutil,                                 (*MAN 007*)
     {$U obj:prMgr      }  prMgr,                                     (*MAN 007*)

{$IFC NOT ONWORKSHOP}
     {$U obj:dbenv      }  dbenv,
{$ELSEC}
    {$U-}
     {$U dblib          }  dbenv,
    {$U+}
{$ENDC}
     {$U appw/check     }  checkbox,
     {$U Obj:hwint      }  hwint,
     {$U obj:PMM        }  PMM;

{$S cfgHot}
{$R-}

{$IFC CFGSYMBOLS}
   {$D+}
{$ELSEC}
   {$D-}
{$ENDC}

{$SETC USEFILER := TRUE}
{$SETC PRODUCTION := TRUE}

CONST
 { one thing the casual code peruser will notice is the miasma of constants
   declared here. Personally, I'm not too big on constants but I had no choice.
   The miasma breaks down into the following:
      First we have the debug flag trick.
      Second we have the alert constants.
      Third we have the LDSN t11 buttons is bound to.
      Fourth a few heap sizes
      Fifth some menu constants.
   And now the fun starts.
      Sixth a list of constants that correspond to the ghost buttons in the btnfile.
      Seventh a list of menus that correspond to the menus in the btnfile.
      Eighth and last some usefull screen locations }

   {$IFC NOT CFGDEBUG}
   fdbg = false;
   {$ENDC}


{ Alert constants }
   alertversion = 1;
   adddisk = 5;
   removedisk = 6;
   removebootdisk = 7;
   bootchange = 8;
   addprinter = 9;
   printError = 10;
   tomanyprinters = 11;
   tofewprinters = 12;

{ LDSN }
   btnLDSN = 9;

{ heap sizes }
   HeapSize = 5000;       { size of the heap used by the Libraries }
   btnHeapSize = 13000;   { size of the button data }

   maxprinter = 3;    { should be in prstd }

{ Menu constants }
   muFiler = 2;
   muTool = 3;
   muDebug = 4;        { Menu file constants }
   muString = 5;    fststring = 1;  lststring = 7;
   muWord = 6;

{-------------------------------------------------------------------------------------}
{   Below are the constants that correspond to check box buttons and menus            }
(*  in  {T11}menus. Every Dynamic button, every menu, and some of the special static  *)
{   buttons have corresponding constants here. ANY CHANGE MADE TO THE MENU FILE       }
{   MUST BE REFLECTED HERE. BE SURE TO CHECK THE CASE STATEMENT THAT CONTROLS ANY MENU YOU      }
{   CHANGE.                                                                           }
{-------------------------------------------------------------------------------------}

 {---------------------- Ghost Buttons ---------------------------}
 { These constants correspond exactly to buttons in the menu file }

 { null btn used to display blank space - set in readghostbtn }
   btnempty = 0;

{ device buttons with checkboxes - use btncheck + device constant to access }
   btncheck = 1;

{ Device Buttons without Checkboxes - use btnInact + device constant to access }
   btninact = 11;

{ boot device buttons }           { Screen display constants for startup screen }
   BootMinBtn = 21;                BootBtnSpace = 15;  {space between boot buttons}
   BootLowerTwig = 21;
   BootUpperTwig = 22;
   BootParaBtn = 23;
   BootNetBtns = 30;             { three network boot buttons }
   BootBuiltIn = 33;
   BootSony1 = 34;
   BootMaxBtn = 34;                BootHeaderSpace = 5; {Extra space for header}

{ internal button }
   intrnlbtn = 35;

 {---------------------- Menus -------------------------}
 { These constants correspond to check form menus in the menu file }

{ The main check box menu and it's buttons }
   main = 0;               BtnDial = 0; BtnStrt = 1; BtnPrts = 2; BtnInternal = 3;


{ The menus that form the Convience Setting screen }
   muDflt = 1;                     { Default menu }
   NrmCont = 2;   NrmContBtns = 18;   { Normal Contrast - 18 buttons }
   DmCont = 3;    DimContBtns = 17;   { Dim Contrast - 17 buttons }
   Bpvol = 4;                      { Beep Volume }
   FdDelay = 5;                    { Fade Delay }
   Bgnrepeat = 6;                  { Initial Repeat Delay }
   Sbrepeat = 7;                   { Subsequent Repeat Delay }
   DblClick = 8;                   { Double Click Delay }

{ The menus that form the Start Up screen }
   muBtVol = 9;                    { Boot volume }
   muMemTest = 10;                 { Degree of memory test at boot }

{ Menus for device configuration screen }
{ Each line is a different menu }
   PortLabel = 11;    { the "Ports     Devices Currently Connected" label }
   FirstPort = 12;    { Where the port labels start }
   muASerial = 12;    { the ports }
   muBSerial = 13;    devbtn = 1;   { Location of the device button within the menu }
   muParallel = 14;
   muSlot11 = 15;
   muSlot12 = 16;
   muSlot21 = 17;
   muSlot22 = 18;
   muSlot31 = 19;
   muSlot32 = 20;

{------ Below are the various menus that changing a configuration can invoke --------}

 { Devices - an all ghost menu}
   Devices = 21;

 { Printers }
   Tiper = 22;     { Daiy Wheel }
   DotMtrx = 23;   { Dot Matrix }

     { Printer Configuration }
       DMPagestyle = 24;        btnCutSheet= 1; btnFanFold= 2;
       LQPagestyle = 25;

{$IFC ForIntl }
       LQPaperUnit = 26;      btninches = 1; btnmetric = 2;            (*MAN 002*)
       LQInchSizes = 27;
       LQMetrSizes = 28;
    { Dot Matrix page size options }
       DMPageSize = 29;       btnletter = 1; btnlegal  = 3;            (*MAN 009*)
                              btna4     = 7; btn210x12 = 9;

       wheel  = 30;          { Daisy wheel Print Wheel options }

{ The Internal Screen }
   MemUse = 31;     { Memory to use }
   muMseScal = 32;  { Mouse Scaling }
{$ELSEC }

       LQPageSize = 26;      { Daisy wheel page size options }
    { Dot Matrix page size options }
       DMPageSize = 27;       btn8x11 = 1; btn8x14 = 2;

       wheel  = 28;          { Daisy wheel Print Wheel options }

{ The Internal Screen }
   MemUse = 29;     { Memory to use }
   muMseScal = 30;  { Mouse Scaling }
{$ENDC }

{ Screen Locations }
   LeftMargin = 20;   { Usefull in many spots }
   DevBtnPos = 215;   { Where the device button always goes in a port menu }

Type

  DispString = String[2];        { Used to pass string to showrepeat }
  TBoxStr =  string[35];         { Used for text in menu file - hallocate? }
  TrgDev = Array [DevNone..MaxDev] of TC;
  TrgBoot = array [0..10] of TC;
  sDev = set of 0..30;

VAR
   {$IFC CFGDEBUG}
   fdbg: TF;
   {$ENDC}

   PminitStatus: integer;  { used only when running stand alone to remember the
                             result of the call to pminit. Of questionable use
                             now that the OS sets the defaults. }

   ToldToDie: TF;

   Wmevent: EventRecord;

(*{$IFC NOT ONWORKSHOP}*)   (*MAN 007*)
   Cfgalerts: TalertFile;
(*{$ENDC}*)

   RefNum, AlertRef: TC;

   ConfigID:   TC;

   PaperSizeLocation:  TC;  (*MAN 002*)


 { vars to read in data from button file }
   DataHandle:   ^hcheckmenus;
   btnhnd:       hcheckmenus;

{ Scroll bar vars }
   scrldscr:      TsbList;    {scroll bar descriptors - set in initscrollbars}
   vertscrl:      Thsb;
   hortscrl:      THsb;       {handles to scroll bars - set in initscrollbars}

{ Parameter memory records }
   BootFrom: TBootstuff;
   OutputRec: TOutPutStuff;
   InputRec: TInputStuff;
   IntrnlRec: TInternalStuff;


{ State information used mostly in device connection mode }
   Portmenu,              { Remembers what port menu was clicked }
   Delmenu: TC;           { Last port menu }

   CurDev: TDeviceType;   { The device currently connected to port portmenu }
   curDevBtn: TC;         { The current button in the device menu }

   KFeeder: packed record      { Variant for converting feeder types }
        case boolean of
           true: (eFeeder: Tfeeder);
           false: (iFeeder: 0..3);
   end;

   CurDevinfo: record     { The configuration word for the device }
        case integer of
          1: (PRRec: TPrPMWd);            { Printer configuration word in PrStd }
          2: (CfgWord: TdeviceInfo);      { Blind integer }
   end;

   CurScreen: TC;    { Startup, convenience, Config, or internal screen }

   CurPort: TPorts;  { The logical port for passing to pmread/writeconfig }
   DevMenu: TrgDev;  { What device is associated with each button in the device menu }
   BootMenu:TrgBoot; { What port is associated with each button in the boot menu }

   OrigConfig: array [parallel..Serialb] of TdeviceType; { The device config at init }
   DevOnPort: array [parallel..Serialb] of sDev;  { What devices can go on what ports }

   TwoPortCard: set of TPorts;    { subset of tports that applies to 2 port cards }

   DevInternal: sDev;
   ConfigDev: sDev;

   CardsInSlot: Slot_Array;  { initialized by call to cards_equipped in init stuff }

   the_info: minfo;    {record with machine information}    (*LAN 010*)

{ Record for display Black Box }
   BlackBox: Record
                BBRect: Rect;               { Where the Black Box is }
                Visible: boolean;         { When the black Box is visible }
             end;

   BoxStr:   array [fststring..lststring] of TBoxStr; { box text, read from menus }
   Linespc:  integer;           { Space betweens lines of text in the box }
   WordStr:  TBoxStr;           { Double click demo text }

{ Info to demo dim contrast }
   ShowDim: Record
              FudgeRect: rect;
              RealContrast: TC;
              DimisSet: boolean;
            end;

{ True -> the user is currently configuring a device and we will have to clear config
  menus }
   Clearlastmenus: boolean;

   printerCount: integer;    {number of printers currently connected - set in
                              showport and printer, no device cases}

   rgmuFldr:   ARRAY[muFiler..muWord] OF MenuInfo;   { menu array }

 { Current screen structure }
   hCheckForm:  THform;

   Errnum: integer;        {General error var }
{ ---------------------------------------------------------------------- }
{                            Forward Dec's                               }
{ ---------------------------------------------------------------------- }

{$IFC NOT PRODUCTION OR ONWORKSHOP}
Procedure printPM;
   forward;
{$ENDC}
procedure DrawScreen(withscrollbars, growfolder: boolean);
   forward;


{ ---------------------------------------------------------------------- }
{                            Pr Config                                   }
{ ---------------------------------------------------------------------- }

function portFromMenu(menu: TC): Tports;
{function: To convert from a menu constant to a Tport. }
begin
case menu of
   muaserial: portFromMenu := seriala;
   mubserial: portFromMenu := serialb;
   muparallel: portFromMenu := parallel;
   muslot11: portFromMenu := slot11;
   muslot12: portFromMenu := slot12;
   muslot21: portFromMenu := slot21;
   muslot22: portFromMenu := slot22;
   muslot31: portFromMenu := slot31;
   muslot32: portFromMenu := slot32;
   end;
end;

function menuFromPort(Port: Tports): TC;
{ Function: Translate a Tport into a useable 2 port card offset in a list of
            buttons or menus. }
begin
case port of
   seriala: menuFromPort := 0;
   serialb: menuFromPort := 1;
   parallel: menuFromPort := 2;
   slot11: menuFromPort := 3;
   slot12: menuFromPort := 4;
   slot21: menuFromPort := 5;
   slot22: menuFromPort := 6;
   slot31: menuFromPort := 7;
   slot32: menuFromPort := 8;
   end;
end;

procedure ShowDevices(VAR ShowDev: sDev; CurDevice: TC);
{Function: For a given port display only those devies that can be plugged into it.
           Fills Devmenu array.
           ShowDev is a set of devices that can go on this port
           CurDevice is the device whose button should be checked.}
var
   curbtn, Dev, vert, hort: TC;
   btnInternal, refBtn, Port: TC;

begin
curbtn := 1;
btnInternal := 0;
refbtn := 0;
vert := 20;

{ Display the device menu }
For Dev := Devnone to MaxDev do   {For all the devices}
   if Dev in showdev then         {If this device can go on this port}
      begin
      if RefBtn = 0 then       {Display the device next to the previous one}
         hort := LeftMarg
      else
         hort := hmastermu^^[devices]^^.rgbtn[RefBtn].boundr.botright.h + 10;
      if hort > 450 then
         begin
         hort := leftmarg;
         vert := 35;
         end;
      ResetBtnCoords(dev + 1,hort,vert);{ plus one for btns }
      refbtn := curbtn;
      if dev = CurDevice then
         curDevBtn := curbtn;
      replacebtn(hmastermu^^[devices],curbtn,dev + 1,false);{ plus one for btns }
      DevMenu[curbtn] := dev;
      curbtn := curbtn + 1;
      end;

      {clear the rest of the buttons}
      for port := curbtn to 10 do
         replacebtn(hmastermu^^[Devices], port, btnempty, false);
AddMenu(Devices,curDevBtn,hCheckForm);
end;

{------------------------------------------------------------------------------}

procedure ShowRepeat(DispStr: DispString; Flashpt: TC; rate: TC);
{Function:  Demo the repeat rates }

var
  temprect: rect;
  i: TC;
  Now: TL;
begin
      moveto(300,FlashPt-5);

      for i := 1 to 10 do
         begin
         DrawString(dispstr);
         now := timer;
         repeat until timer > now + rate;
         end;

      SetRect(temprect,300,FlashPt-20,600,FlashPt);
      EraseRect(TempRect);
end;

{------------------------------------------------------------------------------}

PROCEDURE DoCheck (iMu, iBtn: TC);
{ Function: Contains the checkbox semantics. Builds the screens and
  sets parameter memory according to input. It is one GIANT case statement and
  EVERY possible menu has a case and so do a lot of buttons.
  Note: The scattered "+1"s and "-1"s are due to the button numbers being one off
  from the actual parameter memory values }

label 10;

VAR
   i, start, stop: TC;  { loop control }
   temp: TPorts;        { more loop control an other dubious distinctions }
   temprect: rect;      { Do I really have to go through and explain all }
   temppt: point;       { these simple minded temporary variables. }
   Port: TC;            { I mean what good is it going to do. }
   slot: TC;            { Your obviously a bright, intelligent, compasionate }
   curbtn: TC;          { individual - do really need to spell it our for you. }
   BootBtn: TC;         { No, I think not. }
   BootPort: TPorts;
   Now: TL;             { So figure them out for yourself }

{ To convert from TPorts and integer buttons }
   kludge: record
           case boolean of
             true:  (dummy: byte;
                     eport: Tports);
             false: (intport: integer);
           end;

{ To convert ewhcl to buttons }
   WheelKludge: record
           case boolean of
             true:  (ewhcl: TEwhcl);
             false: (iwhcl: 0..8);
           end;

procedure ShowDblClick;
{Function: demo the double click rate.}
var
  i,
  vert,
  hort,
  caretpos,
  strlength: integer;
  wordrect,
  caretrect: rect;

begin
   {Get out bearings}
   with hCheckForm^^.rghmu[iMu]^^ do
      vert := mulp + rbb.botright.v - dvmarg;
   hort := 300;
   caretPos := TextWidth(@wordstr,1,length(wordstr) div 2)-1;
   strlength := TextWidth(@WordStr,1,length(WordStr));
   setrect(caretrect, hort+caretPos-1,vert-10,hort + caretPos,vert);
   setrect(wordrect, hort-1,vert-10, hort + strlength,vert+1);
   moveto(hort,vert);

   Drawstring(wordstr);

   for i := 1 to 3 do {do the demo}
      begin
      invertrect(caretrect);  {show a caret}
      now := timer;
      repeat until timer > now + inputrec.DoubleClick * 100;
      invertrect(caretrect);  {erase the caret}
      invertrect(wordrect);   {hilight the word}
      now := timer;
      repeat until timer > now + inputrec.DoubleClick * 100;
      invertrect(wordrect)    {unhilight the word}
      end;

   EraseRect(wordrect);       {clean the screen}
end;

function wheelFromButton(button: integer): Tewhcl;
{Function: converts a button number into an enumerated wheel type}
begin
case ibtn of
   1:wheelFromButton := ewhcl15;
   2:wheelFromButton := ewhcl12;
   3:wheelFromButton := ewhcl10;
   4:wheelFromButton := ewhclps;
   5:wheelFromButton := ewhclmf;
   6:wheelFromButton := ewhclmp;
   7:wheelFromButton := ewhclLCS;
   end;
end;

function ButtonFromWheel(whl: Tewhcl): integer;
{function: converts a wheel type to a button number}
begin
   case whl of
   ewhcl15: ButtonFromWheel := 1;
   ewhcl12: ButtonFromWheel := 2;
   ewhcl10: ButtonFromWheel := 3;
   ewhclps: ButtonFromWheel := 4;
   ewhclmf: ButtonFromWheel := 5;
   ewhclmp: ButtonFromWheel := 6;
   ewhclLCS: ButtonFromWheel := 7;
   end;
end;

{$IFC ForIntl }
function DMFromButton(button: integer): integer;                        (*MAN 009*)
{Function: converts a button number into a DM page size}
begin
case button of
   1:DMFromButton := btnletter;
   3:DMFromButton := btnlegal;
   5:DMFromButton := btna4;
   7:DMFromButton := btn210x12;
   end;
end;                                                                    (*MAN 009*)

function BtnFromDM(DMpgsz: integer): integer;                           (*MAN 009*)
{Function: converts a DM page size into a button number}
begin
case DMpgsz of
   btnletter:BtnFromDM := 1;
   btnlegal: BtnFromDM := 3;
   btna4:    BtnFromDM := 5;
   btn210x12:BtnFromDM := 7;
   end;
end;                                                                    (*MAN 009*)
{$ENDC }

procedure ShowConfiguration;
{Fuction: For the device connected to the port "clicked" show the apporpriate
          configuration.}
var
   thisBtn: INTEGER;
begin
with curdevinfo do
   begin

 { I know that the device menu is at DELMENU right now so, to erase any possible
   existing configuration menu, reset the form from delmenu + 1 }
   resetform(hCheckForm, delmenu + 1);
   if curdev in [Typer, DMPrinter] then
      with prrec, hCheckForm^^ do
         begin

         if Curdev = Typer then
            begin
            AddMenu(Tiper,btnnil,hCheckForm);
            AddMenu(LQpagestyle,ord(feeder)+1,hCheckForm);
         {$IFC ForIntl }
            AddMenu(LQpaperunit, (ipgsz div 7)+1, hCheckForm);         (*MAN 002*)
            if ipgsz <= 6 then
                AddMenu(LQInchSizes, ipgsz, hCheckForm)
            else
                AddMenu(LQMetrSizes, ipgsz-6, hCheckForm);
            PaperSizeLocation := cmu - 1;
         {$ELSEC }
            AddMenu(LQpagesize, ipgsz, hCheckForm);
         {$ENDC }
            AddMenu(wheel, buttonFromWheel(ewhcl),hCheckForm);
            end
         else
            begin
            AddMenu(DotMtrx,BtnNil,hCheckForm);
            AddMenu(DMpagestyle,ord(feeder)+1,hCheckForm);
         {$IFC ForIntl }
            AddMenu(DMpagesize, BtnFromDM(ipgsz), hCheckForm);          (*MAN 009*)
         {$ELSEC }
            thisBtn := btnnil;
            if ipgsz = ipg8x11 then
               thisBtn := btn8x11
            else
               thisBtn := btn8x14;
            AddMenu(DMpagesize, thisBtn, hCheckForm);
         {$ENDC }
            end;
         end;  { with prrec }
   end; { with curdevinfo }
end;

procedure ShowPort(targetPort: Tports);
{ Function: Throw up a menu for targetport
  Assumes: that this is called in a tight loop and that above the loop
           printercount has been set to 0. otherwise printercount will be wrong!}

begin
   if fdbg then
      writeln('entering showport');

 { Get the device on this port }
   PMReadConfig(targetPort,CurDev,CurDevinfo.cfgWord);

(*{$IFC NOT ONWORKSHOP}*)
   if curdev in [dmprinter, typer] then
      printercount := printercount + 1;
(*{$ENDC}*)

 { install the button for that device and display the menu }
   ResetBtnCoords(btnInact + Curdev,DevBtnPos,-1);
   ReplaceBtn(hmastermu^^[menufromport(targetPort)+firstPort],devbtn,btnInact + Curdev,false);
   AddMenu(menufromport(targetPort)+firstPort,BtnNil,hCheckForm);
end;

BEGIN
   IF fDbg THEN WRITELN ('DoCheck: iMu=', iMu:1, ',iBtn=', iBtn:1);

  { Turn off demo stuff }
      ShowDim.DimisSet := false;

  { if the user was configuring a device and has click elsewhere
    remove config menus }
      if ClearLastMenus then
         if imu <= Delmenu then
           begin
           ClearLastMenus := false;
           resetform(hCheckForm, delmenu);
           end;

  { Erase Black Box }
      with hCheckForm^^.rghmu[iMu]^^ do
      if (BlackBox.visible) and (idMu = main) and (iBtn <> btnDial) then
         with BlackBox do
            begin
            EraseRect(BBrect);
            visible := false;
            end;



{ This is the main case. Every menu has a case }
      CASE hCheckForm^^.rghmu[iMu]^^.idMu OF

  { The main menu only brings in other menus, setting the correct button. }
      main: begin
              resetForm(hCheckForm,imu);
              case ibtn of

    { Throw up the Memory test menu and the boot volume menu.
      The boot volume menu displayed consists of existing ports that do not
      currently have printers plugged into them.  BootMenu remembers what ports
      are at what buttons. }
           BtnStrt: begin
              CurScreen := BtnStrt;

              PMReadBoot(BootFrom);
              BootPort := BootFrom.eboot;
              curbtn := 1;


    If the_info.io_board = iob_lisa then                                         (*LAN 011*)
          begin
           { The twiggys are always there (sic) }                                (*LAN 011*)
              BootMenu[curbtn] := ord(upperTwig);
              replacebtn(hmastermu^^[muBtVol], curbtn,BootLowerTwig, false);
              if BootPort = upperTwig then
                 BootBtn := curbtn -1;
              curbtn := curbtn + 1;

              BootMenu[curbtn] := ord(lowerTwig);
              replacebtn(hmastermu^^[muBtVol], curbtn,BootUpperTwig, false);
              if BootPort = lowerTwig then
                 BootBtn := curbtn -1;
              curbtn := curbtn + 1;
            end                                                                  (*LAN 011*)
          else                                                                   (*LAN 011*)
          begin
           { For Pepsi, the built-in and sony are always there}                  (*LAN 011*)
              BootMenu[curbtn] := ord(hard_disk);                                (*LAN 011*)
              replacebtn(hmastermu^^[muBtVol], curbtn,BootBuiltIn, false);       (*LAN 011*)
              if BootPort = hard_disk then                                       (*LAN 011*)
                 BootBtn := curbtn -1;
              curbtn := curbtn + 1;

              BootMenu[curbtn] := ord(micro_disk);                               (*LAN 011*)
              replacebtn(hmastermu^^[muBtVol], curbtn,BootSony1, false);         (*LAN 011*)
              if BootPort = micro_disk then                                      (*LAN 011*)
                 BootBtn := curbtn -1;
              curbtn := curbtn + 1;
            end;                                                                 (*LAN 011*)

             { Display all the card ports that have proFiles }
               for slot := 1 to 3 do
                  begin

                  if cardsinslot[slot] = n_port_card then
                     begin
                     case slot of
                        1: start := ord(slot11);
                        2: start := ord(slot21);
                        3: start := ord(slot31);
                        end;

                     for port := start to start + 1 do
                        begin
                        kludge.intport := port;
                        pmreadconfig(kludge.eport,curdev,curdevinfo.cfgword);
                        if curdev = profile then
                           begin

                     { let me explain the machinations in the succeding call:
                       1: in the boot volume menu replace the current button pos
                          with the correct ghost button.
                       2: The correct ghost button is found by getting 2 port
                          card button offset from menufromport and adding the
                          position in the ghost button list of the first boot
                          botton to it.}

                           ResetBtnCoords(MenuFromPort(kludge.eport)+bootminbtn,
                                   LeftMargin,((curbtn) *  BootBtnSpace) +
                                   BootHeaderSpace);
                           replacebtn(hmastermu^^[muBtVol], curbtn,
                                   MenuFromPort(kludge.eport)+bootminbtn, false);
                           BootMenu[curbtn] := port;

                           if BootPort = kludge.eport then
                              BootBtn := curbtn -1;
                           curbtn := curbtn + 1;
                           end
                        end
                  end
                  {$IFC NOT PRODUCTION}
                  else
                     if cardsinslot[slot] = net_card then
                        begin
                        resetbtncoords(BootNetBtns+slot-1,LeftMargin,
                              ((curbtn) *  BootBtnSpace) + BootHeaderSpace);
                        replacebtn(hmastermu^^[muBtVol], curbtn,
                            BootNetBtns+slot-1,false);
                        BootMenu[curbtn] := start;
                        if ord(bootport) = start then
                           bootbtn := curbtn -1;
                        curbtn := curbtn +1;
                        end
                  {$ENDC}
              end;

             { Special case the parallel port also }
              PMReadConfig(parallel,curdev,curdevinfo.cfgword);
              if curdev = profile then
                 begin
                 ResetBtnCoords(BootParaBtn,LeftMargin,((curbtn) * BootBtnSpace)
                                + BootHeaderSpace);
                 replacebtn(hmastermu^^[muBtVol], curbtn,
                                       BootParaBtn, false);
                 BootMenu[curbtn] := ord(parallel);
                 if BootPort = parallel then
                    BootBtn := curbtn -1;
                 curbtn := curbtn + 1;
                 end;

              for port := curbtn to 10 do
                 replacebtn(hmastermu^^[muBtVol], port, btnempty, false);
              AddMenu(muBtVol, BootBtn + 1, hCheckForm);
              AddMenu(muMemTest, ord(BootFrom.ExtendMem) + 1, hCheckForm);
           end;

          { Put up the convience menus }
              BtnDial: begin
                       CurScreen := BtnDial;

                       AddMenu(muDflt,btnnil,hCheckForm);
                       PMreadOutPut(OutputRec);
                       with OutputRec do
                          begin
                          AddMenu(NrmCont, NrmContBtns - NormCont, hCheckForm);
                          AddMenu(FdDelay, FadeDelay, hCheckForm);
                          AddMenu(DmCont, DimContBtns - DimCont, hCheckForm);
                          if beepvol = 0 then
                             AddMenu(Bpvol, 2, hCheckForm)
                          else
                             AddMenu(Bpvol, BeepVol + 3, hCheckForm);
                          end;
                       PMReadInput(InputRec);
                       with InputRec do
                          begin
                          AddMenu(BgnRepeat, BeginRepeat + 2, hCheckForm);
                          AddMenu(SbRepeat, SubRepeat + 1, hCheckForm);
                          AddMenu(DblClick, DoubleClick, hCheckForm);
                          end;
                       end;

     { Throw up all the ports and their devices }
              BtnPrts: begin
                    CurScreen := BtnPrts;
                    printerCount := 0;

                        { put up Ports Devices header }
                    AddMenu(portlabel,BtnNil,hCheckForm);

                        { display backplane ports }
                    kludge.dummy := 0;

                        { for all the slots }
                    for slot := 1 to 3 do
                       case cardsinslot[slot] of
                          no_card: if fdbg then
                                   writeln('no card in slot ',slot);

                          n_port_card:
                            begin
                            { for each port on the card }
                            case slot of
                               1: kludge.intport := ord(slot11);
                               2: kludge.intport := ord(slot21);
                               3: kludge.intport := ord(slot31);
                               end;

                            showport(kludge.eport);

                            kludge.intport := kludge.intport + 1;
                            showport(kludge.eport);
                            end;{ n_port_card case }

                 {$IFC NOT PRODUCTION}
                          Net_card: writeln('Apple Net Card in slot');

                          Apple_card: writeln('Apple Card in slot');

                          Laser_Card: writeln('Laser Card in slot');

                          otherwise writeln('unknown card in slot');
                 {$ENDC}
                          end; {card case}

                    if the_info.io_board = iob_lisa then showport(parallel);        (*LAN 010*)
                    showport(seriala);
                    showport(serialb);
                    end;{case instance}

           { Put up internal menus }
              {$IFC ONWORKSHOP}
              BtnInternal:
                 begin
                 CurScreen := BtnInternal;
                 PMReadDevolp(IntrnlRec);
                    with IntrnlRec do
                       begin
                       AddMenu(MemUse,(Mem_Loss div 250) + 1,hCheckForm);
                       (*
                       AddMenu(osconsl,osconsole + 1,hCheckForm);
                       AddMenu(appconsl,apconsole + 1,hCheckForm);
                       *)
                       AddMenu(muMseScal,ord(MouseScal) + 1,hCheckForm);
                       end;
                 end;
              {$ENDC}
              end; {ibtn Case}

              { draw the screen }
              drawscreen(true, true);
            end; {Main menu case}

{ Set Defaults }
      muDflt: begin
              with outputrec do
                 begin
                 normcont:= DfltNormCont;
                 dimcont := DfltDimCont;
                 beepvol := DfltBeepVol;
                 fadedelay := DfltFadeDelay;
                 end;
              PMWriteOutput(OutputRec);
              with InputRec do
                 begin
                 DoubleClick := DfltDoubleClick;
                 beginrepeat := DfltInitRepeat;
                 subrepeat := DfltSubRepeat;
                 end;
              PMWriteInput(InputRec);
              ResetForm(hCheckForm, main + 1);
              docheck(main,curScreen);
              end;

{ Normal Contrast through Fade Delay.
  The (ibtn - X)*(-1) is to convert button numbers into PM numbers. X is the number
  of buttons. }
      NrmCont: begin
               OutputRec.Normcont := ((ibtn - NrmContBtns)*(-1));
               PMWriteOutput(OutputRec);
               end;

      DmCont: begin
              OutputRec.Dimcont := (ibtn - DimContBtns)*(-1);
              PMWriteOutput(OutputRec);

         { Set the contrast to the dim level so the user can see what it gets
           reset it when the mouse moves }
              SetContrast(DimConvert(OutPutRec.DimCont));
              ShowDim.RealContrast := OutPutRec.NormCont;
              ShowDim.DimisSet := true;
              GetMouse(temppt);
              setrect(showdim.fudgerect,temppt.h - 5,temppt.v - 5,temppt.h + 5,temppt.v + 5);
              end;

      BpVol: begin
             if ibtn = 2 then
                OutputRec.BeepVol := 0
             else
                OutputRec.BeepVol := ibtn - 3;
             PMWriteOutput(OutputRec);
(*{$IFC NOT ONWORKSHOP}*)                                              (*MAN 006*)
             BeepAlert(1);
             if outputrect.beepvol > 0 then
                begin
                Now := Timer;
                repeat
                until timer > now + 100;
                BeepAlert(3);
                end;
(*{$ENDC}*)
             end;

      FdDelay: begin
               OutputRec.FadeDelay := ibtn;
               PMWriteOutput(OutputRec);
               end;

{ Begin Repeat through Double Click Delay }
      BgnRepeat: begin
          { -2 because of the incetious relationship between the repeat menus }
                 InputRec.BeginRepeat := ibtn - 2;
                 PMWriteInput(InputRec);
                 ShowRepeat('* ',hCheckForm^^.rghmu[iMu]^^.mulp + 50,
                           inputrect.beginRepeat * 100);
                 end;

      SbRepeat:  begin
                 InputRec.SubRepeat := ibtn - 1;
                 PMWriteInput(InputRec);
                 showrepeat('*', hCheckForm^^.rghmu[iMu]^^.mulp + 35,
                           inputrect.SubRepeat * 100);
                 end;

      DblClick: begin
                 InputRec.DoubleClick := ibtn;
                 PMWriteInput(InputRec);
                 ClickDelay := InputRec.DoubleClick * 10;
                 ShowDblClick;
                 end;

{ Start up menu }
  { When Setting boot volume inform user that system will have to be rebooted
    before the change takes effect }
      muBtVol: begin
             BootFrom.iboot := BootMenu[ibtn];
{$IFC NOT ONWORKSHOP}
             NoteAlert(cfgalerts,bootchanged);
{$ENDC}
             PmWriteBoot(BootFrom);
             end;

      muMemTest: begin
                 BootFrom.ExtendMem := ibtn = 2;
                 PMWriteBoot(BootFrom);
                 end;

{ Main device configuration menu.  }
   muASerial,
   muBSerial,
   muParallel,
   muSlot11,
   muSlot12,
   muSlot21,
   muSlot22,
   muSlot31,
   muSlot32:
       with hCheckForm^^ do
          begin

          curport := portFromMenu(rghmu[imu]^^.idmu);

                 { Set state }
          ClearLastMenus := true;
          Delmenu := cmu - 1;
          if imu <> portmenu then
             MenuPush(hCheckForm^^.rghmu[portmenu],BtnNil);
          Portmenu := imu;

 { Set up curdev }
          PmReadConfig(curport,curdev,CurDevinfo.cfgWord);

 { show device list }
          showdevices(devonPort[curport], curdev);

 { show configuration }
          ShowConfiguration;

          drawscreen(true, true);
          end; { with hCheckForm^^ }

{ The devics menu }
      Devices: with curdevinfo do
               begin

{$IFC NOT ONWORKSHOP}
            { decrement printer count and Warn if removing last printer }
               if not (DevMenu[ibtn] in [typer,dmprinter]) and
                                           (curdev in [typer,dmprinter]) then
                  begin
                  if (printercount = 1) then
                     notealert(cfgalerts, tofewprinters);
                  printerCount := printerCount -1;
                  end;

            { Increment printer count and Stop if adding 4'th printer }
               if (DevMenu[ibtn] in [typer,dmprinter]) and
                   not (curdev in [typer,dmprinter]) then
                  if (printercount = maxprinter) then
                     begin
                     StopAlert(cfgalerts, tomanyprinters);
               { reset button to old device }
                     MenuPush(hCheckForm^^.rghmu[imu],curDevBtn);
                     goto 10;
                     end
                  else
                     begin
                     if not ((OrigConfig[curport] in [typer,dmprinter]) or
                             (curPort = seriala) or (curPort = serialb))then
                        notealert(cfgalerts, addprinter);
                     printerCount := printerCount +1;
                     end;

            { Warn the user that a disk change will take affect until later }
               if ((DevMenu[ibtn] = profile) and (curdev <> profile)) then
                    notealert(cfgalerts,adddisk);

               if ((DevMenu[ibtn] <> profile) and (curdev = profile)) then
                 begin
                 pmreadboot(BootFrom);
                 if ord(curport) = BootFrom.iboot then
                    notealert(cfgalerts,removebootdisk)
                 else
                    notealert(cfgalerts,removedisk);
                 end;
{$ENDC}

               if (DevMenu[ibtn] in [dmprinter,typer]) then
                  begin
                  if (curdev <> DevMenu[ibtn]) then
                      PrPmDefaults(DevMenu[ibtn],cfgword)
                  end
               else
                  cfgword := 0;

               curdev := DevMenu[ibtn];
               curdevBtn := ibtn;

            { Write out the new device with dumy configuration }
               PMWriteConfig(curport,curdev,cfgword);

            { Put the device next to the port }
               ResetBtnCoords(btnInact + DevMenu[ibtn],DevBtnPos,0);
               Replacebtn(hCheckForm^^.rghmu[Portmenu],devbtn,btnInact + DevMenu[ibtn],
                        true);

               showconfiguration;
10:
               drawscreen(true,true);
               end;

 { Printer Configuration stuff }
      DMPageStyle,
      LQPageStyle: with curdevinfo, kFeeder do
                    begin
                    iFeeder := ibtn -1;
                    PRRec.feeder := efeeder;
                    PMWriteConfig(CurPort,CurDev,CfgWord);
                    end;

   {$IFC ForIntl }
      LQPaperUnit:  with curdevinfo do                                 (*MAN 002*)
                    begin
                    start := hCheckForm^^.rghmu[PaperSizeLocation]^^.mulp;
                    with hCheckForm^^.rghmu[PaperSizeLocation]^^.rbb do
                        SetRect(tempRect, left, start+top, right+3, start+bottom+3);
                    EraseRect(tempRect);
                    if ibtn = btninches then
                       ReplaceMenu(PaperSizeLocation, LQInchSizes, PRRec.ipgsz, hCheckForm)
                    else
                       ReplaceMenu(PaperSizeLocation, LQMetrSizes, PRRec.ipgsz-6, hCheckForm);
                    drawscreen(true,true);
                    end;

      LQInchSize:   with curdevinfo do                                 (*MAN 002*)
                    begin
                    PRRec.ipgsz := ibtn;
                    PMWriteConfig(CurPort,CurDev,CfgWord);
                    end;

      LQMetrSize:   with curdevinfo do                                 (*MAN 002*)
                    begin
                    PRRec.ipgsz := ibtn + 6;
                    PMWriteConfig(CurPort,CurDev,CfgWord);
                    end;
  {$ELSEC }

      LQPageSize:  with curdevinfo do
                    begin
                    PRRec.ipgsz := ibtn;
                    PMWriteConfig(CurPort,CurDev,CfgWord);
                    end;

      DMPageSize:  with curdevinfo do
                    begin
                    if ibtn = btn8x11 then
                        PRRec.ipgsz := ipg8X11
                    else
                        PRRec.ipgsz := ipg8X14;
                    PMWriteConfig(CurPort,CurDev,CfgWord);
                    end;
  {$ENDC }

  {$IFC ForIntl }
      DMPageSize:  with curdevinfo do
                    begin
                    PRRec.ipgsz := DMFromButton(ibtn);                 (*MAN 009*)
                    PMWriteConfig(CurPort,CurDev,CfgWord);
                    end;
  {$ENDC }

      Wheel: with curdevinfo do
                begin
                PrRec.ewhcl := wheelFromButton(ibtn);
                PMWriteConfig(CurPort,CurDev,CfgWord);
                end;


{ Internal developement }
      {$IFC  ONWORKSHOP }
  { Amount of memory to run with }
      MemUse:begin
             intrnlRec.Mem_Loss := (ibtn - 1) * 256;
             PMWriteDevlp(IntrnlRec);
             end;

  { MouseScaling }
     muMseScal: begin
                intrnlRec.MouseScal := ibtn = 2;
                PMWriteDevlp(IntrnlRec);
                end;

      {$ENDC}

   END; {hCheckForm case}
END;{prcfgcmd}

{ ---------------------------------------------------------------------- }

PROCEDURE IdleProc {};
VAR pt: Point;
   TempRect: rect;
   temp: TC;
   icrs: TC;
BEGIN

   icrs := icrsInactive;
   GetMouse (pt);
   if ShowDim.DimisSet then
      with showdim do
         begin
         if not ptinrect(pt,fudgerect) then
            begin
            SetContrast(ConvertCont(Realcontrast));
            DimisSet := false;
            end;
         end;
   if Findbutton(hCheckForm, pt, temp, temp) then
      icrs := icrscheck;
   SetStdCursor(icrs);

END;

{ ---------------------------------------------------------------------- }
{                        Window Stuff                                    }
{ ---------------------------------------------------------------------- }

procedure ClipLessSBars(window: windowptr);
var
temprect: rect;
begin
tempRect := window^.portRect;
WITH tempRect DO
   BEGIN
   right := right - dhSbox + 1;
   bottom := bottom - dvSbox + 1;
   END;

ClipRect(tempRect)
end;

{ ---------------------------------------------------------------------- }

PROCEDURE InitScrollBars;
   { initializes scrollbar data structures }
VAR
   ptTopLeft : Point;

BEGIN
if fdbg then
    writeln('InitScrollBars');

InitWmlSb;  { initialize the scrollbar library }

   { intialize the scroll bar list descriptor }
InitSbList(scrldscr,theHeap);

   { set the topLeft pt to some arbitrary value.  Will be set in DrawScrollBars }
SetPt(ptTopLeft,0,0);

   { allocate the scroll bar data strucutures in the heap }
vertscrlH := sbCreate(scrldscr,hsbNil,tyvhV,ptTopLeft,0);
hortscrlH := sbCreate(scrldscr,hsbNil,tyvhH,ptTopLeft,0); { h scroll bar is now first }

   { Specify the set of scroll bar icons to be displayed, none for orphans }
SetSbIcons(vertscrlH,[]);
SetSbIcons(hortscrlH,[]);

if fdbg then
     writeln('   exit InitScrollBars');
END;

{------------------------------------------------------------------------------}

PROCEDURE DrawScrollBars(window : WindowPtr);
   { Paints the scroll bars.  Sets clipping to protect them. }

VAR
   rH,rV,tempRect : Rect;

BEGIN
if fdbg then
       writeln('DrawScrollBars');

SetPort(window);

   { Set clipping to whole folder so that scroll bars can be drawn }
ClipRect(window^.portRect);

   { get rectangles for scroll bars }
FlushRects(rH,rV);

   { set the rectangular area to be drawn }
SetSbRect(vertscrlH,rV);
SetSbRect(hortscrlH,rH);

   { display the scroll bars and grow icon }
PaintSb(hortscrlH);
PaintSb(vertscrlH);
PaintGrow;

   { set clipping to protect scroll bars }
ClipLessSBars(mywindow);
END;
{------------------------------------------------------------------------------}

PROCEDURE DownInWindow;

VAR
   rH,rV,oldPortRect,tempRect : Rect;
   oldBotRight,newBotRight,pt : Point;
   Err:integer;

BEGIN
if fdbg then
   writeln('DownInWindow');

SetPort(WMEvent.who);
pt := WMEvent.where;

   { Test for button down in "Grow" icon }
IF fGrowHit(pt) THEN
   BEGIN
   if fdbg then
      writeln('   Down in grow box');
      { save location of current botRight, portRect }
   oldBotRight := WMEvent.who^.portRect.botRight;
   oldPortRect := WMEvent.who^.portRect;

      { let user determine new size }
   DragFrame(pt,TRUE {draw scroll bars},newBotRight);

      { open up clipRgn }
   ClipRect(oldPortRect);
      { erase  vertical scroll bar if necessary }
   IF (newBotRight.h > oldBotRight.h) THEN
      BEGIN
      tempRect := oldPortRect;
      tempRect.left := tempRect.right - dhSbox + 1;
      EraseRect(tempRect);
      END;

      { erase  horizontal scroll bar if necessary }
   IF (newBotRight.v > oldBotRight.v) THEN
      BEGIN
      tempRect := oldPortRect;
      tempRect.top := tempRect.bottom - dvSbox + 1;
      EraseRect(tempRect);
      END;

      { compute new size }
   SubPt(WMEvent.who^.portRect.topLeft,newBotRight);

      { resize folder }
   FolderSize(WMEvent.who,newBotRight.h,newBotRight.v,FALSE {no update event});

 { Set clipping }
   ClipRect(WMEvent.who^.portRect);

      { put up scroll bars in new location }
   DrawScrollBars(MyWindow);

   ClipLessSBars(MyWindow);

   if WMEvent.who = MyWindow then
      drawscreen(true, false);
   END;

END;


{------------------------------------------------------------------------------}

procedure SizeFolder(MyWindow: WindowPtr; newlp: TC);
var
   temprect: rect;
begin
with mywindow^ do
   if newlp + dhsbox > portrect.botright.v - portrect.topleft.v then
       begin
       ClipRect(portRect);  { open up clipping to erase scrollbars }
       WITH portRect DO
          BEGIN
          SetRect(tempRect,left,bottom-dvSBox+1,right,bottom);
          EraseRect(tempRect);
          SetRect(tempRect,right-dhSBox+1,top,right,bottom);
          EraseRect(tempRect);
          FolderSize(MyWindow, botright.h - topleft.h, newlp + dhsbox, false);
          END;
       DrawScrollBars(MyWindow);
       ClipLessSBars(mywindow);
       end;
end;

{ ---------------------------------------------------------------------- }

PROCEDURE DisplayForm;
VAR i: TC;
  vert, hort:  integer;
BEGIN
   IF fdbg THEN WRITELN ('DisplayForm');
   WITH hCheckForm^^ DO
      begin
      FOR i := 0 TO cMu -1 DO
          MenuShow(rghmu[i], rghmu[i]^^.mulp);
      if rghmu[main]^^.ibtn = btndial then
         with BlackBox do
            begin
            with FntInfo do
                linespc := ascent + descent + leading;
            FillRect(BBRect,Black);
            TextMode(srcXor);
            hort := bbrect.topleft.h + 15;
            vert := bbrect.topleft.v + 20;
            moveto(hort,vert);
            for i := fststring to lststring do
                begin
                vert := vert + linespc;
                moveto(hort,vert);
                drawstring(boxstr[i]);
                end;
            visible := true;
            TextMode(SrcOr);
            end;
      end;
END;
{ ---------------------------------------------------------------------- }

procedure DrawScreen{withscrollbars, growfolder: booelan};
{Function: Draw the Screen.
           Grow the folder to accomodate the screen size if neccessary and wanted.
           Do the right thing with scroll bars.
}
begin
if growfolder then
   with hCheckForm^^.rghmu[hCheckForm ^^.cmu -1]^^ do
      SizeFolder(mywindow, mulp + rbb.botright.v);

DisplayForm;
ClipRect(WMEvent.who^.portRect);

if withscrollbars then
   drawscrollbars(MyWindow)
else
   hideSBorder(MyWindow^.portrect);
ClipLessSBars(mywindow);
end;

{ ---------------------------------------------------------------------- }

PROCEDURE InstallMenus;
VAR i, start,stop: INTEGER;
BEGIN
   {$IFC ONWORKSHOP}
   start := muTool;
   {$ELSEC}
   start := muFiler;
   {$ENDC}
   {$IFC PRODUCTION}
   stop := start;
   {$ELSEC}
   stop := muDebug;
   {$ENDC}
   IF fDbg THEN WRITELN ('InstallMenus');
   for  i := start TO stop DO InsertMenu(rgmuFldr[i],0);
   DrawMenuBar;
END;

{ ---------------------------------------------------------------------- }
{$IFC NOT PRODUCTION OR ONWORKSHOP}
Procedure printPM;
VAR
   CurDev: TDeviceType;
   BootFrom: TBootstuff;
   OutputRec: TOutPutStuff;
   InputRec: TInputStuff;
   dummy: TInternalStuff;
   Port: TPorts;
   ptrStr: ^Tsp;

begin
writeln(' Presenting Parameter Memory ');
PMReadInput(InputRec);
with inputrec do
  begin
  writeln('begin Repeat     ',beginrepeat);
  writeln('Next Repeat      ',subrepeat);
  writeln('Double  Click     ',DoubleClick);
  end;
PMReadOutPut(OutPutRec);
with OutPutrec do
  begin
  writeln('Normal contrast  ',Normcont);
  writeln('Dim contrast     ',Dimcont);
  writeln('Beep Volume      ',Beepvol);
  writeln('Fade Delay       ',FadeDelay);
  end;
PMReadBoot(BootFrom);
writeln('Boot volume      ',BootFrom.iboot);
for port :=  parallel to serialb do
   begin
   pmreadconfig(port,CurDev, CurDevinfo.cfgword);
   if port in TwoPortCard then
       begin
       ptrstr := @hmastermu^^[menufromport(port)+firstport]^^.rgbtn[0].hsp^^;
       write(ptrstr^);
       end
   else
       write(ord(port));
   case curdev of
      devnone:   write(' no device');
      profile:   write(' profile  ');
      corvus:    write(' corvus   ');
      Dmprinter: write(' Dmprinter');
      Typer:     write(' Typwriter');
      Modem:     write(' Modem    ');
      AppleNet:  write(' AppleNet ');
      otherwise  write(' unknown  ');
      end;
   if curdev in ConfigDev then
      with CurDevinfo.prrec do
         begin
         writeln(' feeder type is ',ord(feeder):1);
         writeln('                     pasgesize is ',ipgsz:1);
         if curdev = typer then
            writeln('                     wheel is ',ord(ewhcl):1);
         end
   else
      writeln;
   end;
PMReadDevlp(dummy);
  writeln('memloss is ',dummy.mem_loss);
  writeln('mon wd is ',dummy.mon_wd);
  writeln('timeoffset is ',dummy.timeoffset);
  writeln('mouseon is ',dummy.mouseon);
  writeln('osconsole is ',dummy.osconsole);
  writeln('apconsole is ',dummy.apconsole);
end;

{ ---------------------------------------------------------------------- }

procedure SetAllDefaults;
var
   Port: TPorts;
begin
    For port := parallel to serialb do
        pmwriteconfig(port,0,0);
    PMReadInput(InputRec);
    with inputrec do
      begin
      beginrepeat :=  dfltinitrepeat;
      subrepeat := dfltsubrepeat;
      DoubleClick := dfltDoubleClick;
      end;
    PmWriteInput(inputrec);

    PMReadOutPut(OutPutRec);
    with OutPutrec do
      begin
      Normcont := dfltNormcont;
      Dimcont := dfltDimcont;
      Beepvol := dfltBeepvol;
      FadeDelay := dfltFadeDelay;
      end;
    pmwriteoutput(outputrec);

    PMReadBoot(BootFrom);
    with BootFrom do
       begin
       eboot := uppertwig;
       Extendmem := dfltExtenmem;
       end;
    pmwriteboot(bootfrom);

    PMReadDevlp(IntrnlRec);
    with IntrnlRec do
      begin
      OSDS := 0;
      mem_loss := dfltmem_loss;
      mon_wd := dfltmon_wd;
      timeoffset := dflttime;
      mouseon := Dfltmouseon;
      end;
    pmwritedevlp(IntrnlRec);
end;
{$ENDC}

{$IFC CFGDEBUG}
PROCEDURE ConfigDbg ( f: TF );
BEGIN
   fDbg := f;
   checkdebug  (f);
END;
{$ENDC}
{ ---------------------------------------------------------------------- }

PROCEDURE MenuCommand(mu, mi: TC);
var
   error: integer;
BEGIN
   IF fDbg THEN WRITELN ('Fldr: MenuCommand: mu=', mu:1, 'mi=', mi:1);
   CASE mu OF


{$IFC USEFILER}
      muFiler: CASE mi OF
           1: DoFilingCmd(cmdclosall);
           2: DoFilingCmd(cmdclose);
           3:;
           4: begin
              PrBgdDlg(error,true);
              if error > 0 then
                 notealert(cfgalerts,printerror);
              end;
      END;
{$ENDC}

{$IFC NOT PRODUCTION OR ONWORKSHOP}
      muTool: CASE mi OF
         1: SetAllDefaults;
         2: begin
            pmwrite;
            toldtodie := true;
            hidecursor;
            SetPort(DeskPort);
            FillRect(DeskPort^.portRect,white);
            Exit(menuCommand);
            end;
      END;
{$ENDC}

{$IFC CFGDEBUG AND NOT PRODUCTION}
      muDebug: CASE mi OF
         1: printPM;
         2: configdbg(not fdbg);
         3: eventDebug := NOT eventDebug;
         4: drawscreen(true,true);
         5: PMWrite;
      END;
{$ENDC}

   END;
   HiLiteMenu (0);
END;

{$IFC ONWORKSHOP}
{---------------------------- PrcsDskEvent ----------------------------}
{ Attempt to Process a Disk event }

PROCEDURE PrcsDskEvent (VAR TheEvent: EventRecord);
VAR
     ErrNum: Integer;
     VName, DevName: E_Name;
     FSParms: UT_Parmt;
BEGIN
CASE TheEvent.KeyCap OF
     Disk1InCode, Disk1OutCode: DevName := 'UPPER';
     Disk2InCode, Disk2OutCode: DevName := 'LOWER';
     END;
CASE TheEvent.KeyCap OF
     Disk1InCode, Disk2InCode:
          BEGIN
          Mount (ErrNum, VName, DevName, DevName);
          IF (ErrNum > 0) AND (ErrNum <> 1052) THEN { call speaker};
          END;
     Disk1OutCode, Disk2OutCode:
          BEGIN
          UnMount (ErrNum, DevName);
          IF (ErrNum <= 0) OR (ErrNum = 1062) THEN
               BEGIN
               FSParms.Command := Eject;
               FSParms.Dev_Name := DevName;
               FS_Utilities (ErrNum, FSParms);
               END
          ELSE
               { call speaker };
          END;
     PowerCode: { ????? };
     END;
END;
{$ENDC }

{ ---------------------------------------------------------------------- }

PROCEDURE ProcessEvent;
VAR mu, mi:    TC;
    minTime:   LongInt;
    cErr:      TC;
    flrExt:    FilerExt;
    ptrstr: ^Tsp;

   FUNCTION SkipEvent (what: EventKind): TF;
   {Used to skip over aborted events.}
   BEGIN
      SkipEvent := FALSE;
   END;

BEGIN

   IF NOT SkipEvent (Wmevent.what) THEN
   CASE Wmevent.what OF

      buttonDown:
         IF Wmevent.who = menuFolder THEN
            begin
            MenuSelect (Wmevent.where, mu, mi);
            MenuCommand(mu,mi);
            end
         else
            if fgrowhit(WMEvent.where) then
                DownInWindow
            else
                IF Wmevent.who = mywindow THEN
                   IF FindMenuHit(hCheckForm, Wmevent.where, mu, mi) THEN
                       DoCheck (mu, mi);

      folderActivate:
         BEGIN
         if fdbg then
           writeln('activate Wmevent ');
         TakeControl (Wmevent,false,false);
         SetPort(Wmevent.who);
         InstallMenus;
         if Wmevent.who = mywindow then
            begin
            ClipLessSBars(mywindow);
            drawscreen(true, false);
            ValidRect(MyWindow^.portrect);
            DrawScrollBars(WMEvent.who);
            end;
         END;


      folderDeactivate:
         begin
         if Wmevent.who = mywindow then
            begin
            if fdbg then
                writeln('deactivate Wmevent');
            SetPort(Wmevent.who);
            cliprect(mywindow^.portrect);
            hideSBorder(MyWindow^.portrect);
            ClearMenuBar;

        { Write out PM }
            PMWrite;

        { Create picture for updates }
            wmOpenPic(MyWindow);
            ClipLessSBars(mywindow);
            DrawScreen(false,false);
            cliprect(MyWindow^.portrect);
            hideSBorder(MyWindow^.portrect);
            wmClosePic;
            end;
         GiveControl (Wmevent);
         end;

      folderUpdate:
         BEGIN
         if fdbg then
            writeln('update Wmevent');
         if Wmevent.who = mywindow then
            begin
            SetPort(Wmevent.who);
            ClipLessSBars(mywindow);
            end;

         {$IFC NOT USEFILER}
         rectrgn(wmevent.who^.visrgn,wmevent.who^.portrect);
         {$ENDC}

         BeginUpdate(Wmevent.who);
         if Wmevent.who = mywindow then
             DrawScreen(false, false);                                 (*MAN 008*)
         EndUpdate(Wmevent.who);
         END;

{$IFC NOT ONWORKSHOP}
      filerEvent:
         BEGIN
         GetAddParams (cErr, Wmevent, flrExt);

         CASE flrExt.theFlrOp OF

            fcNone:
               BEGIn
               if fdbg then
                  writeln('fcnone Wmevent');
               TakeWindow(Wmevent.who);
               SetPort(Wmevent.who);
               MyWindow := Wmevent.who;
               SetOrigin(0,0);
               ClipRect(wmevent.who^.portrect);
               eraserect(wmevent.who^.portrect);
               END;

            fcTerminate:
               BEGIN
               ImDying;
               ToldToDie := TRUE;
               END;

            fcClose, fcSuspend, fcShred:
               BEGIN
               TellFiler (cErr, docClosd, allOK, mywindow);
               END;

         END;
      END;
{$ELSEC }
        DiskEvent: PrcsDskEvent (Wmevent);                             (*MAN 004*)
{$ENDC}

   END;
END;

{ ---------------------------------------------------------------------- }
{$S cfgInit}
PROCEDURE ConfigInit (hz: THz);
{Function: Read the menus. Initialize the checkboxes.}

VAR fileMu: TEXT;
    i: TC;
    temprect: rect;
    port: Tports;
    error: TC;
    temp: itemptr;

BEGIN
   if fdbg then
      writeln('entering configinit');

   showdim.dimisset := false;
   ClearLastMenu := false;
   CurScreen := -1;
   PortMenu := 2;


{ Do the menu thing }
   RESET(fileMu,'{T11}MENUS.TEXT');
   if fdbg then
      IF IOResult<>0 THEN
         begin
         writeln('Cant find menus');
         end;

   FOR i := muFiler TO muWord DO ReadMenu (fileMu,rgmuFldr[i]);
   close(filemu);

{ read the box text form the menu file }
   for i := fststring to lstString do
      begin
      temp := @boxstr[i];
      getitem(rgmufldr[mustring],i, temp);
      end;

{ read the dbl click demo text }
   temp := @WordStr;
   getitem(rgmufldr[muWord],1,temp);

{ If Stand alone on the OS then create a folder }
{$IFC NOT USEFILER}
   SetRect(TempRect,33,33,653,313);
   mywindow := Newfolder(temprect,'Preferences',true,dialogfolder,0,My_id,80);
   makefldractive(mywindow, niluserdata);
   setport(mywindow);
{$ENDC}

   InitWmlCrs(Error);

{ set the lx to something strange so that bindlx will bind the font }
   oldlx.fb := true;
   oldlx.fi := true;
   oldlx.fam := 3;

{ save of the original configuration }
   for port := parallel to serialb do
       pmreadconfig(port,OrigConfig[port],i);

{ Establish what devices can go an what ports }
   DevOnPort[SerialA] := [DevNone,Typer,DMPrinter,Modem];
   DevOnPort[SerialB] := [DevNone,Typer,DMPrinter,Modem];

   for port := Parallel to Slot34 do
       DevOnPort[port] := [DevNone,DMPrinter,Profile];

   TwoPortCard := [parallel, slot11, slot12, slot21, slot22, slot31, slot32,
                                        seriala, serialb];

{$IFC (PRODUCTION) AND NOT (ONWORKSHOP)}
{remove internal button for production version}
   replacebtn(hCheckForm^^.rghmu[0],3,0,false);
{$ELSEC}
{install internal button for tippe version}
   with hCheckForm^^ do
       begin
       resetBtnCoord(intrnlbtn, rghmu[0]^^.rgbtn[2].boundr.botright.h + 10,0);
       replacebtn(rghmu[0],3,intrnlbtn,false);
       end;
{$ENDC}

      DevInternal := [];
      ConfigDev := [Typer,DmPrinter];

{ What cards are where }
   Cards_Equipped(error,CardsInSlot);

{ Initialize Black Box }
   with BlackBox do
      begin
      SetRect(BBRect,450,50,600,180);
      visible := false;
      end;

END;

{ ---------------------------------------------------------------------- }
{                        Aborts/Errors                                   }
{ ---------------------------------------------------------------------- }

FUNCTION HeapError(hz: Thz; bytesNeeded: TC): TC;
   VAR expansion,
       newdiscsize,
       newmemsize : longint;
       status : integer;
       dsinfo: dsinforec;

    BEGIN
    if fdbg then WRITELN('The Configuration Tool heap is full.-- Expanding   ');

    IF bytesneeded < 2*512 then expansion := 2*512
    else expansion := bytesneeded;

    Info_dataseg(Status,refnum,dsinfo);
    size_dataseg(status,refnum,expansion,newmemsize,expansion,newdiscsize);
    if status > 0 then
       BEGIN
       if fdbg then
          WRITELN('Expansion Failed  Status = ', status);
       HeapError := 0;
       END

    ELSE
       BEGIN
       if fdbg then
           if status < 0 then writeln('HeapError warning ',status);
       HeapError := newmemsize - dsinfo.mem_size;
       if fdbg then
          WRITELN('Configuration Tool expanded to ',newmemsize);
       END;
    END;


{ -------------------------------------------------------------------- }


{$IFC NOT ONWORKSHOP}
  procedure FailedAlert;
  begin
  stopalert(cfgalerts,2);
  end;
{$ENDC}

  { -------------------------------------------------------------------- }

  procedure FailedInit;
  begin
  if fdbg then
     writeln('failed Init');
  TellFiler(errnum,initfailed,internalerror,mywindow);
  halt;
  end;

{ -------------------------------------------------------------------- }

PROCEDURE LastWishes(environPtr : P_env_blk; excepDataPtr : P_ex_data);

BEGIN
ImDying;
END;

{ -------------------------------------------------------------------- }

{$IFC ONWORKSHOP}
PROCEDURE Refresh;      {GJC 002}
VAR
    Coverfolder:windowPtr;
    Frame:Rect;
BEGIN
Hidecursor;
WITH Deskport^.PortRect do
    Setrect (frame, left, top, right, bottom); {full screen}
Coverfolder := Newfolder (Frame,
                          '',             {no title}
                          TRUE,           {visible}
                          DialogFolder,   {behind nothing; over all }
                          0,              {Refcon }
                          My_Id,
                          80);            {icon number}

DisposeFolder (Coverfolder);
Drawmenubar;
Showcursor;
END;
{$ENDC}

PROCEDURE InitMain(var initerror: integer);
VAR Cfgheap:      THz;
    SegName:      PathName;
    Addr:         longint;
    cError:       integer;
    schedError:   integer;
    excepName:    T_Ex_Name;
    i, actualheapsize :integer;
    dsinfo:       dsinforec;
    origPrefix:   PathName;
    bootPath:     e_name;
    bootPrefix:   PathName;
    ecode:        integer;          (*LAN 010*)

BEGIN
{$IFC CFGDEBUG}
   configdbg(false);
{$ENDC}

   if fdbg then
      write('Calling unit inits');

   initerror := 0;

   {$IFC USEFILER}
   {Sched_Class(schedError,true);}                            (*LAN 012*)
   {$ENDC}

   {$IFC ONWORKSHOP}
   Get_Working_Dir(cError, origPrefix);
   Get_Config_Name(cError,OSBootVol(cError),bootPath);
   bootPrefix := concat('-',bootPath);
   Set_Working_Dir(cError, bootPrefix);
   {$ENDC}

   Mach_Info(ecode,the_info); {Lisa, Pepsi or Whopper?}          (*LAN 010*)

   InitGraf(@theport);

   OpenWM;
   SetPort(DeskPort);
  {$IFC ONWORKSHOP}
   TakeWindow(FilerFolder);
   FilerProcess := My_Id;
   Refresh;           (*  GJC 002  *)
  {$ENDC}
   if fdbg then
     writeln('*');

  {$IFC USEFILER}
   excepName := 'SYS_TERMINATE';
   Declare_Excep_Hdl (cError, excepName, @LastWishes);
   IF cError <> 0 THEN BEGIN
      TellFiler(cError, initFailed, noMemory, nil);
      ImDying;
      HALT;
   END;
  {$ENDC}



   ToldToDie := FALSE;
   ConfigID := My_ID;


{ open the button data segment }
   if fdbg then
      write('Creating configuration tool heap');
   Segname := '{T11}buttons';
   {$IFC USEFILER}
   Sched_Class(schedError,false);
   {$ENDC}
   Open_DataSeg (cError, SegName, Refnum, Addr, btnLDSN);
   {$IFC USEFILER}
   Sched_Class(schedError,true);
   {$ENDC}
   if cError <= 0 then
      SetAccess_DataSeg(cError, RefNum, False)  {Access R/W}
   else
      begin
  {$IFC ONWORKSHOP}                                                    (*MAN 001*)
      writeln('The Preferences Button file ({T11}buttons) cannot be found');
  {$ENDC}
      halt;
      end;

{ retrieve the handles }
   datahandle := pointer(ord(addr));
   btnhnd := datahandle^;

{ Stuff the handles from button file }
   with btnhnd^^ do
      begin
      hCheckForm := formMaster;
      hbtnmaster := btnMaster;
      hmastermu := menuMaster;
      end;

   hCheckForm^^.cmu := main + 1;
   hCheckForm^^.rghmu[main]^^.ibtn := btnnil;

{ create our heap on top of the buttons }
   Info_dataseg(cerror,refnum,dsinfo);

   InitHeap(pointer(addr+btnheapsize),pointer(addr + dsinfo.mem_size),@heaperror);
   if ord(theheap) = 1 then
      if fdbg then
         begin
         writeln;
         writeln('Can not allocate Heap in configuration tool');
         end
      else
         failedinit;

   InitScrollBars;

   if fdbg then
      write('PMinit InitAlert OpenPhraseFile');

   {$IFC NOT USEFILER}
   PMinit(pminitstatus);
   {$ENDC}

{$IFC NOT ONWORKSHOP}
   InitAlerts(3,1900,theheap,nil,@FailedAlert);
   if alerterror > 0 then
      FailedInit;

   {$IFC NOT USEFILER}
   PrGlobalInit;
   {$ENDC}
   PrMgrInit(cerror);
   if cerror > 0 then
      failedInit;

   OPenPhraseFile(AlertRef,'{T11}');
   if alerterror > 0 then
      FailedInit;

   Cfgalerts := ReadAlerts(AlertRef, AlertVersion);
   if alerterror > 0 then
      FailedInit;
   if fdbg then
       writeln('*');
{$ENDC}


   ConfigInit (TheHeap);

   Set_Working_Dir(cError, origPrefix);
END;

{ -------------------------------------------------------------------- }

{$IFC ONWORKSHOP}
PROCEDURE ExitWorkShop;                                                (*MAN 004*)
var ErrNum: integer; PInfo: ProcInfoRec; HeapRefNum: integer;
begin
    Info_Process(ErrNum, My_Id, PInfo);
    GiveWindow(FilerFolder, PInfo.Father_Id);
    FilerProcess := PInfo.Father_Id;
    WMKillProcess(My_Id);
    FlushInput (Nil);
    ScreenCtr(Cclearscreen); (* added by G.C. (4142) to do a final screen clear *)
                                                                       (*MAN 005*)
    Info_Address (ErrNum, ordHeap, HeapRefNum); {QuickDraw heap: (private)}
    if ErrNum <= 0 then
       Close_DataSeg (ErrNum, HeapRefNum);
    Info_LDSN (ErrNum, 15, HeapRefNum);         {Window Manager heap: WMDATA}
    if ErrNum <= 0 then
       Close_DataSeg (ErrNum, HeapRefNum);
    Info_LDSN (ErrNum, 16, HeapRefNum);         {Font Manager heap: FMDATA}
    if ErrNum <= 0 then
       Close_DataSeg (ErrNum, HeapRefNum);
                                                                       (*MAN 005*)
end;
{$ENDC}                                                                (*MAN 004*)

PROCEDURE MainProg;
var error: integer;
BEGIN
   InitMain(error);
   if error <> 0 then halt;

   REPEAT  { Main Program Loop }
      IF ImActive THEN BEGIN
         IF EventAvail THEN BEGIN
            GetEvent   (Wmevent);
            ProcessEvent;
         END
         ELSE BEGIN
            IdleProc;
            LetOthersRun;
         END;
      END
      ELSE BEGIN
         GetEvent(Wmevent);
         ProcessEvent;
      END;
   UNTIL ToldToDie;
  {$IFC ONWORKSHOP}
   ExitWorkShop;                                                       (*MAN 004*)
  {$ENDC}
END;

{ ---------------------------------------------------------------------- }
{                          Main Program                                  }
{ ---------------------------------------------------------------------- }

BEGIN
   WordStr := 'Copyright 1983, Apple Computer Inc.';
   MainProg;
END.

