Program Preference;

{ Welcome to the ALL Create Preferences Window.


  Through the extensive use of hallucenogens I have found truth and beauty. However,
  those same hallucenogens have also made me incapable of getting to Dodge Ridge to sell
  reclaimed ski wax in the parking lot.}



USES
     {$U libos/SysCall  }  SysCall,
     {$U libos/PSysCall }  PSysCall,
     {$U Obj:UnitStd    }  UnitStd,
     {$U Obj:UnitHz     }  UnitHz,

     {$U Obj:quickdraw  }  quickdraw,
     {$U Obj:FontMgr    }  FontMgr,
     {$U Obj:Storage    }  Storage,

     {$U obj:WM.Events  }  Events,
     {$U obj:WM.Menus   }  Menus,
     {$U obj:WM.Folders }  Folders,
     {$U Obj:WmlStd     }  WmlStd,
     {$U Obj:WmlCrs     }  WmlCrs,
     {$U obj:Wmlsb      }  Wmlsb,
     {$U obj:Wmlgrow    }  Wmlgrow,
     {$U libpm/pmdecl   }  pmdecl,
     {$U obj:FilerComm  }  FilerComm,
     {$U libpl/paslibcall}  paslibcall,
     {$U libpl/ppaslibc}   ppaslibc,
     {$U obj:alertMgr   }  alertMgr,
                           prStdInfo,
                           prPublic,
                           prEvents,
     {$U appw/UMM       }  UMM,
     {$U appw/check     }  checkbox,
     {$U appw/Upref     }  UPref,
     {$U obj:dbenv      }  dbenv,
     {$U Obj:hwint      }  hwint,
     {$U libpm/PMM      }  PMM;

{$S cfgHot}
{$R-}

{$IFC CFGSYMBOLS}
   {$D+}
{$ELSEC}
   {$D-}
{$ENDC}


CONST
 { one thing the casual code peruser will notice is the miasma of constants
   declared here. Personally, I'm not too big on constants but I had no choice.
   The miasma breaks down into the following:
      First we have the debug flag trick.
      Second we have the alert constants.
      Third we have the LDSN t11 buttons is bound to.
      Fourth a few heap sizes
      Fifth some menu constants.
   And now the fun starts.
      Sixth a list of constants that correspond to the ghost buttons in the btnfile.
      Seventh a list of menus that correspond to the menus in the btnfile.
      Eighth and last some usefull screen locations }

   {$IFC NOT CFGDEBUG}
   fdbg = false;
   {$ENDC}


{ LDSN }
   btnLDSN = 9;

{ heap sizes }
   HeapSize = 5000;       { size of the heap used by the Libraries }
   btnHeapSize = 30000;   { size of the button data }

{ Menu constants }
   muFiler = 2;
   muTool = 3;
   muDebug = 4;        { Menu file constants }
   muString = 5;    fststring = 1;  lststring = 7;
   muWord = 6;


{ Screen Locations }
   LeftMargin = 20;   { Usefull in many spots }
   DevBtnPos = 215;   { Where the device button always goes in a port menu }

Type

  DispString = String[2];        { Used to pass string to showrepeat }
  TBoxStr = s255;

VAR
   {$IFC CFGDEBUG}
   fdbg: TF;
   {$ENDC}

    ToldToDie:      BOOLEAN;
    toolIsInitialized:  BOOLEAN;
    firstActivate:  BOOLEAN;
    Wmevent:        EventRecord;

    RefNum:         INTEGER;

    ConfigID:       INTEGER;


(* This is the declaration in libpl/ppaslibc
   dsProcParam = record
                  case ProcCode : dsProcCode of
                    dsResProg    : (RProcessId : longint); {must be called before
                                                    the process starts running.}
                    dsSoftPwbtn  : (SPButton : boolean);        {result}
                    dsPrintDev   : (PrDevice : e_name);
                    dsSetGPrefix : (errnum : INTEGER;           {result}
                                    prefix : pathname);
                    dsEnbDisk    : (toEnbDisk : boolean);
                    dsGetDiskEnbF : (diskEnbF : boolean);       {result}
                  end;
*)

    procParam:      dsProcParam;

 { vars to read in data from button file }
   DataHandle:   ^hcheckmenus;

{ Scroll bar vars }
   scrldscr:      TsbList;    {scroll bar descriptors - set in initscrollbars}
   vertscrl:      Thsb;
   hortscrl:      THsb;       {handles to scroll bars - set in initscrollbars}

{ Parameter memory records }
   Output:      TOutPutStuff;
   InputRec:    TInputStuff;
   IntrnlRec:   TInternalStuff;
   bootInfo:    TBootStuff;

{ Record for display Black Box }
   BlackBox: Record
                BBRect: Rect;               { Where the Black Box is }
                Visible: boolean;         { When the black Box is visible }
             end;

   BoxStr:   array [fststring..lststring] of TBoxStr; { box text, read from menus }
   Linespc:  integer;           { Space betweens lines of text in the box }
   DoubleClickDemoText:  TBoxStr;           { Double click demo text }

{ Info to demo dim contrast }
   ShowDim: Record
              FudgeRect: rect;
              RealContrast: TC;
              DimisSet: boolean;
            end;

{ True -> the user is currently configuring a device and we will have to clear config
  menus }
   Clearlastmenus: boolean;


   menuArray:   ARRAY[muFiler..muWord] OF MenuInfo;   { menu array }

   Errnum: integer;        {General error var }
{ ---------------------------------------------------------------------- }
{                            Forward Dec's                               }
{ ---------------------------------------------------------------------- }

{$IFC CFGDEBUG}
Procedure printPM;
    FORWARD;
{$ENDC}
procedure DrawScreen(withscrollbars, growfolder: boolean);
    FORWARD;
PROCEDURE DoCheck (menuHit: TMenu; buttonHit: TC);
    FORWARD;
FUNCTION  EqualChar(source, dest: Ptr; nBytes: INTEGER): BOOLEAN; EXTERNAL;
PROCEDURE EnterLisaBug; EXTERNAL;
{------------------------------------------------------------------------------}
{$S PrefHot}
procedure ShowRepeat(DispStr: DispString; Flashpt: TC; rate: TC);
{Function:  Demo the repeat rates }

var
  temprect: rect;
  i: TC;
  Now: TL;
begin
      moveto(300,FlashPt-5);

      for i := 1 to 10 do
         begin
         DrawString(dispstr);
         now := timer;
         repeat until timer > now + rate;
         end;

      SetRect(temprect,300,FlashPt-20,600,FlashPt);
      EraseRect(TempRect);
end;

{------------------------------------------------------------------------------}

PROCEDURE ShowDblClick (menu: TMenu);
{Function: demo the double click rate.}
var
    i,
    vert,
    hort,
    caretpos,
    strlength:  integer;
    wordrect,
    caretrect:  rect;
    now:        longint;

begin
   {Get out bearings}
   with menu do
      vert := mulp + boundRect.botright.v - dvmarg;
   hort := 300;
   caretPos := TextWidth(@DoubleClickDemoText,1,length(DoubleClickDemoText) div 2)-1;
   strlength := TextWidth(@DoubleClickDemoText,1,length(DoubleClickDemoText));
   setrect(caretrect, hort+caretPos-1,vert-10,hort + caretPos,vert);
   setrect(wordrect, hort-1,vert-10, hort + strlength,vert+1);
   moveto(hort,vert);

   Drawstring(DoubleClickDemoText);

   for i := 1 to 3 do {do the demo}
      begin
      invertrect(caretrect);  {show a caret}
      now := timer;
      repeat until timer > now + inputrec.DoubleClick * 100;
      invertrect(caretrect);  {erase the caret}
      invertrect(wordrect);   {hilight the word}
      now := timer;
      repeat until timer > now + inputrec.DoubleClick * 100;
      invertrect(wordrect)    {unhilight the word}
      end;

   EraseRect(wordrect);       {clean the screen}
end;

{------------------------------------------------------------------------------}


PROCEDURE DefaultButton_MainMenu;
VAR btn: INTEGER;
{ puts up default printer, Start up from, and  Memory text menus  }
BEGIN
    root.BuildDefaultPrinterMenu;
    root.BuildBootFromMenu;
    PMReadBoot(bootInfo);
    btn := 2;
    IF bootInfo.extendMem THEN
        btn := 3;
    mainForm.AddMenu(cTestMemory, btn);
END;

{------------------------------------------------------------------------------}

PROCEDURE ConenienceButton_MainMenu;
BEGIN
    mainForm.AddMenu(muDfltConven,btnnil);
    PMreadOutPut(Output);
    with Output do
       begin
       mainForm.AddMenu(NrmCont, NrmContBtns - NormCont);
       mainForm.AddMenu(FdDelay, FadeDelay + 1);
       mainForm.AddMenu(DmCont, DimContBtns - DimCont);
       if beepvol = 0 then
          mainForm.AddMenu(Bpvol, 3)
       else
          mainForm.AddMenu(Bpvol, BeepVol + 4);
       end;
    PMReadInput(InputRec);
    with InputRec do
       begin
       mainForm.AddMenu(BgnRepeat, BeginRepeat + 3);
       mainForm.AddMenu(SbRepeat, SubRepeat + 2);
       mainForm.AddMenu(DblClick, DoubleClick + 2);
       end;
END;

{------------------------------------------------------------------------------}

PROCEDURE AttachButton_MainMenu;
VAR error:  INTEGER;
BEGIN
  { put up the main device configuration menu }
    root.BuildMenu(error);
END;

{------------------------------------------------------------------------------}

PROCEDURE RemoveButton_MainMenu;
VAR error:  INTEGER;
BEGIN
  { put up the main device configuration menu }
    BuildRemoveMenu;
END;

{------------------------------------------------------------------------------}

PROCEDURE InstallButton_MainMenu(menu: TMenu);
VAR error:  INTEGER;
BEGIN
  { put up the main device configuration menu }
    BuildInstallMenu;
END;

{------------------------------------------------------------------------------}

PROCEDURE MainMenu(menu: TMenu; button: INTEGER);
BEGIN
    mainForm.Reset(menu);
    CASE button OF
        btnDflt:     DefaultButton_MainMenu;
        btnConven:   ConenienceButton_MainMenu;
        btnAttach:   AttachButton_MainMenu;
        btnInstall:  InstallButton_MainMenu(menu);
        btnRemove:   RemoveButton_MainMenu;
        END;
END;

{------------------------------------------------------------------------------}

PROCEDURE DfltCoven_ConenMenu;
BEGIN

    DefaultPM;
    mainForm.Reset(TMenu(mainForm.menuArray.first));
    DoCheck(theMainMenu,btnConven);
    DrawScreen(FALSE, FALSE);
END;

{------------------------------------------------------------------------------}

PROCEDURE NrmCont_ConvenMenu(ibtn: INTEGER);
BEGIN
{ The (ibtn - NrmContBtns)*(-1) is to convert button numbers into PM numbers. NrmContBtns is the number
  of buttons. }
    Output.Normcont := ((ibtn - NrmContBtns)*(-1));
    PMWriteOutput(Output);
END;

{------------------------------------------------------------------------------}

PROCEDURE DimCont_ConvenMenu(ibtn: INTEGER);
VAR tempPt: Point;
BEGIN
{ The (ibtn - X)*(-1) is to convert button numbers into PM numbers. X is the number
  of buttons. }
    Output.Dimcont := (ibtn - DimContBtns)*(-1);
    PMWriteOutput(Output);

 { Set the contrast to the dim level for temporary feedback. Reset to normal level when the mouse moves }
    SetContrast(DimConvert(Output.DimCont));
    ShowDim.RealContrast := Output.NormCont;
    ShowDim.DimisSet := true;
    GetMouse(temppt);
    setrect(showdim.fudgerect,temppt.h - 5,temppt.v - 5,temppt.h + 5,temppt.v + 5);
END;

{------------------------------------------------------------------------------}

PROCEDURE BeepVol_ConvenMenu(ibtn: INTEGER);
VAR now:    LONGINT;
BEGIN
    if ibtn = 3 then
       Output.BeepVol := 0
    else
       Output.BeepVol := ibtn - 4;
    PMWriteOutput(Output);
    BeepAlert(1);
    if Output.beepvol > 0 then
       begin
       Now := Timer;
       repeat
       until timer > now + 100;
       BeepAlert(3);
       end;
END;

{------------------------------------------------------------------------------}

PROCEDURE DimDelay_ConvenMenu(ibtn: INTEGER);
BEGIN
    Output.FadeDelay := ibtn - 1;
    PMWriteOutput(Output);
END;

{------------------------------------------------------------------------------}

PROCEDURE InitialRepeat_ConvenMenu(menu: TMenu; ibtn: INTEGER);
BEGIN
          { -2 because of the incestuous relationship between the repeat menus }
    InputRec.BeginRepeat := ibtn - 3;
    PMWriteInput(InputRec);
    ShowRepeat('* ',menu.mulp + 50, inputrect.beginRepeat * 100);
END;

{------------------------------------------------------------------------------}

PROCEDURE SubseqRepeat_ConvenMenu(menu: TMenu; ibtn: INTEGER);
BEGIN
    InputRec.SubRepeat := ibtn - 2;
    PMWriteInput(InputRec);
    showrepeat('*', menu.mulp + 35, inputrect.SubRepeat * 100);
END;

{------------------------------------------------------------------------------}

PROCEDURE ClickRepeat_ConvenMenu(menu: TMenu; ibtn: INTEGER);
BEGIN
    InputRec.DoubleClick := ibtn - 2;
    PMWriteInput(InputRec);
    ClickDelay := InputRec.DoubleClick * 10;
    ShowDblClick (menu);
END;

{------------------------------------------------------------------------------}

FUNCTION ShouldContinue(connector: TPrefPOrt): BOOLEAN;
VAR
    device:     TPrefDevice;
    pmObject:   TPmObject;
    button:     TButton;
    lastMenu:   TMenu;
BEGIN
    ShouldContinue := TRUE;
    device := TPrefDevice(connector.connectedDevice);
    IF device <> NIL THEN
        IF device.isDetached THEN
            BEGIN
            PrefParamAlert(@device.name.ch, @emptyString);
            IF NOT CautionAlert(prefAlert, MapAlert(deferedIsAttached)) THEN
                BEGIN
                pmObject := PosWhere(connector.position, deferedList);
             {$IFC CFGDEBUG}
                IF pmObject = NIL THEN ABCBreak('NIL object returned from PosWhere in ShouldContinue',0);
             {$ENDC}
                list_PM.InsLast(pmObject);
                deferedList.DelObject(pmObject, FALSE);
                device.isDetached := FALSE;
              { Remove the "detached" from the button }
                lastMenu := TMenu(mainForm.menuArray.Last);
                lastMenu.ChangeButton(device.name, @emptyString);
                END
            ELSE
                ShouldContinue := FALSE;
            END;
END;

{------------------------------------------------------------------------------}

PROCEDURE RootMenu_AttachMenu(menu: TMenu; ibtn: INTEGER);
VAR port:   TPrefPort;
    error:  INTEGER;
    connector: TPrefPort;
BEGIN
    mainForm.Reset(menu);
    connector := TPrefPort(TDriverButton(menu.btnArray.elements[ibtn]).driver);
    IF ShouldContinue(connector) THEN
        connector.BuildMenu(error);
END;

{------------------------------------------------------------------------------}

FUNCTION HasDetachedDevice(card: TCard): BOOLEAN;
VAR
    i:      INTEGER;
    pos:    cd_position;
BEGIN
    HasDetachedDevice := FALSE;
    pos := card.position;
    FOR i := 1 TO card.connectors.size DO
        BEGIN
        pos.chan := i;
        IF PosToConnector(pos).connectedDevice <> NIL THEN
            BEGIN
            HasDetachedDevice := TRUE;
            Exit(HasDetachedDevice);
            END;
        END;
END;

{------------------------------------------------------------------------------}

PROCEDURE DetachError(error: INTEGER; thisAlert: INTEGER; thisMenu, ChangeMenu: TMenu;
                                                                            deviceIsPrinter: BOOLEAN);
VAR
    ptrStr1, ptrStr2:     ^TParamAlert;
    dummy:      TParamAlert;
    newName:    TDynamicArray;
    oldName:    TDynamicArray;
    alterButton: TButton;
BEGIN
    IF error > 0 THEN
        BEGIN

        WITH thisMenu DO
            BEGIN
            newName := TButton(btnArray.elements[ibtn]).text;
            IF oldBtn <> btnNIL THEN
                oldName := TButton(btnArray.elements[oldBtn]).text
            ELSE
                oldName := sUnknown;
            END;
        PrefParamAlert(@oldName.ch, @newName.ch);

        CASE error OF
        752,753:
                BEGIN
                IF deviceIsPrinter THEN
                    BEGIN
                    NoteAlert(prefAlert, MapAlert(PrinterInUse));
                    thisMenu.RestoreButton;
                    EXIT(DetachError);
                    END;

                WITH changeMenu DO
                    alterButton := TButton(btnArray.elements[ibtn + 1]);

                IF CautionAlert(prefAlert, MapAlert(thisAlert)) THEN
                    BEGIN
                    TDevicePort(thisMenu.port).DefferConnectedDevice(error);
                    IF error <> 0 THEN
                        NoteAlert(PrefAlert, MapAlert(errorDetaching));
                    alterButton.AppendText(sDetached);
                    WITH changeMenu DO
                        BEGIN
                  {$H-} alterButton.Erase(muLp);
                        alterButton.Draw(muLp); {$H+}
                        END;
                    mainForm.Reset(changeMenu);
                    END
                ELSE
                    thisMenu.RestoreButton;
                END;

            OTHERWISE
                BEGIN
                PrefParamAlert(@oldName.ch, @emptyString);
                NoteAlert(PrefAlert, MapAlert(errorDetaching));
                thisMenu.RestoreButton;
                END;
            END;
       END;
END;

{------------------------------------------------------------------------------}

PROCEDURE AttachError(error: INTEGER; name: pE_name; thisMenu: TMenu);
BEGIN
    IF error > 0 THEN
        BEGIN
        PrefParamAlert(name, @emptyString);
        IF error = pmFull THEN
            NoteAlert(prefAlert, MapAlert(pmFull))
        ELSE
            NoteAlert(prefAlert, MapAlert(cantAttachDevice));
        END;
    thisMenu.RestoreButton;
END;

{------------------------------------------------------------------------------}

PROCEDURE CnctToSlot_AttachMenu(menu: TMenu; ibtn: INTEGER);  { This ones shows all the cards available for a specific slot }
VAR selectedDevice: TChObject;
    newDevice:  TPrefPort;
    connectedDevice:    TPrefPort;
    error:              INTEGER;
    card:               TCard;
    i:                  INTEGER;
    connector:          TConnector;
    pos:                cd_position;
    tempPos:            cd_position;
    ptrStr:             ^e_name;
    thisAlert:          INTEGER;
    tempString:         e_name;

BEGIN
    error := 0;
    connectedDevice := menu.port.connectedDevice;
    selectedDevice := TChObject(TDriverButton(menu.btnArray.elements[ibtn]).driver);
    pos := menu.port.position;
    mainForm.Reset(menu);

    IF connectedDevice <> NIL THEN
        BEGIN
        IF ibtn <> cNothingBtn THEN
          { If the new device is the same as the current device then get out }
            IF EqualChar(@selectedDevice.name, @connectedDevice.name.ch, connectedDevice.name.size) THEN
                BEGIN
                connectedDevice.BuildMenu(error);
                EXIT(CnctToSlot);
                END;

      { Check for devices still attach to the card }
        IF PosHasKids(pos) THEN
            BEGIN
            IF EqualChar(@connectedDevice.name.ch, @sUnknown.ch, sUnknown.size) THEN
                NoteAlert(prefAlert, MapAlert(CardHasUnKnownDevices))
            ELSE
                BEGIN
                PrefParamAlert(@connectedDevice.name.ch, @emptyString);
                NoteAlert(prefAlert, MapAlert(cardHasDevices));
                END;
            menu.RestoreButton;
            connectedDevice.BuildMenu(error);
            EXIT(CnctToSlot_AttachMenu);
            END;
        END;

    thisAlert := SlotInUseSoCantAttach;
    IF iBtn = cNothingBtn THEN
        thisAlert := InUseSlot;

  { Remove any connectedDevice }
    TDevicePort(menu.port).RemoveConnectedDevice(error);
    IF error > 0 THEN
        DetachError(error, thisAlert, menu, theRootMenu, FALSE)
    ELSE
        IF iBtn = cNothingBtn THEN
            theRootMenu.ChangeButton(sNothing, NIL)
        ELSE
            BEGIN
            newDevice := selectedDevice.AttachDevice(error, menu.port);
            tempString := selectedDevice.name;
            IF error > 0 THEN
                AttachError(error, @tempString, menu)
            ELSE
                BEGIN
                theRootMenu.ChangeButton(NIL, @tempString);
              { Rebuild the menu }
                newDevice.BuildMenu(error);
                END;
            END;
END;

{------------------------------------------------------------------------------}

PROCEDURE InstallDriver_InstallMenu(menu: TMenu; ibtn: INTEGER);
VAR error:  INTEGER;
    newDevice:  TPrefPort;
    newDriver:  TChObject;
    dummy:      e_name;
BEGIN
    CopyDriver(error, TButton(menu.btnArray.elements[ibtn]).text, @dummy);
    menu.Hit(btnNIL);
END;

{------------------------------------------------------------------------------}

PROCEDURE RemoveDriver_RemoveMenu(menu: TMenu; ibtn: INTEGER);
VAR
    driver:     TChObject;
    tempString: e_name;
BEGIN
  { Test if this driver is currently installed }
    driver := TChObject(TDriverButton(menu.btnArray.elements[ibtn]).driver);
    PrefParamAlert(@driver.name, @emptyString);
    IF driver.InUse THEN
        NoteAlert(PrefAlert, MapAlert(deviceInUse))
    ELSE
        IF CautionAlert(prefAlert, MapAlert(confirmRemove)) THEN
            BEGIN
            tempString := driver.name;
            KillDriver(@tempString);
            END;
    mainForm.Reset(theMainMenu);
    BuildRemoveMenu;
END;

{------------------------------------------------------------------------------}

PROCEDURE CardMenu_AttachMenu(menu: TMenu; ibtn: INTEGER);
VAR error:      INTEGER;
    connector: TPrefPort;
BEGIN
    mainForm.reset(menu);
    connector := TPrefPort(TDriverButton(menu.btnArray.elements[ibtn]).driver);
    IF ShouldContinue(connector) THEN
        connector.BuildMenu(error);
END;

{------------------------------------------------------------------------------}

PROCEDURE CncToConnector_AttachMenu(menu: TMenu; ibtn: INTEGER);
VAR connectedDevice:    TPrefPort;
    selectedDevice:     TChObject;
    newDevice:          TPrefPort;
    error:              INTEGER;
    changeMenu:         TMenu;
    thisAlert:          INTEGER;
    tempString:         e_name;

BEGIN
    error := 0;
  { Get ready for what will come }
    connectedDevice := menu.port.connectedDevice;

    WITH mainForm.menuArray DO
        changeMenu := TMenu(elements[size - 1]);

    mainForm.Reset(menu);

    selectedDevice := TCddObject(TDriverButton(menu.btnArray.elements[ibtn]).driver);
  { If the new device is the same as the current device then get out }
    IF (connectedDevice <> NIL) AND (ibtn <> cNothingBtn) THEN
        IF EqualChar(@selectedDevice.name, @connectedDevice.name.ch, connectedDevice.name.size) THEN
            Exit(CncToConnector_AttachMenu);

    thisAlert := ConnInUseSoCantAttach;
    IF iBtn = cNothingBtn THEN
        thisAlert := InUseConn;

  { Remove any connectedDevice }
    TDevicePort(menu.port).RemoveConnectedDevice(error);
    IF error > 0 THEN
        BEGIN
        DetachError(error, thisAlert, menu, changeMenu, TDevice(connectedDevice).typeDevice = printer);
        EXIT(CncToConnector);
        END;

    IF iBtn = cNothingBtn THEN
        changeMenu.ChangeButton(sNothing, NIL)
    ELSE
        BEGIN
        newDevice := selectedDevice.AttachDevice(error, menu.port);
        tempString := selectedDevice.name;
        IF error > 0 THEN
            AttachError(error, @tempString, menu)
        ELSE
            changeMenu.ChangeButton(NIL, @tempString);
        END;
    END;

{------------------------------------------------------------------------------}

PROCEDURE DfltPrinter_DefaultMenu(menu: TMenu; ibtn: INTEGER);
VAR dfltPm:     TPmObject;
    i:          INTEGER;
BEGIN
    FOR i := 1 TO list_Pm.size DO
        TPmObject(list_Pm.elements[i]).SetDefault(FALSE);
    TPmObject(TDriverButton(menu.btnArray.elements[ibtn]).driver).SetDefault(TRUE);
    printerChanged := TRUE;
END;

{------------------------------------------------------------------------------}

PROCEDURE BootFrom_DefaultMenu(menu: TMenu; ibtn: INTEGER);
VAR
    driver: TPmObject;
    name:   TDynamicArray;
BEGIN
    PMReadBoot(bootInfo);
    driver := TPmObject(TDriverButton(menu.btnArray.elements[ibtn]).driver);
    bootPos := driver.config.pos;
    WITH bootInfo DO
        CASE bootPos.slot OF
            1:
                IF bootPos.chan = 1 THEN
                    bootVol := 3
                ELSE
                    IF bootPos.chan = 2 THEN
                        bootVol := 4;
            2:
                IF bootPos.chan = 1 THEN
                    bootVol := 6
                ELSE
                    IF bootPos.chan = 2 THEN
                        bootVol := 7;
            3:
                IF bootPos.chan = 1 THEN
                    bootVol := 9
                ELSE
                    IF bootPos.chan = 2 THEN
                        bootVol := 10;
            11: bootVol := 2;
            12: bootVol := 0;
            13: bootVol := 1;
        END;
    PMWriteBoot(bootInfo);

    NoteAlert(prefAlert, MapAlert(bootChanged));
END;

{------------------------------------------------------------------------------}

PROCEDURE MemoryTest_DefaultMenu(menu: TMenu; ibtn: INTEGER);
VAR dfltPm:     TPmObject;
    i:          INTEGER;
BEGIN
    PMReadBoot(bootInfo);
    bootInfo.extendMem := FALSE;
    IF ibtn = 3 THEN
        bootInfo.extendMem := TRUE;
    PMWriteBoot(bootInfo);
END;

{------------------------------------------------------------------------------}

PROCEDURE DoCheck {menuHit: TMenu; buttonHit: TC};
{ Function: Contains the checkbox semantics. Builds the screens and
  sets parameter memory according to input. It is one GIANT case statement and
  EVERY possible menu has a case and so do a lot of buttons.
  Note: The scattered "+1"s and "-1"s are due to the button numbers being one off
  from the actual parameter memory values }

VAR
    i, start, stop: INTEGER;  { loop control }
    temprect: rect;      { Do I really have to go through and explain all }
    error:  INTEGER;

BEGIN        {DoCheck starts here}
    IF fDbg THEN WRITELN ('Entering DoCheck');

  { Turn off demo stuff }
    ShowDim.DimisSet := false;

  { Erase Black Box }
    with menuHit do
 {$H-} if (BlackBox.visible) and (menuHit = mainForm.menuArray.first) and (iBtn <> BtnConven) then {$H-}
            with BlackBox do
                begin
          {$H-} EraseRect(BBrect); {$H+}
                visible := false;
                end;


{ This is the main case. Every menu has a case }

    CASE menuHit.idmu OF

        main:           MainMenu(menuHit, buttonHit);

    { These are the menus within the Convenience Menu }
        muDfltConven:   DfltCoven_ConenMenu;
        NrmCont:        NrmCont_ConvenMenu(buttonHit);
        DmCont:         DimCont_ConvenMenu(buttonHit);
        BpVol:          BeepVol_ConvenMenu(buttonHit);
        FdDelay:        DimDelay_ConvenMenu(buttonHit);
        BgnRepeat:      InitialRepeat_ConvenMenu(menuHit, buttonHit);
        SbRepeat:       SubseqRepeat_ConvenMenu(menuHit, buttonHit);
        DblClick:       ClickRepeat_ConvenMenu(menuHit,buttonHit);

    { These are the menus within the Defaults menu }
        cDefaultPrinter:    DfltPrinter_DefaultMenu(menuHit, buttonHit);
        cBootFrom:          BootFrom_DefaultMenu(menuHit, buttonHit);
        cTestMemory:        MemoryTest_DefaultMenu(menuHit, buttonHit);

    { These are the menus within the Device Connection menu }

        cRootMenu:          RootMenu_AttachMenu(menuHit, buttonHit);
        cCnctToSlot:        CnctToSlot_AttachMenu(menuHit, buttonHit);
        cCardMenu:          CardMenu_AttachMenu(menuHit, buttonHit);
        cCncToConnector:    CncToConnector_AttachMenu(menuHit, buttonHit);

    { This is the install menu }
        cInstall:           InstallDriver_InstallMenu(menuHit, buttonHit);

    { This is the remove menu }
        cRemoveDriver:      RemoveDriver_RemoveMenu(menuHit, buttonHit);

    { These are the menus within the Workshop menu }
    END; {mainForm case}
    IF (theMainMenu.iBtn <> BtnConven) OR (theMainMenu.oldBtn <> BtnConven) OR (mainForm.iMuKey = theMainMenu) THEN
        drawscreen(true, true);
END; {prcfgcmd}

{ ---------------------------------------------------------------------- }

PROCEDURE IdleProc {};
VAR pt: Point;
   TempRect: rect;
   temp: TC;
   dummy: TMenu;
   icrs: TC;
BEGIN

   icrs := icrsInactive;
   GetMouse (pt);
   if ShowDim.DimisSet then
      with showdim do
         begin
         if not ptinrect(pt,fudgerect) then
            begin
            SetContrast(ConvertCont(Realcontrast));
            DimisSet := false;
            end;
         end;
   if FindMenuAndButton(mainForm, pt, dummy, temp) then
      icrs := icrscheck;
   SetStdCursor(icrs);

END;

{ ---------------------------------------------------------------------- }
{                        Window Stuff                                    }
{ ---------------------------------------------------------------------- }
{$S PrefCold}
procedure ClipLessSBars(window: windowptr);
var
temprect: rect;
begin
tempRect := window^.portRect;
WITH tempRect DO
   BEGIN
   right := right - dhSbox + 1;
   bottom := bottom - dvSbox + 1;
   END;

ClipRect(tempRect)
end;

{ ---------------------------------------------------------------------- }
{$S PrefInit}
PROCEDURE InitScrollBars;
   { initializes scrollbar data structures }
VAR
   ptTopLeft : Point;

BEGIN
if fdbg then
    writeln('InitScrollBars');

InitWmlSb;  { initialize the scrollbar library }

   { intialize the scroll bar list descriptor }
InitSbList(scrldscr,theHeap);

   { set the topLeft pt to some arbitrary value.  Will be set in DrawScrollBars }
SetPt(ptTopLeft,0,0);

   { allocate the scroll bar data strucutures in the heap }
vertscrlH := sbCreate(scrldscr,hsbNil,tyvhV,ptTopLeft,0);
hortscrlH := sbCreate(scrldscr,hsbNil,tyvhH,ptTopLeft,0); { h scroll bar is now first }

   { Specify the set of scroll bar icons to be displayed, none for orphans }
SetSbIcons(vertscrlH,[]);
SetSbIcons(hortscrlH,[]);

if fdbg then
     writeln('   exit InitScrollBars');
END;

{------------------------------------------------------------------------------}
{$S PrefCold}
PROCEDURE DrawScrollBars(window : WindowPtr);
   { Paints the scroll bars.  Sets clipping to protect them. }

VAR
   rH,rV,tempRect : Rect;

BEGIN
if fdbg then
       writeln('DrawScrollBars');

SetPort(window);

   { Set clipping to whole folder so that scroll bars can be drawn }
ClipRect(window^.portRect);

   { get rectangles for scroll bars }
FlushRects(rH,rV);

   { set the rectangular area to be drawn }
SetSbRect(vertscrlH,rV);
SetSbRect(hortscrlH,rH);

   { display the scroll bars and grow icon }
PaintSb(hortscrlH);
PaintSb(vertscrlH);
PaintGrow;

   { set clipping to protect scroll bars }
ClipLessSBars(mywindow);
END;
{------------------------------------------------------------------------------}

PROCEDURE DownInWindow;

VAR
   rH,rV,oldPortRect,tempRect : Rect;
   oldBotRight,newBotRight,pt : Point;
   Err:integer;

BEGIN
if fdbg then
   writeln('DownInWindow');

SetPort(WMEvent.who);
pt := WMEvent.where;

   { Test for button down in "Grow" icon }
IF fGrowHit(pt) THEN
   BEGIN
   if fdbg then
      writeln('   Down in grow box');
      { save location of current botRight, portRect }
   oldBotRight := WMEvent.who^.portRect.botRight;
   oldPortRect := WMEvent.who^.portRect;

      { let user determine Create size }
   DragFrame(pt,TRUE {draw scroll bars},newBotRight);

      { open up clipRgn }
   ClipRect(oldPortRect);
      { erase  vertical scroll bar if necessary }
   IF (newBotRight.h > oldBotRight.h) THEN
      BEGIN
      tempRect := oldPortRect;
      tempRect.left := tempRect.right - dhSbox + 1;
      EraseRect(tempRect);
      END;

      { erase  horizontal scroll bar if necessary }
   IF (newBotRight.v > oldBotRight.v) THEN
      BEGIN
      tempRect := oldPortRect;
      tempRect.top := tempRect.bottom - dvSbox + 1;
      EraseRect(tempRect);
      END;

      { compute Create size }
   SubPt(WMEvent.who^.portRect.topLeft,newBotRight);

      { resize folder }
   FolderSize(WMEvent.who,newBotRight.h,newBotRight.v,FALSE {no update event});

 { Set clipping }
   ClipRect(WMEvent.who^.portRect);

      { put up scroll bars in Create location }
   DrawScrollBars(MyWindow);

   ClipLessSBars(MyWindow);

   if WMEvent.who = MyWindow then
      drawscreen(true, false);
   END;

END;


{------------------------------------------------------------------------------}

procedure SizeFolder(MyWindow: WindowPtr; newlp: TC);
var
   temprect: rect;
begin
with mywindow^ do
   if newlp + dhsbox > portrect.botright.v - portrect.topleft.v then
       begin
       ClipRect(portRect);  { open up clipping to erase scrollbars }
       WITH portRect DO
          BEGIN
          SetRect(tempRect,left,bottom-dvSBox+1,right,bottom);
          EraseRect(tempRect);
          SetRect(tempRect,right-dhSBox+1,top,right,bottom);
          EraseRect(tempRect);
          FolderSize(MyWindow, botright.h - topleft.h, newlp + dhsbox, false);
          END;
       DrawScrollBars(MyWindow);
       ClipLessSBars(mywindow);
       end;
end;

{ ---------------------------------------------------------------------- }
{$S PrefHot}
PROCEDURE DisplayForm;
VAR i: TC;
  vert, hort:  integer;
  menu: Tmenu;
BEGIN
    IF fdbg THEN WRITELN ('Entering DisplayForm - going to draw ',mainform.menuArray.size:1,' menus');
    mainForm.Draw;
    WITH mainForm DO
        begin
{$H-}   IF theMainMenu.ibtn = BtnConven THEN
            with BlackBox do
                begin
                with FntInfo do
                    linespc := ascent + descent + leading;
                FillRect(BBRect,Black);
                TextMode(srcXor);
                hort := bbrect.topleft.h + 15;
                vert := bbrect.topleft.v + 20;
                moveto(hort,vert);
                for i := fststring to lststring do
                    begin
                    vert := vert + linespc;
                    moveto(hort,vert);
                    drawstring(boxstr[i]);
                    end;
                visible := true;
                TextMode(SrcOr);       {$H+}
                end;
      end;
END;
{ ---------------------------------------------------------------------- }

procedure DrawScreen{withscrollbars, growfolder: booelan};
VAR menu:   TMenu;
{Function: Draw the Screen.
           Grow the folder to accomodate the screen size if neccessary and wanted.
           Do the right thing with scroll bars.
}
begin
if growfolder then
    BEGIN
    WITH mainForm do
        menu := TMenu(menuArray.elements[menuArray.size]);
    SizeFolder(mywindow, menu.mulp + menu.boundRect.botright.v);
    END;

DisplayForm;
ClipRect(WMEvent.who^.portRect);

if withscrollbars then
   drawscrollbars(MyWindow)
else
   hideSBorder(MyWindow^.portrect);
ClipLessSBars(mywindow);
end;

{ ---------------------------------------------------------------------- }
{$S PrefInit}
PROCEDURE InstallMenus;
VAR i, start,stop: INTEGER;
BEGIN
    IF onWorkShop THEN
        start := muTool
    ELSE
        start := muFiler;

   {$IFC CFGDEBUG}
   stop := muDebug;
   {$ELSEC}
   stop := start;
   {$ENDC}
   for  i := start TO stop DO InsertMenu(menuArray[i],0);
   DrawMenuBar;
END;

{ ---------------------------------------------------------------------- }
{$IFC CFGDEBUG}
Procedure printPM;
VAR
   Output:   TOutPutStuff;
   InputRec:    TInputStuff;
   dummy:       TInternalStuff;
   bootrec:     TBootStuff;
   ptrStr:      ^Tsp;
   config:      configdev;
   error:       INTEGER;
   entryKey:    LONGINT;

begin
writeln(' Presenting Parameter Memory ');
PMReadInput(InputRec);
with inputrec do
  begin
  writeln('begin Repeat     ',beginrepeat);
  writeln('Next Repeat      ',subrepeat);
  writeln('Double  Click     ',DoubleClick);
  end;
PMReadOutPut(Output);
with Output do
  begin
  writeln('Normal contrast  ',Normcont);
  writeln('Dim contrast     ',Dimcont);
  writeln('Beep Volume      ',Beepvol);
  writeln('Fade Delay       ',FadeDelay);
  end;
PMReadDevlp(dummy);
  writeln('memloss is ',dummy.mem_loss);
  writeln('mouseon is ',dummy.mouseon);
PMReadBoot(bootRec);
WITH bootRec DO
    BEGIN
    WRITELN('Boot location is ',bootVol);
    WRITELN('exented memory test is ',ExtendMem);
    END;

    {read entire PM into list_PM}
    entryKey := 0;
    PMREADCONFIG(error, entryKey, config);
    REPEAT
        WITH config.pos DO
            WRITELN(config.devname,' is at ',slot:1, '  ', chan:1,'  ', dev:1);
        PMREADCONFIG(error, entryKey, config);
    UNTIL (error > 0);
end;

{ ---------------------------------------------------------------------- }

procedure SetAllDefaults;
begin
(*
    DefaultPM;
    DefaultConfig;
*)
end;
{$ENDC}

{$IFC CFGDEBUG}
PROCEDURE PrefDbg ( f: TF );
BEGIN
   fDbg := f;
   checkdebug  (f);
END;
{$ENDC}
{ ---------------------------------------------------------------------- }
{$S PrefHot}
PROCEDURE MenuCommand(mu, mi: TC);
var
   error:   INTEGER;
   i, j:    INTEGER;
BEGIN
   IF fDbg THEN WRITELN ('Entering MenuCommand: menu =', mu:1, 'item =', mi:1);
   CASE mu OF


      muFiler: CASE mi OF
           1: DoFilingCmd(cmdclosall);
           2: DoFilingCmd(cmdclose);
           3:;
           4: PrBgdDlg;
        END;

      muTool: CASE mi OF
         1: begin
            toldtodie := true;
            hidecursor;
            SetPort(DeskPort);
            FillRect(DeskPort^.portRect,white);
        { Write out PM }
            DeactPref(error);
            Exit(menuCommand);
            end;
        END;

{$IFC CFGDEBUG}
      muDebug: CASE mi OF
         1: EnterLisaBug;
         2: WITH dynamicHeap^ DO
                fScramble := NOT fScramble;
         3: DrawScreen(TRUE, TRUE);
         4: PMWrite;
         5: BEGIN
            printPM;
            list_pm.Print;
            END;
         6: PrefDbg(not fdbg);
         7: uprefDbg := NOT uprefDbg;
         8: configDbg := NOT configDbg;
         9: mainForm.Print;
         10: root.Print;
         11: BEGIN
             WRITELN;
             WRITELN('$$$$ The Card List $$$$');
             cardList.Print;
             END;
         12: BEGIN
             WRITELN;
             WRITELN('$$$$ The Device List $$$$');
             deviceList.Print;
             END;
         13: BEGIN
             WRITELN;
             WRITELN('$$$$ The Driver List $$$$');
             driverList.Print;
             END;
         14: BEGIN
             WRITELN;
             WRITELN('$$$$ The Process List $$$$');
             processList.Print;
             END;
         15: BEGIN
             WRITELN;
             WRITELN('$$$$ The defered List $$$$');
             deferedList.Print;
             END;
      END;
{$ENDC}

   END;
   HiLiteMenu (0);
END;

{---------------------------- PrcsDskEvent ----------------------------}
{ Attempt to Process a Disk event }
{$S PrefCold}
PROCEDURE PrcsDskEvent (VAR TheEvent: EventRecord);
VAR
     ErrNum: Integer;
     VName, DevName: E_Name;
     FSParms: UT_Parmt;
BEGIN
IF (theEvent.keyCap = MicroInCode) OR (theEvent.keyCap = MicroOutCode) THEN
    DevName := 'LOWER';
IF theEvent.keyCap = MicroInCode THEN
      BEGIN
      Mount (ErrNum, VName, DevName, DevName);
      IF (ErrNum > 0) AND (ErrNum <> 1052) THEN { call speaker};
      END;
IF theEvent.keyCap = MicroOutCode THEN
      BEGIN
      UnMount (ErrNum, DevName);
      IF (ErrNum <= 0) OR (ErrNum = 1062) THEN
           BEGIN
           FSParms.Command := Eject;
           FSParms.Dev_Name := DevName;
           FS_Utilities (ErrNum, FSParms);
           END
      ELSE
           { call speaker };
      END;
END;

PROCEDURE Refresh;      {GJC 002}
VAR
    Coverfolder:windowPtr;
    Frame:Rect;
BEGIN
Hidecursor;
WITH Deskport^.PortRect do
    Setrect (frame, left, top, right, bottom); {full screen}
Coverfolder := Newfolder (Frame,
                          '',             {no title}
                          TRUE,           {visible}
                          DialogFolder,   {behind nothing; over all }
                          0,              {Refcon }
                          My_Id,
                          80,             {icon number}
                          noIcon);

DisposeFolder (Coverfolder);
Drawmenubar;
Showcursor;
END;

{ ---------------------------------------------------------------------- }
{$S PrefHot}
PROCEDURE ProcessEvent;
VAR menu:       TMenu;
    button:     INTEGER;
    pullMenu:   INTEGER;
    menuItem:   INTEGER;
    minTime:    LongInt;
    error:      INTEGER;
    flrExt:     FilerExt;
    ptrstr:     ^Tsp;
    drawBars:   BOOLEAN;

    PROCEDURE DoActivate;
    BEGIN
        IF fdbg THEN
            WRITELN('Doing the activate');
        TakeControl (Wmevent,false,false);
        SetPort(Wmevent.who);
        InstallMenus;

        if Wmevent.who = mywindow then
            begin
            printerChanged := FALSE;
            IF firstActivate THEN
                BEGIN
                firstActivate := FALSE;
                InitPref(error);
                IF error > 0 THEN
                    BEGIN
                 { **** Put up the technical difficulties alert here ****}
                    TellFiler(error,initfailed,internalerror,mywindow);
                    toldtoDie := TRUE;
                    ImDying;
                    END
                ELSE
                    toolIsInitialized := TRUE;
                END
            ELSE
                BEGIN
                ActvtPref;
                IF (theMainMenu.iBtn = btnInstall) OR (theMainMenu.iBtn = btnRemove) THEN
                    BEGIN
                    mainForm.reset(theMainMenu);
                    theMainMenu.Hit(btnNIL);
                    END;
                END;
            ClipLessSBars(mywindow);
            drawscreen(true, false);
            ValidRect(MyWindow^.portrect);
            DrawScrollBars(WMEvent.who);
            end;
    END;

    FUNCTION SkipEvent (what: EventKind): TF;
    {Used to skip over aborted events.}
    BEGIN
      SkipEvent := FALSE;
    END;

BEGIN
 {$IFC CFGDEBUG}
    IF NOT fCheckHz(staticHeap, error) THEN
        ABCBreak('staticHeap is bad in processEvent',0);
    IF NOT fCheckHz(dynamicHeap, error) THEN
        ABCBreak('dynamicHeap is bad in processEvent',0);
 {$ENDC}

    IF NOT SkipEvent (Wmevent.what) THEN
    CASE Wmevent.what OF

      buttonDown:
         IF Wmevent.who = menuFolder THEN
            begin
            MenuSelect (Wmevent.where, pullMenu, menuItem);
            MenuCommand(pullMenu, menuItem);
            end
         else
            if fgrowhit(WMEvent.where) then
                DownInWindow
            else
                IF Wmevent.who = mywindow THEN
                    IF MousePress(mainForm, Wmevent.where, menu, button) THEN
                        DoCheck (menu, button);

      folderActivate:
         BEGIN
         if fdbg then
           writeln('activate Wmevent ');
         DoActivate
         END;


      folderDeactivate:
         begin
         if Wmevent.who = mywindow then
            begin
            if fdbg then
                writeln('deactivate Wmevent');
            SetPort(Wmevent.who);
            cliprect(mywindow^.portrect);
            hideSBorder(MyWindow^.portrect);
            ClearMenuBar;

        { Write out PM }
            DeactPref(error);
            IF printerChanged THEN
                PrUpdate;
       {$IFC CFGDEBUG}
            IF error > 0 THEN
                ABCBreak('Error from DeactPref in processEvent ',error);
       {$ENDC}
        { Create picture for updates }
            wmOpenPic(MyWindow);
            ClipLessSBars(mywindow);
            DrawScreen(false,false);
            cliprect(MyWindow^.portrect);
            hideSBorder(MyWindow^.portrect);
            wmClosePic;
            end;
         GiveControl (Wmevent);
         end;

      folderUpdate:
         BEGIN
         if fdbg then
            writeln('update Wmevent');
         if Wmevent.who = mywindow then
            begin
            SetPort(Wmevent.who);
            ClipLessSBars(mywindow);
            end;

         IF onWorkShop THEN
            rectrgn(wmevent.who^.visrgn,wmevent.who^.portrect);

         drawBars := FALSE;
         IF activeFolder = myWindow THEN
            drawBars := TRUE;

         BeginUpdate(Wmevent.who);
         if Wmevent.who = myWindow then
             DrawScreen(drawBars, FALSE);
         EndUpdate(Wmevent.who);
         END;

      filerEvent:
         BEGIN
         GetAddParams (error, Wmevent, flrExt);

         CASE flrExt.theFlrOp OF

            fcNone:
               BEGIn
               if fdbg then
                  writeln('fcnone Wmevent');
               TakeWindow(Wmevent.who);
               SetPort(Wmevent.who);
               MyWindow := Wmevent.who;
               SetOrigin(0,0);
               ClipRect(wmevent.who^.portrect);
               eraserect(wmevent.who^.portrect);
               IF wmEvent.who = activeFolder THEN
                   DoActivate;
               END;

            fcTerminate:
               BEGIN
               ImDying;
               ToldToDie := TRUE;
               END;

            fcClose, fcSuspend, fcShred:
               BEGIN
               TellFiler (error, docClosd, allOK, mywindow);
               END;

            fcDfClose:
               BEGIN
               Close_Object(error, flrExt.theDf);
               TellFiler (error, dfClosed, allOK, mywindow);
               END;

        {$IFC CFGDEBUG}
            OTHERWISE ABCBreak('unkown filer event received', 0);
        {$ENDC}

         END;
      END;
        DiskEvent: PrcsDskEvent (Wmevent);

   END;
END;

{ ---------------------------------------------------------------------- }
{$S PrefInit}
PROCEDURE ConfigInit (hz: THz);
{Function: Read the menus. Initialize the checkboxes.}

VAR fileMu: TEXT;
    i: TC;
    temprect: rect;
    error: TC;
    temp: itemptr;

BEGIN
   if fdbg then
      writeln('entering configinit');

   showdim.dimisset := false;
   ClearLastMenu := false;

{ read the box text form the menu file }
   for i := fststring to lstString do
      begin
      temp := @boxstr[i];
      getitem(menuArray[mustring],i, temp);
      end;

{ read the dbl click demo text }
   temp := @DoubleClickDemoText;
   getitem(menuArray[muWord],1,temp);

{ If Stand alone on the OS then create a folder }
    IF onWorkShop THEN
        BEGIN
        SetRect(TempRect,33,33,653,313);
        mywindow := Newfolder(temprect,'Preferences',true,dialogfolder,0,My_id,80, noIcon);
        makefldractive(mywindow, niluserdata);
        setport(mywindow);
        END;

   InitWmlCrs(Error);

{ set the lx to something strange so that bindlx will bind the font }
   oldlx.fb := true;

{ Initialize Black Box }
   with BlackBox do
      begin
      SetRect(BBRect,450,50,600,180);
      visible := false;
      end;

END;

{ ---------------------------------------------------------------------- }
{                        Aborts/Errors                                   }
{ ---------------------------------------------------------------------- }
{$S PrefCold}
FUNCTION HeapError(hz: Thz; bytesNeeded: TC): TC;
   VAR expansion,
       newdiscsize,
       newmemsize : longint;
       status : integer;
       dsinfo: dsinforec;

    BEGIN
    IF fdbg THEN
        WRITELN('The Configuration Tool heap is full.-- Expanding   ');

    IF bytesneeded < 1024 then expansion := 1024
    else expansion := bytesneeded;

    Info_dataseg(Status,refnum,dsinfo);
    size_dataseg(status,refnum,expansion,newmemsize,expansion,newdiscsize);
    if status > 0 then
       BEGIN
       if fdbg then
          WRITELN('Expansion Failed  Status = ', status);
       HeapError := 0;
       END

    ELSE
       BEGIN
       if fdbg then
           if status < 0 then writeln('HeapError warning ',status);
       HeapError := newmemsize - dsinfo.mem_size;
       if fdbg then
          WRITELN('Configuration Tool expanded to ',newmemsize);
       END;
    END;


{ -------------------------------------------------------------------- }

procedure CfgGrafErr(error: integer);
begin
if fdbg then writeln('graf init error error is', error);
halt
end;

{ -------------------------------------------------------------------- }
{$S PrefInit}
  procedure FailedAlert;
  begin
  stopalert(prefAlerts,2);
  end;

  { -------------------------------------------------------------------- }

  procedure FailedInit;
  begin
  if fdbg then
     writeln('failed Init');
  TellFiler(errnum,initfailed,internalerror,mywindow);
  halt;
  end;

{ -------------------------------------------------------------------- }

PROCEDURE LastWishes(environPtr : P_env_blk; excepDataPtr : P_ex_data);
VAR error:  INTEGER;
BEGIN
ImDying;
IF NOT toldToDie AND toolIsInitialized THEN
    BEGIN
    DeactPref(error);
    ExitPref;
    END;
END;

{ -------------------------------------------------------------------- }

PROCEDURE InitFormAndMenuMaster;
VAR ptrStr: ^TSp;
BEGIN
 { Convert the method table pointers }
    TransformPointers;

 { Initialize the form }
    theMainMenu := menuMaster.GetMenu(main);
    mainForm.MakeEndAt(theMainMenu);
    theMainMenu.iBtn := BtnNil;
    mainForm.iMuKey := theMainMenu;
END;

PROCEDURE InitMain(var initerror: integer);
VAR Cfgheap:      THz;
    SegName:      PathName;
    Addr:         longint;
    error:        integer;
    schedError:   integer;
    excepName:    T_Ex_Name;
    i, actualheapsize :integer;
    dsinfo:       dsinforec;
    origPrefix:   PathName;
    bootPath:     e_name;
    bootPrefix:   PathName;
    toolPrefix:   e_name;
    pmInitStatus: INTEGER;

BEGIN
{$IFC CFGDEBUG}
PrefDbg(FALSE);
uprefDbg := FALSE;
configDbg := FALSE;

(*
IF Prompt('Turn on debugging?') THEN
    BEGIN
    IF Prompt('Set Break Point? ') THEN
        EnterLisaBug;
    PrefDbg(Prompt('Debug Check and PrefMain? '));
    uprefDbg := Prompt('Debug uPref? ');
    configDbg := Prompt('Debug uConfig? ');
    END;
*)
{$ENDC}

    if fdbg then
        write('Calling unit inits');

    toolIsInitialized := FALSE;
    firstActivate := TRUE;

    initerror := 0;

    procParam.procCode := dsGetDiskEnbF;
    DSPaslibCall(ProcParam);
    onWorkShop := procParam.diskEnbF;

   OSBootVol(error,bootPath);
   bootPrefix := concat('-',bootPath);
    IF onWorkShop THEN
        BEGIN
        Get_Working_Dir(error, origPrefix);
        Set_Working_Dir(error, bootPrefix);
        END;

   IF fdbg THEN
        WRITELN('Calling initGraf');
   InitGraf(@theport);

   IF fdbg THEN
        WRITELN('Calling OpenWM');
   OpenWM;
   SetPort(DeskPort);

   if fdbg then
     writeln('Declaring execption handler');

    IF NOT onWorkShop THEN
        BEGIN
        excepName := 'SYS_TERMINATE';
        Declare_Excep_Hdl (error, excepName, @LastWishes);
        IF error <> 0 THEN
            BEGIN
            TellFiler(error, initFailed, noMemory, nil);
            ImDying;
            HALT;
            END;
        END
    ELSE
        Refresh;


   ToldToDie := FALSE;
   ConfigID := My_ID;

{ open the button data segment }
   if fdbg then
      write('Creating configuration tool heap');
   Segname := '{T11}buttons';
   IF NOT onWorkShop THEN
        Sched_Class(schedError,false);
   Open_DataSeg (error, SegName, Refnum, Addr, btnLDSN);
   IF NOT onWorkShop THEN
        Sched_Class(schedError,true);

   if error <= 0 then
      SetAccess_DataSeg(error, RefNum, False)  {Access R/W}
   else
      begin
      TellFiler(error,initfailed,internalerror,mywindow);
      halt;
      end;


{ create our heap on top of the buttons }
   Info_dataseg(error,refnum,dsinfo);

   InitHeap(pointer(addr+btnheapsize),pointer(addr + dsinfo.mem_size),@heaperror);
   if ord(theheap) = 1 then
      if fdbg then
         begin
         writeln;
         writeln('Can not allocate Heap in configuration tool');
         end
      else
         failedinit;

    GetHeap(dynamicHeap);

{ retrieve the handles }
    datahandle := pointer(ord(addr));
    handleHolder := datahandle^;

    UnStuffHandles;

   { Create and initialize the configuration data structures }
    InitFormAndMenuMaster;

    theRootMenu := menuMaster.GetMenu(cRootMenu);

    Staticheap := mainForm.Heap;

 {$IFC CFGDEBUG}
    IF NOT fCheckHz(staticHeap, error) THEN
        ABCBreak('staticHeap is bad after initformandmenumaster',0);
 {$ENDC}

    IF onWorkShop THEN
        PMinit(pminitstatus);

    InitScrollBars;

    if fdbg then
        WRITELN('InitAlert OpenPhraseFile');

   toolPrefix := Concat(bootPrefix,'-','{t11}');
   InitMP(dynamicHeap, toolPrefix, @FailedAlert, 2{version}, @menuArray, prefAlerts , alertError);
   if alerterror > 0 then
      FailedInit;

    IF onWorkShop THEN
        BEGIN
        TakeWindow(FilerFolder);
        FilerProcess := My_Id;
        PrGlobalInit;
        Set_Working_Dir(error, origPrefix);
        END;

   PrMgrInit;


    ConfigInit (TheHeap);
END;

{ -------------------------------------------------------------------- }

PROCEDURE ExitWorkShop;
var ErrNum: integer; PInfo: ProcInfoRec; HeapRefNum: integer;
begin
    Refresh;
    Info_Process(ErrNum, My_Id, PInfo);
    GiveWindow(FilerFolder, PInfo.Father_Id);
    FilerProcess := PInfo.Father_Id;
    WMKillProcess(My_Id);
    FlushInput (Nil);
    ScreenCtr(Cclearscreen);
    Info_Address (ErrNum, ordHeap, HeapRefNum); {QuickDraw heap: (private)}
    if ErrNum <= 0 then
       Close_DataSeg (ErrNum, HeapRefNum);
    Info_LDSN (ErrNum, 15, HeapRefNum);         {Window Manager heap: WMDATA}
    if ErrNum <= 0 then
       Close_DataSeg (ErrNum, HeapRefNum);
    Info_LDSN (ErrNum, 16, HeapRefNum);         {Font Manager heap: FMDATA}
    if ErrNum <= 0 then
       Close_DataSeg (ErrNum, HeapRefNum);

end;

{$S PrefHot}

PROCEDURE MainProg;
var error: integer;
BEGIN
   InitMain(error);
   if error > 0 then halt;

   REPEAT  { Main Program Loop }
      IF ImActive THEN BEGIN
         IF EventAvail THEN BEGIN
            GetEvent   (Wmevent);
            ProcessEvent;
         END
         ELSE BEGIN
            IdleProc;
            LetOthersRun;
         END;
      END
      ELSE BEGIN
         GetEvent(Wmevent);
         ProcessEvent;
      END;
   UNTIL ToldToDie;
   ExitPref;
   IF onWorkShop THEN
        ExitWorkShop;
END;

{ ---------------------------------------------------------------------- }
{                          Main Program                                  }
{ ---------------------------------------------------------------------- }

BEGIN
   DoubleClickDemoText := 'Copyright 1983, Apple Computer Inc.';
   MainProg;
END.


