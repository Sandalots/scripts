PROGRAM Clock; { 10-Nov-83 }  { Copyright 1984, Apple Computer Inc. }


USES {$U libsm/UnitStd   }  UnitStd,
     {$U libsm/UnitHz    }  UnitHz,
     {$U libsm/Storage   }  Storage,
     {$U libos/SysCall   }  SysCall,
     {$U libos/PSysCall  }  PSysCall,
     {$U libqd/QuickDraw }  QuickDraw,
     {$U libfm/FontMgr   }  FontMgr,
     {$U libwm/Events    }  Events,
     {$U libwm/Folders   }  Folders,
     {$U libwm/Menus     }  Menus,
     {$U libsb/WmlStd    }  WmlStd,
     {$U libsb/WmlCrs    }  WmlCrs,
     {$U libsb/WmlGrow   }  WmlGrow,
     {$U libsb/WmlSb     }  WmlSb,
     {$U libam/AlertMgr  }  AlertMgr,
     {$U libpm/PMDecl    }  PMDecl,
     {$U libpm/PMM       }  PMM,
     {$U PrStdInfo       }  PrStdInfo,
     {$U PrPublic        }  PrPublic,
     {$U libfc/FilerComm }  FilerComm,
     {$U libin/IntRLib   }  International;

{$S        }   { in case some unit exports a $S }

{$SETC ClkDebug := fDbgOK }
{$SETC ClkSymbols := fSymOK }

{$IFC ClkSymbols }
{$D+ }
{$ELSEC }
{$D- }
{$ENDC }

{$IFC ClkDebug }
{$R+ }
{$ELSEC }
{$R- }
{$ENDC }


CONST

{$IFC NOT ClkDebug }
   dbgClock      = FALSE;
{$ENDC }

     { "Filing" menu items }
   mCloseAll     = 1;
   mClose        = 2;
   mBlank1       = 3;
   mPutBack      = 4;
   mSaveChanges  = 5;
   mUndoChanges  = 6;
   mBlank2       = 7;
   mPrintStatus  = 8;

   firstMenu     = 1;
   lastMenu      = 1;


   timeFont      = p10Tile;  { Font used in the dialog box                     }
   cursorOnTime  = 60;
   cursorOffTime = 40;

   editLength    = 17;       { length of date/time string, starting with 0         }

   heapSize      = 3000;     { Size of resident heap so we don't need a data seg   }


   endJa = 31;               { Julian conversion aids, cumulative days             }
   endFe = 59;
   endMr = 90;
   endAp = 120;
   endMy = 151;
   endJn = 181;
   endJl = 212;
   endAu = 243;
   endSe = 273;
   endOc = 304;
   endNo = 334;
   endDe = 365;

   bsCode =      8;      { Decimal codes for non-printing characters           }
   ntrCode =     3;
   tabCode =     9;
   rtnCode =     13;

   maxTmpStr =    20;                            { *************** <-- NEW SINCE RELEASE 1.0 *********** }

TYPE

    NumberStr   =  STRING[11];   { large enough for - max LongInt }
    String10    =  String[10];
    TcharKind   = (ampmChar, numChar, oneOrLess, twoOrLess, threeOrLess,
                   oneToNine, twoToNine, sixToNine, fourToNine, advChar);
    Tmonth      = (Ja,Fe,Mr,Ap,My,Jn,Jl,Au,Se,Oc,No,De);
    TwhereDown  = (inField, inNoMansLand, notDown);
    Twhere      = (hourBox, minBox, ampmBox, moBox, dayBox, yearBox, noBox);


    TStr =         STRING[maxTmpStr];           { *************** <-- NEW SINCE RELEASE 1.0 *********** }


VAR

      { State Information }

    arrowCrs:   BOOLEAN;   { Cursor location: FALSE=over field, TRUE=anywhere else }
    curTime:    Time_Rec;  { Result of most recent OS call, GMT, not converted     }
    cursorBlink:INTEGER;   { }
    downIn:     TwhereDown;{ Area where mouse mouse went down, or button is up     }
    editTime:   PACKED ARRAY [0..editLength] OF CHAR; { Displayed date/time, with edits}
    err:        INTEGER;
    timerProcID:LONGINT;   { OS process id of the timer subprocess                 }

      { Field Edit State }

    editField:  Twhere;    { Current edit field                                    }
    fieldPos:   INTEGER;   { Which char of field gets next character               }
    hiliteFld:  Twhere;    { The current highliting, if any                        }

      { Form Layout }

    editCol:    INTEGER;    { Screen character location of displayed date and time }
    editRow:    INTEGER;

    editRect,
    hourRect,
    minRect,
    ampmRect,
    moRect,
    dayRect,
    yearRect:   Rect;

      { Font size info }

    numWidth:   INTEGER;        { Width of '0' in pixels                          }
    rowHt:      INTEGER;        { Font height in pixels                           }
    sysAscent:  INTEGER;        { char ascent of font in pixels                   }
    sysDescent: INTEGER;        { Char descent of font in pixels                  }

      { Edit Support }

    julianDays: ARRAY [0..12] OF INTEGER; { Cumulative days by month              }
    leapYear:   BOOLEAN;        { TRUE if year MOD 4 = 0                          }

    bs,                         { Non-printing ascii characters                   }
    ntr,
    rtn,
    tab:        CHAR;

      { Window Stuff }

    theEvent    : EventRecord;  { holds the last event received }
    myWindow    : WindowPtr;    { passed to me by filer in "OpenDoc" event  }
    windowState : WindowInfo;   { Holds 'visible' flag  }


      { Menu stuff }

    menuFile    : TEXT;         { used for reading the menu text file       }
    myMenus     :               { menu descriptor list.  Cache of menu file }
      ARRAY[1..lastMenu] OF MenuInfo;

      { Alert stuff }

    alertRefnum : INTEGER;      { File refnum for alert phrase file         }
    clkAlert    : TAlertFile;
    myHeap      : ARRAY [0..heapSize] OF CHAR;

      { control flags }

    initing     : INTEGER;      { Initialization state: 0/fin, 1/initing, 2.../fail}
    toldToDie   : BOOLEAN;      { Set to TRUE when "fcTerminate" filerOp received }


    { ************ NEW SINCE RELEASE 1.0:  Field character position offsets into display string ********* }

                         errnum:        INTEGER;

                         hourOffset:    INTEGER;
                         minOffset:     INTEGER;

                         leadTOffset:   INTEGER;
                         sepTOffset:    INTEGER;
                         trailTOffset:  INTEGER;
                         ampmOffset:    INTEGER;

                         dayOffset:     INTEGER;
                         moOffset:      INTEGER;
                         yearOffset:    INTEGER;

                         firstDFOffset: INTEGER;
                         secDFOffset:   INTEGER;
                         thirdDFOffset: INTEGER;

                         sep1DOffset:   INTEGER;
                         sep2DOffset:   INTEGER;

                         leadTStr:      TStr;
                         sepTStr:       TStr;
                         trailT24Str:   TStr;

                         amStr:         TStr;
                         pmStr:         TStr;

                         sep1DStr:      TStr;
                         sep2DStr:      TStr;

                         ampm24Switch:  BOOLEAN;      { true: 12-hour clock }
                         showZero:      BOOLEAN;      { true: zeroes are shown }

  { ________________________________________END OF NEW VARIABLES_________________________________________ }

{$IFC ClkDebug }
    dbgClock    : BOOLEAN;
{$ENDC }


{--------------------------------------------------------------------------}
{ FORWARD DECLARATIONS                                                     }
{--------------------------------------------------------------------------}

   { All procedures are declared forward to allow alphabetical ordering }

PROCEDURE DeHilite;                                                 FORWARD;
PROCEDURE DoActivateStuff;                                          FORWARD;
FUNCTION  EditAmPm (newChar: CHAR) : BOOLEAN;                       FORWARD;
PROCEDURE EditChar (pos: INTEGER; newChar: CHAR);                   FORWARD;
FUNCTION  EditDay (newChar: CHAR) : BOOLEAN;                        FORWARD;
FUNCTION  EditFirstChar (offset: INTEGER; char1: CHAR) : BOOLEAN;   FORWARD;
FUNCTION  EditHour (newChar: CHAR) : BOOLEAN;                       FORWARD;
FUNCTION  EditMin (newChar: CHAR) : BOOLEAN;                        FORWARD;
FUNCTION  EditMonth (newChar: CHAR) : BOOLEAN;                      FORWARD;
FUNCTION  EditSecondChar (offset: INTEGER; char2: CHAR) : BOOLEAN;  FORWARD;
FUNCTION  EditYear (newChar: CHAR) : BOOLEAN;                       FORWARD;
PROCEDURE FailedAlert;                                              FORWARD;
PROCEDURE GetFormat (timeAlert, dateAlert: TStr);                   FORWARD;
PROCEDURE GetTime;                                                  FORWARD;
PROCEDURE HiliteField;                                              FORWARD;
PROCEDURE Initialize;                                               FORWARD;
PROCEDURE IntToStr (number : LongInt; VAR strg : NumberStr);        FORWARD;
PROCEDURE InvertField (field: Twhere);                              FORWARD;
PROCEDURE JulianToMoDay (julian: INTEGER; leapYear: BOOLEAN; VAR mo, day: INTEGER);
                                                                    FORWARD;
PROCEDURE LastWishes (environPtr : P_env_blk; excepDataPtr : P_ex_data);
                                                                    FORWARD;
PROCEDURE MenuCommand (menu,item: INTEGER);                         FORWARD;
PROCEDURE NextField (key: CHAR);                                    FORWARD;
FUNCTION  ProcessKey (newChar: CHAR) : BOOLEAN;                     FORWARD;
PROCEDURE ProcessTheEvent;                                          FORWARD;
FUNCTION  PtInField (where: Point) : Twhere;                        FORWARD;
PROCEDURE ResetTime (err: INTEGER);                                 FORWARD;
FUNCTION  SetEditField (where: Point) : Twhere;                     FORWARD;
PROCEDURE ShowForm;                                                 FORWARD;
PROCEDURE ShowTime (update: BOOLEAN);                               FORWARD;
PROCEDURE TrackCursor;                                              FORWARD;
FUNCTION  WhichMonth : Tmonth;                                      FORWARD;
FUNCTION  ValidChar (testChar: CHAR; kind: TcharKind) : BOOLEAN;    FORWARD;


{--------------------------------------------------------------------------}
{  DeHilite                                                                }
{--------------------------------------------------------------------------}

PROCEDURE Dehilite;
BEGIN
IF dbgClock THEN WRITELN ('Dehilite: hilited field is ',ORD(hiliteFld):1);

IF hiliteFld <> noBox
THEN BEGIN
  InvertField (hiliteFld);
  hiliteFld := noBox;
  END;

IF dbgClock THEN WRITELN ('   exit Dehilite');
END;


{--------------------------------------------------------------------------}
{  DoActivateStuff                                                                }
{--------------------------------------------------------------------------}
{$S EditTime }
PROCEDURE DoActivateStuff;

{puts up the menus, etc.}

VAR
   i  : INTEGER;

BEGIN
IF dbgClock THEN WRITELN ('[DoActivateStuff], entry');

{ install my menus }
FOR i := 1 TO lastMenu DO
   InsertMenu (myMenus[i], 0);
DrawMenuBar;
SetPort (myWindow);
ClipRect (myWindow^.portRect);
InitCursor;

IF dbgClock THEN WRITELN ('[DoActivateStuff], exit');
END; {of PROC DoActivateStuff}


{--------------------------------------------------------------------------}
{  EditAmPm                                                                }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION EditAmPm {newChar: CHAR) : BOOLEAN};
VAR err:   INTEGER;
    func:  BOOLEAN;

BEGIN
IF dbgClock THEN WRITELN ('EditAmPm');

func := TRUE;
IF ValidChar (newChar, advChar)
THEN NextField (newChar)
ELSE BEGIN
  func := ValidChar (newChar, ampmChar);
  IF func
  THEN BEGIN
    Dehilite;
                { ******************** NEW: match lower case and upper case **************************}
    if CompareChar(newchar, amStr[1], CompWeak)
    THEN EditChar (ampmOffset, amStr[1])
    ELSE EditChar (ampmOffset, pmStr[1]);
    fieldPos := 3;
    ResetTime (err);
    END;
  END;

EditAmPm := func;

IF dbgClock THEN WRITELN ('   exit EditAmPm');
END;


{--------------------------------------------------------------------------}
{  EditChar                                                                }
{--------------------------------------------------------------------------}

{$S EditTime }
PROCEDURE EditChar {pos: INTEGER; newChar: CHAR};
VAR
    left:     INTEGER;
    tempRect: Rect;

BEGIN
IF dbgClock THEN WRITELN ('EditChar: pos = ',pos:1,', newChar = ',newChar);

left := editRect.left + (pos*numWidth);
SetRect (tempRect, left, editRect.top, left+numWidth, editRect.bottom);
MoveTo (left, editRow*rowHt);
FillRect (tempRect, white);
DrawChar (newChar);
editTime[pos] := newChar;

IF dbgClock THEN WRITELN ('   exit EditChar');
END;


{--------------------------------------------------------------------------}
{  EditDay                                                                 }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION EditDay {newChar: CHAR) : BOOLEAN};
VAR
    curMonth:  Tmonth;
    func:      BOOLEAN;

BEGIN
IF dbgClock THEN WRITELN ('EditDay');

func := FALSE;
curMonth := WhichMonth;
CASE fieldPos OF
  1: BEGIN
     IF ValidChar (newChar, oneToNine)
     OR ValidChar (newChar, advChar)
     THEN BEGIN
       func := EditFirstChar (dayOffset, newChar);
       IF (ValidChar (newChar, fourToNine)
       OR ((curMonth = Fe) AND (newChar > '2'))) AND showZero
       THEN EditChar (dayOffset, '0');                  { Complete field   }
       END
     ELSE func := FALSE;
     END;

  2: CASE curMonth OF
       Fe: IF ValidChar (newChar, advChar)
           OR ValidChar (editTime[dayOffset+1], oneOrLess)
           OR ((editTime[dayOffset+1] = '2') AND ((newChar < '9') OR leapYear))
           THEN func := EditSecondChar (dayOffset, newChar)
           ELSE func := FALSE;

       Ap, Jn, Se, No:
           IF ValidChar (newChar, advChar)
           OR ValidChar (editTime[dayOffset+1], twoOrLess)
           OR ((editTime[dayOffset+1] = '3') AND (newChar = '0'))
           THEN func := EditSecondChar (dayOffset, newChar)
           ELSE func := FALSE;

       OTHERWISE
           IF ValidChar (newChar, advChar)
           OR ValidChar (editTime[dayOffset+1], twoOrLess)
           OR ((editTime[dayOffset+1] = '3') AND ValidChar (newChar, oneOrLess))
           THEN func := EditSecondChar (dayOffset, newChar)
           ELSE func := FALSE;
       END;
  END;

EditDay := func;

IF dbgClock THEN WRITELN ('   exit EditDay');
END;


{--------------------------------------------------------------------------}
{  EditFirstChar                                                           }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION EditFirstChar {offset: INTEGER; char1: CHAR) : BOOLEAN};

VAR err:  INTEGER;

BEGIN
IF dbgClock THEN WRITELN ('EditFirstChar: offset = ',offset:1,', char1 = ',ORD(char1):1);

EditFirstChar := TRUE;

IF char1 IN [leadTStr[1], trailT24str[1], tab, rtn, ntr, bs,
             sepTStr[1], sep1DStr[1], sep2DStr[1] ]
THEN BEGIN                               { Skip field w/o editing          }
  NextField (char1);
  EXIT (EditFirstChar);
  END;

IF NOT ValidChar (char1, numChar)
THEN BEGIN                               { Invalid char, don't alter field }
  EditFirstChar := FALSE;
  EXIT (EditFirstChar);
  END;

Dehilite;                                { Clear Field...                  }
EditChar (offset, ' ');
EditChar (offset+1, char1);              { ... and set low-order char      }
fieldPos := 2;
IF editField <> yearBox THEN ResetTime (err);

IF dbgClock THEN WRITELN ('   exit EditFirstChar');
END;


{--------------------------------------------------------------------------}
{  EditHour                                                                }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION EditHour {newChar: CHAR) : BOOLEAN};
VAR
    func:  BOOLEAN;

BEGIN
IF dbgClock THEN WRITELN ('EditHour');

func := FALSE;
CASE fieldPos OF
  1: BEGIN
     func := EditFirstChar (hourOffset, newChar);
     END;
  2: BEGIN
     IF ampm24Switch
       THEN
       IF ((editTime[hourOffset+1] = '0')              { hour is 0-9        }
            AND ValidChar (newChar, numChar))
          OR ((editTime[hourOffset+1] = '1')           { hour is 10-12      }
            AND ValidChar (newChar, twoOrLess))
          OR ValidChar (newChar, advChar)
       THEN func := EditSecondChar (hourOffset, newChar)
       ELSE func := FALSE;

     IF NOT ampm24Switch
       THEN
       IF ( (editTime[hourOffset+1] = '0')              { hour is 0-9        }
             AND ValidChar (newChar, numChar) )
          OR
          ( (editTime[hourOffset+1] = '1')              { hour is 10-19      }
             AND ValidChar (newChar, numChar) )
          OR
          ( (editTime[hourOffset+1] = '2')              { hour is 20-24      }
             AND ValidChar (newChar, threeOrless) )
          OR ValidChar (newChar, advChar)
       THEN func := EditSecondChar (hourOffset, newChar)
       ELSE func := FALSE;
     END;
  END;

EditHour := func;

IF dbgClock THEN WRITELN ('   exit EditHour');
END;


{--------------------------------------------------------------------------}
{  EditMin                                                                 }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION EditMin {newChar: CHAR) : BOOLEAN};
VAR
    func:  BOOLEAN;

BEGIN
IF dbgClock THEN WRITELN ('EditMin');

func := FALSE;
CASE fieldPos OF
  1: BEGIN
     func := EditFirstChar (minOffset, newChar);
     IF ValidChar (newChar, sixToNine) THEN EditChar (minOffset, '0');
     END;
  2: BEGIN
     IF (NOT ValidChar (editTime[minOffset+1], sixToNine))
     OR ValidChar (newChar, advChar)
     THEN func := EditSecondChar (minOffset, newChar)
     ELSE func := FALSE;
     END;
  END;

EditMin := func;

IF dbgClock THEN WRITELN ('   exit EditMin');
END;


{--------------------------------------------------------------------------}
{  EditMonth                                                               }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION EditMonth {newChar: CHAR) : BOOLEAN};
VAR
    func:  BOOLEAN;

  {--------------------------------------------------------------------------}

  PROCEDURE DayInRange;
  LABEL 88;

  VAR err:   INTEGER;
      mo:    Tmonth;

  BEGIN
  IF dbgClock THEN WRITELN ('DayInRange');

  mo := WhichMonth;

  CASE editTime[dayOffset] OF        { Check 10's digit and leading blank    }
   ' ',                              { <--- NEW, Sept 20, 83 }
   '0',
   '1': EXIT (DayInRange);           { In range                              }
   '2': IF mo <> Fe THEN EXIT (DayInRange);
   '3': IF mo = Fe THEN GOTO 88;
    OTHERWISE GOTO 88;               { bulletproofing, should never get here }
    END;

  CASE editTime[dayOffse+1] OF       { Check 1's digit                       }
   '1': IF NOT (mo IN [Ap,Jn,Se,No]) THEN EXIT (DayInRange);
   '9': IF (mo <> Fe) OR leapYear OR (editTime[dayOffset] <> '2')
           THEN EXIT (DayInRange);
    OTHERWISE EXIT (DayInRange);
    END;

  88:
  IF showZero THEN                   { <- NEW, Sept 20, 83 }
        BEGIN
            editTime[dayOffset] := '0';
            EditChar (dayOffset, '0');        { Out of range, reset to '1' }
        END;
  editTime[dayOffset+1] := '1';
  EditChar (dayOffset+1, '1');
  ResetTime (err);

  IF dbgClock THEN WRITELN ('   exit DayInRange');
  END;

{--------------------------------------------------------------------------}

BEGIN
IF dbgClock THEN WRITELN ('EditMonth');

func := FALSE;
CASE fieldPos OF
  1: BEGIN
     IF ValidChar (newChar, oneToNine)
     OR ValidChar (newChar, advChar)
     THEN BEGIN
       func := EditFirstChar (moOffset, newChar);
       IF func THEN DayInRange;
       if NOT ( ValidChar(newChar, oneOrLess) OR ValidChar(newChar, advChar) ) AND showZero
                                                { ValidChar(newChar, advChar) is new 10/6/83 }
                then EditChar( moOffset, '0');
       END
     ELSE func := FALSE;
     END;
  2: BEGIN
     IF ((editTime[moOffset+1] = '1')              { month is 10-12      }
          AND ValidChar (newChar, twoOrLess))
     OR ValidChar (newChar, advChar)
     THEN BEGIN
       func := EditSecondChar (moOffset, newChar);
       IF func THEN DayInRange;
       END
     ELSE func := FALSE;
     END;
  END;

EditMonth := func;

IF dbgClock THEN WRITELN ('   exit EditMonth');
END;


{--------------------------------------------------------------------------}
{  EditSecondChar                                                          }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION EditSecondChar {offset: INTEGER; char2: CHAR) : BOOLEAN};
LABEL 99;
VAR  err:   INTEGER;
     func:  BOOLEAN;
BEGIN
IF dbgClock THEN WRITELN ('EditSecondChar: offset = ',offset:1,', char2 = ',ORD(char2):1);

func := FALSE;

IF ValidChar (char2, advChar) OR (char2 = '0')
THEN BEGIN                               { Complete field, check for 0 value}
  IF (editTime[offset+1] IN [' ','0'])   { Field value is 0                 }
  AND NOT (editField IN [hourBox, minBox]){ But some fields can't be zero   }
  THEN GOTO 99;
  IF char2 <> '0'
  THEN BEGIN
    IF (editField IN [minBox]) OR      { Some high-order digits can't be ' '}
       ((editField IN [dayBox, moBox, yearBox]) AND showZero )
    THEN EditChar (offset, '0');
    NextField (char2);
    func := TRUE;
    GOTO 99;
    END;
  END
ELSE IF NOT ValidChar (char2, numChar)
     THEN GOTO 99;                       { Invalid char, exit w/o altering  }

IF (editField IN [minBox,dayBox,moBox,yearBox])  { Set high-order digit     }
AND (editTime[offset+1] = ' ') AND showZero
THEN EditChar (offset, '0')              { Some high-order digits can't be ' '}
ELSE EditChar (offset, editTime[offset+1]);
EditChar (offset+1, char2);              { Set low-order digit              }
fieldPos := 3;
func := TRUE;
ResetTime (err);
(*NextField (tab);*)                     { Finished with this field         }

99:
EditSecondChar := func;

IF dbgClock THEN WRITELN ('   exit EditSecondChar:',func);
END;


{--------------------------------------------------------------------------}
{  EditYear                                                                }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION EditYear {newChar: CHAR) : BOOLEAN};
LABEL 99;

BEGIN
IF dbgClock THEN WRITELN ('EditYear');

EditYear := FALSE;
CASE fieldPos OF
  1: BEGIN
     IF ValidChar (newChar, advChar)
     OR (ValidChar (newChar, numChar) AND (newChar >= '8'))
     THEN EditYear := EditFirstChar (yearOffset, newChar);
     END;
  2: BEGIN
     IF ValidChar (newChar, numChar)
     THEN BEGIN
       IF ((editTime[yearOffset+1] = '9') AND (newChar > '5'))
       OR ((editTime[yearOffset+1] = '8') AND (newChar = '0')) THEN GOTO 99;
       IF EditSecondChar (yearOffset, newChar)
       THEN BEGIN
         EditYear := TRUE;
         ShowTime (TRUE);                   { Correct leap year display }
         END;
       END;
     END;
  END;

99:
IF dbgClock THEN WRITELN ('   exit EditYear');
END;


{--------------------------------------------------------------------------}
{  FailedAlert                                                             }
{--------------------------------------------------------------------------}

{$S EditTime }
PROCEDURE FailedAlert;
{ Called by alert manager when an error occurs using the alert manager package }
BEGIN
IF dbgClock THEN WRITELN('*** Alert manager error = ',alertError);
StopAlert(clkAlert,2);   { Problem reading startup disk ... }
SetPort (myWindow);
TextFont (timeFont);
TextFace ([]);
END;


{-------------------------------------------------------------------------------}
{   GetFormat         *************** <-- NEW SINCE RELEASE 1.0 **********      }
{-------------------------------------------------------------------------------}
{$S InitClock }
PROCEDURE GetFormat{timeAlert, dateAlert: TStr};

     LABEL 100;          { restart after scanned timeStr being too loon }

     CONST

          defTimeStr =   '/://am/pm/12';     { default: US format }
          defDateStr =   'mdy0/';            { default: US format }
          maxTimeChar =  4;                  { for good looks in the clock }

     VAR

          str:           TStr;
          part:          TStr;
          tmpStr:        TStr;
          sequ:          INTEGER;
          currOffset:    INTEGER;
          count:         INTEGER;


     PROCEDURE GetPart(VAR str:TStr; VAR part:TStr);
     VAR  chPos:         INTEGER;
     BEGIN
     chPos     := POS('/', str);
     IF chPos = 0 then
          BEGIN
          part := str;
          str := '';
          END
     ELSE
          BEGIN
          part := COPY(str, 1, chPos-1);
          DELETE(str, 1, chPos);
          END;
     END; { of GetPart }


     BEGIN   { of GetFormat }

     IF dbgclock THEN  WRITELN('start GetFormat');

     count := 0;
     str := timeAlert;          {============ get time format =====}
     if length(str) < 7       { Mininum : 5 times '/' + 2 char's for '12' or '24' }
     then begin errnum := errnum + 1;
                str := defTimeStr;          { default: US format }
          end;

 100:
     IF dbgclock THEN  WRITELN('GetFormat 1');


     GetPart(str, part);
     leadTStr := part;

     GetPart(str, part);
     sepTStr := part;

     GetPart(str, part);
     trailT24Str := part;

     GetPart(str, part);
     amStr := part;

     GetPart(str, part);
     pmStr := part;

     IF dbgclock THEN  WRITELN('GetFormat 2');

     GetPart(str, part);
     tmpStr := COPY(part,1,2);
     if tmpStr = '12' then ampm24Switch := TRUE
     else
     if tmpStr = '24' then ampm24Switch := FALSE
                              else           { default: US 12-hour clock }
                                   BEGIN
                                        ampm24Switch := TRUE;
                                        errnum := errnum + 4;
                                   END;

     IF dbgclock THEN  WRITELN('GetFormat 3');

     if ampm24Switch then if length(pmStr) > length(amStr)
                             then count := length(pmStr)
                             else count := length(amStr)
                     else count := length(trailT24Str);
     count := count + length(leadTStr) + length(sepTStr);
     if count > maxTimeChar then begin str := defTimeStr;
                                       errnum := errnum + 2;
                                       goto 100;
                                 end;

     IF dbgclock THEN  WRITELN('GetFormat 4');

     str := dateAlert;         { ==============get date format======== }

     if (length(str) < 3) or (length(str) > 5) then str := defDateStr;
                                                       { default: US date format  }
     if length(str) = 3 then str := CONCAT(str, '  '); { add lost 'Run Alert' blanks }
     if length(str) = 4 then str := CONCAT(str, ' ');

     tmpStr := COPY(str, 1, 3);

     IF dbgclock THEN  WRITELN('GetFormat 5');

     sequ := 0;
     if (tmpStr = 'dmy') then sequ := 1;
     if (tmpStr = 'mdy') then sequ := 2;
     if (tmpStr = 'ymd') then sequ := 3;
     if (tmpStr = 'DMY') then sequ := 1;
     if (tmpStr = 'MDY') then sequ := 2;
     if (tmpStr = 'YMD') then sequ := 3;
     if sequ = 0 then
          begin errnum := errnum + 8;
                sequ := 2;              { default: US format }
          end;

     tmpStr := COPY(str, 4, 1);          { showZero }
     if (tmpStr = '0') or
        (tmpStr = 'O') or
        (tmpStr = 'o') or
        (tmpStr = 'y') or
        (tmpStr = 'Y')
     then showZero := true
     else if (tmpStr = ' ') or
             (tmpStr = 'n') or
             (tmpStr = 'N')
          then showZero := false
          else begin errnum := errnum + 16;
                     showZero := true;     { default: ISO-Standard shows zeroes }
               end;

     IF dbgclock THEN  WRITELN('GetFormat 6');

     tmpStr := COPY(str, 5, 1);
     sep1DStr := tmpStr;
     sep2DStr := tmpStr;

                                           { calculate time offsets }

     currOffset := 0;

     leadTOffset := currOffset;
     if length(leadTStr) > 0 then currOffset := currOffset + length(leadTStr) + 1;

     hourOffset := currOffset;
     currOffset := currOffset + 2;
                                        { => 1 blank in front of hours' display
                                             2 spaces for hours }

     sepTOffset := currOffset;
     currOffset := currOffset + length(sepTStr);

     minOffset := currOffset;
     currOffset := currOffset + 3;     { 2 spaces for minutes
                                         1 trailing blank }


     trailTOffset := 0;
     ampmOffset := 0;
     if ampm24Switch then ampmOffset := currOffset
                     else trailTOffset := currOffset;

     IF dbgclock THEN  WRITELN('GetFormat 7');

                                       { ======== calculate date offsets ======= }

     sep1DOffset := secDFOffset - 1;
     sep2DOffset := thirdDFOffset - 1;

     CASE sequ OF
     1:   begin dayOffset  := firstDFOffset;
                moOffset   := secDFOffset;
                yearOffset := thirdDFOffset;
          end;

     2:   begin moOffset  := firstDFOffset;
                dayOffset   := secDFOffset;
                yearOffset := thirdDFOffset;
          end;

     3:   begin yearOffset  := firstDFOffset;
                moOffset   := secDFOffset;
                dayOffset := thirdDFOffset;
          end;

     OTHERWISE  begin
                end;

     END; { CASE sequ }

     IF dbgclock THEN  WRITELN('exit GetFormat');

     END; { PROCEDURE GetFormat }



{--------------------------------------------------------------------------}
{  GetTime                                                                 }
{--------------------------------------------------------------------------}

{$S        }
PROCEDURE GetTime;

VAR i:        INTEGER;
    mo:       INTEGER;
    day:      INTEGER;
    localTime:Time_Rec;
    osErr:    INTEGER;
    strVal:   NumberStr;

  PROCEDURE InsertStr (offset: INTEGER);
  VAR i:    INTEGER;
      lgth: INTEGER;
  BEGIN
  lgth := LENGTH(strVal);
  FOR i := 1 TO lgth
  DO editTime[offset+1+i-lgth] := strVal[i];
  END;


  PROCEDURE PutStr (offset: INTEGER);          { *************** <-- NEW SINCE RELEASE 1.0 *********** }
  VAR i:    INTEGER;
      lgth: INTEGER;
  BEGIN
  lgth := LENGTH(strVal);
  FOR i := 1 TO lgth
  DO editTime[offset-1+i] := strVal[i];
  END;


BEGIN
IF dbgClock THEN WRITELN ('GetTime');

                              { == bring invariant char's into edit string ===== }

FOR i := 0 TO editLength DO editTime[i] := ' ';
IF LENGTH(leadTStr) > 0 THEN BEGIN strVal := leadTStr;
                                   if dbgClock then writeln('leadTStr: ',leadTStr);
                                   PutStr(leadTOffset);
                             END;
strVal := sepTStr;
if dbgClock then writeln('sepTStr: ',sepTStr);
PutStr(sepTOffset);
IF (NOT ampm24Switch) AND (LENGTH(trailT24Str) > 0)
      THEN BEGIN strVal := trailT24Str;
                 if dbgClock then writeln('trailT24Str: ',trailT24Str);
                 PutStr(trailTOffset);
           END;

strVal := sep1DStr;
PutStr(sep1DOffset);
strVal := sep2DStr;
PutStr(sep2DOffset);
if dbgClock then writeln('sep2DStr: ',sep2DStr);


                              { =============  convert OS time =========== }
Get_Time (osErr, curTime);
Convert_Time (osErr, curTime, localTime, FALSE{gmt to local});
leapYear := ((localTime.year MOD 4) = 0);
IF dbgClock THEN WRITELN ('   yeapYear is ',leapYear);
IF ampm24Switch THEN
BEGIN
IF localTime.hour > 11
THEN BEGIN
  strVal :=  pmStr;
  IF localTime.hour > 12 THEN localTime.hour := localTime.hour - 12;
  END
ELSE BEGIN
  IF localTime.hour = 0 THEN localTime.hour := 12;
  strVal := amStr;
  END;
IF dbgClock THEN WRITELN ('   set am/pm: ',strVal);
PutStr (ampmOffset);
END;

IntToStr (localTime.hour, strVal);
IF dbgClock THEN WRITELN ('   set hour: ',strVal);
InsertStr (hourOffset);

IntToStr (localTime.minute, strVal);
IF dbgClock THEN WRITELN ('   set minute: ',strVal);
InsertStr (minOffset);
IF editTime[minOffset] = ' ' THEN editTime[minOffset] := '0';

JulianToMoDay (localTime.day, leapYear, mo, day);
IntToStr (mo, strVal);
IF dbgClock THEN WRITELN ('   set month: ',strVal);
InsertStr (moOffset);
IF showZero and (editTime[moOffset] = ' ') THEN editTime[moOffset] := '0';

IntToStr (day, strVal);
IF dbgClock THEN WRITELN ('   set day: ',strVal);
InsertStr (dayOffset);
IF showZero and (editTime[dayOffset] = ' ') THEN editTime[dayOffset] := '0';

IntToStr (localTime.year, strVal);
DELETE (strVal, 1, LENGTH(strVal)-2);
IF dbgClock THEN WRITELN ('   set year: ',strVal);
InsertStr (yearOffset);
IF showZero and (editTime[yearOffset] = ' ') THEN editTime[yearOffset] := '0';


IF dbgClock THEN WRITELN ('   exit GetTime');
END;



{-----------------------------------------------------------------------------}
{  HeapOverflow                                                               }
{-----------------------------------------------------------------------------}

FUNCTION HeapOverflow (hz: THz; bytesNeeded: INTEGER) : INTEGER;
VAR bytes:  NumberStr;
BEGIN
IF dbgClock THEN WRITELN ('HeapOverflow: bytesNeeded = ',bytesNeeded:1);

TellFiler (err, docClosd, noMemory, myWindow);
HALT;

IF dbgClock THEN WRITELN ('   exit HeapOverflow');
END;

{--------------------------------------------------------------------------}
{  HiliteField                                                             }
{--------------------------------------------------------------------------}

PROCEDURE HiliteField;
BEGIN
IF dbgClock THEN WRITELN ('HiliteField: field is ',ORD(editField):1,
                          ', current field is ',ORD(hiliteFld):1);

IF (editField <> hiliteFld) AND (fieldPos = 1)
THEN BEGIN
  Dehilite;
  InvertField (editField);
  hiliteFld := editField;
  END;

IF dbgClock THEN WRITELN ('   exit HiliteField');
END;




{-----------------------------------------------------------------------------}
{  Initialize                                                                 }
{-----------------------------------------------------------------------------}

{$S InitClock }
PROCEDURE Initialize;

VAR alertErr    : INTEGER;
    clkName     : TParamAlert;
    clockInfo   : ProcInfoRec;
    copyRight   : STRING[35];
    debugLine   : Str255;
    entryName   : NameString;
    excepName   : T_Ex_Name;
    i,err,ioerr : INTEGER;
    fInfo       : FontInfo;
    fmErr       : INTEGER;
    fsInfo      : Fs_Info;
    lFontID     : TLFntID;
    pcInfo      : ProcInfoRec;
    pt          : Point;
    timerPathname:Pathname;

    timeAlert   : TStr;          { *************** <-- NEW SINCE RELEASE 1.0 *********** }
    dateAlert   : TStr;

BEGIN
Sched_Class (err, TRUE);          { Make me non-premptable }
copyright := 'Copyright 1984, Apple Computer Inc.';

{$IFC ClkDebug }
dbgClock := TRUE;
{$ENDC }

IF dbgClock THEN WRITELN ('InitSetTime');

initing := 1;
InitGraf(@thePort);               { Init LisaGraf.  Should be done by each process }
OpenWm;                           { give W/M addressability to shared heap }

   { If any error conditions are encountered, 'TellFiler (..., initFailed, ...}

   { Set up the O/S terminate exception handler }
   { This should be the first thing done, in case of a crash in initialization }

excepName := 'SYS_TERMINATE';
Declare_Excep_Hdl (err, excepName, @LastWishes);
IF (err <> 0) THEN
   BEGIN
   WRITELN (My_Id:1,' Declar_Excep_Hdl error: ',err:1);
   initing := 2;
   HALT;
   END;

toldToDie := FALSE;   { set to TRUE on "fcTerminate".  Flags abnormal death }

SetPort(deskPort);            { To assure a default grafport, to be done in OpenWM }
InitHeap (@myHeap[0], @myHeap[heapSize], @HeapOverflow);

   { Set up Menus }

Info_Process(err,My_ID,pcInfo);
clkName := CONCAT(COPY(pcInfo.progPathname,1,POS('-{',pcInfo.progPathname)-1),
                     '-{t13}');

InitMP(theHeap,clkName,@FailedAlert,2,@myMenus[firstMenu],clkAlert,err);
IF (err > 0) THEN
      BEGIN
      IF dbgClock THEN WRITELN('InitMP error = ',err);
      HALT;
      END;

DisableItem(myMenus[1],mBlank1);
DisableItem(myMenus[1],mBlank2);
DisableItem(myMenus[1],mSaveChanges);
DisableItem(myMenus[1],mUndoChanges);

   { Set up Alerts }

InitWmlCrs (err);
IF err > 0 THEN HALT;


GetAlert( clkAlert, 109, @timeAlert );          { ***************  NEW SINCE RELEASE 1.0 *********** }
IF dbgClock THEN WRITELN('timeAlert:', timeAlert);
GetAlert( clkAlert, 110, @dateAlert );
if dbgClock then writeln('dateAlert:', dateAlert);

                        {  start up settings for alert error and display }
errnum := 0;
firstDFOffset := 10;
secDFOffset := 13;
thirdDFOffset := 16;

GetFormat(timeAlert, dateAlert);
if dbgClock then writeln('GetFormat-errnum:', errnum);
                                                { ______________ END OF NEW CODE _____________________ }

PrMgrInit;
IF err > 0
THEN BEGIN
  WRITELN ('PrMgrInit error: ',err:1);
  HALT;
  END;

  { Init Form layout }

myWindow := NIL;
editCol := 1;
editRow := 1;

WITH lFontID DO BEGIN
  fam := timeFont;
  setEFace := [];
  dev := devScreen;
  END;

IF NOT FMFontMetrics (lFontID, fInfo, fmErr)
THEN BEGIN
  WRITELN ('Unable to get p10Tile font metrics');
  initing := 3;
  HALT;
  END;
IF fmErr <> 0 THEN WRITELN ('FontMetrics error: ',fmErr:1);

WITH fInfo DO
   BEGIN
   rowHt := ascent + descent + leading + 4;
   sysAscent := ascent;
   sysDescent := descent;
   END;

TextFont (timeFont);
numWidth := CharWidth('0');

  { Init edit support }

SetRect (editRect, editCol*numWidth, (editRow-1)*rowHt+sysDescent+2,
         (editCol+1)*numWidth, editRow*rowHt+sysDescent+2);
WITH editRect
DO BEGIN
  SetRect (hourRect, left+(hourOffset*numWidth), top,
           left+((hourOffset+2)*numWidth), bottom);
  SetRect (minRect, left+(minOffset*numWidth), top,
           left+((minOffset+2)*numWidth), bottom);
  IF ampm24Switch THEN          { *************** <-- NEW SINCE RELEASE 1.0 *********** }
  SetRect (ampmRect, left+(ampmOffset*numWidth), top,
           left+((ampmOffset+1)*numWidth), bottom);
  SetRect (moRect, left+(moOffset*numWidth), top,
           left+((moOffset+2)*numWidth), bottom);
  SetRect (dayRect, left+(dayOffset*numWidth), top,
           left+((dayOffset+2)*numWidth), bottom);
  SetRect (yearRect, left+(yearOffset*numWidth), top,
           left+((yearOffset+2)*numWidth), bottom);
  END;

bs := CHR (bsCode);
ntr := CHR (ntrCode);
rtn := CHR (rtnCode);
tab := CHR (tabCode);

julianDays[0] := 0;
julianDays[1] := endJa;
julianDays[2] := endFe;
julianDays[3] := endMr;
julianDays[4] := endAp;
julianDays[5] := endMy;
julianDays[6] := endJn;
julianDays[7] := endJl;
julianDays[8] := endAu;
julianDays[9] := endSe;
julianDays[10] := endOc;
julianDays[11] := endNo;
julianDays[12] := endDe;

  { Start the Timer subprocess }

entryName := '';
Info_Process (err, My_ID, clockInfo);
timerPathname := CONCAT(clockInfo.progPathname, '1');
Make_Process (err, timerProcID, timerPathname, entryName, 0);
IF err <> 0
THEN BEGIN
  IF dbgClock THEN WRITELN ('   Could not start timer subproc: ',err:1);
  HALT;
  END;
Suspend_Process (err, timerProcID, FALSE);

initing := 0;

IF dbgClock THEN WRITELN('   exit Initialize');
END;


{-----------------------------------------------------------------------------}
{  IntToStr - converts an integer into a string                               }
{-----------------------------------------------------------------------------}

{$S        }
PROCEDURE IntToStr {number : LongInt; VAR strg : NumberStr};

VAR
   i,
   numDigits : INTEGER;
   negative  : BOOLEAN;
   bkwdStrg  : NumberStr;

BEGIN
negative := (number < 0);
numDigits := 0;

REPEAT
   numDigits := numDigits + 1;
   bkwdStrg[numDigits] := CHR(ORD('0') + ABS(number MOD 10));
   number := number DIV 10
UNTIL number = 0;

IF negative THEN
   BEGIN
   numDigits := numDigits + 1;
   bkwdStrg[numDigits] := '-';
   END;

FOR i := 1 TO numDigits DO
   strg[i] := bkwdStrg[numDigits-i+1];

{$R-}
strg[0] := CHR(numDigits);
{$R+}
END;


{--------------------------------------------------------------------------}
{  InvertField                                                             }
{--------------------------------------------------------------------------}

{$S EditTime }
PROCEDURE InvertField {field: Twhere};
VAR
    theRect:  Rect;

BEGIN
IF dbgClock THEN WRITELN ('InvertField: ',ORD(field):1);

CASE field OF
  hourBox:  theRect := hourRect;
  minBox:   theRect := minRect;
  ampmBox:  if ampm24Switch then theRect := ampmRect
                            else EXIT(InvertField);
  moBox:    theRect := moRect;
  dayBox:   theRect := dayRect;
  yearBox:  theRect := yearRect;
  OTHERWISE EXIT (InvertField);
  END;

InvertRect (theRect);

IF dbgClock THEN WRITELN ('   exit InvertField');
END;


{--------------------------------------------------------------------------}
{  JulianToMoDay                                                           }
{--------------------------------------------------------------------------}

{$S        }
PROCEDURE JulianToMoDay {julian: INTEGER; leapYear: BOOLEAN; VAR mo, day: INTEGER};
VAR feb29:  BOOLEAN;
    i:      INTEGER;

BEGIN
IF dbgClock THEN WRITELN ('JulianToMoDay: ',julian:1);

feb29 := FALSE;
IF leapYear AND (julian > endFe)
THEN BEGIN
  IF julian = endFe + 1 THEN feb29 := TRUE;
  julian := julian - 1;                           { keep in month }
  END;

i := 12;
WHILE julianDays[i] >= julian DO i := i - 1;
mo := i+1;
IF feb29
THEN day := 29
ELSE day := julian - julianDays[i];


IF dbgClock THEN WRITELN ('   exit JulianToMoDay: mo is ',mo:1,', day is ',day:1);
END;


{--------------------------------------------------------------------------}
{  LastWishes                                                              }
{--------------------------------------------------------------------------}

{$S InitClock }
PROCEDURE LastWishes {environPtr: P_env_blk; excepDataPtr: P_ex_data};

   { The Sys_Terminate exception handler.  Gets called when the program terminates
     normally (i.e., last statement executed) or abnormally (e.g., bus error)    }

VAR
   err : INTEGER;
   failReason : FReason;

BEGIN
IF dbgClock THEN WRITELN('LastWishes');

CASE initing OF
  0: ;
  2: TellFiler (err, initFailed, noMemory, NIL);
  3: TellFiler (err, initFailed, noDiskSpace, NIL);
  OTHERWISE TellFiler (err, initFailed, internalError, NIL);
  END;

ImDying;

Activate_Process(err, timerProcID, TRUE);
Kill_Process(err, timerProcID);

IF dbgClock THEN IF toldToDie
THEN WRITELN('Halting')
ELSE WRITELN('Abnormal Death');
END;


{--------------------------------------------------------------------------}
{  MenuCommand                                                              }
{--------------------------------------------------------------------------}

{$S         }
PROCEDURE MenuCommand {menu,item: INTEGER};
   { handles all menu commands }

VAR err:        INTEGER;
    filerErr:   INTEGER;

BEGIN
IF dbgClock THEN WRITELN('MenuCommand');

CASE menu OF
  1: CASE item OF
       mCloseAll: DoFilingCmd(cmdClosAll);
       mClose:    DoFilingCmd(cmdClose);
       mPutBack:  BEGIN
                  TellFiler(filerErr,docClosd,docPutBack,myWindow);
                  myWindow := NIL;
                  END;
       mPrintStatus: BEGIN
                  PrBgdDlg;
                  SetPort (myWindow);
                  TextFont (timeFont);   {*** CL19 ***}
                  TextFace ([]);
                  END;

       END;
  END;

HiliteMenu(0);  { Turn off menu hiliting }

IF dbgClock THEN WRITELN('   exit MenuCommand');
END;


{--------------------------------------------------------------------------}
{  NextField                                                               }
{--------------------------------------------------------------------------}

{$S EditTime }
PROCEDURE NextField {key: CHAR};
LABEL 99;
VAR
    next:  Twhere;
    right: BOOLEAN;

BEGIN
IF dbgClock THEN WRITELN ('NextField: key = ',ORD(key):1);

IF downIn = inField THEN GOTO 99;                { Mouse selecting field   }

IF key = bs THEN right := FALSE                  { Which direction to go   }
ELSE right := TRUE;

IF key = rtn
THEN next := hourBox                             { Move to first field     }
ELSE CASE editField OF                           { Move to adjacent field  }

                                                   { ***************  NEW SINCE RELEASE 1.0 *********** }

       hourBox: IF right THEN next := minBox
                         ELSE BEGIN IF dayOffset  = firstDFOffset THEN next := yearBox;
                                    IF moOffset   = firstDFOffset THEN next := yearBox;
                                    IF yearOffset = firstDFOffset THEN next := dayBox;
                              END;

       minBox:  IF right THEN IF ampm24Switch                     THEN next := ampmBox
                              ELSE
                              BEGIN IF dayOffset  = firstDFOffset THEN next := dayBox;
                                    IF moOffset   = firstDFOffset THEN next := moBox;
                                    IF yearOffset = firstDFOffset THEN next := yearBox;
                              END
                         ELSE next := hourBox;

       ampmBox: IF right THEN BEGIN IF dayOffset  = firstDFOffset THEN next := dayBox;
                                    IF moOffset   = firstDFOffset THEN next := moBox;
                                    IF yearOffset = firstDFOffset THEN next := yearBox;
                              END
                         ELSE next := minBox;

       dayBox:
                BEGIN
                IF dayOffset = firstDFOffset THEN IF right THEN next := moBox
                                      ELSE IF ampm24Switch THEN next := ampmBox
                                                           ELSE next := minBox;

                IF moOffset   = firstDFOffset THEN IF right THEN next := yearBox
                                                            ELSE next := moBox;

                IF yearOffset = firstDFOffset THEN IF right THEN next := hourBox
                                                            ELSE next := moBox;
                END;

       moBox:   BEGIN
                IF dayOffset  = firstDFOffset THEN IF right THEN next := yearBox
                                                            ELSE next := dayBox;

                IF moOffset   = firstDFOffset THEN IF right THEN next := dayBox
                                       ELSE IF ampm24Switch THEN next := ampmBox
                                                            ELSE next := minBox;

                IF yearOffset = firstDFOffset THEN IF right THEN next := dayBox
                                                            ELSE next := yearBox;
                END;

       yearBox: BEGIN
                IF dayOffset  = firstDFOffset THEN IF right THEN next := hourBox
                                                            ELSE next := moBox;

                IF moOffset   = firstDFOffset THEN IF right THEN next := hourBox
                                                            ELSE next := dayBox;

                IF yearOffset = firstDFOffset THEN IF right THEN next := moBox
                                       ELSE IF ampm24Switch THEN next := ampmBox
                                                            ELSE next := minBox;
                END;

       noBox:   next := hourBox;
       END;
                                                { ______________________ END OF NEW CODE ___________________ }

fieldPos := 1;
editField := next;                               { Set state variables     }
HiliteField;                                     { Hilite the new field    }

99:
IF dbgClock THEN WRITELN ('   exit NextField: ',ORD(editField):1);
END;


{------------------------------------------------------------------------------}
{  PtInField                                                                   }
{------------------------------------------------------------------------------}

{$S        }
FUNCTION PtInField {where: Point) : Twhere};

BEGIN

IF PtInRect (where, hourRect)       THEN PtInField := hourBox
ELSE IF PtInRect (where, minRect)   THEN PtInField := minBox
ELSE IF PtInRect (where, ampmRect)  AND ampm24Switch     { ********** <-- NEW SINCE RELEASE 1.0 *********** }
                                    THEN PtInField := ampmBox
ELSE IF PtInRect (where, moRect)    THEN PtInField := moBox
ELSE IF PtInRect (where, dayRect)   THEN PtInField := dayBox
ELSE IF PtInRect (where, yearRect)  THEN PtInField := yearBox
                                    ELSE PtInField := noBox;
END;


{--------------------------------------------------------------------------}
{  ProcessKey                                                              }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION ProcessKey {newChar: CHAR) : BOOLEAN};
VAR theAlert:  INTEGER;
BEGIN
IF dbgClock THEN WRITELN ('ProcessKey: ',ORD(newChar):1,
                           ', fieldPos = ',fieldPos:1);
theAlert := 0;

IF fieldPos = 3
THEN IF ValidChar(newChar, advChar)
     THEN NextField (newChar)
     ELSE theAlert := 106

ELSE CASE editField OF
       hourBox: IF NOT EditHour  (newChar) THEN
                           IF ampm24Switch THEN theAlert := 100 { ****** <-- NEW SINCE RELEASE 1.0 ******* }
                                           ELSE theAlert :=  99;
       minBox:  IF NOT EditMin   (newChar) THEN theAlert := 101;
       ampmBox: IF NOT EditAmPm  (newChar) THEN theAlert := 102;
       moBox:   IF NOT EditMonth (newChar) THEN theAlert := 103;
       dayBox:  IF NOT EditDay   (newChar) THEN theAlert := 104;
       yearBox: IF NOT EditYear  (newChar) THEN theAlert := 105;
       noBox:   IF ValidChar (newChar, advChar)
                THEN NextField (newChar)   ELSE theAlert := 106;
       END;

IF theAlert = 0
THEN ProcessKey := TRUE
ELSE BEGIN
  ProcessKey := FALSE;
  IF dbgClock THEN WRITELN ('   putting up alert ',theAlert:1);
  StopAlert (clkAlert, theAlert);
  SetPort (myWindow);
  TextFont (timeFont);
  TextFace ([]);
  END;

IF dbgClock THEN WRITELN('   exit ProcessKey');
END;


{--------------------------------------------------------------------------}
{  ProcessTheEvent                                                         }
{--------------------------------------------------------------------------}

{$S EditTime }
PROCEDURE ProcessTheEvent;

VAR
   i,theMenu,theItem : INTEGER;
   filerParams : FilerExt;
   filerError  : INTEGER;
   failReason  : FReason;

BEGIN
IF dbgClock THEN WRITELN('ProcessTheEvent');

CASE theEvent.what OF


   buttonDown:
      BEGIN
      IF dbgClock THEN WRITELN('   button down event');
      IF theEvent.who = menuFolder THEN
         BEGIN
         MenuSelect(theEvent.where,theMenu,theItem);   { find which one }
         MenuCommand(theMenu,theItem);                 { do the job }
         END
      ELSE IF theEvent.who = dialogFolder THEN
         BEGIN
         END
      ELSE IF theEvent.who = scrapFolder THEN
         BEGIN
         END
      ELSE
         BEGIN
         IF (SetEditField (theEvent.where) = noBox)
           THEN downIn := inNoMansLand
           ELSE IF fieldPos = 2
                THEN downIn := notDown             { still editing same field }
                ELSE downIn := inField;
         END;
      END;

   buttonUp:
      BEGIN   { ignore }
      downIn := notDown;
      IF dbgClock THEN WRITELN('   button up event');
      END;

   filerEvent:
      BEGIN
      IF dbgClock THEN WRITELN('   filer event');
      GetAddParams(filerError,theEvent,filerParams);
      CASE filerParams.theFlrOp OF

         fcNone:
            BEGIN
            IF dbgClock THEN WRITELN ('   fcNone');
            TakeWindow (theEvent.who);
            myWindow := theEvent.who;
            FolderSize (myWindow, 180, 25, FALSE);
            SetPort (myWindow);
            ClipRect (myWindow^.portRect);
            EraseRect (myWindow^.portRect);
            ShowForm;
            Activate_Process (err, timerProcID, FALSE);
            IF (myWindow = activeFolder) THEN
               DoActivateStuff;
            END;

         fcSuspend,
         fcClose:
            BEGIN
            TellFiler(filerErr,docClosd,allOk,myWindow);
            myWindow := NIL;
            END;

         fcTerminate:
            BEGIN
            IF dbgClock THEN WRITELN ('   fcTerminate');
            toldToDie := TRUE;
            END;

         OTHERWISE
            BEGIN
            IF dbgClock THEN WRITELN ('    unexpected filer op: ',
                                      ORD(filerParams.theFlrOp):1);
            TellFiler(filerErr,docClosd,internalErr,theEvent.who);
            END;
         END;
      END;


   keyDown:
      BEGIN
      IF dbgClock THEN WRITELN('   key down event');
      IF downIn = notDown THEN IF ProcessKey (theEvent.ascii) THEN;
      END;


   folderActivate:
      BEGIN
      IF dbgClock THEN WRITELN('   activate event');
      TakeControl(theEvent,FALSE,FALSE);   { standard "activate" protocol }
      Activate_Process (err, timerProcID, FALSE);
      DoActivateStuff;
      END;


   folderDeactivate:
      BEGIN
      IF dbgClock THEN WRITELN('   deactivate event');
      Dehilite;
      fieldPos := 0;
      editField := noBox;
      downIn := notDown;
      ShowTime (TRUE);
      GiveControl(theEvent);   { standard "deactivate" protocol }
      END;


   folderMoved:  IF dbgClock THEN WRITELN('   folder moved');

   folderUpdate:
      BEGIN
      IF dbgClock THEN WRITELN('   update event');
      BeginUpdate(theEvent.who);    { sets visRgn to updateRgn }
      CASE fieldPos OF
        1,2: BEGIN                  { In the middle of an edit }
             SetPort (myWindow);
             TextFont (timeFont);
             TextFace ([]);
             FOR i := 0 TO editLength DO EditChar (i, editTime[i]);
             IF (hiliteFld <> noBox) AND (fieldPos = 1)
             THEN InvertField (editField);
             END;
        OTHERWISE  ShowForm;
        END;
      EndUpdate(theEvent.who);      { restores visRgn and clears updateRgn }
      END;

   OTHERWISE IF dbgClock THEN WRITELN('   unknown event');

   END;  { case theEvent }

IF dbgClock THEN WRITELN('   exit ProcessEvent');
END;


{--------------------------------------------------------------------------}
{  ResetTime                                                               }
{--------------------------------------------------------------------------}

{$S EditTime }
PROCEDURE ResetTime {err: INTEGER};

VAR days:        INTEGER;
    mo:          INTEGER;
    newTime:     Time_Rec;
    testTime:    Time_Rec;

  FUNCTION StrToInt (offset, lgth: INTEGER) : INTEGER;
  VAR i:     INTEGER;
      next:  CHAR;
      value: INTEGER;

  BEGIN
  IF dbgClock THEN WRITELN ('StrToInt: offset ',offset:1,', lgth ',lgth:1);
  value := 0;
  FOR i := offset TO offset+lgth-1
  DO BEGIN
     next := editTime[i];
     IF next IN ['0'..'9']
     THEN value := value * 10 + (ORD(next)-ORD('0'));
     END;
  StrToInt := value;
  IF dbgClock THEN WRITELN ('   exit StrToInt: ',value:1);
  END;

BEGIN
IF dbgClock THEN WRITELN ('ResetTime');

newTime.mSec := 0;
newTime.second := 0;
newTime.hour := StrToInt (hourOffset, 2);
IF ampm24Switch  THEN                           { *************** <-- NEW SINCE RELEASE 1.0 *********** }
        IF (editTime[ampmOffset] = pmStr[1]) AND (newTime.hour < 12)
        THEN newTime.hour := newTime.hour + 12
        ELSE IF (editTime[ampmOffset] = amStr[1]) AND (newTime.hour = 12)
             THEN newTime.hour := 0;

newTime.minute := StrToInt (minOffset, 2);
IF dbgClock THEN WRITELN ('   minute is ',newTime.minute:1);

newTime.year := 1900 + StrToInt (yearOffset, 2);
IF newTime.year = 1980 THEN newTime.year := 1981;
leapYear := ((newTime.year MOD 4) = 0);  {*** CL17 ***}
IF dbgClock THEN WRITELN ('   year is ',newTime.year:1,', leapYear is ',leapYear);

mo := StrToInt (moOffset, 2);
IF dbgClock THEN WRITELN ('   month is ',mo:1);
newTime.day := julianDays[mo-1] + StrToInt (dayOffset, 2);
IF leapYear AND (mo > 2) THEN newTime.day := newTime.day + 1; { Leap year adjustment }
IF dbgClock THEN WRITELN ('   day is ',newTime.day:1);


Convert_Time (err, newTime, newTime, TRUE{to GMT});
Get_Time (err, curTime);
Set_Time (err, newTime);
IF err = 0 THEN Get_Time (err, testTime);
IF err <> 0
THEN BEGIN
  IF dbgClock THEN WITH newTime DO WRITELN ('   error ',err:1,' setting clock to ',
                                            hour:1,':',minute:2,' ',day:3,'/',year:4);
  Set_Time (err, curTime);   { Set newTime failed, reset    }
  StopAlert (clkAlert, 107);
  SetPort (myWindow);
  TextFont (timeFont);
  TextFace ([]);
  ShowTime (TRUE);
  END;

Get_Time (err, curTime);
leapYear := ((curTime.year MOD 4) = 0);

IF dbgClock THEN WRITELN ('   exit ResetTime: err =', err:1);
END;


{--------------------------------------------------------------------------}
{  SetEditField                                                            }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION SetEditField {where: Point) : Twhere};

VAR thisField:  Twhere;

BEGIN
IF dbgClock THEN WRITELN ('SetEditField');

  { Is a field being selected? }
thisField := PtInField (where);          { Which field to select           }
IF thisField = noBox
THEN BEGIN
  SetEditField := noBox;                 { Current field                   }
  EXIT (SetEditField);
  END;
downIn := inField;

IF fieldPos = 2
THEN BEGIN                               { Complete the current field      }
  IF editField = thisField
  THEN ShowTime (TRUE)                   { Forget partial (year) edits     }
  ELSE
    IF NOT ProcessKey (ntr)              { Complete current field          }
    THEN BEGIN                           { Current (year) value is invalid }
      downIn := notDown;
      SetEditField := editField;         { Current field                   }
      EXIT (SetEditField);
      END;
    END;

  { Select the new field }
fieldPos := 1;
editField := thisField;                  { Set field state variables       }
HiliteField;
SetEditField := editField;               { New field                       }

IF dbgClock THEN WRITELN ('   exit SetEditField: editField is ',ORD(editField):1);
END;


{--------------------------------------------------------------------------}
{  ShowForm                                                                }
{--------------------------------------------------------------------------}

{$S        }
PROCEDURE ShowForm;
VAR err:        INTEGER;
    textStart:  INTEGER;
    timeString: STRING[30];

BEGIN
IF dbgClock THEN WRITELN ('ShowForm');
IF myWindow = NIL THEN EXIT (ShowForm);

  { Init state variables }

downIn := notDown;
arrowCrs := TRUE;
editField := noBox;
hiliteFld := noBox;
fieldPos := 0;

TextFont (timeFont);
TextFace ([]);
ClipRect (myWindow^.portRect);
ValidRect (myWindow^.portRect);            { Cancel any pending updates    }

ShowTime (FALSE);

IF dbgClock THEN WRITELN ('   exit ShowForm');
END;


{--------------------------------------------------------------------------}
{  ShowTime                                                                }
{--------------------------------------------------------------------------}

{$S        }
PROCEDURE ShowTime {update: BOOLEAN};
{ IF update is TRUE redisplay only those fields that have changed }

VAR curDisplay: PACKED ARRAY [0..editLength] OF CHAR;
    i:          INTEGER;

BEGIN
IF dbgClock THEN WRITELN ('ShowTime');

IF myWindow = NIL
THEN BEGIN
  IF dbgClock THEN WRITELN ('   no window open, suspending the timer subprocess');
  Suspend_Process (err, timerProcID, FALSE);
  EXIT (ShowTime);
  END;

GetWindInfo (myWindow, windowState);
IF NOT windowState.visible
THEN BEGIN
  IF dbgClock THEN WRITELN ('   window not visible, suspending the timer subprocess');
  Suspend_Process (err, timerProcID, FALSE);
  EXIT (ShowTime);
  END;

SetPort (myWindow);
IF update
THEN FOR i := 0 TO editLength DO curDisplay[i] := editTime[i]
ELSE FOR i := 0 TO editLength DO curDisplay[i] := ' ';{ Force field update }
GetTime;                                { Puts the current time in editTime}
TextFont (timeFont);
TextFace ([]);
Dehilite;
FOR i := 0 TO editLength
DO IF curDisplay[i] <> editTime[i] THEN EditChar (i, editTime[i]);

IF dbgClock THEN WRITELN ('   exit ShowTime');
END;


{------------------------------------------------------------------------------}
{  TrackCursor                                                                 }
{------------------------------------------------------------------------------}

{$S        }
PROCEDURE TrackCursor;
VAR
    mousePt:   Point;
    newField:  Twhere;

BEGIN
GetMouse (mousePt);

IF (PtInField(mousePt)<>noBox) = arrowCrs
                                      { If mouse over a field and arrowCrs...  }
                                      { ...OR not over a field and not arrowCrs}
THEN BEGIN                            { Change cursor                          }
  IF arrowCrs
  THEN SetStdCursor (icrsLCcross)
  ELSE SetStdCursor (icrsInactive);
  arrowCrs := NOT arrowCrs;
  END;

IF downIn = inField THEN newField := SetEditField(mousePt); { Select edit field }

END;


{--------------------------------------------------------------------------}
{ WhichMonth                                                               }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION WhichMonth {: Tmonth};
VAR mo:  Tmonth;
BEGIN
IF dbgClock THEN WRITELN ('WhichMonth: ''',editTime[moOffset],editTime[moOffset+1],'''');

CASE editTime[moOffset] OF
 ' ',
 '0': CASE editTime[moOffset+1] OF
       '1': mo := Ja;
       '2': mo := Fe;
       '3': mo := Mr;
       '4': mo := Ap;
       '5': mo := My;
       '6': mo := Jn;
       '7': mo := Jl;
       '8': mo := Au;
       '9': mo := Se;
        END;
 '1': CASE editTime[moOffset+1] OF
       '0': mo := Oc;
       '1': mo := No;
       '2': mo := De;
        END;
  END;
WhichMonth := mo;
IF dbgClock THEN WRITELN (' exit WhichMonth: ',ORD(mo):1);
END;

{--------------------------------------------------------------------------}
{  ValidChar                                                               }
{--------------------------------------------------------------------------}

{$S EditTime }
FUNCTION ValidChar {testChar: CHAR; kind: TcharKind) : BOOLEAN};

VAR ok:   BOOLEAN;

BEGIN
IF dbgClock THEN WRITELN ('ValidChar: ',testChar);

ok := FALSE;

CASE kind OF
  advChar:
    BEGIN
    IF testChar IN [tab,rtn,bs,ntr] THEN ok := TRUE;
                                  { ********  NEW SINCE RELEASE 1.0 ******** }
    IF LENGTH(leadTStr) > 0 THEN  IF CompareChar(testChar, leadTStr[1], CompWeak)        THEN ok := TRUE;
    IF LENGTH(sepTStr)  > 0 THEN  IF CompareChar(testChar, sepTStr[1], CompWeak)         THEN ok := TRUE;
    IF LENGTH(trailT24Str) > 0 THEN  IF CompareChar(testChar, trailT24Str[1], CompWeak)  THEN ok := TRUE;
    IF LENGTH(sep1DStr)  > 0 THEN  IF CompareChar(testChar, sep1DStr[1], CompWeak)       THEN ok := TRUE;
    IF LENGTH(sep2DStr)  > 0 THEN  IF CompareChar(testChar, sep2DStr[1], CompWeak)       THEN ok := TRUE;
    IF testChar IN ['0'..'9'] THEN ok := FALSE;
    END;
  ampmChar:
    BEGIN                               { ******** <-- NEW SINCE RELEASE 1.0 ******** }
    IF CompareChar(testChar, amStr[1], CompWeak)      THEN ok := TRUE;
    IF CompareChar(testChar, pmStr[1], CompWeak)      THEN ok := TRUE;
    END;
  numChar:     IF testChar IN ['0'..'9']        THEN ok := TRUE;
  oneOrLess:   IF testChar IN [' ','0','1']     THEN ok := TRUE;
  twoOrLess:   IF testChar IN [' ','0'..'2']    THEN ok := TRUE;
  threeOrLess: IF testChar IN [' ','0'..'3']    THEN ok := TRUE;
  oneToNine:   IF testChar IN ['1'..'9']        THEN ok := TRUE;
  twoToNine:   IF testChar IN ['2'..'9']        THEN ok := TRUE;
  fourToNine:  IF testChar IN ['4'..'9']        THEN ok := TRUE;
  sixToNine:   IF testChar IN ['6'..'9']        THEN ok := TRUE;
  END;

ValidChar := ok;

IF dbgClock THEN WRITELN ('   exit ValidChar: ',ok);
END;


{--------------------------------------------------------------------------}
{  Main Program                                                            }
{--------------------------------------------------------------------------}

BEGIN   { main program }

Initialize;

REPEAT  { Main Program Loop }

  IF dbgClock THEN WRITELN ('   I''m active:',ImActive);

  WHILE NOT (ImActive OR toldToDie) DO
     BEGIN
     IF dbgClock THEN WRITELN ('   wait for event, I''m not active');
     GetEvent(theEvent);  { may suspend me }
     IF theEvent.what = private1        { Handling here permits better segmentation }
     THEN BEGIN
       IF dbgClock THEN WRITELN ('   got a private1 event, update the time');
       ShowTime (TRUE);
       END
     ELSE ProcessTheEvent;
     END;

  WHILE ImActive AND (NOT toldToDie) DO
     BEGIN
     IF EventAvail THEN
        BEGIN
        IF dbgClock THEN WRITELN ('   get the event, I''m active');
        GetEvent(theEvent);
        IF theEvent.what = private1
        THEN IF (fieldPos = 0) OR (fieldPos = 3)
             THEN ShowTime (TRUE)
             ELSE                     { Don't update if user is editing }
        ELSE ProcessTheEvent;
        END

     ELSE
        BEGIN
        TrackCursor;
        LetOthersRun;
        END;
     END;

  UNTIL toldToDie;



IF dbgClock THEN WRITELN('That''s all folks');

{ Change List

08-Dec-82  A3 release
13-Dec-82  ResetTime: added 12 am check. (CL01)
           MenuCommand: No longer set toldToDie when put away.
           ProcessTheEvent: No longer set toldToDie when suspended/closed.
           ResetTime: added month = 0 check (CL04)
10-Jan-83  ResetTime: removed month = 0 check, and
           EditMonth: added oneToNine check (CL04/CL08)
           EditDay: added oneToNine check (CL10)
           EditYear: added ValidChar (advChar)/(numChar) check (CL07)
           EditYear: added ValidChar (numChar) check (CL11)
13-Jan-83  JulianToMoDay: added feb29 (CL06)
           A4 release
14-Jan-83  EditYear: added check for year > '95.
           A4 re-release
 1-Feb-83  ProcessTheEvent: added downIn:=noField to folderDeactivate (CL09)
           ProcessTheEvent: added SetPort to folderActivate (CL10)
           EditYear: added ShowTime after second char edited (CL14)
           ResetTime: added leapYear computation (CL15)
           EditYear: added '80' check on second char (CL13)
           SetEditField: moved downIn assignment after last err exit (CL02)
           SetEditField: added ShowTime to permit reselecting current field
18-Feb-83  SetEditField: moved InvertField into Case stmt (CL16)
24-Feb-83  MenuCommand: added TextFont, TextFace calls (CL19)
           EditSecondChar: many changes (CL18)
           SetEditField: added InvertField in CASE stmt (CL20)
25-Feb-83  ResetTime: added leapYear calculation (CL17)
21-Apr-83  ResetTime: added check for 1980.

29-Jun-83  Int'l upgrade. Refer to Sepp FRIEDRICH.

           The new clock operates on Office System Release 1.0
           Code size increased by about 30%. Main part of it goes into the Initialization
           and the Editing segment. The Display (Main) segment stays about the same.

           New Procedure GetFormat:
               - Scans time and date formats
               - Calculates display offsets depending on the 12-or-24-hour switch,
                 date order and length of separator strings
               - Sets separators for display and passes them on for handling as
                 advancing characters
               - Sets switch for showing leading zeroes

           Changed strongly:
               - Procedure Initialize
                 reads time and date formats from phrase file,
                 sets invariant display offsets for 1st date field, 2nd etc., and
                 makes edit rectangles sensitive depending on 12-or-24-hour Switch
               - Procedures GetTime and NextField
                 Depending on the calculated offsets the edit string gets filled.
                 Advancing to next edit fields is done depending on the variables.

           Further code changes:
                 There are code changes (usually as additives) all over the clock
                 wherever the Am/Pm field is involved, a leading zero might be shown,
                 and where display offsets  are used (sometimes marked THIS IS NEW ...).

           New features:
               - In case of the 24-hour clock he Am/Pm field is not edit sensitive anymore.

               - If leading zeroes are shown in the date fields, also the month leading
                 zero gets displayed immediately after entering the first digit (up to now
                 this applies to day and minute field only).

               - Alert file changes:

                 Alert no. 106 changed:
                 The separators are not enumerated in the displayed alert anymore.

                 Alert no. 99 is new:
                 Like alert no. 100 there is a warning for entering characters not being
                 within the 24-hour clock

                 Alert no. 109 and 110 are new:
                 Time and date formats are read in by procedure Initialize.

           For details concerning the time and date alerts and the corresponding display,
           please see file CLKALERT.TEXT.

31-Jan-84  Changes for new activate sequence, copyright -> 1984 : Ken Krugler.

}

END.
