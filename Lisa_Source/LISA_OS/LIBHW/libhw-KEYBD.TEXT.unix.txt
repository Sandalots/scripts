
;
;   File KEYBD.TEXT
;
;-----------------------------------------------------------------------------
;
;   Hardware Interface for Keyboard State and Events
;
;   Written by Rick Meyers
;   Copyright 1983, Apple Computer Inc.
;
;
;
;   The routines below provide an assembly language interface to the keyboard.
;   Parameters are passed in registers.  Unless otherwise noted, all registers
;   are preserved.
;
;   Routines labeled with a * require supervisor mode.
;
;-----------------------------------------------------------------------------
;
;   Change Log
;
;   <25Oct83>  LAN  Turn on bits in EventTable for the 4 Sony disks
;   <12Jan84>  LAN  Add entries to DKDTable


;-----------------------------------------------------------------------------
;
;   The Keyboard
;
;   The routines below provide an interface to the keyboard, the keypad, the
;   mouse button and plug, the disk inserted switches, the diskette buttons
;   and insertion switches, and the power switch.  Three interfaces are provided,
;   a pollable keyboard state, a queue of keyboard events, and undecoded key
;   transitions.
;


;-----------------------------------------------------------------------------
;
;   Tables
;
;   The EventTable, RepeatTable, ShiftTable and OffsetTable are keyboard
;   layout and legend independent.
;

EventTable      ; EventTable(keycode) = 1 iff the key generates events

 .BYTE  $7B     ; unused 4*Disk PPort MBtn MPlug
 .BYTE  $9E     ; Power  2*unused intSony s1Sony s2Sony s3Sony 1*unused     <25Oct83>
 .BYTE  $00     ; 8*unused
 .BYTE  $00     ; 8*unused
 .BYTE  $FF     ; Pad: Clear - Left Right 789 Up
 .BYTE  $FF     ; Pad: 456 Down .23 N-Enter
 .BYTE  $00     ; 8*unused
 .BYTE  $00     ; 8*unused
 .BYTE  $FE     ; -=\<p BackSp A-Enter unused
 .BYTE  $CC     ; Return Pad:0 2*unused / Pad:1 R-Option unused
 .BYTE  $FF     ; 90uijk[]
 .BYTE  $FF     ; ml;' Space ,.o
 .BYTE  $FF     ; e6785rty
 .BYTE  $FF     ; `fghvcbn
 .BYTE  $FF     ; a2341qsw
 .BYTE  $F0     ; Tab zxd L-Option Caps Shift Command


RepeatTable     ; RepeatTable(keycode) = 1 iff the key is repeatable

 .BYTE  $00     ; unused 4*Disk PPort MBtn MPlug
 .BYTE  $00     ; Power 7*unused
 .BYTE  $00     ; 8*unused
 .BYTE  $00     ; 8*unused
 .BYTE  $FF     ; Pad: Clear - Left Right 789 Up
 .BYTE  $FF     ; Pad: 456 Down .23 N-Enter
 .BYTE  $00     ; 8*unused
 .BYTE  $00     ; 8*unused
 .BYTE  $FE     ; -=\<p BackSp A-Enter unused
 .BYTE  $CC     ; Return Pad:0 2*unused / Pad:1 R-Option unused
 .BYTE  $FF     ; 90uijk[]
 .BYTE  $FF     ; ml;' Space ,.o
 .BYTE  $FF     ; e6785rty
 .BYTE  $FF     ; `fghvcbn
 .BYTE  $FF     ; a2341qsw
 .BYTE  $F0     ; Tab zxd L-Option Caps Shift Command


ShiftTable      ; Defines ShiftMap using <bit position>, <keycode> pairs

 .BYTE  0,$7D   ; Bit  0: Caps-Lock
 .BYTE  1,$7E   ; Bit  1: Shift
 .BYTE  2,$4E   ; Bit  2: R-Option
 .BYTE 10,$7C   ; Bit 10: L-Option (ORed with bit 2)                            <23Mar83>
 .BYTE  3,$7F   ; Bit  3: Command
 .BYTE  4,$06   ; Bit  4: Mouse Button
                ; Bit  5: Repeat
 .BYTE  0,$00   ; end of table



DKDFirst        .EQU    $10     ;  Diacritical Marks have special coded values
DKDLast         .EQU    $14     ;  in the AsciiTable.  These values range from
                                ;  DKDFirst to DKDLast

DKDTable        ; Triples contain <diacritical code>, <letter>, <combination>
                ; <diacritical code>, <space>, <diacritical>  must appear last
                ; for each diacritical

 .BYTE  $10,$61,$89     ; circumflex, a
 .BYTE  $10,$65,$90     ; circumflex, e
 .BYTE  $10,$69,$94     ; circumflex, i
 .BYTE  $10,$6F,$99     ; circumflex, o
 .BYTE  $10,$75,$9E     ; circumflex, u
 .BYTE  $10,$20,$5E     ; circumflex, space

 .BYTE  $11,$61,$88     ; grave accent, a
 .BYTE  $11,$41,$CB     ; grave accent, A
 .BYTE  $11,$65,$8F     ; grave accent, e
 .BYTE  $11,$69,$93     ; grave accent, i
 .BYTE  $11,$6F,$98     ; grave accent, o
 .BYTE  $11,$75,$9D     ; grave accent, u
 .BYTE  $11,$20,$60     ; grave accent, space

 .BYTE  $12,$61,$8B     ; tilde, a
 .BYTE  $12,$41,$CC     ; tilde, A
 .BYTE  $12,$6E,$96     ; tilde, n
 .BYTE  $12,$4E,$84     ; tilde, N
 .BYTE  $12,$6F,$9B     ; tilde, o
 .BYTE  $12,$4F,$CD     ; tilde, O
 .BYTE  $12,$20,$7E     ; tilde, space

 .BYTE  $13,$61,$87     ; acute accent, a
 .BYTE  $13,$65,$8E     ; acute accent, e
 .BYTE  $13,$45,$83     ; acute accent, E
 .BYTE  $13,$69,$92     ; acute accent, i
 .BYTE  $13,$6F,$97     ; acute accent, o
 .BYTE  $13,$75,$9C     ; acute accent, u
 .BYTE  $13,$20,$AB     ; acute accent, space

 .BYTE  $14,$61,$8A     ; umlaut, a
 .BYTE  $14,$41,$80     ; umlaut, A
 .BYTE  $14,$65,$91     ; umlaut, e
 .BYTE  $14,$69,$95     ; umlaut, i
 .BYTE  $14,$6F,$9A     ; umlaut, o
 .BYTE  $14,$4F,$85     ; umlaut, O
 .BYTE  $14,$75,$9F     ; umlaut, u
 .BYTE  $14,$55,$86     ; umlaut, U
 .BYTE  $14,$79,$D8     ; umlaut, y
 .BYTE  $14,$20,$AC     ; umlaut, space

 .BYTE  $00,$00,$00     ; end of table



OffsetTable     ; OffsetTable(shift state AND 7) = offset into AsciiTable

 .WORD  0       ; option=0, shift=0, caps=0  --  normal
 .WORD  128     ; option=0, shift=0, caps=1  --  alpha-lock
 .WORD  256     ; option=0, shift=1, caps=0  --  shift
 .WORD  256     ; option=0, shift=1, caps=1  --  shift
 .WORD  384     ; option=1, shift=0, caps=0  --  alternate
 .WORD  512     ; option=1, shift=0, caps=1  --  alternate alpha-lock
 .WORD  640     ; option=1, shift=1, caps=0  --  alternate shift
 .WORD  640     ; option=1, shift=1, caps=1  --  alternate shift



;-----------------------------------------------------------------------------
;
;  Keyboard State
;
;  Low level access to the keyboard is provided through a pollable keyboard
;  state.  This state information is based on physical keycodes defined above.
;  Routine KeyIsDown returns the position of a single specified key.  Routine
;  KeyMap returns an 128-bit map, one bit for each key.  A zero indicates
;  the key is up, a one indicates down.  For the mouse plug, a zero indicates
;  unplugged, a one indicates plugged in.  Certain keys are not pollable; the
;  corresponding bits will always be zero.  These keys are disk 1 inserted,
;  disk 1 button, disk 2 inserted, disk 2 button, parallel port, and power
;  switch.
;
;
;   Routine:    KeyIsDown
;   Arguments:    D0 (input)   --  keycode (integer)
;                 D1 (output)  --  key position, 0=up, 1=down (integer)
;   Function:   Return the position of the key specified by keycode.
;

KeyIsDown       MOVEM.L D2/A0,-(SP)         ; save registers
                MOVE.W  D0,D1               ; keycode
                ASR.W   #3,D1               ; keycode / 8
                AND.W   #$C,D1              ; byte offset of long
                MOVE.W  D0,D2               ; keycode
                AND.W   #32-1,D2            ; bit position within long
                LEA     KeyBitmap,A0        ; keyboard map address
                MOVE.L  0(A0,D1.W),D1       ; long containing bit
                BTST    D2,D1               ; 0=up, 1=down
                SNE     D1                  ; 0=up, $FF=down
                AND.W   #1,D1               ; 0=up, 1=down
                MOVEM.L (SP)+,D2/A0         ; restore registers
                RTS                         ; return


;
;   Routine:    KeyMap
;   Arguments:    D0 (output)  --  keyboard state bits 0 (low-order) to 31
;                 D1 (output)  --  keyboard state bits 32 (low-order) to 63
;                 D2 (output)  --  keyboard state bits 64 (low-order) to 95
;                 D3 (output)  --  keyboard state bits 96 (low-order) to 127
;   Function:   Return the current keyboard state as an 128-bit map, one bit
;               for each key.  A 0 indicates the key is up, a 1 indicates down.
;               Note carefully the order of the bits, it's not obvious.
;

KeyMap          MOVE.L  KeyBitmap,D0        ; first 32 bits
                MOVE.L  KeyBitmap+4,D1      ; second 32 bits
                MOVE.L  KeyBitmap+8,D2      ; third 32 bits
                MOVE.L  KeyBitmap+12,D3     ; final 32 bits
                RTS                         ; return


;-----------------------------------------------------------------------------
;
;   Keyboard Events
;
;   The hardware interface provides two keyboard input queues, one corresponding
;   to each of the two displays.  When the primary (graphics) display is visible,
;   input goes into the primary input queue.  Similiarly, when the alternate
;   (debugging) display is visible, input goes into the  alternate input queue.
;   Initially input is directed into the primary queue.  The user can toggle
;   between the two queues (and displays) by typing <Option-Toggle> (hold
;   down Option while typing the Toggle key defined by routine SetToggleKey).
;   The <Option-Toggle> combination does not generate an event.  Programs can
;   toggle between the two displays using routine ScreenKeybd and SetScreenKeybd.
;
;   The events in the input queues are generally key down transitions.  Each
;   event contains the following information:
;
;      keycode  --  physical key
;      ascii    --  ascii interpretation of this key
;      state    --  caps-lock, shift, option, command, mouse button and repeat
;      mouseX   --  X-coordinate of the mouse when the key was pressed
;      mouseY   --  Y-coordinate of the mouse when the key was pressed
;      time     --  value of the millisecond timer when the key was pressed
;
;
;   Keycode -- Keycodes are defined above.
;
;   Ascii -- The ascii interpretation of keys depends on the state of the
;   caps-lock, shift and option keys.  Six interpretations are associated
;   with each different keyboard layout:
;
;      normal
;      caps-lock
;      shift or (shift and caps-lock)
;
;      alternate
;      alternate with caps-lock
;      alternate with shift or (shift and caps-lock)
;
;   In most cases the ascii value returned is obvious.  The table below
;   lists the cases that aren't so obvious.
;
;      $00  (NUL)   Disk 1 Inserted
;      $00  (NUL)   Disk 1 Button
;      $00  (NUL)   Disk 2 Inserted
;      $00  (NUL)   Disk 1 Button
;      $00  (NUL)   Power Button
;      $00  (NUL)   Mouse Button (down)
;      $00  (NUL)   Mouse Plug (in)
;      $01  (SOH)   Mouse Button (up)
;      $01  (SOH)   Mouse Plug (out)
;      $03  (ETX)   Enter
;      $08  (BS)    BackSpace
;      $09  (HT)    Tab
;      $0D  (CR)    Return
;      $1B  (ESC)   Clear
;      $1C  (FS)    Left
;      $1D  (GS)    Right
;      $1E  (RS)    Up
;      $1F  (US)    Down
;      $20  (SP)    Space
;
;   State -- A 16-bit word is used to return the state of several keys with
;   each event.  Each bit represents one or more keys, a zero indicates that
;   all of the keys are up, a one indicates that at least one of the keys is
;   down.  An additional bit indicates, if it is a one, that the event was
;   generated by repeating the previous event. The following bits of state are
;   currently assigned:
;
;      bit 0:  caps-lock
;      bit 1:  left or right shift
;      bit 2:  left or right option
;      bit 3:  command
;      bit 4:  mouse button
;      bit 5:  this event is a repeat
;
;   Certain keys never generate events.  These keys are caps-lock, both shift
;   keys, option keys, and the command keys.  The <Option-Toggle> combination,
;   used to toggle between the two input queues (and displays) does not generate
;   an event.  The mouse button generates events on both the down and up transitions.
;   Down transitions have as ascii value of 0, up transitions 1.  The mouse plug
;   also generates two different events.  When the mouse is plugged in an event
;   with an ascii value of 0 is returned, when it is unplugged a value of 1 is
;   returned.
;
;
;   Dead Key Diacriticals
;
;   Many languages employ diacritical marks on certain letters.  Several of the
;   required diacritical mark, letter combinations appear on European keyboards,
;   but others do not.  The combinations shown in the table below may be typed
;   as a two key sequence, by first typing the dead key diacritical (which has
;   no immediate effect), and then typing the letter.  Dead key diacriticals
;   appear on keyboard legends as the diacritical mark over a dotted square.
;
;       circumflex    ^   --   ‰      ”      ™   ž
;       grave accent  `   --   ˆ      “      ˜   
;       tilde         ~   --   ‹          –„  ›
;       acute accent  «   --   ‡   Žƒ  ’      —   œ
;       umlaut        ¬   --   Š€  ‘   •      š…  Ÿ†
;
;   A dead key diacritical followed by a letter which appears in the table above
;   yields the corresponding foreign character.  The event that is generated
;   contains the keycode, state, mouse location and time that correspond to the
;   letter, but the ascii value of the letter-diacritical combination.  A dead
;   key diacritical followed by a space yields just the diacritical mark.  The
;   event contains the keycode, state, mouse location and time corresponding to
;   the space, but the ascii value of the diacritical mark.  Finally, a dead
;   key diacritical followed by any other character (i.e. not a defined letter
;   or space) yields both the diacritical mark and the following character.
;
;       diacritical, defined letter   -->  foreign character
;       diacritical, space            -->  diacritical
;       diacritical, other character  -->  diacritical, other character
;
;
;   KeybdPeek and AltKeyPeek
;
;   Functions KeybdPeek and AltKeyPeek are used to examine events in the keyboard
;   queues, without removing them from the queue.  The first input parameter
;   indicates whether repeats are desired.  The second parameter is the queue
;   index.  The first output parameter indicates whether the specified queue entry
;   contains an event. To examine an entire queue, first call KeybdPeek (or
;   AltKeyPeek) with a queue index of 1.  If an event is returned, call it again
;   with a queue index of 2, etc.
;
;
;   Routine:    KeybdPeek
;   Arguments:    D0 (input)   --  0=no repeats, else=repeats ok (byte)
;                 D1 (input)   --  keyboard queue index: 1,2,3... (integer)
;                 D0 (output)  --  0=no event, 1=event returned (integer)
;                 D1 (output)  --  keycode (byte)
;                 D2 (output)  --  ascii value (byte)
;                 D3 (output)  --  shift key state (word)
;                 D4 (output)  --  mouseX (word)
;                 D5 (output)  --  mouseY (word)
;                 D6 (output)  --  millisecond timer value (long)
;   Function:   Return an event from the primary keyboard event queue, without
;               removing it from the queue. Repeats will be generated iff the
;               repeat parameter is non-zero.  An event is returned only if the
;               specified queue entry contains an event. The first output
;               parameter is 0 if no event is being returned, and 1 if an
;               event is returned.
;
;
;   Routine:    AltKeyPeek
;   Arguments:    D0 (input)   --  0=no repeats, else=repeats ok (byte)
;                 D1 (input)   --  keyboard queue index: 1,2,3... (integer)
;                 D0 (output)  --  0=no event, 1=event returned (integer)
;                 D1 (output)  --  keycode (byte)
;                 D2 (output)  --  ascii value (byte)
;                 D3 (output)  --  shift key state (word)
;                 D4 (output)  --  mouseX (word)
;                 D5 (output)  --  mouseY (word)
;                 D6 (output)  --  millisecond timer value (long)
;   Function:   Return an event from the alternate keyboard event queue, without
;               removing it from the queue. Repeats will be generated iff the
;               repeat parameter is non-zero.  An event is returned only if the
;               specified queue entry contains an event. The first output
;               parameter is 0 if no event is being returned, and 1 if an
;               event is returned.
;


KeybdPeek       MOVE.L  A0,-(SP)            ; save registers
                MOVE.W  #0,D5               ; 0=primary, else=alternate
                MOVE.W  D0,D3               ; save repeats
                MOVE.W  D1,D4               ; save queue index
                LEA     Queue,A0            ; keyboard event queue address
                MOVE.W  QueueIn,D0          ; queue input index
                MOVE.W  QueueOut,D1         ; queue output index
                MOVE.W  #QueueSize-1,D2     ; queue size - 1
                BRA.S   MorePeek            ; continue

AltKeyPeek      MOVE.L  A0,-(SP)            ; save registers
                MOVE.W  #1,D5               ; 0=primary, else=alternate
                MOVE.W  D0,D3               ; save repeats
                MOVE.W  D1,D4               ; save queue index
                LEA     AltQueue,A0         ; alternate event queue address
                MOVE.W  AltQueIn,D0         ; alternate queue input index
                MOVE.W  AltQueOut,D1        ; alternate queue output index
                MOVE.W  #AltQueSize-1,D2    ; alternate queue size - 1

MorePeek        TST.W   D4                  ; index <= 0 ?
                BLE     @3                  ; branch if index <= 0

                SUB.W   D1,D0               ;  - queue output index
                AND.W   D2,D0               ; entries in queue
                CMP.W   D0,D4               ; index > entries ?
                BGT.S   @2                  ; branch if index > entries

;   Copy event from the queue.

                SUB.W   #1,D4               ; index - 1
                ADD.W   D1,D4               ;  + queue output index
                AND.W   D2,D4               ; (...) mod size
                MULS    #12,D4              ; byte offset in queue
                ADD.W   D4,A0               ; queue entry address

                MOVE.B  Keycode(A0),D1      ; keycode
                MOVE.B  Ascii(A0),D2        ; ascii
                MOVE.W  State(A0),D3        ; state
                MOVE.W  MouseX(A0),D4       ; mouse X-coordinate
                MOVE.W  MouseY(A0),D5       ; mouse Y-coordinate
                MOVE.L  Time(A0),D6         ; timer value
                MOVE.W  #1,D0               ; 1=event returned
                MOVE.L  (SP)+,A0            ; restore registers
                RTS                         ; return

;   Attempt to generate a repeat.

@2              CMP.B   #1,D4               ; index = 1
                BNE.S   @3                  ; branch if index <> 1

                TST.B   D3                  ; repeats desired ?
                BEQ.S   @3                  ; branch if repeats not desired

                JSR     RepeatCheck         ; attempt to generate a repeat
                TST.B   RepeatAvailable     ; 0=not available
                BEQ.S   @3                  ; branch if repeat not available

;   Return the repeat event.

                MOVE.B  Repeat+Keycode,D1   ; keycode
                MOVE.B  Repeat+Ascii,D2     ; ascii
                MOVE.W  Repeat+State,D3     ; state
                MOVE.W  Repeat+MouseX,D4    ; mouse X-coordinate
                MOVE.W  Repeat+MouseY,D5    ; mouse Y-coordinate
                MOVE.L  Repeat+Time,D6      ; millisecond timer value
                MOVE.W  #1,D0               ; 1=event returned
                MOVE.L  (SP)+,A0            ; restore registers
                RTS                         ; return

;   No event available.  Return a dummy event.

@3              MOVE.L  #0,D6               ; dummy millisecond timer
                MOVE.L  #0,D5               ; dummy mouseY
                MOVE.L  #0,D4               ; dummy mouseX
                MOVE.L  #0,D3               ; dummy shift key state
                MOVE.L  #0,D2               ; dummy ascii value
                MOVE.L  #0,D1               ; dummy keycode
                MOVE.W  #0,D0               ; 0=no event returned
                MOVE.L  (SP)+,A0            ; restore registers
                RTS                         ; return


;
;   Functions KeybdEvent and AltKeyEvent are used both to determine if a keyboard
;   event is available, and to return the event if one is available.  The event
;   is removed from the queue. The functions return a boolean result which is true
;   if an event is returned.  A parameter to KeybdEvent (and AltKeyEvent) is used
;   to indicate if the caller will accept repeated events on this call.  A second
;   parameter indicates if the functions should wait for an event if one is not
;   immediately available.
;
;
;   Routine:    KeybdEvent
;   Arguments:    D0 (input)   --  0=no repeats, else=repeats ok (byte)
;                 D1 (input)   --  0=don't wait, else=wait for event (byte)
;                 D0 (output)  --  0=no event, 1=event returned (integer)
;                 D1 (output)  --  keycode (byte)
;                 D2 (output)  --  ascii value (byte)
;                 D3 (output)  --  shift key state (word)
;                 D4 (output)  --  mouseX (word)
;                 D5 (output)  --  mouseY (word)
;                 D6 (output)  --  millisecond timer value (long)
;   Function:   Return the next event from the primary keyboard event queue.
;               Repeats will be generated iff the repeat parameter is non-zero.
;               The first output parameter is 0 if no event is being returned,
;               and 1 if an event is returned.
;
;
;   Routine:    AltKeyEvent
;   Arguments:    D0 (input)   --  0=no repeats, else=repeats ok (byte)
;                 D1 (input)   --  0=don't wait, else=wait for event (byte)
;                 D0 (output)  --  0=no event, 1=event returned (integer)
;                 D1 (output)  --  keycode (byte)
;                 D2 (output)  --  ascii value (byte)
;                 D3 (output)  --  shift key state (word)
;                 D4 (output)  --  mouseX (word)
;                 D5 (output)  --  mouseY (word)
;                 D6 (output)  --  millisecond timer value (long)
;   Function:   Return the next event from the alternate keyboard event queue.
;               Repeats will be generated iff the repeat parameter is non-zero.
;               The first output parameter is 0 if no event is being returned,
;               and 1 if an event is returned.
;

KeybdEvent      MOVEM.L A0-A2,-(SP)         ; save registers
                MOVE.W  #0,D5               ; 0=primary, else=alternate
                LEA     Queue,A0            ; keyboard event queue address
                LEA     QueueIn,A1          ; queue input index address
                LEA     QueueOut,A2         ; queue output index address
                MOVE.W  #QueueSize-1,D2     ; queue size - 1
                BRA.S   MoreEvent           ; continue

AltKeyEvent     MOVEM.L A0-A2,-(SP)         ; save registers
                MOVE.W  #1,D5               ; 0=primary, else=alternate
                LEA     AltQueue,A0         ; alternate event queue address
                LEA     AltQueIn,A1         ; alternate input index address
                LEA     AltQueOut,A2        ; alternate output index address
                MOVE.W  #AltQueSize-1,D2    ; alternate queue size - 1

MoreEvent       MOVE.W  D0,D3               ; save repeats
                MOVE.W  D1,D4               ; save wait

@1              MOVE.W  (A2),D0             ; queue output index
                CMP.W   (A1),D0             ; queue empty ?
                BEQ.S   @2                  ; branch in queue empty

;   Remove next event from the queue.

                MOVE.W  D0,D1               ; queue output index
                MULS    #12,D1              ; byte offset in queue
                ADD.W   D1,A0               ; queue entry address
                ADD.W   #1,D0               ; (queue output index)+1
                AND.W   D2,D0               ; (queue out index)+1 mod size
                MOVE.W  D0,(A2)             ; new queue output index

                MOVE.B  #0,RepeatAvailable  ; 0=not available
                MOVE.L  Keycode(A0),Repeat  ; keycode,ascii,state
                OR.W    #$0020,Repeat+State ; repeat bit in state
                MOVE.L  Time(A0),RepeatStart; time key went down
                MOVE.L  Time(A0),RepeatTime ; time key went down
                MOVE.L  RepeatInitial,D1    ; initial repeat delay
                ADD.L   D1,RepeatTime       ; time of first repeat

                MOVE.B  Keycode(A0),D1      ; keycode
                MOVE.B  Ascii(A0),D2        ; ascii
                MOVE.W  State(A0),D3        ; state
                MOVE.W  MouseX(A0),D4       ; mouse X-coordinate
                MOVE.W  MouseY(A0),D5       ; mouse Y-coordinate
                MOVE.L  Time(A0),D6         ; timer value
                MOVE.W  #1,D0               ; 1=event returned
                MOVEM.L (SP)+,A0-A2         ; restore registers
                RTS                         ; return

;   Attempt to generate a repeat.

@2              TST.B   D3                  ; repeats desired ?
                BEQ.S   @3                  ; branch if repeats not desired

                JSR     RepeatCheck         ; attempt to generate a repeat
                TST.B   RepeatAvailable     ; 0=not available
                BEQ.S   @3                  ; branch if repeat not available

;   Return the repeat event.

                MOVE.B  #0,RepeatAvailable  ; 0=not available
                MOVE.L  RepeatSubseq,D0     ; subsequent repeat delay
                ADD.L   D0,RepeatTime       ; time of next repeat

                MOVE.B  Repeat+Keycode,D1   ; keycode
                MOVE.B  Repeat+Ascii,D2     ; ascii
                MOVE.W  Repeat+State,D3     ; state
                MOVE.W  Repeat+MouseX,D4    ; mouse X-coordinate
                MOVE.W  Repeat+MouseY,D5    ; mouse Y-coordinate
                MOVE.L  Repeat+Time,D6      ; millisecond timer value
                MOVE.W  #1,D0               ; 1=event returned
                MOVEM.L (SP)+,A0-A2         ; restore registers
                RTS                         ; return

;   No event available. Either wait or return a dummy event.

@3              TST.B   D4                  ; 0=don't wait, else=wait
                BNE.S   @1                  ; branch if waiting for event

                MOVE.L  #0,D6               ; dummy millisecond timer
                MOVE.L  #0,D5               ; dummy mouseY
                MOVE.L  #0,D4               ; dummy mouseX
                MOVE.L  #0,D3               ; dummy shift key state
                MOVE.L  #0,D2               ; dummy ascii value
                MOVE.L  #0,D1               ; dummy keycode
                MOVE.W  #0,D0               ; 0=no event returned
                MOVEM.L (SP)+,A0-A2         ; restore registers
                RTS                         ; return


;-----------------------------------------------------------------------------
;
;   Repeats
;
;   Certain keys, if held down for an extended period of time, may generate
;   multiple events (repeats).  Several conditions must all be satisfied before
;   a repeat is generated.  These conditions are as follows:
;       1)  KeybdPeek, AltKeyPeek, KeybdEvent or AltKeyEvent is called with
;           repeatsDesired true.
;       2)  The specified keyboard event queue is empty.
;       3)  The key returned in the last event is still down.
;       4)  No down transitions have occurred since the last event.
;       5)  The key is repeatable.
;       6)  Enough time has elapsed.
;       7)  The request is for the keyboard where last key was typed.
;
;   All keys are repeatable, with the exception of caps-lock, shifts,
;   options, command, disk 1 inserted, disk 1 button, disk 2 inserted, disk 2
;   button, parallel port, mouse button, mouse plug, and the power button.
;
;   Repeats generate events with the following attributes:
;
;      keycode  --  original keycode
;      ascii    --  original ascii interpretation
;      state    --  original position of the caps-lock, shift, etc.
;      mousePt  --  revised mouse location
;      time     --  revised value of the millisecond timer
;
;   The repeat rates can be read and set by calls to RepeatRate and
;   SetRepeatRate.  The rates include an initial delay, which occurs prior
;   to the first repetition, and a subsequent delay, prior to additional
;   repetitions.  They are both in units of milliseconds.  The default repeat
;   rates are 400 milliseconds initially and 150 milliseconds subsequently.
;
;
;
;   Routine:    RepeatRate
;   Arguments:    D0 (output)  --  initial repeat delay in milliseconds (long)
;                 D1 (output)  --  subsequent delay in milliseconds (long)
;   Function:   Return the initial and subsequent repeat delays.
;
;   Routine:    SetRepeatRate
;   Arguments:    D0 (input)   --  initial repeat delay in milliseconds (long)
;                 D1 (input)   --  subsequent delay in milliseconds (long)
;   Function:   Set the initial and subsequent repeat delays.
;


RepeatRate      MOVE.L  RepeatInitial,D0    ; initial repeat delay
                MOVE.L  RepeatSubseq,D1     ; subsequent repeat delay
                RTS                         ; return

SetRepeatRate   MOVE.L  D0,RepeatInitial    ; initial repeat delay
                MOVE.L  D1,RepeatSubseq     ; subsequent repeat delay
                RTS                         ; return


;-----------------------------------------------------------------------------
;
;   RepeatCheck
;
;   Internal routine RepeatCheck tests the following conditions:
;       1)  The request is for the keyboard where last key was typed.
;       2)  The key returned in the last event is still down.
;       3)  No down transitions have occurred since the last event.
;       4)  The key is repeatable.
;       5)  Enough time has elapsed.
;   If all of the conditions are true, RepeatCheck generate a repeat into
;   global variable Repeat, and sets RepeatAvailable to 1.  All registers
;   are preserved.
;

RepeatCheck     MOVEM.L D0-D1/A0,-(SP)      ; save registers
                TST.B   RepeatAvailable     ; 0=not available
                BNE.S   @1                  ; branch if already available

                CMP.B   ScrnKeybd,D5        ; 0=primary, else=alternate
                BNE.S   @1                  ; branch if different keyboard

                MOVE.B  Repeat+Keycode,D0   ; repeated key
                EXT.W   D0                  ; keycode (word)
                JSR     KeyIsDown           ; D1 <- 0=up, 1=down
                TST.W   D1                  ; key down ?
                BEQ.S   @1                  ; branch if not down

                CMP.B   LastKeyDown,D0      ; same as last key down ?
                BNE.S   @1                  ; branch if keys differ

                MOVE.L  RepeatStart,D1      ; time repeated key went down
                CMP.L   LastKeyTime,D1      ; same time as last key down ?
                BNE.S   @1                  ; branch if time differ

                TST.B   DKDPending          ; 0=not pending, else=pending (byte)
                BNE.S   @1                  ; branch if diacritical pending

                LEA     RepeatTable,A0      ; repeatable keys table address
                MOVE.W  D0,D1               ; keycode (word)
                ASR.W   #3,D0               ; keycode / 8
                NOT     D1                  ; bits numbered right to left
                AND.W   #8-1,D1             ; bit position
                BTST    D1,0(A0,D0.W)       ; keyswitch repeatable ?
                BEQ.S   @1                  ; branch if not repeatable

                JSR     Timer               ; D0 <- millisecond timer
                CMP.L   RepeatTime,D0       ; repeat delay elapsed ?
                BMI.S   @1                  ; branch if delay not elapsed

                MOVE.L  D0,Repeat+Time      ; millisecond timer value
                JSR     MouseLocation       ; D0/D1 <- mouse location
                MOVE.W  D0,Repeat+MouseX    ; mouse X-coordinate
                MOVE.W  D1,Repeat+MouseY    ; mouse Y-coordinate
                MOVE.B  #1,RepeatAvailable  ; 1=repeat available

@1              MOVEM.L (SP)+,D0-D1/A0      ; restore registers
                RTS                         ; return



;-----------------------------------------------------------------------------
;
;   Pseudo-Keys
;
;   The disk insertion switches, the disk buttons and the power button are
;   detected in drivers other than the normal keyboard driver.  The drivers
;   which detect these switches and buttons must call routine KeyPushed each
;   time a pseudo-key is pressed.  KeyPushed is passed a keycode, defined as
;   follows:
;
;       01  --  Disk 1 Inserted
;       02  --  Disk 1 Button
;       03  --  Disk 2 Inserted
;       04  --  Disk 2 Button
;       08  --  Power Button
;       09  --  reserved for use by O.S.
;       0A  --  reserved for use by O.S.
;       0B  --  Internal Sony Inserted
;       0C  --  Slot 1 Sony Inserted
;       0D  --  Slot 2 Sony Inserted
;       0E  --  Slot 3 Sony Inserted
;
;
;   Routine:    KeyPushed
;   Arguments:    D0 (input)   --  keycode (integer)
;   Function:   Indicate that the psuedo-key identified by keycode has been
;               pressed.
;

KeyPushed       ACTIVE                      ; report user activity
                MOVEM.L D0-D7/A0-A6,-(SP)   ; save registers
                MOVE.L  KeybdRoutine,A0     ; address of routine Key
                TST.B   ScrnKeybd           ; 0=primary, else=alternate (byte)
                BEQ.S   @1                  ; branch if primary screen/keyboard
                LEA     Key,A0              ; address of default Key routine

@1              MOVEM.L D0/A0,-(SP)         ; save registers
                MOVE.W  #$80,D1             ; #80=down transition
                JSR     (A0)                ; indicate down transition
                MOVEM.L (SP)+,D0/A0         ; restore registers
                MOVE.W  #$00,D1             ; $00=up transition
                JSR     (A0)                ; indicate up transition
                MOVEM.L (SP)+,D0-D7/A0-A6   ; restore registers
                RTS                         ; return


;-----------------------------------------------------------------------------
;
;   NMI Key
;
;   It is possible to program a specific keyboard key to generate NMI (non-
;   maskable interrupt) rather than the character it normally generates.  The
;   key is specified by it's keycode, defined above.  If no NMI key is desired,
;   specify a keycode of zero.  The routines below return the keycode of the
;   current NMI key, and program a new NMI key.  Initially no NMI key has been
;   programmed.
;
;
;   Routine:    NMIKey
;   Arguments:    D0 (output)  --  keycode (integer)
;   Function:   Return the keycode of the current NMI key.
;

NMIKey          MOVE.W  #0,D0               ; clear register
                MOVE.B  NMIKeycode,D0       ; NMI keycode
                RTS                         ; return


;
;   Routine:    SetNMIKey *
;   Arguments:    D0 (input)   --  keycode (integer)
;   Function:   Program the specified key to generate NMI.
;

SetNMIKey       MOVEM.L D0-D2,-(SP)         ; save registers
                MOVE.L  COPSCounter,D2      ; COPS transaction counter
                MOVE.B  D0,D1               ; save keycode
                LSR.B   #4,D0               ; high nibble and garbage
                AND.B   #$07,D0             ; high nibble of NMI key
                OR.B    #$58,D0             ; add set high nibble command
                JSR     COPSCMD             ; send command to COPS
                MOVE.B  D1,D0               ; restore keycode
                AND.B   #$0F,D0             ; low nibble of NMI key
                OR.B    #$60,D0             ; add set low nibble command
                JSR     COPSCMD             ; send command to COPS
                CMP.L   COPSCounter,D2      ; interrupted ?
                MOVEM.L (SP)+,D0-D2         ; restore registers
                BNE.S   SetNMIKey           ; branch if interrupted

                ADD.L   #1,COPSCounter      ; COPS transaction counter
                MOVE.B  D0,NMIKeycode       ; NMI keycode
                RTS                         ; return


;-----------------------------------------------------------------------------
;
;   Toggle Key
;
;   The user can toggle between the primary and alternate screen/keyboard by
;   typing <Option-Toggle>.  The Toggle key is defined programmatically by
;   specifying it's keycode, defined above.  If no Toggle key is desired,
;   specify a keycode of zero.  The routines below return the keycode of the
;   current Toggle key, and program a new Toggle key.  Initially no Toggle key
;   is defined.
;
;
;   Routine:    ToggleKey
;   Arguments:    D0 (output)  --  keycode (integer)
;   Function:   Return the keycode of the current Toggle key.
;

ToggleKey       MOVE.W  #0,D0               ; clear register
                MOVE.B  ToggleCode,D0       ; Toggle keycode
                RTS                         ; return


;
;   Routine:    SetToggleKey
;   Arguments:    D0 (input)   --  keycode (integer)
;   Function:   Set the alternate screen/keyboard Toggle key.
;

SetToggleKey    MOVE.B  D0,ToggleCode       ; Toggle keycode
                RTS                         ; return



;-----------------------------------------------------------------------------
;
;   Undecoded Key Transitions
;
;   The user may supply a routine, called "KEY", which is called once for each
;   key transition.  Routine KEY is passed both the keycode, defined above,
;   and the direction of the transition (down/up).  The user supplied routine
;   KEY replaces the built-in routines that provide the pollable keyboard
;   state and keyboard events.  Therefore, if a user supplied KEY routine is
;   being used, calls to KeyIsDown, KeyMap, KeybdPeek, and KeybdEvent will
;   return meaningless results.
;
;   The user may also specify a routine, called "KEYID", which is called
;   whenever a new keyboard identification is detected.  The user supplied
;   routine KEYID replaces built-in routines.  Therefore, if a user supplied
;   KEYID routine is in use, calls to Keyboard will return meaningless results.
;
;   The user may specify a routine, called "KEYERR", which is called whenever
;   a COPS failure is detected.  KEYERR is passed a parameter which indicates
;   if the failure is in the I/O board COPS or the keyboard COPS.
;
;   The user supplied routine KEY, KEYID, and KEYERR run as interrupt handlers.
;   Interrupts at priority levels 1-6 are disabled during their execution.
;   To guarentee proper response to interrupts, they should complete their
;   processing within 1-2 milliseconds.  These routines need not preserve
;   registers.
;
;
;   Routine:    KEY (user routine)
;   Arguments:    D0 (input)   --  keycode (integer)
;                 D1 (input)   --  $00=up, $80=down transition (integer)
;   Function:   User supplied routine which is called for each key transition.
;
;
;   Routine:    KeyRoutine
;   Arguments:    A0 (output)  --  address of routine KEY
;   Function:   Return the address of routine KEY, the user supplied routine
;               which is called for each key transition.
;

KeyRoutine      MOVE.L  KeybdRoutine,A0     ; address of routine KEY
                RTS                         ; return


;   Routine:    SetKeyRoutine
;   Arguments:    A0 (input)   --  address of routine KEY
;   Function:   Specify the address of routine KEY, the user supplied routine
;               which is called for each key transition.
;

SetKeyRoutine   MOVE.L  A0,KeybdRoutine     ; address of routine KEY
                RTS                         ; return


;   Routine:    KEYID (user routine)
;   Arguments:    D0 (input)   --  keyboard identification (integer)
;   Function:   User supplied routine which is called when a new keyboard
;               identification is detected.
;
;   Routine:    KeyIdRoutine
;   Arguments:    A0 (output)  --  address of routine KEYID
;   Function:   Return the address of routine KEYID, the user supplied routine
;               which is called when a new keyboard identification is detected.
;

KeyIdRoutine    MOVE.L  KeybdIdRoutine,A0   ; address of routine KEYID
                RTS                         ; return


;   Routine:    SetKeyIdRoutine
;   Arguments:    A0 (input)   --  address of routine KEYID
;   Function:   Specify the address of routine KEYID, the user supplied routine
;               which is called when a new keyboard identification is detected.
;

SetKeyIdRoutine MOVE.L  A0,KeybdIdRoutine   ; address of routine KEYID
                RTS                         ; return


;   Routine:    KEYERR (user routine)
;   Arguments:    D0 (input)   --  0=I/O board COPS failure,
;                                  1=keyboard COPS failure (integer)
;   Function:   User supplied routine which is called when a COPS error is
;               detected.
;
;   Routine:    KeyErrRoutine
;   Arguments:    A0 (output)  --  address of routine KEYERR
;   Function:   Return the address of routine KEYERR, the user supplied routine
;               which is called when a COPS error is detected.
;

KeyErrRoutine   MOVE.L  KeybdErrRoutine,A0  ; address of routine KEYERR
                RTS                         ; return


;   Routine:    SetKeyErrRout
;   Arguments:    A0 (input)   --  address of routine KEYERR
;   Function:   Specify the address of routine KEYERR, the user supplied routine
;               which is called when a COPS error is detected.
;

SetKeyErrRout   MOVE.L  A0,KeybdErrRoutine  ; address of routine KEYERR
                RTS                         ; return





;-----------------------------------------------------------------------------
;
;   Key
;
;   Internal routine Key is called from the COPS interrupt handler and from
;   routine KeyPushed. Key maintains the keyboard map and shift key state,
;   and adds events to the keyboard event queue.  It operates with interrupts
;   at priority levels 1-2 disabled.  Registers are NOT preserved.
;
;
;   Routine:    KEY
;   Arguments:    D0 (input)   --  keycode (integer)
;                 D1 (input)   --  $00=up, $80=down transition (integer)
;   Function:   Built-in routine which is called for each key transition.
;
;

Key             MOVE.W  D0,D2               ; keycode
                ASR.W   #3,D2               ; keycode / 8
                AND.W   #$C,D2              ; byte offset of long
                MOVE.W  D0,D3               ; keycode
                AND.W   #32-1,D3            ; bit position within long
                LEA     KeyBitmap,A0        ; keyboard map address
                MOVE.L  0(A0,D2.W),D4       ; long containing bit
                TST.W   D1                  ; $00=up, $80=down
                BNE.S   @1                  ; branch if down transition

                BCLR    D3,D4               ; key map, 0=up
                BNE.S   @2                  ; branch if previously down
                ADD.W   #1,ErrorsDown       ; we missed a down transition!
                BRA.S   @2                  ; continue

@1              MOVE.B  D0,LastKeyDown      ; keycode of last key down (byte)
                MOVE.W  D0,-(SP)            ; save register
                JSR     Timer               ; D0 <- millisecond timer (long)
                MOVE.L  D0,LastKeyTime      ; time of last key down (long)
                MOVE.W  (SP)+,D0            ; restore register
                BSET    D3,D4               ; key map, 1=down
                BEQ.S   @2                  ; branch if previously up
                ADD.W   #1,ErrorsUp         ; we missed an up transition!

@2              MOVE.L  D4,0(A0,D2.W)       ; update keyboard map

;  Update the shift key state.

                MOVE.W  ShiftState,D3       ; shift key state, 0=up             <23Mar83>
                LEA     ShiftTable,A0       ; shift table address

@3              TST.W   (A0)                ; end of table ?
                BEQ.S   @5                  ; branch if end of table

                MOVE.B  (A0)+,D2            ; bit number in shift key state
                CMP.B   (A0)+,D0            ; keycode matches table ?
                BNE.S   @3                  ; branch if not a match

                BSET    D2,D3               ; shift key state, 1=down           <23Mar83>
                TST.W   D1                  ; $00=up, $80=down                  <23Mar83>
                BNE.S   @3                  ; branch if down transition         <23Mar83>

                BCLR    D2,D3               ; shift key state, 0=up             <23Mar83>
                BRA.S   @3                  ; continue                          <23Mar83>

@5              MOVE.W  D3,ShiftState       ; update shift key state            <23Mar83>
                OR.B    ShiftState,D3       ; OR high and low bytes             <23Mar83>
                MOVE.B  D3,Event+State+1    ; update shift key state            <23Mar83>

;   Should we toggle between screens and keyboards?

                CMP.B   ToggleCode,D0       ; keycode the toggle ?
                BNE.S   @6                  ; branch if not the toggle

                MOVE.W  Event+State,D2      ; shift key state, 1=down
                AND.W   #ToggleState,D2     ; toggle state
                CMP.W   #ToggleState,D2     ; necessary state keys down ?
                BNE.S   @6                  ; branch if keys not down

                TST.W   D1                  ; $00=up, $80=down
                BEQ     @14                 ; branch if up transition

;   Toggle to the other screen and keyboard.

                MOVE.L  D0,-(SP)            ; save registers
                JSR     ScreenKeybd         ; current screen/keyboard
                BCHG    #0,D0               ; 0=primary, 1=alternate
                JSR     SetScreenKeybd      ; toggle to other screen/keyboard
                MOVE.L  (SP)+,D0            ; restore registers
                BRA     @14                 ; don't generate an event

;   Decide if an event should be generated.

@6              MOVE.B  D0,Event+Keycode    ; event keycode (byte)
                LEA     EventTable,A0       ; event table address
                MOVE.W  D0,D2               ; keycode
                ASR.W   #3,D2               ; keycode / 8
                MOVE.W  D0,D3               ; keycode
                NOT     D3                  ; bits numbered right to left
                AND.W   #8-1,D3             ; bit position
                BTST    D3,0(A0,D2.W)       ; key generates events ?
                BEQ     @14                 ; branch if doesn't yield events

                TST.W   D1                  ; $00=up, $80=down
                BEQ.S   @7                  ; branch if up transition

                MOVE.W  Event+State,D1      ; shift key state
                JSR     KeyToAscii          ; D0 <- ascii (byte)
                MOVE.B  D0,Event+Ascii      ; event ascii value (byte)
                MOVE.L  LastKeyTime,Event+Time  ; millisecond timer
                BRA.S   @9                  ; continue

;   Up transitions on the mouse button and mouse plug yield events, with
;   ascii values of 1.

@7              CMP.W   #$06,D0             ; keycode = mouse button ?
                BEQ.S   @8                  ; branch if mouse button
                CMP.W   #$07,D0             ; keycode = mouse plug ?
                BNE     @14                 ; branch if not mouse plug

@8              MOVE.B  #1,Event+Ascii      ; event ascii value (byte)
                JSR     Timer               ; D0 <- millisecond timer (long)
                MOVE.L  D0,Event+Time       ; millisecond timer

;   Construct the remainder of the event.

@9              JSR     MouseLocation           ; D0/D1 <- mouse location
                MOVE.W  D0,Event+MouseX         ; mouse X-coordinate
                MOVE.W  D1,Event+MouseY         ; mouse Y-coordinate
                MOVE.B  Event+Ascii,D0          ; current character ascii

;   Check to see if the previous key was a diacritical mark. If so, search
;   the dead key diacritical table for the combination of the pending
;   diacritical and the current character.

                TST.B   DKDPending          ; 0=not pending, else=pending
                BEQ.S   @12                 ; branch if not pending

                MOVE.B  #0,DKDPending       ; 0=not pending, else=pending
                MOVE.B  DKDEvent+Ascii,D1   ; diacritical code
                LEA     DKDTable-3,A0       ; prior to DKDTable (address)

@10             ADD.W   #3,A0               ; next DKDTable entry
                TST.B   (A0)                ; end of table ?
                BEQ.S   @11                 ; branch if end of table

                CMP.B   (A0),D1             ; diacritical mark matches table ?
                BNE.S   @10                 ; branch if doesn't match table

                MOVE.B  2(A0),D2            ; combination of DKD and character
                CMP.B   1(A0),D0            ; current character matches table ?
                BNE.S   @10                 ; branch if doesn't match table

;   The <diacritical code>, <letter> (or space) combination has been found in
;   the DKDTable.  Enqueue an event whose ascii is the <combination>, and
;   whose keycode, state, mouse location and time correspond to the <letter>
;   (or space).

                MOVE.B  D2,Event+Ascii      ; combination of DKD and character
                BRA.S   @13                 ; enqueue the event

;   The <diacritical code>, <letter> combination was not found in the DKDTable.
;   Enqueue an event for the diacritical mark, then continue processing the
;   current character.  The ascii value of the diacritical corresponds to the
;   <diacritical code>, <space> entry in the table.

@11             MOVE.B  D2,DKDEvent+Ascii   ; ascii for the diacritical
                LEA     DKDEvent,A0         ; dead key diacritical event
                JSR     Enqueue             ; add diacritical to event queue

;   If the ascii value for the current character is a code indicating that it
;   is a dead key diacritical mark, save this event until the next character
;   is typed.

@12             CMP.B   #DKDLast,D0         ; ascii > last diacritical code ?
                BGT.S   @13                 ; branch if not a diacritical code

                CMP.B   #DKDFirst,D0        ; ascii < first diacritical code ?
                BLT.S   @13                 ; branch if not a diacritical code

                LEA     Event,A0            ; event buffer (address)
                LEA     DKDEvent,A1         ; dead key diacritical event (addrress)
                MOVE.L  (A0)+,(A1)+         ; Keycode, Ascii, State
                MOVE.L  (A0)+,(A1)+         ; MouseX, MouseY
                MOVE.L  (A0)+,(A1)+         ; Time
                MOVE.B  #1,DKDPending       ; 0=not pending, else=pending
                BRA.S   @14                 ; return

;   Enqueue the event.

@13             LEA     Event,A0            ; event buffer address
                JSR     Enqueue             ; add event to event queue

@14             RTS                         ; return



;-----------------------------------------------------------------------------
;
;   KeyToAscii
;
;   Internal routine KeyToAscii returns the ascii value associated with a
;   specified keycode and shift key state.  All registers are preserved.
;
;   Input Parameters:
;
;       D0  --  keycode (word)
;       D1  --  shift key state (word)
;
;   Output Parameters:
;
;       D0  --  ascii (byte)
;

KeyToAscii      MOVEM.L D1/A0,-(SP)         ; save registers
                LEA     OffsetTable,A0      ; offsets into AsciiTable
                AND.W   #$7,D1              ; option, shift, caps
                ADD.W   D1,D1               ; double for byte offset
                MOVE.W  0(A0,D1.W),D1       ; offset into AsciiTable
                MOVE.L  #AsciiTable,A0      ; keycode to ascii table
                ADD.W   D0,D1               ; offset + keycode
                MOVE.B  0(A0,D1.W),D0       ; ascii (byte)
                MOVEM.L (SP)+,D1/A0         ; restore registers
                RTS                         ; return



;-----------------------------------------------------------------------------
;
;   Enqueue
;
;   Internal routine Enqueue adds an event to one of the keyboard event queues.
;   A beep is generated if the queue is full.  All registers are preserved.
;
;   Input Parameters:
;
;       A0  --  event (address)
;


Enqueue         MOVEM.L D0-D3/A1,-(SP)          ; save registers
                LEA     Queue,A1                ; keyboard event queue address
                MOVE.W  QueueIn,D0              ; queue input index
                MOVE.W  QueueOut,D1             ; queue output index
                MOVE.W  #QueueSize-1,D2         ; queue size - 1
                TST.B   ScrnKeybd               ; 0=primary, else=alternate
                BEQ.S   @1                      ; branch if primary keyboard

                LEA     AltQueue,A1             ; alternate event queue address
                MOVE.W  AltQueIn,D0             ; alternate queue input index
                MOVE.W  AltQueOut,D1            ; alternate queue output index
                MOVE.W  #AltQueSize-1,D2        ; alternate queue size - 1

@1              MOVE.W  D0,D3                   ; queue input index
                MULS    #12,D3                  ; byte offset in queue

                MOVE.L  Keycode(A0),Keycode(A1,D3.W)    ; keycode,ascii,state
                MOVE.L  MouseX(A0),MouseX(A1,D3.W)      ; mouse X and Y
                MOVE.L  Time(A0),Time(A1,D3.W)          ; millisecond timer

                ADD.W   #1,D0                   ; (queue input index)+1

                AND.W   D2,D0                   ; (queue in index)+1 mod size
                CMP.W   D1,D0                   ; event queue full ?
                BEQ.S   @3                      ; branch if queue full

                TST.B   ScrnKeybd               ; 0=primary, else=alternate
                BNE.S   @2                      ; branch if alternate keyboard

                MOVE.W  D0,QueueIn              ; new queue input index
                BRA.S   @4                      ; continue

@2              MOVE.W  D0,AltQueIn             ; new alternate input index
                BRA.S   @4                      ; continue

@3              MOVE.L  #4545,D0                ; wavelength for A below middle C
                MOVE.L  #200,D1                 ; duration of 200 milliseconds
                JSR     Beep                    ; beep the speaker

@4              MOVEM.L (SP)+,D0-D3/A1          ; restore registers
                RTS                             ; return



;-----------------------------------------------------------------------------
;
;   KeyId
;
;   Internal routine KeyId is called by the interrupt handlers each time a new
;   keyboard id is detected.  KeyId modifies the keyboard bitmap and the shift
;   key state to indicate that all keys are up.  It also calls SetLegends to
;   establish the new keyboard mapping.
;
;   Routine:    KEYID
;   Arguments:    D0 (input)   --  keyboard identification (integer)
;   Function:   Built-in routine which is called when a new keyboard
;               identification is detected.
;

KeyId           MOVE.L  D0,-(SP)            ; save registers
                MOVE.B  D0,KeybdId          ; save keyboard id
                AND.L   #$E0,KeyBitmap      ; save parallel port, mouse button & plug
                MOVE.L  #0,KeyBitmap+4      ; clear  63 .. 32
                MOVE.L  #0,KeyBitmap+8      ; clear  95 .. 64
                MOVE.L  #0,KeyBitmap+12     ; clear 127 .. 96
                MOVE.W  #0,ShiftState       ; clear shift key state         <08Jul83>
                AND.W   #$003F,D0           ; keybd layout/legends
                JSR     SetLegends          ; establish new keyboard mapping
                MOVE.L  (SP)+,D0            ; restore registers
                RTS                         ; return


;-----------------------------------------------------------------------------
;
;   KeyErr
;
;   Internal routine KeyErr is called by the interrupt handlers when a COPS
;   failure has been detected.
;
;   Routine:    KEYERR
;   Arguments:    D0 (input)   --  0=I/O board COPS failure,
;                                  1=keyboard COPS failure (integer)
;   Function:   Built-in routine which is called when a COPS error is
;               detected.
;

KeyErr          TST.W   D0                  ; 0=I/O COPS, 1=keyboard COPS
                BNE.S   @1                  ; branch if keyboard COPS
                ADD.W   #1,ErrorsIO         ; increment error count
                RTS                         ; return

@1              ADD.W   #1,ErrorsKeybd      ; increment error count
                RTS                         ; return




ÿ