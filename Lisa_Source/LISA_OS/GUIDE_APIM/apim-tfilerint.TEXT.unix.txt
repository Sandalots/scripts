{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}


{****************************************************************}
{               IM Event Recording procedures                    }
{****************************************************************}

{$S imtf }

PROCEDURE MovContEvt(obj: ObjectHandle;
                           doState: ObjectState);
VAR listHead,son: ObjectHandle;
    objIdx: TC;
BEGIN
IF NOT fRObjects THEN EXIT(MovContEvt);
IF trcFiler THEN WRITELN('MovContEvt "',obj^^.name,'"');
listHead := obj^^.contents;
son:=listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state= doState
     THEN BEGIN
        objIdx := GetObjIdx(curObjTable, son);
        WITH son^^.loc DO Add8ObjEvt(curEvtBuf, CObjMove, objIdx, h, v);
      END;
   son:=son^^.prev;
   END;
END;

PROCEDURE MovObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    WITH hObj^^.loc DO Add8ObjEvt(curEvtBuf, CObjMove, objIdx, h, v);
   END;
END;


PROCEDURE MovFldrEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    WITH hObj^^.objWindow^.PortBits.bounds
       DO Add8ObjEvt(curEvtBuf, CObjMove, objIdx, -left, -top);
   END;
END;


PROCEDURE SzObjEvt(hObj: ObjectHandle; ht, wd: TC);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN
    IF hObj <> nilObject
      THEN BEGIN
        objIdx := GetObjIdx(curObjTable, hObj);
        Add8ObjEvt(curEvtBuf, CObjSize, objIdx, ht, wd);
       END;
END;


PROCEDURE ActObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN
    IF hObj <> nilObject
      THEN BEGIN
        objIdx := GetObjIdx(curObjTable, hObj);
        Add4ObjEvt(curEvtBuf, CObjActivate, objIdx);
       END;
END;


PROCEDURE OpnObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add4ObjEvt(curEvtBuf, CObjOpen, objIdx);
   END;
END;


PROCEDURE ClsObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add4ObjEvt(curEvtBuf, CObjClose, objIdx);
   END;
END;


PROCEDURE KilObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add4ObjEvt(curEvtBuf, CObjKill, objIdx);
   END;
END;


PROCEDURE CCtObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add6ObjEvt(curEvtBuf, CObjChgCont, objIdx,
              GetObjIdx(curObjTable, hObj^^.container));
    MovObjEvt(hObj);
   END;
END;


PROCEDURE DupObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add4ObjEvt(curEvtBuf, CObjDuplicate, objIdx);
   END;
END;


PROCEDURE OPdObjEvt(hObj, hNewObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add6ObjEvt(curEvtBuf, CObjOpnPad, objIdx, GetObjIdx(curObjTable, hNewObj));
   END;
END;


PROCEDURE BackObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add4ObjEvt(curEvtBuf, CObjPutBak, objIdx);
   END;
END;


PROCEDURE SelObjEvt(hObj: ObjectHandle; howSel: TC);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add6ObjEvt(curEvtBuf, CObjSelect, objIdx, howSel);
   END;
END;


PROCEDURE DSlObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN BEGIN
    objIdx := GetObjIdx(curObjTable, hObj);
    Add4ObjEvt(curEvtBuf, CObjDeSel, objIdx);
   END;
END;


PROCEDURE SetDeSelAll;
BEGIN
  IF fTstTF THEN WRITELN('SetDeSelAll');
  doDslAll := TRUE;
END;

PROCEDURE DSlAllEvt;
BEGIN
  IF fRObjects THEN Add4ObjEvt(curEvtBuf, CObjDslAll, 0);
  doDslAll := FALSE;
END;


PROCEDURE RNmObjEvt(hObj: ObjectHandle);
VAR objIdx: TC;
BEGIN
  IF fRObjects AND (rnmObjIdx <> CNilOBjIdx) AND (hObj^^.name <> rnmName)
    THEN BEGIN
      objIdx := GetObjIdx(curObjTable, hObj);
      Add6ObjEvt(curEvtBuf, CObjRename, rnmObjIdx, objIdx);
     END;
  rnmObjIdx := CNilObjIdx;
  rnmName := '';
END;


PROCEDURE KillIMFldr(obj: ObjectHandle);
BEGIN
  IF obj^^.imFldr <> NIL
    THEN BEGIN
      obj^^.imFldr^^.fldrFObj := NIL;
      FreeStrFldr(obj^^.imFldr);
     END;
END;


{****************************************************************}
{                Added IM Interface Procedures                   }
{****************************************************************}

FUNCTION OnDisk(obj: ObjectHandle): ObjectHandle;
{ returns first ancestor with type in diskSet }
VAR recID,fatherRecID: TcatRID;
    fatherObj: ObjectHandle;
BEGIN
IF fTstTF THEN WRITELN('OnDisk "',obj^^.name,'"');
recID := obj^^.catRID;

fatherObj := obj;
WHILE (recID.uniqueID <> idNil)  DO
   BEGIN
   IF fatherObj^^.kind IN diskSet THEN
      BEGIN
      OnDisk := fatherObj;
      EXIT(OnDisk);
      END;
   ClimbTree(obj^^.volHdl,recID,fatherRecID,fatherObj);
   recID := fatherRecID;
   END;
OnDisk := nilObject;
END;



FUNCTION  GetDvHndl(VAR devName: FmaxStr): TentryHdl;
VAR devHdl: TentryHdl;
    diskObj: ObjectHandle;
BEGIN
  devHdl := NIL;
  IF fTstTF THEN WRITELN('GetDvHndl for device: ', devName);
  REPEAT
    GetEntry (dev, NIL, devHdl, nilField, devHdl);
    IF devHdl = NIL THEN SysErr(916, nullErr);
    UNTIL (devHdl^^.nameHdl^^ = devName);
  GetDvHndl := devHdl;
END;


PROCEDURE IFMount; { (VAR err: INTEGER; VAR devName: FmaxStr); }
VAR devHdl: TentryHdl;
    diskObj: ObjectHandle;
BEGIN
  IF fTstTF THEN WRITELN('IFMount  devName = ', devName);

  devHdl := NIL;
  REPEAT
    GetEntry (dev, NIL, devHdl, nilField, devHdl);
    IF devHdl = NIL THEN SysErr(916, nullErr);
    UNTIL (devHdl^^.nameHdl^^ = devName);

  IF fTstTF THEN
    WRITELN ('   Opening catalog on device ', devHdl^^.nameHdl^^);
  OpenCat (err, devHdl);          { Creates the vol entry }
  IF err <> 0
  THEN BEGIN
    IF fTstTF THEN
      WRITELN('Catalog for ', devName, ' not opened properly: err = ', err);
    EXIT(IFMount);
   END;

  RestoreDesktop(devHdl^^.volHdl, diskObj);
  WRITELN('IFMount: diskObj: ', ORD(diskObj));
  WRITELN('  floppy1Object:  ', ORD(floppy1Object));
  WRITELN('  floppy2Object:  ', ORD(floppy2Object));
  WRITELN('  hardDiskObject: ', ORD(hardDiskObject));
  WRITELN('  nilObject:      ', ORD(nilObject));


  IF fTstTF THEN
    WRITELN('Catalog opened for dev:', devName, ' err:', err:5);
END;


PROCEDURE IFUnMount; { (VAR err: INTEGER; VAR devName: FmaxStr); }
VAR devHdl: TentryHdl;
    diskObj: ObjectHandle;
BEGIN
  IF fTstTF THEN WRITELN('IFUnMount  devName = ', devName);

  err := 0;
  devHdl := NIL;
  REPEAT
    GetEntry (dev, NIL, devHdl, nilField, devHdl);
    IF devHdl = NIL THEN SysErr(916, nullErr);
    UNTIL (devHdl^^.nameHdl^^ = devName);

  CASE devName[1] OF
    'U': diskObj := floppy1Object;
    'L': diskObj := floppy2Object;
    'P': diskObj := hardDiskObject;
    OTHERWISE diskObj := nilObject;
   END;
  WRITELN('IFUnMount: diskObj: ', ORD(diskObj));
  WRITELN('  floppy1Object:    ', ORD(floppy1Object));
  WRITELN('  floppy2Object:    ', ORD(floppy2Object));
  WRITELN('  hardDiskObject:   ', ORD(hardDiskObject));
  WRITELN('  nilObject:        ', ORD(nilObject));

  IF diskObj <> nilObject THEN
    BEGIN
      { remove the disk icon if ejecting the disk }
      IF NOT CleanupDisk(diskObj)
        THEN IF sDebug THEN WRITELN(' PutBackObject in IFUnMount fails');
      KillObject(diskObj,TRUE,TRUE);
      IF fTstTF THEN
        WRITELN ('   Closing catalog on device ', devHdl^^.nameHdl^^);
      CloseCat (err, devHdl);          { Creates the vol entry }
      IF err <> 0
        THEN BEGIN
          IF fTstTF THEN
            WRITELN('Catalog for ', devName, ' not properly closed: err = ', err);
          IF err > 0 THEN EXIT(IFUnMount);
         END;
      IF fTstTF THEN
        WRITELN('IFUnMount - Catalog closed for dev:', devName, ' err:', err:5);
     END
    ELSE IF fTstTF THEN WRITELN('unMounting nilObject, err=', err);

END;


PROCEDURE DumpBoot;
CONST devErr = 19001;
VAR saveBVol: TentryHdl;
BEGIN
  WRITELN('Preparing to re-write the boot catalog - please confirm.');
  IF GetYorN
   THEN BEGIN
     saveBVol := bootVol;  { Cant usually flush the bootVol, so hide it }
     bootVol := NIL;
     FlushObject(computeObj);
     FlushObject(scrapObject);
     FlushObject(trashObject);
     { not in A2 -gb FlushObject(printerObj); }
     FlushCat(saveBVol);
     bootVol := saveBVol;
    END;
END;


PROCEDURE BootMount;
{ This replaces InitVolCtrl -gb }
CONST
   catDBName      = '{!TFCATALOG}'; { name of catalog }
VAR
    bootDev:     TentryHdl;
    devName:     FMaxStr;
    fileName:    Pathname;
    err:         INTEGER;

BEGIN
  IF fTstTF THEN WRITELN('BootMount');
  scrapTool := 0;

  bootDev := NIL;
  devName := 'BOOT';
  REPEAT
    GetEntry (dev, NIL, bootDev, nilField, bootDev);
    IF bootDev = NIL THEN SysErr(916, nullErr);
    UNTIL (bootDev^^.nameHdl^^ = devName);

  IF fTstTF THEN
    WRITELN ('   Opening catalog on device ', bootDev^^.nameHdl^^);

  catVolName := imVolName;  { Save catalog vol name in filer global }
  fileName := CONCAT('-', catVolName, '-',devName, catDBname);
  KILL_OBJECT(err, filename);
  IF fTstTF THEN WRITELN('Kill prev catalog err = ', err);
  CreateCat (err, bootDev);                  { Creates the bootvol entry}

  IF err <> 0
  THEN BEGIN
    WRITELN('Boot vol not opened properly: err = ', err);
    IF CautionAlert (flrAlert, 247)        { 'Boot disk is broken...          }
    THEN BEGIN
      ParamAlert (bootDev^^.userNmHdl^^,'','');
      WaitAlert (flralert, 221);
      upTime := Time;
      { build a new boot disk catalog }
      RemoveAlert;
      END;
   END;

  IF fTstTF THEN WRITELN ('   boot vol catalog opened: err=', err);
  bootVol := bootDev^^.volHdl;
  bootVol^^.volState := sMounted;

  IF fTstTF THEN
    WRITELN('Catalog opened for dev:', devName, ' err:', err:5);
END;


PROCEDURE SwapCat(VAR err: INTEGER; catFile, devName: FmaxStrPtr; fSave: BOOLEAN);
CONST devErr = 19001;
VAR field: TfieldVar;
    devHdl: TentryHdl;
BEGIN
  IF fTstTF THEN
    WRITELN('SwapCat catFile=',catFile^,' devName=', devName^,' fSave: ',fSave);
  devHdl := NIL;
  REPEAT
    GetEntry (dev, NIL, devHdl, nilField, devHdl);
    IF devHdl = NIL
      THEN BEGIN
        WRITELN('Cant find device entry for device: ', devName^);
        err := devErr;
        EXIT(SwapCat);
       END;
    UNTIL (devHdl^^.nameHdl^^ = devName^);

  IF fSave
    THEN BEGIN
      CloseCat(err, devHdl^^.volHdl);
      IF fTstTF THEN
        WRITELN('Catalog closed  err:', err:5, ' for dev: ', devName^);
      IF err > 0 THEN EXIT(SwapCat);
      SaveCat(err, catFile^, devHdl);
      IF fTstTF THEN
        WRITELN('Catalog saved  err:', err:5, ' for dev: ', devName^);
      OpenCat(err, devHdl);
      IF fTstTF THEN
        WRITELN('Catalog opened  err:', err:5, ' for dev: ', devName^);
      IF err > 0 THEN EXIT(SwapCat);
     END
    ELSE BEGIN
      IFUnMount(err, devName^);
      IF fTstTF THEN
        WRITELN('Device unmounted err:', err:5, ' for dev: ', devName^);
      IF err > 0 THEN EXIT(SwapCat);
      RestoreCat(err, catFile^, devHdl);
      IF fTstTF THEN
        WRITELN('Catalog restored for dev: ', devName^, ' from file: ',
            catFile^, ' err:', err:5);
      IF err > 0 THEN EXIT(SwapCat);
      IFMount(err, devName^);
      IF fTstTF THEN
        WRITELN('Device mounted err:', err:5, ' for dev: ', devName^);
      IF err > 0 THEN EXIT(SwapCat);
     END;
END;


PROCEDURE IFDrawDesk;
BEGIN
  IF fTstTF THEN WRITELN('IFDrawDesk');
    IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFDrawDesk');
  SetHeap(flrHeap);
  UpdateObject(deskObject, TRUE);
END;


PROCEDURE IFDrawInsides;
VAR hObj: ObjectHandle;
BEGIN
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFDrawInsides');
  SetHeap(flrHeap);
  hObj := ObjFromWindow(window);
  IF fTstTF THEN WRITELN('IFDrawInsides "', hObj^^.name, '"');
  IF hObj <> NIL THEN DrawInsides(hObj);
END;


FUNCTION  IFSaveCat;  { (devName, catFName: FmaxStrPtr): TC; }
VAR err: INTEGER;
    diskObj: ObjectHandle;
    fOK: BOOLEAN;
BEGIN
  IF fTstTF THEN WRITELN('IFSaveCat  devName=', devName^, ' catFName=', catFName^);
CASE devName^[1] OF
   'B': BEGIN DumpBoot; EXIT(IFSaveCat); END;
   'U': diskObj := floppy1Object;
   'L': diskObj := floppy2Object;
   'P': diskObj := hardDiskObject;
   OTHERWISE diskObj := nilObject;
   END;
  IF diskObj <>  nilObject
    THEN BEGIN
      fOK := CleanupDisk(diskObj);  { still needed??? -a2}
      IF fTstTF THEN WRITELN('IFSaveCat - CleanupDisk returns: ', fOK);
      SwapCat(err, catFName, devName, TRUE);
      IF fTstTF THEN
        WRITELN('Catalog saved for dev:', devName^, ' err:', err:5);
      IF sDebug THEN BEGIN
        IF err <> 0 THEN  WRITELN('Catalog not saved. Error: ', err);
       END;
     END
    ELSE BEGIN
      WRITELN('SaveCat - No disk mounted on specified device');
      err := 1;
     END;

  IFSaveCat := err;
END;


FUNCTION IFLoadCat;  { (devName, catFName: FmaxStrPtr): TC; }
VAR err: INTEGER;
BEGIN
  IF fTstTF THEN WRITELN('IFLoadCat  devName=', devName^, ' catFName=', catFName^);
  SwapCat(err, catFName, devName, FALSE);
  IF fTstTF THEN
    WRITELN('Catalog loaded for dev:', devName^, ' err:', err:5);
  IF sDebug THEN BEGIN
    IF err <> 0 THEN  WRITELN('Catalog not loaded. Error: ', err);
   END;
   IF err = 873 THEN
    BEGIN  { this is a major kludge, why 873 anyway?? but doing again is fix -gb}
      RestoreCat(err, catFName^, GetDvHndl(devName^));
      {IF fTstTF THEN}
        WRITELN('IFLoadCat Kludge - Catalog restored for dev: ', devName^, ' from file: ',
            catFName^, ' err:', err:5);
      IF err > 0 THEN EXIT(IFLoadCat);
      IFMount(err, devName^);
      {IF fTstTF THEN}
        WRITELN('IFLoadCat Kludge - Device mounted err:', err:5, ' for dev: ', devName^);
      IF err > 0 THEN EXIT(IFLoadCat);
     END;
  IFLoadCat := err;
END;



FUNCTION nextObjSer: TC;
BEGIN
  objSerCount := objSerCount+1;
  nextObjSer := objSerCount;
END;


PROCEDURE IFInit;  { (fMenus: Pathname); }
{ changed code -gb }
VAR i: INTEGER;
    fOK: TF;
BEGIN
  IF fTstTF THEN WRITELN('Entering IFInit');

  objSerCount := 0;
  filerMenus := fMenus;
  doDslAll := FALSE;
  trashObject := nilObject;
  scrapObject := nilObject;
  printerObj := nilObject;
  computeObj := nilObject;

  Initialize;

  flrHeap := theHeap;
  rnmObjIdx := CNilObjIdx;
  rnmName := '';
  hKindTable := CreateSrchTable(SIZEOF(TKindRec), deskKind+1, 3);
  AddKindRec('nilKind', 0);
  AddKindRec('fileKind', 1);
  AddKindRec('drawerKind', 2);
  AddKindRec('folderkind', 3);
  AddKindRec('docKind', 4);
  AddKindRec('docPad', 5);
  AddKindRec('trashKind', 6);
  AddKindRec('printKind', 7);
  AddKindRec('calcKind', 8);
  AddKindRec('trayKind', 9);
  AddKindRec('computerKind', 10);
  AddKindRec('wpDocKind', 11);
  AddKindRec('bgDocKind', 12);
  AddKindRec('lcDocKind', 13);
  AddKindRec('geDocKind', 14);
  AddKindRec('lmDocKind', 15);
  AddKindRec('folderPad', 16);
  AddKindRec('scrapKind', 17);
  AddKindRec('scrap2Kind', 18);
  AddKindRec('clockKind', 19);
  AddKindRec('lanternKind', 20);
  AddKindRec('toolBoxKind', 21);
  AddKindRec('houseKind', 22);
  AddKindRec('bookKind', 23);
  AddKindRec('toolKind', 24);
  AddKindRec('diskKind', 25);
  AddKindRec('disk1Kind', 26);
  AddKindRec('disk2Kind', 27);
  AddKindRec('profileKind', 28);
  AddKindRec('imKind', 29);
  AddKindRec('deskKind', 30);

  { ?? imSet:=[imKind,imScrKind,scrapKind]; }
END;


FUNCTION CountObjects(obj : ObjectHandle): TC;
VAR objCt: TC;
    son, brothers: ObjectHandle;
BEGIN
  objCt := 1;
  IF obj = nilObject
    THEN BEGIN
      CountObjects := 0;
      EXIT(CountObjects);
     END;
  objCt := 1;
  brothers := obj^^.contents;
  son := brothers^^.next;
  WHILE son <> brothers DO   { travel down brother list }
    BEGIN
        { check contents (brothers) }
    IF son^^.state <> placeHolder
      THEN objCt := objCt + CountObjects(son);
    son:=son^^.next;
    END;
  CountObjects := objCt;
END;


PROCEDURE LCName; {(VAR s: TStr40);}
{ converts all upper case chars in "s" to lower case }
VAR i: INTEGER;
BEGIN
FOR i := 1 TO LENGTH(s) DO
   IF (s[i] <= 'Z') THEN
      IF (s[i] >= 'A') THEN s[i] := CHR(ORD(s[i]) + 32);
END;


FUNCTION  NewObjIdx(ObjTbl: ThObjTable; hObj: ObjectHandle;
                    prevIdx, fatIdx: TC): TC;
  { this function is for adding a new object to an object table  -gb }
VAR pto: TPAObj;
    thisIdx: TC;
BEGIN
  IF hObj = nilObject
    THEN BEGIN
      NewObjIdx := CNilObjIdx;
    END
    ELSE BEGIN
      pto := POINTER(ORD(NewSrchTableRec(ObjTbl, thisIdx)));
      IF fTstTF THEN
        WRITELN('NewTableObj:', thisIdx:5, ' named: ', hObj^^.name,
                ' at: ', ORD(hOBj));
      WITH pto^ DO WITH hObj^^ DO BEGIN
        toName := name;
        toLoc := loc;
        toKind := ORD(kind);
        toSubKind := ORD(subKind);
        toState := ORD(state);
        toNext := CNilObjIdx;
        toPrev := prevIdx;
        toFather := fatIdx;
        toSons := CNilObjIdx;
        toVol  := POINTER(ORD(volHdl));
        toCatId := catRID.uniqueId;
        NewObjIdx := thisIdx;
       END;
    END;
END;


FUNCTION  BldObjIdx(ObjTbl: ThObjTable; hObj:
                    ObjectHandle; prevIdx, fatIdx: TC): TC;
  { this function is for adding a new object to an object table  -gb }
VAR pto: TPAObj;
    thisIdx, sonIdx, nxtIdx: TC;
BEGIN
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - BldObjIdx');
  SetHeap(flrHeap);
  IF hObj^^.kind = nilKind
    THEN BEGIN
      BldObjIdx := CNilObjIdx;
      EXIT(BldObjIdx);
    END;
  IF hObj^^.state = placeHolder
    THEN thisIdx :=  CNilObjIdx
    ELSE thisIdx := NewObjIdx(ObjTbl, hObj, prevIdx, fatIdx);
  sonIdx := BldObjIdx(ObjTbl, hObj^^.contents^^.next, CNilObjIdx, thisIdx);
  nxtIdx := BldObjIdx(ObjTbl, hObj^^.next, thisIdx, fatIdx);
  IF thisIdx <> CNilObjIdx
    THEN BEGIN
      pto := POINTER(ORD(NthSrchTableRec(ObjTbl, thisIdx)));
      pto^.toNext := nxtIdx;
      pto^.toSons := sonIdx;
     END;
  BldObjIdx := thisIdx;
END;


FUNCTION  AddObjIdx(ObjTbl: ThObjTable; hObj:
                    ObjectHandle; prevIdx, fatIdx: TC): TC;
  { this function is for adding a new object to an object table  -gb }
VAR pto: TPAObj;
    thisIdx, sonIdx, nxtIdx: TC;
BEGIN
  IF fTstTF THEN WRITELN('AddObjIdx  objName=', hObj^^.name, ' ', ORD(hObj));
  IF hObj^^.kind = nilKind
    THEN BEGIN
      AddObjIdx := CNilObjIdx;
      EXIT(AddObjIdx);
    END;
  thisIdx := NewObjIdx(ObjTbl, hObj, prevIdx, fatIdx);
  nxtIdx := GetObjIdx(ObjTbl, hObj^^.next);
  pto := POINTER(ORD(NthSrchTableRec(ObjTbl, thisIdx)));
  pto^.toNext := nxtIdx;
  sonIdx := GetObjIdx(ObjTbl, hObj^^.contents^^.next);
  pto^.toSons := sonIdx;
  AddObjIdx := thisIdx;
END;


FUNCTION  BldObjTable;  { (obj: ObjectHandle): ThObjTable;  }
VAR oTable: ThObjTable;
    objCt, objIdx: TC;
BEGIN
  IF fTstTF THEN WRITELN('BldObjTable  objName=', obj^^.name, ' ', ORD(obj));
  objCt := CountObjects(deskObject);
  oTable := CreateSrchTable(SIZEOF(TAObj), objCt, 3);
  objIdx := BldObjIdx(oTable, obj, CNilObjIdx, CNilObjIdx);
  IF fTstTF THEN
      WRITELN('Created top level table obj', objIdx,
              ' for obj called: ', obj^^.name);
  BldObjTable := oTable;
END;

FUNCTION  GetObjIdx; { (ot: THObjTable; hObj: ObjectHandle): TC; }
LABEL 900;
VAR recPos: TPAObj;
    i, oIdx, recSize, prevIdx, fatIdx: TC;
    oVol, oId: TL;
BEGIN
  IF ot  =  NIL THEN BEGIN GetObjIdx := CNilObjIdx; EXIT(GetObjIdx); END;
  IF hObj = NIL THEN BEGIN GetObjIdx := CNilObjIdx; EXIT(GetObjIdx); END;
  IF hObj^^.kind = nilKind
                THEN BEGIN GetObjIdx := CNilObjIdx; EXIT(GetObjIdx); END;
  IF hObj^^.state = placeHolder
                THEN BEGIN GetObjIdx := CNilObjIdx; EXIT(GetObjIdx); END;
  recPos := POINTER(ORD(ot^) + SIZEOF(TSrchTable)); { first rec pos }
  recSize := ot^^.stRecSize;
  oVol := ORD(hObj^^.volHdl);
  oId := hObj^^.catRID.uniqueId;
  IF fTstTF THEN WRITELN('GetObjIdx: ', hObj^^.name);
  FOR i := 0 TO ot^^.stNRecs - 1 DO
    BEGIN
      IF recPos^.toCatId = oId
       THEN IF ORD(recPos^.toVol) = oVol
        THEN IF recPos^.toName = hObj^^.name  { check in case of renames }
         THEN BEGIN
           oIdx := i + 1;
           IF fTstTF THEN
             WRITELN(' found obj: ',  oIdx:4, ' named ', recPos^.toName);
           GOTO 900;
          END;
      recPos := POINTER(ORD(recPos) + recSize);
    END;
  IF fTstTF THEN WRITELN('  Adding new obj to obj table');
  prevIdx := GetObjIdx(ot, hObj^^.prev);
  fatIdx := GetObjIdx(ot, hObj^^.container);
  oIdx := AddObjIdx(ot, hObj, prevIdx, fatIdx);
900:
  GetObjIdx := oIdx;
END;


FUNCTION  TstName(objName, chkName: TPStr255): TF;
LABEL 900;
VAR i: TC;
    ch: CHAR;
BEGIN
  IF LENGTH(objName^) <> LENGTH(chkName^) THEN GOTO 900;
  FOR i := 1 TO LENGTH(objName^) DO
    BEGIN
      ch := objName^[i];
      IF ch <> chkName^[i]
        THEN BEGIN   { elaborate letter by letter case independence test }
          IF ch <= 'Z'
            THEN BEGIN
              IF ch < 'A' THEN GOTO 900;
              IF ORD(ch)+32 <> ORD(chkName^[i]) THEN GOTO 900;
             END
            ELSE BEGIN
              IF ch < 'a' THEN GOTO 900;
              IF ch > 'z' THEN GOTO 900;
              IF ORD(ch)-32 <> ORD(chkName^[i]) THEN GOTO 900;
            END;
         END;
    END;
  TstName := TRUE;
  EXIT(TstName);
900:
  TstName := FALSE;
END;


FUNCTION  NamedObjIdx; { (ot: THObjTable; VAR objName: TStr40): TC; }
VAR recPos: TPAObj;
    i, oIdx, recSize: TC;
    objCTIme: TL;
    gotOne: TF;
BEGIN
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - NamedObjIdx');
  SetHeap(flrHeap);
  IF ot  =  NIL THEN BEGIN NamedObjIdx := CNilObjIdx; EXIT(NamedObjIdx); END;
  oIdx := CNilObjIdx;
  objCTime := -1;
  gotOne := FALSE;
  recPos := POINTER(ORD(ot^) + SIZEOF(TSrchTable)); { first rec pos }
  recSize := ot^^.stRecSize;
  IF fTstTF THEN WRITELN('NamedObjIdx: ', objName);
  FOR i := 0 TO ot^^.stNRecs - 1 DO
    BEGIN
      IF TstName(@recPos^.toName, @objName)
        THEN BEGIN
 IF fTstTF THEN
    WRITELN('found named obj', i+1:3, ' named "', objName, '"', recPos^.toCTime);
          IF (NOT gotOne) OR (recPos^.toCTime > objCTime)
            THEN BEGIN
              gotOne := TRUE;
              oIdx := i + 1;
              objCTime := recPos^.toCTime;
             END;
          END;
      recPos := POINTER(ORD(recPos) + recSize);
    END;
  IF fTstTF THEN WRITELN(' found obj: ',  oIdx:4);
  NamedObjIdx := oIdx;
END;


PROCEDURE SetValidObject(obj: ObjectHandle; good: TF);
BEGIN
  WITH obj^^ DO
    IF container^^.isOpen THEN
      IF (loc.h < 10000) AND (loc.h > -10000) AND
         (loc.v < 10000) AND (loc.v > -10000)
        THEN ValidObj(obj, good)
        ELSE BEGIN
          IF fTstTF OR cDebug THEN
            WRITELN('SetValidObject - obj "', name, '" out of range ', loc.h, loc.v);
          HoldIt(cDebug);
         END;
END;


FUNCTION  IFMakeObj;  { (obName: FmaxStr; kind, subKind: ObjectKind;
                      father: ObjectHandle; loc: Point;
                      hFldr: THFldrInfo; r: Rect): ObjectHandle;  }
VAR obj: ObjectHandle;
    err: TC;
    catRID: TcatRID;
    catRec: TcatRec;
    dstr,tstr: STRING10;
    ri: TC;
BEGIN
  IF fTstTF THEN WRITELN('IFMakeObj  obName=', obName, ' kind=', ORD(kind));
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFMakeObj');
  SetHeap(flrHeap);
WITH catRec DO
   BEGIN
   parentID := father^^.catRID.uniqueID;
   selfID   := -1;
   objKind  := kind;
   InsObjName(catRec,'Diskette');
   toolId   := 0;

   objSize  := 0;
   objSize  := RandInt(10, 400);
created := TimeStamp;
TimeToStr(created, dstr, tstr);
IF IMtst THEN
WRITELN('IFMakeObj created obj "', obName, '" size:',
         objSize, ' ', dstr, ' ', tstr);

   created := 3600;  { seconds in an hour }
   ri := RandInt(0, 8760); { hours within a year before now }
   created := created * ri; { hours within a year before now }
   created := TimeStamp - created; { make reasonable but bogus }
TimeToStr(created, dstr, tstr);
IF IMtst THEN
WRITELN('  created:', created, ' ri=', ri, ' date=', dstr, ' time=', tstr);

   modified := 3600;  { seconds in an hour }
   modified := modified * RandInt(0, 4380); { hours within 1/2 year before now }
   modified := TimeStamp - modified; { dates and size }
TimeToStr(modified, dstr, tstr);
IF IMtst THEN
WRITELN('  modified:', modified, ' ri=', ri, ' date=', dstr, ' time=', tstr);

   IF modified < created THEN modified := created;
   objState := 0;
   IF fTstTF THEN WRITELN('IFMade obj "', obName, '" times:', created,
                        ', ', modified, ', ', objSize);
   closedPt := loc;
   openRect := r;
   InsObjName(catRec, obName);
   toolId := imTool;
   selfID  := imKind;
   AddCatRec(err,bootVol,catRec,TRUE,catRID);
  END;
  IF err <> 0
    {THEN IF sDebug }
     THEN BEGIN
      WRITELN('IFMakeObj: err adding cat rec:', err);
      IFMakeObj := NIL;
     END;
  IF fTstTF THEN
     WRITELN('IFMakeObj created obj "', obName, '" with catRID fatherID:',
             catRID.fatherID, ' uniqueID:', catRID.uniqueID);

  WITH catRec DO
    obj:=MakeObject(father, obName, kind, subKind,loc, r, normal, bootVol,
                    catRID, created, modified, objSize, FALSE);
  obj^^.imFldr := hFldr;
  IF hFldr <> NIL THEN BEGIN
     hFldr^^.fldrFObj := POINTER(ORD(obj));
     obj^^.objWindow := hFldr^^.fldrPort;
    END;
  IF obj^^.container^^.isOpen
    THEN BEGIN
      SetPort(obj^^.container^^.objWindow);
      SetValidObject(obj, FALSE);
      DrawObject(obj);
     END;
  IFMakeObj := obj;
END;


FUNCTION IFMakeFolder; {
           (fname: TKeyStr; fKind, fsubKind: ObjectKind;
            opnRect: Rect; clsLoc: Point;
            fVis, fwindow, fSBars: TF;
            behindWind: WindowPtr): THFldrInfo; }
   { builds a new IMFolder and a Filer Object and links them together }
   { If behindWind is Nil folder is a bottom.                         }
   { If behindWind is filerFolder then new folder is at top.          }
VAR fport: WindowPtr;
    newFldr: THFldrInfo;
    newObj: ObjectHandle;
BEGIN
  IF fTstFldrs THEN WRITELN('IFMakeFolder creating ', fname, ' folder port.');
  fport := NewFolder(opnRect, fName, FALSE, behindWind,
                     fldrCount, My_ID, otherSymbol, noIcon);
  newFldr := BuildIMFolder(fName, fVis, fWindow, fSBars, fport);
  newObj := IFMakeObj(fname, fKind, fSubKind, deskObject,
                      clsLoc, newFldr, opnRect);
  IF fVis THEN IFOpenObj(newObj);
  newFldr^^.fldrFObj := POINTER(ORD(newObj));
  IFMakeFolder := newFldr;
  { IFDrawDesk; bet we dont need this }
END;


FUNCTION AsideObject(obj: ObjectHandle; sonsAlso: BOOLEAN): BOOLEAN; FORWARD;

FUNCTION AsideContents(obj: ObjectHandle): BOOLEAN;
{ copied from close contents }

VAR son,nextSon,listHead : ObjectHandle;
BEGIN
IF trcFiler OR fTstTF THEN WRITELN('AsideContents "',obj^^.name,'"');
listHead:=obj^^.contents;
son:=listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   IF Abort THEN EXIT(AsideContents);
   nextSon := son^^.next;
   IF NOT AsideObject(son,TRUE {sons also}) THEN
      BEGIN
      AsideContents := FALSE;
      EXIT(AsideContents);
      END;
   son := nextSon;
   END;
AsideContents := TRUE;
END;


FUNCTION AsideObject{* obj: ObjectHandle; sonsAlso: BOOLEAN): BOOLEAN *};
{  this was cloned off of CloseObject }

VAR deskLoc: Point;
BEGIN
IF trcFiler OR fTstTF THEN WRITELN('AsideObject "',obj^^.name,'"');

IF sonsAlso THEN IF AsideContents(obj) THEN;

IF NOT obj^^.isOpen THEN
   BEGIN
     AsideObject := TRUE;
     EXIT(AsideObject);
   END;

IF (obj^^.container <> deskObject)
  THEN BEGIN
    ChoosePos(deskObject, deskLoc);
    UnfileObject(obj, deskLoc);
   END;
AsideObject := CloseObject(obj, FALSE, FALSE, FALSE);
END;


PROCEDURE BringBackContents(obj: ObjectHandle);
VAR son,nextSon,realSon,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('BringBackContents "',obj^^.name,'"');
listHead:=obj^^.contents;
son:=listHead^^.next;

WHILE son <> listHead DO
   BEGIN
   IF Abort THEN EXIT(BringBackContents);
   nextSon:=son^^.next;
   IF son^^.state =  placeHolder
     THEN BEGIN
       realSon := SearchContents(deskObject, obj^^.volHdl,
                                 son^^.catRID.uniqueID, FALSE);
       IF fTstTF THEN WRITELN('Bringing back object "', realSon^^.name, '"');
       IF realSon <> nilObject
         THEN IF NOT PutBackObject(realSon,TRUE,FALSE)
           THEN  IF fTstTF THEN
             WRITELN('Cant bring back object "', realSon^^.name, '"');
      END
     ELSE IF IsContainer(obj) THEN BringBackContents(son);
   son:=nextSon;
   END;
END;


PROCEDURE IFKillObj;  { (hObj : ObjectHandle); }
   { this is a modified version of KillContetnts }
VAR catRID: TcatRID;
    objVol: TentryHdl;
    pObj: ObjectHandle;
BEGIN
  IF fTstTF THEN WRITELN('IFKillObj  "', hObj^^.name, '" ', ORD(hObj));
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFKillObj');
  SetHeap(flrHeap);
 { ??  KillIMFldr(hObj);  }
  IF hObj = nilObject THEN EXIT(IFKillObj);
  IF hObj = activeObject
    THEN BEGIN
      MakeFldrActive(filerFolder, nilUserData);
      activeWSLink := NIL;  { stops cursor check routine }
     END;
  IF NOT hObj^^.isFiled THEN IF PutBackObject(hObj, TRUE, FALSE) THEN;
  IF isContainer(hObj) THEN BringBackContents(hObj);
  catRID := hObj^^.catRID;
  objVol := hObj^^.volHdl;
  KillObject(hObj, TRUE, TRUE);
  ShredObject(objVol, catRID);
END;


PROCEDURE IFKillXtras; { (obj: ObjectHandle); }
VAR son, nxtson, brothers: ObjectHandle;
BEGIN
  IF obj = nilObject
    THEN BEGIN
      EXIT(IFKillXtras);
     END;
  IF fTstTF THEN WRITELN('IFKillXtras  "', obj^^.name, '" ', ORD(obj));
  brothers := obj^^.contents;
  son := brothers^^.next;
  WHILE son <> brothers DO   { travel down brother list }
    BEGIN
    nxtson:=son^^.next;
    IF son^^.state = placeHolder THEN BEGIN {skip it } END
    ELSE IF
       (FindSrchTableRec(hODefTable, son^^.name) <> NIL)
     THEN BEGIN
         IF GetNameObj(son^^.name, TRUE) = son
            THEN IFKillXtras(son)
            ELSE IFKillObj(son);  { kill duplicates }
       END
     ELSE IF
       (son = deskObject) OR
       (son = trashObject) OR
       (son = scrapObject) OR
       (son = computeObj)
      THEN IFKillXtras(son) { kill extraneous sons }
      ELSE WITH son^^ DO
        IF son^^.imFldr = NIL
          THEN IFKillObj(son) { extraneous obj - kill it and its sons }
          ELSE IF ((son^^.imFldr = hndLGFldr) OR
                   (son^^.imFldr = hndScriptFldr) OR
                   (son^^.imFldr = hndAlertFldr) OR
                   (son^^.imFldr = hndActiveFldr))
                 THEN IFKillXtras(son) { kill extraneous sons }
                 ELSE IFKillObj(son);  { extraneous obj - kill it and its sons }
    son:=nxtson;
    END;
END;


PROCEDURE  IFCloseObj;  { (obj : ObjectHandle; closeSons: BOOLEAN); }
VAR wasClosed: TF;
BEGIN
  IF fTstTF THEN WRITELN('IFCloseObj "', obj^^.name, '" ', ORD(obj));
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFCloseObj');
  SetHeap(flrHeap);
  WasClosed := CloseObject(obj, closeSons, FALSE, FALSE);
END;


PROCEDURE  IFCloseContents; { (obj : ObjectHandle; closeIM: BOOLEAN); }
VAR wasClosed: TF;
BEGIN
  IF fTstTF THEN WRITELN('IFCloseContents "', obj^^.name, '" ', ORD(obj));
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFCloseContents');
  SetHeap(flrHeap);
  WasClosed := CloseContents(obj, FALSE, FALSE);
END;


PROCEDURE IFTearOffObj;  {  (obj : ObjectHandle);  }
VAR r: Rect;
    WasOpened: TF;
BEGIN
  IF fTstTF THEN WRITELN('IFTearOffObj  "', obj^^.name, '" ', ORD(obj));
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFTearOffObj');
  SetHeap(flrHeap);
  WasOpened := TearOffObject(obj);
END;


FUNCTION CmdOpenObject(obj: ObjectHandle; windRect: Rect;
                      startTool: BOOLEAN): BOOLEAN;
{ this is a copy of OpenObject - without the BringToFront for use by IM -gb }
{ Creates a window for the object (if necessary) and displays contents }
{ Changes the icon to indicate that the object is open }

VAR title: FmaxStr;
    docHdl: TentryHdl;
    window: WindowPtr;
    deskLoc: Point;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('CmdOpenObject "',obj^^.name,'"  kind = ',obj^^.kind:1);

IF obj^^.isOpen THEN
   BEGIN
   CmdOpenObject := TRUE;   { It's already open }
   EXIT(CmdOpenObject);
   END;

IF obj = nilObject THEN
   BEGIN
   CmdOpenObject := FALSE;  { This is probably an error? }
   EXIT(CmdOpenObject);
   END;

IF FALSE {obj^^.kind IN docToolSet} THEN
   IF obj^^.container <> deskObject THEN
      BEGIN  { docs & tools are automatically unfiled when opened from container }
      ChoosePos(deskObject,deskLoc);
      UnfileObject(obj,deskLoc);
      END;

{ check that window rect is on screen }
WITH windRect DO
  IF (top < titleHt) OR (top > screenHt) OR ((bottom - top) > screenHt) OR
     (left > screenWidth) OR (right < 1) THEN
     BEGIN
     WRITELN('CmdOpenObject invalid window rect - ',left,top,right,bottom);
     SetRect(windRect,40,40,600,300);
     END;

obj^^.windowRect := windRect;

{ Get the title.  Chooses title if icon title is empty }
GetWndTitle(obj,title);

{ Set up the window, but don't display it yet }
window := obj^^.objWindow;
IF window = NIL THEN
   BEGIN              { need to create a window }
 { window := NewWindow(obj,title); replaced so window is not in front -gb }
   window:= NewFolder(obj^^.windowRect,title,FALSE ,activeFolder,0,My_Id,
                   CloseSymbol(obj^^.kind), noIcon);
   IF window = NIL THEN StopAlert (flrAlert, 206);  { Too many windows }
   obj^^.objWindow := window;
   obj^^.hThumbPos := 0;
   obj^^.vThumbPos := 0;  {*** should remember scroll position ***}
   IF window = NIL THEN
      BEGIN
      CmdOpenObject := FALSE;   { can't open any more windows, abort the operation }
      EXIT(CmdOpenObject);
      END;
   END
ELSE WITH windRect DO
   BEGIN  { Window already exists.  Adjust size and location. }
   MoveFolder(window,left,top);
   FolderSize(window,right-left,bottom-top,FALSE);
   { removed -gb -- BringToFront(Pointer(ORD(window)),TRUE); }
   END;

WITH obj^^ DO
   BEGIN
   isOpen:=TRUE;
   dirty:=TRUE;
   state:=hidden;
   END;

DrawObject(obj);       { redraw object as a ghost }
ZoomObject(obj,TRUE);  { zoom up }
ShowFolder(window);    { display the window, generates update event for window }

IF obj^^.kind IN docToolSet THEN
   BEGIN
{$IFC R}
   FlushObject(obj);                { ensure that catalog is current }
   IF obj^^.wasOpened THEN          { reattempt startup if orphan }
      ResumeDocs(obj^^.objWindow)
   ELSE                             { never opened, try starting it up }
      OpenDoc(obj^^.volHdl,obj^^.catRID,window,docHdl,startTool);
{$ELSEC}
      {!!!!GEOFF'S STUFF GOES HERE!!!!}  { ?? whatever -gb}
      IF fTstTF THEN WRITELN('Opened obj in docToolSet: ', obj^^.name);
{$ENDC}
   END
ELSE IF IsContainer(obj) THEN      { Generate an object list for the contents }
   BEGIN
   { not needed for im version. Dont throw away closed obj contents -gb }
   {  IF obj = trashObject
   {  THEN GenTrashContents ELSE GenContents(obj); }
   CheckContents(obj);             { make sure all icon locations are valid }
   SetAttributes(obj);             { set any fields that may have changed }
   ValidWindow(window,TRUE);       { cancel update for window, draw it now }
   DrawInsides(obj);
   END;

OpnObjEvt(obj);
obj^^.wasOpened := TRUE;
CmdOpenObject := TRUE;
END;


PROCEDURE IFOpenObj;  { (obj : ObjectHandle); }
VAR r: Rect;
    WasOpened: TF;
BEGIN
  IF fTstTF THEN WRITELN('IFOpenObj "', obj^^.name, '" ', ORD(obj));
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFOpenObj');
  SetHeap(flrHeap);
  GetWindRect(obj,r);
  WasOpened := CmdOpenObject(obj,r,FALSE);
END;


PROCEDURE IFMenuCommand;  { (theMenu, theItem: TC); }
BEGIN
  IF fTstTF THEN WRITELN('IFMenuCommand  menu=', theMenu, ' item=', theItem);
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFMenuCommand');
  SetHeap(flrHeap);
  { done in imevtloop now -gb
  { IF fRCommands AND (theItem > 0)
  {  THEN AddCmdRec(curEvtBuf, theMenu, theItem, FALSE); }
  MenuCommand(theMenu, theItem);
END;

PROCEDURE IFBtnUp;
BEGIN
{ use to measure multiple clicks }
clickTime := curEvent.when+clickDelay
END;

PROCEDURE IFAdjustMenus;
BEGIN
  AdjustMenus;
END;

PROCEDURE IFButtonDown;
VAR dh,dv: INTEGER;
    theMenu,theItem: INTEGER;
    whichSb: THsb;
    whichIcon: TIcon;
BEGIN
  IF fTstTF THEN WRITE('IFButtonDown   (entering clikcCount=', clickCount:3, ')');
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFButtonDown');
  SetHeap(flrHeap);
  { below taken from process the event }
      dh := ABS(curEvent.where.h-clickLoc.h);
      dv := ABS(curEvent.where.v-clickLoc.v);
      IF (curEvent.when < clickTime) AND (dh <= 6) AND (dv <= 4) THEN
         clickCount := clickCount+1
      ELSE
         clickCount:=1;
      IF fTstTF THEN WRITELN('  clickCount set to ', clickCount);
      clickLoc := curEvent.where;

{      IF curEvent.who = menuFolder THEN
{         BEGIN
{         KillDuplicates(activeObject);               { abort copy mode }
{         AdjustMenus;                                { enable/disable }
{         MenuSelect(curEvent.where,theMenu,theItem); { find which one }
{         IFMenuCommand(theMenu,theItem);             { do the job }
{         HiLiteMenu(0);  { un-highlight the menu title }
{         END
{
{      ELSE }

      IF curEvent.who = dialogFolder THEN
         BEGIN
         END

      ELSE IF curEvent.who = alertFolder THEN
         BEGIN
         END

      ELSE IF (activeObject <> deskObject) AND FGrowHit(curEvent.where) THEN
         GrowWindow(activeObject,curEvent.where)

      ELSE IF (activeObject <> deskObject) AND
              FSbHit(sbList,curEvent.where,whichSb,whichIcon) THEN
         HitScrollBar(activeObject,whichSb,whichIcon)

      ELSE IF IsContainer(activeObject) THEN
         HitContainer(activeObject)

      ELSE IF curEvent.who = scrapFolder THEN
         BEGIN
         END

      ELSE  { this shouldnt be called anymore -gb }
         BEGIN
         WRITELN('Hit orphan - shouldnt happen');
         HoldIt(TRUE);  { my stuff -gb }
         orphanHit := curEvent.who;   { call HitOrphan on this when active }
         MakeFldrActive(filerFolder,whyHitOrphan);  { send activate to self }
         END;
END;


PROCEDURE IFCommandKey;
BEGIN
  IF fTstTF THEN WRITELN('IFCommandKey ');
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFCommandKey');
  SetHeap(flrHeap);
  CommandKey;
END;


PROCEDURE IFTextKey;
BEGIN
  IF fTstTF THEN WRITELN('IFTextKey ');
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFTextKey');
  SetHeap(flrHeap);
  TextKey;
END;

PROCEDURE IFDeActivate;
BEGIN   { deselect any selected objects }
  IF fTstTF THEN WRITELN('IFDeActivate "', activeObject^^.name, '"');
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFDeActivate');
  SetHeap(flrHeap);
      KillDuplicates(activeObject);  { Abort copy mode }
         { deselect any selected objects }
      IF curEvent.who <> curEvent.fromFolder THEN  { new active <> old active }
         BEGIN
         IF editObject^^.container = activeObject THEN EndEdit;
         SetDeSelAll;  { causes a deSelect all event if any selected -gb }
         ChangeContents(activeObject,hilited,normal,0,0,TRUE);
         END;
      HideScroll(activeObject);
      activeObject:=nilObject;
      {IF wantCheckHeap THEN CheckHeap('ProcessTheEvent - before GiveControl');
      {GiveControl(curEvent);
      {IF wantCheckHeap THEN CheckHeap('ProcessTheEvent - after GiveControl');}
END;


PROCEDURE IFInsertMenu(menId, b4Id: INTEGER);
VAR menuInf: THMenuDInf;
BEGIN
  menuInf := GetIDMenu(menId);
  IF (menuInf = NIL)
    THEN InsertMenu(flrMenus[menId], b4Id)
    ELSE IF menuInf^^.mDispFlag
            THEN IF specialUp
              THEN InsertMenu(flrNameMenus[menId], b4Id)
              ELSE InsertMenu(flrMenus[menId], b4Id);
END;


PROCEDURE IFActivate;
VAR keepMenus: TF;
BEGIN
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFActivate');
  SetHeap(flrHeap);
  keepMenus := (curEvent.fromProcess = filerProcess);
  IF fTstTF THEN WRITELN('IFActivate - keepMenus: ', keepMEnus);
  activeObject:=ObjFromWindow(curEvent.who);
  IF fTstTF THEN WRITELN('IFActivate "', activeObject^^.name, '"');
  {IF NOT keepMenus THEN}
   IF (activeObject^^.imFldr = NIL) OR IsContainer(activeObject)
     THEN InstallMenus;
  ShowScroll(activeObject);
  clickCount := 0; {so activated objects wont immediately be opened }
  HandleWhyActivated(curEvent);
  IF fTstTF THEN
    WRITELN('Activating IF object:', activeObject^^.name,
            ' ', ORD(activeObject));
  ActObjEvt(activeObject);
END;


PROCEDURE IFFolderMove; { (window: WindowPtr); }
VAR hObj: ObjectHandle;
BEGIN
  IF fTstTF THEN WRITELN('IFFolderMove window= ', ORD(window));
  IF fTstTF THEN IF theHeap <> flrHeap
    THEN WRITELN('Resetting the heap to flrHeap - IFFolderMove');
  SetHeap(flrHeap);
  hObj := ObjFromWindow(window);
  IF hObj = nilObject
    THEN BEGIN
      IF fTstTF THEN WRITELN('IFFolderMove for nilObject');
      EXIT(IFFolderMove);
     END;
  AdjWindRect(hObj);   { adjust bottom right }
  MovFldrEvt(hObj);
  WITH window^.portRect DO
    BEGIN
      SetRect(hObj^^.windowRect ,
                 -window^.portBits.bounds.left,
                 -window^.portBits.bounds.top,
                 right-left, bottom-top);
      SetFldrSize(hObj^^.imFldr, right-left, bottom-top, NIL);
      IF (NOT IsContainer(hObj)) OR (hObj^^.imFldr <> NIL)
        THEN DrawScroll(hObj^^.imFldr);
    END;
END;


FUNCTION  IFFindObj;  { (window: WindowPtr; VAR hObj: ObjectHandle): BOOLEAN; }
BEGIN
  IF fTstTF THEN WRITELN('IFFindObj window= ', ORD(window));
  hObj := ObjFromWindow(window);
  IF fTstTF THEN
    IF hObj <> nilObject
      THEN WRITELN('IFFindObj gets: ', hObj^^.name, ' (', ORD(hObj),
                          ') from port: ', ORD(window))
      ELSE WRITELN('IFFindObj gets: nilObject (', ORD(hObj),
                          ') from port: ', ORD(window));
  IFFindObj := hObj <> nilObject;
END;

FUNCTION  GetActObjIdx;  { (VAR objIdx: TC): BOOLEAN; }
BEGIN
  IF fTstTF THEN WRITELN('GetActObjIdx');
  objIdx := GetObjIdx(curObjTable, activeObject);
  GetActObjIdx := objIdx <> CNilObjIdx;
END;

PROCEDURE ExpStk;
VAR dumVar: INTEGER;
    CheatPtr: TP;
BEGIN
  IF fTstTF THEN WRITELN('Expanding heap hack');
  CheatPtr := POINTER(ORD(@dumVar)-4096);
  dumVar := CheatPtr^;
END;


PROCEDURE IFMoveIcon; {  (hObj: ObjectHandle; ix, iy: TC;);  }
BEGIN
  IF fTstTF THEN WRITELN('IFMoveIcon  objName=', hObj^^.name, ' ', ORD(hObj));
  IF (hObj = NIL) OR (hObj = nilObject)
    THEN BEGIN
      IF cDebug THEN WRITELN('Nil obj in IFMoveIcon to: ', ix, iy);
      EXIT(IFMoveIcon);
     END;
  IF hObj^^.container^^.isOpen
    THEN BEGIN
      If fTstTF then
       writeln('Moving icon in open container:', hObj^^.name,
               ' to ', ix:5, iy:5);
      SetPort(hObj^^.container^^.objWindow);
   { ExpStk; }
      SetValidObject(hObj, FALSE);
      SetPt(hObj^^.loc, ix, iy);
      DrawObject(hObj);
     END
    ELSE BEGIN
      SetPt(hObj^^.loc, ix, iy);
      If fTstTF then
       writeln('Moving icon in closed container:', hObj^^.name,
               ' to ', ix:5, iy:5);
     END;
END;


PROCEDURE IFValidIcon; {  (hObj: ObjectHandle; fValid: TF;);  }
BEGIN
  IF fTstTF THEN WRITELN('IFValidIcon  objName=', hObj^^.name, ' ', ORD(hObj));
  IF (hObj = NIL) OR (hObj = nilObject)
    THEN BEGIN
      IF cDebug THEN WRITELN('Nil obj in IFValidIcon : ', fValid);
      EXIT(IFValidIcon);
     END;
  IF hObj^^.container^^.isOpen
    THEN BEGIN
      If fTstTF then
       writeln('Setting valid icon in open container:', hObj^^.name,
               ' to ', fValid);
      SetPort(hObj^^.container^^.objWindow);
      SetValidObject(hObj, FALSE);
     END;
END;


PROCEDURE KillNameObj; { (nameStr: TStr40); }
VAR lstOb: ObjectHandle;
    lstObjSer: TL;
    foundOne, hit: BOOLEAN;

  PROCEDURE KillOne(whichList : ObjectHandle);
  VAR obj, nxobj: ObjectHandle;
  BEGIN
    obj := whichList^^.next;
    WHILE obj <> whichList DO   { travel down brother list }
      BEGIN
        {IF fTstTF THEN
        {  WRITELN('KillOne checking obj: ',obj^^.name,' objSerial: ',
                    obj^^.objSerial); }
        KillOne(obj^^.contents);
        nxobj:=obj^^.next;
        IF TstName(@obj^^.name, @nameStr) THEN IFKillObj(obj);
        obj := nxobj;
      END;
  END;

BEGIN
  IF fTstTF THEN WRITELN('KillNameObj  objName=', nameStr);
  IF nameStr = deskObject^^.name
    THEN BEGIN IF fTstTF THEN WRITELN('Cant kill desk object'); END
    ELSE KillOne(deskObject^^.contents);
END;


FUNCTION GetNameObj; { (nameStr: TStr40; findFirst: TF): ObjectHandle; }
VAR lstOb: ObjectHandle;
    lstObjSer: TL;
    foundOne, hit: BOOLEAN;

  PROCEDURE NmObj(whichList : ObjectHandle);
  VAR obj: ObjectHandle;
  BEGIN
    obj := whichList^^.next;
    WHILE obj <> whichList DO   { travel down brother list }
      BEGIN
      {IF fTstTF THEN
      {  WRITELN('NmObj checking obj: ', obj^^.name, ' objSerial: ',
      {           obj^^.objSerial, ' lstObjSer:', lstObjSer); }
      IF obj^^.state <> placeHolder
       THEN IF TstName(@obj^^.name, @nameStr)
        THEN BEGIN
         hit := FALSE;
         IF NOT foundOne
           THEN hit := TRUE
           ELSE IF findFirst
             THEN BEGIN IF (lstObjSer > obj^^.objSerial) THEN hit:=TRUE; END
             ELSE BEGIN IF (lstObjSer < obj^^.objSerial) THEN hit:=TRUE; END;
         IF hit
          THEN BEGIN
            lstOb := obj;
            lstObjSer := obj^^.objSerial;
            foundOne := TRUE;
            { IF fTstTF THEN
            {   WRITELN('NmObj found obj named:', nameStr, lstObjSer); }
           END;
         END;
      NmObj(obj^^.contents);
      obj:=obj^^.next;
      END;
  END;

BEGIN
  IF fTstTF THEN WRITELN('GetNameObj  objName=', nameStr);
  lstOb := nilObject;
  IF findFirst THEN lstObjSer := MAXINT ELSE lstObjSer := 0;
  foundOne := FALSE;
  IF nameStr = deskObject^^.name
    THEN lstOb := deskObject
    ELSE NmObj(deskObject^^.contents);
  IF fTstTF THEN WRITELN('GetNameObj found obj "', lstOb^^.name, '"');
  GetNameObj := lstOb;
END;


FUNCTION  IFCloseSymbol; { (kind: ObjectKind): INTEGER; }
BEGIN
  IFCloseSymbol := CloseSymbol(kind);
END;


PROCEDURE IFNoEvent;
BEGIN
  IF copyMode THEN BlinkContents(activeObject, hilited);
  UpdateCursor;
  UpdateText;
END;


FUNCTION  IFChangeCont;
   { (obj, cobj: ObjectHandle; ix, iy: TC fChoose: TF): BOOLEAN; }
VAR dh, dv: TC;
BEGIN
  IF fChoose
    THEN BEGIN dh := 0; dv := 0; END
    ELSE BEGIN dh := ix-obj^^.loc.h; dv := iy-obj^^.loc.v; END;
  IF fTstTF THEN BEGIN
    WRITELN('MoveObject: ', obj^^.name, ' into ', cobj^^.name);
    WRITELN(' dh:', dh:5, '  dv:', dv:5, ' chooseLoc: ', fChoose);
   END;
  IF obj^^.container^^.isOpen THEN SetValidObject(obj, FALSE);
  IF obj <> cobj THEN
    IFChangeCont := MoveObject(obj, dh, dv, cobj, FALSE, fChoose, FALSE)
    ELSE IFChangeCont := TRUE;
  WITH obj^^.loc DO BEGIn h := ix; v := iy; END;
  IF obj^^.container^^.isOpen THEN DrawObject(obj);
END;


FUNCTION  IFPutBack; { (obj: ObjectHandle): BOOLEAN; }
VAR fPut: TF;
BEGIN
  IF obj <> deskObject
    THEN BEGIN
      fPut := PutBackObject(obj, FALSE, FALSE);
      IF fTstTF THEN
        WRITELN('IFPutBack of obj "', obj^^.name,
                 '" returns: ', fPut);
     END
    ELSE BEGIN
      fPut := TRUE;
      IF fTstTF THEN
        WRITELN('IFPutBack - cant put back deskObject');
     END;
END;


PROCEDURE IFSetView; { (obj: ObjectHandle; newView: ViewType); }
VAR fPut: TF;
BEGIN
  IF fTstTF THEN
    WRITELN('IFSetView - Setting view for obj "', obj^^.name,
            '" to ', ORD(newView));
  ChangeView(obj, newView);
END;


PROCEDURE IFSelObject; { (obj: ObjectHandle, fSel: TF); }
BEGIN
  IF obj = nilObject THEN EXIT(IFSelObject);
  IF fSel
    THEN BEGIN
      IF obj^^.state <> normal THEN EXIT(IFSelObject);
      SelectObject(obj, TRUE);
     END
    ELSE BEGIN
      IF obj^^.state <> hilited THEN EXIT(IFSelObject);
      IF obj = editObject THEN EndEdit;
      ChangeObject(obj, normal, 0, 0, TRUE);
     END;
  IF fTstTF THEN
    WRITELN('IFSelObject sets state of "', obj^^.name, '" to ',
            ORD(obj^^.state));
END;


FUNCTION  IFIsContainer; { (obj: ObjectHandle): BOOLEAN; }
BEGIN
  IFIsContainer := IsContainer(obj);
END;


PROCEDURE IFDupObj; { (obj: ObjectHandle); }
{ creates a new object on same disk as the given stationery. }
VAR newLoc,newHomeLoc: Point;
    newKind: ObjectKind;
    srcCatRID,newCatRID: TcatRID;
    err: INTEGER;
    catRec: TcatRec;
    newName: FmaxStr;
    newObj,diskObj: ObjectHandle;
    srcVol: TentryHdl;
    curTime: LongInt;
BEGIN
IF fTstTF THEN WRITELN('IFDupObj "',obj^^.name,'"');

diskObj := OnDisk(obj);  { ObjFromVol(obj^^.volHdl); }

{ update catalog for the pad }
FlushObject(obj);

srcVol := obj^^.volHdl;
srcCatRID := obj^^.catRID;

{ make a copy of the files represented by the obj }
XferObject(err,srcCatRID,srcCatRID.fatherID,srcVol,srcVol,TRUE,FALSE,0,newCatRID);
IF err <> 0 THEN
  BEGIN
   IF sDebug THEN WRITELN('IFDupObj - Cant duplicate obj "', obj^^.name, '"');
   EXIT(IFDupObj);
  END;

{ create the new object icon }
EndEdit;
WITH obj^^ DO
   BEGIN
   newName:=obj^^.name;
   newLoc.h:=loc.h+icon2Width;
   newLoc.v:=loc.v+icon2Ht;
   IF obj^^.container^^.objWindow <> NIL THEN
     WITH obj^^.container^^.objWindow^.portRect DO
       BEGIN
         IF newLoc.h + iconWidth > right THEN newLoc.h:=newLoc.h-iconWidth;
         IF newLoc.v + iconHt > bottom THEN newLoc.v:=newLoc.v-iconHt;
       END;
   newKind:=kind;
   curTime := TimeStamp;
   newObj:=MakeObject(container,newName,newKind,subKind,newLoc,windowRect,
                      normal,srcVol,newCatRID,curTime,curTime,size,
                      (container <> deskObject));
   END;

{ if created on desk then choose a home location }
IF newObj^^.container = deskObject THEN
    ChooseHome(newObj,newHomeLoc)
ELSE
   newHomeLoc := newLoc;

newObj^^.dirty := TRUE;

{ change catalog entry to match new object kind, name, loc }
GetCatRec(err,srcVol,newCatRID,catRec);
CheckCatErr(err,'IFDupObj - Unable to get catRec');
WITH catRec DO
   BEGIN
   objKind := newKind;
   InsObjName(catRec,newName);
   closedPt := newHomeLoc;
   created := newObj^^.created;
   modified := newObj^^.modified;
   END;
UpdCatRec(err,srcVol,newCatRID,catRec);
CheckCatErr(err,'IFDupObj - Unable to Add catRec');

{ if created in a list then put in proper location }
IF obj^^.container^^.isOpen
 THEN WITH obj^^ DO
   IF container^^.viewMode <> spatialView THEN
      BEGIN
      SortContents(container,container^^.viewMode);
      DrawContents(container);
      END
    ELSE
      DrawObject(newObj);
END;


PROCEDURE IFReName; { (obj: ObjectHandle; newName: FMaxStr); }
VAR placeObj: ObjectHandle;
BEGIN
  placeObj := GetPlaceHolder(obj);
  IF fTstTF THEN WRITELN('IFRename "', obj^^.name, '" to "', newName, '"');
  IF obj^^.objWindow <> NIL
    THEN SetFldrTitle(obj^^.objWindow, newName);
  obj^^.name := newName;
  WITH obj^^.loc DO IFMoveIcon(obj, h, v);
  IF placeObj <> nilObject
    THEN BEGIN
      placeObj^^.name := newName;
      WITH placeObj^^.loc DO IFMoveIcon(placeObj, h, v);
      IF fTstTF THEN WRITELN('IFRename place obj renamed');
     END;
END;


FUNCTION AddIMFolder;
      { (hObj: ObjectHandle; fVis, fwindow, fSBars: TF; cKeep: TC): THFldrInfo; }
VAR fport: WindowPtr;
    newFldr: THFldrInfo;
    wName: FMaxStr;
    newStr: THIMS;
BEGIN
  IF fTstFldrs THEN WRITELN('AddIMFolder for object: ', hObj^^.name);
  IF hObj^^.objWindow = NIL
    THEN  WITH hObj^^ DO BEGIN
      IF fTstFldrs THEN WRITELN('AddIMFolder - building new GrafPort');
      wName := name;
      fport := NewFolder(windowRect, wName, FALSE,
                    activeFolder, fldrCount, My_ID, IFCloseSymbol(kind), noIcon);
        IF fport = NIL
          THEN BEGIN
            WRITELN('AddIMFolder - NIL folder from NewFolder goto deubgger before trying again');
            HoldIt(sDebug);
           END;
      objWindow := fport;
     END
    ELSE fport := hObj^^.objWindow;
  IF fTstFldrs THEN WRITELN('AddIMFolder - fport: ', ORD(fport));
IF fport <> NIL THEN BEGIN
  newFldr := BuildIMFolder(hObj^^.name, fVis, fWindow, fSBars, fport);
  IF cKeep > 0
    THEN BEGIN
      newStr := NewFldrStream(newFldr, cKeep, IFIsContainer(hObj));
      newStr^^.sCanAddLines := TRUE;
     END;
  newFldr^^.fldrFObj := POINTER(ORD(hObj));
END ELSE newFldr := NIL;
  hObj^^.imFldr := newFldr;
  IF fVis THEN IFOpenObj(hObj);
  AddIMFolder := newFldr;
END;





