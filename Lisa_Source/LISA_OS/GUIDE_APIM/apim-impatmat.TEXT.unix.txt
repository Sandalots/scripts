{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}


{$s impc }

UNIT IMPatMat;

INTERFACE

USES {$U HwInt        }  HwInt,
     {$U libos/SysCall      }  SysCall,
     {$U libos/PSysCall     }  PSysCall,
     {$U UnitStd.obj  }  UnitStd,
     {$U UnitHz.obj   }  UnitHz,
     {$U Storage.obj  }  Storage,
     {$U QuickDraw    }  QuickDraw,
     {$U FontMgr.obj  }  FontMgr,
     {$U PmDecl       }  PmDecl,
     {$U PMM          }  PMM,
     {$U FMgrUtil.obj }  FmgrUtil,
     {$U WM.Events    }  Events,
     {$U WM.Folders   }  Folders,
     {$U WM.Menus     }  Menus,
     {$U WMLStd       }  WMLStd,
     {$U WMLSB        }  WMLSb,
     {$U WMLGrow      }  WMLGrow,
     {$U AlertMgr.obj }  AlertMgr,
     {$U dbenv.obj    }  dbenv,
     {$U DBdecl1      }  DBdecl1,
     {$U fedec.obj    }  fedec,
     {$U fld.obj      }  FieldEdit,
     {$U apim/UnitImf.obj  }  UnitImf,
     {$U apim/imcore.obj   }  IMCore,
     {$U apim/IMMenus.obj  }  IMMenus,
     {$U apim/IMStream.obj }  IMStream,
     {$U apim/IMSEdit.obj  }  IMSEdit,
     {$U apim/IMFolders.obj}  IMFolders,
     {$U apim/TFGlobals    }  IFGlobals,  { Common routines & declarations }
     {$U apim/TFEntry      }  IFEntry,
     {$U apim/TCatalog     }  IFCatalog,
     {$U apim/TFiler       }  TFiler,     { TeachingFiler unit }
     {$U apim/IMScript.obj }  IMScript;


CONST

     CMaxPatLen = 1000;
     CKeyBufLen = 200;
     CBackSpace = 8;
     bsKey = 8;
     CIgnoreChar = -1;

     CShftIgnore = 0;
     CShftFalse = 1;
     CShftTrue = 2;


   { -- matFailCodes -- }

     CTxRngMatchFailure = 1;
     CTxRngTestFailure = 2;
     CNoMatMenuEvt = 3;
     CNoMatSelEvt = 4;
     CNoMatObjEvt = 5;
     CSelLvlDiff = 6;
     CTstKbd1NoMoreKeyEvts = 7;
     CTstKbd2CantSkipKey = 8;
     CTxSkipFail = 9;
     CNoSuchObj = 10;
     CNoObjSelect = 11;
     CNoObjOpen = 12;
     CNoObjClose = 13;
     CNoObjPutBack = 28;
     CNoObjTearOff = 14;
     CNoObjDuplicate = 15;
     CNoObjActivate = 16;
     CNoObjChgCont = 17;
     CNoContainerObj = 18;
     CNoObjRename = 19;
     CNoRenameObj = 20;
     CNoObjXInRange = 21;
     CNoObjYInRange = 22;
     CNoObjHInRange = 23;
     CNoObjWInRange = 24;
     CNoObjThumb = 25;
     CNoObjPage = 26;
     CNoObjArrow = 27;
     CNoSuchFolder = 28;
     CNoStreamInFolder = 29;



   { -- patErrCodes -- }
   { -- reported as match fail code of 100 + patErrCode -- }

     CTxtParenErr = 1;
     CInvTxStringInTxtPat = 2;
     CInvTxPat =  3;
     CInvMenTit = 4;
     CNoMenTit = 5;
     CInvMenItem = 6;
     CNoMenItem = 7;
     CInvSelPat = 8;
     CInvSelectText = 9;
     CInvSelTrailText = 10;
     CInvPatStart = 11;
     CInvTopPatChar = 12;
     CInvMnPatChar = 13;
     CInvSlPatChar = 14;
     CInvObPatChar = 15;
     CInvAndPatChar = 16;
     CInvOrPatChar = 17;
     CAteWholePat = 18;
     CInvKbStringInTxtPat = 19;
     CInvKbdPatChar = 20;
     CInvSelRecPatChar = 21;
     CInvObSelPatChar = 22;
     CInvFolderName = 23;
     CInvVarNameInTxtPat = 24;
     CPastEndOfPat = 99;


TYPE
  THPatRgch = ^TRgch;

  THKeyBuf = ^TPKeyBuf;
  TPKeyBuf = ^TKeyBuf;
  TKeyBuf = RECORD
              kbLen: TC;
              kbFst: TC;
              kbLim: TC;
              kbRgch: THPatRgch;
            END;

  TPEBufPos = ^TEBufPos;
  TEBufPos = RECORD
                 PEBuf: THEvtBuf;
                 PEBufData: THEBufData;
                 PEBufPos: TC;
               END;

  TPEBufRange = ^TEBufRange;
  TEBufRange = RECORD
                 bufStart, bufLim: TPEBufPos;
               END;

  THPatRec = ^TPPatRec;
  TPPatRec = ^TPatRec;

  TPatRec = RECORD
              PPatPtr: THPatRgch;
              PPatLen: TC;
              PPatPos: TC;
              PIMStr: THIMS;
              PTxFstLine: THIMSLine;
              PTxLstLine: THIMSLine;
              PTxMatLine: THIMSLine;
              PFailCode: TC;
              PEBufRange: TEBufRange;
              PPatFail: TF;
              PPartMark: TB;
            END;


  THTxtRange = ^TPTxtRange;
  TPTxtRange = ^TTxtRange;
  TTxtRange = RECORD
                rFstLine: THIMSLine;
                rFstPos: TC;
                rLstLine: THIMSLine;
                rLstPos: TC;
              END;


  THObjSet = ^TPObjSet;
  TPObjSet = ^TObjSet;
  TObjSet  = RECORD
               setSz: TB;
               setCt: TB;
               setId: ARRAY[1..1] OF TB;
              END;


PROCEDURE InitPatMat;
FUNCTION  KbdStr(pstr: TPStr255; maxlen: TC): TC;
FUNCTION  MatchPat(VAR PartMatMark, MatFailCode: TC): TF;



IMPLEMENTATION

TYPE
  TLimChar = RECORD
               lFstChar: CHAR;
               lSecChar: CHAR;
               lNxLChar: CHAR;
               lLstChar: CHAR;
             END;

  TLimByte = RECORD
               lFstByte: TB;
               lSecByte: TB;
               lNxLByte: TB;
               lLstByte: TB;
             END;
              TIMFLims = RECORD
               lSrchErr: TB; {Return code = 0 if last lim search was successful}
               lNestFlag: TF;
               lDblFlag: TF;
               CASE TF OF
                 TRUE: (limChr: TLimChar);
                 FALSE: (limByt: TLimByte);
             END;

VAR limPats: TIMFLims;


FUNCTION  MatOr(pr: TPPatRec): TC; FORWARD;
FUNCTION  MatAnd(pr: TPPatRec): TC; FORWARD;
FUNCTION  MatObj(pr: TPPatRec; patEbr: TEBufRange): TC; FORWARD;


{$S impdbg }
PROCEDURE PrintRange(tr: TPTxtRange);
VAR i: TC;
    pLine: THIMSLine;
    lrgch: TRgch;
BEGIN
  WITH tr^ DO BEGIN
    WRITELN('Text Range at:', ORD(tr));
    WRITELN(' rFstLine', ORD(rFstLine), ' rFstPos:', rFstPos,
            ' rLstLine', ORD(rLstLine), ' rLstPos:', rLstPos);
    pLine := rFstLine;
    WHILE pLine <> NIL DO
      BEGIN
        WRITE('(', LineCCount(pLine):3, ') ');
        lrgch := LineChars(pLine);
        IF lrgch <> NIL THEN
          FOR i := 0 TO LineCCount(pLine) - 1 DO
            BEGIN
              IF pLine = rFstLine THEN
                IF i = rFstPos THEN WRITE('{<}');
              IF pLine = rLstLine THEN
                IF i = rLstPos THEN WRITE('{>}');
              WRITE(CHR(lrgch^[i]));
            END;
        WRITELN;
        IF pLine <> rLstLine
          THEN BEGIN
            pLine := pLine^^.lNext;
            IF pLine = NIL THEN
             WRITELN('Reached end of stream before last line of text range');
           END
          ELSE pLine := NIL;
      END;
  END;
END;


{$S impdbg }
PROCEDURE PrintRgch(rgch: TRgch; len: TC);
VAR i: TC;
BEGIN
  WRITE('Text Rgch at:', ORD(rgch));
  WRITE('[');
  FOR i := 0 TO len - 1 DO
    WRITE(CHR(rgch^[i]));
  WRITELN(']');
END;


{$S impdbg }
PROCEDURE PrintChad(pchad: TChad);
VAR i: TC;
BEGIN
  WITH pchad^ DO BEGIN
    WRITELN('Text Chad at:', ORD(pchad), ' ichFst:', ichFst, ' ichLim:', ichLim);
    WRITE('[');
    FOR i := ichFst TO ichLim - 1 DO
      WRITE(CHR(rgch^[i]));
    WRITELN(']');
  END;
END;


{$S impdbg }
PROCEDURE PrintKeyBuf(hkb: THKeyBuf);
VAR i: TC;
BEGIN
  WITH hkb^^ DO BEGIN
    WRITELN('KeyBuf at:', ORD(hkb^), ' kbFst:', kbFst:5,
             ' kbLim:', kbLim:5, ' kbLen:', kbLen:5);
    WRITE('[');
    FOR i := kbFst TO kbLim - 1 DO
      WRITE(CHR(kbRgch^^[i]));
    WRITELN(']');
  END;
END;


{$S impdbg }
PROCEDURE PrtPat(pr: TPPatRec);
VAR i: TC;
    pptr: TRgch;
BEGIN
  IF pr^.PPatPtr <> NIL
    THEN pptr := pr^.PPatPtr^
    ELSE BEGIN
      WRITELN('No pattern text');
      EXIT(PrtPat);
     END;
  WRITE('[');
  FOR i := 0 TO pr^.PPatLen - 1 DO
    BEGIN
      IF i = pr^.PPatPos THEN WRITE('{!}');
      WRITE(CHR(pptr^[i]));
      IF i MOD 70 = 69 THEN WRITELN
        ELSE IF i MOD 10 = 9 THEN WRITE(' ');
    END;
  WRITELN(']');
END;


{$S impdbg }
PROCEDURE PrtBufPos(ebp: TPEBufPos);
BEGIN
  IF ebp = NIL
    THEN BEGIN
      WRITELN(' Null Buf Pos');
     END
    ELSE WITH ebp^ DO
          WRITELN('  PEBuf:', ORD(PEBuf),
                  '  PEBufData:', ORD(PEBufData),
                  '  PEBufPos:', ORD(PEBufPos));
END;


{$S impdbg }
PROCEDURE PrtBufRange(ebr: TEBufRange);
BEGIN
  WITH ebr DO
      BEGIN
        WRITE('  bufStart');
        PrtBufPos(bufStart);
        WRITE('  bufLim  ');
        PrtBufPos(bufLim);
      END;
END;

{$S impdbg }
PROCEDURE PrintPatRec(pr: TPPatRec);
BEGIN
 IF pr = NIL
   THEN BEGIN
     WRITELN('Pattern match record handle is NIL.');
     EXIT(PrintPatRec);
    END;
 WITH pr^ DO
   BEGIN
     WRITELN('Pattern match record - PatLen:', PPatLen, '  PatPos:', PPatPos);
     PrtPat(pr);
     WRITELN('  PTxFstLine:', ORD(PTxFstLine),
             '  PTxLstLine:', ORD(PTxLstLine),
             '  PTxMatLine:', ORD(PTxMatLine));
     PrtBufRange(PEbufRange);
     WRITELN('  PFailCode:', PFailCode,
             '  PPatFail: ', PPatFail,
             '  PPartMark:', PPartMark);
   END;
END;


{$S impini }
PROCEDURE InitPatMat;
BEGIN
  WITH limPats DO
    BEGIN
      lSrchErr := 0;
      lDblFlag := FALSE;
      lNestFlag := TRUE;
      limChr.lFstChar := '<';
      limByt.lSecByte := 0;
      limByt.lNxLByte := 0;
      limChr.lLstChar := '>';
  END;
END;


{$S imph }
FUNCTION  MatchFail(pr: TPPatRec; matFailCode: TC): TC;
BEGIN
  IF IMtst OR fTstPat THEN WRITELN('Match Fails: ', matFailCode);
  IF pr <> NIL THEN   IF fTstPat THEN PrintPatRec(pr);
  MatchFail := matFailCode;
END;


{$S impdbg }
PROCEDURE PatError(pr: TPPatRec; patErrCode: TC; badChar: CHAR);
BEGIN
  pr^.PPatFail := TRUE;
  pr^.PFailCode := patErrCode;
  IF IMtst OR fTstPat OR sDebug
    THEN BEGIN
      WRITE('Pattern Error: ', patErrCode);
      IF ORD(badChar) <> 0
        THEN WRITELN(' at char: ', badChar, ' (', ORD(badChar), ')')
        ELSE WRITELN;
      PrintPatRec(pr);
     END;
END;


{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICDumpPat(pr: TPPatRec);
CONST icPatPtLen=40;
VAR ppos, plen, strSize, strPos: TC;
    patRgch: TRgch;
    pch: CHAR;
BEGIN
  IF fICompile THEN
      BEGIN
      plen := pr^.PPatLen;
      ppos := 0;
      patRgch := pr^.PPatPtr^;
      WRITELN(icFile, 'CPatSize := ', plen:1, ';');
      strPos := icPatPtLen;
      WHILE ppos < plen DO
          BEGIN
          IF strPos >= icPatPtLen THEN
              BEGIN
              IF ppos > 0 THEN WRITELN(icFile, ''');');
              WRITE(icFile, 'CPatPart(''');
              strPos := 0;
              END;
          pch := CHR(patRgch^[ppos]);
          WRITE(icFile, pch);
          IF pch = '''' THEN WRITE(icFile, pch);
          strPos := strPos+1;
          ppos := ppos+1
          END;
      WRITELN(icFile, ''');');
      END;
END;
{$ENDC }


{$S imph }
FUNCTION  ReadPat(pr: TPPatRec): TF;
VAR patCount: TC;
    hPatRgch: THPatRgch;
    patLevel: TC;
    foundPat: TF;
    pch: CHAR;

  PROCEDURE PutPatChar(pb: CHAR);
  BEGIN
    IF patCount >= CMaxPatLen
      THEN BEGIN
        ReadPat := FALSE;
        IF fTstPat THEN WRITELN('Pattern too long');
        EXIT(ReadPat);
       END;
    hPatRgch^^[patCount] := ORD(pb);
    IF fTstPat THEN WRITE(pb);
    patCount := patCount + 1;
  END;

  PROCEDURE ReadPatArg;
  LABEL 100, 200, 900;
  VAR endCh: CHAR;
  BEGIN
       pch := ReadScriptChar;
       IF pch = '['
         THEN BEGIN endCh := ']'; PutPatChar(pch); END
         ELSE IF pch = '<'
                THEN BEGIN endCh := '>'; PutPatChar(pch); END
                ELSE BEGIN endCh := ')'; GOTO 200; END;
  100: pch := ReadScriptChar;
  200: IF pch = endCh THEN
         BEGIN
           IF endCh <> ')'
             THEN BEGIN
               pch := ReadScriptChar;
               IF pch = ')'
                 THEN BEGIN
                   PutPatChar(endCh);
                   PutPatChar(pch);
                   GOTO 900;
                  END;
               PutPatChar(endCh);
               GOTO 200;
              END
             ELSE BEGIN
               PutPatChar(endCh);
               GOTO 900;
              END;
         END;
     PutPatChar(pch);
     GOTO 100;
  900:
  END;

BEGIN
  WITH pr^ DO
    BEGIN
      patCount := 0;
      patLevel := 0;
      foundPat := FALSE;
      hPatRgch := POINTER(ORD(HAllocate(IMHeap, CMaxPatLen)));
      PPatPtr := hPatRgch;
      IF fTstPat THEN WRITELN('Reading pattern to rgch: ', ORD(hPatRgch^));
      WHILE NOT foundPat DO
        BEGIN
          pch := ReadScriptChar;
          CASE pch OF
            ' ': BEGIN END;
            '<': BEGIN
                   PutPatChar(pch);
                   patLevel := patLevel + 1;
                 END;
            '>': BEGIN
                   PutPatChar(pch);
                   patLevel := patLevel - 1;
                   IF patLevel <= 0 THEN foundPat := TRUE;
                 END;
            '(': BEGIN PutPatChar(pch); ReadPatArg; END;
            '.': BEGIN
                   IF fTstPat THEN WRITELN('Unbalanced right angle bracket');
                   ReadPat := FALSE;
                   EXIT(ReadPat);
                 END;
            OTHERWISE PutPatChar(pch);
           END;
        END;
      IF patCount < CMaxPatLen
        THEN ChangeSizeH(IMHeap, POINTER(ORD(hPatRgch)), patCount);
      PPatLen := patCount;
      IF fTstPat
        THEN BEGIN
          WRITELN;
          WRITELN('Pattern length:', patCount);
          PrintPatRec(pr);
         END;
      ReadPat := TRUE;
{$IFC IMCompile }
      IF fICompile THEN ICDumpPat(pr);
{$ENDC }
    END;
END;


{$S imph }
FUNCTION BuildPatRec(pr: TPPatRec; ebStart: TPEBufPos): TF;
LABEL 900;
VAR pch: CHAR;
BEGIN
  WITH pr^ DO
    BEGIN
      pch := PeekUCScriptChar;
      IF pch <> '<'
        THEN BEGIN
          InvalidCmdChar(pch, 'Invalid pattern start.');
          GOTO 900;
         END
        ELSE WITH pr^ DO
          BEGIN
            IF NOT ReadPat(pr)
              THEN BEGIN
                CmdError('Can''t read pattern.');
                BuildPatRec := FALSE;
                GOTO 900;
               END;
            PEBufRange.bufStart := ebStart;
            PEBufRange.bufLim := NIL;
            ebStart^.PEBuf := curEvtBuf;
            ebStart^.PEBufData := NIL;
            ebStart^.PEBufPos := 0;
            PIMStr := LGStr;
          END;
    END;
  BuildPatRec := TRUE;
900:
END;


{$S imph }
PROCEDURE ClearPatRec(pr: TPPatRec; fOldPat: TF);
BEGIN
  IF fTstPat THEN WRITELN('Clearing pattern rec: ', ORD(pr));
  IF pr <> NIL THEN
    WITH pr^ DO BEGIN
      IF fOldPat AND (PPatPtr <> NIL)
        THEN BEGIN
          IF fTstPat THEN WRITELN('Freeing pattern storage.', ORD(PPatPtr));
          FreeBk(IMHeap, POINTER(ORD(PPatPtr)), tyBkStd);
         END;
      PPatPtr :=  NIL;
      PPatLen :=  0;
      PPatPos :=  0;
      PIMStr := NIL;
      PTxFstLine := NIL;
      PTxLstLine := NIL;
      PTxMatLine := NIL;
      PEBufRange.bufStart := NIL;
      PEBufRange.bufLim := NIL;
      PFailCode := 0;
      PPatFail := FALSE;
      PPartMark := 0;
    END;
END;


{$S imph }
FUNCTION  NewPatRec: THPatRec;
VAR hpr: THPatRec;
BEGIN
  hpr := POINTER(ORD(HAllocate(IMHeap, SIZEOF(TPatRec))));
  IF fTstPat THEN WRITELN('Allocating pattern rec handle at:', ORD(hpr));
  ClearPatRec(hpr^, FALSE);
  NewPatRec := hpr;
END;


{$S impt }
FUNCTION  NewKeyBuf(kLen: TC): THKeyBuf;
VAR hkb: THKeyBuf;
BEGIN
  IF kLen = 0 THEN kLen := CKeyBufLen;
  hkb := POINTER(ORD(HAllocate(IMHeap, SIZEOF(TKeyBuf))));
  WITH hkb^^ DO
    BEGIN
      kbLen := kLen;
      kbRgch := POINTER(ORD(HAllocate(IMHeap, kLen)));
      kbFst := 0;
      kbLim := 0;
    END;
  NewKeyBuf := hkb;
END;


{$S impt }
PROCEDURE ResizeKeyBuf(hkb: THKeyBuf; kbDelta: TC);
BEGIN
  WITH hkb^^ DO
    BEGIN
      kbDelta := kbLen + kbDelta;
      IF kbLen < kbLim THEN kbDelta := kbLim + 10;
      IF fTstPat THEN WRITELN('Resizing key buf to kbLen = ', kbDelta);
      ChangeSizeH(IMHeap, POINTER(ORD(hkb^^.kbRgch)), kbDelta);
    END;
END;


{$S impt }
PROCEDURE FreeKeyBuf(VAR hkb: THKeyBuf);
BEGIN
  IF fTstPat THEN WRITELN('Freeing key buf: ', ORD(hkb));
  FreeBk(IMHeap, POINTER(ORD(hkb^^.kbRgch)), tyBkStd);
  FreeBk(IMHeap, POINTER(ORD(hkb)), tyBkStd);
END;


{
    PROCEDURE FreePatRec(VAR pr: THPatRec);
    BEGIN
      IF fTstPat THEN WRITELN('Freeing pattern rec: ', ORD(pr));
      FreeBk(IMHeap, POINTER(ORD(pr^.PPatPtr)), tyBkStd);
      FreeBk(IMHeap, POINTER(ORD(pr)), tyBkStd);
    END;


    PROCEDURE SetPatPos(pr: TPPatRec; count: TC);
    BEGIN
      WITH pr^ DO
        BEGIN
          PPatPos := count;
        END;
    END;
}


{$S imph }
PROCEDURE BumpPatPos(pr: TPPatRec; count: TC);
BEGIN
  WITH pr^ DO
    BEGIN
      PPatPos := PPatPos + count;
    END;
END;


{$S imph }
FUNCTION  GetPatChar(pr: TPPatRec): CHAR;
BEGIN
  WITH pr^ DO
    BEGIN
      IF PPatPos < PPatLen
        THEN BEGIN
          GetPatChar := CHR(PPatPtr^^[PPatPos]);
          PPatPos := PPatPos + 1;
         END
        ELSE BEGIN
          PatError(pr, CPastEndOfPat, CHR(0));
          GetPatChar := CHR(0);
         END;
    END;
END;


{$S imph }
PROCEDURE SetPartMat(pr: TPPatRec; partCh: CHAR);
VAR partByte: TB;
BEGIN
  partByte := ORD(partCh) - ORD('0');
  pr^.PPartMark := partByte;
  IF fTstPat THEN WRITELN('Partial Match mark set to:', partByte:3);
END;


{$S imph }
FUNCTION  GetPatArg(pr: TPPatRec; pchad: TChad): TF;
LABEL 100, 200, 900;
VAR pch: CHAR;
    endCh: CHAR;
    pLim: TC;
BEGIN
     pchad^.rgch := pr^.PPatPtr^;
     pch := GetPatChar(pr);
     IF pch <> '('
       THEN BEGIN
         GetPatArg := FALSE;
         EXIT(GetPatArg);
        END;
     pch := GetPatChar(pr);
     IF pch = '['
       THEN endCh := ']'
       ELSE IF pch = '<'
              THEN endCh := '>'
              ELSE BEGIN endCh := ')'; BumpPatPos(pr, -1); END;
     pchad^.ichFst := pr^.PPatPos;
100: pLim := pr^.PPatPos;
     pch := GetPatChar(pr);
200: IF pch = endCh THEN
       BEGIN
         IF endCh <> ')'
           THEN BEGIN
             pch := GetPatChar(pr);
             IF pch = ')'
               THEN GOTO 900;
             GOTO 200;
            END
           ELSE GOTO 900;
       END;
     GOTO 100;
900:
     pchad^.ichLim := pLim;
     GetPatArg := TRUE;
     IF fTstPat THEN BEGIN
         WRITE('GetPatArg result chad: ');
         PrintChad(pchad);
       END;
END;


{$S imph }
FUNCTION  GetPatStr(pr: TPPatRec; patStr: TPStr255; lim: TC): TF;
LABEL 100, 200, 900;
VAR pch: CHAR;
    endCh: CHAR;
    strPos: TC;
BEGIN
     strPos := 0;
     pch := GetPatChar(pr);
     IF pch <> '('
       THEN BEGIN
         GetPatStr := FALSE;
         EXIT(GetPatStr);
        END;
     pch := GetPatChar(pr);
     IF pch = '['
       THEN endCh := ']'
       ELSE IF pch = '<'
              THEN endCh := '>'
              ELSE BEGIN endCh := ')'; BumpPatPos(pr, -1); END;
100: pch := GetPatChar(pr);
200: IF pch = endCh THEN
       BEGIN
         IF endCh <> ')'
           THEN BEGIN
             pch := GetPatChar(pr);
             IF pch = ')'
               THEN GOTO 900;
             GOTO 200;
            END
           ELSE GOTO 900;
       END;
     strPos := strPos+1;
     IF strPos <= lim THEN patStr^[strPos] := pch;
     GOTO 100;
900:
     patStr^[0] := CHR(strPos);
     GetPatStr := TRUE;
     IF fTstPat THEN  WRITELN('GetPatStr gets: ', patStr^);
END;


{$S imph }
FUNCTION PatIntArg(pr: TPPatRec; VAR int: TC): TF;
LABEL 200,900;
VAR pch: CHAR;
    fOK, fNeg: TF;
    pvarRec: TPVarRec;
    patint: TC;
    savePos: TC;
BEGIN
  savePos := pr^.PPatPos;
  patint := 0;
  fNeg := FALSE;
  pch := GetPatChar(pr);
  IF (pch = 'U') OR (pch = 'V')
    THEN BEGIN
      pvarRec := GetVarRec(pch);
      IF pvarRec = NIL
        THEN fOK := FALSE
        ELSE IF pvarRec^.vType <> TVInt
          THEN BEGIN
             CmdError('Invalid variable type assignment to INTEGER variable');
             fOK := FALSE;
            END
          ELSE BEGIN patint := pvarRec^.vInt; int := patint; fOK := TRUE; END;
     END
  ELSE IF pch <> '('
    THEN BEGIN fOK := FALSE; BumpPatPos(pr, -1); END
    ELSE
      BEGIN
        pch := GetPatChar(pr);
        IF pch = '-'
          THEN fNeg := TRUE
          ELSE BumpPatPos(pr, -1);
        patint := 0;
   200: pch := GetPatChar(pr);
        IF (pch = ')')
          THEN BEGIN
                fOK := TRUE;
                IF fNeg THEN patint := -patint;
                int := patint;
                GOTO 900;
               END;
        IF (ORD(pch) < ORD('0')) OR (ORD(pch) > ORD('9'))
          THEN BEGIN fOK := FALSE; GOTO 900; END;
        patint := patint * 10;
        patint := patint + ORD(pch) - ORD('0');
        GOTO 200;
      END;
900:
  PatIntArg := fOK;
  IF NOT fOK THEN pr^.PPatPos := savePos;
  IF fTstPat THEN
    IF fOK
      THEN WRITELN('PatIntArg sets  ', ORD(@int), ' to ', patint)
      ELSE WRITELN('PatIntArg fails - cannot set ', ORD(@int), ' to ', patint);
END;


{$S imph }
FUNCTION PatRange(pr: TPPatRec; VAR int, err: TC): TF;
LABEL 900;
VAR pch: CHAR;
    fOK: TF;
    patint, perr: TC;
BEGIN
  patint := 0;
  perr := 0;
  fOK := PatIntArg(pr, patint);
  IF NOT fOK THEN GOTO 900;
  pch := GetPatChar(pr);
  IF fTstPat THEN WRITELN('peeked next char(test for +): ', pch);
  IF pch = '%'
    THEN fOK := PatIntArg(pr, perr)
    ELSE BumpPatPos(pr, -1);
900:
  PatRange := fOK;
  int := patint;
  err := perr;
  IF fTstPat THEN
    IF fOK
      THEN WRITELN('PatRange sets  ', ORD(@int), ' to ', int, '+/- ', err)
      ELSE WRITELN('PatRange fails - cannot set ', ORD(@int), ' to ', patint);
END;


{$S impt }
FUNCTION  TstTxtRgch(patRgch, matRgch: TRgch; count: TC): TF;
LABEL 900;
VAR i: TC;
    ch: TB;
BEGIN
  FOR i := 0 TO count-1 DO
    BEGIN
      ch := patRgch^[i];
      IF ch <> matRgch^[i]
        THEN BEGIN   { elaborate letter by letter case independence test }
          IF ch <= ORD('Z')
            THEN BEGIN
              IF ch < ORD('A') THEN GOTO 900;
              IF ch+32 <> matRgch^[i] THEN GOTO 900;
       IF fTstPat THEN
 WRITELN('Testing CAP patch: ', ch, ' matches SMALL match: ', matRgch^[i]);
             END
            ELSE BEGIN
              IF ch < ORD('a') THEN GOTO 900;
              IF ch > ORD('z') THEN GOTO 900;
              IF ch-32 <> matRgch^[i] THEN GOTO 900;
       IF fTstPat THEN
 WRITELN('Testing SMALL patch: ', ch, ' matches CAP match: ', matRgch^[i]);
             END;
         END;
    END;
  TstTxtRgch := TRUE;
  IF fTstPat THEN WRITELN('TstTxtRgch succeeds');
  EXIT(TstTxtRgch);
 900:
  IF fTstPat THEN WRITELN('TstTxtRgch fails');
  TstTxtRgch := FALSE;
END;


{$S impt }
FUNCTION  TxtPatChad(pr: TPPatRec; patChad: TChad): TF;
LABEL 100,900;
VAR pch, endCh: CHAR;
    scanRgch: TRgCHAR;
    scanpos, scanLim: TC;
{ PPatPos should point to pos immediately after the open paren }
BEGIN
  IF fTstPat THEN WRITELN('TxtPatChad');
  WITH pr^ DO
    BEGIN
      pch := GetPatChar(pr);
      IF pch = '['
        THEN endCh := ']'
        ELSE IF pch = '<'
          THEN endCh := '>'
          ELSE BEGIN
            endCh := ')';
            BumpPatPos(pr, -1);  {this was a string char }
           END;
      scanRgch := @PPatPtr^^[PPatPos];
      WITH patChad^ DO
        BEGIN
          { loop around endCh that is not real end. }
           rgch := @PPatPtr^^[PPatPos];
           ichFst := 0;
           ichLim := 0;
        100:
           scanLim := PPatLen - PPatPos;
           scanpos := SCANEQ(scanLim, endCh, scanRgch^);
           IF scanpos = scanLim
             THEN BEGIN
               PatError(pr, CTxtParenErr, CHR(0));
               ichLim := 0;
               IF fTstPat THEN WRITELN('Pattern Error found in TxtPatChad');
               TxtPatChad := FALSE;
               GOTO 900;
              END;
           ichLim := ichLim + scanpos;
           BumpPatPos(pr, scanpos + 1);
           IF endCh <> ')'
             THEN IF GetPatChar(pr) <> ')'
               THEN BEGIN BumpPatPos(pr, -1); GOTO 100; END;
        END;
    END;
  TxtPatChad := TRUE;
  IF fTstPat THEN BEGIN WRITE('TxtPatChad:'); PrintChad(patChad); END;
900:
END;


{$S impt }
FUNCTION  TxtChadMat(patChad, matChad: TChad): TF;
LABEL 100;
VAR mChar: CHAR;
    mStart, matFst: TC;
    matLen, patLen: TC;
    scanRgch: TRgCHAR;
    patRgch: TRgch;
BEGIN
  WITH patChad^ DO
    BEGIN
      mChar := CHR(rgch^[ichFst]);
      patLen := ichLim - ichFst;
      patRgch := @rgch^[ichFst];
    END;
  WITH matChad^ DO
    BEGIN
      matFst := ichFst;
      matLen := ichLim - ichFst;
100:  IF matLen >= patLen THEN
        BEGIN
          scanRgch := @rgch^[ichFst];
          mStart := SCANEQ(matLen, mChar, scanRgch^);
          IF mStart <> matLen
            THEN BEGIN
              ichFst := mStart + ichFst;
              IF TstTxtRgch(patRgch, @matChad^.rgch^[ichFst], patLen)
                THEN BEGIN
                  TxtChadMat := TRUE;
                  ichFst := ichFst + patLen;
                  EXIT(TxtChadMat);
                 END
                ELSE BEGIN
                  ichFst := ichFst + 1; { bump for next round. }
                  matLen := ichLim - ichFst;
                  GOTO 100;
                 END;
             END;
        END;
      ichFst := matFst;
      TxtChadMat := FALSE;  { failed! }
    END;
END;


{$S impt }
FUNCTION  TxtMatRange(patChad: TChad; tr: TPTxtRange): TF;
VAR matAchad: TAchad;
    matLine: THIMSLine;
BEGIN
  IF fTstPat THEN
    BEGIN
      WRITELN('TxtMatRange');
      PrintRange(tr);
      WRITE('PatChad: ');
      PrintChad(patChad);
    END;
  matLine := tr^.rFstLine;
  WITH matAchad DO
    WHILE matLine <> NIL DO
      BEGIN
        IF fTstPat THEN
          WRITELN('matLine:', ORD(matLine), '  len=', LineCCount(matLine),
                  ' nxtLine:', ORD(matLine^^.lNext));
        rgch := LineChars(matLine);
        IF matLine = tr^.rFstLine
          THEN ichFst := tr^.rFstPos
          ELSE ichFst := 0;
        IF matLine = tr^.rLstLine
          THEN ichLim := tr^.rLstPos
          ELSE ichLim := LineCCount(matLine);
        IF fTstPat THEN BEGIN
            WRITE('TxtMatRange matChad:');
            PrintChad(@matAchad);
          END;
        IF TxtChadMat(patChad, @matAchad)
          THEN BEGIN
            tr^.rFstLine := matLine;
            tr^.rFstPos := matAchad.ichFst;
            TxtMatRange := TRUE;
            EXIT(TxtMatRange);
           END;
        IF matLine = tr^.rLstLine
          THEN matLine := NIL
          ELSE matLine := matLine^^.lNext;
      END;
  TxtMatRange := FALSE;
END;


{$S imph }
FUNCTION  TxtTstRange(patChad: TChad; tr: TPTxtRange): TF;
VAR matAchad: TAchad;
    matLen, patLen: TC;
    patRgch, matRgch: TRgch;
    matLine: THIMSLine;
    matPos: TC;
BEGIN
  IF fTstPat THEN
    BEGIN
      WRITELN('TxtTstRange');
      PrintRange(tr);
      WRITE('patChad: ');
      PrintChad(patChad);
    END;
  WITH patChad^ DO
    BEGIN
      patLen := ichLim - ichFst;
      patRgch := @rgch^[ichFst];
    END;
  matLine := tr^.rFstLine;
  matPos := tr^.rFstPos;
  IF matLine = tr^.rLstLine
    THEN matLen := tr^.rLstPos - matPos
    ELSE matLen := LineCCount(matLine) - matPos;
  IF patLen > matLen
    THEN BEGIN
      IF fTstPat THEN
        WRITELN('TxtTstRange fails because pattern is bigger than match line.');
      TxtTstRange := FALSE;
      EXIT(TxtTstRange);
     END;
  matRgch := LineChars(matLine);
  IF TstTxtRgch(patRgch, @matRgch^[matPos], patLen)
    THEN BEGIN
      TxtTstRange := TRUE;
      tr^.rFstPos := matPos + patLen; { bump mat pos past matched text. }
      IF fTstPat THEN WRITELN('TxtTstRange successful');
     END
    ELSE BEGIN
      IF fTstPat THEN WRITELN('TxtTstRange fails to match');
      TxtTstRange := FALSE;
     END;
END;


{$S imph }
FUNCTION  StartPat(pr: TPPatRec): TF;
VAR pch: CHAR;
BEGIN
  WITH pr^ DO
    BEGIN
      pch := GetPatChar(pr);
      IF pch <> '<'
        THEN BEGIN
          PatError(pr, CInvPatStart, pch);
          IF fTstPat
            THEN WRITELN('Looking for pattern start (<). found: ', pch);
          BumpPatPos(pr, -1);
          StartPat := FALSE;
         END
        ELSE StartPat := TRUE;
    END;
END;


{$S imph }
PROCEDURE EatPatArg(pr: TPPatRec);
LABEL 100, 200, 900;
VAR pch: CHAR;
    endCh: CHAR;
    pLim: TC;
BEGIN
     pch := GetPatChar(pr);
     IF pch = '['
       THEN endCh := ']'
       ELSE IF pch = '<'
              THEN endCh := '>'
              ELSE BEGIN endCh := ')'; BumpPatPos(pr, -1); END;
100: pch := GetPatChar(pr);
200: IF pch = endCh THEN
       BEGIN
         IF endCh <> ')'
           THEN BEGIN
             pch := GetPatChar(pr);
             IF pch = ')'
               THEN GOTO 900;
             GOTO 200;
            END
           ELSE GOTO 900;
       END;
     GOTO 100;
900:
END;


{$S imph }
PROCEDURE EatPat(pr: TPPatRec);
VAR patLevel: TC;
    pch: CHAR;
BEGIN
  patLevel := 1;
  WHILE pr^.PPatPos < pr^.PPatLen  DO
    BEGIN
      pch := GetPatChar(pr);
      IF pch = '>'
        THEN BEGIN
          patLevel := patLevel - 1;
          IF patLevel = 0
            THEN BEGIN
              IF fTstPat
                THEN BEGIN WRITELN('Pattern Skipped.'); PrtPat(pr); END;
              EXIT(EatPat);
             END;
         END
        ELSE IF pch = '<'
          THEN PatLevel := patLevel + 1
          ELSE IF pch = '(' THEN EatPatArg(pr);
    END;
  IF fTstPat THEN WRITELN('Ran out of pattern in EatPat');
  IF pr^.PFailCode = 0 THEN PatError(pr, CAteWholePat, CHR(0));
END;


{$S impo }
FUNCTION ObjName(pr: TPPatRec; VAR nameStr: TStr40): TC;
VAR nameCt: TC;
    oidx: TC;
BEGIN
  IF NOT GetPatStr(pr, @nameStr, 40)
    THEN BEGIN ObjName := CNilObjIdx; nameStr := ''; EXIT(ObjName); END
    ELSE IF fTstPat THEN WRITELN('nameStr set to: ', nameStr);
  IF NOT PatIntArg(pr, nameCt)
    THEN nameCt := -1
    ELSE IF sDebug THEN
      WRITELN('Object name count for not most recent object unimplemented');
  oidx := NamedObjIdx(curObjTable, nameStr);
  IF fTstPat THEN
    WRITELN('ObjName returns "', namestr, '" index = ', oidx);
  ObjName := oidx;
END;


{$S impt }
FUNCTION  TxtSkipChar(tr: TPTxtRange): TF;
LABEL 300;
VAR matPos, matLst: TC;
    matLine: THIMSLine;
BEGIN
  IF fTstPat THEN
    BEGIN
      WRITELN('TxtSkipChar');
      PrintRange(tr);
    END;
  matLine := tr^.rFstLine;
  matPos := tr^.rFstPos;
300: IF matLine = tr^.rLstLine
       THEN matLst := tr^.rLstPos
       ELSE matLst := LineCCount(matLine);
  IF matLst > matPos
    THEN BEGIN
      tr^.rFstPos := matPos + 1;
      tr^.rFstLine := matLine;
      TxtSkipChar := TRUE;
      IF fTstPat THEN WRITELN('TxtSkipChar returns TRUE');
     END
    ELSE BEGIN
     IF matLine = tr^.rLstLine
       THEN BEGIN
         TxtSkipChar := FALSE;
         IF fTstPat THEN WRITELN('TxtSkipChar returns FALSE');
        END
       ELSE BEGIN
         matLine := matLine^^.lNext;
         matPos := 0;
         IF fTstPat THEN WRITELN('TxtSkipChar trying next line in TextRange');
         GOTO 300;
        END;
     END;
END;


{$S impt }
PROCEDURE FreeSelLine(fLine: THIMSLine);
BEGIN
  IF fTstPat THEN WRITELN('FreeSelLine (',  ORD(fLine), ')');
  IF fLine <> NIL THEN
     FreeBk(StrHeap, POINTER(ORD(fLine)), tyBkStd);
END;


{$S impt }
FUNCTION MakeSelLine(pr: TPPatRec; lrgch: TRgch; len: TC): THIMSLine;
  { this is patterned on NewTextLine to create a
    dummy line which is NOT in IMStr }
VAR
  newLine: THIMSLine;
  i: TC;
BEGIN
  IF fTstPat THEN BEGIN WRITE('MakeSelLine (',  len:3, ')- ');
       for i := 0 to (len - 1) do WRITE(chr(lrgch^[i])); WRITELN; END;
  newLine := POINTER(ORD(HAllocate(StrHeap, SIZEOF(TImsLine)+len)));
  newLine^^.lType := CTxtLine;
  newLine^^.lIdx := NxtLnIdx;
  newLine^^.lNext := NIL;
  newLine^^.lHt := 0;
  newLine^^.lVDsp := newline^^.lHt;
  newLine^^.txt.tChrCt := len;
  newLine^^.txt.tIndent := 0;
  newLine^^.txt.tFontIdx := 1;
  MoveRgch(@newLine^^.txt.tChars, lrgch, len);
  MakeSelLine := newLine;
END;


{$S impt }
PROCEDURE MakeLnVar(selLine: THIMSLine; varName: TKeyStr; fstPos: TC);
VAR
  lnStr: Str255;
  varRgch: TRgch;
  strLen: TC;
  i: TC;
BEGIN
  IF fTstPat
    THEN BEGIN
      WRITELN('MakeLnVar var "',  varName, '" first pos: ', fstPos);
      WRITE(' line text "');
      for i := 0 to (selLine^^.txt.tChrCt - 1)
        do WRITE(chr(selLine^^.txt.tChars[i]));
      WRITELN('"');
     END;
  strLen := LineCCount(selLine)-fstPos;
  varRgch := LineChars(selLine);
  IF varRgch = NIL THEN strLen := 0;
  IF strLen <= 0
    THEN strLen := 0
    ELSE MoveRgch(POINTER(ORD(@lnStr)+1),
                  POINTER(ORD(varRgch) + fstPos), strLen);
  WHILE (strLen > 0) AND (lnStr[strLen] = ' ') DO strLen := strLen - 1;
    { squeeze off trailing blanks }
  lnStr[0] := chr(strLen);
  IF fTstPat THEN WRITELN(' varStr set to "', lnStr, '", length=', strLen:4);
  SetStrVar(varName, lnStr);
END;



{$S impt }
FUNCTION  MatTxt(pr: TPPatRec; fRange: TPTxtRange; fInitSrch: TF): TC;
VAR patAchad: TAchad;
    fSearch, txtMatDone: TF;
    txtMatCode: TC;
    pch: CHAR;
    varName: TKeyStr;
BEGIN { MatTxt matches a text pattern. }
  txtMatCode := -1;
  IF StartPat(pr) THEN
    BEGIN
      fSearch := fInitSrch;
      REPEAT
        pch := GetPatChar(pr);
        CASE pch OF
            '>': BEGIN
                   txtMatCode := 0;
                   IF fTstPat THEN WRITELN('Text match successful');
                 END;
            '(': IF TxtPatChad(pr, @patAchad)
                   THEN BEGIN
                     IF fSearch
                       THEN BEGIN
                         IF TxtMatRange(@patAchad, fRange)
                           THEN fSearch := FALSE
                           ELSE txtMatCode := MatchFail(pr, CTxRngMatchFailure);
                        END
                       ELSE BEGIN
                         IF TxtTstRange(@patAchad, fRange)
                           THEN fSearch := FALSE
                           ELSE txtMatCode := MatchFail(pr, CTxRngTestFailure);
                        END;
                    END
                   ELSE PatError(pr, CInvTxStringInTxtPat, CHR(0));
            '-': IF NOT TxtSkipChar(fRange)
                    THEN txtMatCode := MatchFail(pr, CTxSkipFail);
            '*': fSearch := TRUE;
            '+': fSearch := TRUE;
            'V', 'v': BEGIN
                        IF GetPatStr(pr, @varName, CKeySize)
                          THEN MakeLnVar(fRange^.rFstLine, varName,
                                         fRange^.rFstPos)
                          ELSE PatError(pr, CInvVarNameInTxtPat, CHR(0));
                      END;
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
                 SetPartMat(pr, pch);
            OTHERWISE PatError(pr, CInvTxPat, pch);
         END;
      UNTIL (pr^.PPatFail OR (txtMatCode >= 0));
      IF txtMatCode < 0 THEN
        BEGIN
          IF fTstPat THEN WRITELN('Eating rest of text pattern.');
          EatPat(pr);
        END;
    END;
  MatTxt := txtMatCode;
END;


{$S impt }
FUNCTION  MatSrcTxt(pr: TPPatRec): TC;
VAR fRange: TTxtRange;
BEGIN { Sets up for MatTxt with a source text range. }
  WITH pr^ DO
    BEGIN
      fRange.rFstLine := PTxFstLine;
      fRange.rLstLine := PTxLstLine;
      fRange.rFstPos := 0;
      fRange.rLstPos := LineCCount(fRange.rLstLine);
      MatSrcTxt := MatTxt(pr, @fRange, TRUE);
    END;
END;


{$S impt }
FUNCTION  MatSelTxt(pr: TPPatRec; selEvt: TPSelRec; selTxPos: TC): TC;
VAR fRange: TTxtRange;
    matLine: THIMSLine;
    selTxtCode, savePatPos: TC;
BEGIN { Sets up for MatTxt with a selection text range. }
  matLine := MakeSelLine(pr, @selEvt^.SelLnData, selEvt^.SelLnLen);
  savePatPos := pr^.PPatPos;
  pr^.PPatPos := selTxPos;
  fRange.rFstLine := matLine;
  fRange.rLstLine := matLine;
  fRange.rFstPos := selEvt^.SelInt.lpFst;
  fRange.rLstPos := selEvt^.SelInt.lpLim;
  selTxtCode := MatTxt(pr, @fRange, FALSE);
  pr^.PPatPos := savePatPos;
  IF selTxtCode = 0
      THEN BEGIN
        IF fTstPat THEN WRITELN('MatSelTxt succeeds.  Text range now is:');
        IF fTstPat THEN PrintRange(@fRange);
       END;
  IF fTstPat THEN WRITELN('MatSelTxt returns:', selTxtCode:4,
                          '  PatPos reset to:', pr^.PPatPos);
  FreeSelLine(matLine);
  MatSelTxt := selTxtCode;
END;


{$S impt }
FUNCTION  MatPriorTxt(pr: TPPatRec; selEvt: TPSelRec; priorTxPos: TC): TC;
VAR fRange: TTxtRange;
    matLine: THIMSLine;
    priorTxtPos, savePatPos: TC;
BEGIN { Sets up for MatTxt with a selection text range. }
  matLine := MakeSelLine(pr, @selEvt^.SelLnData, selEvt^.SelLnLen);
  savePatPos := pr^.PPatPos;
  pr^.PPatPos := priorTxPos;
  fRange.rFstLine := matLine;
  fRange.rLstLine := matLine;
  fRange.rFstPos := 0;
  fRange.rLstPos := selEvt^.SelInt.lpFst;
  priorTxtCode := MatTxt(pr, @fRange, TRUE);
  pr^.PPatPos := savePatPos;
  IF priorTxtCode = 0
      THEN BEGIN
        IF fTstPat THEN WRITELN('MatPriorTxt succeeds.  Text range now is:');
        IF fTstPat THEN PrintRange(@fRange);
       END;
  IF fTstPat THEN WRITELN('MatPriorTxt returns:', priorTxtCode:4,
                          '  PatPos reset to:', pr^.PPatPos);
  FreeSelLine(matLine);
  MatPriorTxt := priorTxtCode;
END;


{$S impt }
FUNCTION  MatTrailTxt(pr: TPPatRec; selEvt: TPSelRec; trailTxPos: TC): TC;
VAR fRange: TTxtRange;
    matLine: THIMSLine;
    trailTxtCode, savePatPos: TC;
BEGIN { Sets up for MatTxt with a selection text range. }
  matLine := MakeSelLine(pr, @selEvt^.SelLnData, selEvt^.SelLnLen);
  savePatPos := pr^.PPatPos;
  pr^.PPatPos := trailTxPos;
  fRange.rFstLine := matLine;
  fRange.rLstLine := matLine;
  fRange.rFstPos := selEvt^.SelInt.lpLim;
  fRange.rLstPos := LineCCount(fRange.rLstLine);
  trailTxtCode := MatTxt(pr, @fRange, TRUE);
  pr^.PPatPos := savePatPos;
  IF trailTxtCode = 0
      THEN BEGIN
        IF fTstPat THEN WRITELN('MatTrailTxt succeeds.  Text range now is:');
        IF fTstPat THEN PrintRange(@fRange);
       END;
  IF fTstPat THEN WRITELN('MatTrailTxt returns:', trailTxtCode:4,
                          '  PatPos reset to:', pr^.PPatPos);
  FreeSelLine(matLine);
  MatTrailTxt := trailTxtCode;
END;


{$S imph }
FUNCTION  GetNxtEvtRec(ebr: TEBufRange; evtTp: TC): TPEvtRec;
VAR eRec, lstRec: TPEvtRec;
    eBuf: THEBufData;
    ePos: TC;
eCount: TC;
BEGIN
  IF ebr.bufStart = NIL
    THEN BEGIN
      WRITELN('No start buf pos in buf range.');
      GetNxtEvtRec := NIL;
      EXIT(GetNxtEvtRec);
     END;
  IF ebr.bufLim = NIL
    THEN lstRec := NIL
    ELSE lstRec := @ebr.bufLim^.PEBufData^^.BufData[ebr.bufLim^.PEBufPos];
  WITH ebr.bufStart^ DO
    BEGIN
      eBuf := PEBufData;
      ePos := PEBufPos;
eCount := 0;
      IF fTstPat THEN WRITE('GetNextEvtRec eBuf:', ORD(eBuf),
                               ' type:', evtTp:3, ' ePos:', ePos);
      REPEAT
eCount := eCount+1;
        IF ePos >= eBuf^^.BufPos
          THEN BEGIN
            eBuf := eBuf^^.NxtBuf;
            ePos := 0;
            IF eBuf = NIL
              THEN BEGIN
                GetNxtEvtRec := NIL;
                IF fTstPat THEN WRITELN(' none found');
                EXIT(GetNxtEvtRec);
               END
              ELSE IF fTstPat
                     THEN WRITELN('Switching to next eBuf:', ORD(eBuf));
           END;
        eRec := @eBuf^^.BufData[ePos];
        IF lstRec <> NIL
          THEN IF eRec = lstRec
            THEN BEGIN
              GetNxtEvtRec := NIL;
              IF fTstPat THEN WRITELN(' reached end');
              EXIT(GetNxtEvtRec);
             END;
        IF (eRec^.Evt.EvtSize <= 0) OR (eRec^.Evt.EvtSize >= 200)
          THEN BEGIN
            IF cDebug  { for now: } OR TRUE
              THEN BEGIN
                WRITELN('bad length event rec in evt buf.  eBuf:',
                        ORD(eBuf), ' ePos:', ePos);
                WRITELN('  EvtRec count:', eCount, ' eSize:', eRec^.evt.evtSize);
                Brk(776);
               END;
            GetNxtEvtRec := NIL;
            EXIT(GetNxtEvtRec);
          END;
        ePos := ePos + eRec^.Evt.EvtSize;
      UNTIL eRec^.Evt.EvtType = evtTp;
      PEBufData := eBuf;
      PEBufPos := ePos;
      IF fTstPat THEN WRITELN(' found', ORD(eRec));
      GetNxtEvtRec := eRec;
    END;
END;


{$S impt }
PROCEDURE GetKeyEvtBuf(ebr: TEBufRange; hkb: THKeyBuf);
LABEL 900;
VAR keyEvt: TPKeyRec;
BEGIN
  WHILE TRUE DO
    BEGIN
    keyEvt := POINTER(ORD(GetNxtEvtRec(ebr, CTKeyEvt)));
    IF keyEvt = NIL THEN GOTO 900;
    IF (keyEvt^.keyCh = bsKey)
      THEN WITH hkb^^ DO BEGIN
        IF keyEvt^.KeyShift
         THEN BEGIN
           IF kbFst < kbLim THEN kbFst := kbFst + 1; { this is a forwardspace. }
IF fTstPat THEN BEGIN WRITELN('doing forwardspace'); PrintKeyBuf(hkb); END;
          END
         ELSE BEGIN
           IF kbFst > 0 THEN kbFst := kbFst - 1; { this is a backspace. }
IF fTstPat THEN BEGIN WRITELN('doing backspace'); PrintKeyBuf(hkb); END;
          END;
       END
      ELSE WITH hkb^^ DO BEGIN
         IF kbFst = kbLen THEN ResizeKeyBuf(hkb, CKeyBufLen);
         kbRgch^^[kbFst] := keyEvt^.KeyCh;
         kbFst := kbFst + 1;
         kbLim := kbFst;
IF fTstPat THEN
  BEGIN WRITELN('adding key:', CHR(keyEvt^.KeyCh)); PrintKeyBuf(hkb); END;
       END;
   END;
900: hkb^^.kbLim := hkb^^.kbFst;
     hkb^^.kbFst := 0;
     IF fTstPat THEN
       BEGIN WRITE('GetKeyEvtBuf:'); PrintRgch(hkb^^.kbRgch^, hkb^^.kbLim); END;
END;


{$S impt }
FUNCTION KbdStr; { (pstr: TPStr255; maxlen: TC): TC; }
VAR ebr: TEBufRange;
    ebpos: TEBufPos;
    hkb: THKeyBuf;
    strLen: TC;
BEGIN { Sets pstr to be the edited string of recorded typed chars }
  hkb := NewKeyBuf(0);  { default value }
  ebr.bufStart := @ebpos;
  ebr.bufLim := NIL;
  ebpos.PEBuf := curEvtBuf;
  ebpos.PEBufData := NIL;
  ebpos.PEBufData := ebpos.PEBuf^^.FirstBuf;
  ebpos.PEBufPos := 0;
  GetKeyEvtBuf(ebr, hkb);
  WITH hkb^^ DO strLen := kbLim - kbFst;
  IF strLen > maxLen
    THEN BEGIN
      IF IMtst THEN
        WRITELN('Too many chars typed for variable. truncated to:', maxLen:4);
      strLen := maxLen;
     END;
  pstr^[0] := CHR(strLen);
  MoveRgch(POINTER(ORD(pstr)+1), hkb^^.kbRgch^, strLen);
  IF fTstPat THEN WRITELN('KbdStr sets', ORD(pstr), ' to ', pstr^);
  FreeKeyBuf(hkb);
  KbdStr := strLen;
END;


{$S impt }
FUNCTION  MatEdKeyTxt(pr: TPPatRec; ebr: TEBufRange; ekTxPos: TC): TC;
VAR fRange: TTxtRange;
    matLine: THIMSLine;
    hkb: THKeyBuf;
    ekTxtCode: TC;
BEGIN { Sets up for MatTxt with a selection text range. }
  hkb := NewKeyBuf(0);  { default value }
  GetKeyEvtBuf(ebr, hkb);
  WITH hkb^^ DO
    matLine := MakeSelLine(pr, kbRgch^, kbLim);
  pr^.PPatPos := ekTxPos;
  fRange.rFstLine := matLine;
  fRange.rLstLine := matLine;
  fRange.rFstPos := hkb^^.kbFst;
  fRange.rLstPos := hkb^^.kbLim;
  ekTxtCode := MatTxt(pr, @fRange, FALSE);
  IF fTstPat THEN WRITELN('MatSelTxt returns:', ekTxtCode:4,
                          '  PatPos reset to:', pr^.PPatPos);
  FreeKeyBuf(hkb);
  FreeSelLine(matLine);
  MatEdKeyTxt := ekTxtCode;
END;


{$S impt }
FUNCTION TstKStrChad(kstr: TKeyStr; tstChad: TChad): TF;
LABEL 777, 900;
VAR i, chLen: TC;
    crgch, krgch: TRgch;
BEGIN
  chLen := tstChad^.ichLim - tstChad^.ichFst;
  IF fTstPat THEN WRITELN('TstKStrChad  KeyStr: ', kstr, ' tstChad len = ', chLen:3);
  IF fTstPat THEN PrintChad(tstChad);
  IF chLen <> LENGTH(kstr)
    THEN BEGIN
      IF fTstPat THEN WRITELN('TstKStrChad = FALSE for unequal length');
      GOTO 777;
     END
    ELSE BEGIN
       krgch := POINTER(ORD(@kstr) + 1);
       crgch := @tstChad^.rgch^[tstChad^.ichFst];
       FOR i := 0 TO chLen-1 DO
         IF krgch^[i] <> crgch^[i]
           THEN BEGIN
             IF fTstPat THEN
               WRITELN('TstKStrChad = FALSE strings differ at position', i:5);
             GOTO 777;
            END;
       IF fTstPat THEN WRITELN('TstKStrChad = TRUE');
       TstKStrChad := TRUE;
       GOTO 900;
     END;
777:
  TstKStrChad := FALSE;
900:
END;


{$S impw }
FUNCTION  MatMen(pr: TPPatRec; ebr: TEBufRange): TC;
LABEL 300, 900;
VAR pch: CHAR;
    istr: TMStr;
    menEvt: TPCmdRec;
    menCode: TC;
    menTit, menItem: TAChad;
    hMenInfo: THMenuDInf;
    fGotTit, fGotItem: TF;

  FUNCTION  TestMenu: TF;
  BEGIN
    hMenInfo := GetIDMenu(menEvt^.CmdMenu);
    IF hMenInfo = NIL
      THEN BEGIN
        TestMenu := FALSE;
        IF fTstPat THEN WRITELN('Menu test fails - cant find menu info');
        EXIT(TestMenu);
       END;
    IF TstKStrChad(hMenInfo^^.mTitle, @menTit)
      THEN BEGIN
        GetItem(hMenInfo^^.mNameInfo^, menEvt^.CmdItem, @istr);
        IF TstKStrChad(istr, @menItem)
          THEN BEGIN
            IF fTstPat THEN WRITELN('TestMenu = TRUE');
            TestMenu := TRUE;
           END
          ELSE BEGIN
            IF fTstPat THEN WRITELN('TestMenu = FALSE - wrong menu item.');
            TestMenu := FALSE;
           END;
       END
      ELSE BEGIN
        IF fTstPat THEN WRITELN('Menu test fails - wrong menu');
        TestMenu := FALSE;
       END;
  END;

BEGIN { matches a menu pattern. }
  menCode := -1;
  IF StartPat(pr)
    THEN BEGIN
      REPEAT
        pch := GetPatChar(pr);
        CASE pch OF
          'T', 't':
            BEGIN
              IF  GetPatArg(pr, @menTit)
                THEN fGotTit := TRUE
                ELSE PatError(pr, CInvMenTit, CHR(0));
            END;
          'I', 'i':
            BEGIN
              IF  GetPatArg(pr, @menItem)
                THEN fGotItem := TRUE
                ELSE PatError(pr, CInvMenItem, CHR(0));
            END;
          ' ': BEGIN END;
          '>': GOTO 300;
          OTHERWISE PatError(pr, CInvMnPatChar, pch);
         END;
      UNTIL pr^.PPatFail;
      GOTO 900;  { found a pattern error above }
 300: IF NOT fGotTit
        THEN BEGIN
          PatError(pr, CNoMenTit, CHR(0));
          GOTO 900;
         END;
      IF NOT fGotItem
        THEN BEGIN
          PatError(pr, CNoMenItem, CHR(0));
          GOTO 900;
         END;
      REPEAT
        menEvt := POINTER(ORD(GetNxtEvtRec(ebr, CTCmdEvt)));
        IF menEvt = NIL
          THEN BEGIN
            menCode := MatchFail(pr, CNoMatMenuEvt);
           END
          ELSE IF TestMenu
            THEN BEGIN
              IF fTstPat
                THEN WRITELN('Matched menu event at evtRec pos:', ORD(menEvt));
              menCode := 0;
              GOTO 900;
             END;
      UNTIL (pr^.PPatFail OR (menCode >= 0));
    END;
900:
  MatMen := menCode;
  IF fTstPat THEN WRITELN('MatMen returns:', menCode);
END;


{$S impt }
FUNCTION TstKbdChar(keyCode, shftCode: TB; VAR skipCode: TC; ebr: TEBufRange): TC;
LABEL 900;
VAR keyEvt: TPKeyRec;
    tstKbdCode: TC;
  FUNCTION TestKey1: TF;
  BEGIN
  WITH keyEvt^ DO
    BEGIN
    IF (keyCode = KeyCh) OR (keyCode = CIgnoreChar) THEN
      IF ((shftCode = CShftIgnore) OR
          ((shftCode = CShftTrue) AND KeyShift) OR
          ((shftCode = CShftFalse) AND (NOT KeyShift)))
        THEN BEGIN
             TestKey1 := TRUE;
             IF fTstPat THEN WRITELN('TestKey1 passes for keyEvt:', ORD(keyEvt));
             EXIT(TestKey1);
             END;
      TestKey1 := FALSE;
      IF fTstPat THEN WRITELN('TestKey1 fails for keyEvt:', ORD(keyEvt));
    END;
  END;

  FUNCTION TestKey: TF;
  BEGIN
    WITH keyEvt^ DO
      BEGIN
        IF (keyCode <> keyCh) AND (keyCode <> CIgnoreChar)
          THEN BEGIN
            IF fTstPat THEN
             WRITELN('keyCode', keyCode:4, ' doesnt match keyEvt', keyCh);
            TestKey := FALSE;
           END
          ELSE BEGIN
            IF shftCode = CShftTrue
              THEN BEGIN
                IF NOT KeyShift
                  THEN BEGIN
                    IF fTstPat THEN
                      WRITELN('TestKey fails because keyEvt not shifted.');
                    TestKey := FALSE;
                   END;
               END
              ELSE IF shftCode = CShftFalse
                THEN BEGIN
                  IF  KeyShift
                    THEN BEGIN
                      IF fTstPat THEN
                        WRITELN('TestKey fails because keyEvt is shifted.');
                      TestKey := FALSE;
                     END;
                 END;
            END;
      END;
  END;

BEGIN
     tstKbdCode := -1;
     IF fTstPat THEN WRITELN('TstKbdChar:', keyCode, shftCode, skipCode);
     IF fTstPat THEN PrtBufRange(ebr);
     REPEAT
       keyEvt := POINTER(ORD(GetNxtEvtRec(ebr, CTKeyEvt)));
       IF keyEvt = NIL
         THEN BEGIN
           tstKbdCode := MatchFail(NIL, CTstKbd1NoMoreKeyEvts);
           GOTO 900;
          END
         ELSE IF TestKey OR TestKey1
           THEN BEGIN
             tstKbdCode := 0;
             GOTO 900;
            END;
       IF skipCode = 0
         THEN BEGIN
           tstKbdCode := MatchFail(NIL, CTstKbd2CantSkipKey);
           GOTO 900;
          END
         ELSE IF skipCode > 0 THEN skipCode := skipCode - 1;
     UNTIL tstKbdCode >= 0;
900: TstKbdChar := tstKbdCode;
     IF tstKbdCode = 0 THEN skipCode := 0; { skip has been used up }
     IF fTstPat THEN WRITELN('TstKbdChar returns code:', tstKbdCode:4);
END;


{$S impt }
FUNCTION MatKbd(pr: TPPatRec; ebr: TEBufRange; srchCode: TC): TC;
LABEL 800;
VAR pch: CHAR;
    matKbdCode: TC;
    i: TC;
    patAchad: TAchad;
BEGIN
  matKbdCode := 0;
  IF NOT StartPat(pr) THEN matKbdCode := -1
    ELSE BEGIN
      REPEAT
        pch := GetPatChar(pr);
        IF fTstPat THEN
          WRITELN('MatKbd char: ', pch, ORD(pch), ' srchCode:', srchCode);
        CASE pch OF
          'b': matKbdCode := tstKbdChar(CBackSpace, CShftFalse, srchCode, ebr);
          'B': matKbdCode := tstKbdChar(CBackSpace, CShftTrue, srchCode, ebr);
          '-': matKbdCode := tstKbdChar(CIgnoreChar, CShftIgnore, srchCode, ebr);
          '>': GOTO 800;
          '(': IF TxtPatChad(pr, @patAchad)
                 THEN BEGIN
                   FOR i := patAchad.ichFst TO patAchad.ichLim - 1 DO
                     BEGIN
                       matKbdCode := tstKbdChar(patAchad.rgch^[i],
                                                CShftIgnore, srchCode, ebr);
                       IF matKbdCode <> 0 THEN GOTO 800;
                     END;
                  END
                 ELSE PatError(pr, CInvKbStringInTxtPat, CHR(0));
          '*': srchCode := -1;
          '+': IF srchCode >= 0 THEN srchCode := srchCode + 1;
          '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
               SetPartMat(pr, pch);
          OTHERWISE PatError(pr, CInvKbdPatChar, pch);
         END;
      UNTIL (pr^.PPatFail OR (matKbdCode <> 0));
    END;
800:
  IF (matKbdCode = 0) AND pr^.PPatFail THEN matKbdCode := -1;
  IF fTstPat THEN WRITELN('MatKbd returns code', matKbdCode:4);
  MatKbd := matKbdCode;
END;


{$S impt }
FUNCTION MatSelRec(pr: TPPatRec; ebr: TEBufRange; selRecPos: TC): TC;
LABEL 800;
VAR pch: CHAR;
    savePatPos: TC;
    matSelCode: TC;
BEGIN
  matSelCode := 0;
  savePatPos := pr^.PPatPos;
  pr^.PPatPos := selRecPos;
IF fTstPat THEN WRITELN('MatSelRec evt buf range.');
IF fTstPat THEN PrtBufRange(ebr);
  IF StartPat(pr)
    THEN BEGIN
      REPEAT
        pch := GetPatChar(pr);
        CASE pch OF
          'E', 'e': matSelCode := MatKbd(pr, ebr, 0);
          'K', 'k': matSelCode := MatEdKeyTxt(pr, ebr, pr^.PPatPos);
          'M', 'm': matSelCode := MatMen(pr, ebr);
          '>': GOTO 800;
          OTHERWISE PatError(pr, CInvSelRecPatChar, pch);
         END;
        IF (matSelCode = 0) AND pr^.PPatFail THEN matSelCode := -1;
      UNTIL matSelCode <> 0;
     END
    ELSE matSelCode := -1;
800: pr^.PPatPos := savePatPos;
    IF fTstPat THEN WRITELN('MatSelRec returns code', matSelCode:4);
    MatSelRec := matSelCode;
END;


{$S impt }
FUNCTION  MatSel(pr: TPPatRec): TC;
LABEL 300, 700;
VAR pch: CHAR;
    selEvt, nxtSelEvt: TPSelRec;
    prFstBufPos: TEBufPos;
    selFstBufPos: TEBufPos;
    selEbr: TEbufRange;
    selMatCode: TC;
    MatLevel: TC;
    selTxPos, priorTxPos, trailTxPos, selRecPos, selEndPos: TC;
    fTstSelLvl: TF;
    fTstAdjust: TF;

  FUNCTION  TestSel: TF;
  BEGIN
    IF fTstSelLvl THEN
      IF selEvt^.SelLevel <> MatLevel
        THEN BEGIN
          TestSel := FALSE;
          EXIT(TestSel);
         END;
    IF fTstAdjust THEN
      IF NOT selEvt^.SelAdjust
        THEN BEGIN
          TestSel := FALSE;
          EXIT(TestSel);
         END;
    IF selTxPos >= 0
      THEN IF MatSelTxt(pr, selEvt, selTxPos) <> 0
        THEN BEGIN
          TestSel := FALSE;
          EXIT(TestSel);
         END;
    IF priorTxPos >= 0
      THEN IF MatPriorTxt(pr, selEvt, priorTxPos) <> 0
        THEN BEGIN
          TestSel := FALSE;
          EXIT(TestSel);
         END;
    IF trailTxPos >= 0
      THEN IF MatTrailTxt(pr, selEvt, trailTxPos) <> 0
        THEN BEGIN
          TestSel := FALSE;
          EXIT(TestSel);
         END;
    IF selRecPos >= 0
      THEN IF MatSelRec(pr, selEbr, selRecPos) <> 0
        THEN BEGIN
          TestSel := FALSE;
          EXIT(TestSel);
         END;
    { no test for recorded events during selection yet. }
    TestSel := TRUE;
END;

BEGIN { matches a selection pattern}
  fTstSelLvl := FALSE;
  fTstAdjust := FALSE;
  selTxPos := -1;
  priorTxPos := -1;
  trailTxPos := -1;
  selRecPos := -1;
  selEndPos := -1;
  selMatCode := 0;
  MatLevel := ORD(tySelPt);
  IF fTstPat THEN WRITELN('Matching selection pat from pat pos:', pr^.PPatPos);
  IF NOT StartPat(pr)
    THEN MatSel := -1
    ELSE BEGIN
      REPEAT
        pch := GetPatChar(pr);
        CASE pch OF
          'I', 'i':
            BEGIN
              MatLevel := ORD(tySelPt);
              fTstSelLvl := TRUE;
              IF fTstPat THEN WRITELN('MatLvl set to tySelPt:', ORD(tySelPt));
            END;
          'C', 'c':
            BEGIN
              MatLevel := tySelCh;
              fTstSelLvl := TRUE;
              IF fTstPat THEN WRITELN('MatLvl set to tySelCh:', tySelCh);
            END;
          'W', 'w':
            BEGIN
              MatLevel := ORD(tySelWd);
              fTstSelLvl := TRUE;
              IF fTstPat THEN WRITELN('MatLvl set to tySelWd:', ORD(tySelWd));
            END;
          'L', 'l':
            BEGIN
              MatLevel := ORD(tySelPar);
              fTstSelLvl := TRUE;
              IF fTstPat THEN WRITELN('MatLvl set to tySelPar:', ORD(tySelPar));
            END;
          'A', 'a':
            BEGIN
              fTstAdjust := TRUE;
              IF fTstPat THEN WRITELN('Checking for adjusted selection.');
            END;
          'T', 't':
            BEGIN
              selTxPos := pr^.PPatPos;
              IF fTstPat THEN WRITELN('selTxPos set to:', selTxPos);
              IF StartPat(pr) THEN EatPat(pr);
            END;
          'P', 'p':
            BEGIN
              priorTxPos := pr^.PPatPos;
              IF fTstPat THEN WRITELN('priorTxPos set to:', priorTxPos);
              IF StartPat(pr) THEN EatPat(pr);
            END;
          'X', 'x':
            BEGIN
              trailTxPos := pr^.PPatPos;
              IF fTstPat THEN WRITELN('trailTxPos set to:', trailTxPos);
              IF StartPat(pr) THEN EatPat(pr);
            END;
          'R', 'r':
            BEGIN
              selRecPos := pr^.PPatPos;
              IF fTstPat THEN WRITELN('selRecPos set to:', selRecPos);
              IF StartPat(pr) THEN EatPat(pr);
            END;
          ' ': BEGIN END;
          '>': GOTO 300;
          OTHERWISE PatError(pr, CInvSlPatChar, pch);
         END;
      UNTIL pr^.PPatFail;
      IF fTstPat THEN
        WRITELN('Pattern error in MatSel pattern. skip to pattern end.');
      EatPat(pr);
      selMatCode := -1;
      IF fTstPat THEN WRITELN('MatSel returns:', selMatCode);
      MatSel := selMatCode;
      EXIT(MatSel);

 300: selEndPos := pr^.PPatPos;
      prFstBufPos := pr^.PEBufRange.bufStart^;
      selEbr.bufStart := @selFstBufPos;
      selEvt := POINTER(ORD(GetNxtEvtRec(pr^.PEBufRange, CTSelEvt)));
      REPEAT
        IF selEvt = NIL
          THEN selMatCode := MatchFail(pr, CNoMatSelEvt)
          ELSE BEGIN
            selEbr.bufStart^ := pr^.PEBufRange.bufStart^;
            nxtSelEvt := POINTER(ORD(GetNxtEvtRec(pr^.PEBufRange, CTSelEvt)));
            IF nxtSelEvt <> NIL
              THEN selEbr.bufLim := pr^.PEBufRange.bufStart
              ELSE selEbr.bufLim := NIL;
            IF TestSel
              THEN BEGIN
                IF fTstPat THEN
                     WRITELN('Matched selection: type  ', ORD(MatLevel),
                              ' at evtRec pos:', ORD(selEvt));
                GOTO 700;
               END;
            selEvt := nxtSelEvt;
           END;
      UNTIL (pr^.PPatFail OR (selMatCode <> 0));
      IF fTstPat THEN WRITELN('Cant match select event. MatSel fails.');
      IF pr^.PPatFail AND (selMatCode = 0) THEN selMatCode := -1;
 700: pr^.PPatPos := selEndPos;
      IF selMatCode = 0
        THEN pr^.PEBufRange.bufStart^ := selEbr.bufStart^
        ELSE pr^.PEBufRange.bufStart^ := prFstBufPos;
      IF fTstPat THEN WRITELN('MatSel returns:', selMatCode);
      MatSel := selMatCode;
    END;
END;


{$S impo }
FUNCTION FixObjName(VAR fixObjStr:TStr40; objIdx:TC): TF;
VAR pAObjRec: TPAObj;
    fixObj: ObjectHandle;
    oldName: TStr40;
    varName: TKeyStr;
BEGIN
  pAObjRec := POINTER(ORD(NthSrchTableRec(curObjTable, objIdx)));
  IF fTstPat THEN IF (pAObjRec <> NIL) THEN
      WRITELN('Changing obj "', pAObjRec^.toName, '" to "', fixObjStr, '"');
  IF pAObjRec <> NIL
    THEN BEGIN
      fixObj := GetNameObj(pAobjRec^.toName, FALSE);
      IF fixObj <> nilObject
        THEN BEGIN
          varName := 'OldName';
          oldName := fixObj^^.name;
          SetStrVar(varName, oldName);
          varName := 'FixName';
          SetBoolVar(varName, TRUE);
          IFRename(fixObj, fixObjStr);
          pAObjRec^.toName := fixObjStr;
          FixObjName := TRUE;
          EXIT(FixObjName);
         END
        ELSE IF fTstPat THEN
           WRITELN('Cant find real obj "', pAobjRec^.toName,
                   '" to rename to "', fixObjStr, '"');
     END;
  IF fTstPat THEN
    WRITELN('Cant find table obj to rename to "', fixObjStr, '"');
  FixObjName := FALSE;
END;


{$S impo }
FUNCTION ChkObjName(VAR curObj:TStr40; objIdx:TC): TF;
VAR pAObjRec: TPAObj;
BEGIN
   ChkObjName := FALSE;
   pAObjRec := POINTER(ORD(NthSrchTableRec(curObjTable, objIdx)));
IF fTstPat THEN IF (pAObjRec <> NIL) THEN
  WRITELN('Checking for obj "', pAObjRec^.toName, '" same as "', curObj, '"');
   IF pAObjRec <> NIL
     THEN BEGIN
       IF LENGTH(curObj) = LENGTH(pAObjRec^.toName)
         THEN IF TstTxtRgch(POINTER(ORD(@curObj)+1),
                     POINTER(ORD(@pAObjRec^.toName)+1), LENGTH(curObj))
            THEN ChkObjName := TRUE;
      END;
END;


{$S impo }
FUNCTION FindObjEvt(VAR curObj: TStr40; obOp: TB; objEbr: TEBufRange): TPObjRec;
VAR svBufStart: TEBufPos;
    objEvt: TPObjRec;
BEGIN
  svBufStart := objEbr.bufStart^;
  WHILE TRUE DO BEGIN
    objEvt := POINTER(ORD(GetNxtEvtRec(objEbr, CTObjEvt)));
    IF objEvt = NIL
      THEN BEGIN
        FindObjEvt := NIL;
        objEbr.bufStart^ := svBufStart;
        IF fTstPat THEN
          WRITELN('Cant find ', ObjOpArray[obOp], ' for obj "',
                     curObj, '" -FindObjEvt');
        EXIT(FindObjEvt);
      END;
    IF obOp = objEvt^.objOp THEN BEGIN
      IF obOp = CObjDslAll
        THEN BEGIN
          IF fTstPat THEN
            WRITELN('Found ', ObjOpArray[obOp], ' -FindObjEvt');
          FindObjEvt := objEvt;
          EXIT(FindObjEvt);
         END;
      IF ChkObjName(curObj, objEvt^.objIdx)
        THEN BEGIN
          IF fTstPat THEN
            WRITELN('Found ', ObjOpArray[obOp], ' for obj "',
                     curObj, '" -FindObjEvt');
          FindObjEvt := objEvt;
          EXIT(FindObjEvt);
         END;
     END;
  END;
END;


{$S impo }
FUNCTION TestObjInt(objIntNum, objIntVar, objIntErr: TC; VAR curObj: TStr40;
                    obOp: TB; objEbr: TEBufRange; objEvt: TPObjRec): TPObjRec;
LABEL 100,300;
VAR svBufStart: TEBufPos;
    testInt: TC;
BEGIN
  svBufStart := objEbr.bufStart^;
  IF objEvt <> NIL
    THEN IF (obOp = objEvt^.objOp) THEN IF ChkObjName(curObj, objEvt^.objIdx)
        THEN GOTO 100;
  GOTO 300;
100:
    IF objEvt = NIL
      THEN BEGIN
        TestObjInt := NIL;
        objEbr.bufStart^ := svBufStart;
        EXIT(TestObjInt);
      END;
    IF objIntNum = 2 THEN testInt := objEvt^.ObjInt2
      ELSE testInt := objEvt^.ObjInt1;
    IF ValInRange(testInt, objIntVal, objIntErr)
      THEN BEGIN
       TestObjInt := objEvt;
  IF fTstPat THEN  { for debugging only?? }
   WRITELN('Found ', ObjOpArray[obOp], ' (', objIntNum:1, ') for obj "',
    curObj, '" in range:', objIntVal:6, '+/-', objIntErr:4, ' -TestObjInt');
       TestObjInt := objEvt;
       EXIT(TestObjInt);
      END
      ELSE BEGIN
       IF fTstPat THEN
        WRITELN(ObjOpArray[obOp], ' (', objIntNum:1, ') event for obj "',
     curObj, '" not in range:', objIntVal:6, '+/-', objIntErr:4, ' -TestObjInt');
      END;
300:
    objEvt := FindObjEvt(curObj, obOp, objEbr);
    GOTO 100;
END;


{$S impo }
FUNCTION TestObjName(VAR tstObj, curObj: TStr40; obOp: TB; objEbr: TEBufRange;
                    objEvt: TPObjRec; fFixName: TF): TPObjRec;
LABEL 100,300;
VAR svBufStart: TEBufPos;
    testInt: TC;
BEGIN
  svBufStart := objEbr.bufStart^;
  IF objEvt <> NIL
    THEN IF (obOp = objEvt^.objOp) THEN IF ChkObjName(curObj, objEvt^.ObjIdx)
        THEN GOTO 100;
  GOTO 300;
100:
    IF objEvt = NIL
      THEN BEGIN
        TestObjName := NIL;
        objEbr.bufStart^ := svBufStart;
        EXIT(TestObjName);
      END;
    IF ChkObjName(tstObj, ObjEvt^.ObjInt1)
      THEN BEGIN
  IF fTstPat THEN  { for debugging only?? }
   WRITELN('Found ', ObjOpArray[obOp], ' for obj "',
            curObj, '" into "', tstObj, '" -TestObjName');
       TestObjName := objEvt;
       EXIT(TestObjName);
      END
      ELSE BEGIN
        IF fFixName
         THEN BEGIN
           IF FixObjName(tstObj, objEvt^.ObjInt1)
             THEN BEGIN
               TestObjName := objEvt;
               EXIT(TestObjName);
              END
             ELSE IF fTstPat
                THEN WRITELN(ObjOpArray[obOp], ' event for obj "',
                   curObj, '" not fixed into "', tstObj, '" -TestObjName');
          END
         ELSE IF fTstPat
            THEN WRITELN(ObjOpArray[obOp], ' event for obj "',
                         curObj, '" not into "', tstObj, '" -TestObjName');
      END;
300:
    objEvt := FindObjEvt(curObj, obOp, objEbr);
    GOTO 100;
END;


{$S impo }
FUNCTION  MatObjSel(pr: TPPatRec; ebr: TEBufRange; endType: TC): TC;
VAR pch: CHAR;
    matCode: TC;
    objEvt: TPObjRec;
    objFstBufPos, objLstBufPos: TEBufPos;
    objSelEbr: TEBufRange;
    dselName: TStr40;
BEGIN
  matCode := 0;
  pch := GetPatChar(pr);
  IF pch <> '<'
    THEN BEGIN
      BumpPatPos(pr, -1);
     END
    ELSE BEGIN
      objSelEbr.bufStart := @objFstBufPos;  { copy ebr start into objSelEbr }
      objSelEbr.bufStart^ := ebr.bufStart^;
      objSelEbr.bufLim := ebr.bufLim;  {  save original ebr.bufLim }
      dselName := nilObject^^.name;
      objEvt := FindObjEvt(dselName, endType, objSelEbr);
                          { find obj deselect }
      IF objEvt <> NIL
        THEN BEGIN
          ebr.bufLim := @objLstBufPos;    { set ebr bufLim for ObjSelect Match }
          ebr.bufLim^ := objSelEbr.bufStart^;  { ebr pos of the deselect event }
         END;
      REPEAT
        pch := GetPatChar(pr);
        CASE pch OF
          'S', 's': matCode := MatSel(pr);
          'F', 'f': matCode := MatObj(pr, ebr);
          'T', 't': matCode := MatSrcTxt(pr);
          'M', 'm': matCode := MatMen(pr, ebr);
          'E', 'e': matCode := MatKbd(pr, ebr, 0);
          'K', 'k': matCode := MatEdKeyTxt(pr, ebr, pr^.PPatPos);
          ' ': BEGIN END;
          '>': BEGIN
                 matCode := 0;
                 IF fTstPat
                  THEN WRITELN('MatObjSel returns code: ', matCode);
                 ebr.bufLim := objSelEbr.bufLim; { restore original pattern ebr }
                 MatObjSel := matCode;
                 EXIT(MatObjSel);
               END;
          '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
               SetPartMat(pr, pch);
          OTHERWISE BEGIN
                      matCode := -1;
                      PatError(pr, CInvObSelPatChar, pch);
                    END;
         END;
      UNTIL matCode <> 0;
      { IF pr^.PPatFail THEN } EatPat(pr);
      IF (matCode = 0) AND (pr^.PPatFail) THEN matCode := -1;
     END;
  MatObjSel := matCode;
END;


{$S impo }
FUNCTION  MatObj;  { (pr: TPPatRec; patEbr: TEBufRange): TC; }
LABEL 700;
VAR pch, xch: CHAR;
    objEvt: TPObjRec;
    objFstBufPos, objLstBufPos: TEBufPos;
    objEbr: TEbufRange;
    objMatCode: TC;
    tstVal, tstErr: TC;
    curObj, tstObj: TStr40;
    curObjIdx: TC;
    varName: TKeyStr;
    fFixName: TF;

BEGIN { matches a folder object pattern}
  curObj := NameLisaGuide;
  objMatCode := 0;
  objEbr.bufStart := @objFstBufPos;
  objEbr.bufStart^ := patEbr.bufStart^;
  IF patEbr.bufLim = NIL
    THEN objEbr.bufLim := NIL
    ELSE BEGIN
        objEbr.bufLim := @objLstBufPos;
        objEbr.bufLim^ := patEbr.bufLim^;
      END;
  IF fTstPat THEN WRITELN('Matching object pat from pat pos:', pr^.PPatPos);
  IF NOT StartPat(pr)
    THEN MatObj := -1
    ELSE BEGIN
      REPEAT
        pch := GetPatChar(pr);
        CASE pch OF
          'N', 'n':  BEGIN
                       curObjIdx := ObjName(pr, curObj);
                       IF curObjIdx = CNilObjIdx
                          THEN BEGIN
                            objMatCode :=  CNoSuchObj;
                            IF fTstPat THEN WRITELN('Cant find named object')
                           END
                          ELSE BEGIN
                             IF fTstPat THEN
                               WRITELN('Current match object set to; "',
                                       curObj, '"');
                            END;
                     END;
          'S', 's':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjSelect, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" ObjSelect at event:',
                                       ORD(objEbr.bufStart));
                             objMatCode := MatObjSel(pr, objEbr, CObjDslAll);
                             IF fTstPat THEN
                               WRITELN('Select - MatObjSel returned:', objMatCode);
                            END
                           ELSE BEGIN
                             objMatCode := CNoObjSelect;
                             pch := GetPatChar(pr);
                             IF pch = '<'
                               THEN EatPat(pr)
                               ELSE BumpPatPos(pr, -1);
                            END;
                     END;
          'O', 'o':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjOpen, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" ObjOpened at event:',
                                       ORD(objEbr.bufStart));
                            END
                           ELSE objMatCode := CNoObjOpen;
                     END;
          'C', 'c':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjClose, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" ObjClosed at event:',
                                       ORD(objEbr.bufStart));
                            END
                           ELSE objMatCode := CNoObjClose;
                     END;
          'K', 'k':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjPutBak, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" ObjPutBack at event:',
                                       ORD(objEbr.bufStart));
                            END
                           ELSE objMatCode := CNoObjPutBack;
                     END;
          'T', 't':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjOpnPad, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" ObjOpenPad at event:',
                                       ORD(objEbr.bufStart));
                            END
                           ELSE objMatCode := CNoObjTearOff;
                     END;
          'D', 'd':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjDuplicate, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" ObjDuplicate at event:',
                                       ORD(objEbr.bufStart));
                            END
                           ELSE objMatCode := CNoObjDuplicate;
                     END;
          'A', 'a':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjActivate, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" ObjActivate at event:',
                                       ORD(objEbr.bufStart));
                             objMatCode := MatObjSel(pr, objEbr, CObjActivate);
                             IF fTstPat THEN
                               WRITELN('Activate - MatObjSel returned:', objMatCode);
                            END
                           ELSE BEGIN
                             objMatCode := CNoObjActivate;
                             pch := GetPatChar(pr);
                             IF pch = '<'
                               THEN EatPat(pr)
                               ELSE BumpPatPos(pr, -1);
                            END;
                     END;
          'M', 'm':
               BEGIN
                 tstVal := ObjName(pr, tstObj);
                 IF tstVal = CNilObjIdx
                   THEN BEGIN
                     objMatCode :=  CNoContainerObj;
                     IF fTstPat THEN WRITELN('Cant find named object')
                    END
                     ELSE BEGIN
                       objEvt := TestObjName(tstObj, curObj,
                                        CObjChgCont, objEbr, objEvt, FALSE);
                       IF objEvt <> NIL
                         THEN BEGIN
                           IF fTstPat THEN
                            WRITELN('"', curObj, '" moved into object "',
                                    tstObj, '"');
                           END
                          ELSE BEGIN
                            objMatCode := MatchFail(pr, CNoObjChgCont);
                            IF fTstPat THEN
                              WRITELN('"', curObj, '" not put in container',
                                      tstObj, '"');
                           END;
                      END;
                END;
          'R', 'r':
               BEGIN
                 xch := GetPatChar(pr);
                 IF (xch = 'x') OR (xch = 'X')
                   THEN BEGIN
                     varName := 'FixName';
                     fFixName := TRUE;
                     SetBoolVar(varName, FALSE);
                    END
                   ELSE BEGIN
                     fFixName := FALSE;
                     BumpPatPos(pr, -1);
                    END;
                 tstVal := ObjName(pr, tstObj);
                 objEvt := TestObjName(tstObj, curObj, CObjRename,
                                       objEbr, objEvt, fFixName);
                 IF objEvt <> NIL
                   THEN BEGIN
                     IF fTstPat THEN
                       WRITELN('"', curObj, '" renamed to object "',
                                tstObj, '"');
                     END
                    ELSE BEGIN
                      objMatCode := MatchFail(pr, CNoObjRename);
                      IF fTstPat THEN
                        WRITELN('"', curObj, '" not renamed to "',
                                tstObj, '"');
                     END;
                END;
          'X', 'x':
             IF PatRange(pr, tstVal, tstErr)
               THEN BEGIN
                 objEvt := TestObjInt(1, tstVal, tstErr, curObj,
                                         CObjMove, objEbr, objEvt);
                 IF objEvt <> NIL
                   THEN BEGIN
                     IF fTstPat THEN
                      WRITELN('XVal in range', tstVal:6, ' +/-', tstErr:5);
                     END
                    ELSE BEGIN
                      objMatCode := MatchFail(pr, CNoObjXInRange);
                      IF fTstPat THEN
                        WRITELN('XVal NOT in range', tstVal:6, ' +/-',
                                tstErr:5);
                     END;
                END
               ELSE IF fTstPat THEN WRITELN('Cant read X range from pattern');
          'Y', 'y':
             IF PatRange(pr, tstVal, tstErr)
               THEN BEGIN
                 objEvt := TestObjInt(2, tstVal, tstErr, curObj,
                                         CObjMove, objEbr, objEvt);
                 IF objEvt <> NIL
                   THEN BEGIN
                     IF fTstPat THEN
                      WRITELN('YVal in range', tstVal:6, ' +/-', tstErr:5);
                     END
                    ELSE BEGIN
                      objMatCode := MatchFail(pr, CNoObjYInRange);
                      IF fTstPat THEN
                        WRITELN('YVal NOT in range', tstVal:6, ' +/-',
                                tstErr:5);
                     END;
                END
               ELSE IF fTstPat THEN WRITELN('Cant read Y range from pattern');
          'H', 'h':
             IF PatRange(pr, tstVal, tstErr)
               THEN BEGIN
                 objEvt := TestObjInt(1, tstVal, tstErr, curObj,
                                         CObjSize, objEbr, objEvt);
                 IF objEvt <> NIL
                   THEN BEGIN
                     IF fTstPat THEN
                      WRITELN('HVal in range', tstVal:6, ' +/-', tstErr:5);
                     END
                    ELSE BEGIN
                      objMatCode := MatchFail(pr, CNoObjHInRange);
                      IF fTstPat THEN
                        WRITELN('HVal NOT in range', tstVal:6, ' +/-',
                                tstErr:5);
                     END;
                END
               ELSE IF fTstPat THEN WRITELN('Cant read H range from pattern');
          'W', 'w':
             IF PatRange(pr, tstVal, tstErr)
               THEN BEGIN
                 objEvt := TestObjInt(2, tstVal, tstErr, curObj,
                                         CObjSize, objEbr, objEvt);
                 IF objEvt <> NIL
                   THEN BEGIN
                     IF fTstPat THEN
                      WRITELN('WVal in range', tstVal:6, ' +/-', tstErr:5);
                     END
                    ELSE BEGIN
                      objMatCode := MatchFail(pr, CNoObjWInRange);
                      IF fTstPat THEN
                        WRITELN('WVal NOT in range', tstVal:6, ' +/-',
                                tstErr:5);
                     END;
                END
               ELSE IF fTstPat THEN WRITELN('Cant read W range from pattern');
          'E', 'e':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjThumb, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" CObjThumb at event:',
                                       ORD(objEbr.bufStart));
                            END
                           ELSE objMatCode := CNoObjThumb;
                     END;
          'B', 'b':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjPage, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" CObjPage at event:',
                                       ORD(objEbr.bufStart));
                            END
                           ELSE objMatCode := CNoObjPage;
                     END;
          'Z', 'z':  BEGIN
                       objEvt := FindObjEvt(curObj, CObjArrow, objEbr);
                       IF objEvt <> NIL
                          THEN BEGIN
                             IF fTstPat THEN
                               WRITELN('"', curObj, '" CObjArrow at event:',
                                       ORD(objEbr.bufStart));
                            END
                           ELSE objMatCode := CNoObjArrow;
                     END;
          '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
               SetPartMat(pr, pch);
          ' ': BEGIN END;
          '>': GOTO 700;
          OTHERWISE PatError(pr, CInvObPatChar, pch);
         END;
        IF objMatCode <> 0 THEN BEGIN EatPat(pr); GOTO 700; END;
      UNTIL pr^.PPatFail;
      IF fTstPat THEN
        WRITELN('Pattern error in MatObj pattern. skip to pattern end.');
      EatPat(pr);
      objMatCode := -1;
      IF fTstPat THEN WRITELN('MatObj returns:', objMatCode);
      MatObj := objMatCode;
      EXIT(MatObj);

 700: IF pr^.PPatFail AND (objMatCode = 0) THEN objMatCode := -1;
        { in case of pat error in sub (selection event) pattern }
      IF fTstPat THEN WRITELN('MatObj returns:', objMatCode);
      MatObj := objMatCode;
    END;
END;


{$S imph }
FUNCTION  MatFldr(pr: TPPatRec): TC;
VAR fldrName: TStr40;
    fldrObj: ObjectHandle;
    imFld: THFldrInfo;
    fldrInt: TC;
    findFirst: TF;
BEGIN
  IF NOT GetPatStr(pr, @fldrName, 40)
    THEN BEGIN
      PatError(pr, CInvFolderName, CHR(0));
      IF fTstPat THEN WRITELN('MatFldr: cant read folder name in pattern');
      MatFldr := -1;
      EXIT(MatFldr);
     END;
  findFirst := FALSE;
  IF PatIntArg(pr, fldrInt)
    THEN IF fldrInt = 1 THEN findFirst := TRUE;
  fldrObj := GetNameObj(fldrName, findFirst);
  IF fldrObj = nilObject
    THEN BEGIN
      MatFldr := MatchFail(pr, CNoSuchFolder);
      IF fTstPat THEN WRITELN('MatFldr: cant find object "', fldrName, '"');
      EXIT(MatFldr);
     END;
  imFld := fldrObj^^.imFldr;
  IF imFld = NIL
    THEN BEGIN
      MatFldr := MatchFail(pr, CNoStreamInFolder);
      IF fTstPat THEN WRITELN('MatFldr: no imFldr in object "', fldrName, '"');
      EXIT(MatFldr);
     END;
  IF imFld^^.fldrDispWindow = NIL
    THEN BEGIN
      MatFldr := MatchFail(pr, CNoStreamInFolder);
      IF fTstPat THEN
        WRITELN('MatFldr: no dispWindow in imFolder "', fldrName, '"');
      EXIT(MatFldr);
     END;
  IF imFld^^.fldrDispWindow^^.wLink = NIL
    THEN BEGIN
      MatFldr := MatchFail(pr, CNoStreamInFolder);
      IF fTstPat THEN
         WRITELN('MatFldr: no stream linked to dispWindow in imFldr"',
                 fldrName, '"');
      EXIT(MatFldr);
     END;
  WITH pr^ DO BEGIN
    IF fTstPat THEN
        WRITELN('MatFldr: match folder stream set to "', fldrName, '"');
    PIMStr := imFld^^.fldrDispWindow^^.wLink^^.kStream;
    PTxFstLine := PIMStr^^.sLineSeq.sFstLine;
    PTxLstLine := PIMStr^^.sLineSeq.sLstLine;
   END;
  MatFldr := 0;
END;


{$S imph }
FUNCTION  DoPatMatch(pr: TPPatRec): TC;
VAR pch: CHAR;
    matCode: TC;
BEGIN
  WITH pr^.PEBufRange.bufStart^  DO BEGIN
    PEBufData := PEBuf^^.FirstBuf;
    PEBufPos := 0;
   END;
  WITH pr^ DO BEGIN
    PTxFstLine := PIMStr^^.sLineSeq.sFstLine;
    PTxLstLine := PIMStr^^.sLineSeq.sLstLine;
   END;
  matCode := 0;
  IF StartPat(pr)
    THEN BEGIN
      REPEAT
        pch := GetPatChar(pr);
        CASE pch OF
          'S', 's': matCode := MatSel(pr);
          'F', 'f': matCode := MatObj(pr, pr^.PEBufRange);
          'E', 'e': matCode := MatKbd(pr, pr^.PEBufRange, 0);
          'K', 'k': matCode := MatEdKeyTxt(pr, pr^.PEBufRange, pr^.PPatPos);
          'N', 'n': matCode := MatFldr(pr);
          'T', 't': matCode := MatSrcTxt(pr);
          'M', 'm': matCode := MatMen(pr, pr^.PEBufRange);
          '&': matCode := MatAnd(pr);
          '#': matCode := MatOr(pr);
          ' ': BEGIN END;
          '>': BEGIN
                 matCode := 0;
                 IF fTstPat
                  THEN WRITELN('DoPatMat returns code: ', matCode);
                 DoPatMat := matCode;
                 EXIT(DoPatMatch);
               END;
          '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
               SetPartMat(pr, pch);
          OTHERWISE BEGIN
                      matCode := -1;
                      PatError(pr, CInvTopPatChar, pch);
                    END;
         END;
      UNTIL matCode <> 0;
      { IF pr^.PPatFail THEN } EatPat(pr);
      IF (matCode = 0) AND (pr^.PPatFail) THEN matCode := -1;
     END
    ELSE matCode := -1;
  DoPatMat := matCode;
END;


{$S imph }
FUNCTION  MatAnd;  { (pr: TPPatRec): TC; }
VAR patCount: TC;
    matAndCode: TC;
    pch: CHAR;
BEGIN { matches an anded pattern. }
  patCount := 0;
  matAndCode := 0;
  WHILE matAndCode = 0 DO
    BEGIN
      pch := GetPatChar(pr);
      IF pch = '<'
        THEN BEGIN
          patCount := patCount + 1;
          BumpPatPos(pr, -1);
          matAndCode := DoPatMatch(pr);
          IF fTstPat THEN
           WRITELN('MatAnd pattern ', patCount:3, ' returns code:', matAndCode)
         END
        ELSE IF pch = '>'
          THEN BEGIN
            IF fTstPat THEN WRITELN('MatAnd succeeded');
            BumpPatPos(pr, -1);  { leav pat end around for DoPatMatch }
            MatAnd := matAndCode;
            EXIT(MatAnd);
           END
          ELSE IF (ORD(pch) >= ORD('0')) AND (ORD(pch) <= ORD('9'))
            THEN SetPartMat(pr, pch)
            ELSE IF pch <> ' '
                 THEN BEGIN
                   PatError(pr, CInvAndPatChar, pch);
                   matAndCode := -1;
                  END;
    END;
  MatAnd := matAndCode;
END;


{$S imph }
FUNCTION  MatOr;  { (pr: TPPatRec): TC; }
VAR patCount: TC;
    saveFailCode: TC;
    matOrCode: TC;
    pch: CHAR;
BEGIN { matches an ored pattern. }
  patCount := 0;
  matOrCode := 0;
  WHILE matOrCode = 0 DO
    BEGIN
      pch := GetPatChar(pr);
      IF pch = '<'
        THEN BEGIN
          patCount := patCount + 1;
          BumpPatPos(pr, -1);
          matOrCode := DoPatMatch(pr);
          IF matOrCode = 0
            THEN BEGIN
              IF fTstPat THEN
                WRITELN('MatOr pattern ', patCount:3, ' succeded.');
              EatPat(pr);
              BumpPatPos(pr, -1);  { leave pat end around for DoPatMatch }
              MatOr := matOrCode;
              EXIT(MatOr);
             END;
          IF NOT pr^.PPatFail  { not a pattern failure }
            THEN BEGIN
              IF fTstPat THEN
               WRITELN('MatOr pattern', patCount:3, ' failed. Code=', matOrCode);
              saveFailCode := matOrCode;
              matOrCode := 0;
             END
            ELSE IF fTstPat THEN WRITELN('Pattern failure in MatOr');
         END
        ELSE IF (ORD(pch) >= ORD('0')) AND (ORD(pch) <= ORD('9'))
               THEN SetPartMat(pr, pch)
        ELSE IF pch = '>'
          THEN BEGIN
            BumpPatPos(pr, -1);  { leav pat end around for DoPatMatch }
            IF fTstPat THEN WRITELN('MatOr failed.');
            matOrCode := saveFailCode;
           END
          ELSE IF (ORD(pch) >= ORD('0')) AND (ORD(pch) <= ORD('9'))
            THEN SetPartMat(pr, pch)
            ELSE IF pch <> ' '
                 THEN BEGIN
                   PatError(pr, CInvOrPatChar, pch);
                   matOrCode := -1;
                  END;
    END;
  MatOr := matOrCode;
END;


{$S imph }
FUNCTION  MatchPat; { (VAR PartMatMark, MatFailCode: TC); }
VAR apr: TPatRec;
    aebp: TEBufPos;
BEGIN
  ClearPatRec(@apr, FALSE);
  SetHeap(IMHeap);
  IF BuildPatRec(@apr, @aebp)
    THEN BEGIN
{$IFC IMCompile }
      IF fICompile THEN WRITELN(icFile, 'CMatchPat;');
{$ENDC }
      MatFailCode := DoPatMatch(@apr);
      IF fTstPat THEN WRITELN('Completed match pat');
      IF fTstPat THEN PrintPatRec(@apr);
      WITH apr DO
        BEGIN
          MatchPat := (MatFailCode = 0);
          PartMatMark := PPartMark;
          FreeBk(IMHeap, POINTER(ORD(apr.PPatPtr)), tyBkStd);
        END;
     END
    ELSE MatchPat := FALSE;
END;

{$IFC FALSE }  { Object set pattern stuff - not being used now }
{$S impo }
FUNCTION GetNthNamedObj(VAR objName: TStr40; VAR objNum: TC): ObjectHandle;
 TYPE
     THObjArray   = ^TPObjArray;   { added for object access -gb }
     TPObjArray   = ^TObjArray;
     TObjArray    = ARRAY[0..0] OF ObjectHandle;

VAR hObjArray: THObjArray;
    objCt, maxObj: TC;
    fGetBig: TF;

     FUNCTION GetNth: ObjectHandle;
     VAR nthObj: ObjectHandle;
         i: TC;
         nthObjCtim: TL;
     BEGIN
       IF objCt = 0 THEN BEGIN GetNth := NIL; EXIT(GetNth); END;
       nthObj := hObjArray^^[0];
       nthObjCtim := nthObj^^.created;
       FOR i := 1 TO objCt-1 DO
        BEGIN
          IF fGetBig
            THEN BEGIN
              IF hObjArray^^[i]^^.created > nthObjCtim
                THEN BEGIN
                  nthObj := hObjArray^^[i];
                  nthObjCtim := nthObj^^.created;
                END;
             END
            ELSE BEGIN
              IF hObjArray^^[i]^^.created < nthObjCtim
                THEN BEGIN
                  nthObj := hObjArray^^[i];
                  nthObjCtim := nthObj^^.created;
                END;
             END
        END;
        GetNth := nthObj;
     END;

     PROCEDURE OAInsert(tstObj : ObjectHandle);
     {  adds tstObj to ObjArray  }
     VAR i: TC;
     BEGIN
       IF objCt < maxObj
         THEN BEGIN
           hObjArray^^[objCt] := tstObj;
           objCt := objCt + 1;
          END
         ELSE BEGIN
           FOR i := 0 TO maxObj-1 DO
            IF fGetBig
              THEN BEGIN
                IF hObjArray^^[i]^^.created < tstObj^^.created
                  THEN hObjArray^^[i] := tstObj;
               END
              ELSE BEGIN
                IF hObjArray^^[i]^^.created > tstObj^^.created
                  THEN hObjArray^^[i] := tstObj;
               END;
          END;
     END;

     PROCEDURE TreeSearch(whichList : ObjectHandle);
     VAR obj,result: ObjectHandle;
     BEGIN
     obj:=whichList^^.next;
     WHILE obj <> whichList DO   { travel down brother list }
        BEGIN
        IF obj^^.name = objName THEN OAInsert(obj);
            { check contents (sons) }
        TreeSearch(obj^^.contents);
        obj:=obj^^.next;
        END;
     END;

BEGIN
  IF objName = deskObject^^.name
    THEN BEGIN
      GetNthNamedObj := deskObject;
      EXIT(GetNthNamedObj);
     END;
  objCt := 0;
  IF objNum < 0
    THEN BEGIN  fGetBig := FALSE; maxObj := -objNum; END
    ELSE BEGIN  fGetBig := TRUE;  maxObj :=  objNum; END;
  hObjArray := POINTER(ORD(NewHandle(SIZEOF(ObjectHandle)*maxObj)));
  TreeSearch(deskObject^^.contents);
  objNum := objCt;
  GetNthNamedObj := GetNth;
  DisposeHandle(POINTER(ORD(hObjArray)));
END;



{$S impo }
FUNCTION  TstObjInSet(objId: TC; objSet: THObjSet): TF;
TYPE TobPtr = ^TB;
VAR  i: TC;
BEGIN
  FOR i := 1 to objSet^^.setCt DO
    WITH objSet^^ DO BEGIN
      IF setId[i] = objId
        THEN BEGIN
          TstObjInSet := TRUE;
          IF fTstPat THEN
            WRITELN('ObjId:', objId:4, ' is in objSet:', ORD(objSet));
          EXIT(TstObjInSet);
         END;
    END;
  TstObjInSet := FALSE;
END;


{$S impo }
PROCEDURE PutObjInSet(objId: TC; objSet: THObjSet);
TYPE TobPtr = ^TB;
VAR  obPtr, obLim: TobPtr;
BEGIN
  IF NOT TstObjInSet(objId, objSet)
    THEN BEGIN
      WITH objSet^^ DO
        IF objSet^^.setSz >= objSet^^.setCt
          THEN BEGIN
            setSz := setSz+4;  { set size limited to 255 by obj table }
            ChangeSizeH(IMHeap, POINTER(ORD(objSet)), setSz+2);
          END;
      WITH objSet^^ DO BEGIN
        setCt := setCt+1;
        setId[setCt] := objId;
        IF fTstPat THEN
          WRITELN('Obj', objId:4, ' added as ', setCt:4,
                  'th member of set;' , ORD(objSet));
       END;
    END;
END;


{$S impo }
PROCEDURE ObjHndInSet(hObj: ObjectHandle; objSet: THObjSet);
VAR objId: TC;
BEGIN
  objId := GetObjIdx(curObjTable, hObj);
  PutObjInSet(objId, objSet);
END;
{$ENDC }

END.

