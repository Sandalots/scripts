{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}


{$s  }
{$r- }

UNIT TFiler;

INTERFACE


USES {$U HwInt       }  HwInt,
     {$U libos/SysCall     }  SysCall,
     {$U libos/PSysCall    }  PSysCall,
     {$U UnitStd     }  UnitStd,
     {$U UnitHz      }  UnitHz,
     {$U Storage     }  Storage,
     {$U QuickDraw   }  QuickDraw,
     {$U FontMgr     }  FontMgr,
     {$U PmDecl      }  PmDecl,
     {$U PMM         }  PMM,
     {$U WM.Events   }  Events,
     {$U WM.Windows  }  Windows,
     {$U WM.Folders  }  Folders,
     {$U WM.Menus    }  Menus,
     {$U WmlStd      }  WmlStd,
     {$U WmlCrs      }  WmlCrs,
     {$U WmlSb       }  WmlSb,
     {$U WmlGrow     }  WmlGrow,
     {$U GrafUtil    }  GrafUtil,
     {$U AlertMgr    }  AlertMgr,
     {$U DBenv       }  DBenv,
     {$U DBdecl1     }  DBdecl1,
     {$U Apim/tfilercomm }  Tfilercomm,
     {$U Scrap       }  Scrap,
     {$U FEDec       }  FEDec,
     {$U Fld         }  FieldEdit,

        { IM Modules  -gb }

     {$U apim/UnitIMF.obj  }  UnitIMF,
     {$U apim/IMCore.obj   }  IMCore,
     {$U apim/IMMenus.obj  }  IMMenus,
     {$U apim/IMFolders.obj}  IMFolders,

        { Filer Modules }

     {$U apim/TFGlobals    }  IFGlobals,   { Common routines & declarations }
     {$U apim/TSetTime     }  IFSetTime,    { Time display and edit }
     {$U apim/TFEntry      }  IFEntry,     { Manages lists of docs, tools, vols }
     {$U apim/TCatalog     }  IFCatalog,    { Cover procs for database intrinsics }
     {$U apim/TFDocCtrl    }  IFDocCtrl;   { Creating, communicating with apps }
 { out for now {$U TFVolCtrl  FVolCtrl;  { Mount, unmount, copy of volumes }


CONST

{$IFC R}
      salutation = 'Lisa Filer - Version A1 - 8/24/82';
{$ELSEC}  { stuff added for interactive manual }
     CNilObjIdx = -1;  { for object table index -gb }
     imTool = 7;

{$ENDC}

         { Menu & menu item id's.  These must match the menu file }

      filingMenu  = 1;
        mCloseAll     = 1;
        mClose        = 2;
        mBlank13      = 3;
        mPutBack      = 4;
        mOpen         = 5;
        mDuplicate    = 6;
        mNew          = 7;
        mMakePad      = 8;
        mBlank19      = 9;
        mPrintStatus  = 10;

      editMenu    = 2;
        mUndoLast     = 1;
        mBlank22      = 2;
        mCut          = 3;
        mCopy         = 4;
        mPaste        = 5;
        mBlank26      = 6;
        mSelectAll    = 7;

      viewMenu    = 3;
        mSpatial      = 1;
        mAlpha        = 2;
        mChron        = 3;

      diskMenu    = 4;
        mRepair       = 1;
        mErase        = 2;

      specialMenu = 5;      { special debugging menu.  Toggled by command "!" }
        mTrcAll       = 1;
        mTrcOff       = 2;
        mTrcEvents    = 3;
        mTrcFEntry    = 4;
        mTrcCatalog   = 5;
        mTrcFDocCtrl  = 6;
        mTrcFVolCtrl  = 7;
        mTrcFiler     = 8;
        mPrintDocs    = 9;
        mPrintVols    = 10;
        mPrintTools   = 11;
        mPrintDevs    = 12;
        mSetTime      = 13;
        mCheckHeap    = 14;
        mWantSound    = 15;
        mWantAutoSize = 16;
        mBootInOut    = 17;
        mQuit         = 18;

      xtraMenu    = 6;      { Not displayed.  Holds strings used for diff menus. }
        xClose        = 1;
        xOpen         = 2;
        xPutBack      = 3;
        xObjects      = 4;
    {   xWastebasket  = 5;  { eXtraMenu item numbers from TCatalog     }
    {   xClipboard    = 6;  { declared in TCatalog                     }
    {   xPreferences  = 7;  { eXtra menu items for catalog names       }
    {   xDisk         = 8;  { LisaGuide nr bug #4 fix for translation  }
    {   xDiskette     = 9;  { 3/2/83  -gb                              }
        xUntitled     = 10;
        xFolder       = 11;
        xTool         = 12;
        xClock        = 13;
        xCalculator   = 14;
        xBlocksFree   = 15;
        xBackedUp     = 16;
        xNever        = 17;
        xTitle        = 18;
        xSize         = 19;
        xModified     = 20;
        xCreated      = 21;


      firstFlrMenu  = filingMenu;
      lastFlrMenu   = xtraMenu;


         { Char codes in WMFont used for title bar & list view }

      graySymbol    = 64;
      blackSymbol   = 65;
      docPadSymbol  = 78;
      docSymbol     = 80;
      folderSymbol  = 82;
      diskSymbol    = 118;
      otherSymbol   = 86;
      fldrPadSymbol = 92;
      calcSymbol    = 94;
      profileSymbol = 96;
      toolSymbol    = 98;
      scrapSymbol   = 100;
      printSymbol   = 102;
      compSymbol    = 104;
      trashSymbol   = 112;
      clockSymbol   = 114;
      imSymbol      = 143;


         { Screen size constants }

      iconWidth    = 48;  { width of icon bitmap }
      iconHt       = 32;  { height of icon bitmap }
      icon2Width   = 24;  { iconWidth/2 }
      icon2Ht      = 16;  { iconHt/2 }
      menuHt       = 16;  { height of menu bar }
      titleHt      = 16;  { height of window title bar }
      hScrollInc   = 32;  { pixels scrolled for "smooth" horizontal scroll }


         { filename constants }

     {filerMenus     = '{T7xFlrMenus.Text'; { name of file with menu text }
      iconNamFont    = Tile7;   { font number of font used for icon titles }
      flrHeapName    = '{!TFHeap}';    { name of data seg used for heap }

{$IFC R}
      jrnlDirectives = 'JrnlFiles.Text'; { holds filenames for play/record }
{$ENDC}

         { Miscellaneous constants }

      whyHitOrphan = 400;  { "why" value sent to self when orphan hit }
      noTimeout    = -1;   { no "timeouts" occur when "timeoutTime" set to this }



TYPE ObjectKind   = nilKind..lastKind;   { kinds defined in unit "Catalog" }
     KindSet      = SET OF ObjectKind;

     ObjectState  = (nilState,     { used for the "nilObject" }
                     hidden,       { white ghost on desktop }
                     normal,       { closed in container or on desktop (unselected)}
                     hilited,      { closed in container or on desktop (selected) }
                     limbo,        { Xor image while being moved }
                     placeHolder); { gray ghost in container }

     StateSet     = SET OF ObjectState;

     ViewType     = (spatialView,  { icons }
                     alphaView,    { alphabetical list by name }
                     chronView);   { chronological list by date modified }


         { object node - one for each icon on screen & for list head/tail

           Those objects which can hold other objects are refered to as
           "containers."  There is a special container called the "deskObject"
           which holds all objects on the desktop.  The objects in a given
           container are kept in a doubly linked circular list pointed at by
           the field "contents."  "Contents" points to either a head/tail node
           for a circular list, or to the nil object.  When a container is
           opened, the catalog is read and a window and a list of object nodes
           are created.  When the container is closed the window and contents
           are deallocated.

         }

     ObjectHandle = ^ObjectPtr;
     ObjectPtr    = ^FObject;
     FObject      = RECORD
                    name:       FmaxStr;        { icon title }
                    loc:        Point;          { topLeft of bounding box }
                    kind:       ObjectKind;     { doc, folder, disk, etc. }
                    subKind:    ObjectKind;     { used for image overlay }
                    volHdl:     TentryHdl;      { volume on which object lives }
                    catRID:     TcatRID;        { catalog record ID }
                    state:      ObjectState;    { icon state: normal,hilited... }
                    next:       ObjectHandle;   { next brother }
                    prev:       ObjectHandle;   { previous brother }
                    container:  ObjectHandle;   { father }
                    contents:   ObjectHandle;   { sons }
                    isFiled:    BOOLEAN;        { TRUE => container is home }
                    wasOpened:  BOOLEAN;        { TRUE => has been opened }
                    isOpen:     BOOLEAN;        { TRUE => window is on screen }
                    dirty:      BOOLEAN;        { TRUE => catalog needs update}
                    toBeCopied: BOOLEAN;        { TRUE => dup'd, but not real }
                    windowRect: Rect;           { last window location & size }
                    objWindow:  WindowPtr;      { grafport for icon's window }
                    viewMode:   ViewType;       { spatial, alpha, etc. }
                    hThumbPos:  INTEGER;        { h thumb position in 1000ths }
                    vThumbPos:  INTEGER;        { v thumb position in 1000ths }
                    created:    LongInt;        { time stamp when created }
                    modified:   LongInt;        { time stamp when modified }
                    size:       LongInt;        { disk size in blocks }
                    freeSpace:  LongInt;        { used for disks only }
                    backedUp:   LongInt;        { used for disks only }
                    nameRect:   Rect;           { bounding box of icon title }
                    imFldr:     THFldrInfo;     { im stuff -gb }
                    objSerial:  TC;             { object serial index for im }
                    END;


     {
          deskObject
              !
              v
            -----
            !   !
            -----         Objects on desktop
             ! ^
             ! !<-----------------------------
             ! !        ^                    ^
             v !        !                    !
            -----     -----                -----
        --> !h/t! --> !   ! -->         -->! f ! --> to h/t
        <-- !   ! <-- !   ! <--   ...   <--!   ! <-- from h/t
            -----     -----                -----
              !         !                   ! ^              contents of "f"
              v         v                   ! !
           nilObject                        ! !<----------------------------
                                            ! !        ^         ^         ^
                                            v !        !         !         !
                                           -----     -----     -----     -----
                                       --> !h/t! --> !   ! --> !   ! --> !   ! -->
                                       <-- !   ! <-- !   ! <-- !   ! <-- !   ! <--
                                           -----     -----     -----     -----
                                             !         !         !         !
                                             v         v         v         v
                                          nilObject
     }



        { record format for SaveDesktop file }

     SaveStateRec = RECORD
                    recID:     TcatRID;    { catalog id }
                    deskLoc:   Point;      { desktop location }
                    filedFlag: BOOLEAN;    { was it opened from it's container }
                    openFlag:  BOOLEAN;    { was it left opened }
                    END;

VAR debugStartup:       BOOLEAN;  { Initialized to FALSE.  To trace startup, set }
                                  { to TRUE with debugger after first statement  }

    flrHeap: THz;

       { Handles to "system" objects moved to interface -gb }

    nilObject:          ObjectHandle;  { lists are terminated by this }
    deskObject:         ObjectHandle;  { highest level container }
    trashObject:        ObjectHandle;  { the disposal for deleting objects }
    scrapObject:        ObjectHandle;  { the buffer for document pieces }
    printerObj:         ObjectHandle;  { printer status information }
    computeObj:         ObjectHandle;  { configuration info }
    floppy1Object:      ObjectHandle;  { diskette in upper drive }
    floppy2Object:      ObjectHandle;  { diskette in lower drive }
    hardDiskObject:     ObjectHandle;  {*** only 1 hard disk for now ***}
    activeObject:       ObjectHandle;  { object that owns the active window }
    editObject:         ObjectHandle;  { object whose title is being edited }
    edit2Object:        ObjectHandle;  { used when editObject appears twice }

       { Menu descriptors.  Read in from menu file in interface for im -gb }

    filerMenus:         Pathname;
    flrMenus:           ARRAY [firstFlrMenu..lastFlrMenu] OF MenuInfo;
      { these are for the im Menu unit }
    flrNameMenus:       ARRAY [firstFlrMenu..lastFlrMenu] OF MenuInfo;
    flrMTitle:          ARRAY [firstFlrMenu..lastFlrMenu] OF TKeyStr;

    objSerCount:        TC;







PROCEDURE IFMount(VAR err: INTEGER; VAR devName: FmaxStr);
PROCEDURE IFUnMount(VAR err: INTEGER; VAR devName: FmaxStr);
FUNCTION  IFSaveCat(devName, catFName: FmaxStrPtr): TC;
FUNCTION  IFLoadCat(devName, catFName: FmaxStrPtr): TC;
PROCEDURE IFDrawDesk;
PROCEDURE IFInit(fMenus: Pathname);
FUNCTION  BldObjTable(obj: ObjectHandle): ThObjTable;
FUNCTION  GetObjIdx(ot: ThObjTable; hObj: ObjectHandle): TC;
PROCEDURE LCName(VAR s: TStr40);
FUNCTION  NamedObjIdx(ot: THObjTable; VAR objName: TStr40): TC;
FUNCTION  IFMakeObj(obName: FmaxStr; kind, subKind: ObjectKind;
                      father: ObjectHandle; loc: Point;
                      hFldr: THFldrInfo; r: Rect): ObjectHandle;
FUNCTION IFMakeFolder
           (fname: TKeyStr; fKind, fsubKind: ObjectKind;
            opnRect: Rect; clsLoc: Point;
            fVis, fwindow, fSBars: TF;
            behindWind: WindowPtr): THFldrInfo;
PROCEDURE IFKillObj(hObj: ObjectHandle);
PROCEDURE IFKillXtras(obj: ObjectHandle);
PROCEDURE IFCloseObj(obj : ObjectHandle; closeSons: BOOLEAN);
PROCEDURE IFCloseContents(obj : ObjectHandle; closeIM: BOOLEAN);
PROCEDURE IFOpenObj(obj : ObjectHandle);
PROCEDURE IFTearOffObj(obj : ObjectHandle);
PROCEDURE IFMenuCommand(theMenu, theItem: TC);
PROCEDURE IFBtnUp;
PROCEDURE IFAdjustMenus;
PROCEDURE IFButtonDown;
PROCEDURE IFCommandKey;
PROCEDURE IFTextKey;
PROCEDURE IFDeActivate;
PROCEDURE IFActivate;
PROCEDURE IFFolderMove(window: WindowPtr);
PROCEDURE IFDrawInsides(window: WindowPtr); { moved to interface -gb }
FUNCTION  IFFindObj(window: WindowPtr; VAR hObj: ObjectHandle): BOOLEAN;
FUNCTION  GetActObjIdx(VAR objIdx: TC): BOOLEAN;
PROCEDURE IFMoveIcon(hObj: ObjectHandle; ix, iy: TC);
PROCEDURE IFValidIcon(hObj: ObjectHandle; fValid: TF);
PROCEDURE KillNameObj(nameStr: TStr40);
FUNCTION  GetNameObj(nameStr: TStr40; findFirst: TF): ObjectHandle;
FUNCTION  OnDesktop(whichVol: TentryHdl; objID: IDType): BOOLEAN;
FUNCTION  IFCloseSymbol(kind: ObjectKind): INTEGER;
PROCEDURE IFNoEvent;
FUNCTION  IFChangeCont(obj, cobj: ObjectHandle;
                       ix, iy: TC; fChoose: TF): BOOLEAN;
PROCEDURE IFSetView(obj: ObjectHandle; newView: ViewType);
FUNCTION  IFPutBack(obj : ObjectHandle): BOOLEAN;
FUNCTION  IFIsContainer(obj: ObjectHandle): BOOLEAN;
PROCEDURE IFDupObj(obj: ObjectHandle);
PROCEDURE IFSelObject(obj: ObjectHandle; fSel: TF);
PROCEDURE IFReName(obj: ObjectHandle; newName: FMaxStr);
FUNCTION  AddIMFolder(hObj: ObjectHandle;
                      fVis, fwindow, fSBars: TF; cKeep: TC): THFldrInfo;



IMPLEMENTATION


VAR doDslAll:           BOOLEAN;  { for de-select event recording -gb }


       { These variables are used to determine multiple mouse clicks }

    clickTime:          LongInt;   { set to last button up + clickDelay }
    clickCount:         INTEGER;   { clicks seen so far }
    clickLoc:           Point;     { where clicked last }


       { This table tells which kinds of objects a given container will accept }

    matchTable:         ARRAY [ObjectKind] OF KindSet;


       { These are set constants }

    putBackSet:         KindSet;
    diskSet:            KindSet;
    dupSet:             KindSet;
    padSet:             KindSet;
    docToolSet:         KindSet;
    allKindsSet:        KindSet;
    allStates:          StateSet;


       { Scroll bar stuff }

    sbList:             TsbList;       { scroll bar list descriptor }
    hsbV:               THsb;          { handle to vertical scroll bar info }
    hsbH:               THsb;          { handle to horizontal scroll bar info }
    maxThumb:           LongInt;       { constant used to force long arithmetic }


       { Field editor stuff }

    hShowFld:           hndField;      { handle to a field used only for drawing }
    hCurFld:            HndField;      { field being edited }
    hCurFstate:         HndFstate;     { state of field being edited }
    timeoutTime:        LongInt;       { holds next time to blink caret or draw }
    timeoutInterval:    Integer;       { holds interval for next "timeout" }
    iconFntInfo:        FontInfo;      { holds icon font attributes }
    lineHt:             INTEGER;       { height of line in list view }
    botToBaseLn:        INTEGER;       { offset from rect, lineHt tall, to baseline}


       { Miscellaneous global variables }

    copyMode:           BOOLEAN;       { TRUE => blinking duplicates exist }
    specialUp:          BOOLEAN;       { TRUE => special debug menu is visible }
    wantSound:          BOOLEAN;       { TRUE => give sound effects }
    wantAutoSize:       BOOLEAN;       { TRUE => smart window sizing }
    orphanHit:          WindowPtr;     { saved window to be used when activated }
    flrHeapRefnum:      INTEGER;       { heap data seg id.  Used to grow heap }
    bigWave:            LongInt;       { low pitch for zooming sound effect }
    smallWave:          LongInt;       { high pitch for zooming sound effect }

    (*** DS ***)
       { mapping from object kind to char code in font }

    iconData,iconMask:  ARRAY[objectKind] OF CHAR;
    iconBoxes:          ARRAY[objectKind] OF Rect;


    rnmObjIdx: TC;  { for rename events to im -gb }
    rnmName: FMaxStr;


   { External Declarations.  }

PROCEDURE BlockIOinit;     { once only call to init pascal library }
  EXTERNAL;


   { Forward Declarations.   Used to maintain alphabetical order }

PROCEDURE AdjustMenus;
  FORWARD;
PROCEDURE AdjWindRect(obj: ObjectHandle);
  FORWARD;
FUNCTION  AllInside(container: ObjectHandle; whichState: ObjectState;
                    dh,dv: INTEGER; targetObj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE BackupDisk(srcDisk,dstDisk: ObjectHandle);
  FORWARD;
PROCEDURE BlinkContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
PROCEDURE BlinkObject(obj: ObjectHandle);
  FORWARD;
PROCEDURE ChangeContents(obj: ObjectHandle;
                         oldState,newState: ObjectState;
                         dh,dv: INTEGER;
                         redraw: BOOLEAN);
  FORWARD;
PROCEDURE ChangeObject(obj: ObjectHandle;
                       newState: ObjectState;
                       dh,dv: INTEGER;
                       redraw: BOOLEAN);
  FORWARD;
PROCEDURE ChangeParentID(obj: ObjectHandle; newParentID: IDType);
  FORWARD;
PROCEDURE ChangeView(obj: ObjectHandle; newView: ViewType);
  FORWARD;
PROCEDURE CheckContents(obj: ObjectHandle);
  FORWARD;
PROCEDURE CheckHeap(message: FMaxStr);
  FORWARD;
PROCEDURE CheckLoc(container: ObjectHandle; VAR loc: Point; VAR changed: BOOLEAN);
  FORWARD;
PROCEDURE CheckObject(obj: ObjectHandle);
  FORWARD;
PROCEDURE ChooseHome(obj: ObjectHandle; VAR newHomeLoc: Point);
  FORWARD;
PROCEDURE ChoosePos(container: ObjectHandle; VAR pt: Point);
  FORWARD;
FUNCTION  CleanupDisk(diskObj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE ClimbTree(whichVol: TentryHdl; recID: TcatRID;
                    VAR fatherRecID: TcatRID; VAR fatherObj: ObjectHandle);
  FORWARD;
PROCEDURE ClipContent(obj: ObjectHandle);
  FORWARD;
FUNCTION  CloseContents(obj: ObjectHandle; putback,suspendDocs: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  CloseObject(obj: ObjectHandle; sonsAlso,putBack,
                                                  suspendDoc: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  CloseSymbol(kind: ObjectKind): INTEGER;
  FORWARD;
PROCEDURE CommandKey;
  FORWARD;
PROCEDURE CopyContents(obj: ObjectHandle; whichState: ObjectState; dh,dv: INTEGER;
                       madeOnDesk: BOOLEAN);
  FORWARD;
FUNCTION  CopyObject(obj: ObjectHandle; madeOnDesk: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  CountContents(obj: ObjectHandle): INTEGER;
  FORWARD;
PROCEDURE DoDskEvent(VAR event: EventRecord);
  FORWARD;
PROCEDURE DragContents(obj: ObjectHandle;
                       whichState: ObjectState;
                       whichKinds: KindSet;
                       tallyCount: INTEGER;
                       startPt : Point;
                       pointAt: ObjectHandle;
                       VAR targetContainer: ObjectHandle;
                       VAR targetIcon: ObjectHandle;
                       VAR targetMatch: BOOLEAN;
                       VAR dh,dv: INTEGER;
                       maxDh,maxDv,minDh,minDv: INTEGER);
  FORWARD;
PROCEDURE DragRect(startPt: Point; VAR dstRect: Rect);
  FORWARD;
PROCEDURE DrawContents(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawInsides(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawList(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawName(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawObject(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawSpatial(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawStatus(obj: ObjectHandle);
  FORWARD;
PROCEDURE DrawSymbol(obj: ObjectHandle; pt: Point; invert: BOOLEAN);
  FORWARD;
PROCEDURE DrawTinyObject(obj: ObjectHandle; invert: BOOLEAN);
  FORWARD;
PROCEDURE DrawTheIcon(obj: ObjectHandle);
  FORWARD;
PROCEDURE DupContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
PROCEDURE EditCommands(menuItem: INTEGER);
  FORWARD;
PROCEDURE EditName(obj: ObjectHandle; pt: Point);
  FORWARD;
PROCEDURE EmptyTrashCan(volHdl: TentryHdl; diskAlso: BOOLEAN);
  FORWARD;
PROCEDURE EndEdit;
  FORWARD;
PROCEDURE EraseDisk(diskObj: ObjectHandle);
  FORWARD;
PROCEDURE FailedAlert;
  FORWARD;
PROCEDURE FindVisParent(obj: ObjectHandle; VAR visPt: Point;
                                    VAR visObj,placeObj: ObjectHandle);
  FORWARD;
PROCEDURE FlushContents(obj: ObjectHandle);
  FORWARD;
PROCEDURE FlushObject(obj: ObjectHandle);
  FORWARD;
PROCEDURE GenContents(obj: ObjectHandle);
  FORWARD;
PROCEDURE GenTrashContents;
  FORWARD;
PROCEDURE GetContentRect(obj: ObjectHandle; VAR r: Rect);
  FORWARD;
PROCEDURE GetFldStr(hFld: HndField; hFstate: HndFstate; VAR strg: FMaxStr);
  FORWARD;
FUNCTION  GetHomeObj(obj: ObjectHandle): ObjectHandle;
  FORWARD;
PROCEDURE GetListPos(obj: ObjectHandle; tinyIcon: BOOLEAN; VAR pt: Point);
  FORWARD;
FUNCTION  GetPlaceHolder(obj: ObjectHandle): ObjectHandle;
  FORWARD;
PROCEDURE GetWindRect(obj: ObjectHandle; VAR windRect: Rect);
  FORWARD;
PROCEDURE GetWndTitle(obj: ObjectHandle; VAR title: FmaxStr);
  FORWARD;
FUNCTION  GrowHeap(hz: Thz; bytesNeeded: INTEGER): INTEGER;
  FORWARD;
PROCEDURE GrowWindow(obj: ObjectHandle; ptDown: Point);
  FORWARD;
PROCEDURE HandleWhyActivated(event : EventRecord);
  FORWARD;
PROCEDURE HideScroll(obj: ObjectHandle);
  FORWARD;
PROCEDURE HitContainer(obj: ObjectHandle);
  FORWARD;
PROCEDURE HitOrphan(window : WindowPtr);
  FORWARD;
PROCEDURE HitScrollBar(obj: ObjectHandle; whichSb: THsb; whichIcon: TIcon);
  FORWARD;
PROCEDURE InitIcons;
  FORWARD;
PROCEDURE Initialize;
  FORWARD;
{$IFC R}
PROCEDURE InitJournal;
  FORWARD;
{$ENDC}
PROCEDURE InitMatchTable;
  FORWARD;
PROCEDURE InitMyMenus;
  FORWARD;
PROCEDURE InitObjects;
  FORWARD;
PROCEDURE InstallMenus;
  FORWARD;
PROCEDURE InvertContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
PROCEDURE InvertIcon(kind: ObjectKind; topLeft: Point);
  FORWARD;
PROCEDURE InvertObject(obj: ObjectHandle);
  FORWARD;
FUNCTION  IsContainer(obj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE KillContents(obj: ObjectHandle; sonsAlso,erase: BOOLEAN);
  FORWARD;
PROCEDURE KillDuplicates(container: ObjectHandle);
  FORWARD;
PROCEDURE KillObject(obj: ObjectHandle; sonsAlso,erase: BOOLEAN);
  FORWARD;
PROCEDURE KillScroll(window : WindowPtr; needUpdate: BOOLEAN);
  FORWARD;
{$IFC R }
PROCEDURE LastWishes(environPtr : P_env_blk; excepDataPtr : P_term_ex_data);
  FORWARD;
{$ENDC }
FUNCTION  MakeObject(father:      ObjectHandle;
                     nam:         FmaxStr;
                     whatKind:    ObjectKind;
                     whatSubKind: ObjectKind;
                     where:       Point;
                     windRect:    Rect;
                     newState:    ObjectState;
                     whichVol:    TentryHdl;
                     recId:       TcatRID;
                     createTime:  LongInt;
                     modTime:     LongInt;
                     diskSize:    LongInt;
                     filed:       BOOLEAN): ObjectHandle;
  FORWARD;
PROCEDURE MakePadContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
FUNCTION  Match(target: ObjectHandle; srcSet: KindSet; srcCount: INTEGER): BOOLEAN;
  FORWARD;
PROCEDURE MenuCommand(menu,item: INTEGER);
  FORWARD;
{$IFC R}
PROCEDURE MountAvolume(device: Tdevice);
  FORWARD;
{$ENDC}
FUNCTION  MoveContents(obj:        ObjectHandle;
                       whichState: ObjectState;
                       newState:   ObjectState;
                       dh,dv:      INTEGER;
                       dstObject:  ObjectHandle;
                       chooseLoc:  BOOLEAN;
                       eraseDim:   BOOLEAN;
                   VAR anyMoved:   BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  MoveObject(obj: ObjectHandle;
                     dh,dv: INTEGER;
                     dstObj: ObjectHandle;
                     redraw: BOOLEAN;
                     chooseLoc: BOOLEAN;
                     eraseDim: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  MoveToDesk(obj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  MoveToDiffVol(obj,dstObj: ObjectHandle): BOOLEAN;
  FORWARD;
FUNCTION  MoveToSameVol(obj: ObjectHandle; newParent: IDType): BOOLEAN;
  FORWARD;
FUNCTION  MoveToTrash(obj: ObjectHandle; dh,dv: INTEGER): BOOLEAN;
  FORWARD;
PROCEDURE MoveUnfiled(obj: ObjectHandle);
  FORWARD;
FUNCTION  NameWidth(obj: ObjectHandle): INTEGER;
  FORWARD;
FUNCTION  NearList(listHead: ObjectHandle; pt: Point): ObjectHandle;
  FORWARD;
FUNCTION  NewObjList(father: ObjectHandle): ObjectHandle;
  FORWARD;
FUNCTION  NewWindow(obj: ObjectHandle; title: FmaxStr): WindowPtr;
  FORWARD;
FUNCTION  NumFromObj(obj: ObjectHandle): INTEGER;
  FORWARD;
FUNCTION  ObjFromNum(container: ObjectHandle; objNum: INTEGER): ObjectHandle;
  FORWARD;
FUNCTION  ObjFromWindow(window: windowPtr): ObjectHandle;
  FORWARD;
FUNCTION  ObjFromVol(volHdl: TentryHdl): ObjectHandle;
  FORWARD;
PROCEDURE ObjToFront(obj: ObjectHandle; redraw: BOOLEAN);
  FORWARD;

{$IFC R }
FUNCTION  OnDesktop(whichVol: TentryHdl; objID: IDType): BOOLEAN;
  FORWARD;
{$ENDC }

FUNCTION  OneDiskSelected(VAR diskObj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE OpenContents(obj: ObjectHandle; whichState : ObjectState);
  FORWARD;
FUNCTION  OpenObject(obj: ObjectHandle; windRect: Rect;
                     startTool: BOOLEAN): BOOLEAN;
  FORWARD;
PROCEDURE Pause(hundredths: INTEGER);
  FORWARD;

{$IFC R}
PROCEDURE ProcessTheEvent;
  FORWARD;
{$ENDC}

FUNCTION  PutBackContents(obj: ObjectHandle; whichStates: StateSet;
                                             suspendDocs: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  PutBackObject(obj: ObjectHandle; sonsAlso: BOOLEAN;
                                          suspendDoc: BOOLEAN): BOOLEAN;
  FORWARD;
FUNCTION  RandInt(min,max: INTEGER): INTEGER;
  FORWARD;

(*** DS
PROCEDURE ReadIcons;
  FORWARD;
***)

PROCEDURE RepairDisk(diskObj: ObjectHandle);
  FORWARD;
PROCEDURE RestoreDesktop(whichVol: TentryHdl; VAR diskObj: ObjectHandle);
  FORWARD;
FUNCTION  RoomForContents(obj: ObjectHandle; whichState: ObjectState;
                            volHdl: TentryHdl; VAR failVol: TentryHdl): BOOLEAN;
  FORWARD;
FUNCTION  RoomForObject(srcObj: ObjectHandle; volHdl: TentryHdl): BOOLEAN;
  FORWARD;
FUNCTION  RunningDoc(obj: ObjectHandle): BOOLEAN;
  FORWARD;
{$IFC R}
PROCEDURE SaveDesktop(diskObj: ObjectHandle);
  FORWARD;
{$ENDC }
PROCEDURE ScrollContents(obj: ObjectHandle; dh,dv,minH,minV,maxH,maxV: INTEGER;
                         adjustThumb: BOOLEAN);
  FORWARD;
PROCEDURE ScrollLimits(obj: ObjectHandle; VAR minH,minV,maxH,maxV: INTEGER);
  FORWARD;
FUNCTION  SearchContents(obj: ObjectHandle; hVol: TentryHdl; id: IDType;
                                            sonsAlso: BOOLEAN): ObjectHandle;
  FORWARD;
FUNCTION  SearchObject(obj: ObjectHandle; hVol: TentryHdl; id: IDType;
                                             sonsAlso: BOOLEAN): ObjectHandle;
  FORWARD;
PROCEDURE SectClipRgn(window: WindowPtr; r: Rect);
  FORWARD;
PROCEDURE SelAllObjects(container: ObjectHandle);
  FORWARD;
PROCEDURE SelectContents(obj: ObjectHandle; groupRect: Rect);
  FORWARD;
PROCEDURE SelectObject(obj: ObjectHandle; hitName: BOOLEAN);
  FORWARD;
PROCEDURE SelectName(obj: ObjectHandle; hitName: BOOLEAN);
  FORWARD;
PROCEDURE SetAttributes(obj: ObjectHandle);
  FORWARD;
PROCEDURE SetHomePt(obj: ObjectHandle; pt: Point);
  FORWARD;
PROCEDURE SetTimeout(interval: INTEGER);
  FORWARD;
PROCEDURE ShowFld(pStr: PtrString; r: Rect; theAlign: INTEGER; theFont: TFam;
                  theFace: Style);
  FORWARD;
PROCEDURE ShowFldAt(VAR strg: FmaxStr; pt: Point; theAlign: INTEGER; font: TFam;
                    VAR fldRect: Rect);
  FORWARD;
PROCEDURE ShowScrap;
  FORWARD;
PROCEDURE ShowScroll(obj: ObjectHandle);
  FORWARD;
PROCEDURE ShutDown;
  FORWARD;
FUNCTION  SkipEvent: BOOLEAN;
  FORWARD;
PROCEDURE SortContents(obj: ObjectHandle; newView: viewType);
  FORWARD;
FUNCTION  StopDoc(obj: ObjectHandle; suspendDoc,forSure: BOOLEAN): BOOLEAN;
  FORWARD;
PROCEDURE TallyContents(obj: ObjectHandle;
                        whichState: ObjectState;
                        VAR tallyCount: INTEGER;
                        VAR tallySet: KindSet;
                        VAR tallyBBox: Rect;
                        VAR topObject: ObjectHandle);
  FORWARD;
PROCEDURE TearOffContents(obj: ObjectHandle; whichState: ObjectState);
  FORWARD;
FUNCTION  TearOffObject(obj: ObjectHandle): BOOLEAN;
  FORWARD;
PROCEDURE TextKey;
  FORWARD;
FUNCTION  ThumbHpos(obj: ObjectHandle; minH,maxH: INTEGER): INTEGER;
  FORWARD;
FUNCTION  ThumbVpos(obj: ObjectHandle; minV,maxV: INTEGER): INTEGER;
  FORWARD;
PROCEDURE ToggleObject(obj: ObjectHandle);
  FORWARD;
FUNCTION  TopPnlHt(obj: ObjectHandle): INTEGER;
  FORWARD;
FUNCTION  TopVisible: WindowPtr;
  FORWARD;
PROCEDURE UnfileObject(obj: ObjectHandle; deskPt: Point);
  FORWARD;
{$IFC R}
FUNCTION  UnmountAvolume(device: Tdevice; eject,restartDocs: BOOLEAN;
                                          alertNum: INTEGER): BOOLEAN;
  FORWARD;
{$ENDC}
PROCEDURE UpdateContents(obj: ObjectHandle);
  FORWARD;
PROCEDURE UpdateCursor;
  FORWARD;
PROCEDURE UpdateObject(obj: ObjectHandle; sonsAlso: BOOLEAN);
  FORWARD;
PROCEDURE UpdateRec(obj: ObjectHandle; VAR catRec: TcatRec);
  FORWARD;
PROCEDURE UpdateText;
  FORWARD;
PROCEDURE ValidContents(obj: ObjectHandle; whichState: ObjectState; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidIcon(obj: ObjectHandle; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidName(obj: ObjectHandle; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidObject(obj: ObjectHandle; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidScrollBars(window : WindowPtr; good: BOOLEAN);
  FORWARD;
PROCEDURE ValidWindow(window: WindowPtr; good: BOOLEAN);
  FORWARD;
PROCEDURE WalkHome(obj: ObjectHandle);
  FORWARD;
PROCEDURE WalkContents(obj: ObjectHandle; whichState: ObjectState;
                       dhStart,dvStart,dhStop,dvStop: INTEGER);
  FORWARD;
PROCEDURE WalkObject(obj: ObjectHandle; fromPt,toPt: Point);
  FORWARD;
FUNCTION  WhichObject(container: ObjectHandle; pt: Point;
                      VAR hitName: BOOLEAN): ObjectHandle;
  FORWARD;
FUNCTION  WhichSubKind(kind : ObjectKind; toolId : TtoolID) : ObjectKind;
  FORWARD;
FUNCTION  WhichWindow(pt: Point): WindowPtr;
  FORWARD;
PROCEDURE XorIcon(kind: ObjectKind; topLeft: Point);
  FORWARD;
PROCEDURE XorContents(obj: ObjectHandle;
                      whichState: ObjectState; dh,dv: INTEGER);
  FORWARD;
PROCEDURE XorObject(obj: ObjectHandle; dh,dv: INTEGER);
  FORWARD;
PROCEDURE ZoomObject(obj: ObjectHandle; zoomUp: BOOLEAN);
  FORWARD;
PROCEDURE ZoomRect(VAR smallRect,bigRect: Rect; zoomUp: BOOLEAN);
  FORWARD;


{$I apim/TFilerInt.text }


{$S  }
PROCEDURE AdjustMenus;
{ adjusts menu enable/disable state and menu text according to the selection }
VAR obj,nextObj,diskObj,topObject: ObjectHandle;
    tallyCount: INTEGER;
    tallySet: KindSet;
    tallyBBox: Rect;
    enableDiskItems: BOOLEAN;
    enableViewItems: BOOLEAN;
    enableEdit: BOOLEAN;
    fCanClose: BOOLEAN;  { mine -gb }
    itemString,buzzWord,testStr: Str255;
    title: FmaxStr;



  PROCEDURE AdjustItem(menuId,itemId : INTEGER; enable: BOOLEAN);
  BEGIN
  IF enable
    THEN BEGIN
        {additions made for im menu stuff -gb }
      GetItem(flrMenus[menuId],itemId,@testStr);
      IF testStr <> blankStr  { test added for IM Menu stuff -gb }
        THEN EnableItem(flrMenus[menuId],itemId);
      EnableItem(flrNameMenus[menuId],itemId); {changes made for im menu stuff -gb }
     END
  ELSE BEGIN
      DisableItem(flrMenus[menuId],itemId);
      DisableItem(flrNameMenus[menuId],itemId);
    END;
  END;


BEGIN
IF trcFiler THEN WRITELN('AdjustMenus');

TallyContents(activeObject,hilited,tallyCount,tallySet,tallyBBox,topObject);

   { Close menu item }

GetItem(flrMenus[xtraMenu],xClose,@itemString);
fCanClose := (activeObject <> deskObject) AND
              CanFldrClose(activeObject^^.objWindow);
IF fCanClose THEN
   BEGIN
   GetWndTitle(activeObject,title);
   itemString := CONCAT(itemString,' "',title,'"');
   END;

GetItem(flrMenus[filingMenu],mClose,@testStr);
IF testStr <> blankStr                     { test added for IM Menu stuff -gb }
   THEN SetItem(flrMenus[filingMenu],mClose,@itemString);
AdjustItem(filingMenu,mClose,fCanClose);

   { Put Back menu item }

GetItem(flrMenus[xtraMenu],xPutBack,@itemString);
IF activeObject^^.kind IN putBackSet THEN
   BEGIN
   GetWndTitle(activeObject,title);
   itemString := CONCAT(itemString,' "',title,'"');
   END
ELSE IF (activeObject = deskObject) AND ((tallySet * putBackSet) <> []) THEN
   BEGIN
   IF tallyCount = 1 THEN
      itemString := CONCAT(itemString,' "',topObject^^.name,'"')
   ELSE
      BEGIN
      GetItem(flrMenus[xtraMenu],xObjects,@buzzWord);
      itemString := CONCAT(itemString,' ',buzzWord);
      END;
   END;

GetItem(flrMenus[filingMenu],mPutBack,@testStr);
IF testStr <> blankStr                    { test added for IM Menu stuff -gb }
   THEN SetItem(flrMenus[filingMenu],mPutBack,@itemString);
AdjustItem(filingMenu,mPutBack,(activeObject^^.kind IN putBackSet) OR
                                  ((activeObject = deskObject) AND
                                  ((tallySet * putBackSet) <> [])));

   { Open menu item }

GetItem(flrMenus[xtraMenu],xOpen,@itemString);
IF (tallyCount > 0) AND (tallySet <= (allKindsSet - padSet)) THEN
   BEGIN
   AdjustItem(filingMenu,mOpen,TRUE);
   IF tallyCount = 1 THEN
      BEGIN
      IF topObject^^.name <> '' THEN
         itemString := CONCAT(itemString,' "',topObject^^.name,'"');
      END
   ELSE
      BEGIN
      GetItem(flrMenus[xtraMenu],xObjects,@buzzWord);
      itemString := CONCAT(itemString,' ',buzzWord);
      END;
   END
ELSE
   AdjustItem(filingMenu,mOpen,FALSE);

GetItem(flrMenus[filingMenu],mOpen,@testStr);
IF testStr <> blankStr                    { test added for IM Menu stuff -gb }
   THEN SetItem(flrMenus[filingMenu],mOpen,@itemString);


   { other items in filing menu }
AdjustItem(filingMenu,mCloseAll,(TopVisible <> filerFolder));
AdjustItem(filingMenu,mDuplicate,(tallyCount > 0) AND (tallySet <= dupSet));
AdjustItem(filingMenu,mNew,(tallyCount > 0) AND (tallySet <= padSet));
AdjustItem(filingMenu,mMakePad,(tallyCount > 0) AND
                              (tallySet <= ([docKind {* ,folderKind *}] )));
                                {*** make pad of folder needs more work ***}

{ Adjust edit menu items }
AdjustItem(editMenu,mUndoLast,TRUE);
enableEdit := (editObject <> nilObject);
AdjustItem(editMenu,mCopy,enableEdit);
AdjustItem(editMenu,mCut,enableEdit);
AdjustItem(editMenu,mPaste,enableEdit);
AdjustItem(editMenu,mSelectAll,TRUE);

{ adjust view menu items }
enableViewItems := IsContainer(activeObject) AND (activeObject <> deskObject);
AdjustItem(viewMenu,mSpatial,enableViewItems);
AdjustItem(viewMenu,mAlpha,enableViewItems);
AdjustItem(viewMenu,mChron,enableViewItems);
CheckItem(flrMenus[viewMenu],mAlpha,enableViewItems AND
                                      (activeObject^^.viewMode = alphaView));
CheckItem(flrMenus[viewMenu],mChron,enableViewItems AND
                                      (activeObject^^.viewMode = chronView));
CheckItem(flrMenus[viewMenu],mSpatial,enableViewItems AND
                                      (activeObject^^.viewMode = spatialView));


{ adjust disk menu items }
enableDiskItems := OneDiskSelected(diskObj);
AdjustItem(diskMenu,mRepair,enableDiskItems);
AdjustItem(diskMenu,mErase,enableDiskItems);
END;



{$S FilerLow }
PROCEDURE AdjWindRect{* obj : ObjectHandle *};
{ adjusts bottom right to keep scrollbars on screen }
VAR savePort: GrafPtr;
    tempRect: Rect;
    changeSize: BOOLEAN;
    minH,minV,maxH,maxV: INTEGER;
    window: WindowPtr;
BEGIN
IF trcFiler THEN WRITELN('AdjustWindRect "',obj^^.name,'"');
window := obj^^.objWindow;
GetPort(savePort);
SetPort(window);
changeSize := FALSE;
tempRect := window^.portRect;
WITH tempRect DO
   BEGIN
   LocalToGlobal(botRight);
   IF right > screenWidth THEN
      BEGIN
      right := screenWidth;
      changeSize := TRUE;
      END;
   IF bottom > screenHt THEN
      BEGIN
      bottom := screenHt;
      changeSize := TRUE;
      END;
   IF changeSize THEN
      BEGIN
      GlobalToLocal(botRight);
      FolderSize(window,Max(dhSbox,right-left),Max(dvSbox,bottom-top),FALSE);
      ScrollLimits(obj,minH,minV,maxH,maxV);
      obj^^.hThumbPos := ThumbHpos(obj,minH,maxH);
      obj^^.vThumbPos := ThumbVpos(obj,minV,maxV);
      { fixed for imFldrs -gb was: ShowScroll(obj); }
      IF IsContainer(obj) OR (obj^^.imFldr = NIL)
        THEN ShowScroll(obj) ELSE DrawScroll(obj^^.imFldr);
      END;
   END;
SetPort(savePort);
END;



FUNCTION AllInside{* container: ObjectHandle; whichState: ObjectState;
                  dh,dv: INTEGER; targetObj: ObjectHandle): BOOLEAN *};
{ returns TRUE if all locs of objects will be  > topLeft of target window }
{ always TRUE if target viewMode is list }
VAR pos: Point;
    contentRect: Rect;
    son,listHead: ObjectHandle;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('AllInside "',container^^.name,'"');

AllInside := FALSE;
IF targetObj = nilObject THEN EXIT(AllInside);

IF targetObj^^.viewMode <> spatialView THEN
   BEGIN
   AllInside := TRUE;
   EXIT(AllInside);
   END;

GetPort(savePort);
GetContentRect(targetObj,contentRect);
listHead:=container^^.contents;
son:=listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state = whichState THEN
      BEGIN
      IF container^^.viewMode = spatialView THEN
         pos := son^^.loc
      ELSE
         GetListPos(son,FALSE,pos);
      pos.h := pos.h + dh;
      pos.v := pos.v + dv;
      SetPort(container^^.objWindow);
      LocalToGlobal(pos);
      SetPort(targetObj^^.objWindow);
      GlobalToLocal(pos);                 { convert to coords of target window }
      IF (pos.h < 0) OR (pos.v < (contentRect.top-icon2Ht)) THEN
         BEGIN
         SetPort(savePort);
         EXIT(AllInside);
         END;
      END;
   son:=son^^.prev;
   END;
AllInside := TRUE;
SetPort(savePort);
END;


{$S DiskStuff }
PROCEDURE BackupDisk{* srcDisk,dstDisk: ObjectHandle *};
{ initiates the backup of a disk }
CONST respCancel = 1;
      respReplace = 2;
      respAdd = 3;
VAR err: INTEGER;
    srcVol,dstVol: TentryHdl;
    dstDevice: Tdevice;
    response: INTEGER;
    newCatRID: TcatRID;
BEGIN
IF trcFiler THEN WRITELN('BackupDisk "',srcDisk^^.name,
                         '" to "',dstDisk^^.name,'"');
IF NOT (srcDisk^^.kind IN diskSet) THEN EXIT(BackupDisk);
IF NOT (dstDisk^^.kind IN diskSet) THEN EXIT(BackupDisk);

ParamAlert(srcDisk^^.name,dstDisk^^.name,dstDisk^^.name);
{$IFC R}
response := AskAlert(flrAlert,116);  { Cancel, Replace or Add ... }

IF response = respCancel THEN EXIT(BackUpDisk);

srcVol := srcDisk^^.volHdl;
dstVol := dstDisk^^.volHdl;
dstDevice := dstVol^^.devHdl^^.device;
UpdateObject(deskObject,TRUE);  { fix up the display before animation }

{ put back everything on source before copy }
IF NOT CleanupDisk(srcDisk) THEN EXIT(BackupDisk);

IF response = respReplace THEN   { overwrite destination disk with source }
   BEGIN
   ParamAlert(dstDisk^^.name,dstDisk^^.volHdl^^.devHdl^^.userNmHdl^^,'');
   IF NOT CautionAlert(flrAlert,228) THEN EXIT(BackUpDisk);

      { put back everything on destination before copy }
   IF NOT CleanupDisk(dstDisk) THEN EXIT(BackupDisk);

   BackupVol(err,srcVol,dstVol);   { handles error messages }

   { install new volume handles }
   srcDisk^^.volHdl := srcVol;
   dstDisk^^.volHdl := dstVol;

   { take care of destination disk }
   IF (dstDevice IN [upperDrive,lowerDrive]) AND (dstVol <> bootVol) THEN
      BEGIN
      KillObject(dstDisk,TRUE,TRUE);    { remove the icon }
      DismountVol(dstDevice,TRUE,TRUE); { eject the destination disk }
      END;
   END
ELSE IF response = respAdd THEN  { add source contents to destination }
   BEGIN
   {*** check if room before starting.  Use special routine by Frank ***}
   XferObject(err,srcDisk^^.catRID,idDisk,srcVol,dstVol,FALSE,FALSE,0,newCatRID);
   IF err <> 0 THEN
      TellUser (srcVol,dstVol,srcDisk^^.catRID,dstDisk^^.catRID,err);
   END;
{$ELSEC}
StopAlert(imAlert, 401);
{$ENDC}
END;


{$ CopyStuff }
PROCEDURE BlinkContents{* obj: ObjectHandle; whichState: ObjectState *};
{ blinks contents matching "whichState".  No net change to screen }
BEGIN
IF trcFiler THEN WRITELN('BlinkContents "',obj^^.name,'"');
InvertContents(obj,whichState);
Pause(20);   { 0.2 sec }
InvertContents(obj,whichState);
Pause(40);
END;



{$S Filer }
PROCEDURE BlinkObject{* obj: ObjectHandle *};
{ blink an icon, used when an icon is moved over another and accepted }
VAR i: INTEGER;
    blinkTime: LongInt;
BEGIN
IF trcFiler THEN WRITELN('BlinkObject "',obj^^.name,'"');
FOR i:=1 to 6 DO
   BEGIN
   InvertObject(obj);
   blinkTime:=Time+2;  { 1/50 second }
   REPEAT UNTIL Time > blinkTime;
   END;
END;



{$S  }
PROCEDURE ChangeContents{* obj: ObjectHandle;
                           oldState,newState: ObjectState;
                           dh,dv: INTEGER;
                           redraw: BOOLEAN *};
{ change all objects in oldState to newState, }
{ move them dh,dv, and re-draw back to front if flag true }
VAR listHead,son: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('ChangeContents "',obj^^.name,'"');
listHead := obj^^.contents;
son:=listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state=oldState THEN ChangeObject(son,newState,dh,dv,redraw);
   son:=son^^.prev;
   END;
END;



{$S  }
PROCEDURE ChangeObject{* obj: ObjectHandle;
                         newState: ObjectState;
                         dh,dv: INTEGER;
                         redraw: BOOLEAN *};
{ changes state to "newState" adjusts location by dh,dv and redraws if flag true }
VAR isSpatial: BOOLEAN;
BEGIN
IF trcFiler THEN WRITELN('ChangeObject "',obj^^.name,'"');
WITH obj^^ DO
   BEGIN
   dirty := TRUE;
   state := newState;
   IF doDslAll THEN DSlAllEvt;  { event recording -gb }
   isSpatial := (container^^.viewMode = spatialView);
   IF isSpatial THEN
      BEGIN
      loc.h:=loc.h+dh;
      loc.v:=loc.v+dv;
      OffsetRect(nameRect,dh,dv);
      END;
   IF container^^.isOpen THEN {invisible object hack -gb }
   IF redraw THEN
      BEGIN
      DrawTheIcon(obj);
      IF isSpatial AND (newState <> limbo) THEN  { avoids name flash before move }
         DrawName(obj);
      END;
   END;
END;



{$S Filer }
PROCEDURE ChangeParentID{* obj: ObjectHandle; newParentID: IDType *};
{ updates catalog to reflect new parent }
VAR err: INTEGER;
    catRec: TcatRec;
BEGIN
IF trcFiler THEN WRITELN('ChangeParentID "',obj^^.name,'"');
WITH obj^^ DO
   BEGIN
   GetCatRec(err,volHdl,catRID,catRec);
   CheckCatErr(err,'ChangeParentID - Unable to get catRec for update');
   UpdateRec(obj,catRec);
   catRec.parentID := newParentID;
   UpdCatRec(err,volHdl,posCurrent,catRec);
   CheckCatErr(err,'ChangeParentID - Unable to update catRec');
   catRID.fatherID := newParentID;
   END;
END;



{$S FilerLow }
PROCEDURE ChangeView{* obj: ObjectHandle; newView: ViewType *};
{ changes viewing mode and redraws }
VAR rH,rV: Rect;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('ChangeView "',obj^^.name,'"');
IF NOT IsContainer(obj) THEN EXIT(ChangeView);
IF (newView = obj^^.viewMode) THEN EXIT(ChangeView);

EndEdit;   {*** should preserve editing across view changes ***}

IF newView <> spatialView THEN SortContents(obj,newView);

WITH obj^^ DO
   BEGIN
   viewMode := newView;
   hThumbPos := 0;
   vThumbPos := 0;
   END;

{ reset scroll position to topleft }
GetPort(savePort);
SetPort(obj^^.objWindow);
SetOrigin(0,0);
SetPort(savePort);

{ adjust scrollbars for new origin }
IF obj = activeObject THEN ShowScroll(obj);

DrawContents(obj);
END;



{$S Filer }
PROCEDURE CheckContents{* obj: ObjectHandle *};
{ checks all objects in a container for valid field values }
VAR son,listHead: ObjectHandle;
    newLoc: Point;
BEGIN
IF trcFiler THEN WRITELN('CheckContents "',obj^^.name,'"');
listHead:=obj^^.contents;
son:=listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   CheckObject(son);
   son:=son^^.next;
   END;
END;



PROCEDURE CheckHeap{* message: FMaxStr *};
VAR numBlocks: INTEGER;
BEGIN
WRITELN('calling FCheckHz: ',message);
IF NOT FCheckHzOK(theHeap,numBlocks) THEN
   BEGIN
   WRITELN('*** The heap is bad ***   (press return to continue)');
   READLN;
   END;
WRITELN('   ',numBlocks:1,' blocks allocated');
END;



PROCEDURE CheckLoc{* container: ObjectHandle; VAR loc: Point
                                              VAR changed: BOOLEAN *};
{ checks icon location for a reasonable value }
VAR newLoc: Point;
BEGIN
IF trcFiler THEN WRITELN('CheckLoc  (',loc.h:1,',',loc.v:1,') in "',
                                                       container^^.name,'"');
IF (loc.h < 0) OR (loc.h > screenWidth) OR
   (loc.v < -icon2Ht) OR (loc.v > screenHt) THEN
   BEGIN
   ChoosePos(container,newLoc);  { choose a non-overlapping position }
   loc := newLoc;
   changed := TRUE;
   END
ELSE
   Changed := FALSE;
END;



PROCEDURE CheckObject{* obj: ObjectHandle *};
{ checks object an object for valid field values }
VAR changedLoc: BOOLEAN;
BEGIN
IF trcFiler THEN WRITELN('CheckObject "',obj^^.name,'"');
WITH obj^^ DO   { CheckLoc doesn't use heap }
   BEGIN
   CheckLoc(container,loc,changedLoc);
   IF changedLoc THEN obj^^.dirty := TRUE;
   END;
END;



{$S FilerLow }
PROCEDURE ChooseHome{* obj: ObjectHandle; VAR newHomeLoc: Point *};
{ used to determine a spatial home location for an object created on the desktop }
VAR homeObj,placeObj: ObjectHandle;
    catRec: TcatRec;
    err: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('ChooseHome "',obj^^.name,'"');
homeObj := GetHomeObj(obj);
IF homeObj^^.isOpen THEN     { home container is open, choose empty spot }
   BEGIN
   ChoosePos(homeObj,newHomeLoc);
   WITH obj^^ DO
      placeObj :=
         MakeObject(homeObj,name,kind,subKind,newHomeLoc,windowRect,
                    placeHolder,volHdl,catRID,created,modified,size,FALSE);
   placeObj^^.dirty := TRUE;
   DrawObject(placeObj);
   END
ELSE
   SetPt(newHomeLoc,MAXINT,MAXINT); { flag to choose spot when container opened }

SetHomePt(obj,newHomeLoc);   { update catalog }
END;



{$S FilerLow }
PROCEDURE ChoosePos{* container: ObjectHandle; VAR pt: Point *};

{ Find the first free position in container.  If the container is closed then }
{ sets the location to MAXINT as a flag to compute the position when the container
{ is opened.   Chooses a location near the top for containers.  Chooses a location
{ along the right and bottom edges for the desktop. }

CONST hGrid  = 75; { 110; my change -gb }
      vGrid  =  42;
      minH   =  36;
      minV   =   4;
      maxH   = 580;
      maxV   = 300;

VAR listHead: ObjectHandle;
    up: BOOLEAN;
    maxDeskH,maxDeskV: INTEGER;
    numSweeps: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('ChoosePos in "',container^^.name,'"');
IF NOT container^^.isOpen THEN
   BEGIN
   IF trcFiler THEN WRITELN('   container is closed');
   pt.h:=MAXINT;   { flag to choose pt next time container is opened }
   pt.v:=MAXINT;
   EXIT(ChoosePos);
   END;

listHead:=container^^.contents;


IF container = deskObject THEN
   BEGIN           { choose position along LHS or bottom }
   WITH deskObject^^.objWindow^.portRect DO
      BEGIN
      maxDeskH := right - (iconWidth + icon2Width);
      maxDeskV := bottom - (iconHt + iconFntInfo.ascent + iconFntInfo.descent + 4);
      END;
   pt.h := 250; { was - maxDeskH; }
   pt.v := 303; { was - maxDeskV; }
   numSweeps := 0;   { counts number of right-bottom sweeps }
   up := FALSE;  { was TRUE -gb }
   WHILE NearList(listHead,pt) <> nilObject DO
      BEGIN   { something there, try next grid point }
      IF up THEN
         BEGIN
         pt.v := pt.v - vGrid;   { move up right hand side }
         IF pt.v < minV THEN
            BEGIN
            up := FALSE;
            pt.v := maxDeskV - numSweeps*vGrid;
            pt.h := minH;  { was - pt.h - hGrid; }
            END;
         END
      ELSE
         BEGIN
         { pt.h := pt.h - hGrid;   { move left along bottom }
         { IF pt.h < minH THEN
         { used to move left along bottom - we go right here -gb }
         pt.h := pt.h + hGrid;   { move right along bottom }
         IF pt.h > maxDeskH THEN
            BEGIN
            up := TRUE;
            numSweeps := numSweeps + 1;
            pt.h := maxDeskH - numSweeps*hGrid;
            pt.v := pt.v - vGrid;
            IF (pt.h < minH) OR (pt.v < minV) THEN
                BEGIN
                pt.h := maxDeskH;
                pt.v := maxDeskV;
                EXIT(ChoosePos);
                END;
             END;
          END;
       END;
   END
ELSE
   BEGIN     { choose position along top of container }
   pt.h := minH;
   pt.v := minV + TopPnlHt(container);
   WHILE NearList(listHead,pt) <> NilObject DO
      BEGIN
      { try next grid point }
      pt.h:=pt.h + hGrid;
      IF pt.h > maxH THEN
         BEGIN
         pt.h := minH;
         pt.v := pt.v + vGrid;
         IF pt.v > maxV THEN  { all grid spots taken }
            BEGIN
            pt.h := minH;
            pt.v := minV;
            EXIT(ChoosePos);
            END;
         END;
      END;
   END;

END;



{$S DiskStuff }
FUNCTION CleanupDisk{* diskObj: ObjectHandle): BOOLEAN *};
{ saves desktop state and puts back all unfiled objects }


{!!! THIS SHOULD ONLY BE CALLED WHEN PHYLLIS IS CREATING STATE FILES !!!}


VAR listHead,obj,nextObj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('CleanupDisk "',diskObj^^.name,'"');
CleanupDisk := FALSE;

WRITELN('CleanupDisk: disk= ', diskObj^^.name, ' (', ORD(diskObj), ')');

{$IFC R}
SaveDesktop(diskObj);
{$ENDC }

{ put back all opened in place from this disk }
IF NOT PutBackContents(diskObj,allStates,TRUE) THEN
   BEGIN
   {*** couldn't suspend !!?! ***}
   WRITELN('CleanUpDisk - unable to putback contents');
   EXIT(CleanUpDisk);
   END;

{ put back all on desktop from this disk }
listHead := deskObject^^.contents;
obj:=listHead^^.next;
WHILE obj <> listHead DO
   BEGIN
   nextObj := obj^^.next;
   IF Abort THEN EXIT(CleanUpDisk);  { give user a bailout }
   IF obj^^.volHdl = diskObj^^.volHdl THEN
      IF NOT PutBackObject(obj,TRUE,TRUE) THEN
         BEGIN
         {*** what to do??  Doc should have suspended.  (I/O error?) ***}
         WRITELN('CleanUpDisk - unable to putback "',obj^^.name,'"');
         EXIT(CleanUpDisk);
         END;
   obj := nextObj;
   END;

{ remove any icons in trash for this vol }
EmptyTrashCan(diskObj^^.volHdl,FALSE);

  { take care of any update now, looks better }
UpdateObject(deskObject,TRUE);

CleanUpDisk := TRUE;
END;



{$S FilerLow }
PROCEDURE ClimbTree{* whichVol: TentryHdl; recID: TcatRID;
                      VAR fatherRecID: TcatRID; VAR fatherObj: ObjectHandle *};
{ returns recID of father and handle to object if visible }
VAR pCatRec: PtrCatRec;
    err: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('ClimbTree');
{ check if father is visible }
IF fTstTF THEN
  WRITELN('ClimbTree - from cat rec fatherID:', recID.fatherID,
          ' uniqueID: ', recID.uniqueID);
fatherObj := SearchContents(deskObject,whichVol,recID.fatherID,TRUE);
IF fatherObj <> nilObject
THEN BEGIN  {trace modified for testing -gb }
  IF fTstTF THEN
   WRITELN('ClimbTree - searchContents found fatherObj "', fatherObj^^.name, '"');
  fatherRecID := fatherObj^^.catRID;
 END
ELSE BEGIN  { father not visible.  fetch the catalog entry }
   fatherRecID.fatherID := idNil;
   fatherRecID.uniqueID := recID.fatherID;
  IF fTstTF THEN
    WRITELN('ClimbTree - searching catalog for  catRID fID:',
             fatherRecID.fatherID, ' uID:', fatherRecID.uniqueID);
   PosCatRec(err,whichVol,fatherRecID,pCatRec);
   { causes a break -gb
      CheckCatErr(err,'ClimbTree: unable to position to father'); }
   IF err <> 0  { this is replacement err checking -gb }
     THEN BEGIN
       IF fTstTF THEN
         WRITELN('ClimbTree - error in catalog search: ', err);
       IF recID.fatherID = deskObject^^.catRID.uniqueID
         THEN BEGIN
           fatherObj := deskObject;
           fatherRecID := deskObject^^.catRID;
         END
        ELSE BEGIN
           fatherObj := nilObject;
           fatherRecID := nilObject^^.catRID;
         END;
       END
      ELSE BEGIN
         fatherRecID.fatherID := pCatRec^.parentID;  { set father's father }
         IF fTstTF THEN
           WRITELN('ClimbTree catalog search found fatherRecID'); {added trace -gb}
        END;
   END;
  IF fTstTF THEN
    WRITELN('ClimbTree - found "', fatherObj^^.name, '" catRID fID:',
             fatherRecID.fatherID, ' uID:', fatherRecID.uniqueID);
END;



{$S Filer }
PROCEDURE ClipContent{* obj: ObjectHandle *};
{ sets clipping to the content area of a window, excludes scroll & status }
VAR tempRect: Rect;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('ClipContent "',obj^^.name,'"');
GetPort(savePort);
SetPort(obj^^.objWindow);
GetContentRect(obj,tempRect);
ClipRect(tempRect);
SetPort(savePort);
END;



PROCEDURE ClipRight(newRight: INTEGER);
{ sets right coord of clipping rectangle to newRight }
VAR tempRect: Rect;
BEGIN
IF trcFiler THEN WRITELN('ClipRight ',newRight:1);
tempRect := thePort^.clipRgn^^.rgnBBox;  { fetch the current clip rectangle }
IF newRight < tempRect.right THEN tempRect.right := newRight;
ClipRect(tempRect);
END;



FUNCTION CloseContents{* obj: ObjectHandle; putBack,suspendDocs: BOOLEAN): BOOLEAN *};

{ closes all objects contained in obj.  "suspendDocs" tells what kind of  }
{ document shutdown to do (suspend or normal) if documents are encountered }
{ which were opened directly from their filing home.  Returns FALSE and bails }
{ out if any document refuses to shutdown }

VAR son,nextSon,listHead : ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('CloseContents "',obj^^.name,'"');
listHead:=obj^^.contents;
son:=listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   IF Abort THEN EXIT(CloseContents);
   nextSon := son^^.next;
   IF NOT CloseObject(son,TRUE {sons also},putback,suspendDocs) THEN
      BEGIN
      CloseContents := FALSE;
      EXIT(CloseContents);
      END;
   son := nextSon;
   END;
CloseContents := TRUE;
END;



FUNCTION CloseObject{* obj: ObjectHandle; sonsAlso: BOOLEAN; putBack: BOOLEAN;
                                           suspendDoc: BOOLEAN): BOOLEAN *};

{  Zooms the window down to a hilited icon.  If the object is a container then }
{  its content object nodes are freed and the window destroyed.  If the object }
{  is a document then it will be shut down if it was opened directly from its }
{  filing home (or if putBack is TRUE), otherwise its window is hidden.  }
{  CloseObject returns TRUE except in the case of a document which refuses to }
{  shut down (inconsistent, not enough disk space, etc.) }

VAR savePort: GrafPtr;
    anyMoved: BOOLEAN;
    err: INTEGER;
    newState: ObjectState;
    wasActive: TF;   { my addition -gb }
BEGIN
IF trcFiler THEN WRITELN('CloseObject "',obj^^.name,'"');

IF NOT obj^^.isOpen THEN
   BEGIN
   { removed for invis objects and no real docs        -gb }
   {IF putBack AND RunningDoc(obj) THEN    { shut down doc }
   {   CloseObject := StopDoc(obj,suspendDoc,FALSE)
   {ELSE  }
      CloseObject := TRUE;
   EXIT(CloseObject);
   END;

CloseObject := FALSE;
GetPort(savePort);

wasActive := (obj = activeObject);  { mine -gb }

{ de-select all others in closed container }
IF IsContainer(obj)
  THEN BEGIN
    SetDeSelAll;  { causes a deSelect all event if any selected -gb }
    ChangeContents(obj^^.contents,hilited,normal,0,0,TRUE);
   END;
{ de-select all others in same container }
SetDeSelAll;  { causes a deSelect all event if any selected -gb }
ChangeContents(obj^^.container,hilited,normal,0,0,TRUE);

WITH obj^^ DO
   BEGIN
   { remember window location }
   windowRect:=objWindow^.portRect;
   GetPort(savePort);
   SetPort(objWindow);
   LocalToGlobal(windowRect.topLeft);
   LocalToGlobal(windowRect.botRight);
   SetPort(savePort);
   END;

IF obj = scrapObject THEN
   HideFolder(obj^^.objWindow)    { just hide the window for the scrap }
{ this case removed for set aside stuff  - now handle docs like containers }
{ELSE IF obj^^.kind IN docToolSet THEN
{   BEGIN
{   IF (obj^^.container = deskObject) AND (NOT putBack)
{     THEN   {just hide window }
{      HideFolder(obj^^.objWindow)
{   ELSE
{      BEGIN   { shut down the document.  Note document may refuse! }
{      IF NOT StopDoc(obj,suspendDoc,FALSE) THEN EXIT(CloseObject);
{      END;
{   END
}
ELSE IF (obj^^.imFldr <> NIL)  {- added for im stuff -gb }
  THEN BEGIN
    HideFolder(obj^^.objWindow); {just hide window }
    IF fTstTF THEN
      WRITELN('Saving windowPort of ', obj^^.name, ' with imFldr =',
            ORD(obj^^.imFldr));
   END
ELSE
   BEGIN
   { Take care of objects opened from their container, close or move to desktop }
   IF sonsAlso THEN
      BEGIN
      IF NOT CloseContents(obj,putBack,suspendDoc) THEN EXIT(CloseObject);
      END
   ELSE   { Move any objects opened in place from this object to the desktop }
      IF MoveContents(obj,hidden,hidden,0,0,deskObject,TRUE,FALSE,anyMoved) THEN;

   { dispose contents object list }
   { for IM version, dont kill contents.  invisible obj hack -gb
        KillContents(obj,TRUE,FALSE);  }

   { remove the window }
   IF fTstTF THEN {added trace -gb }
     WRITELN('CloseObject - Disposing folder of object "', obj^^.name, '"');
   DisposeFolder(obj^^.objWindow);    { invalidates obj handle }
   obj^^.objWindow := NIL;
   END;

activeObject := ObjFromWindow(activeFolder);   { may have changed }
obj^^.isOpen := FALSE;

{ take care of the any update for container }
UpdateObject(obj^^.container,FALSE);

{ Zoom down }
ZoomObject(obj,FALSE);

ObjToFront(obj,FALSE);   { bring to front since hiliting }
IF wasActive THEN MakeTopActive;

{ If the object's container is the topmost (i.e. active) then redraw
  the icon hilited }
IF (wasActive AND (obj^^.container^^.objWindow = TopVisible))
    OR (obj^^.container = activeObject) THEN
   BEGIN
   newState := hilited;
   SelObjEvt(obj, COpSel);
   SelectName(obj,FALSE);
   END
ELSE BEGIN
   newState := normal;
   END;

ChangeObject(obj,newState,0,0,TRUE);

ClsObjEvt(obj);
CloseObject := TRUE;
END;



FUNCTION CloseSymbol{* kind: ObjectKind): INTEGER *};
{ given an object kind, return the close symbol for its window }
BEGIN
IF trcFiler THEN WRITELN('CloseSymbol');
CASE kind OF
   docKind:
      CloseSymbol := docSymbol;
   folderKind:
      CloseSymbol := folderSymbol;
   diskKind,
   disk1Kind,
   disk2Kind:
      CloseSymbol := diskSymbol;
   profileKind:
      CloseSymbol := profileSymbol;
   docPad:
      CloseSymbol := docPadSymbol;
   folderPad:
      CloseSymbol := fldrPadSymbol;
   calcKind:
      CloseSymbol := calcSymbol;
   toolKind:
      CloseSymbol := toolSymbol;
   scrapKind:
      CloseSymbol := scrapSymbol;
   printKind:
      CloseSymbol := printSymbol;
   computerKind:
      CloseSymbol := compSymbol;
   trashKind:
      CloseSymbol := trashSymbol;
   clockKind:
      CloseSymbol := clockSymbol;
   imKind:
      CloseSymbol := imSymbol;
   OTHERWISE
      CloseSymbol := otherSymbol;
   END;
END;



{$S FilerLow }
PROCEDURE CommandKey;
{ an Apple key was pressed. Do appropriate command if any }
VAR minTime: LongInt;
    whichMenu,whichItem: INTEGER;
    newVolume: SpeakerVolume;
    newWave: MicroSeconds;
BEGIN
IF trcFiler THEN WRITELN('CommandKey');
{$IFC filerDebug }
IF curEvent.ascii = '!' THEN   { command - ! => toggle debugging menu }
   BEGIN
   specialUp := NOT specialUp;
   ClearMenuBar;
   InstallMenus;
   { this is the old version
     IF specialUp THEN
         DeleteMenu(specialMenu)
       ELSE
          InsertMenu(flrMenus[specialMenu],0);
       DrawMenuBar; old version -gb }
   EXIT(CommandKey);
   END;

IF curEvent.ascii = 's' THEN   { set sound parameters }
   BEGIN
   WRITE('Volume (',Volume:1,') ? ');
   READLN(newVolume);
   IF newVolume <> 0 THEN SetVolume(newVolume);
   WRITE('Lowest pitch (8000 - 0) [',bigWave:1,'] ? ');
   READLN(newWave);
   IF newWave <> 0 THEN bigWave := newWave;
   WRITE('Highest pitch (0 - 8000) [',smallWave:1,'] ? ');
   READLN(newWave);
   IF newWave <> 0 THEN smallWave := newWave;
   EXIT(CommandKey);
   END;
{$ENDC }


MenuKey(curEvent.ascii,whichMenu,whichItem);
HiLiteMenu(whichMenu);
minTime:=Time+5;  { 1/20th of a second }
MenuCommand(whichMenu,whichItem);
REPEAT UNTIL Time > minTime;
HiLiteMenu(0);
END;



{$S CopyStuff }
PROCEDURE CopyContents{* obj: ObjectHandle; whichState: ObjectState;
                         dh,dv: INTEGER; madeOnDesk: BOOLEAN *};
{ copies all "whichState" objects on same volume }
VAR son,listHead,diskObj: ObjectHandle;
    failVol: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('CopyContents "',obj^^.name,'"');
IF NOT RoomForContents(obj,whichState,NIL,failVol) THEN
   BEGIN
   diskObj := ObjFromVol(failVol);
   ParamAlert(diskObj^^.name,'','');
   StopAlert(flrAlert,102);  { Insufficient space ... }
   EXIT(CopyContents);
   END;

listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   IF Abort THEN EXIT(CopyContents);
   IF son^^.state = whichState THEN
      BEGIN
      IF NOT CopyObject(son,madeOnDesk) THEN EXIT(CopyContents);   { bail out }
      XorObject(son,dh,dv);                    { remove dim image }
      ChangeObject(son,hilited,dh,dv,TRUE); { draw hilited after copy complete }
      SelObjEvt(son, COpSel);
      END;
   son := son^^.next;
   END;
copyMode := FALSE;
END;



{$S CopyStuff }
FUNCTION CopyObject{* obj: ObjectHandle; madeOnDesk: BOOLEAN): BOOLEAN *};
{ used to make temporary duplicates permanent }
VAR err: INTEGER;
    newCatRID: TcatRID;
    newHomeLoc: Point;
    diskObj,homeObj: ObjectHandle;
    catRec: TcatRec;
    itemString: Str255;
    paramString: TParamAlert;
BEGIN
IF trcFiler THEN WRITELN('CopyObject "',obj^^.name,'"');
diskObj := OnDisk(obj);  { ObjFromVol(obj^^.volHdl); }
IF diskObj = nilObject
  THEN BEGIN
    GetItem(flrMenus[xtraMenu],xDiskette,@itemString);
    paramString := itemString;
    ParamAlert(obj^^.name,paramString,'');
   END
  ELSE ParamAlert(obj^^.name,diskObj^^.name,'');
WaitAlert(flrAlert,101);   { Copying ... }
upTime := Time;

{ make sure catalog is current for this object }
FlushObject(obj);

WITH obj^^ DO
   XferObject(err,catRID,catRID.fatherID,volHdl,volHdl,TRUE,FALSE,0,newCatRID);

IF err <> 0 THEN
   BEGIN
   WITH obj^^ DO TellUser (volHdl,volHdl,catRID,catRID,err);   {*** FL ***}
   (***
   ParamAlert(obj^^.name,'','');
   StopAlert(flrAlert,103);   { Unable to copy ... }
   ***)
   CopyObject := FALSE;
   EXIT(CopyObject);
   END;

obj^^.catRID := newCatRID;
obj^^.toBeCopied := FALSE;

{ if created on desk then ensure home location is ok }
IF madeOnDesk THEN ChooseHome(obj,newHomeLoc);

DupObjEvt(obj);

obj^^.dirty := TRUE;
CopyObject := TRUE;
RemoveAlert;
END;



{$S Filer }
FUNCTION  CountContents{* obj: ObjectHandle): INTEGER *};
{ returns number of objects contained in "obj".   Note: "obj" must be open }
VAR listHead,son: ObjectHandle;
    numObjects: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('CountContents "',obj^^.name,'"');
numObjects := 0;
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   numObjects := numObjects + 1;
   son := son^^.next;
   END;
CountContents := numObjects;
END;



{$S DiskStuff }
PROCEDURE DoDskEvent{* VAR event: EventRecord *};
{ handles disk events and power button }
BEGIN
IF trcFiler THEN WRITELN('DoDskEvent: ',event.keyCap:1);

CASE event.keyCap OF
   powerCode :
      ShutDown;
   disk1InCode :
{$IFC R}
      MountAvolume(upperDrive);
{$ELSEC}
      ;
{$ENDC}
   disk1OutCode :
{$IFC R}
      IF UnmountAvolume(upperDrive,TRUE,TRUE,0) THEN;
{$ELSEC}
      ;
{$ENDC}
   disk2InCode :
{$IFC R}
      MountAvolume(lowerDrive);
{$ELSEC}
      ;
{$ENDC}
   disk2OutCode :
{$IFC R}
      IF UnmountAvolume(lowerDrive,TRUE,TRUE,0) THEN;
{$ELSEC}
      ;
{$ENDC}
   mouseCode:
      BEGIN
      IF sDebug THEN WRITE('Mouse ');  { suppress writelns -gb }
      IF ORD(event.ascii) > 0 THEN
         BEGIN IF sDebug THEN WRITELN('unplugged.'); END
      ELSE
         BEGIN IF sDebug THEN WRITELN('plugged in.'); END;
      END;
   OTHERWISE
      IF sDebug THEN WRITELN('Unknown "disk" command = ',event.keyCap:1);
   END;
END;



{$S  }
PROCEDURE DragContents{* obj: ObjectHandle;
                         whichState: ObjectState;
                         whichKinds: KindSet;
                         tallyCount: INTEGER;
                         startPt: Point;
                         pointAt: ObjectHandle;
                         VAR targetContainer: ObjectHandle;
                         VAR targetIcon: ObjectHandle;
                         VAR targetMatch: BOOLEAN;
                         VAR dh,dv: INTEGER;
                         maxDh,maxDv,minDh,minDv: INTEGER *};

{ drags the specified objects around, blinking valid targets under it       }
{ returns the container object (nilObject if not a valid container)         }
{ returns the target icon if dropped on one (nilObject if not over an icon) }

CONST blinkDelay = 500000;  { disabled }
VAR oldPt,newPt: Point;
    oldTargetIcon: ObjectHandle;
    blinkTime: LongInt;
    targetInverted: BOOLEAN;
    hitName: BOOLEAN;

BEGIN
IF trcFiler THEN WRITELN('DragContents "',obj^^.name,'"');
dh:=0;
dv:=0;
oldTargetIcon:=nilObject;
targetIcon:=nilObject;
targetContainer:=obj;
targetMatch:=FALSE;
targetInverted:=FALSE;
oldPt:=startPt;
blinkTime:=Time+blinkDelay;

XorContents(obj,whichState,0,0);      { draw image in XOR }

{ drag the selection around, hilighting valid targets under it }
REPEAT
   GetMouse(newPt);
   IF (newPt.h <> oldPt.h) OR (newPt.v <> oldPt.v) THEN
      BEGIN
      XorContents(obj,whichState,dh,dv);  { erase old xor image }
      dh:=newPt.h-startPt.h;
      dv:=newPt.v-startPt.v;
      IF dh > maxDh THEN dh:=maxDh;
      IF dv > maxDv THEN dv:=maxDv;
      IF dh < minDh THEN dh:=minDh;
      IF dv < minDv THEN dv:=minDv;
      XorContents(obj,whichState,dh,dv);  { draw new xor image }
      oldPt:=newPt;

      targetContainer := ObjFromWindow(WhichWindow(newPt));    { which container }
      targetIcon := WhichObject(targetContainer,newPt,hitName);{ over which icon }
      IF hitName THEN targetIcon := nilObject;           { ignore name }

      IF targetIcon <> oldTargetIcon THEN
         BEGIN
         IF targetInverted THEN   { un-invert old target if its inverted }
            BEGIN
            InvertObject(oldTargetIcon);
            targetInverted:=FALSE;
            END;


          IF targetIcon^^.state IN [nilState,limbo,hidden,placeHolder] THEN
             targetMatch:=FALSE
          ELSE
             targetMatch:=Match(targetIcon,whichKinds,tallyCount);

          { If the object pointed at when dragging began is over its own
            placeholder then pretend the place holder doesn't exist }
          WITH targetIcon^^ DO
             IF state = placeHolder THEN
                IF (volHdl = pointAt^^.volHdl) AND
                   (catRID.uniqueID = pointAt^^.catRID.uniqueID) THEN
                   targetIcon := nilObject;

          IF targetMatch THEN
             BEGIN
             InvertObject(targetIcon);
             targetInverted:=TRUE;
             END;

          oldTargetIcon:=targetIcon;
        END;
    END;

  IF targetMatch AND (Time > blinkTime) THEN
     BEGIN
     blinkTime:=Time+blinkDelay;
     InvertObject(targetIcon);
     targetInverted:=NOT targetInverted;
     END;

UNTIL NOT StillDown;

{ un-invert target if it's inverted }
IF targetInverted THEN InvertObject(targetIcon);
END;



{$S  }
PROCEDURE DragRect{* startPt: Point; VAR dstRect: Rect *};
{ get a rectangle from the mouse by dragging out a flickering outline }
VAR saveMode: INTEGER;
    newPt,oldPt: Point;
BEGIN
IF trcFiler THEN WRITELN('DragRect');
dstRect.topLeft:=startPt;
dstRect.botRight:=startPt;
PenPat(gray);
PenMode(notPatXor);
oldPt:=startPt;
WHILE StillDown DO
   BEGIN
   GetMouse(newPt);
   IF (newPt.h <> oldPt.h) OR (newPt.v <> oldPt.v) THEN
      BEGIN
      FrameRect(dstRect);   { hide old }
      Pt2Rect(startPt,newPt,dstRect);
      FrameRect(dstRect);   { draw new }
      oldPt:=newPt;
      END;
   END;
FrameRect(dstRect);   { hide final image }
PenNormal;
END;



{$S  }
PROCEDURE DrawContents{* obj: ObjectHandle *};
{ draw the contents of an object in its display mode }
VAR savePort: GrafPtr;
BEGIN
IF (NOT obj^^.isOpen) OR (NOT IsContainer(obj)) THEN EXIT(DrawContents);
IF trcFiler THEN WRITELN('DrawContents "',obj^^.name,'"');

GetPort(savePort);

WITH obj^^ DO
   BEGIN
   SetPort(objWindow);
   IF obj = deskObject THEN
      FillRect(objWindow^.portRect,gray)
   ELSE
      BEGIN
      ClipScrollBars(objWindow,TRUE);
      EraseRect(objWindow^.portRect);
      END;
   END;

DrawStatus(obj);

CASE obj^^.viewMode OF
   spatialView:
      DrawSpatial(obj);
   alphaView,chronView:
      DrawList(obj);
   END;

SetPort(savePort);
END;



{$S  }
PROCEDURE DrawInsides{* obj: ObjectHandle *};
{ call appropriate drawing routine based on which object }
BEGIN
IF trcFiler THEN WRITELN('DrawInsides "',obj^^.name,'"');
IF obj = nilObject THEN EXIT(DrawInsides);

IF (obj <> deskObject) AND
   (isContainer(obj) OR (obj^^.imFldr = NIL)) THEN
  IF obj^^.objWindow = activeFolder
    THEN ShowScroll(obj)
    ELSE HideScroll(obj);

IF obj = scrapObject THEN
   ShowScrap
ELSE IF obj^^.kind IN docToolSet THEN
   DummyDisplay(obj^^.objWindow)
ELSE
   DrawContents(obj);
IF obj^^.imFldr <> NIL THEN ReDrawFldrContents(obj^^.imFldr);
END;



{$S Filer }
PROCEDURE DrawList{* obj: ObjectHandle *};
{ draws contents in list mode }
VAR son,listHead: ObjectHandle;
    savePort: GrafPtr;
    fldRect: Rect;
    tinyPt: Point;
    dateStr,timeStr: String10;
    numStr: NumberStr;
    strg : FMaxStr;
    itemString: Str255;
BEGIN
IF trcFiler THEN WRITELN('DrawList "',obj^^.name,'"');
GetPort(savePort);
SetPort(obj^^.objWindow);

{ create bounding rectangle for column titles }
WITH fldRect DO
   BEGIN
   left := 40;
   right := thePort^.portRect.right;
   top := thePort^.portRect.top+TopPnlHt(obj);  { titles start below top panel }
   bottom := top + lineHt;
   END;

{ draw column titles }
IF RectInRgn(fldRect,thePort^.visRgn) THEN
   BEGIN
   GetItem(flrMenus[xtraMenu],xTitle,@itemString);
   strg := itemString;
   ShowFld(@strg,fldRect,left,sysText,[underline]);

   fldRect.right := 350;
   GetItem(flrMenus[xtraMenu],xSize,@itemString);
   strg := itemString;
   ShowFld(@strg,fldRect,right,sysText,[underline]);

   fldRect.right := 475;
   GetItem(flrMenus[xtraMenu],xModified,@itemString);
   strg := itemString;
   ShowFld(@strg,fldRect,right,sysText,[underline]);

   fldRect.right := 600;
   GetItem(flrMenus[xtraMenu],xCreated,@itemString);
   strg := itemString;
   ShowFld(@strg,fldRect,right,sysText,[underline]);
   END;

ClipContent(obj);

fldRect.top := TopPnlHt(obj);
tinyPt.h := 10;
listHead := obj^^.contents;
son := listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   { create bounding rectangle for list entry }
   WITH fldRect DO
      BEGIN
      left := 0;
      right := thePort^.portRect.right;
      top := top + lineHt;
      bottom := top + lineHt;
      END;

   WITH son^^ DO
      BEGIN
      nameRect := fldRect;
      nameRect.left := 40;
      nameRect.right := 250;
      END;

   { draw the symbol, name, and attributes }
   IF RectInRgn(fldRect,thePort^.visRgn) THEN
      BEGIN
      tinyPt.v := fldRect.bottom - botToBaseLn - 13;
      DrawSymbol(son,tinyPt,FALSE);

      DrawName(son);

      IntToStr(son^^.size,numStr);
      fldRect.right := 350;
      ShowFld(@numStr,fldRect,right,sysText,[]);

      TimeToStr(son^^.modified,dateStr,timeStr);
      fldRect.right := 475;
      ShowFld(@dateStr,fldRect,right,sysText,[]);

      TimeToStr(son^^.created,dateStr,timeStr);
      fldRect.right := 600;
      ShowFld(@dateStr,fldRect,right,sysText,[]);
      END;

   son:=son^^.prev;
   END;

SetPort(savePort);
END;



{$S  }
PROCEDURE DrawName{* obj: ObjectHandle *};
{ draw an object's name, special case name being edited }
VAR fldPt: Point;
    someChars: BOOLEAN;
    newNameRect: Rect;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('DrawName "',obj^^.name,'"');

IF NOT obj^^.container^^.isOpen THEN EXIT(DrawName);  { invisible obj fix -gb }

GetPort(savePort);
SetPort(obj^^.container^^.objWindow);

{IF (LENGTH(obj^^.name) = 0) AND (obj <> editObject)
 { This was taken from beginning of DrawName to fix nr bug #3 - edit2Obj name }
 { not erased when edit name is erased. -gb 3/2/83                            }
{  THEN BEGIN
{    EXIT(DrawName);
{  END; }

IF obj^^.container^^.viewMode = spatialView THEN
   BEGIN
   WITH obj^^ DO
      BEGIN
      fldPt.h := loc.h + icon2Width;     { compute name location }
      fldPt.v := loc.v + iconHt + iconFntInfo.ascent + 1;
      END;

   IF obj = editObject THEN
      BEGIN
      MoveField(hCurFld,hCurFstate,fldPt);   { compute new bounding box }
      newNameRect := hCurFld^^.coords;

      { if name is smaller than before then invalidate it to update uncovered area }
      IF (newNameRect.right - newNameRect.left) <
         (obj^^.nameRect.right - obj^^.nameRect.left) THEN
         BEGIN
         IF trcFiler THEN WRITELN('   name is smaller, must erase and redraw all ');
         InvalRect(obj^^.nameRect);    { add name rect to update region }
         WITH hCurFstate^^ DO          { tell fld ed that caret is gone }
            BEGIN
            selectOn := FALSE;
            visCaret := FALSE;
            END;
         obj^^.nameRect := newNameRect;  { set name rect so update will draw }
         UpdateObject(obj^^.container,FALSE);  { updates area and draws smaller name }
         END
      ELSE     { new name is same or larger, just draw it }
         BEGIN
         IF trcFiler THEN WRITELN('   name is same or larger, call DrawFldAt ');
         someChars := (hCurFld^^.curLen > 0);
         DrawFldAt(hCurFld,hCurFState,fldPt,FALSE {show select} ,someChars {erase});
         IF someChars THEN
            BEGIN     { Start caret blinking if appropriate }
            HilightSel(hCurFld,hCurFstate,TRUE);
            StartBlink(timeoutInterval);
            END
         ELSE
            timeoutInterval := noTimeout;
         SetTimeout(timeoutInterval);
         obj^^.nameRect := newNameRect;
         END;
      END
   ELSE BEGIN
      IF (LENGTH(obj^^.name) > 0) { lisaGuide nr bug #3 fix 3/3/83 }
        THEN ShowFldAt(obj^^.name,fldPt,center,iconNamFont,obj^^.nameRect);
     END;
   END
ELSE       { list view }
   BEGIN
   { clip to keep name from overwriting attributes }
   ClipRight(obj^^.nameRect.right);
   IF obj = editObject THEN
      BEGIN
      DrawField(hCurFld,hCurFstate,FALSE,TRUE);
      IF hCurFld^^.curLen > 0 THEN
         BEGIN
         HilightSel(hCurFld,hCurFstate,TRUE);
         StartBlink(timeoutInterval);
         END
      ELSE
         timeoutInterval := noTimeout;
      SetTimeout(timeoutInterval);
      END
   ELSE
      ShowFld(@obj^^.name,obj^^.nameRect,left,sysText,[]);
   ClipContent(obj^^.container);   { reset clipping to container }
   END;

SetPort(savePort);
END;



{$S  }
PROCEDURE DrawObject{* obj: ObjectHandle *};
BEGIN
IF NOT obj^^.container^^.isOpen THEN EXIT(DrawObject);

IF trcFiler THEN WRITELN('DrawObject "',obj^^.name,'"');

IF obj^^.container^^.viewMode <> spatialView THEN
   DrawTinyObject(obj,FALSE)
ELSE
   BEGIN
   DrawTheIcon(obj);
   DrawName(obj);
   END;
END;



{$S  }
PROCEDURE DrawSpatial{* obj: ObjectHandle *};
{ draws contents in spatial view mode (back to front) }
VAR son,listHead: ObjectHandle;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('DrawSpatial "',obj^^.name,'"');
GetPort(savePort);

ClipContent(obj);
listHead := obj^^.contents;
son := listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   DrawObject(son);
   son := son^^.prev;
   END;

SetPort(savePort);
END;



{$S Filer }
PROCEDURE DrawStatus{* obj: ObjectHandle *};
{ draws status panel if appropriate at top of window }
LABEL 1;
VAR freeStr,sizeStr: NumberStr;
    statusStr: Str255;
    dateStr,timeStr: String10;
    fldRect: Rect;
    savePort: GrafPtr;
    itemString: Str255;
BEGIN
IF trcFiler THEN WRITELN('DrawStatus "',obj^^.name,'"');
GetPort(savePort);
SetPort(obj^^.objWindow);
IF obj^^.kind IN diskSet THEN
   BEGIN
   fldRect := thePort^.portRect;
   fldRect.bottom := fldRect.top + TopPnlHt(obj);

   IF NOT RectInRgn(fldRect,thePort^.visRgn) THEN GOTO 1;

   WITH obj^^ DO
      BEGIN
      IntToStr(freeSpace,freeStr);
      IntToStr(size,sizeStr);
      IF backedup = 0 THEN BEGIN
         GetItem(flrMenus[xtraMenu],xNever,@itemString);
         dateStr := itemString;
        END
      ELSE
         TimeToStr(backedup,dateStr,timeStr);
      END;

   GetItem(flrMenus[xtraMenu],xBlocksFree,@itemString);
   statusStr := CONCAT(' ',freeStr,' ', itemString,' ',sizeStr);
   GetItem(flrMenus[xtraMenu],xBackedUp,@itemString);
   statusStr := CONCAT(statusStr, '. ', itemString, ': ',dateStr,'.');
   ShowFld(@statusStr,fldRect,left,sysText,[]);

   MoveTo(0,fldRect.bottom-1);
   LineTo(thePort^.portRect.right,fldRect.bottom-1);

   END;
1:
SetPort(savePort);
END;



PROCEDURE DrawSymbol{* obj: ObjectHandle; pt: Point; invert: BOOLEAN *};
{ draws small icon for list view & and window top left }
VAR charCode: INTEGER;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('DrawSymbol "',obj^^.name,'"  at: ',pt.h,pt.v,
                         '  invert: ',invert,'  state: ',ORD(obj^^.state):1);
GetPort(savePort);
SetPort(obj^^.container^^.objWindow);

charCode := CloseSymbol(obj^^.kind);

IF thePort = menuFolder THEN BEGIN
  WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
TextFont(wmFont);

IF NOT invert THEN
   BEGIN   { if not inverting then erase, current before drawing new }
   MoveTo(pt.h,pt.v);
   TextMode(srcBic);
   DrawChar(CHR(blackSymbol));     { erase the area }
   MoveTo(pt.h,pt.v);
   IF obj^^.state IN [hidden,limbo,placeHolder] THEN
      BEGIN
      TextMode(srcOr);
      DrawChar(CHR(charCode+1));    { OR on the mask }
      MoveTo(pt.h,pt.v);
      TextMode(srcBic);
      DrawChar(CHR(graySymbol));   { punch holes in it }
      END
   ELSE
      BEGIN
      TextMode(srcOr);
      DrawChar(CHR(charCode));     { draw the symbol }
      END;
   END;

IF (obj^^.state = hilited) OR invert THEN
   BEGIN
   MoveTo(pt.h,pt.v);
   TextMode(srcXor);
   DrawChar(CHR(charCode+1));
   END;

TextMode(srcOr);
SetPort(savePort);
END;



{$S Filer }
PROCEDURE DrawTinyObject{* obj: ObjectHandle; invert: BOOLEAN *};
{ draws object in when container viewing mode is a list }
VAR pt: Point;
BEGIN
IF trcFiler THEN WRITELN('DrawTinyObject "',obj^^.name,'"');
IF NOT obj^^.container^^.isOpen THEN EXIT(DrawTinyObject);

GetListPos(obj,TRUE,pt);
DrawSymbol(obj,pt,invert);
END;



{$S  }
PROCEDURE DrawTheIcon{* obj: ObjectHandle *};
LABEL 1;
VAR objKind,sub: ObjectKind;
    savePort: GrafPtr;
    h,v:      INTEGER;
    dstRect:  Rect;

BEGIN
IF trcFiler THEN WRITELN('DrawTheIcon');

IF NOT obj^^.container^^.isOpen THEN EXIT(DrawTheIcon);  { invisible obj fix -gb }

IF obj^^.container^^.viewMode <> spatialView THEN
   BEGIN
   DrawTinyObject(obj,FALSE);
   EXIT(DrawTheIcon);
   END;

GetPort(savePort);
SetPort(obj^^.container^^.objWindow);

  objKind := obj^^.kind;
  sub := obj^^.subKind;
  IF objKind = imKind
    THEN BEGIN
      objKind := docKind; {my kludge -gb }
      sub := imKind; {my kludge -gb }
     END;
  h := obj^^.loc.h;             { topLeft of where to draw 48 by 32 }
  v := obj^^.loc.v;

IF thePort = menuFolder THEN BEGIN
  WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
  TextFont(fIconFont);
  TextMode(srcBic);
  MoveTo(h,v);
  DrawChar(iconMask[objKind]);   { use mask to punch a hole in the screen }
  TextMode(srcOr);

  CASE obj^^.state OF

    hidden,limbo,placeHolder:  { draw ltGray or white }
      BEGIN
        IF thePort = filerFolder THEN GOTO 1;  { use white image }

        dstRect := iconBoxes[objKind];
        OffsetRect(dstRect,h,v);
        PenPat(dkGray);
        PenMode(patXor);
        PaintRect(dstRect);           { xor some gray onto the screen }
        MoveTo(h,v);
        DrawChar(iconMask[objKind]);  { draw the icon mask }
        PaintRect(dstRect);           { gray the mask and restore the rest }
        PenNormal;
        GOTO 1;
      END;

    normal,hilited:
      BEGIN
        MoveTo(h,v);
        DrawChar(iconData[objKind]);
      END;
  END;

  IF sub <> nilKind THEN   { OR on the data from subKind icon }
    BEGIN
      MoveTo(h,v);
      DrawChar(iconData[sub]);
    END;

  IF obj^^.state=hilited THEN   { use mask to invert the icon }
    BEGIN
      TextMode(srcXor);
      MoveTo(h,v);
      DrawChar(iconMask[objKind]);
    END;

1:
SetPort(savePort);
END;




{$S CopyStuff }
PROCEDURE DupContents{* obj: ObjectHandle; whichState: ObjectState *};

{ duplicate all whichState objects in the list, bringing new copies to front }
{ Note: the copy of disk files represented by the objects is postponed until }
{ the duplicate(s) are moved to their destination }

VAR son,prevSon,listHead,lastObject,newObj: ObjectHandle;
    newLoc,newHomeLoc: Point;
BEGIN
IF trcFiler THEN WRITELN('DupContents "',obj^^.name,'"');

EndEdit;
listHead:=obj^^.contents;
lastObject:=listHead^^.next;
son:=listHead;
prevSon:=son^^.prev;

WHILE son <> lastObject DO
   BEGIN
   son:=prevSon;
   prevSon:=son^^.prev;

   IF son^^.state=whichState THEN
      BEGIN
      WITH son^^ DO
         BEGIN           { determine location for the duplicate }
         newLoc.h:=loc.h+icon2Width;
         IF newLoc.h + iconWidth > obj^^.objWindow^.portRect.right THEN
            newLoc.h:=newLoc.h-iconWidth;

         newLoc.v:=loc.v+icon2Ht;
         IF newLoc.v + iconHt > obj^^.objWindow^.portRect.bottom THEN
            newLoc.v:=newLoc.h-iconHt;

         state:=normal;
         newObj:=MakeObject(obj,name,kind,subKind,newLoc,windowRect,hilited,
                            volHdl,catRID,created,modified,size,
                            (obj <> deskObject));
         END;

      newObj^^.toBeCopied := TRUE;     { postpone actual copy }
      copyMode := TRUE;

      IF obj^^.viewMode = spatialView THEN
         BEGIN
         ValidIcon(son,FALSE);
         DrawObject(newObj);
         END;
      END;
   END;

IF obj^^.viewMode <> spatialView THEN
   BEGIN
   SortContents(obj,obj^^.viewMode);
   DrawContents(obj);  { redraw list }
   END;
END;



{$S FilerLow }
PROCEDURE EditCommands{* menuItem: INTEGER *};
{ handles commands from the "Edit" menu }
VAR err: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('EditComands');
err := 0;
CASE menuItem OF
   mUndoLast:
      UndoEdit(hCurFld,hCurFstate,err);
   mCopy,mCut:
      CutCopyField(hCurFld,hCurFstate,(menuItem=mCut),TRUE,err);
   mPaste:
      PasteField(hCurFld,hCurFstate,err,FALSE,MAXINT);
   mSelectAll:
      SelAllObjects(activeObject);
   END;

IF menuItem IN [mUndoLast,mCopy,mCut,mPaste] THEN
   SetTimeout(0);   { force field to be redrawn }
IF err <> 0 THEN
   WRITELN('field editor error: ',err:1);
END;



{$S FilerLow }
PROCEDURE EditName{* obj: ObjectHandle; pt: Point *};
{ called when a button down occurs in the name of the object setup for editing}
VAR savePort: GrafPtr;
    dataPtr: PtrData;
    nbrHood: Rect;
BEGIN
IF trcFiler THEN WRITELN('EditName "',obj^^.name,'"');
IF obj^^.toBeCopied THEN EXIT(EditName);       { can't name until created }
IF obj <> editObject THEN EXIT(EditName);

rnmObjIdx := GetObjIdx(curObjTable, editObject);
rnmName := editObject^^.name;

IF hCurFld^^.curLen = 0 THEN EXIT(EditName);

pt := curEvent.where;
LocalToGlobal(pt);

GetPort(savePort);
SetPort(obj^^.container^^.objWindow);

GlobalToLocal(pt);   { convert mouse pt to local coords for this window }

IF curEvent.shiftKey THEN
   GrowSel(pt,hCurFld,hCurFstate,nbrHood)   { extend the selection }
ELSE
   BEGIN
   HilightSel(hCurFld,hCurFstate,FALSE);   { turn off current selection }
   CASE clickCount OF
      1: Select(pt,hCurFld,hCurFstate,nbrHood,timeoutInterval);
      2: SelectWord(pt,hCurFld,hCurFstate,nbrHood,timeoutInterval);
      OTHERWISE
         SelectAll(hCurFld,hCurFstate,timeoutInterval);
      END;
   END;

{ grow the selection while the button is down }
WHILE StillDown DO
   IF clickCount < 3 THEN
      BEGIN
      GetMouse(pt);
      IF NOT PtInRect(pt,nbrHood) THEN
         GrowSel(pt,hCurFld,hCurFstate,nbrHood);
      END;

{ Set the timeout to blink the caret if appropriate }
IF (clickCount = 1) AND NOT curEvent.shiftKey THEN
   StartBlink(timeoutInterval)
ELSE
   timeoutInterval := noTimeout;

ObscureCursor;
SetTimeout(timeoutInterval);
SetPort(savePort);
END;



{$S FilerLow }
PROCEDURE EmptyTrashCan{* volHdl: TentryHdl; diskAlso: BOOLEAN *};
{ destroys all closed objects in the trash can on the given volume }
VAR obj,nextObj,listHead: ObjectHandle;
    catRID: TcatRID;
BEGIN
IF trcFiler THEN WRITELN('EmptyTrashCan');
{ destroy icons if trash can is open }
IF TRUE {trashObject^^.isOpen} THEN  { for im do this anyway -gb      2/22/83 }
   BEGIN                             { fix for non-reported lisa guide bug #2 }
   listHead:=trashObject^^.contents;
   obj:=listHead^^.next;
   WHILE obj <> listHead DO
      BEGIN
      nextObj:=obj^^.next;
      IF (obj^^.volHdl = volHdl) AND (obj^^.state = normal) THEN
         BEGIN
         catRID := obj^^.catRID;
         KillObject(obj,TRUE,TRUE);
         IF diskAlso THEN ShredObject(volHdl,catRID);
         END;
      obj:=nextObj;
      END;
   END
ELSE   { trash can is closed.  Just destroy disk structures }
   IF diskAlso THEN ShredContents(volHdl,trashCatRID);
END;



{$S Filer }
PROCEDURE EndEdit;
{ terminates editing of current field }
VAR savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('EndEdit');
IF editObject = nilObject THEN EXIT(EndEdit);

GetFldStr(hCurFld,hCurFstate,editObject^^.name);  { extract the edited name }
FlushObject(editObject);

IF NOT editObject^^.container^^.isOpen
  THEN BEGIN  { invisible object check -gb }
    IF cDebug OR fTstTF THEN
      WRITELN('Called EndEdit on obj whose container is closed "',
         editObject^^.name, '" container "', editObject^^.container^^.name, '"');
    Holdit(cDebug);
   END
ELSE BEGIN
GetPort(savePort);
SetPort(editObject^^.container^^.objWindow);
ExitField(hCurFld,hCurFState);
SetPort(savePort);
END;

uInfo.lastOp := noOp;  { end undo capability for this field }

RNmObjEvt(editObject);
editObject := nilObject;
edit2Object := nilObject;
SetTimeout(noTimeout);
SetStdCursor(icrsInactive);
END;



{$S DiskStuff }
PROCEDURE EraseDisk{* diskObj: ObjectHandle *};
{ reinitializes a disk }
VAR err: INTEGER;
    deviceType: Tdevice;
    deviceName: FMaxStr;
    newVolHdl: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('EraseDisk "',diskObj^^.name,'"');
IF NOT (diskObj^^.kind IN diskSet) THEN EXIT(EraseDisk);

{$IFC R}
WITH diskObj^^.volHdl^^.devHdl^^ DO
   BEGIN
   deviceName := userNmHdl^^;
   deviceType := device;
   END;

IF diskObj^^.volHdl = bootVol THEN
   BEGIN
   ParamAlert (deviceName,'','');
   StopAlert(flrAlert,112);    { Can't erase startup disk ... }
   EXIT(EraseDisk);
   END;

{ Put everything away before asking for confirmation
               so that user can see what will be destroyed }
IF NOT CleanupDisk(diskObj) THEN EXIT(EraseDisk);

{ ask user if s/he really wants to do this }
ParamAlert (diskObj^^.name,deviceName,'');
IF NOT CautionAlert(flrAlert, 228) THEN EXIT(EraseDisk);
{$ELSEC}
ParamAlert (diskObj^^.name,'','');
StopAlert(imAlert, 402);
{$ENDC}

UpdateObject(deskObject,TRUE);   { repaint under alert box }

{$IFC R}
ParamAlert(deviceName,'','');
IF NOT UnmountAvolume(deviceType,FALSE {don't eject},FALSE,234 {wait alert}) THEN
   BEGIN
   HideFolder(alertFolder);
   EXIT(EraseDisk);
   END;

ReinitializeVol(err,deviceType,newVolHdl);

IF err = 0 THEN
   diskObj^^.volHdl := newVolHdl
ELSE
   BEGIN   { failed.  Remove disk icon and eject the disk }
   KillObject(diskObj,TRUE,TRUE);
   DismountVol(deviceType,TRUE {eject},TRUE {resume docs});
   END;
HideFolder(alertFolder);
{$ENDC}
END;



{$S FilerLow }
PROCEDURE FailedAlert;
{ Called by alert manager when an error occurs using the alert manager package }
BEGIN
WRITELN('*** Alert manager error = ',alertError);
StopAlert(flrAlert,2);   { Problem reading startup disk ... }
END;



{$S Filer }
PROCEDURE FindVisParent{* obj: ObjectHandle; VAR visPt: Point;
                                             VAR visObj,placeObj: ObjectHandle *};
{ climbs object tree looking for first visible parent }
LABEL 100;  { my addition -gb }
VAR savePort: GrafPtr;
    whichVol: TentryHdl;
    recID,fatherRecID: TcatRID;
BEGIN
IF trcFiler THEN WRITELN('FindVisParent "',obj^^.name,'"');
GetPort(savePort);

whichVol := obj^^.volHdl;
recID := obj^^.catRID;

{ search for first visible ancestor }
REPEAT
   ClimbTree(whichVol,recID,fatherRecID,visObj);
   IF fatherRecID.uniqueID = recID.uniqueID
    { added because my catalogs arent perfect -gb }
     THEN BEGIN
       IF sDebug OR fTstTF THEN
         WRITELN('FindVisParent - loop in climbTree - using DeskObject');
       IF sDebug THEN WRITELN('Tell Geoff about this!. type <cr> to go on');
       HoldIt(sDebug);
       visObj := DeskObject;
       GOTO 100;
      END;
   recID := fatherRecID;
   IF (NOT visObj^^.isOpen) AND (NOT visObj^^.container^^.isOpen)
     THEN visObj := nilObject;  {added (invis object) fix -gb }
UNTIL visObj <> nilObject;
100:

WITH visObj^^ DO
   BEGIN
   IF isOpen THEN
      BEGIN                { must be father. return closed position }
      placeObj := SearchContents(visObj,obj^^.volHdl,obj^^.catRID.uniqueID,FALSE);
      IF placeObj = nilObject THEN
         WRITELN('FindVisParent - can''t locate place holder object');
      IF viewMode = spatialView THEN
         visPt := placeObj^^.loc
      ELSE
         GetListPos(placeObj,FALSE,visPt);
      SetPort(objWindow);
      END
   ELSE
      BEGIN                { not open, return icon position }
      placeObj := nilObject;
      IF container^^.viewMode = spatialView THEN
         visPt:=loc
      ELSE
         GetListPos(visObj,FALSE,visPt);
      SetPort(container^^.objWindow);
      END;
   END;

LocalToGlobal(visPt);

IF trcFiler THEN WRITELN('   first vis = "',visObj^^.name,'"');

SetPort(savePort);
END;



PROCEDURE FlushContents{* obj: ObjectHandle *};
{ updates catalog for each dirty object in container }
VAR son,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('FlushContents "',obj^^.name,'"');
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   FlushObject(son);
   son := son^^.next;
   END;
END;



PROCEDURE FlushObject{* obj: ObjectHandle *};
{ updates catalog from memory structures }
VAR err: INTEGER;
    catRec: TcatRec;
BEGIN
WITH obj^^ DO
  IF (volHdl <> NIL) AND (volHdl <> bootVol) {dont update boot vol for im -gb}
     AND dirty THEN
   BEGIN
   IF trcFiler THEN WRITELN('FlushObject "',obj^^.name,'"');
   GetCatRec(err,volHdl,catRID,catRec);
   CheckCatErr(err,'Unable to fetch object record for updating');
   UpdateRec(obj,catRec);
   UpdCatRec(err,volHdl,posCurrent,catRec);
   CheckCatErr(err,'Unable to update');
   END;
END;



PROCEDURE GenContents{* obj: ObjectHandle *};
{ produces the contents list for an object }
{ objects are read from catalog in alphabetical order }
VAR catRID   : TcatRID;
    objID    : IDType;
    whichVol : TentryHdl;
    pCatRec  : PtrCatRec;
    son      : ObjectHandle;
    err      : INTEGER;
    objName  : FmaxStr;
    subKind  : ObjectKind;
BEGIN
IF trcFiler THEN WRITELN('GenContents "',obj^^.name,'"');

IF NOT IsContainer(obj) THEN EXIT(GenContents);

whichVol := obj^^.volHdl;
objID    := obj^^.catRID.uniqueID;

{ position to first record of contents }
posApprox.fatherID := objID;
PosCatRec(err,whichVol,posApprox,pCatRec);

{ create an object node for each record }
WHILE (err = 0) AND (pCatRec^.parentID = objID) DO
   WITH pCatRec^ DO
      BEGIN
      ExtObjName(pCatRec^,objName);
      subKind := WhichSubKind(objKind,toolId);
      catRID.fatherID := parentID;
      catRID.uniqueID := selfID;
      son := MakeObject(obj,objName,objKind,subKind,closedPt,openRect,normal,
                        whichVol,catRID,created,modified,objSize,TRUE);
      IF OnDesktop(whichVol,selfId) THEN son^^.state := placeHolder;
      PosCatRec(err,whichVol,posNext,pCatRec);
      END;

IF (err <> 0) AND (err <> endOfCat) THEN
   CheckCatErr(err,'GenContents - reading sons');

IF obj^^.viewMode <> spatialView THEN
   SortContents(obj,obj^^.viewMode);
END;



PROCEDURE GenTrashContents;
{ produces union of trash on all volumes }
VAR whichVol: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('GenTrashContents');
whichVol := firstVol;
WHILE whichVol <> NIL DO
   BEGIN
   IF whichVol^^.catOpen THEN
      BEGIN
      trashObject^^.volHdl := whichVol;
      GenContents(trashObject);
      END;
   whichVol := whichVol^^.nextHdl;
   END;
trashObject^^.volHdl := bootVol;   { restore proper volHdl }
END;



PROCEDURE GetContentRect{* obj: ObjectHandle; VAR r: Rect *};
{ returns the content rectangle }
BEGIN
IF trcFiler THEN WRITELN('GetContentRect "',obj^^.name,'"');
r := obj^^.objWindow^.portRect;
WITH r DO
   BEGIN
   top := top + TopPnlHt(obj);             { adjust for status panel }
   IF obj^^.viewMode <> spatialView THEN   { adjust for column titles }
      top := top + lineHt;
   IF obj <> deskObject THEN               { adjust for scrollbars }
      BEGIN
      right := right - dhSbox + 1;
      bottom := bottom - dvSbox + 1;
      END;
   END;
END;



{$S FilerLow }
PROCEDURE GetFldStr{* hFld: HndField; hFstate: HndFstate; VAR strg: FMaxStr *};
{ extracts the current value of a field }
VAR i,fldLength: INTEGER;
    dataPtr: PtrData;
BEGIN
{$R-}
fldLength := MIN(hFld^^.curLen,SIZEOF(strg)-1);
IF hFstate = NIL THEN
   BEGIN
   dataPtr := @strg;
   MoveLeft(hFld^^.curValue^^,dataPtr^[1],fldLength);
   END
ELSE
   BEGIN
   FOR i := 0 TO fldLength-1 DO
      strg[i+1] := CHR(hFld^^.curValue^^[ExpandedLp(i,hFld,hFstate)]);
   END;

strg[0] := CHR(fldLength);
{$R+}

IF trcFiler THEN WRITELN('GetFldStr "',strg,'"');
END;



{$S Filer }
FUNCTION GetHomeObj{* obj: ObjectHandle): ObjectHandle *};
{ returns a the filing home of obj, nilObject if not visible }
BEGIN
IF trcFiler THEN WRITELN('GetHomeObj "',obj^^.name,'"');
GetHomeObj := SearchContents(deskObject,obj^^.volHdl,obj^^.catRID.fatherId,TRUE);
END;



PROCEDURE GetListPos{* obj: ObjectHandle; tinyIcon: BOOLEAN; VAR pt: Point *};
{ returns an object's list view icon position }
VAR objNum,vPos: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('GetListPos "',obj^^.name,'"');
objNum := NumFromObj(obj);
vPos := (objNum+1)*lineHt + TopPnlHt(obj^^.container);
SetPt(pt,10,vPos-botToBaseLn-13);

IF NOT tinyIcon THEN
   WITH pt DO   { adjust pt so that large icon is centered over tiny icon }
      BEGIN
      h := h - 12;
      v := v - 12;
      END;
END;



FUNCTION GetPlaceHolder{* obj: ObjectHandle): ObjectHandle *};
{ searches for the placeholder for obj }
VAR testObj,placeObj,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('GetPlaceHolder for "',obj^^.name,'"');
listHead := deskObject^^.contents;
testObj := listHead^^.next;
WHILE testObj <> listHead DO
   BEGIN
   IF testObj <> obj THEN
      BEGIN
      placeObj := SearchObj(testObj,obj^^.volHdl,obj^^.catRID.uniqueId,TRUE);
      IF placeObj^^.state = placeHolder THEN
         BEGIN
         GetPlaceHolder := placeObj;
         IF trcFiler THEN WRITELN('   found placeholder in "',
                                  placeObj^^.container^^.name,'"');
         EXIT(GetPlaceHolder);
         END;
      END;
   testObj := testObj^^.next;
   END;
GetPlaceHolder := nilObject;
IF trcFiler THEN WRITELN('   placeholder not found');
END;



PROCEDURE GetWindRect{* obj: ObjectHandle; VAR windRect: Rect *};
{ positions and sizes newly created container windows }
CONST
  contWidth = 580;
  contHt    = 250;
VAR savePort: GrafPtr;
    fatherPos: Point;

BEGIN
IF trcFiler THEN WRITELN('GetWindRect "',obj^^.name,'"');
GetPort(savePort);
IF IsContainer(obj) AND wantAutoSize THEN
   BEGIN
   SetRect(windRect,0,0,contWidth,contHt);
   IF obj^^.container = deskObject THEN
      OffsetRect(windRect,RandInt(5,15),RandInt(40,60))
   ELSE
      BEGIN   { offset from father container }
      SetPort(obj^^.container^^.objWindow);
      fatherPos:=thePort^.portRect.topLeft;
      LocalToGlobal(fatherPos);

      OffsetRect(windRect,fatherPos.h+RandInt(25,60),fatherPos.v+RandInt(20,40));
      { make sure it is totally visible }
      WITH windRect DO
         IF (top > 300) OR (left > 500) THEN   { would be too small }
            BEGIN
            SetRect(windRect,0,0,contWidth,contHt);
            OffsetRect(windRect,RandInt(10,30),RandInt(40,60));
            END
         ELSE
            BEGIN
            IF right > screenWidth THEN right:=screenWidth;
            IF bottom > screenHt THEN bottom:=screenHt;
            END;
      END;
   END
ELSE
  windRect:=obj^^.windowRect;

SetPort(savePort);
END;



PROCEDURE GetWndTitle{* obj: ObjectHandle; VAR title: FmaxStr *};
{ returns the name to be used in the window when an object is open }
VAR itemString: Str255;
    titleItem: TC;
BEGIN
IF trcFiler THEN WRITELN('GetWndTitle "',obj^^.name,'"');
IF obj^^.name <> '' THEN
   BEGIN
   title := obj^^.name;
   EXIT(GetWndTitle);
   END;

{ LisaGuide nr fix #4 for translation 0ld code ...
CASE obj^^.kind OF
   folderKind:     title := 'Folder';
   docKind:        title := 'Untitled';
   trashKind:      title := 'Wastebasket';
   calcKind:       title := 'Calculator';
   computerKind:   title := 'Preferences';
   scrapKind:      title := 'Clipboard';
   clockKind:      title := 'Clock';
   lanternKind,
   toolBoxKind,
   houseKind,
   bookKind,
   toolKind:       title := 'Tool';
   diskKind,
   disk1Kind,
   disk2Kind:      title := 'Diskette';
   profileKind:    title := 'Disk';
   OTHERWISE       title := 'Untitled';
   END;
 *** replaced by new code... }

CASE obj^^.kind OF
   folderKind:     titleItem := xFolder;
   docKind:        titleItem := xUntitled;
   trashKind:      titleItem := xWastebasket;
   calcKind:       titleItem := xCalculator;
   computerKind:   titleItem := xPreferences;
   scrapKind:      titleItem := xClipboard;
   clockKind:      titleItem := xClock;
   lanternKind,
   toolBoxKind,
   houseKind,
   bookKind,
   toolKind:       titleItem := xTool;
   diskKind,
   disk1Kind,
   disk2Kind:      titleItem := xDiskette;
   profileKind:    titleItem := xDisk;
   OTHERWISE       titleItem := xUntitled;
   END;

  GetItem(flrMenus[xtraMenu],titleItem,@itemString);
  title := itemString;
  { end of LisaGuide nr fix #4 made 3/2/83 -gb  }

  obj^^.name := title;  {reset the title -gb }
  SetValidObj(obj, FALSE);


END;



{$S FInit }
FUNCTION GrowHeap{* hz: Thz; bytesNeeded: INTEGER): INTEGER *};
VAR errNum: INTEGER;
    newMemSize: LongInt;
    newDiskSize: LongInt;
    dsInfo: DsInfoRec;
BEGIN
IF trcFiler THEN WRITELN('GrowHeap');
Info_DataSeg(errNum,flrHeapRefnum,dsInfo);
WRITELN('"',flrHeapName,'" is full.   Current size = ',dsInfo.mem_size:1,
        '  bytesNeeded = ',bytesNeeded:1);
Size_Dataseg(errNum,flrHeapRefnum,bytesNeeded,newMemSize,bytesNeeded,newDiskSize);
IF errNum <= 0 THEN
   BEGIN
   WRITELN('"',flrHeapName,'" has been expanded to ',newMemSize:1);
   GrowHeap := newMemSize - dsInfo.mem_Size;
   END
ELSE
   BEGIN
   WRITELN;
   WRITELN('Unable to expand "',flrHeapName,'" by ',bytesNeeded:1,' bytes.  err: ',
            errNum:1);
   WRITELN('Current data segment size = ',dsInfo.mem_size:1);
   GrowHeap := 0;
   END;
END;



PROCEDURE GrowWindow{* obj: ObjectHandle; ptDown: Point *};

{ change the size of the active window }

VAR window: WindowPtr;
    newBotRight: Point;
    width,height,minH,minV,maxH,maxV: INTEGER;
    needUpdate: BOOLEAN;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('GrowWindow "',obj^^.name,'"');
window := obj^^.objWindow;
IF (window = filerFolder) THEN EXIT(GrowWindow);
IF NOT CanFldrGrow(window) THEN EXIT(GrowWindow);

GetPort(savePort);
SetPort(window);

{ drag XOR frame with scrollbars until mouse button is released }
DragFrame(ptDown,TRUE,newBotRight);

WITH window^.portRect DO
   IF (newBotRight.h <> botRight.h) OR (newBotRight.v <> botRight.v) THEN
      BEGIN
      width := MAX(dhSbox,newBotRight.h - topLeft.h);
      height := MAX(dvSbox,newBotRight.v - topLeft.v);
      needUpdate := (newBotRight.h > botRight.h) OR (newBotRight.v > botRight.v);
      KillScroll(window,needUpdate); { erase and invalidate old scroll bars }
      FolderSize(window,width,height,needUpdate);
      ScrollLimits(obj,minH,minV,maxH,maxV);
      obj^^.hThumbPos := ThumbHpos(obj,minH,maxH);
      obj^^.vThumbPos := ThumbVpos(obj,minV,maxV);
      SzObjEvt(obj, height, width);  { im evt rec -gb }
      { fixed for im below -gb ... was: ShowScroll(obj); }
      SetFldrSize(obj^^.imFldr, width, height, NIL);
      IF IsContainer(obj) OR (obj^^.imFldr = NIL)
        THEN ShowScroll(obj) ELSE DrawScroll(obj^^.imFldr);
      END;

SetPort(savePort);
END;



{$S  }
PROCEDURE HandleWhyActivated{* event : EventRecord *};
{ handles the "why" field for activate events }
VAR clsObj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('HandleWhyActivated');
CASE event.why OF

   whyNot: ;

   whyClick:    { window mgr sends this when user buttons down in window }
      BEGIN
      clickCount:=1;
      clickLoc:=event.where;
      clickTime:=event.when+clickDelay;
      HitContainer(activeObject);
      END;

   whyClose:    { window mgr sends this when a window is to be closed (dbl click)}
      BEGIN
      clsObj := ObjFromWindow(Pointer(event.userData));
      IF CloseObject(clsObj,FALSE,FALSE,FALSE)
        THEN IF clsObj^^.container <> deskObject THEN BackObjEvt(clsObj);
          { generate a put back event if obj is closed in place }
      TopActive;
      END;

{$IFC R}
   whyDisk:    { window mgr sends this when power or disk buttons pushed }
      BEGIN
      DoDskEvent(event);
      TopActive;
      END;
{$ENDC}

   whyDied:     { application sends this via "ImDying" }
      BEGIN
{$IFC R}
      FinishTerminating;
{$ENDC}
       TopActive;
     END;

   whyHitOrphan:  { filer sends this to itself so that it is active first }
      BEGIN
      HitOrphan(orphanHit);
      END;



   { These come from applications when an item from the first menu is chosen }

   cmdClose:
      BEGIN
      IF CloseObject(ObjFromWindow(event.fromFolder),FALSE,FALSE,FALSE) THEN;
      TopActive;
      END;

   cmdClosAll:
      BEGIN
      IF CloseContents(deskObject,FALSE,FALSE) THEN;
      TopActive;  { ensure that filer is active }
      END;

{   cmdPutBack:
{      BEGIN
{      IF NOT PutBackObject(ObjFromWindow(event.fromFolder),FALSE,FALSE) THEN;
{      TopActive;
{      END; }

   OTHERWISE
      BEGIN
      WRITELN('Filer activated with unknown why = ',event.why:1);
      END;

   END;  { case why }
END;



PROCEDURE HideScroll{* obj: ObjectHandle *};
{ erases scroll bar contents but leaves border }
VAR window: WindowPtr;
    savePort: GrafPtr;
 BEGIN
IF trcFiler THEN WRITELN('HideScroll "', obj^^.name, '"');

window := obj^^.objWindow;

{ stuff for imFldr scroll bars  }
IF (window = filerFolder) OR (window = NIL) THEN EXIT(HideScroll);
IF (NOT IsContainer(obj)) AND (obj^^.imFldr <> NIL)
  THEN BEGIN IMHideScroll(obj^^.imFldr); EXIT(HideScroll) END;

GetPort(savePort);
SetPort(window);
ClipRect(window^.portRect);
HideSborder(window^.portRect);
ClipContent(obj);
SetPort(savePort);
END;



{$S  }
PROCEDURE HitContainer{* obj: ObjectHandle *};

{ Handles button down events in container windows (including desktop) }
{ Handles selection of objects.  Decides what to do after objects have }
{ been dragged }

VAR newPt,oldPt:  Point;
    pointAt,targetIcon,targetContainer,diskObj,topObject: ObjectHandle;
    targetMatch:  BOOLEAN;
    groupRect:    Rect;
    windRect:     Rect;
    dh,dv:        INTEGER;

    tallyCount:   INTEGER;   { how many things are selected }
    tallySet:     KindSet;   { what kinds are selected }
    tallyBBox:    Rect;
    maxDh,maxDv:  INTEGER;
    minDh,minDv:  INTEGER;
    savePort:     GrafPtr;
    anyMoved:     BOOLEAN;
    srcIsList,dstIsList: BOOLEAN;
    redrawSrc,redrawDst: BOOLEAN;
    hitName: BOOLEAN;


   PROCEDURE RefuseMove;
   { rejects move attempt by moving icons back to starting point }
   BEGIN
   IF trcFiler THEN WRITELN('RefuseMove');
   XorContents(obj,limbo,dh,dv);   { erase final xor }
   UpdateObject(deskObject,TRUE);       { cleanup screen before animation }
   WalkContents(obj,limbo,dh,dv,0,0);           { animate back }
   ChangeContents(obj,limbo,hilited,0,0,TRUE);  { hilite those left }
   END;


BEGIN
{ Quit if not a container }
IF NOT IsContainer(obj) THEN EXIT(HitContainer);

IF trcFiler THEN WRITELN('HitContainer "',obj^^.name,'"');

srcIsList := (obj^^.viewMode <> spatialView);
oldPt := curEvent.where;

{ determine which object was pointed at }
pointAt := WhichObject(obj,oldPt,hitName);

{ exit copy mode if didn't point at a blinking duplicate }
IF copyMode AND (NOT pointAt^^.toBeCopied) THEN KillDuplicates(obj);

{ Stop current editing if pointed at an object other than that currently being edited }
IF pointAt <> editObject THEN EndEdit;

{ check if pointed at name }
IF hitName THEN
   BEGIN
   IF pointAt = editObject THEN        { clicked in name set up for editing }
      EditName(pointAt,curEvent.where)
   ELSE IF curEvent.shiftKey THEN      { Shift clicked in name of different icon }
      ToggleObject(pointAt)
   ELSE                                { clicked in name of different icon }
      SelectObject(pointAt,TRUE);
   EXIT(HitContainer);
   END;

{ if pointed in empty space then drag out a rectangle for a group selection }
IF pointAt = nilObject THEN
   BEGIN
   IF NOT curEvent.shiftKey THEN BEGIN
      SetDeSelAll;  { causes a deSelect all event if any selected -gb }
      ChangeContents(obj,hilited,normal,0,0,TRUE); { de-select all }
     END;
   IF NOT srcIsList THEN
      BEGIN
      DragRect(oldPt,groupRect);
      SelectContents(obj,groupRect);
      END;
   EXIT(HitContainer);
   END;

{ ignore clicks on ghost icons }
IF pointAt^^.state IN [hidden,placeHolder] THEN EXIT(HitContainer);

{ if double click then open an icon or tear off from pad }
IF clickCount = 2 THEN
   BEGIN
   EndEdit;
   TallyContents(obj,hilited,tallyCount,tallySet,tallyBBox,topObject);
   IF tallySet <= (allKindsSet - padSet) THEN
      BEGIN
      IF NOT copyMode THEN
         BEGIN
         OpenContents(obj,hilited);
         TopActive;
         END;
      END
   ELSE IF tallySet <= padSet THEN      { if pads only then create new objects }
      TearOffContents(obj,hilited);
   EXIT(HitContainer);
   END;

{ if shift-click then toggle a single object }
IF curEvent.shiftKey THEN
   BEGIN
   EndEdit;
   ToggleObject(pointAt);
   EXIT(HitContainer);
   END;

{ none of the above, so just select the object pointed at }
IF pointAt^^.state = normal THEN SelectObject(pointAt,FALSE);

{ put in a little hysteresis to minimize flashing if just selecting }
REPEAT
   GetMouse(newPt);
   dh:=ABS(newPt.h-oldPt.h);
   dv:=ABS(newPt.v-oldPt.v);
   IF NOT StillDown THEN EXIT(HitContainer);
UNTIL (dh > 3) OR (dv > 2);


{ Moved a little. Prepare to move the selection }

{ scan the selection }
TallyContents(obj,hilited,tallyCount,tallySet,tallyBBox,topObject);

{ make bounding box of selection global and set up maxDeltas for dragging }
GetPort(savePort);
SetPort(curEvent.who);
LocalToGlobal(tallyBBox.topLeft);
LocalToGlobal(tallyBBox.botRight);
SetPort(savePort);

maxDh:=screenWidth-tallyBBox.right;
maxDv:=screenHt-tallyBBox.bottom;
minDh:=0-tallyBBox.left;
minDv:=0-tallyBBox.top;

{ hide the selection }
ChangeContents(obj,hilited,limbo,0,0,TRUE);

{ drag the selection around, hilighting valid targets under it, leaves Xor image }
DragContents(obj,limbo,tallySet,tallyCount,oldPt,pointAt,
             targetContainer,targetIcon,targetMatch,
             dh,dv,maxDh,maxDv,minDh,minDv);

dstIsList := (targetContainer^^.viewMode <> spatialView);
redrawSrc := FALSE;
redrawDst := FALSE;


IF targetIcon = nilObject THEN       { over empty space in a window }
   BEGIN
   IF AllInside(obj,limbo,dh,dv,targetContainer) THEN
      BEGIN
      IF targetContainer = obj THEN     { changed location in same container }
         BEGIN
         IF copyMode THEN
            BEGIN
            ValidContents(obj,limbo,FALSE);  { erase at old location }
            CopyContents(obj,limbo,dh,dv,(obj=deskObject));  { do postponed copy }
            END
         ELSE IF NOT srcIsList THEN
            BEGIN
            ValidContents(obj,limbo,FALSE);  { erase at old location }
            XorContents(obj,limbo,dh,dv);  { erase dim images }
            ChangeContents(obj,limbo,limbo,dh,dv,TRUE);{ adjust location }
            MovContEvt(obj, limbo);  { this is inserted for im event rec }
              { otherwise the changecontents could be in one call }
            ChangeContents(obj,limbo,hilited,0,0,TRUE);{ adjust state }
            END;
         END
              { moved to a different window }
      ELSE IF Match(targetContainer,tallySet,tallyCount) THEN
         BEGIN   { move to a different open container }
         IF tallySet * diskSet = [] THEN   { don't move disk icon to open disk ?? }
            BEGIN
            IF MoveContents(obj,limbo,hilited,dh,dv,targetContainer,dstIsList,
                                                               TRUE,anyMoved) THEN
               MakeFldrActive(targetContainer^^.objWindow,whyNot);
            IF anyMoved AND (tallyCount = 1) AND NOT dstIsList THEN
               SelectName(pointAt,FALSE);
            redrawSrc := srcIsList AND anyMoved AND
                         (targetContainer <> deskObject);
            redrawDst := dstIsList AND anyMoved;
            END;
         END;
      END;
   END

ELSE      { The icon is over another icon }
   BEGIN
   IF targetMatch THEN
      BEGIN
          { special case moving disks }
      IF (pointAt^^.kind IN diskSet) AND (targetIcon^^.kind IN diskSet) THEN
         BEGIN
         BackupDisk(pointAt,targetIcon);
         RefuseMove;              { return source disk to its desk location }
         DrawObject(pointAt);     { redraw source (update cleared in backup) }
         EXIT(HitContainer);
         END;

      { blink and hilite target icon if transfer accepted }
      BlinkObject(targetIcon);
      IF MoveContents(obj,limbo,hilited,dh,dv,targetIcon,TRUE,TRUE,anyMoved) THEN
         BEGIN
         ChangeObject(targetIcon,hilited,0,0,TRUE);
         IF targetContainer <> activeObject THEN
            MakeFldrActive(targetContainer^^.objWindow,whyNot);
         END;
      redrawSrc := srcIsList AND anyMoved;
      END;
   END;

RefuseMove;             { return any that weren't transferred }
KillDuplicates(obj);    { remove any temporary duplicates that weren't copied }

IF redrawDst THEN
   BEGIN
   SortContents(targetContainer,targetContainer^^.viewMode);
   DrawContents(targetContainer);
   END;
IF redrawSrc THEN DrawContents(obj);
END;



{$S FilerLow }
PROCEDURE HitOrphan{* window : WindowPtr *};

{ handles button down events in orphans. An orphan is a document window that is }
{ temporarily being managed by the filer.  Some ways in which orphans come about }
{ are: a tool crashes, a diskette is removed which has code for a document that }
{ is still online, etc. }

VAR
   docHdl : TentryHdl;
   savePort: GrafPtr;

BEGIN
IF trcFiler THEN WRITELN('HitOrphan: ',ORD(window):1);

                     {!!!!GEOFF REWRITE THIS!!!!}

   { Is this one of our orphans ? }
docHdl:=WindowToDocEntry(window);
IF docHdl = NIL THEN EXIT (HitOrphan);

GetPort(savePort);

{$IFC R}
StartDoc(docHdl,FALSE);
{$ENDC}
SetPort(savePort);
MakeFldrActive(window,whyNot);   { let it know its active }
END;



PROCEDURE HitScrollBar{* obj: ObjectHandle; whichSb: THsb; whichIcon: TIcon *};
{ handles vertical and horizontal scrolling of containers }
VAR newThumb: INTEGER;
    longThumb: LongInt;  { used to coerce long arithmetic (avoid overflow) }
    window: WindowPtr;
    contentRect: Rect;
    dh,dv,minH,minV,maxH,maxV,newLeft,newTop: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('HitScrollBar "',obj^^.name,'"');
window := obj^^.objWindow;
ClipRect(window^.portRect);             { open up clipping }
ScrollLimits(obj,minH,minV,maxH,maxV);  { determine scroll limits }
GetContentRect(obj,contentRect);
dh := 0;
dv := 0;

CASE whichIcon OF

   iconThumb:
      BEGIN
      DragThumb(whichSb,curEvent.where,newThumb);
      IF trcFiler THEN WRITELN('   thumb to: ',newThumb:1);
      longThumb := newThumb;
      WITH contentRect DO
         IF whichSb = hsbH THEN
            BEGIN
            newLeft := MAX(minH,longThumb*(maxH-(right-left)) DIV maxThumb);
            IF trcFiler THEN WRITELN('   right: ',right:1,'  left: ',left:1,
                                     '  newLeft: ',newLeft:1);
            dh := left - newLeft;
            obj^^.hThumbPos := newThumb;
            END
         ELSE
            BEGIN
            newTop := MAX(minV,longThumb*(maxV-(bottom-top)) DIV maxThumb);
            dv := top - newTop;
            obj^^.vThumbPos := newThumb;
            END;
      ScrollContents(obj,dh,dv,minH,minV,maxH,maxV,FALSE);
      END;

   iconArwA,iconArwB:
      BEGIN
      PaintArw(whichSb,whichIcon,TRUE);

      IF whichSb = hsbH THEN
         IF whichIcon = iconArwA THEN
            dh := hScrollInc
         ELSE
            dh := -hScrollInc
      ELSE
         IF whichIcon = iconArwA THEN
            dv := lineHt
         ELSE
            dv := -lineHt;

      WHILE StillDown DO
         ScrollContents(obj,dh,dv,minH,minV,maxH,maxV,TRUE);

      PaintArw(whichSb,whichIcon,FALSE);
      END;

   iconPagA,iconPagB:
      BEGIN
      WITH contentRect DO
         BEGIN
         IF whichSb = hsbH THEN
            IF whichIcon = iconPagA THEN
               dh := right - left
            ELSE
               dh := left - right
         ELSE
            IF whichIcon = iconPagA THEN
               dv := bottom - top
            ELSE
               dv := top - bottom;
         END;

      WHILE StillDown DO
         ScrollContents(obj,dh,dv,minH,minV,maxH,maxV,TRUE);
      END;
   END;

ClipContent(obj);
END;



{$S FInit }
PROCEDURE InitFldStuff;
VAR modifier: TModifier;
    r: Rect;
    fntInfo: FontInfo;
    err: INTEGER;
    s:Tstr;
BEGIN
IF trcFiler THEN WRITELN('InitFldStuff');
{ s:='xAx x9x x$x x%x x.9 x.% 9,9 A''A';  done in iminit -gb }
{ FEInit(theHeap,@s);                                        }

{ create field to be used by drawing procedure "ShowFldAt" & "ShowFld" }
SetRect(r,0,0,0,0);
hShowFld := CreateField(r,fMaxStrLen,0,center,2{pad},1{runs},0,
                        iconNamFont,FALSE);         { protected field }
DisposeHandle(Pointer(ORD(hShowFld^^.curValue)));
             { Not needed. Will pt to data }

{ create field to be used for editing }
hCurFld := CreateField(r,fMaxStrLen,0,center,2{pad},1{runs},0,
                       iconNamFont,FALSE);         { protected field }
hCurFstate := Pointer(ORD(NewHandle(SizeOf(hCurFstate^^))));

IF thePort = menuFolder THEN BEGIN
  WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
TextFont(iconNamFont);
GetFontInfo(iconFntInfo);  { fetch font size information }
IF trcFiler THEN
   WITH iconFntInfo DO
      WRITELN('  icon font ascent: ',ascent:1,'  descent: ',descent:1);

TextFont(sysText);
GetFontInfo(fntInfo);
WITH fntInfo DO
  BEGIN
  lineHt := ascent+descent+leading;
  lineHt := ((lineHt+3) DIV 4)*4;        { must be multiple of 4 }
  botToBaseLn := descent + ((lineHt - (ascent+descent) + 1) DIV 2);
  END;

SetTimeout(noTimeout);      { no timeouts for now }
END;



{$S FInit }
PROCEDURE InitFlrHeap;

{ Initialize the heap for filer objects }

CONST dsSize = $4000;   { 16K bytes for now }

VAR errNum:             INTEGER;
    openErrNum:         INTEGER;
    dsAddr:             LongInt;
    dsName:             PathName;
    dsInfo:             DsInfoRec;
    newMemSize:         LongInt;
    newDiskSize:        LongInt;

BEGIN
IF trcFiler THEN WRITELN('InitFlrHeap');
{$IFC R}
dsName := flrHeapName;
Open_DataSeg(openErrNum,dsName,flrHeapRefnum,dsAddr,flrHeapLDSN);
IF openErrNum <= 0 THEN
   BEGIN
   SetAccess_DataSeg(errNum,flrHeapRefnum,FALSE);    { allow write access }
   Info_DataSeg(errNum,flrHeapRefnum,dsInfo);        { how big is is it? }
   Size_Dataseg(errNum,flrHeapRefnum,                { set it to its initial size }
                dsSize - dsInfo.mem_Size, newMemSize,
                dsSize - dsInfo.disc_size, newDiskSize);
   IF errNum <> 0 THEN
      BEGIN
      WRITELN('InitFlrHeap failed on Size_Dataseg.  err = ',errNum:1);
      Halt;
      END;
   END
ELSE
   BEGIN  { openErrNum > 0  --> hard error }
   Kill_DataSeg(errNum,dsName);
   Make_DataSeg(errNum,dsName,dsSize,dsSize,flrHeapRefnum,dsAddr,flrHeapLDSN,
                ds_private);   {*** shared to guarantee space?? ***}
   IF errnum <> 0 THEN
      BEGIN
      WRITELN('InitFlrHeap failed on Make_DataSeg. err = ',errNum);
      Halt;
      END
   END;

InitHeap(Pointer(dsAddr),Pointer(dsAddr+dsSize),@GrowHeap);

{$ELSEC }

SetHeap(IMHeap);

{$ENDC }

IF trcFiler THEN WRITELN('Filer heap is at:', ORD(theHeap));
END;



{$S FInit }
PROCEDURE Initialize;
CONST fAlertName = 'FlrAlert';
VAR dummy: INTEGER;
    volName: Pathname;
    devName: E_Name;
    result: INTEGER;
    err: INTEGER;
    excepName: T_Ex_Name;
    line: String[5];
    devHdl: TentryHdl;
    dummyEvent: EventRecord;
    scrapPeek: WindowPeek;
    pt: Point;
    copyRight,registrata,theApple: STRING[1];
    imTemp:integer;
    alertFile: PathName;

BEGIN
{ debugStartup := FALSE; - set in initFlags -gb }

   { Set up the terminate exception handler }

firstVol   := NIL;  { allows terminate handler to run if error in intialization}

{$IFC R}  { this is done in the IM }

excepName := 'SYS_TERMINATE';
Declare_Excep_Hdl (err, excepName, @LastWishes);
IF err <> 0 THEN
   BEGIN
   WRITELN (' Declar_Excep_Hdl error: ',err);
   HALT;
   END;

SetFldTest(debugStartup);
{$ENDC }

TraceDB(debugStartup);

catVolName := imVolName;  { Save catalog vol name in filer global }

{$IFC filerDebug }
   trcFEntry   := debugStartup;
   trcCatalog  := debugStartup;
   trcFDocCtrl := debugStartup;
   trcFVolCtrl := debugStartup;
   trcFiler    := debugStartup;
   wantCheckHeap := debugStartup;
{$ENDC }

quitFiler  := FALSE;
copyMode   := FALSE;
wantSound  := FALSE;
wantAutoSize := FALSE;
smallWave  := 100;
bigWave    := 7000;
specialUp  := FALSE;
diskSet    := [diskKind,disk1Kind,disk2Kind,profileKind];
putBackSet := [docKind,folderKind,docPad,folderPad,toolKind,calcKind,clockKind];
dupSet     := putBackSet;
padSet     := [docPad,folderPad];
docToolSet := [docKind,toolKind,calcKind,clockKind,computerKind,printKind];
allKindsSet:= [nilKind..lastKind];
allStates  := [hidden,normal,hilited,limbo];

{$IFC R}
InitGraf;

IF trcFiler THEN WRITELN('   calling InitWm ...');
InitWM;                { once-only call by filer at boot }
eventDebug := debugStartup;   { set after InitWm call, since InitWM clears it }
{$ENDC }

{*** WM should do this ***}
scrapPeek := Pointer(ORD(scrapFolder));
scrapPeek^.closeIcon := scrapSymbol;

IF trcFiler THEN WRITELN('   calling InitFlrHeap ...');
InitFlrHeap;           { open/create filer heap }
SetPort(filerFolder);

{ clear update region, so that WM doesn't send update at startup }
ValidWindow(filerFolder,TRUE);

{$IFC R}
InitJournal;           { set up the event recording/playback mechanism }
{$ENDC}

InitAlerts (40, 5500, theHeap, NIL, @FailedAlert);   {*** FL ***}
IF trcFiler THEN WRITELN('Back from init alerts: error = ', alertError);
IF alertError > 0 THEN
   BEGIN
   WRITELN('InitAlerts error = ',alertError);
   HALT;
   END;
alertFile := CONCAT('-', imVolName, '-', imToolName, fAlertName);
OpenPhraseFile (alertRefnum, alertFile);
IF trcFiler THEN WRITELN('Back from OpenPhraseFile: error = ', alertError);
IF alertError > 0 THEN
   BEGIN
   WRITELN('OpenPhraseFile for filer "', alertFile, '" error = ',alertError);
   HALT;
   END;
flrAlert{s} := ReadAlerts (alertRefnum,-1);
IF trcFiler THEN WRITELN('Back from ReadAlerts: error = ', alertError);
IF alertError > 0 THEN
   BEGIN
   WRITELN('ReadAlerts for filer "', alertFile, '" error = ',alertError);
   HALT;
   END;


{ tell user to wait for startup }
copyright     := ' ';
registrata    := ' ';
theApple      := ' ';
copyright[1]  := CHR(ccCopy);
registrata[1] := CHR(ccReg);
theApple[1]   := CHR(202);
ParamAlert(copyright,registrata,theApple);
{$IFC R}
WaitAlert(flrAlert,210);
{$ENDC}


{ removed for Lisa2 2/84  ...PrGlobalInit;     { Initialize the printing package }
InitFldStuff;     { Initialize field editor & related structures }
PMInit(err);      { Initialize parameter memory manager }
IF err > 0 THEN WRITELN('PMInit error = ',err:1);

{$IFC R}
IF trcFiler THEN WRITELN('   calling InitScrap ...');
InitScrap(err);
IF err > 0 THEN WRITELN('InitScrap error = ',err:1);

InitMenus;        { Initialize the menu package }
{$ENDC }

InitWmlCrs(err);  { Init cursor routines }
IF err > 0 THEN WRITELN('InitWmlCrs err = ',err:3);

InitWmlSb;   { Init scrollbar routines }
InitSbList(sbList,theHeap);   { create the scrollbar list descriptor }
hSbV := SbCreate(sbList,hsbNil,tyvhV,pt,0);   { allocate scroll bar structures }
hSbH := SbCreate(sbList,hsbNil,tyvhH,pt,0);
maxThumb := 1000;


InitMyMenus;   { Set up filer menus }
CheckItem(flrMenus[specialMenu],mTrcEvents,eventDebug);
CheckItem(flrMenus[specialMenu],mTrcFEntry,trcFEntry);
CheckItem(flrMenus[specialMenu],mTrcCatalog,trcCatalog);
CheckItem(flrMenus[specialMenu],mTrcFDocCtrl,trcFDocCtrl);
CheckItem(flrMenus[specialMenu],mTrcFVolCtrl,trcFVolCtrl);
CheckItem(flrMenus[specialMenu],mTrcFiler,trcFiler);

IF trcFiler THEN WRITELN('   calling ReadIcons ...');

(*** DS
ReadIcons;
***)

InitIcons; (*** DS ***)

InitMatchTable;
InitFentry;  { assumes heap is initialized }

{ get name of boot device }
volName := '';
{$IFC R}
Get_Dev_Name(result,volName,devName);
{$ELSEC}
volName := 'BOOT';
devName := '';
{$ENDC }
IF trcFiler THEN WRITELN('   calling InitCat ...');
InitCat(result,devName);
IF trcFiler THEN WRITELN('   returning from InitCat err = ',result:1);
CheckCatErr(result,'Error initializing database intrinsics.');
IF result <> 0 THEN HALT;

InitDocCtrl;

{$IFC R}
IF quitFiler THEN HALT;

(*** hangs ?
{ flush any typeahead - InitVolCtrl may put up alert box }
WHILE EventAvail DO GetEvent(dummyEvent);
***)

HideFolder(alertFolder);  { remove wait alert before showing time }

{ display time & allow setting }
InitSetTime;
SetTimeDialog;

InitVolCtrl;

IF quitFiler THEN HALT;

{$ELSEC }
InitSetTime;
BootMount;

{$ENDC}

InitObjects;

UpdateObject(deskObject,TRUE);   { repaint under dialog box now }

{$IFC R}
{ attempt to mount other volumes }
devHdl := firstDev;
WHILE devHdl <> NIL DO
  BEGIN
  IF devHdl^^.volHdl <> bootVol THEN MountAvolume(devHdl^^.device);
  devHdl := devHdl^^.nextHdl;
  END;
{$ENDC}

UpdateObject(deskObject,TRUE);   { repaint under alert box now }

{ done on activate -gb. InstallMenus;  { created active }

SetStdCursor(icrsInactive);

TopActive;
END;


(*** DS ***)
{$S FInit }
PROCEDURE InitIcons;


   PROCEDURE CalcBBoxes;

   { calculate the bounding box of each icon by looking at its mask }

   LABEL 1,2,3,4;

   VAR h,v:        INTEGER;
       bbox:       Rect;
       kind:       ObjectKind;
       tempBits:   BitMap;
       savePort:   GrafPtr;
       tempPort:   GrafPort;
       tempBuf:    ARRAY[0..95] OF INTEGER;

   BEGIN
     GetPort(savePort);
     OpenPort(@tempPort);

     tempBits.baseAddr := @tempBuf;
     tempBits.rowBytes := 6;
     SetRect(tempBits.bounds,0,0,48,32);
     SetPortBits(tempBits);

IF thePort = menuFolder THEN BEGIN
  WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
     TextFont(fIconFont);

     FOR kind := nilKind TO lastKind DO
       BEGIN
         EraseRect(tempBits.bounds);
         MoveTo(0,0);
         DrawChar(iconMask[kind]);

         bbox.left:=0;
         bbox.right:=48;
         bbox.top:=0;
         bbox.bottom:=32;

         FOR h:= 0 TO 47 DO  { scan for left }
           BEGIN
             FOR v := 0 TO 31 DO IF BitTst(@tempBuf, v*48 + h) THEN
               BEGIN
                 bbox.left := h;
                 GOTO 1;
               END;
           END;
       1:

         FOR v:= 0 TO 31 DO  { scan for top }
           BEGIN
             FOR h := 0 TO 47 DO IF BitTst(@tempBuf, v*48 + h) THEN
               BEGIN
                 bbox.top := v;
                 GOTO 2;
               END;
           END;
       2:

         FOR h:= 47 DOWNTO 0 DO  { scan for right }
           BEGIN
             FOR v := 0 TO 31 DO IF BitTst(@tempBuf, v*48 + h) THEN
               BEGIN
                 bbox.right := h + 1;
                 GOTO 3;
               END;
           END;
       3:

         FOR v:= 31 DOWNTO 0 DO  { scan for bottom }
           BEGIN
             FOR h := 0 TO 47 DO IF BitTst(@tempBuf, v*48 + h) THEN
               BEGIN
                 bbox.bottom := v + 1;
                 GOTO 4;
               END;
           END;
       4:

       iconBoxes[kind] := bbox;

       IF trcFiler THEN WITH bbox DO
          WRITELN('bbox[',ORD(kind),'] = ',left,top,right,bottom);

     END;  { for kind }

     SetPort(savePort);
   END;



BEGIN
  iconData[nilKind]     := CHR(65);     iconMask[nilKind]       := CHR(65);
  iconData[fileKind]    := CHR(0);      iconMask[fileKind]      := CHR(1);
  iconData[drawerKind]  := CHR(2);      iconMask[drawerKind]    := CHR(3);
  iconData[folderkind]  := CHR(4);      iconMask[folderkind]    := CHR(5);
  iconData[docKind]     := CHR(6);      iconMask[docKind]       := CHR(7);
  iconData[docPad]      := CHR(8);      iconMask[docPad]        := CHR(9);
  iconData[trashKind]   := CHR(10);     iconMask[trashKind]     := CHR(11);
  iconData[printKind]   := CHR(12);     iconMask[printKind]     := CHR(13);
  iconData[calcKind]    := CHR(14);     iconMask[calcKind]      := CHR(15);
  iconData[trayKind]    := CHR(16);     iconMask[trayKind]      := CHR(17);
  iconData[computerKind]:= CHR(16);     iconMask[computerKind]  := CHR(19);
  iconData[wpDocKind]   := CHR(20);     iconMask[wpDocKind]     := CHR(7);
  iconData[bgDocKind]   := CHR(22);     iconMask[bgDocKind]     := CHR(7);
  iconData[lcDocKind]   := CHR(24);     iconMask[lcDocKind]     := CHR(7);
  iconData[geDocKind]   := CHR(26);     iconMask[geDocKind]     := CHR(7);
  iconData[lmDocKind]   := CHR(28);     iconMask[lmDocKind]     := CHR(7);
  iconData[folderPad]   := CHR(30);     iconMask[folderPad]     := CHR(31);
  iconData[scrapKind]   := CHR(52);     iconMask[scrapKind]     := CHR(53);
  iconData[clockKind]   := CHR(34);     iconMask[clockKind]     := CHR(35);
  iconData[toolKind]    := CHR(36);     iconMask[toolKind]      := CHR(37);
  iconData[diskKind]    := CHR(38);     iconMask[diskKind]      := CHR(41);
  iconData[disk1Kind]   := CHR(38);     iconMask[disk1Kind]     := CHR(41);
  iconData[disk2Kind]   := CHR(38);     iconMask[disk2Kind]     := CHR(41);
  iconData[profileKind] := CHR(44);     iconMask[profileKind]   := CHR(45);
  iconData[pertDocKind] := CHR(46);     iconMask[pertDocKind]   := CHR(7);
  iconData[termDocKind] := CHR(48);     iconMask[termDocKind]   := CHR(7);

  (*** DS  choose char codes for IM icon ***)
  iconData[imKind]      := CHR(50);     iconMask[imKind]        := CHR(7);

  iconData[deskKind]    := CHR(65);     iconMask[deskKind]      := CHR(65);

  CalcBBoxes;
END;



{$IFC R}
{$S FInit }
PROCEDURE InitJournal;
{ Sets journal action according to text file }
VAR f: TEXT;
    playName,recordName: PathName;
    playMode,recordMode: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('InitJournal');
RESET(f,jrnlDirectives);
IF IOResult = 0 THEN
   BEGIN
   READLN(f,playName);
   IF playName <> '' THEN READLN(f,playMode);
   READLN(f,recordName);
   IF recordName <> '' THEN READLN(f,recordMode);
   END
ELSE
   BEGIN
   WRITE('Enter PLAYBACK journal name (return for none). ');
   READLN(playName);
   IF playName <> '' THEN
      BEGIN
      WRITELN('Enter journal mode (0-3).');
      WRITE('0 = slow/exact, 1 = fast/exact,  2 = slow/inexact, 3 = fast/inexact. ');
      READLN(playMode);
      END;
   WRITE('Enter RECORD journal name (return for none). ');
   READLN(recordName);
   IF recordName <> '' THEN
      BEGIN
      WRITELN('Enter journal mode (0-3).');
      WRITE('0 = slow/exact, 1 = fast/exact,  2 = slow/inexact, 3 = fast/inexact. ');
      READLN(recordMode);
      END;
   END;

IF playName <> '' THEN StartPlayback(playName,playMode);
IF recordName <> '' THEN StartRecord(recordName,recordMode);
END;
{$ENDC}



{$S FInit }
PROCEDURE InitMatchTable;
{ which kinds of source are legal for each kind of destination }
BEGIN
IF trcFiler THEN WRITELN('InitMatchTable');
matchTable[nilKind]     := [];
matchTable[folderkind]  := putBackSet;
matchTable[trashKind]   := putBackSet;
matchTable[printKind]   := [];
matchTable[calcKind]    := [];
matchTable[trayKind]    := putBackSet;
matchTable[computerKind]:= [];
matchTable[diskKind]    := putBackSet + diskSet;
matchTable[disk1Kind]   := putBackSet + diskSet;
matchTable[disk2Kind]   := putBackSet + diskSet;
matchTable[profileKind] := putBackSet + diskSet;
matchTable[docPad]      := [];
matchTable[docKind]     := [];
matchTable[wpDocKind]   := [];
matchTable[bgDocKind]   := [];
matchTable[lcDocKind]   := [];
matchTable[geDocKind]   := [];
matchTable[lmDocKind]   := [];
matchTable[deskKind]    := [fileKind..lastKind];
matchTable[folderPad]   := [];
matchTable[scrapKind]   := [];
matchTable[toolKind]    := [];
matchTable[clockKind]   := [];

{ Second release icons }
matchTable[fileKind]    := [drawerKind,folderKind,docKind,calcKind];
matchTable[drawerKind]  := [folderKind,docKind,docPad,calcKind];
matchTable[imKind]      := [];
END;


{$S FInit }
PROCEDURE InitMyMenus;
VAR i : INTEGER;
    menuFile: Text;
    ior: TC;
BEGIN
IF trcFiler THEN WRITELN('InitMyMenus');
RESET(menuFile,FilerMenus);
  ior := IORESULT;
  IF IMtst THEN
    WRITELN('Reset FlrMenus file: ', FilerMenus, ' err:', ior);
  IF ior <> 0
    THEN BEGIN
      { IF sDebug THEN }
        WRITELN('InitMyMenus:  cant find menu file - ',
                      filerMenus, ' err:', ior);
      { FailedInit; }
     END;
FOR i:=firstFlrMenu to lastFlrMenu DO
  BEGIN  { added for im tracing }
    ReadMenu(menuFile,flrMenus[i]);
   END;
CLOSE(menuFile);
pXtraMenu := @flrMenus[xtraMenu];  { LisaGuide nr fix #4 - for translation }
                            { 3/2/83 -gb   puts sys obj names in menu file }
END;



{$S FInit }
PROCEDURE InitObjects;
{ initializes object tree.  Creates the initial objects }
VAR diskObj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('InitObjects');

{ create the "nil" object.  Lists are terminated by pointing to this object }
nilObject := Pointer(ORD(NewHandle(SizeOf(FObject))));
WITH nilObject^^ DO
   BEGIN
   name       := 'NilObject';
   prev       := nilObject;
   next       := nilObject;
   loc.h      := 0;
   loc.v      := 0;
   kind       := nilKind;
   subKind    := nilKind;
   catRID.fatherID := idNIL;{ added to stop searches where desk is really parent }
   catRID.uniqueID := idNIL;{ these may occur in im version -gb }
   volHdl     := NIL;
   state      := nilState;
   isFiled    := FALSE;
   isOpen     := FALSE;
   dirty      := FALSE;
   wasOpened  := FALSE;
   toBeCopied := FALSE;
   container  := nilObject;
   contents   := nilObject;
   objWindow  := NIL;
   hThumbPos  := 0;
   vThumbPos  := 0;
   created    := 0;
   modified   := 0;
   size       := 0;
   viewMode   := spatialView;
   SetRect(nameRect,0,0,0,0);
   imFldr     := NIL;
   objSerial  := nextObjSer;
   END;

{ Create the "Desk" object.  This is the root of the object tree, father of all }
deskObject := Pointer(ORD(NewHandle(SizeOf(FObject))));
deskObject^^ := nilObject^^;
WITH deskObject^^ DO
   BEGIN
   name       := 'DeskObject';
   kind       := deskKind;
   isOpen     := TRUE;
   objWindow  := filerFolder;
   objSerial  := nextObjSer;
   END;

editObject     := nilObject;    { nothing being edited }
floppy1Object  := nilObject;
floppy2Object  := nilObject;
hardDiskObject := nilObject;

{ restore the desktop of the boot volume }
RestoreDesktop(bootVol,diskObj);

activeObject:=deskObject;   { filer is initially active }
END;



{$S Filer }
PROCEDURE InstallMenus;
VAR i: INTEGER;
    menuLim: INTEGER;
BEGIN
IF fTstTF THEN WRITELN('InstallMenus');
IF IsContainer(activeObject)
  THEN menuLim := specialMenu
  ELSE menuLim := filingMenu;
FOR i:=firstFlrMenu to menuLim DO
  BEGIN
    IFInsertMenu(i, 0); { used to be InsertMenu(flrMenus[i],0); -gb }
    IF fTstTF THEN      { added for IM testing -gb }
      WRITELN('Installing filer menu:', i:3, ' info at: ', ORD(@flrMenus[i]));
  END;
IF TopicsMInfo^^.mDispFlag
  THEN BEGIN
    IF fTstTF THEN WRITELN('Inserting Topics menu in filer folder');
    InsertMenu(TopicsMInfo^^.mBarInfo^, 0);
   END;
IF specialUp
   THEN BEGIN
    InsertMenu(flrMenus[specialMenu],0);
      { added to make all functions available when soime items are blanked }
    IF fTstTF THEN  { added for IM testing -gb }
      WRITELN('Installing filer menu:', specialMenu:3,
              ' info at: ', ORD(@flrMenus[specialMenu]));
   END;

DrawMenuBar;
END;



PROCEDURE InvertContents{* obj: ObjectHandle; whichState; ObjectState *};
{ Invert contents of obj matching "whichState" }
VAR son,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('InvertContents "',obj^^.name,'"');
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state = whichState THEN InvertObject(son);
   son := son^^.next;
   END;
END;



(*** DS
PROCEDURE InvertIcon{* kind: ObjectKind; topLeft: Point *};
VAR srcRect,dstRect: Rect;
    srcBits: BitMap;
    maskAddr: WordPtr;
BEGIN
IF trcFiler THEN WRITELN('InvertIcon');
srcBits := iconHeader.iconInfo[kind];
srcRect := srcBits.bounds;
dstRect:=srcRect;
OffsetRect(dstRect,topLeft.h,topLeft.v);
maskAddr := Pointer(ORD(@iconData) + HiWord(ORD(srcBits.baseAddr)));
srcBits.baseAddr := maskAddr;
XferRect(srcBits,thePort^.portBits,srcRect,dstRect,srcXor,white);
END;
***)


(*** DS ***)
PROCEDURE InvertIcon{* kind: ObjectKind; topLeft: Point *};
BEGIN
IF trcFiler THEN WRITELN('InvertIcon');
TextFont(fIconFont);
TextMode(srcXor);
MoveTo(topLeft.h,topLeft.v);
DrawChar(iconMasks[kind]);
END;



{$S  }
PROCEDURE InvertObject{* obj: ObjectHandle *};
VAR pt: Point;
    savePort : GrafPtr;
    tempRect: Rect;
BEGIN
IF trcFiler THEN WRITELN('InvertObject "',obj^^.name,'"');
GetPort(savePort);
WITH obj^^ DO
   BEGIN
   pt:=loc;
   SetPort(container^^.objWindow);

   IF container^^.viewMode = spatialView THEN
      InvertIcon(kind,pt)
   ELSE
      DrawTinyObject(obj,TRUE);
   END;
SetPort(savePort);
END;



{$S  }
FUNCTION IsContainer{* obj: ObjectHandle): BOOLEAN *};
BEGIN
IF trcFiler THEN WRITELN('IsContainer "',obj^^.name,'"');
IsContainer:=(matchTable[obj^^.kind] <> []);
END;



{$S Filer }
FUNCTION IsIn(whichVol: TentryHdl; obj,theContainer: ObjectHandle): BOOLEAN;
{ returns TRUE if "obj" is a descendant of "aContainer" }
VAR recID,fatherRecID: TcatRID;
    fatherObj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('IsIn "',obj^^.name,'" "',theContainer^^.name,'"');
recID := obj^^.catRID;

WHILE (recID.fatherID <> idNil)  DO
   BEGIN
   IF recID.fatherID = theContainer^^.catRID.uniqueID THEN
      BEGIN
      IsIn := TRUE;
      EXIT(IsIn);
      END;
   ClimbTree(whichVol,recID,fatherRecID,fatherObj);
   recID := fatherRecID;
   END;
IsIn := FALSE;
END;



PROCEDURE KillContents{* obj: ObjectHandle; sonsAlso,erase: BOOLEAN *};
{ Kills all descendants of obj.  Frees storage }
VAR son,nextSon,listHead: ObjectHandle;
BEGIN
IF obj^^.state = placeHolder THEN EXIT(KillContents);
listHead:=obj^^.contents;
IF listhead = nilObject THEN EXIT(KillContents);
IF trcFiler THEN WRITELN('KillContents "',obj^^.name,'"');

son:=listHead^^.next;
WHILE son <> listHead DO   { kill all brothers }
   BEGIN
   IF sonsAlso THEN KillContents(son,TRUE,erase);     { kill any sons first}
   nextSon:=son^^.next;
   KillObject(son,sonsAlso,erase);
   son:=nextSon;
   END;

{ dispose head/tail node }
IF listHead^^.name <> 'head/tail node' THEN
   WRITELN('Bad Dispose "head/tail node" = "',listHead^^.name,'"');

IF wantCheckHeap THEN CheckHeap('KillContents - before dispose');
DisposeHandle(POINTER(ORD(listHead)));
IF wantCheckHeap THEN CheckHeap('KillContents - after dispose');

obj^^.contents:=nilObject;
END;



{$S Filer }
PROCEDURE KillDuplicates{* container: ObjectHandle *};
{ aborts duplicate mode by removing, blinking duplicates }
VAR son,nextSon,listHead: ObjectHandle;
    killedSome: BOOLEAN;
BEGIN
IF NOT copyMode THEN EXIT(KillDuplicates);
IF trcFiler THEN WRITELN('KillDuplicates "',container^^.name,'"');

killedSome := FALSE;
listHead := container^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   nextSon := son^^.next;
   IF son^^.toBeCopied THEN
      BEGIN
      KillObject(son,TRUE,TRUE);
      killedSome := TRUE;
      END;
   son := nextSon;
   END;
IF (container^^.viewMode <> spatialView) AND killedSome THEN
   DrawContents(container);
UpdateObject(deskObject,TRUE);
copyMode := FALSE;
END;



{$S Filer }
PROCEDURE KillObject{* obj: ObjectHandle; sonsAlso,erase: BOOLEAN *};
{ Frees storage.  Records info in catalog if appropriate }
VAR err : INTEGER;
    catRec : TcatRec;
BEGIN
IF obj = nilObject THEN EXIT(KillObject);
IF trcFiler THEN WRITELN('KillObject "',obj^^.name,'"');

IF sonsAlso THEN KillContents(obj,TRUE,erase);

IF obj = editObject THEN EndEdit;   { terminate editing }

{ update catalog if necessary }
FlushObject(obj);

IF CloseObject(obj,FALSE,TRUE,FALSE) THEN;

{ remove from list }
WITH obj^^ DO
   BEGIN
   prev^^.next:=next;
   next^^.prev:=prev;

   { If disk then invalidate global object handle }
   CASE kind OF
      disk1Kind:   floppy1Object  := nilObject;   { *** case on device type ***}
      disk2Kind:   floppy2Object  := nilObject;
      profileKind: hardDiskObject := nilObject;
      END;
   END;

IF obj = activeObject THEN activeObject := nilObject;
IF obj^^.container^^.isOpen THEN { test aded for kept invisible objects -gb }
  IF erase THEN ValidObject(obj,FALSE);

IF wantCheckHeap THEN CheckHeap('KillObject - before dispose');
{im stuff added  -gb }
KillIMFldr(obj);
IF fTstTF THEN {added trace -gb }
  WRITELN('KillObject - Disposing folder of object "', obj^^.name, '" (',
           ORD(obj^^.objWindow), ')');
   IF obj^^.objWindow <> NIL
     THEN DisposeFolder(obj^^.objWindow)   { invalidates obj handle }
     ELSE IF fTstTF THEN
       IF obj^^.state <> placeHolder
         THEN WRITELN('KillObj - no folder to dispose of - ignored "',
                       obj^^.name, '"');
DisposeHandle(POINTER(ORD(obj)));
IF wantCheckHeap THEN CheckHeap('KillObject - after dispose');
END;



{$S Filer }
PROCEDURE KillScroll{* window : WindowPtr; needUpdate: BOOLEAN *};
{ open up clipping, erase and invalidate both scroll bars. }
VAR rH,rV,growRect: Rect;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('KillScroll');
IF (window = filerFolder) THEN EXIT(KillScroll);

GetPort(savePort);
SetPort(window);
ClipRect(window^.portRect);
FlushRects(rH,rV);
GetGrowRect(growRect);
UnionRect(growRect,rV,rV);
EraseRect(rV);
EraseRect(rH);
IF needUpdate THEN ValidScrollBars(window,FALSE);

SetPort(savePort);
END;


{$IFC R }
{$S FInit }
PROCEDURE LastWishes{* environPtr : P_env_blk; excepDataPtr : P_term_ex_data *};

   { The Sys_Terminate exception handler.  Gets called when the program terminates
     normally (i.e., last statement executed) or abnormally (e.g., bus error).

     In the event of an abnormal termination the filer attempts to save its most
     critical data structure - the object catalog.

     When the filer terminates (by exiting this procedure) the O/S will signal
     the terminate exception to all the sons (applications) of the filer.  Each
     son will then enter it's terminate exception handler and try to save its
     state.

     NOTE: If an error occurs within the exception handler, the process is
           terminated by the O/S without reentering the handler.

   }

VAR
   err: INTEGER;
   volHdl,
   nextHdl: TentryHdl;
   saveFile: Pathname;
   crashed: BOOLEAN;

BEGIN
IF trcFiler THEN WRITELN('LastWishes');
HideCursor;

crashed := (excepDataPtr^.excep_kind <> ended);

   { attempt to close the object catalog on all volumes }

volHdl := firstVol;
WHILE volHdl <> NIL DO
   BEGIN
   nextHdl := volHdl^^.nextHdl; { save nextHdl since CloseCat deallocates volHdl }
   CloseCat(err,volHdl);
   volHdl := nextHdl;
   END;

WRITELN;
IF crashed THEN
   WRITELN('Successful cleanup after crash.')
ELSE
   WRITELN('That''s all folks ...');

{ blank the screen }
SetPort(deskPort);
ClipRect(deskPort^.portRect);
FillRect(deskPort^.portRect,black);
END;
{$ENDC }


{$I apim/Tfiler2.text }

END.
