{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}

{$s imex }
{$R-}

PROGRAM IM;


USES {$U HwInt        }  HwInt,
     {$U libos/SysCall      }  SysCall,
     {$U libos/PSysCall     }  PSysCall,
     {$U UnitStd.obj  }  UnitStd,
     {$U UnitHz.obj   }  UnitHz,
     {$U Storage.obj  }  Storage,
     {$U QuickDraw    }  QuickDraw,
     {$U FontMgr.obj  }  FontMgr,
     {$U PmDecl       }  PmDecl,
     {$U PMM          }  PMM,
     {$U FMgrUtil.obj }  FmgrUtil,
     {$U WM.Events    }  Events,
     {$U WM.Windows   }  Windows,
     {$U WM.Folders   }  Folders,
     {$U WM.Menus     }  Menus,
     {$U WMLStd       }  WMLStd,
     {$U WMLCrs       }  WMLCrs,
     {$U WMLSB        }  WMLSb,
     {$U WMLGrow      }  WMLGrow,
     {$U AlertMgr.obj }  AlertMgr,
     {$U dbenv.obj    }  dbenv,
     {$U DBdecl1      }  DBdecl1,
     {$U fedec.obj    }  fedec,
     {$U fld.obj      }  FieldEdit,
     {$U apim/tfilercomm }tfilercomm,
     {$U Scrap.obj    }  Scrap,
     {$U apim/UnitImf.obj  }  UnitImf,
     {$U apim/imcore.obj   }  IMCore,
     {$U apim/IMMenus.obj  }  IMMenus,
     {$U apim/IMStream.obj }  IMStream,
     {$U apim/IMSEdit.obj  }  IMSEdit,
     {$U apim/IMFolders.obj}  IMFolders,
     {$U apim/TFGlobals    }  IFGlobals,  { Common routines & declarations }
     {$U apim/TFEntry      }  IFEntry,
     {$U apim/TCatalog     }  IFCatalog,
     {$U apim/TFiler       }  TFiler,     { TeachingFiler unit }
     {$U apim/IMScript.obj }  IMScript,
     {$U apim/IMPatMat.obj }  IMPatMat,
     {$U apim/IMInterp.obj }  IMInterp,
     {$U apim/IMSim.obj    }  IMSim;


LABEL 999;

CONST

{$IFC NOT IMDebug}
  fIMEvtTst    = FALSE;
  demoFlag     = FALSE;
  debugMenu    = FALSE;
  fAskDemo     = FALSE;
  fAskFlags    = FALSE;
  fPlayXFile   = FALSE;
{$ENDC }

  IMVersion = 'A5, February 10, 1983';
  copyright = 'copyright 1983, Apple Computer Inc.';

  alertversion = 1;

  imgraf     = 49;

  selectShell = 2;
  newShell = 3;
  powerOff = 4;
  reboot = 5;

  CMinHMouseMove = 15;
  CMinVMouseMove = 10;

  CMoveStopSlopTime = 15;  {1/4 second stop allowed for "continuous" mouse moves}

  CSeqTime = 50;  { 1/2 sec allowed between clicks in selections }

  dbHeight = 80;

  crsHideH = 15;
  crsHideV = 10;


  ToolID        = '{T7}';
  CLessonDirFile = 'LDir.text';
  CTutorMFile    = 'TutorMenus.text';
  CTopicMFile    = 'TopicsMenu.text';
  CFilerMFile    = 'FlrMenus.text';
  CAlertFile     = 'IMAlert';
  CSetupFile     = 'Setup.text';
  FilerShell     = 'Shell.Office System                     ';

  { Tutor menu items }
    iContLesson = 1;
    iNextHint = 2;
    iPrevHint = 3;

  { Edit menu items }
    iCut = 3;
    iPaste = 5;
    iCopy = 4;
    iUndo = 1;

  { IM Control menu items }
    iCSStep = 1;
    iCSWait = 2;
    iCS1Step = 3;
    iCWindCmd = 4;
    iCrdrw = 5;
    iCShowScr = 6;
    iCKillScr = 7;
    iCPrSkip = 8;
    iCClSkip = 9;
    iCMkMap = 10;
    iCCmprsScr = 11;
    iCDpSyntx = 12;

  { IM File Control menu items }
    iFShow = 1;
    iFShowL = 2;
    iFSetP = 3;
    iFSetFP = 4;
    iFReSet = 5;
    iFNxtL = 6;
    iFNxtC = 7;
    iFPrvExz = 8;       { also in BeginCommand in IMInterp }
    iFLstExz = 9;      { also in BeginCommand in IMInterp }
    iFShwBufP = 10;
    iFPrtPBuf = 11;

  { IM Flags menu items }
    iFlNoTrace =      1;  { trace off                 }
    iFlTrace =        2;  { im trace                  }
    iFlSCmdErrs =     3;  { script debug              }
    iFlIMScPrt =      4;  { print script              }
    iFlErTrace =      5;  { trace event recording     }
    iFlTFTrace =      6;  { trace teaching filer      }
    iFlIMPatTrace =   7;  { trace pattern match       }
    iFlIMSTrace =     8;  { trace im display stream   }
    iFlIMFTrace =     9;  { trace im script file unit }
    iFlIMMTrace =    10;  { trace im menu             }
    iFlIMFldrTrace = 11;  { trace im folder           }
    iFlIMScrTrace =  12;  { trace im script           }
    iFlIMTabTrace =  13;  { trace im search tables    }
    iFlIMFETrace =   14;  { trace im field edit       }
    iFlSSTrace =     15;  { trace im script stream    }
    iFlIMEvtTst =    16;  { trace im events           }
    iFlcDebug =      17;  { code debugging tests      }
    iFlFieldTrace =  18;  { trace field editor        }
    iFlAllTraces =   19;  { ask all traces            }

  { Sim Edit Menu items }
    iSimEdit = 1;
    iSimTrace = 2;
    iSimPB = 3;
    iSimPBGo = 4;
    iSimGo = 5;
    iSimRecord = 6;
    iSimSave = 7;
    iSimRest = 8;
    iSimPBx = 9;
    iSimSetMode = 10;

    GoAwayButn = 1;


TYPE   { for the moveconsole external def }
  consoledest = (alscreen, mainscreen, xsorocA, xsorocB, folder, spare1,
                  spare2, spare3);      (* max 8 options *)

VAR
  LessonDirFile: PathName;
  TutorMFile:    PathName;
  TopicMFile:    PathName;
  FilerMFile:    PathName;
  AlertFile:     PathName;
  SetupFile:     PathName;

  tempRect:       Rect;
  theMenu:        INTEGER;
  theItem:        INTEGER;
  menuFile:       TEXT;

  toFolder:       WindowPtr;
  toProcess:      LongInt;

  clickTime:      LongInt;
  clickCount:     INTEGER;
  clickLoc:       Point;

  scrollEvent:    INTEGER;
  width,height:   INTEGER;
  maxWidth:       INTEGER;
  dialogHt:       INTEGER;

  fButtonUp:      TF;
  BtnDwnFldr:     THFldrInfo;

  crsHidden:      TF;
  crsHideRect:    Rect;

  timeoutTime:    LongInt;
  waitTimeout:    TL;
  fCheckTime:     TF;
  FndMove:        TF;

  activeContainer: TF;

  SelectMouseLoc: Point;
  WaitMouseLoc:   Point;

  fSingleStep:    TF;

  fWasWaiting:    TF;

  hintLeft:       TC;
  hintTop:        TC;
  hintWidth:      TC;
  hintHeight:     TC;

  nxShellCode:   TC;
  nxShellName:   TStr40;

  feStarted:     TF;
  qdStarted:     TF;


{$IFC IMDebug}
  fIMEvtTst:      TF;
  demoFlag:       TF;
  debugMenus:     TF;
  fAskDemo:       TF;
  fAskFlags:      TF;
  fPlayXFile:     TF;
{$ENDC }

  LisaPrefix:     TFileStr;

  startWave:           MicroSeconds;
  dltWave, ddltWave:   MicroSeconds;
  durWave, ddurWave:   MilliSeconds;
  mVol, dltVol:        TC;
  waveIter, wVol:      TC;

  msDWave, msUWave:    MicroSeconds;
  msDltWave:           MicroSeconds;
  msWaveIter:          TC;
  msVol:               TC;


PROCEDURE BlockIOinit;  {once only call to init pascal IO library}
             EXTERNAL;

PROCEDURE WaitEnded; FORWARD;
PROCEDURE DeActFldr(imFldr: THFldrInfo);  FORWARD;
PROCEDURE moveconsole(var errnum : integer; applconsole : consoledest);
           external;



{$S imec }
{$IFC IMDebug }
  PROCEDURE IMEDbgOn;
  BEGIN
  END;
{$ENDC }

{$S imeini }
PROCEDURE SetupSound;
BEGIN
  startWave := 800;
  dltWave := 40;
  ddltWave := 0;
  durWave := 0;
  ddurWave := 0;
  mVol := 4000;
  dltVol := 0;
  waveIter := 180;
  wVol := 4;

  msDWave := 800;
  msDltWave := 30;
  msWaveIter := 270;
  msUWave := msDWave + (msDltWave*msWaveIter);
  msVol := 4;
END;

{$S imeh }
PROCEDURE TstSound;
VAR curWave:   MicroSeconds;
    curMVol:   TC;
    curVol:    TC;
    curDur:    MilliSeconds;
    nxtNoise:  MilliSeconds;
    curDWave:  MicroSeconds;
    curDDur:   MilliSeconds;
    startTime: MilliSeconds;
    ddFlag:    TF;
    i:         TC;
    toCt:      TC;
    nxtVolChg: TC;
    vDlt,vCt:  TC;
BEGIN
  curWave := startWave;
  curMVol := mVol;
  curVol  := (curMVol+500) DIV 1000;
  SetVolume(curVol);
  curDur  := durWave;
  curDWave := dltWave;
  curDDur  := durWave;
  startTime := Timer;
  toCt := 0;
  FOR i := 1 TO waveIter DO
    BEGIN
      Noise(curWave);
      nxtNoise := curDur+Timer;
      curWave := curWave+curDWave;
      IF curWave > 8191 THEN curWave := 8191;
      IF curWave < 1 THEN curWave := 1;
      curDur  := curDur+curDDur;
      IF i >= nxtVolChg
        THEN BEGIN
         curVol := curVol+vDlt;
         IF curVol > 7 THEN curVol := 7;
         IF curVol < 0 THEN curVol := 0;
         nxtVolChg := i+vCt;
         SetVolume(curVol);
        END;
      REPEAT toCt := toCt+1; UNTIL Timer >= nxtNoise;
    END;
  Silence;
  IF IMtst THEN WRITELN('TstSound = timeoutCount =', toCt);
END;

{$S imeh }
PROCEDURE DoSound(curWave, curDWave: MicroSeconds; waveCt, curVol: TC);
VAR i:         TC;
    toCt:      TC;
BEGIN
  SetVolume(curVol);
  toCt := 0;
  FOR i := 1 TO waveCt DO
    BEGIN
      Noise(curWave);
      curWave := curWave+curDWave;
      IF curWave > 8191 THEN curWave := 8191;
      IF curWave < 1 THEN curWave := 1;
      toCt := toCt+1;
    END;
  Silence;
END;

{$IFC IMDebug }
{$S imeini }
PROCEDURE AskTraces(fInit: TF);
LABEL 100;
VAR tfldTest: TF;
BEGIN
  WRITELN('Enter Trace Flag Values...');
100:
  AskFlag(@cDebug,       'IM Code Debug trace ');
  AskFlag(@sDebug,       'IM Script Debug trace ');
  AskFlag(@IMtst,        'IM trace ');
  AskFlag(@fScriptPrint, 'IM Script Print ');
  AskFlag(@fSingleStep,  'Single Step Mode ');
  AskFlag(@IMERTst,      'IM EvtRec trace ');
  AskFlag(@fTstTF,       'IM Teaching Filer trace ');
  AskFlag(@fTstPat,      'IM Pat Match trace ');
  AskFlag(@IMStst,       'IM Stream trace ');
  AskFlag(@IMFtst,       'IM Script File trace ');
  AskFlag(@IMMtst,       'IM Menu trace ');
  AskFlag(@fTstFldrs,    'IM Folder trace ');
  AskFlag(@IMScrTst,     'IM Script trace ');
  AskFlag(@fTstTab,      'IM Search table trace ');
  AskFlag(@IMFldTst,     'IM Field Edit trace ');
  AskFlag(@fScriptTrace, 'IM Script Stream trace ');
  AskFlag(@fIMEvtTst,    'IM Event trace ');
  AskFlag(@debugStartup, 'Full filer trace');
  AskFlag(@fTstSim,      'Sim Unit trace ');
  IF NOT fInit THEN
    IF fScriptPrint
         THEN ShowScript;
  TFCount := 0;

{$IFC fDbgOK }
  AskFlag(@fTstHz, 'Heap zone trace ');
  AskFlag(@fTstStd, 'Std unit trace ');
  AskFlag(@tfldTest, 'Field Edit trace ');
  SetFldTest(tfldTest);
{$ENDC }

  WRITE('Ask them again?');
  IF GetYorN THEN GOTO 100;
END;
{$ENDC }


{$S imec }
PROCEDURE ChkCtrlMenu;
BEGIN
{$IFC IMDebug }
  IF CtrlMInfo <> NIL THEN BEGIN
    IMCheckItem(CtrlMInfo, iCSWait, fWait);
    IMCheckItem(CtrlMInfo, iCS1Step, fSingleStep);
    SetAbleItem(CtrlMInfo, iCSStep, NOT fWait);
    SetAbleItem(CtrlMInfo, iCWindCmd, fScriptPrint);
    SetAbleItem(CtrlMInfo, iCKillScr, (hndScriptFldr <> NIL));
   END;
{$ENDC }
END;


{$IFC IMDebug }
{$S imec }
PROCEDURE ChkFlagMenu;
BEGIN
  IF FlagsMInfo <> NIL THEN BEGIN
    IMCheckItem(FlagsMInfo, iFlTrace,       IMtst);
    IMCheckItem(FlagsMInfo, iFlSCmdErrs,    sDebug);
    IMCheckItem(FlagsMInfo, iFlIMScPrt,     fScriptPrint);
    IMCheckItem(FlagsMInfo, iFlErTrace,     IMERTst);
    IMCheckItem(FlagsMInfo, iFlTFTrace,     fTstTF);
    IMCheckItem(FlagsMInfo, iFlIMPatTrace,  fTstPat);
    IMCheckItem(FlagsMInfo, iFlIMSTrace,    IMStst);
    IMCheckItem(FlagsMInfo, iFlIMFTrace,    IMFtst);
    IMCheckItem(FlagsMInfo, iFlIMMTrace,    IMMtst);
    IMCheckItem(FlagsMInfo, iFlIMFldrTrace, fTstFldrs);
    IMCheckItem(FlagsMInfo, iFlIMScrTrace,  IMScrTst);
    IMCheckItem(FlagsMInfo, iFlIMTabTrace,  fTstTab);
    IMCheckItem(FlagsMInfo, iFlIMFETrace,   IMFldTst);
    IMCheckItem(FlagsMInfo, iFlSSTrace,     fScriptTrace);
    IMCheckItem(FlagsMInfo, iFlIMEvtTst,    fIMEvtTst);
    IMCheckItem(FlagsMInfo, iFlcDebug,      cDebug);
    IMCheckItem(FlagsMInfo, iFlFieldTrace,  fldTest);
   END;
END;
{$ENDC }


{$S imeini }
PROCEDURE InitTraces;
BEGIN
{$IFC IMDebug }
  IMtst := FALSE;
  sDebug := NOT demoFlag;
  debugStartup := FALSE;
  fScriptPrint := FALSE;
  IMERTst :=  FALSE;
  fTstTF := FALSE;
  fTstPat := FALSE;
  IMStst := FALSE;
  IMFtst := FALSE;
  IMMtst := FALSE;
  fTstFldrs := FALSE;
  IMScrTst := FALSE;
  fTstTab := FALSE;
  IMFldTst := FALSE;
  fScriptTrace := FALSE;
  fIMEvtTst := FALSE;
  cDebug := FALSE;
  fTstSim := FALSE;
  TFCount := 0;
{$ENDC }

{$IFC fDbgOK }
  fTstHz := FALSE;
  fTstStd := FALSE;
  eventDebug := FALSE;
  SetFldTest(FALSE);
{$ENDC }

END;


{$IFC IMDebug}
{$S imeini }
PROCEDURE AskDemoTraces;
VAR mpt: Point;
BEGIN
  IF fAskDemo
    THEN BEGIN
      WRITELN('Is this a demo?');
      AskFlag(@demoFlag, 'demoFlag ');
     END;
  IF fAskFlags
    THEN BEGIN
      WRITELN('Ask trace flags? ');
      IF GetYorN THEN AskTraces(TRUE) ELSE InitTraces;
     END
    ELSE InitTraces;
  ChkFlagMenu;
END;
{$ENDC }


{$S imeini }
PROCEDURE IMInitScrap;
VAR clsPos: Point;
    scrapErr: TC;
BEGIN
  IF UnderFiler
    THEN BEGIN
      OpenScrap(scrapErr);
      IF (scrapErr <> 0) AND sDebug THEN WRITELN('Scrap open error: ', scrapErr)
        ELSE IF IMtst THEN WRITELN('Scrap open error: ', scrapErr);
     END
    ELSE BEGIN
      InitScrap(scrapErr);
      IF (scrapErr <> 0) AND sDebug THEN WRITELN('Scrap init error: ', scrapErr)
        ELSE IF IMtst THEN WRITELN('Scrap init error: ', scrapErr);
      END;
  SetPt(clsPos, 540, 240);
  FolderSize(scrapFolder, 400, 50, FALSE);
  MoveFolder(scrapFolder, 30, 300);
  hScrapFldr := AddIMFolder(scrapObject, FALSE, TRUE, TRUE, 0);
  AddFldrMenu(hScrapFldr, FilingMInfo, FALSE);
  AddFldrMenu(hScrapFldr, TopicsMInfo, FALSE);
END;


{$S imew }
PROCEDURE SaveFldrState(inFldr: THFldrInfo);
VAR fs: THFldrState;
BEGIN
  IF fInSelect OR fSelection
    THEN BEGIN
      fs := HoldFldrState;
      fs^^.fsInSelect := fInSelect;
      fs^^.fsSelection := fSelection;
      fs^^.fsTimeout := selTimeout;
      IF cDebug AND IMtst THEN IF inFldr^^.fldrState <> NIL
        THEN StrangeError('Non nil fldr state in SaveFldrState');
      inFldr^^.fldrState := fs;
      fInSelect := FALSE;
      fSelection := FALSE;
      selTimeout := -1;
     END;
END;


{$S imew }
PROCEDURE BrokenFldrState(fromFldr: THFldrInfo);
BEGIN
  IF fromFldr^^.fldrState <> NIL
    THEN WITH fromFldr^^.fldrState^^
      DO BEGIN
        fInSelect := fsInSelect;
        fSelection := fsSelection;
        selTimeout := fsTimeout;
        FreeFldrState(fromFldr^^.fldrState);
        fromFldr^^.fldrState := NIL;
       END
    ELSE BEGIN
      fInSelect := FALSE;
      fSelection := FALSE;
      selTimeout := -1;
     END;
END;


{$S imew }
PROCEDURE DeActFldr;  { (imFldr: THFldrInfo);  FORWARD; }
VAR pbutn: TButn;
BEGIN
  IF imFldr = NIL
    THEN BEGIN
      IF cDebug AND IMtst THEN
        WRITELN('Trying to deactivate a NIL fldr.');
      EXIT(DeActFldr);
     END;
  IF imFldr <> hndActiveFldr
    THEN BEGIN
      IF cDebug AND IMtst THEN
        WRITELN('Trying to deactivate a non-active fldr:', ORD(imFldr));
      EXIT(DeActFldr);
     END;
  IMHideScroll(imFldr);
  SaveFldrState(hndActiveFldr);
  hndActiveFldr := NIL;
  ActiveWSLink := NIL;
END;



{$S imeh }
PROCEDURE DoTutorCommand;
BEGIN
  IF NOT kbdCommand
    THEN IF hndScriptFldr = hndActiveFldr
      THEN IF fSelection OR fInSelect THEN ClearSelection;
  { think about putting clear selection in DisplayCommand - RedrwDFldr }
  InterpretCommand;
  FinishCommand;
END;


{$S imec }
PROCEDURE DimHint;
VAR flg: TF;
BEGIN
  IF (HintCount < 1) OR (LastHint < 1) OR (HintDisplayed AND (LastHint < 2))
    THEN flg := FALSE
    ELSE flg := TRUE;
  IF IMTst THEN WRITELN('Previous Hint enable: ', flg);
  flg := SetActItem('Tutor', 'Previous Hint', flg);
  flg := LastHint < HintCount;
  IF IMTst THEN WRITELN('Next Hint enable: ', flg);
  flg := SetActItem('Tutor', 'Next Hint', flg);
END;


{$S imec }
PROCEDURE ClearHint;
BEGIN
  IF HintDisplayed THEN
    BEGIN
      IF HintStr <> NIL THEN ClearIMStream(HintStr);
      IF IMtst THEN WRITELN('Clearing hints');
      HintDisplayed := FALSE;
      HideFolder(alertFolder);
      HideButn(GoAwayButn);
    END;
  DimHint;
END;


{$S imex }
FUNCTION CalcMouseMoves(StartLoc, EndLoc: Point): TF;
VAR dh, dv: TC;
BEGIN
  dh := StartLoc.h - EndLoc.h;
  dv := StartLoc.v - EndLoc.v;
  IF dh > CMinHMouseMove THEN BEGIN fMMoveLeft := TRUE; END;
  IF -dh > CMinHMouseMove THEN BEGIN fMMoveRight := TRUE; END;
  IF dv > CMinVMouseMove THEN BEGIN fMMoveUp := TRUE; END;
  IF -dv > CMinVMouseMove THEN BEGIN fMMoveDown := TRUE; END;
  IF fMMoveLeft OR fMMoveRight OR fMMoveUp OR fMMoveDown
    THEN fMouseMoved := TRUE
    ELSE fMouseMoved := FALSE;
  IF IMtst THEN BEGIN
    WRITELN('Calc mouse moves. dh:', dh:5, '  dv:', dv:5);
    IF fMouseMoved THEN WRITE('Mouse moved: ');
    IF fMMoveLeft THEN WRITE(' left ');
    IF fMMoveRight THEN WRITE(' right ');
    IF fMMoveUp THEN WRITE(' up ');
    IF fMMoveDown THEN WRITE(' down.');
    WRITELN;
   END;
  CalcMouseMoves := fMouseMoved;
END;


{$S imew }
PROCEDURE WaitEnded; {(beware forward declaration) }
BEGIN
  IF IMtst THEN WRITELN('Wait ended, fWait = ', fWait);
  IF fWait THEN
    BEGIN
      ClearSelection;
      ClearRecordingFlags;
      ClearWaitFlags;
    END;
  waitTimeout := -1;
  fPause := FALSE;
  fWait := FALSE;
  ChkCtrlMenu;
END;


{$S imeh }
PROCEDURE SetPointNbhd(pt: Point; VAR nbhd: Rect);
BEGIN
  nbhd.topLeft := pt;
  nbhd.botRight.h := pt.h + 1;
  nbhd.botRight.v := pt.v + 1;
END;


{$S imew }
PROCEDURE WaitBegins;
BEGIN { whatever needs to be done when wait begins }
  IF IMtst THEN WRITELN('Wait Begins.');
  IF fWait THEN
        BEGIN ClearResultFlags; FreeObjtable; END;
  IF fRObjects THEN curObjTable := BldObjTable(deskObject);
  IF fWTimeout OR fPause THEN
    BEGIN
      toWaitEndTime := TIME + toWaitTime;
      waitTimeout := 1;
      IF IMtst THEN BEGIN
          WRITELN('Timeout wait for ', toWaitTime, '  ends at: ', toWaitEndTime);
         END;
    END;
  IF fWMouseMoved
    THEN BEGIN
      SetPort(LGPort);
      GetMouse(WaitMouseLoc);
      IF IMtst
        THEN BEGIN WRITE('WaitMouseLoc: '); PrintPoint(WaitMouseLoc);
                   WRITELN(' in port: ', ORD(thePort)); END;
     END;
  ChkCtrlMenu;
END;


{$S imex }
FUNCTION FldrWidth(fldr: WindowPtr): TC;
BEGIN
WITH fldr^.PortRect DO
  FldrWidth := right - left;
END;


{$S imex }
FUNCTION FldrHeight(fldr: WindowPtr): TC;
BEGIN
WITH fldr^.PortRect DO
  FldrHeight := bottom - top;
END;


{$S imex }
FUNCTION FldrLeft(fldr: WindowPtr): TC;
BEGIN
WITH fldr^.PortBits.bounds DO
  FldrLeft := -left;
END;


{$S imex }
FUNCTION FldrTop(fldr: WindowPtr): TC;
BEGIN
WITH fldr^.PortBits.bounds DO
  FldrTop := -top;
END;


{$S imec }
PROCEDURE DrawABoxContents;
VAR hfldr: THFldrInfo;
BEGIN
  hfldr := hndAlertFldr;
  IF IMTst THEN BEGIN
        WRITELN('DrawContents for alert folder:', ORD(alertFolder));
        WRITE('PortRect: '); PrintRect(alertFolder^.PortRect);
      END;
  IF NOT HintDisplayed THEN EXIT(DrawABoxContents);  { a real alert! }
  BEGIN
    ReDrawFldrContents(hfldr);
    ShowButn(GoAwayButn, 20, alertFolder^.PortRect.bottom - 23, TRUE);
   END;
END;


{$S imex }
PROCEDURE DisplayNextHint(nextFlag: TF);
VAR saveLGStr: THIMS;
    saveLGPos: TFpos;
    hstr: Str255;
    dbHt: TC;
BEGIN
  IF NOT nextFlag
    THEN BEGIN
      IF NOT HintDisplayed
        THEN BEGIN
          IF LastHint > 0 THEN LastHint := LastHint - 1;
         END
        ELSE IF LastHint > 1
          THEN LastHint := LastHint - 2
          ELSE LastHint := 0;
     END;
  IF LastHint >= HintCount
    THEN BEGIN
      IF HintDisplayed
        THEN BEGIN
          ClearHint;
          DimHint;
         END;
      EXIT(DisplayNextHint);
     END;
  HideFolder(alertFolder);
  ClearIMStream(HintStr);
  PushButn(GoAwayButn, FALSE);
  SetPort(alertFolder);
  saveLGStr := LGStr;
  LGStr := HintStr;
  LastHint := LastHint + 1;
  IF IMtst THEN WRITELN('Displaying hint number: ', LastHint);
  saveLGPos := IMFLinePos(PIMFS, ScriptPos);
  IF NOT IMFSetPos(PIMFS, PHintList^[LastHint])
    THEN BEGIN
       IF sDebug THEN WRITELN('Cant find existing hint!! File unit error.');
       Brk(884);
       EXIT(DisplayNextHint);
     END;
  DoTutorCommand;
  IF NOT IMFSetPos(PIMFS, saveLGPos) THEN BEGIN
    IF sDebug THEN
      WRITELN('Cant return to current file position... File Unit Error!!!');
    Brk(883);
   END;
  HintDisplayed := TRUE;
  LGStr := saveLGStr;
  dbHt := StreamHt(HintStr);
  hintHeight := dbHt + 25;
  IF (FldrWidth(alertFolder) <> hintWidth) OR
     (FldrHeight(alertFolder) <> hintHeight)
    THEN FolderSize(alertFolder, hintWidth, hintHeight, FALSE);
  IF (FldrTop(alertFolder) <> hintTop) OR (FldrLeft(alertFolder) <> hintLeft)
      THEN MoveFolder(alertFolder, hintLeft, hintTop);
  ShowFolder(alertFolder);
  SetPort(alertFolder);
  EraseRect(alertFolder^.PortRect);
  IF IMtst THEN BEGIN
    WRITELN('Alert folder:');
    PrintPort(alertFolder);
   END;
  DimHint;
END;


{$S imew }
PROCEDURE SimStopped;
BEGIN
  IF IMTst THEN WRITELN('SimStopped.  fSimHold = ', fSimHold);
  fSimRunning := FALSE;
  IF simMode = CsimRecord THEN CloseRecord;
  IF simMode = CsimPlayback THEN ClosePlayback;
  IF NOT fSimHold THEN fSim := FALSE;
END;

{$S imew }
PROCEDURE SimSetup;
BEGIN
  fSelection := FALSE;
  fInSelect := FALSE;
  fButtonUp := TRUE;
  clickTime := 0;
  clickCount := 0;
  ClearSelection;
END;

{$S imew }
PROCEDURE SimPlayback;
VAR fOK: TF;
    fName: TFileStr;
BEGIN
  SimSetup;
  fName := simName;
  IF fSimEdit
    THEN BEGIN
      fOK := IMFSetPos(PIMFS, simPos);
      IF fPlayXFile THEN fName := CONCAT('X', fName);
     END;
  fSimWtPB := FALSE;
  IF IMtst THEN WRITELN('Starting playback of sim file: ', fName);
  IF OpenPlayback(fName)
    THEN BEGIN
      fSimRunning := TRUE;
     END
    ELSE BEGIN
      IF IMtst OR sDebug
        THEN WRITELN('Cant open simulation playback file: ', fName);
      SimStopped;
     END;
END;


{$S imedbg }
PROCEDURE SimRecord;
VAR fOK: TF;
BEGIN
  SimSetup;
  IF fSimEdit THEN fOK := IMFSetPos(PIMFS, simPos);
  fSimWtRec := FALSE;
  IF IMtst THEN WRITELN('Starting record of sim file: ', simName);
  IF OpenRecord(simName)
    THEN BEGIN
      fSimRunning := TRUE;
      IF sDebug THEN WRITELN('Record started. simMode = ', simMode);
     END
    ELSE BEGIN
      CmdError('Cant open simulation record file: ');
      CmdError(simName);
      SimStopped;
     END;
END;


{$S imedbg }
PROCEDURE SimCopy(srcName, destName: TFileStr);
LABEL 900;
BEGIN
  MakeSimName(srcName);
  MakeSimName(destName);
  IF NOT FileExists(srcName)
    THEN BEGIN
      WRITELN('SimCopy - cant find source file: ', srcName);
      GOTO 900;
     END;
  IF FileExists(destName)
    THEN BEGIN
      WRITELN('Destroy current file: ', destName, '?');
      IF NOT GetYorN
        THEN BEGIN
          WRITELN('Sim file ', srcName, ' NOT copied to ', destName);
          GOTO 900;
         END;
     END;
  IF CopyJrnlFile(srcName, destName)
    THEN WRITELN('current sim file (', srcName, ') saved as:', destName)
    ELSE WRITELN('Cant copy sim file: ', srcName);
900:
END;


{$S imedbg }
PROCEDURE SimSave;
VAR srcName, destName: TFileStr;
BEGIN
  srcName := simName;
  destName := CONCAT('X', simName);
  SimCopy(srcName, destName);
END;


{$S imedbg }
PROCEDURE SimRestore;
VAR srcName, destName: TFileStr;
BEGIN
  srcName := CONCAT('X', simName);
  destName := simName;
  SimCopy(srcName, destName);
END;


{$IFC IMDebug}
{$S imeini }
PROCEDURE IMSetup;
LABEL 700,900;
VAR prfxFid: TEXT;
    prfxStr: TFileStr;
    fidx: TB;
    fFam: TC;
    fontKey: TKeyStr;
    ior: TC;
BEGIN
  {$I- }
  RESET(prfxFid, SetupFile);
  ior := IORESULT;
  IF cDebug AND (ior <> 0)
    THEN BEGIN
        WRITELN('IMSetup:  reset setup file - ',
                      SetupFile, ' err:', ior);
     END;
  IF ior = 0 THEN
    WHILE NOT EOF(prfxFid) DO
      BEGIN
        READLN(prfxFid, prfxStr);
        IF IMtst THEN WRITELN('setup prfxstr: ', prfxStr);
        ior := IORESULT;
        IF ior <> 0 THEN GOTO 700;
        IF POS('PREFIX', prfxStr) <> 0
          THEN BEGIN
            READLN(prfxFid, prfxStr);
            IF IMtst THEN WRITELN('prefix prfxstr: ', prfxStr);
            ior := IORESULT;
            IF ior = 0
              THEN BEGIN
                LisaPrefix := prfxStr;
                IF IMtst THEN WRITELN('LisaPrefix set to: <', LisaPrefix, '>');
               END
              ELSE BEGIN
                IF IMtst THEN
                  WRITELN('Cant read prefix string from prefix file. ior=', ior);
                IF IMtst THEN WRITELN('Lisa prefix remains = ', LisaPrefix);
               END;
           END;
        IF POS('SETDEMO', prfxStr) <> 0
          THEN BEGIN
            READLN(prfxFid, prfxStr);
            IF IMtst THEN WRITELN('prefix prfxstr: ', prfxStr);
            ior := IORESULT;
            IF ior = 0
              THEN BEGIN
                IF prfxStr = 'ASK'
                  THEN fAskDemo := TRUE
                  ELSE IF prfxStr = 'FALSE'
                    THEN BEGIN
                      fAskDemo := FALSE;
                      demoFlag := FALSE;
                     END
                    ELSE IF prfxStr = 'TRUE'
                      THEN BEGIN
                        fAskDemo := FALSE;
                        demoFlag := TRUE;
                       END;
                IF IMtst THEN WRITELN('fAskDemo set to: ', fAskDemo);
                IF IMtst THEN WRITELN('demoFlag set to: ', demoFlag);
               END
              ELSE BEGIN
                IF IMtst THEN
                  WRITELN('Cant read askdemo string from prefix file. ior =', ior);
               END;
           END;
        IF POS('ASKFLAGS', prfxStr) <> 0
          THEN BEGIN
            READLN(prfxFid, prfxStr);
            IF IMtst THEN WRITELN('prefix prfxstr: ', prfxStr);
            ior := IORESULT;
            IF ior = 0
              THEN BEGIN
                IF prfxStr = 'FALSE'
                  THEN fAskFlags := FALSE
                  ELSE IF prfxStr = 'TRUE'
                    THEN fAskFlags := TRUE;
                IF IMtst THEN WRITELN('fAskFlags set to: ', fAskFlags);
               END
              ELSE BEGIN
                IF IMtst THEN
                 WRITELN('Cant read askflags string from prefix file. ior =', ior);
               END;
           END;
        IF POS('FONT', prfxStr) <> 0
          THEN BEGIN
            READLN(prfxFid, fontKey);
            IF IMtst THEN WRITELN('prefix fontKey: ', fontKey);
            ior := IORESULT;
            IF ior = 0
              THEN BEGIN
                READLN(prfxFid, fFam);
                ior := IORESULT;
                IF ior = 0
                  THEN BEGIN
                    fidx := AddIMFont(fontKey, fFam);
                    IF IMtst THEN
                      WRITELN('Font ', fontKey, ' index: ', fidx,
                              ' is set to font family:', fFam);
                   END
                  ELSE BEGIN
                     IF IMtst THEN WRITELN(
                       'Cant read font family number from prefix file. ior =', ior);
                      END;
               END
              ELSE BEGIN
                 IF IMtst THEN
                   WRITELN('Cant read fontKey string from prefix file. ior =', ior);
                 READLN(prfxFid, prfxStr);
                 IF IMtst THEN WRITELN('Skipping prefix line: ', prfxStr);
               END;
           END;
       END
    ELSE IF cDebug THEN WRITELN('Cant open prefix file. ior = ', ior);
  GOTO 900;
700:
  IF sDebug THEN WRITELN('Error reading prefix file: ', ior);
  CLOSE(prfxFid);
  {$I+ }
900:
END;
{$ENDC }

{ -------------------------------------------------------------------- }

PROCEDURE EjectDisk(dName: e_name);
VAR fsParams: UT_ParmT;
    err: TC;
BEGIN
  UnMount(err, dName);
  IF err <> 0
    THEN BEGIN
      IF sDebug THEN WRITELN(dName, ' UnMount eject err = ', err);
     END
    ELSE IF IMtst THEN WRITELN(dName, ' UnMount ejected, err = 0');
  fsParams.command := eject;
  fsParams.dev_name := dName;
  FS_Utilities(err, fsParams);
  IF err <> 0
    THEN BEGIN
      IF sDebug THEN WRITELN(dName, ' Diskette eject err = ', err);
     END
    ELSE IF IMtst THEN WRITELN(dName, ' Diskette ejected, err = 0');
END;

{ -------------------------------------------------------------------- }

PROCEDURE SetShutDown(doNextCode: TL);
BEGIN
  IF IMtst THEN WRITELN('SetShutDown code = ', doNextCode);
  nxShellCode := doNextCode;
  GOTO 999;
END;


{ -------------------------------------------------------------------- }
PROCEDURE ShutDown;
VAR shellStr: TStr40;
    tpParams:  s_eventblk;
    err: TC;
BEGIN
  CursorInit;
  CursorTracking(TRUE);  { esp in case of demo crashes }

  IF feStarted THEN FETerminate;

  CloseLocMap;

  IF bootVol^^.volState = sMounted THEN
      BEGIN
      CloseCat(err, bootVol);
      IF err <> 0 THEN IF sDebug THEN
          WRITELN('Error closing boot catalog: ', err);
      err := 0;
      END;

{$IFC IMCompile }
  IF fICompile THEN BEGIN ICCompComplete; CloseComp; END;
{$ENDC }
  IF NOT IMFSetPos(PIMFS, -1)
    THEN IF sDebug THEN WRITELN('ShutDown - IMFSetPos failed to close script');
  {IF imVolName = 'upper' THEN EjectDisk(imVolName);}
  {IF imVolName = 'lower' THEN EjectDisk(imVolName);}

  ImDying;

   { blank the screen }
  IF qdStarted THEN BEGIN
    SetPort(deskPort);
    ClipRect(deskPort^.portRect);
    FillRect(deskPort^.portRect,gray);
   END;

  tpParams[1] := nxShellCode;
  MoveRgch(POINTER(ORD4(@tpParams)+8), POINTER(ORD4(@nxShellName)+1), 32);
  IF IMtst THEN WRITELN('Calling Terminate_Process nxShellCode=', nxShellCode,
                        ' next shell name length :', LENGTH(nxShellName));
  IF IMtst THEN WRITELN(' next shell name "', nxShellName, '"');
  Terminate_Process(err, @tpParams);
  IF IMtst THEN WRITELN('Terminate_Process err = ', err);
END;


{ -------------------------------------------------------------------- }

{$s imeini}
PROCEDURE FailedInit;
VAR errnum: TC;
BEGIN
  WRITELN('LisaGuide Init failed');
  IF cDebug
    THEN BEGIN
      WRITELN('Something failed in the LisaGuide init, Failure is Probable!');
      {$IFC IMDebug } HoldIt(TRUE); {$ENDC }
     END
    ELSE BEGIN
      IF UnderFiler THEN
        TellFiler(errnum,initfailed,internalerror,LGPort);
      SetShutDown(selectShell);
     END;
END;

{ -------------------------------------------------------------------- }

PROCEDURE LastWishes(environPtr : P_env_blk; excepDataPtr : P_ex_data);
{$IFC IMDebug }
LABEL 123;
{$ENDC }
BEGIN
  IF sDebug THEN WRITELN('LisaGuide - LastWishes');
  {$IFC IMDebug }
    IF cDebug THEN IF NOT fQuit
      THEN BEGIN
        WRITELN('LastWishes for abnormal death - type "g pc+2<cr>" to lisaBug');
        123: GOTO 123;
       END;
  {$ENDC }

  IF NOT fQuit THEN   { Must have crashed }
     Writeln('   Abnormal death in the LisaGuide tool.');
  ShutDown;
  IF sDebug THEN WRITELN('Halting');
END;

{ -------------------------------------------------------------------- }

{$s imeini }
PROCEDURE QDError(err: INTEGER);
BEGIN
{$IFC IMDebug}
  IF sDebug THEN WRITELN('Error in QuickDraw: ', err);
  IF sDebug OR cDebug THEN HoldIt(TRUE)
    ELSE SetShutDown(selectShell);
{$ENDC }
END;

{ -------------------------------------------------------------------- }

{$S imew }
PROCEDURE DrawContents(folder: WindowPtr);
VAR hfldr: THFldrInfo;
BEGIN
  hfldr := PortFolder(folder);
  IF IMTst AND cDebug THEN BEGIN
        WRITELN('DrawContents for folder:', ORD(folder));
        WRITE('PortRect: '); PrintRect(folder^.PortRect);
      END;
  IFDrawInsides(folder);
END;

{ -------------------------------------------------------------------- }


{$S imec }
PROCEDURE DoRandAccess(midx, iidx: TC);
VAR BlockKey: TKeyStr;
    TopicName: Str255;
BEGIN
  IF fSimRunning THEN EXIT(DoRandAccess);
  IF iidx > 0 THEN BEGIN
      WouldAlert(TopicsMInfo^^.mBarInfo^, iidx);
      IF IMTst THEN WRITELN('Trying random Topics menu item: ', iidx);
      GetItem(TopicsMInfo^^.mLookupInfo^, iidx, @BlockKey);
      IF IMTst THEN WRITELN('Skipping to Lesson named: ', BlockKey);
      WaitEnded;
      SkipTo('L', BlockKey);
      IF TRUE OR fSkip THEN BEGIN
         GetItem(TopicsMInfo^^.mNameInfo^, iidx, @TopicName);
         ParamAlert (TopicName,'','');
         IMAlertUp;
         WaitAlert (imalert, 410);
       END;
    END;
END;


{$S imeh }
PROCEDURE DoIMButton(btnIdx: TC);
VAR pBtnRec: TPButton;
    BlockKey: TKeyStr;
BEGIN
  IF fSimRunning THEN EXIT(DoIMButton);
  pBtnRec := GetButtonRec(btnIdx);
  IF pBtnRec = NIL
    THEN BEGIN
      IF IMTst THEN WRITELN('Invalid button in DoIMButton');
      Brk(993);
      EXIT(DoIMButton);
     END;
  BlockKey := pBtnRec^.btnName;
  IF BlockKey = 'CONT'
    THEN fContinue := TRUE;
  IF cDebug THEN IF NOT fWait THEN
    IF BlockKey = 'CONT'
      THEN WRITELN('Continue hit before wait begun!!')
      ELSE WRITELN('Block Button hit before wait begun!!');
  ClearHint;
  WaitEnded;
  IF BlockKey <> 'CONT'
    THEN BEGIN
      IF IMTst THEN WRITELN('Skipping to Block named: ', BlockKey);
      SkipTo('B', BlockKey);
     END;
END;


{$S imex }
PROCEDURE DoTutorMenu(midx, iidx: TC);
BEGIN
  WouldAlert(TutorMInfo^^.mBarInfo^, iidx);
  CASE iidx OF
    iContLesson: BEGIN ClearHint; WaitEnded; END;
    iNextHint: DisplayNextHint(TRUE);
    iPrevHint: DisplayNextHint(FALSE);
  END;
END;


{$S imew }
PROCEDURE DoEditMenu(midx, iidx: TC);
VAR errnum: TC;
    wsLink: THWSLink;
BEGIN
  WouldAlert(EditMInfo^^.mBarInfo^, iidx);
  errnum := 0;
  IF activeContainer OR (ActiveWSLink = NIL)
    THEN BEGIN
      IFMenuCommand(midx, iidx);
      EXIT(DoEditMenu);
     END;
  CASE iidx OF
     iCut: BEGIN
             IMSCut(ActiveWSLink, errnum);
             SetupUndo(TRUE);
           END;
     iPaste: BEGIN
               IMSPaste(ActiveWSLink, errnum);
               SetupUndo(TRUE);
             END;
     iCopy: BEGIN
              IMSCopy(ActiveWSLink, errnum);
              SetupUndo(TRUE);
            END;
     iUndo: BEGIN
              IMSUndo(ActiveWSLink, errnum);
            END;
     OTHERWISE IFMenuCommand(midx, iidx);
     END; { of case }
  IF errnum <> 0 THEN
     BEGIN
       IF sDebug THEN WRITELN ('Edit error ', errnum);
     END;
END;


{$IFC IMDebug}
{$S imec }
PROCEDURE DoControlMenu(menu, item: INTEGER);
VAR hfldr: THFldrInfo;
    himstr: THIMS;
    himwindow: THIMW;
    himwsl: THWSLink;
    mapFile: PathName;
    saveSDbg: TF;
BEGIN
  WouldAlert(CtrlMInfo^^.mBarInfo^, item);
  CASE item OF { IM Control Menu }
    iCSStep: BEGIN
             IF fWait THEN WRITELN('Still waiting...')
               ELSE BEGIN
                 fStepped := FALSE;
               END;
           END;
    iCSWait: BEGIN fWait := NOT fWait;
               IF fWait THEN WaitBegins ELSE WaitEnded;
             END;
    iCS1Step: BEGIN
                fSingleStep := NOT fSingleStep;
                fStepped := TRUE;
              END;
    iCWindCmd: BEGIN
                fStepped := FALSE;
                DoWindowCmd;
              END;
    iCrdrw: BEGIN
              DrawContents(activePort);
            END;
    iCShowScr: ShowScript;
    iCKillScr:
       BEGIN
        IF hndScriptFldr <> NIL
          THEN IF hndScriptFldr = hndActiveFldr
                 THEN DeActFldr(hndScriptFldr);
        KillScript;
        ChkFlagMenu; { for script print flag }
       END;
    iCPrSkip: PrintSkipStuff;
    iCClSkip: ClearSkips;
    iCMkMap:
      BEGIN
        IF locMapFile <> ''
          THEN mapFile := locMapFile
          ELSE mapFile := CONCAT('-', imVolName, '-', imToolName, 'LessonMap');
        IF NOT MakeLocMap(mapFile) THEN StopAlert(imAlert, 414);
       END;
    iCCmprsScr:
       BEGIN
       saveSDbg := sDebug;
       WRITELN('Compressing script to file LGCScript.text');
       sDebug := TRUE;
       DumpCScriptLesson(0);
       sDebug := saveSDbg;
       END;
    iCDpSyntx:
      BEGIN
        DumpCmdChars;
      END;
  END;
  ChkCtrlMenu;
END;
{$ENDC }


{$IFC IMDebug}
{$S imec }
PROCEDURE DoFileControlMenu(menu, item: TC);
VAR dcLEsson: TC;
    wordFile: TEXT;
BEGIN
  WouldAlert(FCtrlMInfo^^.mBarInfo^, item);
  CASE item OF { IM Flags menu }
    iFShow: BEGIN ShowIMFPos(PIMFS); END;
    iFShowL: BEGIN ShowIMFLinePos(PIMFS, ScriptPos); END;
    iFSetP: BEGIN ClearSkips; SetIMFRPos(PIMFS); END;
    iFSetFP: BEGIN ClearSkips; SetIMFFilePos(PIMFS); END;
    iFReSet: BEGIN ClearSkips; ReSetIMFPos(PIMFS); END;
    iFNxtL:  NextIMFLine(PIMFS);
    iFNxtC:  NextIMFChar(PIMFS);
    iFPrvExz: IF IMFSetPos(PIMFS, PrevExzPos) THEN BEGIN
                PrevExzPos := 0;
                SetAbleItem(FCtrlMInfo, iFPrvExz, FALSE);
                InExercise := FALSE;
                ClearBTables;
                ClearETables;
                WaitEnded;
               END
              ELSE WRITELN('Cant find last exercise position');
    iFLstExz: IF IMFSetPos(PIMFS, LastExzPos) THEN BEGIN
                InExercise := FALSE;
                ClearBTables;
                ClearETables;
                WaitEnded;
               END
              ELSE WRITELN('Cant find last exercise position');
    iFShwBufP: {ShowIMFBufPos(PIMFS); }
               BEGIN
               WRITELN('Dump text of word buf to file LGWords.text');
               REWRITE(wordFile, 'LGWords.text');
               ICDumpWords;
               CLOSE(wordFile, LOCK);
               END;
    iFPrtPBuf: ListIMFBuf(PIMFS);
   END;
END;
{$ENDC }


{$IFC IMDebug}
{$S imec }
PROCEDURE DoFlagMenu(menu, item: TC);
BEGIN
  WouldAlert(FlagsMInfo^^.mBarInfo^, item);
  CASE item OF  { IM Flags menu  }
    iFlNoTrace:     InitTraces;
    iFlTrace: IMtst := NOT IMtst;
    iFlSCmdErrs: IF sDebug
                   THEN BEGIN sDebug := FALSE; END
                   ELSE BEGIN sDebug := TRUE; END;
    iFlIMScPrt: BEGIN
                  IF fScriptPrint THEN fScriptPrint := FALSE
                                  ELSE fScriptPrint := TRUE;
                  PrtScript(fScriptPrint);
                  ChkCtrlMenu;  { for script stuff }
                 END;
    iFlErTrace:     IF IMERtst THEN IMERtst := FALSE
                               ELSE IMERtst := TRUE;
    iFlTFTrace:     IF fTstTF THEN fTstTF := FALSE
                              ELSE fTstTF := TRUE;
    iFlIMPatTrace:  IF fTstPat THEN fTstPat := FALSE
                               ELSE fTstPat := TRUE;
    iFlIMSTrace:    IF IMStst THEN IMStst := FALSE
                              ELSE IMStst := TRUE;
    iFlIMFTrace:    IF IMFtst THEN IMFtst := FALSE
                              ELSE IMFtst := TRUE;
    iFlIMMTrace:    IF IMMtst THEN IMMtst := FALSE
                              ELSE IMMtst := TRUE;
    iFlIMFldrTrace: IF fTstFldrs THEN fTstFldrs := FALSE
                                 ELSE fTstFldrs := TRUE;
    iFlIMScrTrace:  IF IMScrTst THEN IMScrTst := FALSE
                                ELSE IMScrTst := TRUE;
    iFlIMTabTrace:  IF fTstTab THEN fTstTab := FALSE
                               ELSE fTstTab := TRUE;
    iFlIMFETrace:   IF IMFldTst THEN IMFldTst := FALSE
                                ELSE IMFldTst := TRUE;
    iFlSSTrace:     IF fScriptTrace THEN fScriptTrace := FALSE
                                    ELSE fScriptTrace := TRUE;
    iFlIMEvtTst:    IF fIMEvtTst THEN fIMEvtTst := FALSE
                                 ELSE fIMEvtTst := TRUE;
    iFlcDebug:      IF cDebug THEN cDebug := FALSE
                       ELSE BEGIN sDebug := TRUE; cDebug := TRUE; END;
    iFlFieldTrace: BEGIN
                    {$IFC fDbgOK }
                     IF fldTest
                       THEN fldTest := FALSE
                       ELSE fldTest := TRUE;
                     SetFldTest(fldTest);
                    {$ENDC }
                    END;
    iFlAllTraces:  AskTrace(FALSE);
   END;
  ChkFlagMenu;
END;
{$ENDC }


{$IFC IMDebug}
{$S imec }
PROCEDURE DoSimMenu(menu, item: TC);
BEGIN
  WouldAlert(SimMInfo^^.mBarInfo^, item);
  CASE item OF { IM Flags menu }
    iSimEdit:  IF fSimEdit
         THEN BEGIN fSimEdit := FALSE; WRITELN('Simulation Editing  stopped'); END
         ELSE BEGIN fSimEdit := TRUE; WRITELN('Simulation Editing  started'); END;
    iSimTrace:  IF fTstSim
         THEN BEGIN fTstSim := FALSE; WRITELN('Simulation Trace  stopped'); END
         ELSE BEGIN fTstSim := TRUE; WRITELN('Simulation Trace  started'); END;
    iSimPB: IF fSim
              THEN BEGIN fPlayXFile := FALSE; fSimWtPB := TRUE; END
              ELSE WRITELN('Not in simulation command.');
    iSimPBGo: BEGIN
                fSimHold := FALSE;
                IF fSim THEN fSimWtPB := TRUE
                        ELSE WRITELN('Not in simulation command.');
              END;
    iSimGo: BEGIN
              fSimHold := FALSE;
              IF fSim THEN SimStopped;
            END;
    iSimRecord:
      IF fSim
        THEN BEGIN
          fSimWtRec := TRUE;
          WRITELN('Type Code-S to start simulation recording.');
          WRITELN('Type Code-. to end simulation recording.');
         END
        ELSE WRITELN('Not in simulation command.');
    iSimSave:   SimSave;
    iSimRest:   SimRestore;
    iSimPBx: IF fSim
               THEN BEGIN fPlayXFile := TRUE; fSimWtPB := TRUE; END
               ELSE WRITELN('Not in simulation command.');
    iSimSetMode:
       BEGIN
         WRITE('Enter Journal mode for simulations (0..3):');
         READLN(simJMode);
         WRITELN('SimJMode set to:', simJMode);
       END;
  END;
  IMCheckItem(SimMInfo, iSimEdit, fSimEdit);
  IMCheckItem(SimMInfo, iSimTrace, fTstSim);
END;
{$ENDC }

{$s imeini }
PROCEDURE ReadTutorMenus(debugFlag: TF);
VAR menuFile: TEXT;
    i : INTEGER;
    ior: TC;
BEGIN
  IF IMtst THEN WRITELN('ReadTutorMenus - reading TutorMenus file');
  RESET(menuFile,TutorMFile);
  ior := IORESULT;
  IF IMtst THEN
    WRITELN('Reset TutorMenus file: ', TutorMFile, ' err:', ior);
  IF ior <> 0
    THEN BEGIN
      StrangeError('Read tutor menu:  cant find menu file');
      FailedInit;
     END;
  FOR i:=firstTMenu to lastTMenu DO
    BEGIN  { added for im tracing }
      IF IMMtst THEN
        WRITELN('Reading bar menu ', i:2, ' into ', ORD(@TutorBarMenus[i]));
      ReadMenu(menuFile,TutorBarMenus[i]);
     END;
  CLOSE(menuFile);
  RESET(menuFile,TutorMFile);
  ior := IORESULT;
  IF IMtst THEN
    WRITELN('Reset TutorMenus file: ', TutorMFile, ' err:', ior);
  FOR i:=firstTMenu to lastTMenu DO
    BEGIN  { added for im tracing }
      IF IMMtst THEN
        WRITELN('Reading name menu ',i:2,' into ',ORD(@TutorNameMenus[i]));
      ReadMenu(menuFile,TutorNameMenus[i]);
     END;
  CLOSE(menuFile);

  IF IMtst THEN WRITELN('ReadTutorMenus - reading TopicMenu file');
  RESET(menuFile,TopicMFile);
  ior := IORESULT;
  IF IMtst THEN
    WRITELN('Reset TopicsMenu file: ', TopicMFile, ' err:', ior);
  IF ior <> 0
    THEN BEGIN
      StrangeError('Reading topics menu:  cant find menu file');
      FailedInit;
     END;
  ReadMenu(menuFile,TutorBarMenus[mTopics]);
  CLOSE(menuFile);
  RESET(menuFile,TopicMFile);
  ior := IORESULT;
  IF IMtst THEN
    WRITELN('Reset TopicsMenu file: ', TopicMFile, ' err:', ior);
  ReadMenu(menuFile,TutorNameMenus[mTopics]);
  ReadMenu(menuFile,TopicLookupMenu);
  CLOSE(menuFile);

  IF IMtst THEN WRITELN('ReadTutorMenus - reading FilerMenus file');
  RESET(menuFile,FilerMenus);
  ior := IORESULT;
  IF IMtst THEN
    WRITELN('Reset FlrMenu file: ', FilerMenus, ' err:', ior);
  FOR i:=firstFlrMenu to lastFlrMenu DO
    BEGIN
     IF IMMtst THEN
       WRITELN('Reading flr name menu ',i:2,' into ',ORD(@flrNameMenus[i]));
      ReadMenu(menuFile,flrNameMenus[i]);
    END;
  CLOSE(menuFile);

  TutorMInfo :=
      NewMenu('Tutor', FALSE, FALSE, @TutorBarMenus[mTutor],
               @TutorNameMenus[mTutor], @TutorNameMenus[mTutor]);
  EditMInfo :=
      NewMenu('Edit', FALSE, FALSE, @TutorBarMenus[mEdit],
              @TutorNameMenus[mEdit], @TutorNameMenus[mEdit]);
  CtrlMInfo :=
      NewMenu('IM Control',TRUE,debugFlag,@TutorBarMenus[mControl],
              @TutorNameMenus[mControl], @TutorNameMenus[mControl]);
  FCtrlMInfo :=
      NewMenu('File Control',TRUE,debugFlag,@TutorBarMenus[mFControl],
              @TutorNameMenus[mFControl], @TutorNameMenus[mFControl]);
  FlagsMInfo :=
      NewMenu('IM Flags', TRUE, debugFlag, @TutorBarMenus[mFlags],
              @TutorNameMenus[mFlags], @TutorNameMenus[mFlags]);
  SimMInfo :=
      NewMenu('Sim Edit', TRUE, debugFlag, @TutorBarMenus[mSim],
              @TutorNameMenus[mSim], @TutorNameMenus[mSim]);
  TopicsMInfo :=
      NewMenu('Topics', FALSE, FALSE, @TutorBarMenus[mTopics],
              @TutorNameMenus[mTopics], @TopicLookupMenu);
  FilingMInfo :=
      NewMenu('File/Print', FALSE, FALSE, @flrMenus[filingMenu],
              @flrNameMenus[filingMenu], @flrNameMenus[filingMenu]);
  FlrEditMInfo :=
      NewMenu('FlrEdit', FALSE, FALSE, @flrMenus[editMenu],
              @flrNameMenus[editMenu], @flrNameMenus[editMenu]);
  ViewMInfo :=
      NewMenu('View', FALSE, FALSE, @flrMenus[viewMenu],
              @flrNameMenus[viewMenu], @flrNameMenus[viewMenu]);
  FlrDiskMInfo :=
      NewMenu('Disk', FALSE, FALSE, @flrMenus[diskMenu],
              @flrNameMenus[diskMenu], @flrNameMenus[diskMenu]);
  SpecMInfo :=
      NewMenu('Special', FALSE, FALSE, @flrMenus[specialMenu],
              @flrNameMenus[specialMenu], @flrNameMenus[specialMenu]);
END;


{$s imeini }
PROCEDURE ShowDebugMenus(debugFlag: TF);
VAR fOK: TF;
BEGIN
  fOK := SetDspMenu('IM Control', debugFlag);
  fOK := SetDspMenu('File Control', debugFlag);
  fOK := SetDspMenu('IM Flags', debugFlag);
  fOK := SetDspMenu('Sim Edit', debugFlag);
  LoadMenuBar(hndActiveFldr);
END;


{$s imew }
PROCEDURE TutorMenuCommand(menu, item: INTEGER);
BEGIN
  IF IMTst THEN WRITELN('TutorMenuCommand(', menu, ',', item,')');
  IF (item > 0) THEN IF logging THEN SysILog(103, menu, item);
  IF fRCommands AND (item > 0)
      THEN AddCmdRec(curEvtBuf, menu, item, FALSE);
  CASE menu OF
    editMenu:  DoEditMenu(menu, item);
    mTutor:    DoTutorMenu(menu, item);
    mEdit:     DoEditMenu(menu, item);
{$IFC IMDebug}
    mControl:  DoControlMenu(menu, item);
    mFControl: DoFileControlMenu(menu, item);
    mFlags:    DoFlagMenu(menu, item);
    mSim:      DoSimMenu(menu, item);
{$ENDC }
    mTopics:   DoRandAccess(menu, item);
    OTHERWISE  IFMenuCommand(menu, item);
  END;
  HiliteMenu(0);
END;


{$S imeh }
PROCEDURE UpdateIMCursor;
{ changes cursor as appropriate }
VAR myPort, savePort: GrafPtr;
    pt, wPt: Point;
    whichCursor: INTEGER;
BEGIN
whichCursor := icrsInactive;
IF activeWSLink = NIL
  THEN BEGIN
    IF IMtst THEN WRITELN('UpdateCursor - no active link');
    SetStdCursor(whichCursor);
    EXIT(UpdateIMCursor);
   END;

GetPort(savePort);
myPort := hndActiveFldr^^.fldrPort;
SetPort(myPort);

GetMouse(pt);
IF PtInRgn(pt,myPort^.visRgn) THEN
  IF hndActiveFldr^^.fldrSBars
    THEN WITH thePort^.PortRect DO BEGIN
       IF (pt.h < right-dhSBox+1) AND (pt.v < bottom-dvSBox+1)
         THEN whichCursor := icrsXIBeam;
      END
    ELSE whichCursor := icrsXIBeam;

wPt := pt;
WindPt(ActiveWSLink^^.kWindow, wPt);
IF (whichCursor = icrsXIBeam) AND (activeWSLink <> NIL)
  THEN IF OverIMButton(activeWSLink, wPt) <> NIL
     THEN whichCursor := icrsInactive
     ELSE BEGIN
       IF crsHidden THEN IF PtInRect(pt, crsHideRect)
         THEN whichCursor := icrsHidden;
      END;

IF whichCursor <> icrsHidden THEN crsHidden := FALSE;
SetStdCursor(whichCursor);
SetPort(savePort);
END;


{$S imex }
FUNCTION SkipEvent: BOOLEAN;
BEGIN
  { use this to filter out events after apple-period pressed }
  SkipEvent:=FALSE;
END;


{$S imec }
PROCEDURE DoCodeKey;
CONST
Qcap = $75;
Scap = $76;
periodCap = 94;
Zcap = $79;
Gcap = $6A;
Ocap = $5F;
Lcap = $59;
Rcap = $65;
Wcap = $77;
Dcap = $7B;

BEGIN
  WITH curEvent DO
    BEGIN
      IF fIMEvtTst THEN WRITELN('Key event..', curEvent.keycap,curEvent.shiftKey);
      IF (curEvent.keycap = Qcap) AND (curEvent.shiftKey)
        THEN BEGIN fQuit := TRUE; END;
      IF fSim
        THEN BEGIN
          IF (curEvent.keycap = Scap) AND fSimWtRec
            THEN SimRecord;
          IF (curEvent.keycap = periodCap) THEN SimStopped;
          IF (curEvent.keycap = Zcap) THEN SimStopped;
         END;
{$IFC IMDebug}
      IF (curEvent.keycap = Dcap) AND (not curEvent.shiftKey)
        THEN BEGIN
          debugMenus := NOT debugMenus;
          IF IMtst THEN
            WRITELN('Reloading tutor menus. debugMenus: ', debugMenus);
          ShowDebugMenus(debugMenus);
        END;
      IF NOT sDebug THEN EXIT(DoCodeKey);
      IF NOT fSim
        THEN BEGIN
          IF (curEvent.keycap = Scap) AND fSingleStep
            THEN fStepped := FALSE;
          IF (curEvent.keycap = Gcap) AND fWait
            THEN BEGIN
              ClearHint;
              WaitEnded;
              fStepped := FALSE;
             END;
         END;
      IF (curEvent.keycap = Rcap) AND (curEvent.shiftKey) THEN BEGIN
             IF IMtst THEN WRITELN('Recording Object Commands');
             fRObjects := TRUE;
             curObjTable := BldObjTable(deskObject);
             IF IMERTst THEN WRITELN('curObjTable is: ', ORD(curObjTable));
           END;
      IF (curEvent.keycap = Wcap) AND (curEvent.shiftKey) THEN BEGIN
             fStepped := FALSE;
             DoWindowCmd;
           END;
      IF (curEvent.keycap = Dcap) AND (curEvent.shiftKey) THEN BEGIN
             IF IMtst THEN WRITELN('Drawing desk contents');
             IFDrawDesk;
           END;
      IF (curEvent.keycap = Ocap) THEN BEGIN
           DoSound(startWave, dltWave, waveIter, wVol);
           DoSound(startWave+(dltWave*waveIter), -dltWave, waveIter, wVol);
          END;
{$ENDC }
    END;
END;


{$S imew }
PROCEDURE DoTextKey;
BEGIN
  WITH curEvent DO
    BEGIN
      IF fIMEvtTst THEN WRITELN('Text Key event..', curEvent.ascii);
      IF fInSelect THEN SelectComplete;
      IF fSelection
        THEN BEGIN
          IF fRKeyboard THEN AddKeyEvt(curEvtBuf, ORD(curEvent.ascii),
                               shiftKey, codeKey, appleKey, hndActiveFldr);
          fSelection :=
                 IMSChar(ActiveWSLink, curEvent.ascii, shiftKey, selTimeout);
          { IMSChar calls SetupUndo  -  SetupUndo(TRUE);  }
         END
        ELSE IF IMtst THEN
               WRITELN('No selection so typed char is ignored.');
    END;
END;


{$s imeini }
PROCEDURE SetupAlerts;
BEGIN
  IF IMtst THEN WRITELN('Beginning alertError =:', alertError, ' now reset to 0');
  alertError := 0;
  InitAlerts(5, 10000, IMHeap, NIL, NIL);
  IF IMtst THEN WRITELN('InitAlerts alertError =:', alertError);
  IF alertError > 0
    THEN BEGIN
       IF sDebug THEN WRITELN('InitAlerts alertError:', alertError);
       FailedInit;
     END;
  IF IMtst THEN WRITELN('Alert file: ', AlertFile);
  OpenPhraseFile(phraseRef, AlertFile);
  IF IMtst THEN WRITELN('OpenPhraseFile alertError =:', alertError);
  IF alertError > 0
    THEN BEGIN
       IF sDebug THEN WRITELN('OpenPhraseFile alertError:', alertError);
       FailedInit;
     END;
  IMAlert := ReadAlerts(phraseRef, 1);
  IF IMtst THEN WRITELN('ReadAlerts alertError =:', alertError);
  IF alertError > 0
    THEN BEGIN
       IF sDebug THEN WRITELN('ReadAlerts alertError:', alertError);
       FailedInit;
     END;
  IF alertError < 0
    THEN BEGIN
      Beepalert(2);
      WRITELN('ReadAlerts warning error ',alerterror:1);
    END;
END;


{$s imeini }
PROCEDURE InitLGFolders(myFilerWindow: WindowPtr);
VAR clsPos:    Point;
    openRect:  Rect;
BEGIN
  IF fTstFldrs THEN WRITELN('Creating LisaGuide folder.');
  SetPt(clsPos, 30, 60);
  SetRect(openRect, 10, 40, 600, 350);
  IF UnderFiler
    THEN BEGIN
      LGPort := myFilerWindow;
      TakeWindow(LGPort);
      MoveFolder(LGPort, 10, 40);
      FolderSize(LGPort, 590, 310, FALSE);
     END
    ELSE BEGIN
      LGPort := NewFolder(openRect, NameLisaGuide, FALSE,
                   filerFolder, fldrCount, My_ID, IFCloseSymbol(imKind), noIcon);
     END;
  hndLGFldr := BuildIMFolder(NameLisaGuide, FALSE, TRUE, TRUE, LGPort);
  LGObj := IFMakeObj(NameLisaGuide, imKind, nilKind, deskObject, clsPos,
                      hndLGFldr, openRect);
  hndLGFldr^^.fldrFObj := POINTER(ORD(LGObj));
  LGStr := NewFldrStream(hndLGFldr, 250, FALSE);
  LGWindow := hndLGFldr^^.fldrDispWindow;
  LastLGLine := NIL;
  LGPort := hndLGFldr^^.fldrPort;
  WITH LGPort^.PortRect DO
    LGPortWidth := botRight.h - topLeft.h;
  DefFldr := NameLisaGuide;
  hndDefFldr := hndLGFldr;
  IF IMtst THEN WRITELN('LisaGuide:', ORD(hndLGFldr),
                        ORD(hndLGFldr^), ORD(LGPort));
  IF IMtst THEN WRITELN('ScrapFldr:', ORD(hScrapFldr),
                        ORD(hScrapFldr^), ORD(scrapFolder));
  IF IMtst THEN WRITELN('AlertFldr:', ORD(hndAlertFldr),
                        ORD(hndAlertFldr^), ORD(alertFolder));
  AddFldrMenu(hndLGFldr, FilingMInfo, FALSE);
  AddFldrMenu(hndLGFldr, EditMInfo, FALSE);
  AddFldrMenu(hndLGFldr, TopicsMInfo, FALSE);
  AddFldrMenu(hndLGFldr, TutorMInfo, FALSE);
  AddFldrMenu(hndLGFldr, CtrlMInfo, FALSE);
  AddFldrMenu(hndLGFldr, FCtrlMInfo, FALSE);
  AddFldrMenu(hndLGFldr, FlagsMInfo, FALSE);
  AddFldrMenu(hndLGFldr, SimMInfo, FALSE);
  MakeFldrActive(deskObject^^.objWindow, whyNot);
  WaitEnded;
END;


   PROCEDURE DownShift(VAR s: Pathname);
   { converts all upper case chars in "s" to lower case }
   VAR i: INTEGER;
   BEGIN
   FOR i := 1 TO LENGTH(s) DO
      IF (s[i] <= 'Z') THEN
         IF (s[i] >= 'A') THEN s[i] := CHR(ORD(s[i]) + 32);
   END;


{$s imeini }
PROCEDURE IMInit;
VAR errnum:    TC;
    cError:    TC;
    excepName: T_Ex_Name;
    imPathName: Pathname;
    proc_info: procInfoRec;
    s:Tstr;
    copyright, theApple: STRING[1];
BEGIN

  IF logging THEN SysLog(108, NIL);
  IF IMtst THEN WRITELN ('In IMInit', ORD(@IMInit));
  TutorMInfo  := NIL;
  EditMInfo   := NIL;
  CtrlMInfo   := NIL;
  FCtrlMInfo  := NIL;
  FlagsMInfo  := NIL;
  SimMInfo    := NIL;
  TopicsMInfo := NIL;
  FilingMInfo := NIL;
  ViewMInfo   := NIL;
  FlrEditMInfo:= NIL;
  FlrDiskMInfo:= NIL;
  hndLGFldr   := NIL;

  PIMFS := NIL;
  feStarted := FALSE;
  qdStarted := FALSE;

  LisaPrefix := '';
  imToolName := ToolID;

  UnderFiler := FALSE;

  fSingleStep := FALSE;
  fStepped := TRUE;

{$IFC IMDebug}
  fAskFlags := FALSE;
  fAskDemo :=  FALSE;
  demoFlag :=  TRUE;
{$ENDC }
  InitTraces;

  IF logging THEN SysLog(109, NIL);
  excepName := 'SYS_TERMINATE';
  Declare_Excep_Hdl (cError, excepName, @LastWishes);
  IF cError <> 0 THEN BEGIN
     WRITELN (My_Id:1,' Declar_Excep_Hdl error: ',cError);
     ImDying;
     HALT;
   END;

  fQuit := FALSE;
  nxShellName := FilerShell;
  nxShellCode := selectShell;

  Info_Process(errnum, MY_ID, proc_info);
  IF errnum > 0 THEN
     BEGIN
     WRITELN('InfoProcess(my_Id) error = ',errnum);
     HALT;
     END;
  DownShift(proc_info.progPathname);
  imPathName := proc_info.progPathname; (* name of our object file: '-vol-{Tn}' *)
  imPathName := COPY(imPathName,2,LENGTH(imPathName)-1);
  imVolName := COPY(imPathName, 1, POS('-',imPathName)-1);
  Info_Process(errnum, proc_info.father_id, proc_info);
  DownShift(proc_info.progPathname);
  UnderFiler := (Pos('desktop.shell', proc_info.progPathname) <> 0);

  LessonDirFile := CONCAT('-', imVolName, '-', imToolName, CLessonDirFile);
  TutorMFile    := CONCAT('-', imVolName, '-', imToolName, CTutorMFile);
  TopicMFile    := CONCAT('-', imVolName, '-', imToolName, CTopicMFile);
  FilerMFile    := CONCAT('-', imVolName, '-', imToolName, CFilerMFile);
  AlertFile     := CONCAT('-', imVolName, '-', imToolName, CAlertFile);
  SetupFile     := CONCAT('-', imVolName, '-', imToolName, CSetupFile);

  IF IMtst  { repeated below - only here for pre-compiled imtst }
    THEN BEGIN
      WRITELN('InfoProcess(father_id) error = ',errnum,
              ' progPath:', proc_info.progPathname);
      IF Pos('system.shell', proc_info.progPathname) > 0
         THEN WRITELN('Started by shell')
         ELSE WRITELN('Started by: ', proc_info.progPathname);
     END;

  IF logging THEN SysLog(110, NIL);
  InitGraf(@thePort);
  qdStarted := TRUE;

IF UnderFiler
  THEN BEGIN
    IF IMtst THEN WRITELN('Started by the Filer');
    OpenWM;
    SetPort(DeskPort);
   END
  ELSE BEGIN
    IF IMtst THEN WRITELN('Started by the OS');
    InitWM;
   END;

  CursorInit;
  CursorTracking(TRUE);
  BusyDelay(0);
  SetFadeDelay(300000);  { set to 5 mins for init - dont blank on new users }
  MoveConsole(errnum, alscreen);
  SetScreenKbd(PriScrn);


  InitWmlSb;

  { Initialize the units of the interactive manual }

  IF logging THEN SysLog(111, NIL);
  IMCoreInit;

  SetLnIdx(0, FALSE);

{$IFC IMDebug}
  IMSetup;
  AskDemoTraces;
  debugMenus := NOT demoFlag;
{$ENDC }

  IF IMtst THEN
    BEGIN
      WRITELN(' imPathName is ', imPathName, 'imVolName: ', imVolName);
      WRITELN('My procID:', proc_info.global_id,
              '  MY_ID:', MY_ID, ' father_id:', proc_info.father_id);
      WRITELN('LessonDirFile = ', LessonDirFile);
      WRITELN('TutorMFile = ', TutorMFile);
      WRITELN('TopicMFile = ', TopicMFile);
      WRITELN('FilerMFile = ', FilerMFile);
      WRITELN('AlertFile = ',  AlertFile);
      WRITELN('SetupFile = ',  SetupFile);
      WRITELN('InfoProcess(father_id) error = ',errnum,
              ' progPath:', proc_info.progPathname);
      IF Pos('system.shell', proc_info.progPathname) > 0
         THEN WRITELN('Started by shell')
         ELSE WRITELN('Started by: ', proc_info.progPathname);
     END;

  IMFldrsInit;
  SetupAlerts;

  theApple := ' ';
  copyright := ' ';
  theApple[1] := CHR(ccApple);
  copyright[1] := CHR(ccCopy);
  IMAlertUp;
  ParamAlert(imVersion, copyright, theApple);
  WaitAlert(imAlert, 412);

  IF logging THEN SysLog(114, NIL);
  s:='xAx x9x x$x x%x x.9 x.% 9,9 A''A';
  FEInit(StrHeap,@s, errnum);
  IF errnum <> 0 THEN WRITELN('Field editor init error: ', errnum);
  IF errnum > 0 THEN FailedInit;
  feStarted := TRUE;

  IF logging THEN SysLog(112, NIL);
  IFInit(FilerMFile);

  ReadTutorMenus(debugMenus);  {menus must be set after calling IFInit}
  InitSim;
  SetSimPrefix(CONCAT('-', imVolName, '-', imToolName));

  hndAlertFldr := BuildIMFolder('Alert', FALSE, TRUE, FALSE,
                                alertFolder);
  HintStr := NewFldrStream(hndAlertFldr, 30, FALSE);

  IF logging THEN SysLog(113, NIL);
  IMIntrpInit;
  IF logging THEN SysLog(115, NIL);
  IMInitScrap;

  IF logging THEN SysLog(116, NIL);
  IF NOT IMScrInit(LessonDirFile) THEN FailedInit;

  IF logging THEN SysLog(117, NIL);
{$IFC IMDebug }
  ChkFlagMenu;
  ChkCtrlMenu;
  fPlayXFile := FALSE;
{$ENDC }

  fCheckTime := FALSE;
  waitTimeout := -1;
  selTimeout := -1;
  timeoutTime := 0;

  SetRect(bigNbrhood, -30000, -30000, 30000, 30000);
  curNbrhood := bigNbrhood;
  timeoutTime := -1;

  {Flags for finding and maintaining info on double and triple Clicks}

  FndMove := FALSE;

  fWasWaiting := FALSE;

  fSelection := FALSE;
  fInSelect := FALSE;
  fButtonUp := TRUE;
  clickTime := 0;
  clickCount := 0;
  SetPt(clickLoc, -10, -10);
  ClearSelection;

  SetRect(crsHideRect, 0, 0, 0, 0);
  crsHidden := FALSE;

  UndoMItem := iUndo;
  UndoEnabled := FALSE;

  hintLeft := 20;
  hintTop := 20;
  hintWidth := 650;
  hintHeight := 100;

  fWait := TRUE;

  dialogHt:=0;

  PrevExzPos := 0;
  LastExzPos := 0;
  SetAbleItem(FCtrlMInfo, iFLstExz, FALSE);
  SetAbleItem(FCtrlMInfo, iFPrvExz, FALSE);

  activeContainer := FALSE;

  SetupSound;

  IF NOT UnderFiler THEN  InitLGFolders(NIL);  { got to make my own folder }
END;


{$s imec }
PROCEDURE DoCommandKey;
{ an Apple key was pressed. Do appropriate command if any }
CONST perCap = $94;
VAR minTime: LongInt;
BEGIN
  IF IMTst THEN
   WRITELN('Command key: ascii:', curEvent.ascii, ' kcap: ', curEvent.keyCap);

  MenuKey(curEvent.ascii,theMenu,theItem);
  IF theMenu = 0 THEN IFCommandKey
    ELSE BEGIN
      HiLiteMenu(theMenu);
      minTime:=Time+5;  { 1/20th of a second }
      TutorMenuCommand(theMenu,theItem);
      REPEAT UNTIL Time > minTime;   { make sure the hilite shows }
      HiLiteMenu(0);
     END;
END;


{$s imeh }
PROCEDURE ResetTimeouts;
VAR dt,selT: TL;
BEGIN
  IF cDebug AND fIMEvtTst THEN WRITELN('Reset Timeout');
  selT := selTimeout;
  dt := -1;
  IF waitTimeout <> -1 THEN dt := waitTimeout;
  IF selT <> -1
    THEN if dt = -1
      THEN dt := selT
      ELSE IF selT < dt THEN dt := selT;
  IF dt <> -1
    THEN BEGIN
      fCheckTime := TRUE;
      timeoutTime := TIME + dt;
     END
    ELSE fCheckTime := FALSE;
END;


{$s imeh }
PROCEDURE ResetNbrhood;
VAR mPt: Point;
BEGIN
  { IF IMTst THEN WRITELN('Reset Nbrhood');}
  IF fWMouseMoved
    THEN BEGIN
      IF IMtst THEN BEGIN
         SetPort(LGPort);
         GetMouse(mPt);
         WRITELN('reset nbrhood. port:', ORD(thePort));
         WRITE('event.where: '); PrintPoint(curEvent.where); WRITELN;
         WRITE('cur mouse pt: '); PrintPoint(mPt); WRITELN;
        END;
      SetPointNbrhd(mPt, curNbrhood);
      IF IMtst  AND fIMEvtTst
        THEN BEGIN WRITELN('curNbrhood:  '); PrintRect(curNbrhood); END;
     END
    ELSE curNbrhood := bigNbrhood;
END;


{$s imew }
PROCEDURE SelButton(wsLink: THWSLink; hitLine: THImsLine; linePt: Point;
                    VAR clickCt: TC);
VAR mDragPt, hidePt: Point;
  shiftClick: TF;
  setAdjust: TF;
BEGIN
    { check for shift-mouse down }
  IF IMtst THEN
    WRITELN('SelButton for line: ', ORD(hitLine), ' clickCt:', clickCt);
  IF curEvent.shiftKey
    THEN BEGIN
      IF fIMEvtTst THEN
        WRITELN('ShiftSelect - fInSelect: ', fInSelect,
                ' fSelection: ', fSelection);
         shiftClick := TRUE;
         setAdjust  := TRUE;
      { fall through to DragSelect }
     END
    ELSE
      WITH curEvent DO BEGIN
        shiftClick := FALSE;
        hidePt := where;
        IF (FndMove OR (NOT fInSelect)) THEN
          BEGIN
            clickCt := 1;
            FndMove := FALSE;
           END;
        IF clickCt = 1
          THEN BEGIN { single click }
            IF fIMEvtTst THEN WRITELN;
            SelectMouseLoc :=  where;
            fInSelect := IMSSelectLine(wsLink, hitline, where, linePt,
                                       selNbrhood, selTimeout);
            IF IMtst THEN WRITELN('fInSelect set to ', fInSelect,
                                  ' selTimeout: ', selTimeout);
           END
          ELSE IF clickCt = 2
            THEN BEGIN  {Double click found }
              IF fIMEvtTst THEN WRITE('Double Click ');
              fInSelect :=
                 IMSDoubleClick(wsLink, where, selNbrhood, selTimeout);
              IF IMtst THEN WRITELN('fInSelect set to ', fInSelect);
                { IF IMtst THEN                                              }
                {   BEGIN WRITE('selNbrhood: '); PrintRect(selNbrhood); END; }
             END
            ELSE IF clickCt = 3
              THEN BEGIN  {Triple click found }
                IF fIMEvtTst THEN WRITE ('Triple Click');
                clickCt := 0; { go round again after this }
                fInSelect :=
                    IMSTripleClick(wsLink, selNbrhood, selTimeout);
                IF IMtst THEN WRITELN('fInSelect set to ', fInSelect);
               END;
     END;  { of non-shift click }

   IF fInSelect OR fSelection THEN
     WHILE StillDown OR shiftClick DO
       BEGIN
         GetMouse (mDragPt);
         hidePt := mDragPt;
         shiftClick := FALSE;
         IF NOT PtInRect (mDragPt, selNbrhood)
           THEN BEGIN
                 (*
                   writeln ('Mouse move detected; point is ', mDragPt.h,
                           mDragPt.v);
                   writeln ('Neighborhood: ', selNbrhood.left,
                      selNbrhood.top, selNbrhood.right, selNbrhood.bottom);
                 *)
             FndMove := TRUE;
             IF setAdjust
               THEN BEGIN
                 fInSelect := TRUE;
                 fSelection := FALSE;
                 fAdjustSel := TRUE;
                END;
             IMSDragSelect(ActiveWSLink, mDragPt, selNbrhood);
            END;
       END; { of tracking the mouse while the button is down }
  IF fInSelect OR fSelection
    THEN BEGIN
      crsHidden := TRUE;
      SetRect(crsHideRect, hidePt.h-crsHideH, hidePt.v-crsHideV,
                           hidePt.h+crsHideH, hidePt.v+crsHideV);
      SetStdCursor(icrsHidden);
     END;
END;


{$S imew }
PROCEDURE HitBtnLine(wsLink: THWSLink; hitLine: THImsLine;
                     hitPt, linePt: Point; VAR clickCt: TC);
VAR btnPos: Point;
    fPressed: TF;
BEGIN
  IF hitLine^^.lType = CBtnLine
    THEN BEGIN
      SetPt(btnPos, linePt.h+hitLine^^.btn.pBtnHPos, linePt.v);
      IF TestIMButton(hitLine^^.btn.pBtnIdx, btnPos, hitPt, fPressed)
        THEN BEGIN
          IF fPressed THEN BEGIN
             DoIMButton(hitLine^^.btn.pBtnIdx);
             clickCt := 0;
             PressBtn(hitLine^^.btn.pBtnIdx, FALSE, btnPos);
            END;
        END;
     END;
END;


{$S imec }
PROCEDURE AddNewSelLine(imFldr: THFldrInfo; wsLink: THWSLink; hitWPt: Point);
VAR newLine: THImsLine;
    linePt: Point;
    txtChar: CHAR;
BEGIN
  IF wsLink^^.kStream^^.sCanAddLines
    THEN IF hitWPt.v+wsLink^^.kLPOffset.v > StreamHt(wsLink^^.kStream)
      THEN BEGIN
        txtChar := ' ';
        newLine := AddNewTextLine(wsLink^^.kStream, @txtChar, 0, TRUE);
        DrawFldrContents(imFldr);
        IF LnWindowPos(wsLink, newLine, linePt)
          THEN BEGIN
            PortPt(wsLink^^.kWindow, linePt);
            fSelection := SelectAtPos(wsLink, newLine, linePt,
                                      0, 0, selTimeout);
            SelectComplete;  { not the best way - see IMSSelectLine above }
            IF IMtst THEN BEGIN
               WRITELN(' Selection set for added line at:',
                       linePt.h, linePt.v);
               WRITELN('   selTimeout:', selTimeout, '  fSelection:',
                       fSelection);
              END;
           END
          ELSE IF IMtst THEN WRITELN('Cant find added line');
       END;
END;


{$S imew }
PROCEDURE StreamHit(imFldr: THFldrInfo; VAR clickCt: TC);
VAR scrollEvent: TC;
    wsLink: THWSLink;
    hitLine: THImsLine;
    wPt, linePt: Point;
    ffam: TC;
BEGIN
  IF cDebug AND IMtst THEN WRITELN('StreamHit');
  IF imFldr = NIL
    THEN BEGIN
      IF cDebug THEN
        IF IMtst THEN WRITELN('Stream button in Nil folder');
      { EXIT(StreamHit);}
      imFldr := AttachIMFldr(activeObject, TRUE, TRUE, TRUE, 50);
     END;
  IF imFldr^^.fldrDispWindow = NIL
    THEN BEGIN
      IF cDebug THEN
        IF IMtst THEN WRITELN('Stream button in folder with no window');
      EXIT(StreamHit);
     END;
  IF (TstScroll(curEvent.who,curEvent.where) = 0)
    { scroll stuff done by TstScroll otherwise do this  }
    THEN BEGIN
      wsLink := imFldr^^.fldrDispWindow^^.wLink;
      IF wsLink = NIL
        THEN BEGIN
          IF cDebug THEN IF IMtst
             THEN WRITELN('Stream button in window with no stream');
          EXIT(StreamHit);
         END;
      BtnDwnFldr := imFldr;
      SetPort(wsLink^^.kWindow^^.wPort);
      wPt := curEvent.where;
      WindPt(wsLink^^.kWindow, wPt);
      hitLine := LineAtPos(wsLink, wPt, linePt);
      IF hitLine = NIL
        THEN BEGIN
          IF cDebug THEN IF IMtst THEN
            WRITELN('StreamHit - no line at pos:', wPt.h, wPt.v);
          IF wsLink^^.kStream^^.sCanAddLines
            THEN AddNewSelLine(imFldr, wsLink, wPt);
          EXIT(StreamHit);
         END;
      PortPt(wsLink^^.kWindow, linePt);
      IF hitLine^^.lType = CBtnLine
        THEN BEGIN
          HitBtnLine(wsLink, hitLine, curEvent.where, linePt, clickCt);
         END
        ELSE BEGIN
          IF hitLine^^.lType = CTxtLine
            THEN BEGIN
              ffam := FontFam(hitLine^^.txt.tFontIdx);
              IF ffam = systext THEN EXIT(StreamHit); { Dont select Systext lines }
              IF ffam = imgraf THEN EXIT(StreamHit); { Dont select graphics lines }
             END;
          linePt.v := linePt.v - 1;
          IF wsLink^^.kStream^^.sCanSelect
            THEN SelButton(wsLink, hitLine, linePt, clickCt);
         END;
    END;
END;


{$S imec }
PROCEDURE MouseMoved(mPt: Point);
VAR ctime: LongInt;
BEGIN
  IF IMTst OR fIMEvtTst THEN WRITELN('MouseMoved event');
  IF IMTst THEN BEGIN
    WRITE('new mouse pt:'); PrintPoint(mPt); WRITELN('in port:', ORD(thePort));
    END;
  IF fWMouseMoved
    THEN BEGIN
      IF CalcMouseMoves(WaitMouseLoc, mPt)
         THEN BEGIN
           IF IMTst THEN WRITELN('Mouse has moved.');
           WaitEnded;
          END;
     END
    ELSE BEGIN
      IF sDebug THEN WRITELN('Unexplained mouse moved event.');
      Brk(743);
     END;
  ResetNbrhood;
END;


{$S imew }
PROCEDURE Timeout;
LABEL 900;
VAR ctime: TL;
    exp: TF;
BEGIN
  ctime := TIME;
  exp := FALSE;
  IF fIMEvtTst THEN WRITELN('Timeout event..');
  IF (fWTimeout OR fPause)
    THEN BEGIN
      exp := TRUE;
      IF fIMEvtTst THEN WRITELN('Wait/Pause timeout.');
      IF  (ctime > toWaitEndTime)
        THEN BEGIN
          WaitEnded;
          fTimeout := TRUE;
          IF IMTst THEN WRITELN('timeout ended at:', ctime);
          waitTimeout := -1;
          GOTO 900;
         END
       ELSE BEGIN
          IF fIMEvtTst
            THEN WRITELN('timeout continues for:', (toWaitEndTime - ctime));
        END;
     END;
  IF (selTimeout <> -1) AND (fSelection OR fInSelect)
    THEN BEGIN
      exp := TRUE;
      IF fIMEvtTst THEN WRITELN('Selection timeout.');
      IMSTimeout(ActiveWSLink, selTimeout);
      IF fInSelect THEN SelectComplete;
      GOTO 900;
     END;
  IF cDebug THEN
    IF (NOT exp) THEN
      BEGIN IF sDebug THEN WRITELN('unexplained timeout:'); BRK(774); END;
900:
  ResetTimeouts;
END;


{$S imec }
PROCEDURE DoAlertButton(btnPt: Point);
VAR pbutn: TButn;
BEGIN
  pbutn := 6;
  IF ButnPushed(GoAwayButn, GoAwayButn, pbutn, btnPt)
    THEN BEGIN
      IF pbutn <> GoAwayButn
        THEN BEGIN
          IF sDebug THEN WRITELN('pushed strange alert button. pbutn =', pbutn)
         END
        ELSE BEGIN
          IF IMTst then WRITELN('Pushed alert button: ', pbutn);
          IF HintDisplayed THEN ClearHint
            ELSE BEGIN
              IF sDebug THEN
                WRITELN('Alert button pushed when hint not displayed!!!');
              Brk(984);
             END;
         END;
     END;
END;


PROCEDURE WhyDiskEvent;
{ handles disk events and power button }
BEGIN
IF IMtst THEN WRITELN('WhyDiskEvent: ', curEvent.keyCap:1);

CASE curEvent.keyCap OF
   powerCode :  IF curEvent.codeKey OR curEvent.appleKey
                   THEN SetShutDown(selectShell)
                   ELSE SetShutDown(powerOff);
   disk1InCode :
      BEGIN IF IMtst THEN WRITELN('upper diskette inserted'); END;
   disk1OutCode :
      IF imVolName = 'upper'
        THEN SetShutDown(newShell)
        ELSE EjectDisk('upper');
   disk2InCode :
      BEGIN IF IMtst THEN WRITELN('lower diskette inserted'); END;
   disk2OutCode :
      IF imVolName = 'lower'
        THEN SetShutDown(newShell)
        ELSE EjectDisk('lower');
   mouseCode:
      BEGIN
      IF IMTst THEN WRITE('Mouse ');  { suppress writelns -gb }
      IF ORD(curEvent.ascii) > 0
        THEN BEGIN IF IMTst THEN WRITELN('unplugged.'); END
        ELSE BEGIN IF IMTst THEN WRITELN('plugged in.'); END;
      END;
   OTHERWISE
      IF sDebug OR IMTst THEN
        WRITELN('Unknown "disk" command = ', curEvent.keyCap:1);
   END;
END;


{$s imeh }
PROCEDURE DoTheEvent;
VAR i: INTEGER;
    curPort: GrafPtr;
    wPt: Point;
  PROCEDURE DoDownButton;
  VAR dh, dv: TC;
      globalWhere: Point;
  BEGIN
    IF fIMEvtTst THEN WRITE('MouseDown event..');
    IF logging THEN SysILog(104, clickLoc.h, clickLoc.v);
    globalWhere := curEvent.where;
    LocalToGlobal(globalWhere);
    dh := ABS(globalWhere.h-clickLoc.h);
    dv := ABS(globalWhere.v-clickLoc.v);
    IF (curEvent.when < clickTime) AND (dh < 3) AND (dv < 2)
      THEN clickCount:=clickCount+1
      ELSE clickCount:=1;
    clickLoc:=globalWhere;

    IF curEvent.who = alertFolder THEN
      BEGIN ClickCount := 0; DoAlertButton(curEvent.where); END

    ELSE IF curEvent.who = dialogFolder THEN
      BEGIN
      END

    ELSE
       BEGIN
        fButton := TRUE;
        StreamHit(hndActiveFldr, clickCount);
      END;
  END;

  PROCEDURE DoUpButton;
  BEGIN
    IF fIMEvtTst THEN WRITELN('MouseUp event.. ');
    fButtonUp := TRUE;
    clickTime := curEvent.when + CSeqTime;
    IF fWButton
      THEN BEGIN
        WaitEnded;
        fButton := TRUE;
        IF IMtst THEN WRITELN('fButton set to TRUE');
       END
      ELSE BEGIN
        IF fInSelect THEN
           fInSelect := IMSButtonUp
                 (BtnDwnFldr^^.fldrDispWindow^^.wLink, selTimeout);
       END;
  END;

  PROCEDURE DoFilerEvent;
  VAR cErr:      TC;
      flrExt:    FilerExt;
  BEGIN
    GetAddParams (cErr, curEvent, flrExt);

    IF fIMEvtTst THEN WITH flrExt DO
       WRITELN('got filer event, filerOp:', ORD(theFlrOp), '  path:', thePrefix,
                ' theDF:', theDF {, ' bytesReqd:', bytesReqd});
    CASE flrExt.theFlrOp OF

       fcNone:
          BEGIN
          IF fIMEvtTst THEN writeln('fcNone filer event');
          HoldIt(sDebug);
          InitLGFolders(curEvent.who);
          {  need this? SetPort(curEvent.who);
          {  eraserect(curEvent.who^.portrect); }
          {TellFiler (cErr, docOpened, allOK, LGPort); }
          END;

       fcTerminate:
          BEGIN
          IF fIMEvtTst THEN writeln('fcTerminate filer event');
          ImDying;
          fQuit := TRUE;
          END;

       {I'm a tool: No Doc! Fake OK response!}
       fcResume:
          BEGIN
          IF fIMEvtTst THEN writeln('fcResume filer event');
          IF sDebug THEN
            WRITELN('Got Doc event in LisaGuide tool', ORD(flrExt.theFlrOp));
          Holdit(sDebug);
          InitLGFolders(curEvent.who);
          { TellFiler (cErr, docOpened, allOK, LGPort); }
          END;

       fcClose, fcSuspend, fcShred:
          BEGIN
          IF fIMEvtTst THEN writeln('fcClose, fcSuspend or fcShred filer event');
          IF sDebug THEN
            WRITELN('Got Doc event in LisaGuide tool', ORD(flrExt.theFlrOp));
          Holdit(sDebug);
          TellFiler (cErr, docClosd, allOK, LGPort);
          END;

       fcCopy, fcPut:
          BEGIN
          IF fIMEvtTst THEN writeln('fcCopy or fcPut filer event');
          IF sDebug THEN
            WRITELN('Got Doc event in LisaGuide tool', ORD(flrExt.theFlrOp));
          Holdit(sDebug);
          TellFiler (cErr, docXfered, allOK, LGPort);
          END;

         END;
  END;


BEGIN
  SetPort(curEvent.who);

  IF NOT SkipEvent THEN
    CASE curEvent.what OF

      buttonUp:
        BEGIN
          IF curEvent.who <> menuFolder THEN BEGIN
            IF btnSound > noSound
              THEN IF fSim OR (btnSound >= yesSound)
                THEN DoSound(msUWave, -msDltWave, msWaveIter, msVol);
            IF activeContainer
              THEN IFBtnUp
              ELSE DoUpButton;
           END;
        END;

      buttonDown:
        BEGIN
          IF btnSound > noSound
            THEN IF fSim OR (btnSound >= yesSound)
              THEN DoSound(msDWave, msDltWave, msWaveIter, msVol);
          IF curEvent.who = menuFolder THEN
            BEGIN
             IF fIMEvtTst THEN WRITELN('Mouse down in menu');
             clickCount := 0;
             IFAdjustMenus;
             MenuSelect (curEvent.where, theMenu, theItem);
             IF btnSound > noSound
               THEN IF fSim OR (btnSound >= yesSound)
                 THEN DoSound(msUWave, -msDltWave, msWaveIter, msVol);
             IF fIMEvtTst THEN WRITELN('Menu command event: ', theMenu, theItem);
             TutorMenuCommand(theMenu,theItem);  { do IM fldr menu }
             HiLiteMenu(0);  { un-highlight the menu title }
            END

          ELSE IF activeContainer
            THEN IFButtonDown
            ELSE DoDownButton;
        END;

      keyDown:
        BEGIN
          IF fIMEvtTst THEN WRITELN('Got event type keyDown            ');
          IF curEvent.appleKey THEN DoCommandKey
          ELSE IF curEvent.codeKey THEN DoCodeKey
          ELSE IF activeContainer THEN IFTextKey ELSE DoTextKey;
        END;


      folderDeactivate:
        BEGIN
          IF fIMEvtTst THEN WRITELN('Got event type folder Deactivate  ');
          IF logging THEN SysLog(105, NIL);
          GiveControl(curEvent);

          IF hndActiveFldr <> NIL
            THEN BEGIN
              SaveFldrState(hndActiveFldr);
             END;
          IFDeActiveate;
          hndActiveFldr := NIL;
          activePort := NIL;
          ActiveWSLink := NIL;
          activeContainer := FALSE;
          ClearSelection;
          { ClearMenuBar; }
        END;


      folderActivate:
        BEGIN
          IF curEvent.why = whyClick
            THEN IF btnSound > noSound
              THEN IF fSim OR (btnSound >= yesSound)
                THEN DoSound(msDWave, msDltWave, msWaveIter, msVol);
          IF logging THEN SysLog(106, NIL);
          IF fImEvtTst
            THEN WRITELN('Got event type folderActiveate for folder:',
                          ORD(curEvent.who));
          TakeControl(curEvent, FALSE, FALSE);

          IF curEvent.why = whyClick
            THEN IF btnSound > noSound
              THEN IF fSim OR (btnSound >= yesSound)
                THEN DoSound(msUWave, -msDltWave, msWaveIter, msVol);
          activePort := curEvent.who;
          hndActiveFldr := PortFolder(curEvent.who);
          ActiveWSLink := NIL;
          IF hndActiveFldr <> NIL
            THEN BEGIN
              BrokenFldrState(hndActiveFldr);
              IF hndActiveFldr^^.fldrDispWindow <> NIL
                THEN ActiveWSLink := hndActiveFldr^^.fldrDispWindow^^.wLink;
             END;
          IF IMTst THEN
             WRITELN('Activating folder: who = ', ORD(curEvent.who),
                     ' folder:', ORD(hndActiveFldr),
                     ' wsLink:', ORD(ActiveWSLink));
          IFActivate;
          clickCount := 0;
          IF IFIsContainer(activeObject)
            THEN activeContainer := TRUE
            ELSE IF (hndActiveFldr <> NIL)
                THEN BEGIN
                  LoadMenuBar(hndActiveFldr);
                  activeContainer := FALSE;
                  IF curEvent.why = whyClick
                    THEN IF activeWSLink <> NIL
                      THEN BEGIN
                        wPt := curEvent.Where;
                        WindPt(ActiveWSLink^^.kWindow, wPt);
                        IF OverIMButton(activeWSLink, wPt) <> NIL
                          THEN BEGIN
                            DoDownButton;
                            DoUpButton;
                           END;
                       END;
                 END;
        END;


      diskEvent:
        BEGIN
          IF fImEvtTst
            THEN WRITELN ('Got event type diskEvent ', ' code = ',
                          curEvent.keyCap:4, ' for folder:', ORD(curEvent.who));
          WhyDiskEvent;
        END;


      folderMoved:
        BEGIN
          IF fIMEvtTst THEN WRITELN('Got event type folderMoved       ');
          IFFolderMoved(curEvent.who);
        END;


      abortEvent:
        BEGIN
          IF fIMEvtTst THEN WRITELN('Got event type abortEvent       ');
          fQuit := TRUE;
        END;


      folderUpdate:
        BEGIN
          IF logging THEN SysLog(107, NIL);
          IF fIMEvtTst THEN WRITELN('Got event type folderUpdate       ');
          BeginUpdate(curEvent.who);
          IF curEvent.who = alertFolder
            THEN DrawABoxContents
            ELSE DrawContents(curEvent.who);
          EndUpdate(curEvent.who);
        END;

      filerEvent:  DoFilerEvent;

    END;  { case curEvent }

END;   { of DoTheEvent }


{$s imeh }
PROCEDURE EventLoop;
LABEL 500;
VAR mPt: Point;
BEGIN
  REPEAT
    WHILE NOT ImActive AND NOT fQuit DO
      BEGIN
        GetEvent(curEvent);
        IF fIMEvtTst THEN WITH curEvent DO
             WRITELN('got inactive event, who:', ORD(who), '  what:', what,
                     ' when:', when, ' where:', where.h, where.v);
        DoTheEvent;
      END;

    WHILE ImActive AND NOT fQuit DO
      BEGIN
        IF fSim THEN BEGIN
          IF fSimRunning AND ((simMode = CsimNormal) OR
                              NOT(playFlag OR recordFlag))
           THEN SimStopped
          ELSE IF fSimWtPB THEN SimPlayback;
         END;
        IF EventAvail THEN
            BEGIN
              GetEvent(curEvent);
              IF fIMEvtTst THEN WITH curEvent DO
                   WRITELN('got active event, who:', ORD(who), '  what:', what,
                           ' when:', when, ' where:', where.h, where.v);
              DoTheEvent;
              ResetTimeouts;
            END
          ELSE BEGIN
            IF fWMouseMoved
              THEN BEGIN
                SetPort(LGPort);
                GetMouse(mPt);
   IF IMtst THEN BEGIN WRITELN('check mouse move at:');
      PrintPoint(mPt); WRITELN(' in port:', ORD(thePort));
     END;
                IF NOT PtInRect(mPt, curNbrhood) THEN MouseMoved(mPt);
               END;
            IF activeContainer
              THEN IFNoEvent
              ELSE IF hndActiveFldr <> NIL
                         THEN UpdateIMCursor;
            IF fCheckTime
              THEN IF (Time > timeoutTime) THEN
              BEGIN
                IF fIMEvtTst THEN
                  WRITELN('Doing Timeout. timeoutTime=', timeoutTime);
                Timeout;
              END;

       { quick fix to make compilation run right through regardless of fWait }
            IF fICompile THEN
               BEGIN
               IF NOT (fSingleStep AND fStepped) THEN
                   BEGIN
                   DoTutorCommand;
                   IF fWait OR fPause THEN
                       BEGIN
                       WaitBegins;
                       WaitEnded;
                       GOTO 500;
                       END;
                   END;
               END
            ELSE {end of fICompile stuff }
            IF ((NOT fWait) AND (NOT fPause)
                AND (NOT HintDisplayed) AND (NOT fSim))
               OR kbdCommand
              THEN BEGIN
                IF NOT (fSingleStep AND fStepped)
                  THEN BEGIN
                    fWasWaiting := fWait;
                    DoTutorCommand;
                    IF (NOT fWasWaiting) AND (fWait OR fPause) THEN WaitBegins;
                    ResetNbrhood;
                    ResetTimeouts;
                    GOTO 500;
                   END;
               END;
             LetOthersRun;
           END;
      500:
      END; { while }
  UNTIL fQuit;
END;

{$s       }

BEGIN {***************************** main ***************************** }

{$IFC IMDebug }
  IMTst := FALSE;
{$ENDC }
  IMInit;
  SetHeap(IMHeap);
  { ShowCursor; }
  EventLoop;
  SetShutDown(newShell);
999:
IF IMtst THEN WRITELN('999 Halt');
  fQuit := TRUE;
HALT;

END.



