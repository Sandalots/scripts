{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}


{$s imscc }
{$r- }

UNIT IMScript;

INTERFACE

USES {$U HwInt        }  HwInt,
     {$U libos/SysCall      }  SysCall,
     {$U libos/PSysCall     }  PSysCall,
     {$U UnitStd.obj  }  UnitStd,
     {$U UnitHz.obj   }  UnitHz,
     {$U Storage.obj  }  Storage,
     {$U QuickDraw    }  QuickDraw,
     {$U FontMgr.obj  }  FontMgr,
     {$U PmDecl       }  PmDecl,
     {$U PMM          }  PMM,
     {$U FMgrUtil.obj }  FmgrUtil,
     {$U WM.Events    }  Events,
     {$U WM.Windows   }  Windows,
     {$U WM.Folders   }  Folders,
     {$U WM.Menus     }  Menus,
     {$U WMLStd       }  WMLStd,
     {$U WMLSB        }  WMLSb,
     {$U WMLGrow      }  WMLGrow,
     {$U AlertMgr.obj }  AlertMgr,
     {$U dbenv.obj    }  dbenv,
     {$U DBdecl1      }  DBdecl1,
     {$U fedec.obj    }  fedec,
     {$U fld.obj      }  FieldEdit,
     {$U apim/UnitImf.obj  }  UnitImf,
     {$U apim/imcore.obj   }  IMCore,
     {$U apim/IMMenus.obj  }  IMMenus,
     {$U apim/IMStream.obj }  IMStream,
     {$U apim/IMSEdit.obj  }  IMSEdit,
     {$U apim/IMFolders.obj}  IMFolders,
     {$U apim/TFGlobals    }  IFGlobals,  { Common routines & declarations }
     {$U apim/TFEntry      }  IFEntry,
     {$U apim/TCatalog     }  IFCatalog,
     {$U apim/TFiler       }  TFiler;     { TeachingFiler unit }


CONST

  {$IFC NOT IMCompile }
  fICompile = FALSE;
  fCompTrace = FALSE;
  {$ENDC }
  cWordArraySize = 3000;
  cMaxSpaces = 1;

  CUserVars = 10;
  CExzVars = 10;
  CLessonVars = 10;
  CGlobalVars = 10;

  CLessonLocs = 10;
  CExzLocs = 20;
  CBlockLocs = 20;
  CTagLocs = 10;

  cWBSize = 10000;
  CLocSize = 9;


TYPE
     THScrLineBuf = ^TPScrLineBuf;
     TPScrLineBuf = ^TScrLineBuf;
     TScrLineBuf = RECORD
                        iScrLine: Str255;
                        iBufCr: TF;
                        nextLineBuf: THScrLineBuf;
                      END;
     THScrIBuf = ^TPScrIBuf;
     TPScrIBuf = ^TScrIBuf;
     TScrIBuf = RECORD
                     oScrPtr: TRgch;
                     oScrPos, oScrLineLen: TC;
                     oScrBuf: Str255;
                     iScrLBuf: THScrLineBuf;
                     iBufCr: TF;
                     nextIBuf: THScrIBuf;
                   END;



     {Type definitions for lookup table records.}
     TVarType = (TVChar, TVInt, TVStr, TVBool, tvdata);
     TPVarRec = ^TVarRec;
     TVarRec = RECORD
               vKey: TKeyStr;
               vType: TVarType;
               CASE TVarType OF
                 tvdata: (vData: QDPtr);
                 TVChar: (vChar: CHAR);
                 TVInt: (vInt: TC);
                 TVStr: (vHStr: THStr255);
                 TVBool: (vBool: TF);
               END;
     THVarTable = THSrchTable;

     TLocStr = STRING[CLocSize];

     TPLocRec = ^TLocRec;
     TLocRec = RECORD
               vKey: TLocStr;
               vStartPos, vEndPos: TFPos;
               tablePos: TL;
               {$IFC IMCompile }
               blkNo: TC;
               nxtBlkNo: TC;
               {$ENDC }
             END;
     THLocTable = THSrchTable;

     THLoopRec = ^TPLoopRec;
     TPLoopRec = ^TLoopRec;
     TLoopRec = RECORD
                 pKey: TKeyStr;
                 pCounted, pTested: TF;
                 pCount, pIter: TC;
                 pTestVar: TKeyStr;
                 pStartPos, pEndPos: TFPos;
                 pNextLoop: THLoopRec;
                END;

    THBlockRec = ^TPBlockRec;
    TPBlockRec = ^TBlockRec;
    TBlockRec = RECORD
                  blkFTest: TF;
                  blkName: TLocStr;
                  blkNext: THBlockRec;
                END;
    TWordPtr =  ^Str255;
    THWordBuf = ^TRgch;


VAR
  {$IFC IMCompile }
    fICompile:     TF;
    fCompTrace:    TF;
    icFileName:    PathName;
    icOpenName:    PathName;
    icProcNumber:  TC;
    icLocNumber:   TC;
    icLessonNumber: TC;
    icExzNumber:   TC;
    icBlockNumber: TC;
    icInProc:      TF;
    icSkipCommand: TF;
    icSkipBlock:   TF;
    icInBlock:     TF;
    icCmdErrCount: TC;
    icNameIntArg:  TKeyStr;
    icNameStrArg:  TKeyStr;
  {$ENDC }

{$IFC IMDebug }
    icFile:        TEXT;
    topWordIdx:    TC;
    wUseArray:     Array [0..cWordArraySize] OF TC;
{$ENDC }
    topWordPos:    TC;
    wordBuf:       THWordBuf;
    wordBufSize:   TC;
    icSaveName:    TKeyStr;
    icOpenName:    PathName;



    PIMFS:         TPIMF;

    ldirfile:      STRING[40];

    ScriptBuf:     Str255;
    ScriptPos:     TC;
    ScriptPtr:     TRgch;
    ScriptLineLen: TC;

    ScrIBuf:       THScrIBuf;

    nxtWCLine:     THImsLine;
    nxtWCPos:      TC;

    InArg:         TF;
    InCommand:     TF;
    ArgEndChar:    CHAR;

    TopBlock:         THBlockRec;

    InExercise:       TF;
    InLesson:         TF;

    curLesson:     TKeyStr;
    curExercise:   TKeyStr;
    curBlock:      TKeyStr;

    resLesson:     TKeyStr;
    resExercise:   TKeyStr;
    resBlock:      TKeyStr;

    fSkip:            TF;
    fNoPause:         TF;
    fStepped:         TF;
    skipNext:         TF;
    skipName:         TKeyStr;
    skipExzName:      TKeyStr;
    skipBlkName:      TKeyStr;
    skipType:         CHAR;
    skipEndType:      CHAR;
    skipToEnd:        TF;

    fOpenLocMap:   TF;
    fFullLocMap:   TF;
    fMakeLocMap:   TF;
    locMapRef:     TC;
    locMapFile:    PathName;
    resetPos:      TFPos;
    lessonCounter: TC;

  { Interpreter data lookup tables }
    hUserVarTable: THVarTable;
    hExzVarTable:  THVarTable;
    hLessonVarTable: THVarTable;
    hGlobalVarTable: THVarTable;

    hLessonLocTable: THLocTable;
    hExzLocTable: THLocTable;
    hBlockLocTable: THLocTable;
    hTagLocTable: THLocTable;
    hTopLoopRec: THLoopRec;




PROCEDURE GoStartPos;
PROCEDURE SaveResetPos;
PROCEDURE NewWordBuf(bufSize: TC);
PROCEDURE KrunchScript(alertNum: TC);
PROCEDURE EndKrunch;
PROCEDURE SetupComp(fileName: Pathname; fullKrunch: TF);
PROCEDURE CompLesson;
PROCEDURE ICDumpWords;
PROCEDURE CloseComp;
PROCEDURE ShowScript;
PROCEDURE PrtScript(sFlg: TF);
PROCEDURE HideScript;
PROCEDURE KillScript;
FUNCTION  IMScrInit(ldirfile: Pathname): TF;
PROCEDURE DumpScriptLine(VAR lStr: Str255);
PROCEDURE PushScrIBuf;
PROCEDURE PopScrIBuf;
PROCEDURE InsertScrLine(pistr: TPStr255; endCr, pushFlag: TF);
FUNCTION  NewIBufLine: BOOLEAN;
PROCEDURE NewScriptLine;
PROCEDURE DoWindowCmd;
PROCEDURE EndWindowCmd;
PROCEDURE CheckScriptBuf;
FUNCTION  PeekScriptChar: CHAR;
FUNCTION  PeekUCScriptChar: CHAR;
FUNCTION  ReadScriptChar: CHAR;
FUNCTION  ReadUCScriptChar: CHAR;
PROCEDURE ScriptWord(rgch:TRgch; maxLen: TC; VAR actLen: TC; endWord: TF);
PROCEDURE GetBufWord(wPos: TC; wp: TWordPtr);
FUNCTION  FindBufWord(VAR wordStr: Str255): TC;
FUNCTION  AddBufWord(VAR wordStr: Str255): TC;
PROCEDURE StrWord(VAR wordStr: Str255; bufRgch: TRgch; VAR bufPos: TC; bufLen: TC);
PROCEDURE StartArg;
FUNCTION  EndArg: BOOLEAN;
PROCEDURE FinishArg;
PROCEDURE MunchCommand; { eats a command contained within another }
PROCEDURE CommandDone;
PROCEDURE FinishCommand;
PROCEDURE CmdError(errStr: Str255);
FUNCTION ReadCmdChar: CHAR;
FUNCTION CheckComment: BOOLEAN;

FUNCTION ArgChar(VAR ch: CHAR): TF;
FUNCTION ArgInt(VAR int: TC; fCompile: TF): TF;
FUNCTION ArgRange(VAR int, err: TC; fCompile: TF): TF;
FUNCTION ArgStr(pstr: TPStr255; maxlen: TC; fCompile: TF): TF;
FUNCTION ArgBool(VAR bool: TF): TF;

FUNCTION GetVVar(varName: TKeyStr):TPVarRec;
FUNCTION FindVarRec(varSource: CHAR; VAR varName: TKeyStr):TPVarRec;
FUNCTION GetVarRec(varSource: CHAR):TPVarRec;
PROCEDURE PrintVData(pvarRec: TPVarRec);
FUNCTION  NewVarRec(varSource: CHAR; VAR varName: TKeyStr;
                    varType: TVarType):TPVarRec;
PROCEDURE SetStrVar(VAR varName: TKeyStr; strVal: Str255);
PROCEDURE SetBoolVar(VAR varName: TKeyStr; boolVal: TF);
PROCEDURE ClearVarTable(hvt: THVarTable);
FUNCTION GetBoolVar(varName: TKeyStr; noFindResult: TF; VAR foundFlag: TF): TF;

PROCEDURE PopAllBlocks;
PROCEDURE PopLoopRec;
PROCEDURE ClearLoops;
PROCEDURE ClearGTables;
PROCEDURE ClearLTables;
PROCEDURE ClearETables;
PROCEDURE ClearBTables;

PROCEDURE PrintSkipStuff;
PROCEDURE ClearSkips;
PROCEDURE GoLoc(blkType: CHAR; toName: TKeyStr);
PROCEDURE SkipTo(bType: CHAR; tName: TKeyStr);
PROCEDURE StopSkip;

FUNCTION  GetLocTable(blkType: CHAR): THLocTable;
FUNCTION  MakeLocMap(mapFile: PathName): TF;
PROCEDURE DumpCmdChars;
PROCEDURE OpenLocMap(mapFile: PathName);
PROCEDURE ReadLocMap(filePos: TL; locTable: THLocTable);
FUNCTION  WriteLocMap(locTable: THLocTable): TC;
PROCEDURE WriteLessonLoc(mapComplete: TF);
PROCEDURE ReadLessonLoc(lMapFile: PathName);
PROCEDURE CloseLocMap;
FUNCTION GetLimitType(srchType: CHAR): CHAR;
FUNCTION LookupLoc(blkType: CHAR; blkName: TKeyStr): TPLocRec;
PROCEDURE SetStartLoc(btype: CHAR; bname: TKeyStr; bpos: TFpos);
PROCEDURE SetEndLoc(btype: CHAR; bname: TKeyStr; bpos: TFpos);

PROCEDURE GobbleCmd(curChar: CHAR; errMsg: Str255);
PROCEDURE InvalidCmdChar(curChar: CHAR; errMsg: Str255);




IMPLEMENTATION


VAR
    resWait: TF;
    doReset: TF;
    WCharSet: Set Of 0..255;
    MWCharSet: Set Of 0..255;
    fDumpSyntax:   TF;


FUNCTION FixLocMap(mapFile: PathName; alert: TC): TF; FORWARD;
PROCEDURE SkipBlk(VAR lName, eName, bName: TKeyStr); FORWARD;

PROCEDURE ClrResetPos;
VAR stPos:   TFpos;
    pStPos:  TPFposRec;
BEGIN
   resLesson   := '';
   resExercise := '';
   resBlock    := '';
   resWait     := FALSE;
   resetPos := 0;
   DoReset     := FALSE;
END;


{$S imscc }
PROCEDURE GoStartPos;
VAR stPos:   TFpos;
    pStPos:  TPFposRec;
BEGIN
   pStPos := @stPos;
   WITH pStPos^ DO
     BEGIN
       fileIdx := 1;
       hifilepos := 0;
       filePos := 0;
     END;
   IF NOT IMFSetPos(PIMFS, stPos)
     THEN IF cDebug THEN
       WRITELN('Cant go to start im LisaGuide script');
END;


{$S imscc }
PROCEDURE SaveResetPos;
VAR stPos:   TFpos;
    pStPos:  TPFposRec;
BEGIN
   resLesson   := curLesson;
   resExercise := curExercise;
   resBlock    := curBlock;
   resWait     := fWait;
   resetPos    := IMFPos(PIMFS);
   DoReset     := FALSE;
END;


PROCEDURE KrunchScript; { (alertNum: TC); }
BEGIN
   SaveResetPos;
   GoStartPos;
   SkipTo('L', 'no such lesson');
   fStepped    := FALSE;
   fWait       := FALSE;
   IMAlertUp;
   WaitAlert (imAlert, alertNum);
   lessonCounter := 0;
   CountAlert(9, lessonCounter);
END;

PROCEDURE EndKrunch;
BEGIN
   IF lessonCounter >= 0 THEN PullAlert;
   lessonCounter := -1;
   DoReset := TRUE;
   SkipBlk(resLesson, resExercise, resBlock);
END;

PROCEDURE DownShift(VAR s: Pathname);
{ converts all upper case chars in "s" to lower case }
VAR i: INTEGER;
BEGIN
FOR i := 1 TO LENGTH(s) DO
   IF (s[i] <= 'Z') THEN
      IF (s[i] >= 'A') THEN s[i] := CHR(ORD(s[i]) + 32);
END;


PROCEDURE ICDumpWords;
VAR idx: TC;
    wp: TWordPtr;
BEGIN
{$IFC IMDebug }
  IF fICompile THEN
      BEGIN
      WRITELN(icFile);
      WRITELN(icFile);
      idx := 2;
      WHILE idx < topWordPos DO
          BEGIN
          wp := POINTER(ORD(@wordBuf^)+idx);
          WRITELN(icFile, '   {  word ',  idx:4, ' = ''', wp^, ''';  usage: ',
                           wUseArray[idx]:4, ' }');
          END;
      WRITELN(icFile, 'END;');
      END;
{$ENDC }
END;


{$S imcomp }
PROCEDURE CloseComp;
VAR ior: TC;
BEGIN
{$IFC IMCompile }
    IF fICompile = TRUE THEN
        BEGIN
        IF icCmdErrCount > 0 THEN
            WRITELN(icFile, '{ ***** ***** There are ', icCmdErrCount:1,
                    '!! command errors in this compilation ***** ***** }');
        DownShift(icFileName);
        IF icFileName <> '-console' THEN
            BEGIN
            CLOSE(icFile, LOCK);
            ior := IORESULT;
            WRITELN('IOResult of closing compile file "',
                     icFileName, '" is:', ior:4);
            END;
        WRITELN('LisaGuide script compilation completed with ', icCmdErrCount:1,
                'errors.');
        END;
    icFileName := '';
    fICompile := FALSE;
{$ENDC }
END;


{$S imscw }
PROCEDURE NewWordBuf; { (bufSize: TC); }
BEGIN
  wordBufSize := bufSize;
  wordBuf := POINTER(ORD(HAllocate(IMHeap, wordBufSize)));
  IF wordBuf = NIL
    THEN BEGIN
      WRITELN(' NewWordBuf initialization failed during storage allocation.');
      { turn off word logging }
     END;
  topWordPos := 2;
  IF cDebug THEN WRITELN(' wordBuf space from ', ORD(wordBuf^));
END;


{$S imcomp }
FUNCTION OpenComp: INTEGER;
VAR ior: TC;
    iStr: TStr20;
BEGIN
{$IFC IMCompile }
    IF icFileName <> '-console' THEN
        BEGIN
        IntStr20(icLessonNumber, iStr);
        icOpenName := CONCAT(icFileName, iStr, '.text');
        END
    ELSE icOpenName := icFileName;
    REWRITE(icFile, icOpenName);
    ior := IORESULT;
    WRITELN('IOResult of opening compile file "', icOpenName, '" is:', ior:4);
    OpenComp := ior;
{$ENDC }
END;


{$S imcomp }
PROCEDURE SetupComp; { (fileName: Pathname; fullKrunch); }
{$IFC IMCompile }
LABEL 100, 200;
VAR ior: TC;
{$ENDC }
BEGIN
{$IFC IMCompile }
    IF fICompile = TRUE THEN
        BEGIN
        IF fileName = icFileName THEN EXIT(SetupComp);
        CloseComp;
        END;
100:
    IF fileName = '' THEN filename := '-paraport-lgscript.text';
    WRITE('Starting script compilation to "', fileName, '". OK? ');
    IF GetYorN THEN GOTO 200;
    WRITE('Do script compile to another file? ');
    IF NOT GetYorN THEN EXIT(SetupComp);
    WRITE('Please enter script file name: ');
    READLN(filename);
    GOTO 100;
200:
    icLessonNumber := 1;
    DownShift(fileName);
    icFileName := fileName;
    ior := OpenComp;
    IF ior > 0 THEN
       BEGIN
       WRITE('Try another file? ');
       IF GetYorN THEN
           BEGIN
           fileName := '';
           GOTO 100;
           END
       ELSE
           BEGIN
           WRITE('Try anyway?');
           IF NOT GetYorN THEN EXIT(SetupComp);
           END;
       END;
    fICompile := TRUE;
    fCompTrace := FALSE;
    icBlockNumber := 0;
    icProcNumber := 0;
    icLocNumber := 0;
    icInProc := FALSE;
    icInBlock := FALSE;
    icSkipCommand := FALSE;
    icSkipBlock := FALSE;
    icNameIntArg := 'cargInt';
    icNameStrArg := 'cargStr';
    icCmdErrCount := 0;
    topWordIdx := cMaxSpaces;
    IF wordBuf = NIL THEN NewWordBuf(cWBSize);
    IF fullKrunch THEN KrunchScript(418);
    WRITELN('Beginning script compilation');
{$ENDC }
END;


{$S imcomp }
PROCEDURE CompLesson;
VAR ior: TC;
    filename: PathName;
    iStr: TStr20;
BEGIN
{$IFC IMCompile }
    icLessonNumber := icLessonNumber+1;
    filename := icFileName;
    IF filename = '-console' THEN EXIT(CompLesson);

    CLOSE(icFile, LOCK);
    ior := IORESULT;
    WRITELN('IOResult of closing compile file "',
                 icFileName, '" is:', ior:4);

    ior := OpenComp;
    WRITELN('IOResult of opening compile file "', filename, '" is:', ior:4);
{$ENDC }
END;


{$S imscdbg }
PROCEDURE ShowScript;
VAR clsPos: Point;
    openRect: Rect;
BEGIN
 {$IFC IMDebug }
  IF hndScriptFldr = NIL
    THEN BEGIN
      IF IMMtst THEN WRITELN('Creating Script folder.');
      SetPt(clsPos, 100, 60);
      SetRect(openRect, 40, 150, 525, 275);
      hndScriptFldr := IFMakeFolder('IM Script', docKind, nilKind, openRect,
                          clsPos, TRUE, TRUE, TRUE, filerFolder);
      ScriptStr := NewFldrStream(hndScriptFldr, 150, FALSE);
      ScriptStr^^.sCanAddLines := TRUE;
      AddFldrMenu(hndScriptFldr, FilingMInfo, TRUE);
      { AddFldrMenu(hndScriptFldr, FlrEditMInfo, TRUE); }
      AddFldrMenu(hndScriptFldr, EditMInfo, TRUE);
      AddFldrMenu(hndScriptFldr, CtrlMInfo, TRUE);
      AddFldrMenu(hndScriptFldr, FCtrlMInfo, TRUE);
      AddFldrMenu(hndScriptFldr, FlagsMInfo, TRUE);
      AddFldrMenu(hndScriptFldr, SimMInfo, TRUE);
      ReDrawFldrContents(hndScriptFldr);
     END
   ELSE IFOpenObj(POINTER(ORD(hndScriptFldr^^.fldrFObj)));
   BringToFront(POINTER(ORD(hndScriptFldr^^.fldrPort)), TRUE);
   DrawScroll(hndScriptFldr);
 {$ENDC }
END;

{$S imscdbg }
PROCEDURE PrtScript; { (sFlg: TF); }
BEGIN
 {$IFC IMDebug }
  IF sFlg THEN ShowScript;
  fScriptPrint := sFlg;
 {$ENDC }
END;

{$S imscdbg }
PROCEDURE HideScript;
BEGIN
 {$IFC IMDebug }
  IF hndScriptFldr <> NIL
   THEN IFCloseObj(POINTER(ORD(hndScriptFldr^^.fldrFObj)), FALSE);
  fScriptPrint := FALSE;
 {$ENDC }
END;

{$S imscdbg }
PROCEDURE KillScript;
BEGIN
 {$IFC IMDebug }
  IF hndScriptFldr <> NIL
    THEN IFKillObject(POINTER(ORD(hndScriptFldr^^.fldrFObj)));
  IF hndScriptFldr = hndActiveFldr THEN hndActiveFldr := NIL;
    { this is a temporary fix }
  hndScriptFldr := NIL;
  ScriptStr := NIL;
  fScriptPrint := FALSE;
 {$ENDC }
END;

{$S imscini }
FUNCTION IMScrInit;  { (ldirfile: Pathname): TF; }
VAR fsInit: TF;
BEGIN

{$IFC IMCompile }
  fICompile := FALSE;
  icFileName := '';
{$ENDC }

  wordBuf := NIL;
  wordBufSize := 0;
  NEW(PIMFS);
  IF IMtst THEN WRITELN('Initializing IM file state at: ', ORD(PIMFS));
  fsInit := InitIMFS(PIMFS, ldirfile);
  IF NOT fsInit THEN WRITELN('Cant init the IM file state');
  IMScrInit := fsInit;

  ScriptPos := 0;
  ScriptLineLen := 0;
  ScrIBuf := NIL;

  InArg := FALSE;
  InCommand := FALSE;
  ArgEndChar := ')';

  TopBlock := NIL;

  InExercise := FALSE;
  InLesson := FALSE;

  curLesson   := '';
  curExercise := '';
  curBlock    := '';

  ClrResetPos;
  nxtWCLine := NIL;
  nxtWCPos := 0;

  fNoPause := FALSE;
  fStepped := TRUE;

  ClearSkips;

  fOpenLocMap := FALSE;
  fFullLocMap := FALSE;
  fMakeLocMap := FALSE;
  fDumpSyntax := FALSE;
  locMapRef   := 0;
  locMapFile  := '';
  resetPos    := 0;
  lessonCounter := -1;

  hUserVarTable   := CreateSrchTable(SIZEOF(TVarRec), CUserVars, 3);
  hExzVarTable    := CreateSrchTable(SIZEOF(TVarRec), CExzVars, 3);
  hLessonVarTable := CreateSrchTable(SIZEOF(TVarRec), CLessonVars, 3);
  hGlobalVarTable := CreateSrchTable(SIZEOF(TVarRec), CGlobalVars, 3);

  hLessonLocTable := CreateSrchTable(SIZEOF(TLocRec), CLessonLocs, 3);
  hExzLocTable    := CreateSrchTable(SIZEOF(TLocRec), CExzLocs, 3);
  hBlockLocTable  := CreateSrchTable(SIZEOF(TLocRec), CBlockLocs, 3);
  hTagLocTable    := CreateSrchTable(SIZEOF(TLocRec), CTagLocs, 3);

  hTopLoopRec := NIL;

  WCharSet := [33..39, 42..59, 61, 63..90, 92, 94..122, 124,126,
           128..159, 167, 174..175, 187, 188, 190..191, 202, 162, 163, 180];
     { this set is a composite of IMFWChars and the sets in charClass of    }
     {  Fld.Sel in the field editor (shown below) this is installed to      }
     {  fix lisaGuide nr bug #8 for translation 3/4/83  -gb                 }
     {  [65..90, 97..122, 128..159, 167, 174..175, 187, 188, 190..191, 202] }
     {  for alphas,  [48..57] for numbers, and [162, 163, 180] for $        }

  MWCharSet := WCharSet - [ORD('.'), ORD(';'), ORD(':')];

  hndScriptFldr := NIL;
  ScriptStr := NIL;
  IF fScriptPrint THEN ShowScript;
END;



{$S imscc }
PROCEDURE DumpScriptLine; {(VAR lStr: Str255);}
VAR srgch: TRgch;
    lineLen: TC;
    saveIMStst: TF;
    scriptLine: THImsLine;
BEGIN
 {$IFC IMDebug }
  IF fScriptPrint AND (hndScriptFldr <> NIL) THEN
    WITH hndScriptFldr^^ DO
      BEGIN
        srgch := POINTER(ORD(@lStr)+1);
        lineLen := LENGTH(lStr);
        saveIMStst := IMStst;
        IF saveIMStst <> fScriptTrace THEN IMStst := fScriptTrace;
        scriptLine := AddNewTextLine(ScriptStr, srgch, lineLen, TRUE);
        DrawFldrContents(hndScriptFldr);
        IF saveIMStst <> fScriptTrace THEN IMStst := saveIMStst;
      END;
 {$ENDC }
END;


{$S imscc }
PROCEDURE ShowKbdLine(VAR lStr: Str255);
VAR sStr: Str255;
BEGIN
  {  sStr := CONCAT('kbd: ', lStr); }
  {  DumpScriptLine(sStr);          }
END;


{$S imscc }
PROCEDURE PushScrIBuf;
VAR ibuf: THScrIBuf;
BEGIN
  IF IMScrTst THEN WRITELN('Pushing new Script IBuf   ');
  ibuf := POINTER(ORD(HAllocate(IMHeap, SIZEOF(TScrIBuf))));
  WITH ibuf^^ DO
    BEGIN
      oScrPtr := ScriptPtr;
      oScrPos := ScriptPos;
      oScrBuf := ScriptBuf;
      oScrLineLen := ScriptLineLen;
      ScriptPos := 0;
      ScriptLineLen := 0;
      iScrLBuf := NIL;
      nextIBuf := ScrIBuf;
      ScrIBuf := ibuf;
    END;
END;


{$S imscc }
PROCEDURE PopScrIBuf;
VAR ibuf: THScrIBuf;
    lbuf, nxtLbuf: THScrLineBuf;
BEGIN
  IF IMScrTst THEN WRITELN('Popping the script IBuf   ');
  WITH ScrIBuf^^ DO
    BEGIN
      ScriptPtr := oScrPtr;
      ScriptBuf := oScrBuf;
      ScriptPos := oScrPos;
      ScriptLineLen := oScrLineLen;
      lbuf := iScrLBuf;
      WHILE lbuf <> NIL DO
        BEGIN
          nxtLbuf := lbuf^^.nextLineBuf;
          FreeBk(IMHeap, POINTER(ORD(lbuf)), tybkStd);
          lbuf := nxtLbuf;
        END;
      ibuf := ScrIBuf;
      ScrIBuf := nextIBuf;
      FreeBk(IMHeap, POINTER(ORD(ibuf)), tybkStd);
    END;
END;


{$S imscc }
PROCEDURE InsertScrLine; {(ipstr: TPStr255; endCr, pushFlag: TF);}
VAR lbuf, plbuf: THScrLineBuf;
BEGIN
  IF IMScrTst THEN WRITELN('Inserting script line into IBuf');
  IF pushFlag THEN PushScrIBuf;
  IF ScrIBuf = NIL THEN PushScrIBuf;
  lbuf := POINTER(ORD(HAllocate(IMHeap, SIZEOF(TScrLineBuf))));
  { if we can change to rgch from string then use above plus  LENGTH(pistr^) }
  IF IMScrTst THEN WRITELN('Inserting line/string: ', pistr^, ' endCr: ', endCr);
  WITH lbuf^^ DO
    BEGIN
      iBufCr := endCr;
      iScrLine := pistr^;
      nextLineBuf := NIL;
    END;
  IF ScrIBuf^^.iScrLBuf = NIL
    THEN BEGIN
      ScrIBuf^^.iScrLBuf := lbuf;
      ScriptBuf := lbuf^^.iScrLine;
      ScriptPtr := POINTER(ORD(@lbuf^^.iScrLine) + 1);
      IF IMScrTst THEN WRITELN('ScriptPtr set to: ', ORD(ScriptPtr));
      ScriptPos := 0;
      ScriptLineLen := LENGTH(pistr^);
      IF IMScrTst THEN WRITELN('Inserting first line in insert buf.',
                ' (becomes current script buf).');
     END
    ELSE BEGIN
      plbuf := ScrIBuf^^.iScrLBuf;
      WHILE plbuf^^.nextLineBuf <> NIL DO plbuf := plbuf^^.nextLineBuf;
      plbuf^^.nextLineBuf := lbuf;
      IF IMScrTst THEN WRITELN('Adding extra line into script buf.');
     END;
END;


{$S imscc }
FUNCTION NewIBufLine; {: BOOLEAN;}
VAR lbuf: THScrLineBuf;
BEGIN { called only when ScrIBuf <> NIL }
  IF IMScrTst THEN WRITELN('Getting new line from IBuf');
  WITH ScrIBuf^^ DO
    BEGIN
      IF (iScrLBuf <> NIL) AND (iScrLBuf^^.nextLineBuf <> NIL)
        THEN BEGIN
          lbuf := iScrLBuf^^.nextLineBuf;
          FreeBk(IMHeap, POINTER(ORD(iScrLBuf)), tybkStd);
          iScrLBuf := lbuf;
         END
        ELSE PopScrIBuf;
    END;
  IF (ScrIBuf <> NIL)
    THEN IF (ScrIBuf^^.iScrLBuf <> NIL)
    THEN BEGIN
      ScriptPtr := POINTER(ORD(@ScrIBuf^^.iScrLBuf^^.iScrLine) + 1);
      ScriptBuf := ScrIBuf^^.iScrLBuf^^.iScrLine;
      ScriptPos := 0;
      ScriptLineLen := LENGTH(ScrIBuf^^.iScrLBuf^^.iScrLine);
      NewIBufLine := TRUE;
      EXIT(NewIBufLine);
     END;
  NewIBufLine := (ScriptPos < ScriptLineLen);
     { TRUE if chars left in popped line. }
END;


{$S imscc }
PROCEDURE ReadWindowLn(VAR bufStr: Str255; VAR bufPos, bufLen: TC);
VAR lnCt: TC;
BEGIN
  WHILE nxtWCLine <> NIL
    DO BEGIN
      lnCt := LineCCount(nxtWCLine);
IF IMStst THEN WRITELN('Window command line:', ORD(nxtWCLine), ' length:', lnCt);
      MoveRgch(POINTER(ORD(@bufStr)+1), LineChars(nxtWCLine), lnCt);
      bufPos := nxtWCPos;
      bufLen := lnCt;
      bufStr[0] := CHR(lnCt);
      nxtWCLine := nxtWCLine^^.lNext;
      nxtWCPos := 0;
      IF lnCt > 0
        THEN BEGIN
          ScriptPtr := POINTER(ORD(@ScriptBuf)+1);
          EXIT(ReadWindowLn);
         END;
     END;
  IF IMStst THEN  WRITELN('WindowCmd - ran out of window text');
  EndWindowCmd;
END;


{$S imscc }
PROCEDURE DoWindowCmd;
BEGIN
 {$IFC IMDebug }
  kbdCommand := TRUE;
  IF ScriptStr = NIL
    THEN BEGIN
      IF IMStst THEN
        WRITELN('Cant do window command with no script window');
      EXIT(DoWindowCmd);
     END;
  IF NOT ActSel(ScriptStr)
    THEN BEGIN
      IF IMStst THEN
        WRITELN('Cant do window command with no script window selection');
      EXIT(DoWindowCmd);
     END;
  nxtWCLine := ScriptStr^^.sField;
  nxtWCPos := ScriptStr^^.sField^^.fld.fhFState^^.select.int.lpFst;
  IF IMScrTst THEN WRITELN('DoWindowCmd - Initial buf pos:', nxtWCPos);
  ReadWindowLn(ScriptBuf, ScriptPos, ScriptLineLen);
 {$ENDC }
END;


{$S imscc }
PROCEDURE EndWindowCmd;
VAR selLine: THImsLine;
BEGIN
 {$IFC IMDebug }
  InCommand := FALSE;
  kbdCommand := FALSE;
  nxtWCLine := NIL;
  nxtWCPos := 0;
  ScriptPos := ScriptLineLen + 1;
IF IMStst THEN WRITELN('Window command is complete');
 {$ENDC }
END;


{$S imsch }
PROCEDURE NewScriptLine;
LABEL 100,900;
BEGIN  { ScriptBuf is used only in this procedure - could be dropped - and readscriptchar now }
  IF ScrIBuf <> NIL
    THEN IF NewIBufLine THEN GOTO 900;
100:
  IF kbdCommand
    THEN ReadWindowLn(ScriptBuf, ScriptPos, ScriptLineLen)
    ELSE BEGIN
      IMFReadln(PIMFS, ScriptBuf);
      ScriptPos := 0;
     END;
  IF IMScrTst THEN WRITELN('got script line: ', ScriptBuf);
  IF POS('^', ScriptBuf) = 1 THEN GOTO 100;
  ScriptPtr := POINTER(ORD(@ScriptBuf)+1);
  ScriptLineLen := LENGTH(ScriptBuf);
  ScriptPos := 0;
  IF kbdCommand THEN ShowKbdLine(ScriptBuf)
                ELSE BEGIN
                  IF (hndScriptFldr = hndActiveFldr) THEN ClearSelection;
                  DumpScriptLine(ScriptBuf);
                 END;
900:
END;


{$S imsch }
PROCEDURE CheckScriptBuf;
BEGIN
  WHILE (ScriptPos >= ScriptLineLen)
    DO NewScriptLine;
END;


{$S imsch }
FUNCTION PeekScriptChar; {: CHAR;}
LABEL 100;
BEGIN
100: IF (ScriptPos < 0) OR (ScriptPos >= ScriptLineLen)
       THEN
         BEGIN
           IF (ScrIBuf <> NIL)
            THEN IF  (NOT ScrIBuf^^.iBufCr)
              THEN BEGIN NewScriptLine; GOTO 100; END;
           PeekScriptChar := CHR(13);
           IF IMScrTst THEN WRITELN('PeekScriptChar  = 13  (end of line)');
         END
       ELSE
         BEGIN
           PeekScriptChar := ScriptBuf[ScriptPos+1];
           IF IMScrTst THEN WRITELN('PeekScriptChar ',CHR(ScriptPtr^[ScriptPos]),
               '  ord = ', ScriptPtr^[ScriptPos]:5, '  SPos:', ScriptPos:4);
         END;
END;


{$S imsch }
FUNCTION PeekUCScriptChar; {: CHAR;}
VAR cchr: CHAR;
BEGIN
  cchr := PeekScriptChar;
  WHILE (ORD(cchr) = 32) OR (ORD(cchr) = 13) OR (ORD(cchr) = 0)
    DO BEGIN
      IF ORD(cchr) = 13
        THEN NewScriptLine
        ELSE cchr := ReadScriptChar;
      cchr := PeekScriptChar;
     END;
  IF (ORD(cchr) >= 97) AND (ORD(cchr) <= 122) THEN cchr := CHR(ORD(cchr) - 32);
  PeekUCScriptChar := cchr;
END;


{$S imsch }
FUNCTION ReadScriptChar; {: CHAR;}
VAR chByte: TB;
    chInt:  TC;
BEGIN
  WHILE (ScriptPos < 0) OR (ScriptPos >= ScriptLineLen)
    DO NewScriptLine;  { this is really CheckScriptBuf; }
  {chByte := ScriptPtr^[ScriptPos];
  {IF chByte < 0 THEN
  {    BEGIN
  {    chInt := chByte+256;
  {    chByte := chInt;
  {    END;  }
  ReadScriptChar := ScriptBuf[ScriptPos+1];
  IF IMScrTst THEN WRITE('(', ScriptBuf[ScriptPos+1], '-', ScriptPos:2, '),');
  ScriptPos := ScriptPos + 1;
END;


{$S imsch }
FUNCTION ReadUCScriptChar; {: CHAR;}
VAR cchr: CHAR;
BEGIN
  cchr := CHR(0);
  WHILE (ORD(cchr) = 32) OR (ORD(cchr) = 13) OR (ORD(cchr) = 0)
    DO cchr := ReadScriptChar;
  IF (ORD(cchr) >= 97) AND (ORD(cchr) <= 122) THEN cchr := CHR(ORD(cchr) - 32);
  ReadUCScriptChar := cchr;
  IF IMScrTst THEN WRITE('<', cchr, '>,');
END;


{$S imscw }
PROCEDURE ScriptWord; {(rgch: TRgch; maxLen: TC; VAR actLen: TC; endWord: TF);}
LABEL 700,900;
     {  for alphas,  [48..57] for numbers, and [162, 163, 180] for $        }
TYPE TScriptNum = 0..255;   { types added for lisaguide nr bug #8 fix }
     TScriptARgch = PACKED ARRAY [0..0] OF TScriptNum;
     TScriptRgch = ^TScriptARgch;
VAR srcSt: TC;
    traceWd: Str255;
    scriptN: TScriptNum;
    scriptRgch: TScriptRgch; { var added for lisaguide nr bug #8 fix }
BEGIN
  srcSt := -1;
  scriptRgch := POINTER(ORD(ScriptPtr));
  REPEAT
    IF ScriptPos = ScriptLineLen THEN GOTO 700;
    CASE ScriptPtr^[ScriptPos] OF
      32: ScriptPos := ScriptPos + 1;
      0, 13, 9, 16:
        BEGIN ScriptPos := ScriptPos + 1;
              IF sDebug THEN
                WRITELN('Strange char in script buf: ', ScriptPtr^[ScriptPos],
                        ' scriptPos = ', ScriptPos);
              IF ScriptPtr^[ScriptPos] = 16 THEN ScriptPos := ScriptPos+1;
              HoldIt(sDebug); END;
      OTHERWISE srcSt := ScriptPos;
     END;
  UNTIL (srcSt >= 0);
  ScriptPos := ScriptPos + 1;
  { old code IF (ScriptPtr^[srcSt] IN IMFWChars) THEN -- changed for nr bug #8 }
  scriptN := ScriptRgch^[srcSt];
  IF scriptN IN WCharSet
    THEN BEGIN
      scriptN := ScriptRgch^[ScriptPos];
      WHILE (scriptN IN WCharSet) AND
            (ScriptPos-srcSt < maxLen) AND
            (ScriptPos < ScriptLineLen)
        DO BEGIN
            ScriptPos := ScriptPos + 1;
            scriptN := ScriptRgch^[ScriptPos];
           END;
      actLen := ScriptPos - srcSt;
      IF (actLen = maxLen) AND endWord THEN
        WHILE (scriptN IN WCharSet) DO
          BEGIN
            ScriptPos := ScriptPos + 1;
            scriptN := ScriptRgch^[ScriptPos];
           END;
    END
   ELSE actLen := 1;
   MoveRgch(rgch, @ScriptPtr^[srcSt], actLen);
   IF IMScrTst THEN BEGIN RgchToStr(traceWd, rgch, actLen);
             WRITE('Script word = ', traceWd);
             IF actLen = 1 THEN WRITELN(' (', ORD(traceWd[1]), ')') ELSE WRITELN;
             END;
   GOTO 900;
700:
   actLen := 1;
   rgch^[0] := 13;
900:
END;


{$S imscw }
PROCEDURE GetBufWord; { (wPos: TC; wp: TWordPtr); }
BEGIN
  IF (wPos > 1) AND (wPos <= topWordPos)
     THEN
         BEGIN
         wp := POINTER(ORD(wordBuf^)+wPos);
         END
     ELSE wp := NIL;
END;


{$S imscw }
FUNCTION FindBufWord; { (VAR wordStr: Str255): TC; }
VAR bufIdx:    TC;
    notDone:   TF;
    lastWord:  TC;
    bufPos: TC;
    wp:     TWordPtr;
BEGIN
{$IFC IMDebug}
  bufIdx := cMaxSpaces;
  notDone := TRUE;
  bufPos := 2;
  lastWord := topWordPos;
  WHILE notDone DO
      BEGIN
      IF bufPos >= lastWord THEN
          BEGIN
          bufPos := 0;
          notDone := FALSE;
          END
      ELSE
          BEGIN
          bufIdx := bufIdx +1;
          wp := POINTER(ORD(wordBuf^)+bufPos);
          IF wordStr = wp^ THEN
             BEGIN
             notDone := FALSE;
             wUseArray[bufIdx] := wUseArray[bufIdx]+1;
             IF fCompTrace THEN
                 WRITELN('FindBufWord got word "', wordStr,
                          '" at index: ', bufIdx);
             END
          ELSE bufPos := bufPos + LENGTH(wp^) + 1;
          END;
       END;
  FindBufWord := bufPos;
{$ENDC }
END;


{$S imscw }
FUNCTION AddBufWord; { (VAR wordStr: Str255): TC; }
VAR wPos: TC;
    wLen: TC;
BEGIN
{$IFC IMDebug }
  wPos := FindBufWord(wordStr);
  IF wPos = 0 THEN
      BEGIN
      wLen := LENGTH(wordStr) + 1;
      wPos := topWordPos;
      IF wPos + wLen > wordBufSize THEN
          BEGIN
          wordBufSize := wordBufSize+1000;
          ChangeSizeH(IMHeap, POINTER(ORD(wordBuf)), wordBufSize);
          END;
      topWordIdx := topWordIdx+1;
      MoveRgch(POINTER(ORD(wordBuf^)+wPos), @wordStr, wLen);
      IF imTst THEN WRITELN('Added word ', topWordIdx, ' - "', wordStr, '" len=', wLen:4,
              ' at bufPos:', wPos:4);
      topWordPos := topWordPos+wLen;
      wUseArray[topWordIdx] := 1;
      END;
   AddBufWord := wPos;
{$ENDC }
END;


{$S imscw }
PROCEDURE StrWord;{(VAR wordStr: Str255; bufRgch: TRgch; VAR  bufPos, bufLen: TC);}
LABEL 900;
     {  for alphas,  [48..57] for numbers, and [162, 163, 180] for $        }
TYPE TScriptNum = 0..255;   { types added for lisaguide nr bug #8 fix }
     TScriptARgch = PACKED ARRAY [0..0] OF TScriptNum;
     TScriptRgch = ^TScriptARgch;
VAR srcSt: TC;
    actLen: TC;
    strLen: TB;
    traceWd: Str255;
    scriptN: TScriptNum;
    scriptRgch: TScriptRgch; { var added for lisaguide nr bug #8 fix }
BEGIN
  srcSt := -1;
  actLen := 0;
  scriptRgch := POINTER(ORD(bufRgch));
  IF bufPos = bufLen THEN GOTO 900;
  srcSt := bufPos;
  bufPos := bufPos + 1;
  scriptN := ScriptRgch^[srcSt];
  IF scriptN IN MWCharSet
    THEN BEGIN
      scriptN := ScriptRgch^[bufPos];
      WHILE (scriptN IN MWCharSet) AND
            (bufPos-srcSt < 255) AND
            (bufPos < bufLen)
        DO BEGIN
            bufPos := bufPos + 1;
            scriptN := ScriptRgch^[bufPos];
           END;
      actLen := bufPos - srcSt;
    END
   ELSE actLen := 1;
   MoveRgch(POINTER(ORD(@wordStr)+1), @bufRgch^[srcSt], actLen);

900:
  strLen := actLen;
  wordStr[0] := CHR(strLen);
  IF IMScrTst
     THEN BEGIN
     WRITE('Str word = ', wordStr);
     IF actLen = 1 THEN WRITELN(' (', ORD(wordStr[1]), ')') ELSE WRITELN;
     END;
END;

{$S imsch }
PROCEDURE StartArg;
{ called after the arg start char has been eaten. }
VAR pc, rc: CHAR;
BEGIN
  InArg := TRUE;
  pc := PeekScriptChar;
  CASE pc OF
    '[': BEGIN rc := ReadScriptChar; ArgEndChar := ']'; END;
    '<': BEGIN rc := ReadScriptChar; ArgEndChar := '>'; END;
    '*': BEGIN rc := ReadScriptChar; ArgEndChar := '*'; END;
    OTHERWISE  ArgEndChar := ')';
  END;
END;


{$S imsch }
FUNCTION EndArg; {: BOOLEAN;}
{ called after ArgEndChar has been eaten. If a sequence is needed to end the arg
  then EndArg will eat the rest of it }
VAR achr: CHAR;
BEGIN
  IF IMScrTst THEN WRITELN('ArgEndChar: ', ArgEndChar, ORD(ArgENdCHar):4);
  IF ArgEndChar = ')'
    THEN InArg := FALSE
    ELSE
      BEGIN
        achr := PeekScriptChar;
        IF achr = ')'
          THEN
            BEGIN
              InArg := FALSE;
              ArgEndChar := ')';
              achr := ReadScriptChar; { gobble the close paren. }
            END;
      END;
  IF IMScrTst THEN WRITELN('EndArg = ', (NOT InArg));
  EndArg := NOT InArg;
END;


{$S imsch }
PROCEDURE FinishArg;
VAR achr: CHAR;
BEGIN
   WHILE InArg DO
      BEGIN
      achr := ReadScriptChar;
      IF achr = ArgEndChar THEN InArg := NOT EndArg; { gobble the Boolean value }
      END;
END;


{$S imscw }
PROCEDURE MunchCommand; { eats a command contained within another }
VAR svInArg: TF;
    svArgEnd, cchr: CHAR;
BEGIN
  svInArg := InArg;
  svArgEnd := ArgEndChar;
  REPEAT
    cchr := ReadScriptChar;
    IF cchr = '(' THEN BEGIN StartArg; FinishArg; END;
   UNTIL cchr = '.';
  InArg := svInArg;
  ArgEndChar := svArgEnd;
END;

{$S imsch }
PROCEDURE CommandDone;
BEGIN
  InCommand := FALSE;
  IF kbdCommand THEN EndWindowCmd;
END;


{$S imsch }
PROCEDURE FinishCommand;
VAR cchr: CHAR;
BEGIN
  IF InCommand
    THEN
      BEGIN
        IF InArg THEN FinishArg;
        REPEAT
          cchr := ReadScriptChar;
          IF cchr = '(' THEN BEGIN StartArg; FinishArg; END;
        UNTIL(cchr = '.');
        CommandDone;
      END;
END;


{$S imscdbg }
PROCEDURE CmdError; {(errStr: Str255);}
VAR i: INTEGER;
BEGIN
  IF sDebug OR IMScrTst
    THEN
      BEGIN
        WRITELN('Command Error at position: ', ScriptPos:5, ' - ', errStr);
        For i := 0 TO (ScriptPos - 1) DO WRITE(CHR(ScriptPtr^[i]));
        WRITE('<!>');
        For i := ScriptPos TO ScriptLineLen-1 DO WRITE(CHR(ScriptPtr^[i]));
        WRITELN(' In Lesson "', curLesson, '", exercise "', curExercise,
                '", block "', curBlock, '"');
      END;
{$IFC IMCompile }
  IF fICompile THEN
      BEGIN
      WRITELN(icFile, '{*****Command Error ***** ', errStr, ' }');
      WRITELN(icFile, 'IF sDebug THEN');
      WRITELN(icFile, '    BEGIN');
      WRITELN(icFile, '    WRITELN(''*** Command Error *** "', errStr, '" '');');
      WRITELN(icFile, '    WRITELN('' In Lesson "', curLesson,
                          '", exercise "', curExercise,
                          '", block "', curBlock, '"'');');
      WRITELN(icFile, '    END;');
      icCmdErrCount := icCmdErrCount+1;
      END;
  {$ENDC }
END;


{$S imsch }
FUNCTION CheckComment; {: BOOLEAN;}
BEGIN
    StartArg;
    IF ArgEndChar = '*'
      THEN
        BEGIN
          FinishArg;
          IF IMtst THEN WRITELN;
          IF IMtst THEN WRITELN('Skipping comment');
          CheckComment := TRUE;
        END
      ELSE
        BEGIN
          CmdError('( at top command level, but not for comment');
          CheckComment := FALSE;
        END;
END;


{$S imsch }
FUNCTION ReadCmdChar; {: CHAR;}
LABEL 100;
VAR cchr: CHAR;
BEGIN
100: cchr := ReadUCScriptChar;
  IF cchr = '('
    THEN IF CheckComment THEN GOTO 100
    ELSE FinishArg;
  IF cchr = '.' THEN CommandDone;
  ReadCmdChar := cchr;
END;


{$S imsch }
FUNCTION ArgChar; {(VAR ch: CHAR): TF;}
VAR cchr: CHAR;
    pvarRec: TPVarRec;
    fOK: TF;
BEGIN
  cchr := ReadUCScriptChar;
  IF (cchr = 'U') OR (cchr = 'V')
    THEN BEGIN
      pvarRec := GetVarRec(cchr);
      IF pvarRec = NIL
        THEN fOK := FALSE
        ELSE IF pvarRec^.vType <> TVChar
          THEN BEGIN CmdError('Invalid variable type assignment to CHAR variable');
             fOK := FALSE;
            END
          ELSE
              BEGIN
              ch := pvarRec^.vChar;
              fOK := TRUE;
              {$IFC IMCompile } IF fICompile THEN WRITELN(icFile, 'CGetCharVar(''', cchr, ''');'); {$ENDC }
              END;
     END
  ELSE IF cchr <> '('
    THEN fOK := FALSE
    ELSE
      BEGIN
        StartArg;
        cchr := ReadScriptChar;
        IF (cchr = ArgEndChar)
          THEN BEGIN
            IF EndArg
              THEN fOK := FALSE
              ELSE BEGIN ch := cchr; fOK := TRUE; END;
           END
          ELSE BEGIN ch := cchr; fOK := TRUE; END;
          {$IFC IMCompile } IF fICompile THEN WRITELN(icFile, 'argChar := ''', ch, ''';'); {$ENDC }
      END;
  ArgChar := fOK;
  FinishArg;
  IF IMScrTst THEN
    IF fOK
      THEN WRITELN('ArgChar sets  ', ORD(@ch), ' to ', cchr)
      ELSE WRITELN('ArgChar fails - cannot set ', ORD(@ch), ' to ', cchr);
END;


{$S imsch }
FUNCTION GetIntArg(VAR int: TC; fCompile: TF): TF;
LABEL 200,900;
VAR cchr: CHAR;
    fOK, fNeg: TF;
    pvarRec: TPVarRec;
    scrint: TC;
BEGIN
  scrint := 0;
  fNeg := FALSE;
  cchr := ReadUCScriptChar;
  IF (cchr = 'U') OR (cchr = 'V')
    THEN BEGIN
      pvarRec := GetVarRec(cchr);
      IF pvarRec = NIL
        THEN fOK := FALSE
        ELSE IF pvarRec^.vType <> TVInt
          THEN BEGIN CmdError('Invalid variable type assignment to INTEGER variable');
             fOK := FALSE;
            END
          ELSE
              BEGIN
              scrint := pvarRec^.vInt;
              int := scrint;
              fOK := TRUE;
        {$IFC IMCompile }
              IF fICompile THEN IF fCompile THEN
                  WRITELN(icFile, 'CGetIntVar(''', cchr, ''');');
        {$ENDC }
              END;
     END
  ELSE IF cchr <> '('
    THEN fOK := FALSE
    ELSE
      BEGIN
        StartArg;
        cchr := PeekUCScriptChar;
        IF cchr = '-'
          THEN BEGIN
             fNeg := TRUE;
             cchr := ReadUCScriptChar;
            END;
        scrint := 0;
   200: cchr := ReadScriptChar;
        IF (cchr = ArgEndChar) THEN IF EndArg
          THEN BEGIN
                fOK := TRUE;
                IF fNeg THEN scrint := -scrint;
                int := scrint;
                GOTO 900;
               END;
        IF (ORD(cchr) < ORD('0')) OR (ORD(cchr) > ORD('9'))
          THEN BEGIN fOK := FALSE; GOTO 900; END;
        scrint := scrint * 10;
        scrint := scrint + ORD(cchr) - ORD('0');
        GOTO 200;
   900:
{$IFC IMCompile }
       IF fICompile THEN IF fCompile THEN
            WRITELN(icFile, icNameIntArg, ' := ', scrint:1, ';');
{$ENDC }
      END;
  GetIntArg := fOK;
  FinishArg;
  IF IMScrTst THEN
    IF fOK
      THEN WRITELN('GetIntArg sets  ', ORD(@int), ' to ', scrint)
      ELSE WRITELN('GetIntArg fails - cannot set ', ORD(@int), ' to ', scrint);
END;


{$S imsch }
FUNCTION ArgInt; { (VAR int: TC; fCompile: TF): TF;}
LABEL 200, 900;
VAR cchr: CHAR;
    fOK: TF;
    scrint, scrplus: TC;
BEGIN
  scrint := 0;
  fOK := GetIntArg(scrint, fICompile);
  IF NOT fOK THEN GOTO 900;
200:
  cchr := PeekUCScriptChar;
  IF IMScrTst THEN WRITELN('peeked next char(test for +): ', cchr);
  IF cchr = '+'
    THEN BEGIN
      cchr := ReadScriptChar;
{$IFC IMCompile }
      IF fICompile THEN IF fCompile THEN
          BEGIN
          icSaveName := icNameIntArg;
          icNameIntArg := 'cargSum';
          END;
{$ENDC }
      fOK := GetIntArg(scrplus, fCompile);
      IF NOT fOK THEN GOTO 900;
      scrint := scrint + scrplus;
      scrplus := 0;
{$IFC IMCompile }
      IF fICompile THEN IF fCompile THEN
          WRITELN(icFile, icSaveName, ' := ', icSaveName, ' + cargSum;');
{$ENDC }
      GOTO 200;
     END;
900:
  ArgInt := fOK;
  int := scrint;
{$IFC IMCompile }
  IF fICompile THEN icNameIntArg := 'cargInt';
{$ENDC }
  IF IMScrTst THEN
    IF fOK
      THEN WRITELN('ArgInt sets  ', ORD(@int), ' to ', int, scrint)
      ELSE WRITELN('ArgInt fails - cannot set ', ORD(@int), ' to ', scrint);
END;


{$S imscw }
FUNCTION ArgRange; { (VAR int, err: TC; fCompile: TF): TF;}
LABEL 900;
VAR cchr: CHAR;
    fOK: TF;
    scrint, screrr: TC;
BEGIN
  scrint := 0;
  screrr := 0;
  fOK := ArgInt(scrint, fCompile);
  IF NOT fOK THEN GOTO 900;
  cchr := PeekUCScriptChar;
  IF IMScrTst THEN WRITELN('peeked next char(test for +): ', cchr);
  IF cchr = '%'
    THEN BEGIN
      cchr := ReadScriptChar;
{$IFC IMCompile }
      IF fICompile THEN IF fCompile THEN icNameIntArg := 'cargRngErr';
{$ENDC }
      fOK := ArgInt(screrr, fCompile);
     END;
900:
  ArgRange := fOK;
  int := scrint;
  err := screrr;
  IF IMScrTst THEN
    IF fOK
      THEN WRITELN('ArgRange sets  ', ORD(@int), ' to ', int, '+/- ', err)
      ELSE WRITELN('ArgRange fails - cannot set ', ORD(@int), ' to ', scrint);
END;


{$S imsch }
FUNCTION ArgStr; {(pstr: TPStr255; maxlen: TC; fCompile: TF): TF;}
LABEL 200,900;
VAR cchr: CHAR;
    fOK: TF;
    pvarRec: TPVarRec;
    ccount: TC;
    cptr: TRgch;
BEGIN
  cchr := ReadUCScriptChar;
  IF (cchr = 'U') OR (cchr = 'V')
    THEN BEGIN
      pvarRec := GetVarRec(cchr);
      IF pvarRec = NIL
        THEN fOK := FALSE
        ELSE IF pvarRec^.vType <> TVStr
          THEN BEGIN CmdError('Invalid variable type assignment to STRING variable');
             fOK := FALSE;
            END
          ELSE
              BEGIN
              pstr := pvarRec^.vHStr^;
              fOK := TRUE;
{$IFC IMCompile }
              IF fICompile THEN IF fCompile THEN
                  WRITELN(icFile, 'CGetStrVar(''', cchr, ''');');
{$ENDC }
              END;
     END
  ELSE IF cchr <> '('
    THEN fOK := FALSE
    ELSE
      BEGIN
        StartArg;
        ccount := 0;
        cptr := POINTER(ORD(pstr));
   200: cchr := ReadScriptChar;
        IF (cchr = ArgEndChar) THEN IF EndArg THEN GOTO 900;
          { THEN BEGIN fOK := TRUE; cptr^[0] := ccount; GOTO 900; END; }
        IF ccount = maxlen THEN GOTO 900;
          { THEN BEGIN fOK := TRUE; cptr^[0] := ccount; GOTO 900; END; }
        ccount := ccount + 1;
        cptr^[ccount] := ORD(cchr);
        GOTO 200;
   900: fOK := TRUE;
        cptr^[0] := ccount;
{$IFC IMCompile }
        IF fICompile THEN IF fCompile THEN
            WRITELN(icFile, icNameStrArg, ' := ''', pstr^, ''';');
{$ENDC }
      END;
  ArgStr := fOK;
  FinishArg;
{$IFC IMCompile }
  IF fICompile THEN icNameStrArg := 'cargStr';
{$ENDC }
  IF IMScrTst THEN
    IF fOK
      THEN WRITELN('ArgStr sets  ', ORD(pstr), ' to ', pstr^)
      ELSE WRITELN('ArgStr fails - cannot set ', ORD(pstr));
END;


{$S imscw }
FUNCTION ArgBool; {(VAR bool: TF): TF;}
LABEL 900;
VAR cchr: CHAR;
    pvarRec: TPVarRec;
    fOK: TF;
BEGIN
  cchr := ReadUCScriptChar;
  IF (cchr = 'U') OR (cchr = 'V')
    THEN BEGIN
      pvarRec := GetVarRec(cchr);
      IF pvarRec = NIL
        THEN fOK := FALSE
        ELSE IF pvarRec^.vType <> TVBool
          THEN BEGIN CmdError('Invalid variable type assignment to BOOLEAN variable');
             fOK := FALSE;
            END
          ELSE
              BEGIN
              bool := pvarRec^.vBool;
              fOK := TRUE;
              {$IFC IMCompile } IF fICompile THEN  WRITELN(icFile, 'CGetBoolVar(''', cchr, ''');'); {$ENDC }
              END;
     END
  ELSE IF cchr <> '('
    THEN fOK := FALSE
    ELSE
      BEGIN
        StartArg;
        cchr := ReadScriptChar;
        IF (cchr = ArgEndChar) THEN IF EndArg
          THEN BEGIN fOK := FALSE; GOTO 900; END;
        IF (cchr = 'T') OR (cchr = 't')
          THEN BEGIN fOK := TRUE; bool := TRUE; END
          ELSE IF (cchr = 'F') OR (cchr = 'f')
                 THEN BEGIN fOK := TRUE; bool := FALSE; END
                 ELSE fOK := FALSE;
      END;
900:
  ArgBool := fOK;
  {$IFC IMCompile } IF fICompile THEN  WRITELN(icFile, 'cargBool := ', bool, ');'); {$ENDC }
  FinishArg;
  IF IMScrTst THEN
    IF fOK
      THEN WRITELN('ArgBool sets  ', ORD(@bool), ' to ', cchr)
      ELSE WRITELN('ArgBool fails - cannot set ', ORD(@bool), ' to ', cchr);
END;


{$S imscw }
FUNCTION GetVVar; {(varName: TKeyStr):TPVarRec;}
VAR pvarRec: TPVarRec;
BEGIN
  pvarRec := NIL;
  IF InExercise THEN
      pvarRec := POINTER(ORD(FindSrchTableRec(hExzVarTable, varName)));
  IF (InLesson) AND (pvarRec = NIL)
    THEN pvarRec := POINTER(ORD(FindSrchTableRec(hLessonVarTable, varName)));
  IF pvarRec = NIL
    THEN pvarRec := POINTER(ORD(FindSrchTableRec(hGlobalVarTable, varName)));
  IF IMtst THEN WRITELN('GetVVar for ', varName, ' found var rec:', ORD(pvarRec));
  GetVVar := pvarRec;
END;


{$S imscw }
FUNCTION FindVarRec; {(varSource: CHAR; VAR varName: TKeyStr): TPVarRec;}
VAR pvarRec: TPVarRec;
BEGIN
  pvarRec := NIL;
  CASE varSource OF
     'U': pvarRec := POINTER(ORD(FindSrchTableRec(hUserVarTable, varName)));
     'V': pvarRec := GetVVar(varName);
     OTHERWISE
         BEGIN
         CmdError('Assign must be to U(ser) or V(ariable).');
         END;
     END;
  IF IMtst THEN WRITELN('GetVar for ', varName, ' source: ', varSource,
                             ' found var rec:', ORD(pvarRec));
  FindVarRec := pvarRec;
END;


{$S imscw }
FUNCTION GetVarRec; {(varSource: CHAR):TPVarRec;}
VAR pvarRec: TPVarRec;
    varName: TKeyStr;
    s255: Str255;
BEGIN
  pvarRec := NIL;
  IF varSource = 'u' THEN varSource := 'U' ;
  IF varSource = 'v' THEN varSource := 'V' ;
  pvarRec := NIL;
  IF ArgStr(@varName, CKeySize, FALSE)
    THEN pVarRec := FindVarRec(varSource, varName)
    ELSE CmdError('Cant read variable name in GetVarRec');
  IF IMtst THEN WRITELN('GetVar for ', varName, ' source: ', varSource,
                             ' found var rec:', ORD(pvarRec));
{$IFC IMCompile }
  IF fICompile THEN
      BEGIN
      s255 := varName;
      CASE varSource OF
        'U': WRITELN(icFile, 'CFindUVarRec(', AddBufWord(s255):1, ');');
        'V': WRITELN(icFile, 'CFindVVarRec(', AddBufWord(s255):1, ');');
        END;
      END;
{$ENDC }
  GetVarRec := pvarRec;
END;


{$S imscw }
FUNCTION NewVarRec; {(varSource: CHAR; varName: TKeyStr;
                      varType: TVarType):TPVarRec;}
VAR pvarRec: TPVarRec;
    recN:    TC;
    hstr: THStr255;
    hst: THVarTable;
BEGIN
  pvarRec := NIL;
  IF varSource = 'u' THEN varSource := 'U' ;
  IF varSource = 'v' THEN varSource := 'V' ;
  IF varSource = 'U' THEN hst := hUserVarTable
  ELSE IF InExercise THEN hst := hExzVarTable
  ELSE IF InLesson   THEN hst := hLessonVarTable
  ELSE hst := hGlobalVarTable;
  pvarRec := POINTER(ORD(FindSrchTableRec(hst, varName)));
  IF pvarRec <> NIL
    THEN BEGIN
      IF IMtst THEN WRITELN('Redefining variable named: ', varName);
      IF (pVarRec^.vType = TVStr) THEN BEGIN
        IF IMtst THEN WRITELN('Freeing block for var string ', varName);
        FreeBk(IMHeap, POINTER(ORD(pVarRec^.vHStr)), tybkStd);
        pVarRec^.vHStr := NIL;
       END;
     END
    ELSE pvarRec := POINTER(ORD(NewSrchTableRec(POINTER(ORD(hst)), recN)));
  IF pvarRec = NIL THEN StrangeError('Ran out of entries in variable table.');
  IF IMtst THEN WRITELN('Creating var rec number ', recN, ' in table:', ORD(hst));
  WITH pvarRec^ DO
    BEGIN
      vKey := varName;
      vType := varType;
      IF varType = TVStr THEN
          BEGIN
          hstr := POINTER(ORD(HAllocate(IMHeap, 256)));
          vHStr := hstr;
          vHstr^^ := '';
          END;
    END;
  NewVarRec := pvarRec;
END;


{$S imscc }
PROCEDURE SetStrVar; {(VAR varName: TKeyStr; strVal: Str255;}
VAR pVarRec: TPVarRec;
    recIdx: TC;
    fNew: TF;
    hStr: THStr255;
BEGIN
  pVarRec := NewVarRec('V', varName, TVStr);
  hstr := POINTER(ORD(HAllocate(IMHeap, 256)));
  WITH pVarRec^ DO
    BEGIN
      vHStr := hstr;
      vHStr^^ := strVal;
      IF IMtst THEN WRITELN('Set (Defined) string variable ', varName,
                    ' to value: ', vHStr^^);
    END;
END;


{$S imscc }
PROCEDURE SetBoolVar; {(VAR varName: TKeyStr; boolVal: TF);}
VAR pVarRec: TPVarRec;
    recIdx: TC;
    fNew: TF;
BEGIN
  pVarRec := NewVarRec('V', varName, TVBool);
  WITH pVarRec^ DO
    BEGIN
      vBool := boolVal;
      IF IMtst THEN WRITELN('Defined bool variable ', varName,
                    ' with value: ', boolVal);
    END;
END;



{$S imscw }
PROCEDURE ClearVarTable; { (hvt: THVarTable); }
VAR i: TC;
    pvarRec: TPVarRec;
    hst: THSrchTable;
BEGIN
  hst := POINTER(ORD(hvt));
  IF IMtst THEN WRITELN('Clearing var table:', ORD(hvt));
  pvarRec := POINTER(ORD(NthSrchTableRec(hst, 1)));
  FOR i := 1 TO hst^^.stNRecs DO
    WITH pvarRec^ DO
      BEGIN
        IF vType = TVStr THEN
          BEGIN
            IF IMtst THEN WRITELN('Freeing block for var string ', vKey);
            FreeBk(IMHeap, POINTER(ORD(vHStr)), tybkStd);
          END;
        pvarRec := POINTER(ORD(pvarRec) + hst^^.stRecSize);
      END;
  ClearSrchTable(hst);
END;


{$S imscdbg }
PROCEDURE PrintVData; {(pvarRec: TPVarRec);}
VAR pStrVal: ^Str255;
    pBoolVal: ^TF;
    pIntVal: ^TC;
    pCharVal: ^CHAR;
BEGIN
  IF pvarRec = NIL THEN WRITELN('No value record from which to print the data')
    ELSE BEGIN
      CASE pvarRec^.vType OF
        TVChar: BEGIN WRITE(pvarRec^.vChar); END;
        TVInt: BEGIN WRITE(pvarRec^.vInt); END;
        TVStr: BEGIN WRITE(pvarRec^.vHStr^^); END;
        TVBool: BEGIN WRITE(pvarRec^.vBool); END;
      END;
     END;
END;


{$S imscw }
FUNCTION GetBoolVar; {(varName: TKeyStr; noFindResult: TF; VAR foundFlag: TF): TF;}
VAR pvarRec: TPVarRec;
BEGIN
  pvarRec := GetVVar(varName);
  IF (pvarRec = NIL) OR (pvarRec^.vType <> TVBool)
    THEN BEGIN
           GetBoolVar := noFindResult;
           IF IMtst THEN WRITELN('GetBoolVar for ', varName,
                                 ' cant find var - returns: ', noFindResult);
           foundFlag := FALSE;
         END
    ELSE BEGIN
           GetBoolVar := pvarRec^.vBool;
           IF IMtst THEN WRITELN('GetBoolVar for ', varName,
                                 ' returns: ', pvarRec^.vBool);
           foundFlag := TRUE;
         END;
END;


{$S imsch }
PROCEDURE PopLoopRec;
VAR floop: THLoopRec;
BEGIN
  IF hTopLoopRec <> NIL
    THEN
      BEGIN
        floop := hTopLoopRec;
        hTopLoopRec := hTopLoopRec^^.pNextLoop;
        FreeBk(IMHeap, POINTER(ORD(floop)), tybkStd);
      END;
END;


{$S imsch }
PROCEDURE ClearLoops;
BEGIN
  WHILE hTopLoopRec <> NIL DO PopLoopRec;
END;


{$S imsch }
PROCEDURE PopAllBlocks;
VAR freeBlock: THBlockRec;
BEGIN
  fTest := FALSE;
  IF IMtst THEN WRITELN('Popping all block records. fTest set to FALSE.');
  WHILE TopBlock <> NIL DO
    BEGIN
      freeBlock := TopBlock;
      TopBlock := TopBlock^^.blkNext;
      FreeBk(IMHeap, POINTER(ORD(freeBlock)), tybkStd);
    END;
END;


{$S imscc }
PROCEDURE ClearGTables;
BEGIN
  IF IMtst THEN WRITELN('Clearing Global Tables');
  ClearVarTable(hUserVarTable);
  ClearVarTable(hGlobalVarTable);
  ClearSrchTable(hLessonLocTable);
END;


{$S imsch }
PROCEDURE ClearLTables;
BEGIN
  IF IMtst THEN WRITELN('Clearing Lesson Tables');
  ClearVarTable(hLessonVarTable);
  ClearSrchTable(hExzLocTable);
  IF sDebug THEN curLesson := '';
  PopAllBlocks;
END;


{$S imsch }
PROCEDURE ClearETables;
BEGIN
  IF IMtst THEN WRITELN('Clearing Exercise Tables');
  ClearVarTable(hExzVarTable);
  ClearSrchTable(hBlockLocTable);
  ClearSrchTable(hTagLocTable);
  ClearLoops;
  IF sDebug THEN curExercise := '';
  PopAllBlocks;
END;


{$S imsch }
PROCEDURE ClearBTables;
BEGIN
  IF sDebug THEN curBlock := '';
END;


{$S imscdbg }
PROCEDURE PrintSkipStuff;
BEGIN
  WRITELN('fSkip: ', fSkip, ' skiptype: ', skipType, ' skipNext: ', skipNext);
  WRITELN('skipName: ', skipName, ' skipEndType: ', skipEndType,
              '  skipToEnd: ', skipToEnd);
  WRITELN('skipExzName: ', skipExzName, ' skipBlkName: ', skipBlkName);
END;

{$S imsch }
PROCEDURE ClearSkips;
BEGIN
  skipName := '';
  skipExzName := '';
  skipBlkName := '';
  skipNext := FALSE;
  skipType := 'B';
  skipEndType := 'E';
  skipToEnd := FALSE;
  fSkip := FALSE;
END;


{$S imsch }
PROCEDURE GoLoc; { (blkType: CHAR; toName: TKeyStr); }
VAR plocRec: TPLocRec;
    fOK: TF;
BEGIN
  pLocRec := LookupLoc(blkType, toName);
  IF pLocRec = NIL
    THEN BEGIN
       IF cDebug THEN WRITELN('GoLoc block to name: ', blkType, ' - ',
                               toName,' cant find locRec');
     END
    ELSE BEGIN
      IF cDebug THEN WRITELN('GoLoc block to name: ', blkType, ' - ',
                             toName, ' PosRec: ', ORD(pLocRec));
      fOK := IMFSetPos(PIMFS, plocRec^.vStartPos);
      IF NOT fOK THEN CmdError('Cant get to saved position in file')
        ELSE BEGIN
          IF cDebug THEN
            WRITELN('Jumping to named block: ', toName, ' of type: ', blkType);
          CommandDone;
          CASE blkType OF
            'L': BEGIN { end Lesson }
                   InLesson := FALSE;
                   ClearBTables;
                   ClearETables;
                   ClearLTables;
                   curLesson := toName;
                 END;
            'E': BEGIN { end Exercise }
                   InExercise := FALSE;
                   ClearBTables;
                   ClearETables;
                   curExercise := toName;
                 END;
            'B': BEGIN { end Block }
                   ClearBTables;
                   curBlock := toName;
                 END;
            END;
           NewScriptLine;
           IF PeekUCScriptChar <> 'B'
             THEN IF NOT FixLocMap(locMapFile, 416)
                THEN IF cDebug THEN WRITELN('Cant fix loc map');
         END;
    END;
END;


{$S imsch }
PROCEDURE SkipTo; { (bType: CHAR; tName: TKeyStr); }
BEGIN
  PopAllBlocks;
  ClearSkips;
  skipType := bType;
  skipEndType := GetLimitType(bType);
  skipName := tName;
  fSkip := TRUE;
  IF IMtst THEN WRITELN('Setting up skip to ', bType, ' named: ', tName);
  GoLoc(bType, tName);
END;


{$S imsch }
PROCEDURE StopSkip;
BEGIN
  IF skipExzName <> ''
    THEN BEGIN
      SkipTo('E', skipExzName);
      skipExzName := '';
      IF IMtst THEN PrintSkipStuff;
     END
  ELSE IF skipBlkName <> ''
    THEN BEGIN
      SkipTo('B', skipBlkName);
      skipBlkName := '';
      IF IMtst THEN PrintSkipStuff;
     END
  ELSE BEGIN
    IF IMtst THEN WRITELN('Forward skip ended.');
    fSkip := FALSE;
    ClearSkips;
    IF doReset
      THEN BEGIN
        fWait := resWait;
        IF resetPos <> 0
          THEN IF NOT IMFSetPos(PIMFS, resetPos)
            THEN IF sDebug
              THEN WRITELN('Cant reset file position after BuildLocMap');
        ClrResetPos;
      END;

   END;
END;


{$S imsch }
PROCEDURE SkipBlk; { (VAR lName, eName, bName: TKeyStr): FORWARD; }
BEGIN
  PopAllBlocks;
  ClearSkips;
  IF lName <> ''
    THEN BEGIN
      skipType := 'L';
      skipName := lName;
      skipExzName := eName;
      skipBlkName := bName;
     END
    ELSE IF eName <> ''
      THEN BEGIN
        skipType := 'E';
        skipName := eName;
        skipBlkName := bName;
       END
    ELSE IF bName <> ''
      THEN BEGIN
        skipType := 'B';
        skipName := bName;
       END
    ELSE BEGIN
      IF DoReset THEN StopSkip;
      EXIT(SkipBlk);
     END;
  skipEndType := GetLimitType(skipType);
  fSkip := TRUE;
  IF IMtst THEN PrintSkipStuff;
  GoLoc(skipType, skipName);
END;


{$S imsch }
FUNCTION GetLocTable; {(blkType: CHAR): THLocTable;}
BEGIN
  CASE blkType OF
    'L': GetLocTable := hLessonLocTable;
    'E': GetLocTable := hExzLocTable;
    'B': GetLocTable := hBlockLocTable;
    'T': GetLocTable := hTagLocTable;
    OTHERWISE GetLocTable := NIL;
  END;
END;


{$S imscc }
FUNCTION BuildLocMap(VAR mapFile: PathName): TF;
CONST FileExists = 890;
      fstLocPos = 10;  { file position of first loc table }
VAR fErr: TC;
    iComplete: TC;
    tableSize, bytesWrit: TL;
    filePos: TL;
    stPos:   TFpos;
    pStPos:  TPFposRec;
BEGIN
   IF cDebug THEN WRITELN('BuildLocMap -  for file ', mapFile);
   BuildLocMap := FALSE;
   IF cDebug THEN WRITELN('BuildLocMap - already in progress for ', locMapFile);
   IF fMakeLocMap THEN EXIT(BuildLocMap);
   IF fOpenLocMap THEN BEGIN
      IF cDebug THEN WRITELN('BuildLocMap - closing existing');
      Close_Object(fErr, locMapRef);
      IF cDebug THEN IF (ferr <> 0)
        THEN WRITELN('BuildLocMap re-close error: ', fErr);
      IF fErr > 0 THEN EXIT(BuildLocMap);
     END;
   fFullLocMap := FALSE;
   Make_File(fErr, mapFile, 0);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('BuildLocMap Make_File error: ', fErr);
   IF fErr = FileExists
     THEN BEGIN
       IF IMScrTst THEN WRITELN('Overwriting lesson map "', mapFile, '"');
       fErr := 0;
      END;
   IF fErr > 0 THEN EXIT(BuildLocMap);
   OPEN(fErr, mapFile, locMapRef, [DRead, DWrite]);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('BuildLocMap open error: ', fErr);
   IF fErr > 0 THEN EXIT(BuildLocMap);
   fOpenLocMap := TRUE;
   locMapFile := mapFile;
   filePos := fstLocPos; { first table address }
   Write_Data(fErr, locMapRef, ORD4(@filePos), 4, bytesWrit, Absolute, 0);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('BuildLocMap write filePos error: ',fErr,' bytesWrit:',bytesWrit);
   IF fErr > 0 THEN EXIT(BuildLocMap);
   filePos := 0; { lesson table address }
   Write_Data(fErr, locMapRef, ORD4(@filePos), 4, bytesWrit, Absolute, 4);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('BuildLocMap write lesson Pos error: ', fErr);
   iComplete := 0; { comp[lete map flag }
   Write_Data(fErr, locMapRef, ORD4(@filePos), 2, bytesWrit, Absolute, 8);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('BuildLocMap write complete mark error: ', fErr);
   fMakeLocMap := TRUE;
   BuildLocMap := TRUE;
   IF cDebug THEN
     WRITELN('BuildLocMap Loc map "', mapFile, '" opened for writing, ref=',
              locMapRef);
   ClearSrchTable(hLessonLocTable);
   ClearSrchTable(hExzLocTable);
   ClearSrchTable(hBlockLocTable);
   IF wordBuf = NIL THEN NewWordBuf(cWBSize);
   KrunchScript(413);
END;


{$S imscc }
PROCEDURE DumpCmdChars;
{$IFC IMDebug }
LABEL 100, 200, 300;
VAR cchr: CHAR;
    syntxFid: TEXT;
    syntaxFile: Str255;
    ior: TC;
BEGIN
  IF NOT CautionAlert(imAlert, 418) THEN EXIT(DumpCmdChars);
  syntaxFile := 'IMSyntax.text';
  {$I- }
  REWRITE(syntxFid, syntaxFile);
  ior := IORESULT;
  IF (ior <> 0)
    THEN BEGIN
        WRITELN('DumpCmdChars:  rewrite setup file - ',
                      syntaxFile, ' err:', ior);
        EXIT(DumpCmdChars);
     END;
   ClearSrchTable(hLessonLocTable);
   ClearSrchTable(hExzLocTable);
   ClearSrchTable(hBlockLocTable);
   SaveResetPos;
   GoStartPos;
   SkipTo('L', 'no such lesson');
   fStepped    := FALSE;
   fWait       := FALSE;
   IMAlertUp;
   WaitAlert (imAlert, 413);
   lessonCounter := 1;
   CountAlert(9, lessonCounter);
100:  cchr := ReadUCScriptChar;
  IF cchr = ' ' THEN GOTO 100;
  WRITE(syntxFid, cchr);
    CASE cchr OF
      'B': BEGIN
            cchr := PeekUCScriptChar;
            IF (cchr = 'L') OR (cchr = 'E')
              THEN  BEGIN { begin exercise or lesson }
                cchr := ReadUCScriptChar;
                WRITE(syntxFid, cchr);
                cchr := PeekUCScriptChar;
                IF cchr = '('
                  THEN BEGIN
            300:    cchr := ReadUCScriptChar;
                    WRITE(syntxFid, cchr);
                    IF cchr <> ')' THEN GOTO 300;
                   END;
               END;
           END;
      'E': BEGIN
            cchr := PeekUCScriptChar;
            IF cchr = 'L'
              THEN  BEGIN { end of script }
                cchr := ReadUCScriptChar;
                WRITE(syntxFid, cchr);
                WRITELN(syntxFid);
                WRITELN(syntxFid, 'End of lesson ', lessonCounter);
                WRITELN;
                WRITELN('End of lesson ', lessonCounter);
                lessonCounter := lessonCounter + 1;
                CountAlert(9, lessonCounter);
               END;
            IF cchr = 'Z'
              THEN  BEGIN { end of script }
                cchr := ReadUCScriptChar;
                WRITE(syntxFid, cchr);
                WRITELN;
                WRITELN('End of script ');
                StopSkip;
                GOTO 200;
               END;
           END;
      '(': BEGIN StartArg; FinishArg; WRITE(syntxFid, ArgEndChar); END;
      '.': WRITELN(syntxFid);
    END;
   GOTO 100;
200:
   CLOSE(syntxFid, LOCK);
   ReadLessonLoc(locMapFile);
   EndKrunch;
   WRITELN;
{$ELSEC }
BEGIN
{$ENDC }
END;


{$S imscc }
FUNCTION MakeLocMap; {(mapFile: PathName): TF;}
BEGIN
  IF fMakeLocMap THEN BEGIN MakeLocMap := TRUE; EXIT(MakeLocMap); END;
  IF CautionAlert(imAlert, 415)
    THEN BEGIN
        MakeLocMap := BuildLocMap(mapFile);
     END
    ELSE BEGIN
      MakeLocMap := FALSE;
     END;

END;

{$S imscc }
FUNCTION FixLocMap; { (mapFile: PathName; alert: TC): TF; FORWARD; }
BEGIN
  fDumpSyntax := FALSE;
  IF fMakeLocMap THEN BEGIN FixLocMap := TRUE; EXIT(FixLocMap); END;
  IF CautionAlert(imAlert, alert) THEN
    FixLocMap := BuildLocMap(mapFile)
    ELSE FixLocMap := FALSE;
END;

{$S imscw }
PROCEDURE OpenLocMap; {(mapFile: PathName);}
VAR fErr: TC;
    iComplete: TC;
    bytesRead: TL;
BEGIN
   OPEN(fErr, mapFile, locMapRef, [DRead]);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('OpenLocMap open error: ', fErr);
   IF fErr > 0 THEN
     IF NOT fOpenLocMap THEN IF FixLocMap(mapfile, 416) THEN;
   IF fErr > 0 THEN EXIT(OpenLocMap);
   Read_Data(fErr, locMapRef, ORD4(@iComplete), 2,
             bytesRead, Absolute, 8);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('OpenLocMap read complete flag error: ', fErr,
                  ' iComplete: ', iComplete, ' bytesRead: ', bytesRead);
   fFullLocMap := (iComplete = -1);
   fOpenLocMap := TRUE;
   locMapFile := mapFile;
   IF cDebug THEN
     WRITELN('OpenLocMap "', mapFile, '" opened ref=', locMapRef);
END;

{$S imsch }
PROCEDURE ReadLocMap; {(filePos: TL; locTable: THLocTable);}
VAR fErr: TC;
    tableSize, bytesRead: TL;
BEGIN
   IF NOT fOpenLocMap THEN EXIT(ReadLocMap);
   IF cDebug THEN IF NOT fFullLocMap THEN
     WRITELN('Reading loc map when fFullLocMap is not set');
   IF filePos = 0 THEN EXIT(ReadLocMap);
   Read_Data(fErr, locMapRef, ORD4(locTable^), SIZEOF(TSrchTable),
             bytesRead, Absolute, filePos);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('ReadLocMap read table info error: ', fErr,
                  ' bytesRead: ', bytesRead);
   IF fErr > 0 THEN EXIT(ReadLocMap);
   tableSize := locTable^^.stRecSize;
   tableSize := tableSize * locTable^^.stNRecs;
   tableSize := tableSize + SIZEOF(TSrchTable);
   ReSizeSrchTable(locTable, locTable^^.stMaxRecs);
   IF cDebug THEN
     WRITELN('ReadLocMap - table: ', ORD(locTable),
             ' tableSize: ', tableSize, ' filePos: ', filePos);
   Read_Data(fErr, locMapRef, ORD4(locTable^), tableSize,
             bytesRead, Absolute, filePos);
END;

{$S imscc }
FUNCTION WriteLocMap; {(locTable: THLocTable): TC;}
VAR filePos: TL;
    fErr, fRef: TC;
    tableSize, bytesWrit: TL;
BEGIN
   WriteLocMap := 0;
   IF NOT fMakeLocMap THEN EXIT(WriteLocMap);
   Read_Data(fErr, locMapRef, ORD4(@filePos), 4,
             bytesWrit, Absolute, 0);
   IF cDebug THEN IF (ferr <> 0)
     THEN WRITELN('WriteLocMap read header error: ', fErr,
                  ' bytesWrit: ', bytesWrit);
   IF fErr > 0 THEN EXIT(WriteLocMap);
   tableSize := locTable^^.stRecSize;
   tableSize := tableSize * locTable^^.stNRecs;
   tableSize := tableSize + SIZEOF(TSrchTable);
   IF cDebug THEN
     WRITELN('WriteLocMap - table from: ', ORD(locTable),
             ' tableSize: ', tableSize, ' filePos:', filePos);
   Write_Data(fErr, locMapRef, ORD4(locTable^), tableSize,
              bytesWrit, Absolute, filePos);
   IF fErr > 0 THEN EXIT(WriteLocMap);
   IF cDebug THEN IF (ferr <> 0) THEN
     WRITELN('WriteLocMap - table: bytesWrit: ', bytesWrit, tableSize);
   IF (fErr <= 0) AND (bytesWrit=tableSize) THEN WriteLocMap := filePos;
   filePos := filePos+bytesWrit;
   Write_Data(fErr, locMapRef, ORD4(@filePos), 4,
              bytesWrit, Absolute, 0);
   IF cDebug THEN IF (ferr <> 0) THEN
     WRITELN('WriteLocMap - filePos: ', filePos, ' fErr:', fErr);
   IF (fErr <= 0) AND (bytesWrit=tableSize) THEN WriteLocMap := filePos;
END;

{$S imscw }
PROCEDURE ReadLessonLoc; { (lMapFile: PathName); }
CONST incLocMap = 417;
VAR filePos: TL;
    fErr: TC;
    bytesRead: TL;
BEGIN
   IF fMakeLocMap THEN EXIT(ReadLessonLoc);
   IF NOT fOpenLocMap THEN OpenLocMap(lMapFile);
   IF fMakeLocMap THEN EXIT(ReadLessonLoc);
   IF NOT fFullLocMap THEN BEGIN
      IF cDebug THEN
        WRITELN('ReadLessonLoc - The map not complete - remaking loc map');
      IF FixLocMap(lMapFile, incLocMap) THEN EXIT(ReadLessonMap);
     END;
   IF NOT fOpenLocMap
     THEN BEGIN
        IF sDebug THEN
          WRITELN('ReadLessonLoc - cant read or make loc map: ', lMapFile);
        EXIT(ReadLessonMap);
      END;
   Read_Data(fErr, locMapRef, ORD4(@filePos), 4, bytesRead, Absolute, 4);
   IF cDebug THEN IF (ferr <> 0) THEN
     WRITELN('ReadLessonLoc - filePos:', filePos, ' fErr: ', fErr);
   IF fErr <= 0 THEN ReadLocMap(filePos, hLessonLocMap);
END;

{$S imscc }
PROCEDURE WriteLessonLoc; { (mapComplete: TF); }
VAR filePos: TL;
    iComplete: TC;
    fErr: TC;
    bytesWrit: TL;
BEGIN
   IF NOT fMakeLocMap THEN EXIT(WriteLessonLoc);
   IF mapComplete THEN iComplete := -1 ELSE iComplete := 0;
   filePos := WriteLocMap(hLessonLocTable);
   Write_Data(fErr, locMapRef, ORD4(@filePos), 4,
              bytesWrit, Absolute, 4);
   IF cDebug THEN IF (ferr <> 0) THEN
     WRITELN('WriteLessonLoc - filePos:', filePos, ' fErr: ', fErr);
   Write_Data(fErr, locMapRef, ORD4(@iComplete), 2,
              bytesWrit, Absolute, 8);
   IF cDebug THEN IF (ferr <> 0) THEN
     WRITELN('WriteLessonLoc - complete flag:', iComplete, ' fErr: ', fErr);
   Compact(fErr, locMapRef);
   IF cDebug THEN IF (ferr <> 0) THEN
     WRITELN('WriteLessonLoc - Compact fErr: ', fErr);
   FLUSH(fErr, locMapRef);
   IF cDebug THEN IF (ferr <> 0) THEN
     WRITELN('WriteLessonLoc - FLUSH fErr: ', fErr);
   fMakeLocMap := FALSE;
   fFullLocMap := TRUE;
   fOpenLocMap := TRUE;
   ReadLessonLoc(locMapFile);
   IF cDebug THEN
     WRITELN('WriteLessonLoc - complete flag:', iComplete,' makeLocMap complete');
   EndKrunch;
END;

{$S imscw }
PROCEDURE CloseLocMap;
VAR fErr: TC;
BEGIN
  IF fMakeLocMap
    THEN BEGIN
      WriteLessonLoc(FALSE);
      Compact(fErr, locMapRef);
      IF cDebug THEN IF (ferr <> 0)
        THEN WRITELN('CloseLocMap locMapRef: ',locMapRef,' compact error: ',fErr);
    END;
  Close_Object(fErr, locMapRef);
  IF cDebug THEN IF (ferr <> 0)
    THEN WRITELN('CloseLocMap locMapRef: ', locMapRef, ' close error: ', fErr);
  fOpenLocMap := FALSE;
  fFullLocMap := FALSE;
  fMakeLocMap := FALSE;
  fDumpSyntax := FALSE;  { intl fix 9 }
  locMapRef   := 0;
END;

{$S imsch }
FUNCTION GetLimitType; {(srchType: CHAR): CHAR;}
BEGIN
  CASE srchType OF
    'B', 'T', 'P': GetLimitType := 'E';
    'E': GetLimitType := 'L';
    'L': GetLimitType := 'Z';
    OTHERWISE StrangeError('Invalid block search type in GetLimitType');
  END;
END;

{$S imsch }
FUNCTION LookupLoc; {(blkType: CHAR; blkName: TKeyStr): TPLocRec;}
VAR plocRec: TPLocRec;
    recNum: TC;
BEGIN
  plocRec := POINTER(ORD(
               FindNthSrchTableRec(GetLocTable(blkType), blkName, recNum)));
  IF IMtst THEN WRITELN('LookupLoc(', blkType, ', ', blkName, ') returns ',
                                  ORD(plocRec));
{$IFC IMCompile }
  IF fICompile THEN icLocNumber := recNum;
{$ENDC }
  LookupLoc := plocRec;
END;

{$S imsch }
PROCEDURE SetStartLoc; {(btype: CHAR; bname: TLocStr; bpos: TFpos);}
VAR pLocRec: TPLocRec;
    recN: TC;
BEGIN
  IF lessonCounter >= 0
    THEN IF btype = 'L'
      THEN BEGIN
        lessonCounter := lessonCounter+1;
        CountAlert(9, lessonCounter);
       END;
  plocRec :=  LookupLoc(btype, bname);
  IF plocRec = NIL
    THEN BEGIN
      IF cDebug THEN
        WRITELN('SetStartLoc - creating new loc rec for ', btype, ' ', bname);
      plocRec := POINTER(ORD(NewSrchTableRec(GetLocTable(btype), recN)));
      IF plocRec <> NIL
        THEN WITH plocRec^ DO BEGIN
           vKey := bname;
           vStartPos := bpos;
           vEndPos := 0;
           tablePos := 0;
           {$IFC IMCompile }
           blkNo := 0;
           nxtBlkNo := 0;
           {$ENDC }
           END
        ELSE CmdError('Cant get loc record for start loc-- Call Programmer!!!');
      END
     ELSE BEGIN
       IF IMScrTst THEN
         WRITELN('SetStartLoc - found existing loc rec for ', btype, ' ', bname);
       IF pLocRec^.vStartPos = bpos
         THEN BEGIN
           IF fFullLocMap THEN BEGIN
             IF btype = 'L'
                THEN ReadLocMap(plocRec^.tablePos, hExzLocTable)
             ELSE IF btype = 'E'
                THEN ReadLocMap(plocRec^.tablePos, hBlockLocTable);
            END;
           IF cDebug THEN
             WRITELN('SetStartLoc again for ', btype, ' ', bname);
          END
         ELSE WITH plocRec^ DO BEGIN
           IF sDebug THEN
             CASE btype OF
              'L': CmdError('Duplicate lesson name ');
              'E': CmdError('Duplicate exercise name ');
              'B': CmdError('Duplicate block name ');
              END;
           vKey := bname;
           vStartPos := bpos;
           vEndPos := 0;
           tablePos := 0;
          END;
      END;
  IF IMScrTst THEN WRITELN('SetStartLoc(', bType, ', ', bname, ') saved in locrec ',
                         recN, '(', ORD(plocRec), ')');
END;

{$S imsch }
PROCEDURE SetEndLoc; {(btype: CHAR; bname: TKeyStr; bpos: TFpos);}
VAR pLocRec: TPLocRec;
BEGIN
  plocRec := LookupLoc(btype, bname);
  IF IMtst THEN WRITELN('SetEndLoc(', bType, ', ', bname, ') saved in locrec ',
                                  ORD(plocRec));
  IF plocRec <> NIL
    THEN WITH pLocRec^ DO BEGIN
      vEndPos := bpos;
      IF fMakeLocMap THEN IF tablePos = 0
        THEN BEGIN
          IF bType = 'L'  THEN tablePos := WriteLocMap(hExzLocTable)
          ELSE IF bType = 'E' THEN tablePos := WriteLocMap(hBlockLocTable);
         END;
     END
    ELSE CmdError('Cant find Begin with same name and type.');
END;


{$S imsch }
PROCEDURE GobbleCmd; {(curChar: CHAR; errMsg: Str255); }
  { used in OTHERWISE case by commands with repeat loops to eat many subcommands }
BEGIN
  CASE curChar OF
    ' ': BEGIN END;
    '(': BEGIN
           IF sDebug THEN WRITE(errMsg);
           CmdError(' argument.');
           StartArg;
           FinishCommand;
          END;
    '.': CommandDone;
    OTHERWISE BEGIN
           IF sDebug THEN WRITE(errmsg);
           CmdError(' sub command.');
           FinishCommand;
          END;
  END;
END;


{$S imscdbg }
PROCEDURE InvalidCmdChar; {(curChar: CHAR; errMsg: Str255); }
BEGIN
  CASE curChar OF
    '(': BEGIN CmdError(errMsg); StartArg; FinishArg; END;
    '.': BEGIN CmdError(errMsg); CommandDone; END;
    OTHERWISE BEGIN CmdError(errMsg);  END;
  END;
END;


END.





