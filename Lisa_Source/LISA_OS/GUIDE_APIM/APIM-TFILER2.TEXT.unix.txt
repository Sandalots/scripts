
{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}


{$S Filer }
FUNCTION Makeobject{* father:      ObjectHandle;
                      nam:         FmaxStr;
                      whatKind:    ObjectKind;
                      whatSubKind: ObjectKind;
                      where:       Point;
                      windRect:    Rect;
                      newState:    ObjectState;
                      whichVol:    TentryHdl;
                      recId:       TcatRID;
                      createTime:  LongInt;
                      modTime:     LongInt;
                      diskSize:    LongInt;
                      filed:       BOOLEAN): ObjectHandle *};

{ Allocate a new object and insert at the head of contents. }
{ Does not draw it }

VAR thisObject: ObjectHandle;
    listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('MakeObject');
IF father^^.contents = nilObject THEN   { add head/tail node if empty list }
   father^^.contents := NewObjList(father);

listHead := father^^.contents;

thisObject := Pointer(ORD(NewHandle(SizeOf(FObject))));
{ if we want to use current time for create times. -gb }
{ createTime := TIME; }

WITH thisObject^^ DO
   BEGIN
   prev        := listHead;
   next        := listHead^^.next;
   prev^^.next := thisObject;
   next^^.prev := thisObject;
   name        := nam;
   loc         := where;
   kind        := whatKind;
   subKind     := whatSubKind;
   volHdl      := whichVol;
   catRID      := recID;
   state       := newState;
   isFiled     := filed;
   isOpen      := FALSE;
   dirty       := FALSE;
   wasOpened   := FALSE;
   toBeCopied  := FALSE;
   container   := father;
   contents    := nilObject;
   objWindow  := NIL;
   hThumbPos   := 0;
   vThumbPos   := 0;
   created     := createTime;
   modified    := modTime;
   size        := diskSize;
   viewMode    := spatialView;
   windowRect  := windRect;
   SetRect(nameRect,0,0,0,0);     { gets set by DrawName }
   imFldr      := NIL;
   objSerial   := nextObjSer;
   END;

MakeObject:=thisObject;
END;



{$S FilerLow }
PROCEDURE MakePadContents{* obj: ObjectHandle; whichState: ObjectState *};
{ change selected documents/folders into a pads and redraw }
VAR son,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('MakePadContents "',obj^^.name,'"');
listHead:=obj^^.contents;
son:=listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF Abort THEN Exit(MakePadContents);
   IF son^^.state=whichState THEN
      BEGIN
      son^^.dirty:=TRUE;
      IF son^^.kind = folderKind THEN
         BEGIN
         {*** make sure all descendants are filed ***}
         son^^.kind := folderPad;
         END
      ELSE IF son^^.kind = docKind THEN
         BEGIN
         IF RunningDoc(son) THEN    { shut down doc first }
            IF NOT StopDoc(son,TRUE,FALSE) THEN EXIT(MakePadContents);
         son^^.kind := docPad;
         END;
      FlushObject(son);
      IF obj^^.viewMode = spatialView THEN
         ValidIcon(son,FALSE)
      ELSE
         DrawObject(son);
      END;
   son:=son^^.prev;
   END;
END;



{$S  }
FUNCTION Match{* target: ObjectHandle; srcSet: KindSet; srcCount: INTEGER): BOOLEAN *};
{ returns true if OK to hilite target }
BEGIN
IF trcFiler THEN WRITELN('Match "',target^^.name,'"');

Match:=FALSE;

{ first check that this transfer is legal for each selected object }
IF NOT (srcSet <= matchTable[target^^.kind]) THEN EXIT(Match);

{ reject movement of a disk plus anything else }
IF srcCount > 1 THEN IF srcSet*diskSet <> [] THEN EXIT(Match);

IF target^^.toBeCopied THEN EXIT(Match);

{ now check further, e.g., does diskette have enough room on it }
Match:=TRUE;
END;



{$S Filer }
PROCEDURE MenuCommand{* menu,item: INTEGER *};
VAR bootDevName: FMaxStr;
    err: INTEGER;
    obj,nextObj,diskObj: ObjectHandle;
    volHdl: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('MenuCommand');
SetPort(activeFolder);
CASE menu OF

   filingMenu:

      CASE item OF

         mOpen:
            BEGIN
            OpenContents(activeObject,hilited);
            TopActive;
            END;

         mClose:
            BEGIN
            IF AsideObject(activeObject,FALSE) THEN;
            TopActive;
            END;

         mCloseAll:
            BEGIN
            IF AsideContents(deskObject) THEN;
            TopActive;  { ensure that filer is active }
            END;

         mPutBack:
            BEGIN
            IF activeObject = deskObject THEN
               BEGIN
               IF PutBackContents(deskObject,[hilited],FALSE) THEN;
               END
            ELSE
               IF NOT PutBackObject(activeObject,FALSE,FALSE) THEN;
            TopActive;
            END;

         mDuplicate:
            DupContents(activeObject,hilited);

         mNew:
            TearOffContents(activeObject,hilited);

         mMakePad :
            MakePadContents(activeObject,hilited);

         END;  { case item }


   editMenu:
      EditCommands(item);


   viewMenu:
      CASE item OF
         mAlpha:
            ChangeView(activeObject,alphaView);
         mChron:
            ChangeView(activeObject,chronView);
         mSpatial:
            ChangeView(activeObject,spatialView);
         END;


   diskMenu:
      CASE item OF
         mRepair:
            IF OneDiskSelected(diskObj) THEN RepairDisk(diskObj);
         mErase:
            IF OneDiskSelected(diskObj) THEN EraseDisk(diskObj);
         END;


{$IFC filerDebug }
   specialMenu:
      BEGIN
      CASE item OF

          mTrcAll:
             BEGIN
             eventDebug  := TRUE;
             trcFEntry   := TRUE;
             trcCatalog  := TRUE;
             trcFDocCtrl := TRUE;
             trcFVolCtrl := TRUE;
             trcFiler    := TRUE;
             TraceDB(TRUE);
             {
             SetFldTest(TRUE);
             }
             END;

          mTrcOff:
             BEGIN
             eventDebug  := FALSE;
             trcFEntry   := FALSE;
             trcCatalog  := FALSE;
             trcFDocCtrl := FALSE;
             trcFVolCtrl := FALSE;
             trcFiler    := FALSE;
             TraceDB(FALSE);
             {$IFC fDbgOK }
             SetFldTest(FALSE);
             {$ENDC }
             END;

          mTrcEvents:   eventDebug  := NOT eventDebug;
          mTrcFEntry:   trcFEntry   := NOT trcFEntry;
          mTrcCatalog:  trcCatalog  := NOT trcCatalog;
          mTrcFDocCtrl: trcFDocCtrl := NOT trcFDocCtrl;
          mTrcFVolCtrl: trcFVolCtrl := NOT trcFVolCtrl;
          mTrcFiler:    trcFiler    := NOT trcFiler;

          mPrintDocs :
             PrintEntry(doc,NIL);
          mPrintVols :
             PrintEntry(vol,NIL);
          mPrintTools :
             PrintEntry(tool,NIL);
          mPrintDevs :
             PrintEntry(dev,NIL);

          mSetTime:
             BEGIN
{$IFC R}
             SetTimeDialog;
{$ENDC}
             END;

          {$IFC filerDebug }
            mCheckHeap:
               wantCheckHeap := NOT wantCheckHeap;
          {$ENDC }

          mWantSound:
             wantSound := NOT wantSound;

          mWantAutoSize:
             wantAutoSize := NOT wantAutoSize;

          mBootInOut:        {*** FL ***}
             BEGIN
{$IFC R}
             IF bootOut THEN
                BEGIN
                MountVol(err,bootVol^^.devHdl^^.device,volHdl);
                IF err = 0 THEN NoteAlert (flrAlert,258);
                END
             ELSE
                BEGIN
                GetObjName(bootVol,diskCatRID,bootDevName);
                ParamAlert (bootDevName,'','');
                IF CautionAlert(flrAlert,257) THEN BootVolDismount(err);
                END;
{$ENDC}
             END;

          mQuit:
             ShutDown;

         END;  { case item }

      CheckItem(flrMenus[specialMenu],mTrcEvents,eventDebug);
      CheckItem(flrMenus[specialMenu],mTrcFEntry,trcFEntry);
      CheckItem(flrMenus[specialMenu],mTrcCatalog,trcCatalog);
      CheckItem(flrMenus[specialMenu],mTrcFDocCtrl,trcFDocCtrl);
      CheckItem(flrMenus[specialMenu],mTrcFVolCtrl,trcFVolCtrl);
      CheckItem(flrMenus[specialMenu],mTrcFiler,trcFiler);
      CheckItem(flrMenus[specialMenu],mCheckHeap,wantCheckHeap);
      CheckItem(flrMenus[specialMenu],mWantSound,wantSound);
      CheckItem(flrMenus[specialMenu],mWantAutoSize,wantAutoSize);
      {$IFC R}
      CheckItem(flrMenus[specialMenu],mBootInOut,bootOut);
      {$ENDC}
      END;
{$ENDC }

   END;  { case menu }

END;



{$IFC R}
{$S DiskStuff }
PROCEDURE MountAvolume{* device: Tdevice *};
{ mounts the volume and restores the desktop }
VAR err: INTEGER;
    volHdl: TentryHdl;
    diskObj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('MountAvolume');
MountVol(err,device,volHdl);
IF err = 0 THEN
   BEGIN
   SetDeSelAll;  { causes a deSelect all event if any selected -gb }
   ChangeContents(deskObject,hilited,normal,0,0,TRUE);   { deselect all }
   RestoreDesktop(volHdl,diskObj);
   SelectObject(diskObj,FALSE);
   END
ELSE
   DismountVol(device,TRUE,FALSE);  { mount failed, eject if diskette }
END;
{$ENDC}



{$S Filer }
FUNCTION  MoveContents{* obj:        ObjectHandle;
                         whichState: ObjectState;
                         newState:   ObjectHandle;
                         dh,dv:      INTEGER;
                         dstObject:  ObjectHandle;
                         chooseLoc:  BOOLEAN;
                         eraseDim:   BOOLEAN;
                     VAR anyMoved:   BOOLEAN): BOOLEAN *};
{ move all objects matching whichwhichState to the destination }
VAR son,nextSon,listHead,topObject: ObjectHandle;
    tallyCount: INTEGER;
    tallySet: KindSet;
    tallyBBox: Rect;
    localDh,localDv: INTEGER;
    savePort: GrafPtr;
    pt: Point;
    diskObj: ObjectHandle;
    failVol: TentryHdl;
    dstIsSpatial: BOOLEAN;
BEGIN
IF trcFiler THEN WRITELN('MoveContents "',obj^^.name,'" to "',
                                          dstObject^^.name,'"');
MoveContents := FALSE;
anyMoved := FALSE;
listHead:=obj^^.contents;
TallyContents(obj,whichState,tallyCount,tallySet,tallyBBox,topObject);
IF tallyCount = 0 THEN
   BEGIN
   MoveContents := TRUE;
   EXIT(MoveContents);
   END;

{ de-select all others in destination }
SetDeSelAll;  { causes a deSelect all event if any selected -gb }
ChangeContents(dstObject,hilited,normal,0,0,TRUE);

IF dstObject^^.isOpen AND (NOT chooseLoc) THEN
   BEGIN
      { determine dh,dv for location in new window }
   SetPt(pt,dh,dv);
   GetPort(savePort);
   SetPort(obj^^.objWindow);
   LocalToGlobal(pt);
   SetPort(dstObject^^.objWindow);
   GlobalToLocal(pt);
   SetPort(savePort);
   localDh:=pt.h;
   localDv:=pt.v;
   END
ELSE
   BEGIN
   localDh := 0;
   localDv := 0;
   END;

CASE dstObject^^.kind OF

   trashKind:   { empty appropriate trash cans first }
      BEGIN
      IF copyMode THEN    { Just destroy duplicates.  Don't empty trash can }
         BEGIN
         XorContents(obj,whichState,dh,dv);  { erase dim images }
         KillDuplicates(obj);   { dispose of pseudo-objects }
         anyMoved := FALSE; { LisaGuide nr bug #6 fixed 3/2/83 -gb (was TRUE) }
         MoveContents := TRUE;
         Exit(MoveContents);
         END;
      son:=listHead^^.next;
      WHILE son <> listHead DO
         BEGIN
         IF son^^.state=whichState THEN EmptyTrashCan(son^^.volHdl,TRUE);
         son:=son^^.next;
         END;
      END;

   printKind:
      BEGIN
      END;

   diskKind,disk1Kind,disk2Kind,profileKind,folderKind:
      BEGIN     { make sure there's room on dest vol }
      IF NOT RoomForContents(obj,whichState,dstObject^^.volHdl,failVol) THEN
         BEGIN
         diskObj := ObjFromVol(failVol);
         ParamAlert(diskObj^^.name,'','');
         StopAlert(flrAlert,105);   { Not enough room on destination ... }
         EXIT(MoveContents);
         END;
      END;

   deskKind:
      BEGIN
      IF copyMode THEN
         IF NOT RoomForContents(obj,whichState,obj^^.volHdl,failVol) THEN
            BEGIN
            diskObj := ObjFromVol(failVol);
            ParamAlert(diskObj^^.name,'','');
            StopAlert(flrAlert,102);   { Not enough room to copy ... }
            EXIT(MoveContents);
            END;
      END;

   END; { CASE }

dstIsSpatial := (dstObject^^.viewMode = spatialView);
son:=listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   nextSon:=son^^.next;
   IF son^^.state=whichState THEN
      BEGIN
      IF Abort THEN Exit(MoveContents);
      IF NOT MoveObject(son,dh,dv,dstObject,FALSE,chooseLoc,eraseDim) THEN
         EXIT(MoveContents);
      anyMoved := TRUE;
      {IF dstObject^^.isOpen THEN - removed for invisible objects -gb }
         ChangeObject(son,newState,localDh,localDv,dstIsSpatial);
      END;
   son:=nextSon;
   END;

MoveContents := TRUE;
END;



FUNCTION  MoveObject{* obj: ObjectHandle;
                       dh,dv: INTEGER;
                       dstObj: ObjectHandle;
                       redraw: BOOLEAN;
                       chooseLoc: BOOLEAN;
                       eraseDim: BOOLEAN): BOOLEAN *};
{ moves an object to a new container, returns TRUE if successful }
VAR err: INTEGER;
    newLoc: Point;
    placeObj: ObjectHandle;
    srcVol: TentryHdl;
    srcFather: IdType;
BEGIN
IF trcFiler THEN WRITELN('MoveObject "',obj^^.name,'" to "',dstObj^^.name,'"');
obj^^.dirty := TRUE;
MoveObject := FALSE;
srcVol := obj^^.volHdl;
srcFather := obj^^.catRID.fatherID;

IF dstObj = deskObject THEN
   BEGIN
   IF obj^^.container <> deskObject
    THEN BEGIN
      IF NOT MoveToDesk(obj) THEN EXIT(MoveObject);
     END;
   END
ELSE IF dstObj = trashObject THEN
   BEGIN
   IF NOT MoveToTrash(obj,dh,dv) THEN EXIT(MoveObject);
   END
ELSE IF srcVol = dstObj^^.volHdl THEN  { same volume }
   BEGIN
   IF NOT MoveToSameVol(obj,dstObj^^.catRID.uniqueID) THEN EXIT(MoveObject);
   END
ELSE
   BEGIN
   IF NOT MoveToDiffVol(obj,dstObj) THEN EXIT(MoveObject);
   END;

EndEdit;   { stop editing of current object }

IF obj^^.container^^.isOpen THEN  { invisible obj test -gb }
IF eraseDim THEN
   BEGIN
   XorObject(obj,dh,dv);
   IF dstObj <> deskObject THEN ValidObject(obj,FALSE);   { erases old image }
   END;

obj^^.isFiled := (dstObj <> deskObject);

IF chooseLoc THEN
   BEGIN
   ChoosePos(dstObj,newLoc);
   obj^^.loc := newLoc;
   SetHomePt(obj,newLoc);   { update catalog }
   END;

{ locate placeholder object to be destroyed }
IF dstObj <> deskObject THEN
   placeObj := GetPlaceHolder(obj)
ELSE
   placeObj := nilObject;


IF dstObj^^.isOpen OR TRUE {keep em all -gb } THEN
   BEGIN
   { if moving from list to spatial then set loc to list position so that
     object has correct loc when dh,dv added }
   IF NOT chooseLoc AND (obj^^.container^^.viewMode <> spatialView) AND
      (dstObj^^.viewMode = spatialView) THEN GetListPos(obj,FALSE,obj^^.loc);

   IF dstObj^^.contents = nilObject THEN
      dstObj^^.contents := NewObjList(dstObj); { create head/tail node }

   { install into the new object list }
   WITH obj^^ DO
      BEGIN
      { splice out at old location }
      prev^^.next:=next;
      next^^.prev:=prev;

      IF (placeObj <> nilObject) AND (srcVol = dstObj^^.volHdl) AND
         (srcFatherID = dstObj^^.catRID.uniqueID) THEN
         BEGIN     { splice back in at same location as before }
         prev:=placeObj^^.prev;
         next:=placeObj;
         prev^^.next:=obj;
         next^^.prev:=obj;
         END
      ELSE
         BEGIN    { splice back in at front of contents of destination object }
         prev:=dstObj^^.contents;
         next:=dstObj^^.contents^^.next;
         prev^^.next:=obj;
         next^^.prev:=obj;
         END;

      container:=dstObj;
      END;

   IF redraw AND dstObj^^.isOpen { only if dest open -gb }
     THEN DrawObject(obj);
   END
ELSE
   BEGIN
   KillObject(obj,TRUE,FALSE);
   END;

{ remove placeholder object }
IF fTstTF THEN WRITELN('Killing placeHolder object for ', placeObj^^.name, '"');
IF dstObj <> deskObject THEN KillObject(placeObj,FALSE,TRUE);
CCtObjEvt(obj);

MoveObject := TRUE;
END;



FUNCTION MoveToDesk{* obj: ObjectHandle): BOOLEAN *};
{ handles moving an object from a container to the desktop }
VAR newHomeLoc: Point;
    placeObj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('MoveToDesk "',obj^^.name,'"');
MoveToDesk := FALSE;
IF obj^^.toBeCopied THEN  { do postponed copy now }
   IF NOT copyObject(obj,FALSE) THEN EXIT(MoveToDesk);

{ If moving from trash can, change home of object to disk so "PutBack"
  doesn't return object to trash can }
IF obj^^.container = trashObject THEN
   BEGIN
   ValidObject(obj,FALSE);  { erase placeholder image }
   ChangeParentID(obj,idDisk);
   ChooseHome(obj,newHomeLoc);
   END
ELSE
   BEGIN    { leave a placeholder object behind }
   placeObj := Pointer(ORD(NewHandle(SIZEOF(FObject))));
   placeObj^^ := obj^^;
   WITH placeObj^^ DO
      BEGIN
      { splice placeholder into list }
      prev:=obj^^.prev;
      next:=obj;
      prev^^.next:=placeObj;
      next^^.prev:=placeObj;
      state := placeHolder;
      isOpen := FALSE;
      contents := nilObject;
      objWindow := NIL;
      toBeCopied := FALSE;
      isFiled := TRUE;
      dirty := TRUE;
      imFldr := NIL;  { imStuff -gb }
      END;
   END;

MoveToDesk := TRUE;
END;



{$S CopyStuff }
FUNCTION MoveToDiffVol{* obj,dstObj: ObjectHandle): BOOLEAN *};
{ handles moving an object to a container on a different volume }
VAR err: INTEGER;
    srcVol,dstVol: TentryHdl;
    srcCatRID,dstCatRID,newCatRID: TcatRID;
BEGIN
IF trcFiler THEN WRITELN('MoveToDiffVol');
MoveToDiffVol := FALSE;

ParamAlert (obj^^.name, dstObj^^.name, '');
WaitAlert(flrAlert, 100);  { 'transferring...' }
upTime := Time;

FlushObject(obj);  { make sure source record is current }

srcVol := obj^^.volHdl;
srcCatRID := obj^^.catRID;
dstVol := dstObj^^.volHdl;
dstCatRID := dstObj^^.catRID;

IF RunningDoc(obj) AND NOT obj^^.toBeCopied THEN
   BEGIN
{$IFC R}
   PutDocIn(err,srcVol,srcCatRID,dstVol,dstCatRID.uniqueID,newCatRID);
{$ENDC}
   IF err <> 0 THEN
      BEGIN           {*** FL ***}
      TellUser (srcVol,NIL,srcCatRID,srcCatRID,err);
      EXIT(MoveToDiffVol);
      END;
{ IF fTstTF THEN {added trace -gb }
  WRITELN('MoveToDiffVol - Disposing folder of object "', obj^^.name, '"');
HoldIt(cDebug);
   DisposeFolder(obj^^.objWindow);
   obj^^.objWindow := NIL;
   obj^^.wasOpened := FALSE;
   END
ELSE
   BEGIN
   { copy the object to the destination }
   XferObject(err,srcCatRID,dstCatRID.uniqueID,srcVol,dstVol,TRUE {exclude unfiled},
              NOT obj^^.toBeCopied,0,newCatRID);
   IF err <> 0 THEN
      BEGIN
      TellUser (srcVol,dstVol,srcCatRID,srcCatRID,err);   {*** FL ***}
      (***
      ParamAlert(obj^^.name,'','');
      StopAlert(flrAlert,104);
      ***)
      EXIT(MoveToDiffVol);
      END;
   MoveUnfiled(obj);  { unfiled descendants are moved to obj's container }
   END;


{ remove the source object, if obj isn't a temporary duplicate }
IF NOT obj^^.toBeCopied THEN ShredObject(srcVol,srcCatRID);

{ update the cached object catRID to reflect the new home }
obj^^.catRID := newCatRID;
obj^^.volHdl := dstVol;
obj^^.toBeCopied := FALSE;

RemoveAlert;
MoveToDiffVol := TRUE;
END;



{$S Filer }
FUNCTION MoveToSameVol{* obj: ObjectHandle; newParent: IDType): BOOLEAN *};
{ handles moving an object to a container on the same volume }
VAR err: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('MoveToSameVol "',obj^^.name,'"');
MoveToSameVol := FALSE;

IF obj^^.toBeCopied THEN    { do postponed copy now }
   BEGIN
   IF NOT copyObject(obj,FALSE) THEN EXIT(MoveToSameVol);
   END
ELSE IF RunningDoc(obj) THEN { shut down doc before moving }
   BEGIN
   IF NOT StopDoc(obj,FALSE,FALSE) THEN EXIT(MoveToSameVol);
   END
ELSE
   BEGIN END; { used to be -- MoveUnfiled(obj);}
   { lisa guide nr bug #7 3/3/83 -gb }

ChangeParentID(obj,newParent);
MoveToSameVol := TRUE;
END;



FUNCTION MoveToTrash{* obj: ObjectHandle; dh,dv: INTEGER): BOOLEAN *};
{ handles an object moved into the trash can }
VAR err: INTEGER;
    volHdl: TentryHdl;
    catRID: TcatRID;
BEGIN
IF trcFiler THEN WRITELN('MoveToTrash "',obj^^.name,'"');
MoveToTrash := FALSE;
{ "running" documents must be shut down first }
IF RunningDoc(obj) THEN
   BEGIN
   IF StopDoc(obj,TRUE {suspend},TRUE {must succeed}) THEN;
   END
ELSE
   MoveUnfiled(obj);

MoveToTrash := TRUE;
ChangeParentID(obj,idTrash);
END;



PROCEDURE MoveUnfiled{* obj: ObjectHandle *};
{ moves all unfiled descendants of obj to the container of obj }
VAR unfiledObj,nextUnfiled,listHead,placeObj: ObjectHandle;
    newHomeLoc: Point;
BEGIN
IF trcFiler THEN WRITELN('MoveUnfiled "',obj^^.name,'"');
IF NOT IsContainer(obj) THEN EXIT(MoveUnfiled);

listHead := deskObject^^.contents;
unfiledObj:=listHead^^.next;
WHILE unfiledObj <> listHead DO    { check all objects on desk }
   BEGIN
   nextUnfiled := unfiledObj^^.next;
   IF unfiledObj <> obj THEN
      IF unfiledObj^^.kind IN putBackSet THEN
         IF unfiledObj^^.volHdl = obj^^.volHdl THEN
            IF IsIn(obj^^.volHdl,unfiledObj,obj) THEN
               BEGIN
               KillObject(GetPlaceHolder(obj),FALSE,TRUE);
               ChangeParentID(unfiledObj,obj^^.catRID.fatherID);
               ChooseHome(unfiledObj,newHomeLoc);
               unfiledObj^^.dirty := TRUE;
               END;
   unfiledObj := nextUnfiled;
   END;
END;


{$S       }
FUNCTION NameWidth{* obj: ObjectHandle): INTEGER *};
{ Returns the width of the icon title }
VAR saveFont: INTEGER;
    saveFace: Style;
BEGIN
WITH thePort^ DO
   BEGIN
   saveFont := txFont;
   saveFace := txFace;
   END;
WITH obj^^ DO
   BEGIN
IF thePort = menuFolder THEN BEGIN
  WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
   IF container^^.viewMode = spatialView THEN
      TextFont(iconNamFont)
   ELSE
      TextFont(sysText);
   TextFace([]);
   NameWidth := StringWidth(name) + 4 {pad};
   END;
TextFont(saveFont);
TextFace(saveFace);
END;



{$S Filer }
FUNCTION NearList{* listHead: ObjectHandle; pt: Point): ObjectHandle *};
{ returns the topmost object near pt, nilObject if none }
VAR obj: ObjectHandle;
    hitRect: Rect;
BEGIN
IF trcFiler THEN WRITELN('NearList');

NearList:=nilObject;  { in case no hit }

SetRect(hitRect,pt.h-iconWidth,pt.v-iconHt,
                pt.h+iconWidth,pt.v+iconHt);

obj:=listHead^^.next;
WHILE obj <> listHead DO WITH obj^^ DO
   BEGIN
   IF PtInRect(loc,hitRect) THEN
      BEGIN
      NearList:=obj;
      EXIT(NearList);
      END;
   obj:=next;
   END;
END;



FUNCTION NewObjList{* father: ObjectHandle): ObjectHandle *};
{ create a new object list with no elements in it }
{ the node element also acts as the tail node }
VAR obj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('NewObjList');
IF wantCheckHeap THEN CheckHeap('NewObjList - before NewHandle');
obj:=Pointer(ORD(NewHandle(SizeOf(FObject))));
IF wantCheckHeap THEN CheckHeap('NewObjList - after NewHandle');

obj^^ := nilObject^^;
WITH obj^^ DO
   BEGIN
   name       := 'head/tail node';
   prev       := obj;   { the list is both the head and tail }
   next       := obj;
   container  := father;
   objSerial  := nextObjSer;
   END;
NewObjList:=obj;
END;



FUNCTION NewWindow{* obj: ObjectHandle; title: FmaxStr): WindowPtr *};
{ creates a window for an object.  Handles too many case. }
VAR window: WindowPtr;
BEGIN
IF trcFiler THEN WRITELN('NewWindow "',obj^^.name,'"');
window:= NewFolder(obj^^.windowRect,title,FALSE {hidden},dialogFolder,0,My_Id,
                   CloseSymbol(obj^^.kind), noIcon);
IF window = NIL THEN StopAlert (flrAlert, 206);  { Too many windows }
NewWindow:=window;
END;



FUNCTION NumFromObj{* obj: ObjectHandle): INTEGER *};
{ returns object sequence number given handle }
VAR son,listHead: ObjectHandle;
    objCount: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('NumFromObj "',obj^^.name,'"');
listHead := obj^^.container^^.contents;
son := listHead^^.prev;
objCount := 1;
WHILE son <> listHead DO
   BEGIN
   IF son = obj THEN
      BEGIN
      NumFromObj := objCount;
      EXIT(NumFromObj);
      END;
   objCount := objCount + 1;
   son := son^^.prev;
   END;
NumFromObj := 0;
END;



FUNCTION ObjFromNum{* container: ObjectHandle; objNum: INTEGER): ObjectHandle *};
{ returns handle to the objNumth object }
VAR son,listHead: ObjectHandle;
    objCount: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('ObjFromNum ',objNum:1);
listHead := container^^.contents;
son := listHead^^.prev;
objCount := 1;
WHILE son <> listHead DO
   BEGIN
   IF objNum = objCount THEN
      BEGIN
      ObjFromNum := son;
      EXIT(ObjFromNum);
      END;
   objCount := objCount + 1;
   son := son^^.prev;
   END;
ObjFromNum := nilObject;
END;



FUNCTION ObjFromVol{* volHdl: TentryHdl): ObjectHandle *};
{ return object handle of for a given volume handle }
BEGIN
IF trcFiler THEN WRITELN('ObjFromVol');
ObjFromVol := SearchContents(deskObject,volHdl,idDisk,FALSE);
END;



{$S  }
FUNCTION ObjFromWindow{* window : WindowPtr): ObjectHandle *};
{ Determines which object owns a given window }
VAR whichObj: ObjectHandle;

     FUNCTION TreeSearch(listHead : ObjectHandle): ObjectHandle;
     VAR obj,result: ObjectHandle;
     BEGIN
     TreeSearch:=nilObject;

     obj:=listHead^^.next;
     WHILE obj <> listHead DO   { travel down brother list }
        BEGIN
        IF obj^^.isOpen THEN
           IF (obj^^.objWindow = window) THEN
              BEGIN
              TreeSearch:=obj;
              EXIT(TreeSearch);
              END;
                    { check contents (sons) }
        result:=TreeSearch(obj^^.contents);
        IF result <> nilObject THEN
           BEGIN
           TreeSearch:=result;
           EXIT(TreeSearch);
           END;
        obj:=obj^^.next;
        END;
     END;

BEGIN
IF window = Nil THEN
   whichObj:=nilObject
ELSE IF window = filerFolder THEN
   whichObj:=deskObject
ELSE
   whichObj:=TreeSearch(deskObject^^.contents);

ObjFromWindow:=whichObj;

IF trcFiler THEN WRITELN('ObjFromWindow = "',whichObj^^.name,'"');
END;



{$S Filer }
PROCEDURE ObjToFront{* obj: ObjectHandle; redraw: BOOLEAN *};
{ bring an object to the front and re-draw }
VAR listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('ObjToFront "',obj^^.name,'"');
WITH obj^^ DO
   BEGIN
   IF container^^.viewMode = spatialView THEN
      BEGIN
      listHead:=container^^.contents;

      { splice out at old location }
      prev^^.next:=next;
      next^^.prev:=prev;

      { splice back in at front }
      prev:=listHead;
      next:=listHead^^.next;
      prev^^.next:=obj;
      next^^.prev:=obj;
      END;
   END;

IF redraw THEN DrawObject(obj);
END;



FUNCTION OnDesktop{* whichVol: TentryHdl; objID: IDType): BOOLEAN *};
{ searches desk list for an object }
VAR obj,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('OnDesktop.  vol: ',ORD(whichVol):1,'  id: ',objID:1);
listHead := deskObject^^.contents;
obj:=listHead^^.next;
WHILE obj <> listHead DO
   BEGIN
   IF (obj^^.volHdl = whichVol) AND (obj^^.catRID.uniqueID = objID) THEN
      BEGIN
      OnDesktop := TRUE;
      IF trcCatalog THEN WRITELN('   OnDeskTop = TRUE');
      EXIT(OnDesktop);
      END;
   obj:=obj^^.next;
   END;
OnDesktop:=FALSE;
IF trcFiler THEN WRITELN('   OnDeskTop = FALSE');
END;



{$S FilerLow }
FUNCTION OneDiskSelected{* VAR diskObj: ObjectHandle): BOOLEAN *};
{ returns true if the active window is a disk or if a single disk only is hilited }
VAR topObject: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('OneDiskSelected');
IF activeObject^^.kind IN diskSet THEN
   BEGIN
   OneDiskSelected := TRUE;
   diskObj := activeObject;
   EXIT(OneDiskSelected);
   END;

topObject := deskObject^^.contents^^.next;
WITH topObject^^ DO
   IF (state = hilited) AND (kind IN diskSet) AND (next^^.state <> hilited) THEN
      BEGIN
      OneDiskSelected := TRUE;
      diskObj := topObject;
      EXIT(OneDiskSelected);
      END;

OneDiskSelected := FALSE;
diskObj := nilObject;
END;



{$S Filer }
PROCEDURE OpenContents{* obj: ObjectHandle; whichState : ObjectState *};

{ Opens all objects in container that are in "whichState." }
{ IF 2-4 windows being opened, then automatically positions and sizes }

CONST
   spacing  = 5;
   windowWidth = 660;

VAR son,listHead,highestObj,topObject: ObjectHandle;
    tallyCount: INTEGER;
    tallySet : KindSet;
    tallyBBox: Rect;
    r: Rect;
    windowHt: INTEGER;
    autoPosition: BOOLEAN;
    minV: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('OpenContents "',obj^^.name,'"');
listHead:=obj^^.contents;
TallyContents(obj,whichState,tallyCount,tallySet,tallyBBox,topObject);


{ If opening a few windows then do automatic positioning and sizing }
autoPosition := (tallyCount > 1) AND (tallyCount < 5) AND wantAutoSize;
IF autoPosition THEN
   BEGIN
   windowHt:= ((screenHt-menuHt-spacing) DIV tallyCount) - spacing - titleHt;
   WITH r DO
      BEGIN
      left:=5;
      top:=menuHt+titleHt+spacing;
      right:=left+windowWidth;
      bottom:=top+windowHt;
      END;
   END;


   { open objects (top of screen to bottom of screen) }
REPEAT
   IF Abort THEN EXIT(OpenContents);

      { find obj with smallest vert coord }
   son:=listHead^^.next;
   minV := MAXINT;
   highestObj := nilObject;
   WHILE son <> listHead DO
      BEGIN
      IF (son^^.state = whichState) AND (NOT son^^.isOpen) THEN
         IF son^^.loc.v < minV THEN
            BEGIN
            highestObj := son;
            minV := son^^.loc.v;
            END;
      son := son^^.next;
      END;

   IF highestObj <> nilObject THEN
      BEGIN
      IF NOT autoPosition THEN GetWindRect(highestObj,r);
      IF NOT OpenObject(highestObj,r,TRUE) THEN EXIT(OpenContents);
      IF autoPosition THEN OffsetRect(r,0,windowHt+titleHt+spacing);
      END;
UNTIL (highestObj = nilObject);

  { opened at least one, activate it }
IF tallyCount > 0 THEN TopActive;
END;



FUNCTION OpenObject{* obj: ObjectHandle; windRect: Rect;
                      startTool: BOOLEAN): BOOLEAN *};

{ Creates a window for the object (if necessary) and displays contents }
{ Changes the icon to indicate that the object is open }

VAR title: FmaxStr;
    docHdl: TentryHdl;
    window: WindowPtr;
    deskLoc: Point;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('OpenObject "',obj^^.name,'"  kind = ',obj^^.kind:1);

IF obj^^.isOpen THEN
   BEGIN
   OpenObject := TRUE;   { It's already open }
   EXIT(OpenObject);
   END;

IF obj = nilObject THEN
   BEGIN
   OpenObject := FALSE;  { This is probably an error? }
   EXIT(OpenObject);
   END;

IF FALSE {obj^^.kind IN docToolSet} THEN
   IF obj^^.container <> deskObject THEN
      BEGIN  { docs & tools are automatically unfiled when opened from container }
      ChoosePos(deskObject,deskLoc);
      UnfileObject(obj,deskLoc);
      END;

{ check that window rect is on screen }
WITH windRect DO
  IF (top < titleHt) OR (top > screenHt) OR ((bottom - top) > screenHt) OR
     (left > screenWidth) OR (right < 1) THEN
     BEGIN
     WRITELN('OpenObject invalid window rect - ',left,top,right,bottom);
     SetRect(windRect,40,40,600,300);
     END;

obj^^.windowRect := windRect;

{ Get the title.  Chooses title if icon title is empty }
GetWndTitle(obj,title);

{ Set up the window, but don't display it yet }
window := obj^^.objWindow;
IF window = NIL THEN
   BEGIN              { need to create a window }
   window := NewWindow(obj,title);
   obj^^.objWindow := window;
   obj^^.hThumbPos := 0;
   obj^^.vThumbPos := 0;  {*** should remember scroll position ***}
   IF window = NIL THEN
      BEGIN
      OpenObject := FALSE;   { can't open any more windows, abort the operation }
      EXIT(OpenObject);
      END;
   END
ELSE WITH windRect DO
   BEGIN  { Window already exists.  Adjust size and location. }
   MoveFolder(window,left,top);
   FolderSize(window,right-left,bottom-top,FALSE);
   BringToFront(Pointer(ORD(window)),TRUE);
   END;

WITH obj^^ DO
   BEGIN
   isOpen:=TRUE;
   dirty:=TRUE;
   state:=hidden;
   END;

DrawObject(obj);       { redraw object as a ghost }
ZoomObject(obj,TRUE);  { zoom up }
ShowFolder(window);    { display the window, generates update event for window }

IF obj^^.kind IN docToolSet THEN
   BEGIN
{$IFC R}
   FlushObject(obj);                { ensure that catalog is current }
   IF obj^^.wasOpened THEN          { reattempt startup if orphan }
      ResumeDocs(obj^^.objWindow)
   ELSE                             { never opened, try starting it up }
      OpenDoc(obj^^.volHdl,obj^^.catRID,window,docHdl,startTool);
{$ELSEC}
      {!!!!GEOFF'S STUFF GOES HERE!!!!}  { ?? whatever -gb}
      IF fTstTF THEN WRITELN('Opened obj in docToolSet: ', obj^^.name);
{$ENDC}
   END
ELSE IF IsContainer(obj) THEN      { Generate an object list for the contents }
   BEGIN
   { not needed for im version. Dont throw away closed obj contents -gb }
   {  IF obj = trashObject
   {  THEN GenTrashContents ELSE GenContents(obj); }
   CheckContents(obj);             { make sure all icon locations are valid }
   SetAttributes(obj);             { set any fields that may have changed }
   ValidWindow(window,TRUE);       { cancel update for window, draw it now }
   DrawInsides(obj);
   END;

OpnObjEvt(obj);
obj^^.wasOpened := TRUE;
OpenObject := TRUE;
END;



{$S FilerLow }
PROCEDURE Pause{* hundredths: INTEGER *};
VAR now,stopTime: LongInt;
BEGIN
IF trcFiler THEN WRITELN('Pause');
now := Time;
stopTime := now + hundredths;
IF (now < 0) OR (stopTime < 0) THEN EXIT(Pause);
REPEAT UNTIL Time > StopTime;
END;


{$IFC R}
{$S  }
PROCEDURE ProcessTheEvent;
VAR dh,dv: INTEGER;
    theMenu,theItem: INTEGER;
    keepMenus: BOOLEAN;
    whichSb: THsb;
    whichIcon: TIcon;
BEGIN
IF trcFiler THEN WRITELN('ProcessTheEvent');
IF SkipEvent THEN EXIT(ProcessTheEvent);

SetPort(curEvent.who);

CASE curEvent.what OF

   buttonUp:
      BEGIN
      { use to measure multiple clicks }
      clickTime := curEvent.when+clickDelay
      END;

   buttonDown:
      BEGIN
      dh := ABS(curEvent.where.h-clickLoc.h);
      dv := ABS(curEvent.where.v-clickLoc.v);
      IF (curEvent.when < clickTime) AND (dh <= 6) AND (dv <= 4) THEN
         clickCount := clickCount+1
      ELSE
         clickCount:=1;
      clickLoc := curEvent.where;

      IF curEvent.who = menuFolder THEN
         BEGIN
         KillDuplicates(activeObject);               { abort copy mode }
         AdjustMenus;                                { enable/disable }
         MenuSelect(curEvent.where,theMenu,theItem); { find which one }
         MenuCommand(theMenu,theItem);               { do the job }
         HiLiteMenu(0);  { un-highlight the menu title }
         END

      ELSE IF curEvent.who = dialogFolder THEN
         BEGIN
         END

      ELSE IF curEvent.who = alertFolder THEN
         BEGIN
         END

      ELSE IF (activeObject <> deskObject) AND FGrowHit(curEvent.where) THEN
         GrowWindow(activeObject,curEvent.where)

      ELSE IF (activeObject <> deskObject) AND
              FSbHit(sbList,curEvent.where,whichSb,whichIcon) THEN
         HitScrollBar(activeObject,whichSb,whichIcon)

      ELSE IF IsContainer(activeObject) THEN
         HitContainer(activeObject)

      ELSE IF curEvent.who = scrapFolder THEN
         BEGIN
         END

      ELSE
         BEGIN
         orphanHit := curEvent.who;   { call HitOrphan on this when active }
         MakeFldrActive(filerFolder,whyHitOrphan);  { send activate to self }
         END;
      END;


   keyDown:
      BEGIN
      IF curEvent.appleKey AND (ORD(curEvent.ascii) <> ccBS) THEN
         CommandKey
      ELSE
         TextKey;
      END;


   folderDeactivate:
      BEGIN
      KillDuplicates(activeObject);  { Abort copy mode }
         { deselect any selected objects }
      IF curEvent.who <> curEvent.fromFolder THEN  { new active <> old active }
         BEGIN
         IF editObject^^.container = activeObject THEN EndEdit;
         SetDeSelAll;  { causes a deSelect all event if any selected -gb }
         ChangeContents(activeObject,hilited,normal,0,0,TRUE);
         END;
      HideScroll(activeObject);
      activeObject:=nilObject;
      IF wantCheckHeap THEN CheckHeap('ProcessTheEvent - before GiveControl');
      GiveControl(curEvent);
      IF wantCheckHeap THEN CheckHeap('ProcessTheEvent - after GiveControl');
      END;


   folderActivate:
      BEGIN
      keepMenus := (curEvent.fromProcess = filerProcess);
      IF wantCheckHeap THEN CheckHeap('ProcessTheEvent - before TakeControl');
      TakeControl(curEvent,keepMenus,FALSE);
      IF wantCheckHeap THEN CheckHeap('ProcessTheEvent - after TakeControl');
      IF NOT keepMenus THEN InstallMenus;
      activeObject:=ObjFromWindow(curEvent.who);
      ShowScroll(activeObject);
      HandleWhyActivated(curEvent);
      END;


   folderUpdate:
      BEGIN
      BeginUpdate(curEvent.who);
      DrawInsides(ObjFromWindow(curEvent.who));
      EndUpdate(curEvent.who);
      END;

   folderMoved:
      BEGIN   { sent when user moves window, adjust to keep scrollbars on screen }
      AdjWindRect(ObjFromWindow(curEvent.who));
      END;

   diedEvent:
      BEGIN     { Sent only to filer by "ImDying" when a process terminates. }
      FinishTerminating;
      END;

   abortEvent:
      BEGIN   { ignore this, abort is handled by polling at appropriate times }
      END;

   filerEvent:    { an application is trying to communicate }
      BEGIN       { e.g.,  closed a document, initialization failed, etc. }
      UnsolicitedFilerEvent;
      END;

   OTHERWISE
      BEGIN
      WRITELN('Unknown event = ',curEvent.what:1);
      END;

   END;  { case curEvent }

END;   { of ProcessTheEvent }
{$ENDC}



{$S Filer }
FUNCTION PutBackContents{* obj: ObjectHandle; whichStates: StateSet;
                                               suspendDocs: BOOLEAN): BOOLEAN *};

{ move all objects matching whichState to their filing home.  Any documents }
{ are shut down according to "suspendDocs."  Bails out and returns FALSE if any }
{ document refuses to be putback }

VAR son,nextSon,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('PutBackContents "',obj^^.name,'"');
PutBackContents := FALSE;
listHead:=obj^^.contents;
son:=listHead^^.next;

WHILE son <> listHead DO
   BEGIN
   IF Abort THEN EXIT(PutBackContents);
   nextSon:=son^^.next;
   IF son^^.state IN whichStates THEN
      IF NOT PutBackObject(son,TRUE,suspendDocs) THEN EXIT(PutBackContents);
   son:=nextSon;
   END;
PutBackContents := TRUE;
END;



FUNCTION PutBackObject{* obj: ObjectHandle; sonsAlso: BOOLEAN;
                                            suspendDoc: BOOLEAN): BOOLEAN *};

{ Returns an object to its filing home.  Closes it first if it's open.  If it's }
{ a document then it is shut down according to "suspendDoc".  Returns FALSE if a }
{ document refuses to shut down. }

VAR err: INTEGER;

BEGIN
IF trcFiler THEN WRITELN('PutBackObject "',obj^^.name,'"');
PutBackObject := FALSE;
IF sonsAlso THEN
   IF NOT PutBackContents(obj,allStates,suspendDoc) THEN EXIT(PutBackObject);

IF NOT CloseObject(obj,FALSE,TRUE,suspendDoc) THEN EXIT(PutBackObject);

FlushObject(obj);

IF (obj^^.kind IN putBackSet) AND (obj^^.container = deskObject) THEN
   WalkHome(obj);

BackObjEvt(obj);  { im event -gb }
PutBackObject := TRUE;
END;



FUNCTION RandInt{* min,max: INTEGER): INTEGER *};
{ returns a random integer min <= x <= max }
BEGIN
RandInt := min + (ABS(Random) MOD (max-min+1));
END;


{$S DiskStuff }
PROCEDURE RepairDisk{* diskObj: ObjectHandle *};
{ Scavenges a disk }
VAR err: INTEGER;
    deviceType: Tdevice;
    deviceName: FMaxStr;
    newVolHdl: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('RepairDisk "',diskObj^^.name,'"');
IF NOT (diskObj^^.kind IN diskSet) THEN EXIT(RepairDisk);

WITH diskObj^^.volHdl^^.devHdl^^ DO
   BEGIN
   deviceName := userNmHdl^^;
   deviceType := device;
   END;

{$IFC R}
IF diskObj^^.volHdl = bootVol THEN
   BEGIN
   ParamAlert(deviceName,'','');
   StopAlert(flrAlert,113);   { Can't repair boot disk ... (for now) }
   EXIT(RepairDisk);
   END;

{ must unmount disk to run the scavenger }
ParamAlert(deviceName,'','');
IF NOT UnmountAvolume(deviceType,FALSE {don't eject},FALSE,221 {wait alert}) THEN
   BEGIN
   HideFolder(alertFolder);
   EXIT(RepairDisk);
   END;

RepairVol(err,deviceType,newVolHdl);
IF err = 0 THEN
   diskObj^^.volHdl := newVolHdl
ELSE
   BEGIN   { failed.  Remove disk icon and eject the disk }
   KillObject(diskObj,TRUE,TRUE);
   DismountVol(deviceType,TRUE {eject},TRUE {resumeDocs});
   END;
HideFolder(alertFolder);
{$ELSEC}
ParamAlert(deviceName,'','');
StopAlert(imAlert, 403);
{$ENDC}
END;



{$S FilerLow }
PROCEDURE RestoreDesktop{* whichVol: TentryHdl; VAR diskObj: ObjectHandle *};
{ restores desktop to state last saved }
{ leaves save file open, so that O/S will give error on open if we crash }
VAR saveFile: PathName;
    refnum: INTEGER;
    saveRec: SaveStateRec;
    recID: TcatRID;
    err: INTEGER;
    objName: FMaxStr;
    catRec: TcatRec;


   PROCEDURE MakeSysObject(id: IdType; kind: ObjectKind; VAR obj: ObjectHandle);
   { used to create predefined objects. e.g., disks, scrap, trash, etc. }
   BEGIN
   IF trcFiler THEN WRITELN('MakeSysObject');
   recId.fatherId := idNil;
   recId.uniqueId := id;
   GetCatRec(err,whichVol,recId,catRec);
   CheckCatErr(err,'MakeSysObject - Unable to fetch record.');
   ExtObjName(catRec,objName);
   WITH catRec DO
      obj := MakeObject(deskObject,objName,objKind,nilKind,closedPt,openRect,
                        normal,whichVol,recId,created,modified,objSize,TRUE);
   { not for im stuff -gb CheckObject(obj); }
   IF id = idDisk THEN
      CASE whichVol^^.devHdl^^.device OF
         upperDrive:
            BEGIN
 WRITELN('disk ', objName, ' on floppy1');
            floppy1Object := obj;
            obj^^.kind := disk1Kind;
            END;
         lowerDrive:
            BEGIN
 WRITELN('disk ', objName, ' on floppy2');
            floppy2Object := obj;
            obj^^.kind := disk2Kind;;
            END;
         OTHERWISE   {*** assume hard disk ***}
            BEGIN
 WRITELN('disk ', objName, ' on hardDisk');
            hardDiskObject := obj;
            obj^^.kind := profileKind;
            END;
         END;
   DrawObject(obj);
   END;


   PROCEDURE ReadContents(father: ObjectHandle);
   { recursively restores desktop for "whichVol" }
   LABEL 1;
   VAR err: INTEGER;
       son: ObjectHandle;
       catRec: TcatRec;
       objName: FmaxStr;
       subKind: INTEGER;
       bytesRead: LongInt;
       changed: BOOLEAN;
   BEGIN
   IF trcFiler THEN WRITELN('ReadContents "',father^^.name,'"');
   REPEAT
      Read_Data(err,refnum,ORD(@saveRec),SIZEOF(saveRec),bytesRead,sequential,0);
      IF err <> 0 THEN WRITELN('ReadContents OS err: ',err:1);
      IF trcFiler THEN WITH saveRec DO
         WRITELN(recID.fatherID,recID.uniqueID,deskLoc.h,deskLoc.v,openFlag,
                 filedFlag);
      IF (err <> 0) OR (saveRec.recID.fatherID = -1) THEN GOTO 1;

      CheckLoc(deskObject,saveRec.deskLoc,changed); { make sure its on the desk }
      IF changed THEN WRITELN('Invalid pt in savefile');

      { is it already on the desktop? }
      son := SearchContents(deskObject,whichVol,saveRec.recID.uniqueID,TRUE);

      IF son = nilObject THEN   { create the object }
         BEGIN
         GetCatRec(err,whichVol,saveRec.recID,catRec);
         CheckCatErr(err,'ReadContents: unable to fetch record');
         IF err <> 0 THEN GOTO 1;   {*** bail out ***}
         WITH catRec DO
            BEGIN
            ExtObjName(catRec,objName);
            subKind := WhichSubKind(objKind,toolId);
            recId.fatherId := parentId;
            recId.uniqueId := selfId;
            son :=MakeObject(deskObject,objName,objKind,subKind,closedPt,openRect,
                             normal,whichVol,recID,created,modified,objSize,FALSE);
            son^^.loc := saveRec.deskLoc;
            END;
         END;

      IF changed THEN son^^.dirty := TRUE;
      IF NOT saveRec.filedFlag THEN UnfileObject(son,saveRec.deskLoc);
      IF saveRec.openFlag THEN    {*** better action needed ***}
         IF NOT OpenObject(son,son^^.windowRect,FALSE) THEN EXIT(ReadContents);

      ReadContents(son);
   UNTIL FALSE;
   1: IF trcFiler THEN WRITELN('   exit ReadContents');
   END;


BEGIN
IF trcFiler THEN WRITELN('RestoreDesktop');

{ display the disk object }
IF whichVol <> bootVol  { for imFiler where boot is not a real vol -gb }
  THEN MakeSysObject(idDisk,diskKind,diskObj)
  ELSE diskObj := nilObject;

  IF fTstTF THEN WRITELN('RestoreDesktop for diskObj: ', ORD(DiskOBj), '"',
      diskObj^^.name, '" - vol:', whichVol^^.nameHdl^^);

{ If this is the boot volume then display the "system" objects }
IF whichVol = bootVol THEN
   BEGIN
   MakeSysObject(idScrap,scrapKind,scrapObject);
   scrapObject^^.objWindow := scrapFolder;   { scrap window was created by W/M }
   GetWndTitle(scrapObject,objName);
   SetFldrTitle(scrapFolder,objName);
   MakeSysObject(idComputer,computerKind,computeObject);
{ out for now -a2   MakeSysObject(idPrinter,printKind,printerObject); }
   MakeSysObject(idTrash,trashKind,trashObject);
   END;

{$IFC R }
saveFile:=CONCAT('-',whichVol^^.devHdl^^.nameHdl^^,'-',desktopFile);
{  xx out for now $ELSEC }
saveFile:=CONCAT('-', catVolName, '-',whichVol^^.devHdl^^.nameHdl^^, desktopFile);
{  xx out too     $ENDC }

IF fTstTF THEN BEGIN
  WRITELN('Opening save file: ', saveFile);
  HoldIt(TRUE);
 END;
Open(err,saveFile,refnum,[dRead,dWrite]);
IF trcFiler THEN WRITELN('   opening "',saveFile,'" err = ',err:1);
IF err = 0 THEN
   BEGIN
   ReadContents(deskObject);
   UpdateObject(diskObj,FALSE);   { erase any ghost images for unfiled objects }
   END
ELSE
   BEGIN
   IF err > 0 THEN refNum := -1;   { file was not opened }
   { If file doesn't exist then assume new disk, don't give error message }
   IF err <> 948 {not found} THEN
      BEGIN
      IF err > 0 THEN
         WRITELN('Error opening "',saveFile,'" OS err: ',err:1);
      ParamAlert(whichVol^^.devHdl^^.userNmHdl^^,'','');
      NoteAlert(flrAlert,114);   { Unable to restore desktop ...}
      UpdateObject(deskObject,TRUE);  { repaint under alert box }
      END;
   END;

{ record refnum of savefile, to be used in "SaveDesktop" }
whichVol^^.saveRefNum := refnum;

{ update the trashcan display if it is open }
IF trashObject^^.isOpen THEN
   BEGIN
   trashObject^^.volHdl := whichVol;
   GenContents(trashObj);            { add trash from this volume to the list }
   trashObject^^.volHdl := bootVol;
   DrawContents(trashObject);
   END;
{$ELSEC }
   UpdateObject(diskObj,FALSE);   { erase any ghost images for unfiled objects }
{$ENDC  }
END;



{$S Filer }
FUNCTION  RoomForObject{* srcObj: ObjectHandle; volHdl: TentryHdl): BOOLEAN *};
{ returns TRUE if object (and descendants) will fit on the given volume }
VAR deviceInfo: Fs_Info;
    deviceName: Pathname;
    objectSize: INTEGER;
    err: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('RoomForObject "',srcObj^^.name,'"');

{$IFC R}
IF (srcObj^^.volHdl = volHdl) AND (NOT srcObj^^.toBeCopied) THEN
   BEGIN
   RoomForObject := TRUE;    { object is already on the volume }
   EXIT(RoomForObject);
   END;

deviceName := CONCAT('-',volHdl^^.devHdl^^.nameHdl^^);
Lookup(err,deviceName,deviceInfo);
IF err <> 0 THEN
   BEGIN
   WRITELN('RoomForObject - O/S err: ',err:1);
   RoomForObject := FALSE;
   EXIT(RoomForObject);
   END;

{*** exclude unfiled in calculations ***}
RoomForObject := (srcObj^^.size <= deviceInfo.freeCount);
IF trcFiler THEN WRITELN('   objSize = ',ObjectSize:1,
                         '  freeSpace = ',deviceInfo.freeCount:1);
{$ELSEC}
RoomForObject := TRUE;
{$ENDC}
END;



FUNCTION  RoomForContents{* obj: ObjectHandle; whichState: ObjectState;
                            volHdl: TentryHdl; VAR failVol: TentryHdl): BOOLEAN *};
{ returns TRUE if contents of "obj" in "whichState" fit on the given vol }
{ volHdl = NIL => check same vol (used when destination = desktop) }
{ if failure then "failVol" contains the volume with insufficient space }
VAR son,listHead: ObjectHandle;
    whichVol: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('RoomForContents "',obj^^.name,'"');
{$IFC R}
RoomForContents := FALSE;
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   IF Abort THEN EXIT(RoomForContents);
   IF son^^.state = whichState THEN
      BEGIN
      IF volHdl = NIL THEN
         whichVol := son^^.volHdl
      ELSE
         whichVol := volHdl;
      IF NOT RoomForObject(son,whichVol) THEN
         BEGIN
         failVol := whichVol;
         RoomForContents := FALSE;
         EXIT(RoomForContents);
         END;
      END;
   son := son^^.next;
   END;
{$ENDC}
RoomForContents := TRUE;
END;



FUNCTION RunningDoc{* obj: ObjectHandle): BOOLEAN *};
{ returns true if the object is a document and "OpenDoc" has been called for it }
BEGIN
IF trcFiler THEN WRITELN('RunningDoc "',obj^^.name,'"');
RunningDoc := obj^^.wasOpened AND (obj^^.kind IN docToolSet);
END;



{$S FilerLow }
{$IFC R}
PROCEDURE SaveDesktop{* diskObj: ObjectHandle *};
{ records the desktop state for all objects on the given volume }
VAR saveFile: PathName;
    err,refnum: INTEGER;
    whichVol: TentryHdl;
    saveRec: SaveStateRec;
    bytesRead: LongInt;


   PROCEDURE WriteContents(father: ObjectHandle);
   { recursively writes out the desktop state for "whichVol" }
   VAR son,listHead: ObjectHandle;
       bytesWritten: LongInt;
   BEGIN
   IF trcFiler THEN WRITELN('WriteContents "',father^^.name,'"');
   listHead:=father^^.contents;
   son:=listHead^^.next;
   WHILE son <> listHead DO WITH son^^ DO
      BEGIN
      IF (volHdl = whichVol) AND (isOpen OR NOT isFiled) THEN
         BEGIN
         WITH saveRec DO
            BEGIN
            recID:=catRID;
            deskLoc:=loc;
            openFlag:=isOpen;
            filedFlag:=isfiled;
            END;
         Write_Data(err,refNum,ORD(@saveRec),SIZEOF(saveRec),bytesWritten,
                    sequential,0);
         IF err <> 0 THEN WRITELN('WriteContents OS err: ',err:1);
         IF trcFiler THEN WITH saveRec DO
            WRITELN(recID.fatherID,recID.uniqueID,deskLoc.h,deskLoc.v,isOpen,
                    isFiled);
         WriteContents(son);
         END;
      son := son^^.next;
      END;

   { terminate the list }
   saveRec.recID.fatherID:=-1;
   Write_Data(err,refNum,ORD(@saveRec),SIZEOF(saveRec),bytesWritten,
              sequential,0);
   IF err <> 0 THEN WRITELN('WriteContents OS err: ',err:1);
   IF trcFiler THEN WRITELN('  exit WriteContents');
   END;


BEGIN
IF trcFiler THEN WRITELN('SaveDeskTop "',diskObj^^.name,'"');
{ ensure that disk object is written out first (so that it will be restored first)}
ObjToFront(diskObj,FALSE);

whichVol := diskObj^^.volHdl;
WRITELN('SaveDesktop: diskObj=', diskObj^^.name, ' (', ORD(diskObj),
        ') whichVol: ', ORD(whichVol));
HoldIt(TRUE);

IF whichVol^^.saveRefNum <> -1 THEN
   BEGIN                     { use already opened save file }
   refNum := whichVol^^.saveRefNum;
   IF fTstTF
     THEN WRITELN('SaveDesktop - using open saveRefnum:', whichVol^^.saveRefNum);
   { Reposition to start of file.  (O/S kludge: read 0 bytes from start of file!) }
   Read_Data(err,refNum,ORD(@saveRec),0,bytesRead,absolute,0);
   err := 0;
   END
ELSE
   BEGIN
   {$IFC R }
   saveFile:=CONCAT('-',whichVol^^.devHdl^^.nameHdl^^,'-',desktopFile);
   {$ELSEC }
   saveFile:=CONCAT('-',catVolName,'-',whichVol^^.devHdl^^.nameHdl^^,desktopFile);
   {$ENDC }
    IF fTstTF THEN WRITELN('SaveDesktop - ReOpening save file: ', saveFile);
   Open(err,saveFile,refnum,[dWrite]);
   IF err = 948 THEN
      BEGIN
      Make_File(err,saveFile,0);
      IF err = 0 THEN Open(err,saveFile,refnum,[dWrite]);
      END;
   END;

HoldIt(fTstTF);

IF err <= 0 THEN
   BEGIN
   WriteContents(deskObject);
   Truncate(err,refnum);
   END
ELSE
   BEGIN
   WRITELN('Error opening "',saveFile,'" = ',err:1);
   ParamAlert(whichVol^^.devHdl^^.userNmHdl^^,'','');
   NoteAlert(flrAlert,115);   { Unable to save desktop ...}
   UpdateObject(deskObject,TRUE);  { repaint under alert box }
   END;

Close_Object(err,refnum);
whichVol^^.saveRefNum := -1;
END;
{$ENDC }



{$S Filer }
PROCEDURE ScrollContents{* obj: ObjectHandle; dh,dv,minH,minV,maxH,maxV: INTEGER;
                           adjustThumb: BOOLEAN *};
{ scrolls the window of the given object dh or dv pixels within the bounds given }
{ positions the thumb if "adjustThumb" is TRUE }
VAR window: WindowPtr;
    contentRect,rH,rV: Rect;
    newThumb: INTEGER;
    redoRgn: RgnHandle;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('ScrollContents  dh: ',dh:1,' dv: ',dv:1,
                                        ' maxH: ',maxH:1,' maxV: ',maxV:1);
window := obj^^.objWindow;
WITH window^ DO
   BEGIN
   GetContentRect(obj,contentRect);
   WITH contentRect DO
      BEGIN
      { determine bits to be scrolled }

      IF trcFiler THEN WRITELN('   content rect = ',left,top,right,bottom);

      { adjust dh,dv to boundaries }
      { scroll increments must be a multiple of 4 so that scroll bar gray aligns }
      IF dh < 0 THEN
         BEGIN
         IF right >= maxH THEN EXIT(ScrollContents);
         dh := Max(dh,right-maxH);
         dh := ((dh - 3) DIV 4)*4;
         END
      ELSE IF dh > 0 THEN
         BEGIN
         IF left <= minH THEN EXIT(ScrollContents);
         dh := Min(dh,left-minH);
         dh := ((dh + 3) DIV 4)*4;
         END;

      IF dv < 0 THEN
         BEGIN
         IF bottom >= maxV THEN EXIT(ScrollContents);
         dv := Max(dv,bottom-maxV);
         dv := ((dv - 3) DIV 4)*4;
         END
      ELSE IF dv > 0 THEN
         BEGIN
         IF top <= minV THEN EXIT(ScrollContents);
         dv := Min(dv,top-minV);
         dv := ((dv + 3) DIV 4)*4;
         END;
      END;


   IF obj^^.viewMode <> spatialView THEN
      IF dv <> 0 THEN
         dv := (dv DIV lineHt)*lineHt         { constrain to line boundaries }
      ELSE
         contentRect.top := contentRect.top - lineHt;  { allow titles to scroll }

   IF trcFiler THEN WRITELN('  adjusted dh: ',dh:1,' dv: ',dv:1);

   IF (dh = 0) AND (dv = 0) THEN EXIT(ScrollContents);

   GetPort(savePort);
   SetPort(window);

   redoRgn := newRgn;
   ScrollRect(contentRect,dh,dv,redoRgn);

   SetOrigin(portRect.left-dh,portRect.top-dv);

   OffsetRgn(redoRgn,-dh,-dv);

   { adjust scrollbars to new origin }
   FlushRects(rH,rV);
   rV.top := rV.top + TopPnlHt(obj); { adjust vertical scroll bar for top panel }

   SetSbRect(hsbH,rH);
   SetSbRect(hsbV,rV);

   InvalidateRgn(window,redoRgn);
   BeginUpdate(window);

   DrawContents(obj);

   EndUpdate(window);
   DisposeRgn(redoRgn);

   ClipRect(portRect);

   { determine thumb position }
   IF adjustThumb THEN
      BEGIN
      IF dh <> 0 THEN
         BEGIN
         SetUpMvThumb(hsbH);
         newThumb := ThumbHpos(obj,minH,maxH);
         obj^^.hThumbPos := newThumb;
         END
      ELSE
         BEGIN
         SetUpMvThumb(hsbV);
         newThumb := ThumbVpos(obj,minV,maxV);
         obj^^.vThumbPos := newThumb;
         END;
      IF trcFiler THEN WRITELN('   newThumb = ',newThumb:1);
      MoveThumb(newThumb);
      END;


   SetPort(savePort);
   END;
END;



PROCEDURE ScrollLimits{* obj: ObjectHandle;
                         VAR minH,minV,maxH,maxV: INTEGER *};
{ returns scrolling limits for a container.  Spatial view limits are determined }
{ by the objects farthest to the right and bottom }
CONST
   titleWidth2 = 60;   { guess at 1/2 max title width }
VAR listHead,son: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('ScrollLimits "',obj^^.name,'"');
minH := 0;
minV := TopPnlHt(obj);

IF obj^^.viewMode = spatialView THEN
   BEGIN
   maxH := 0;
   maxV := 0;
   listHead := obj^^.contents;
   son := listHead^^.next;
   WHILE son <> listHead DO
      BEGIN
      WITH son^^.loc DO
         BEGIN
         IF h > maxH THEN maxH := h;
         IF v > maxV THEN maxV := v;
         END;
      son := son^^.next;
      END;

   { adjust for icon title }
   maxH := maxH + iconWidth + titleWidth2;
   WITH iconFntInfo DO
      maxV := maxV + iconHt + ascent + descent + 1;
   END
ELSE
   BEGIN
   minV := minV + lineHt;  { adjust for column titles }
   maxH := 700;
   maxV := (CountContents(obj)+3)*lineHt+TopPnlHt(obj);
   END;

{ scroll increments must be a multiple of 4 so that scrollbar gray aligns }
maxH := ((maxH + hScrollInc - 1) DIV hScrollInc)*hScrollInc;
maxV := ((maxV + 3) DIV 4)*4;
END;



FUNCTION SearchContents{* obj: ObjectHandle; hVol: TentryHdl; id: IDType;
                                             sonsAlso: BOOLEAN): ObjectHandle *};
{ returns handle of descendant that has given values }
LABEL 1;
VAR son,listHead,result: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('SearchContents "',obj^^.name,'"');
listHead:=obj^^.contents;
son:=listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   result:=SearchObject(son,hVol,id,sonsAlso);
   IF result = nilObject THEN
      son:=son^^.next
   ELSE
      GOTO 1;
   END;

result := nilObject;
1:
SearchContents := result;
END;



FUNCTION SearchObject{* obj: ObjectHandle; hVol: TentryHdl; id: IDType;
                                               sonsAlso: BOOLEAN): ObjectHandle *};
{ returns handle of obj or descendant that has given values }
BEGIN
IF trcFiler THEN WRITELN('SearchObject "',obj^^.name,'"');
IF (hVol = obj^^.volHdl) AND (id = obj^^.catRID.uniqueID) THEN
  SearchObject := obj
ELSE IF sonsAlso THEN
  SearchObject := SearchContents(obj,hVol,id,sonsAlso)
ELSE
  SearchObject := nilObject;
END;



PROCEDURE SectClipRgn{* window: WindowPtr; r: Rect *};
{ intersects clip region with rectangle }
VAR rgn: RgnHandle;
BEGIN
IF trcFiler THEN WRITELN('SectClipRgn');
rgn := newRgn;
RectRgn(rgn,r);
SectRgn(rgn,window^.clipRgn,window^.clipRgn);
DisposeRgn(rgn);
END;



{$S FilerLow }
PROCEDURE SelAllObjects{* container: ObjectHandle *};
{ selects all objects in a container }
VAR son,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('SelAllObjects "',container^^.name,'"');
EndEdit;
listHead := container^^.contents;
son := listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state = normal THEN
      BEGIN
      son^^.state := hilited;
      DrawObject(son);
      END;
   son := son^^.prev;
   END;
END;



{$S Filer }
PROCEDURE SelectContents{* obj: ObjectHandle; groupRect: Rect *};

{ toggle selection state of all objects within groupRect,   }
{ bring all selected objects to the front, and redraw as necessary }

VAR son,prevSon,listHead,lastObject: ObjectHandle;
    hitRect: Rect;
    inRect,reDraw:  BOOLEAN;
BEGIN
IF trcFiler THEN WRITELN('SelectContents "',obj^^.name,'"');
hitRect:=groupRect;
OffsetRect(hitRect,-icon2Width,-icon2Ht);

listHead:=obj^^.contents;
lastObject:=listHead^^.next;
son:=listHead;
prevSon:=son^^.prev;

WHILE son <> lastObject DO
   BEGIN
   son:=prevSon;
   prevSon:=son^^.prev;

   IF son^^.state IN [normal,hilited] THEN
      BEGIN
      WITH son^^ DO
         BEGIN
         inRect:=PtInRect(loc,hitRect);
         reDraw:=inRect OR (state=hilited);

         IF inRect THEN   { toggle selection state }
            BEGIN
            IF state=hilited
              THEN BEGIN
                state:=normal;
                DslObjEvt(son);
               END
            ELSE IF state=normal
              THEN BEGIN
               state:=hilited;
               SelObjEvt(son, CGrpSel);
              END;
            END;

         IF state=hilited THEN ObjToFront(son,FALSE);  { bring to front }
         END;

      IF reDraw THEN DrawObject(son);
      END;

   END;
END;



PROCEDURE SelectObject{* obj: ObjectHandle; hitName: BOOLEAN *};
{ de-selects all, selects new object, selects name for editing }
BEGIN
IF trcFiler THEN WRITELN('SelectObject "',obj^^.name,'"');
IF obj^^.state = normal THEN    { hilite and bring to front }
   BEGIN
   SetDeSelAll;  { causes a deSelect all event if any selected -gb }
   ChangeContents(obj^^.container,hilited,normal,0,0,TRUE); { de-select all }
   ToggleObject(obj);
   END;
SelectName(obj,hitName);
END;



PROCEDURE SelectName{* obj: ObjectHandle; hitName: BOOLEAN *};
{ Sets up name for editing }
VAR savePort: GrafPtr;
    dataPtr: PtrData;
BEGIN
IF trcFiler THEN WRITELN('SelectName "',obj^^.name,'"');
IF obj = editObject THEN EXIT(SelectName);       { already being edited }
IF obj^^.toBeCopied THEN EXIT(Selectname);       { can't name until created }

{*** temporary ***}
IF obj^^.state = placeHolder THEN EXIT(SelectName);

EndEdit;  { terminate editing of current field }

{ Set up pointer to duplicate name if any }
IF obj^^.container = deskObject THEN     { On desktop.  Look for placeholder }
   edit2Object := GetPlaceHolder(obj)
ELSE IF obj^^.state = placeHolder THEN   { This is a placeholder.  Look on desktop}
   edit2Object := SearchContents(deskObject,obj^^.volHdl,obj^^.catRID.uniqueId,FALSE)
ELSE
   edit2Object := nilObject;

IF (edit2Object <> nilObject) AND
   (edit2Object^^.container^^.viewMode = spatialView) THEN
   ObjToFront(edit2Object,TRUE);         { bring to front and redraw }

{ copy name into field structure }
WITH hCurFld^^ DO
   BEGIN
   curLen := LENGTH(obj^^.name);
   coords := obj^^.nameRect;
   protect := (obj^^.kind = toolKind);
   dataPtr := @obj^^.name;
   {$R-}
   MoveLeft(dataPtr^[1],curValue^^,curLen);
   {$R+}
   IF obj^^.container^^.viewMode = spatialView THEN
      BEGIN
      align := center;
      fmtInfo^^[0].font := iconNamFont;
      END
   ELSE
      BEGIN
      align := left;
      fmtInfo^^[0].font := sysText;
      END;
   END;

GetPort(savePort);
SetPort(obj^^.container^^.objWindow);

InitFstate(hCurFld,hCurFstate);
SelectAll(hCurFld,hCurFstate,timeoutInterval);
IF hCurFld^^.curLen = 0 THEN
   HilightSel(hCurFld,hCurFstate,FALSE);   { disable caret if no name }

IF hitName THEN      { buttoned down in name }
   BEGIN
   ObscureCursor;    { hide the cursor }
   clickCount := 0;  { reset so that second click doesn't cause word select }
   END;

editObject := obj;
rnmObjIdx := GetObjIdx(curObjTable, editObject);
rnmName := editObject^^.name;

obj^^.dirty := TRUE;
SetTimeout(noTimeout);

SetPort(savePort);
END;



PROCEDURE SetAttributes{* obj: ObjectHandle *};
{ recomputes object attributes that may have changed }
VAR devPathName: PathName;
    devInfo: Fs_Info;
    err: INTEGER;
BEGIN
{$IFC R}
IF obj^^.kind IN diskSet THEN
   BEGIN
   devPathName := CONCAT('-',obj^^.volHdl^^.devHdl^^.nameHdl^^);
WRITELN('SetAttributes for obj:', ORD(obj), ' devPathName: ', devPathName);
   LookUp(err,devPathName,devInfo);
   IF err <> 0 THEN WRITELN('SetAttributes - Lookup failed err: ',err:1);
   WITH obj^^ DO
      BEGIN
      freeSpace := devInfo.freeCount;
      size      := devInfo.fs_size;
      backedup  := devInfo.DTVB;
      END;
   END;
{$ELSEC }
   WITH obj^^ DO
    BEGIN
      IF obj^^.kind IN diskSet
        THEN BEGIN
           IF obj^^.kind = profileKind
                THEN size := 15000
                ELSE size := 764;
           freeSpace := (size DIV 3) + (TIME MOD (size DIV 3));
          END
         ELSE BEGIN
           { size := 0; }
           freeSpace :=0;
          END;
      backedup  := 0;
    END;
{$ENDC }
END;



PROCEDURE SetHomePt{* obj: ObjectHandle; pt: Point *};
{ records spatial location in catalog }
VAR catRec: TcatRec;
    err: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('SetHomePt "',obj^^.name,'"');
GetCatRec(err,obj^^.volHdl,obj^^.catRID,catRec);
CheckCatErr(err,'SetHomePt - Unable to get catRec');
catRec.closedPt := pt;
UpdCatRec(err,obj^^.volHdl,obj^^.catRID,catRec);
CheckCatErr(err,'SetHomePt - Unable to Update catRec');
END;



PROCEDURE SetTimeout{* interval: INTEGER *};
{ sets global "timeoutTime" so that timeout action will be taken }
BEGIN
IF trcFiler THEN WRITELN('SetTimeout: ',interval:1);
IF interval = noTimeout THEN
   timeoutTime := noTimeout
ELSE
   timeoutTime := Time + interval;
END;



PROCEDURE ShowFld{* pStr: PtrString; r: Rect; theAlign: INTEGER; theFont: TFam;
                    theFace: Style *};
{ displays a string in a rectangle according to the alignment and font }
VAR tempPtr: PtrString;
BEGIN
IF trcFiler THEN WRITELN('ShowFld "',pStr^,'"');
tempPtr := Pointer(ORD(pStr)+1);

WITH hShowFld^^ DO
   BEGIN
   curLen   := LENGTH(pStr^);
   align    := theAlign;
   coords   := r;
   curValue := @tempPtr;
   fmtInfo^^[0].font := theFont;
   fmtInfo^^[0].face := theFace;
   END;

DrawField(hShowFld,NIL,FALSE,FALSE);
END;



PROCEDURE ShowFldAt{* VAR strg: FmaxStr; pt: Point; theAlign: INTEGER; font: TFam;
                      VAR fldRect: Rect *};
{ displays a string about a given point according to the alignment and font }
{ returns the bounding box of the field drawn }
VAR tempPtr: PtrString;
BEGIN
IF trcFiler THEN WRITELN('ShowFldAt "',strg,'"  pt: ',pt.h,pt.v);

tempPtr := Pointer(ORD(@strg)+1);

WITH hShowFld^^ DO
   BEGIN
   curLen   := LENGTH(strg);
   align    := theAlign;
   curValue := @tempPtr;
   fmtInfo^^[0].font := font;
   fmtInfo^^[0].face := [];
   END;

{ compute field rectangle at new point so that it can be erased }
MoveField(hShowFld,NIL,pt);

DrawFldAt(hShowFld,NIL,pt,FALSE,TRUE {erase});

fldRect := hShowFld^^.coords;
IF trcFiler THEN WITH fldRect DO WRITELN('   bbox: ',left,top,right,bottom);
END;




PROCEDURE ShowScrap;
VAR err: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('ShowScrap');
DrawScrap(err);
IF err <> 0 THEN   { scrap is not a field }
   DummyDisplay(scrapFolder);
{*** display graphic scrap ***}
END;



{$S  }
PROCEDURE ShowScroll{* obj: ObjectHandle *};
{ draw scroll bars on the active window, then clip down to protect them }
LABEL 1;
VAR rH,rV,tempRect: Rect;
    window: WindowPtr;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('ShowScroll "', obj^^.name, '"');
window := obj^^.objWindow;

{ do show scroll for im folders  -gb }
IF (NOT IsContainer(obj)) AND (obj^^.imFldr <> NIL)
  THEN BEGIN IMShowScroll(obj^^.imFldr); EXIT(ShowScroll); END;

IF (window = filerFolder) OR (window = Nil) THEN EXIT(ShowScroll);
GetPort(savePort);
SetPort(window);

FlushRects(rH,rV);   { get rectangles in which to draw scroll bars }

{ Skip drawing scroll bars if wouldn't show }
GetGrowRect(tempRect);
UnionRect(rV,tempRect,tempRect);
IF NOT (RectInRgn(rH,thePort^.visRgn) OR
        RectInRgn(tempRect,thePort^.visRgn)) THEN GOTO 1;

ClipRect(window^.portRect);   { open up clipping }

{ adjust vertical scroll bar for top panel }
rV.top := rV.top + TopPnlHt(obj);

SetSbRect(hsbV,rV);  { install the rectangles into the data structure }
SetSbRect(hsbH,rH);

{ fill gap in scroll bar with light gray }
WITH rV DO
   SetRect(tempRect,left,window^.portRect.top-1,right,top+1);
FrameRect(tempRect);
InsetRect(tempRect,1,1);
FillRect(tempRect,ltGray);

{ set the icons to be drawn in the scroll bars }
IF obj^^.kind IN (docToolSet + [scrapKind]) THEN
   BEGIN
   SetSbIcons(hsbV,[]);    { orphans have only the grow icon }
   SetSbIcons(hsbH,[]);
   END
ELSE
   BEGIN
   SetSbIcons(hsbV,[iconArwA,iconArwB,iconThumb,iconPagA,iconPagB]);
   SetSbIcons(hsbH,[iconArwA,iconArwB,iconThumb,iconPagA,iconPagB]);
   SetThumb(hsbV,obj^^.vThumbPos);   { set the thumb position }
   SetThumb(hsbH,obj^^.hThumbPos);
   END;

PaintSb(hsbV);       { draw the scroll bars }
PaintSb(hsbH);
PaintGrow;           { draw the grow icon }

ValidScrollBars(window,TRUE);   { exclude scroll bars from possible update }

{ Set the window's clip region to exclude the scroll bars }
ClipContent(obj);

1:
SetPort(savePort);
END;



{$S FInit }
PROCEDURE ShutDown;
VAR devHdl: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('ShutDown');
{$IFC R}
devHdl := firstDev;
WHILE devHdl <> NIL DO
   BEGIN
   IF NOT UnmountAvolume(devHdl^^.device,TRUE,FALSE,0) THEN EXIT(ShutDown);
   devHdl := devHdl^^.nextHdl;
   END;
{$ENDC}

{ process any updates now, since might not get another chance }
UpdateObject(deskObject,TRUE);

IF Abort THEN EXIT(ShutDown);

{$IFC R}
StopPlayback;
StopRecord;

PowerItDown;

EXIT(Filer);
{$ENDC}

END;



{$S  }
FUNCTION SkipEvent {* : BOOLEAN *};
{ filters out events after apple-period pressed }
BEGIN
IF trcFiler THEN WRITELN('SkipEvent');
IF Abort THEN
   SkipEvent := (curEvent.what IN [keyDown,buttonDown,buttonUp])
ELSE
   SkipEvent := FALSE;
END;



{$S Filer }
PROCEDURE SortContents{* obj: ObjectHandle; newView: viewType *};
{ sorts the contents of obj according to the viewType }
{ list is sorted in reverse order using a simple bubble sort }
VAR numToSort,lastSwitched,j: INTEGER;
    listHead,son,nextSon: ObjectHandle;


   PROCEDURE DownShift(VAR s: FMaxStr);
   { converts all upper case chars in "s" to lower case }
   VAR i: INTEGER;
   BEGIN
   FOR i := 1 TO LENGTH(s) DO
      IF (s[i] <= 'Z') THEN
         IF (s[i] >= 'A') THEN s[i] := CHR(ORD(s[i]) + 32);
   END;


   FUNCTION LessStr(s1,s2: FMaxStr): BOOLEAN;
   { does case insensitive compare.  Returns TRUE if s1 < s2 }
   BEGIN
   DownShift(s1);
   DownShift(s2);
   LessStr := (s1 < s2);
   END;


   FUNCTION Switch(obj1,obj2: ObjectHandle; view: ViewType): BOOLEAN;
   { returns TRUE if objects are out of order for given view }
   BEGIN
   CASE view OF
      alphaView:
         Switch := LessStr(obj1^^.name,obj2^^.name);
      chronView:
         Switch := (obj1^^.modified > obj2^^.modified);  { sign bit is on }
      OTHERWISE
         Switch := FALSE;
      END;
   END;


BEGIN
IF trcFiler THEN WRITELN('SortContents "',obj^^.name,'"');
listHead := obj^^.contents;
numToSort := CountContents(obj);

WHILE numToSort > 0 DO
   BEGIN
   lastSwitched := 0;
   son := listhead^^.next;
   IF trcFiler THEN WRITELN('   sort ',numToSort:1,' objects');
   FOR j := 1 TO numToSort-1 DO
      BEGIN
      nextSon := son^^.next;
      IF Switch(son,nextSon,newView) THEN WITH son^^ DO
         BEGIN
         IF trcFiler THEN WRITELN('     switching "',son^^.name,'" with "',
                                                      nextSon^^.name,'"');
         { splice out at old location }
         prev^^.next:=next;
         next^^.prev:=prev;

         { splice back in after next son }
         prev:=nextSon;
         next:=nextSon^^.next;
         prev^^.next:=son;
         next^^.prev:=son;

         lastSwitched := j;
           { same son is now next because of switch }
         END
      ELSE
         son := nextSon;   { move to next in list }
      END;
   numToSort := lastSwitched;
   END;
END;



FUNCTION StopDoc{* obj: ObjectHandle; suspendDoc,forSure: BOOLEAN): BOOLEAN *};
{ tells a document to shut down.  returns TRUE if successful }
VAR err: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('StopDoc "',obj^^.name,'"');
{$IFC R}
CloseDoc(err,obj^^.volHdl,obj^^.catRID,NOT suspendDoc,forSure);
IF err <> 0 THEN
   BEGIN
   WITH obj^^ DO TellUser(volHdl,volHdl,catRID,catRID,err);  {*** FL ***}
   StopDoc := FALSE;
   EXIT(StopDoc);
   END;
{$ENDC}

IF fTstTF THEN {added trace -gb }
  WRITELN('StopDoc - NOT Disposing folder of object "', obj^^.name, '"');
HoldIt(cDebug);
{ DisposeFolder(obj^^.objWindow);
{obj^^.objWindow := NIL;
{obj^^.wasOpened := FALSE;
}
StopDoc := TRUE;
END;



{$S  }
PROCEDURE TallyContents{* obj: ObjectHandle;
                          whichState: ObjectState;
                          VAR tallyCount: INTEGER;
                          VAR tallySet: KindSet;
                          VAR tallyBBox: Rect;
                          VAR topObject: ObjecHandle *};
{ tally up all the objects in whichState }
{ return a count of objects, a set of kinds, and the bounding box }
VAR son,listHead: ObjectHandle;
    pos: Point;
BEGIN
IF trcFiler THEN WRITELN('TallyContents "',obj^^.name,'"');
tallyCount:=0;
tallySet:=[];
SetRect(tallyBBOX,MAXINT,MAXINT,-MAXINT,-MAXINT);
topObject := nilObject;
listHead:=obj^^.contents;
son:=listHead^^.prev;
WHILE son <> listHead DO WITH son^^ DO
   BEGIN
   IF state = whichState THEN
      BEGIN
      IF obj^^.viewMode = spatialView THEN
         pos := loc
      ELSE
         GetListPos(son,FALSE,pos);
      IF pos.h < tallyBBox.left   THEN tallyBBox.left:=pos.h;
      IF pos.v < tallyBBox.top    THEN tallyBBox.top:=pos.v;
      IF pos.h > tallyBBox.right  THEN tallyBBox.right:=pos.h;
      IF pos.v > tallyBBox.bottom THEN tallyBBox.bottom:=pos.v;
      tallyCount:=tallyCount+1;
      tallySet:=tallySet+[kind];
      topObject := son;
      END;
   son:=son^^.prev;
   END;

IF tallyCount=0 THEN
   SetRect(tallyBBox,0,0,0,0)
ELSE
   BEGIN
   tallyBBox.right:=tallyBBox.right+iconWidth;
   tallyBBox.bottom:=tallyBBox.bottom+iconHt;
   END;
END;



{$S CopyStuff }
PROCEDURE TearOffContents{* obj: ObjectHandle; whichState: ObjectState *};
{ called to create new documents from selected stationery pads }
VAR son,nextSon,listHead,diskObj: ObjectHandle;
    failVol: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('TearOffContents "',obj^^.name,'"');

{ make sure new objects will fit on volume (or volumes if obj = deskObject) }
IF NOT RoomForContents(obj,whichState,NIL,failVol) THEN
   BEGIN
   diskObj := ObjFromVol(failVol);
   ParamAlert(diskObj^^.name,'','');
   StopAlert(flrAlert,110);
   EXIT(TearOffContents);
   END;


{ create new objects }
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   IF Abort THEN EXIT(TearOffContents);
   nextSon := son^^.next;
   IF son^^.state = whichState THEN
      IF NOT TearOffObject(son) THEN EXIT(TearOffContents);
   son := nextSon;
   END;
END;



{$S CopyStuff }
FUNCTION TearOffObject{* obj: ObjectHandle): BOOLEAN *};
{ creates a new object on same disk as the given stationery. }
VAR newLoc,newHomeLoc: Point;
    newKind: ObjectKind;
    srcCatRID,newCatRID: TcatRID;
    err: INTEGER;
    catRec: TcatRec;
    itemString: Str255;       { fix nr bug #9 -gb ( for translation ) }
    newName: FmaxStr;
    newObj,diskObj: ObjectHandle;
    srcVol: TentryHdl;
    curTime: LongInt;
    paramString: TParamAlert;
BEGIN
IF trcFiler THEN WRITELN('TearOffObject "',obj^^.name,'"');
IF NOT (obj^^.kind IN padSet) THEN EXIT(TearOffObject);

diskObj := OnDisk(obj);  { ObjFromVol(obj^^.volHdl); }

IF diskObj = nilObject
  THEN BEGIN
    GetItem(flrMenus[xtraMenu],xDiskette,@itemString);
    paramString := itemString;
    ParamAlert(obj^^.name,paramString,'');
   END
  ELSE ParamAlert(obj^^.name,diskObj^^.name,'');
IF obj^^.kind = docPad THEN
   WaitAlert(flrAlert,106)   { Creating new document ... }
ELSE
   WaitAlert(flrAlert,107);   { Copying new folder ... }
upTime := Time;

{ update catalog for the pad }
FlushObject(obj);

srcVol := obj^^.volHdl;
srcCatRID := obj^^.catRID;

{ make a copy of the files represented by the stationery pad }
XferObject(err,srcCatRID,srcCatRID.fatherID,srcVol,srcVol,TRUE,FALSE,0,newCatRID);
IF err <> 0 THEN
   BEGIN
   TellUser (srcVol,srcVol,srcCatRID,srcCatRID,err);   {*** FL ***}
   (***   XferObject currently reports all errors
   ParamAlert(obj^^.name,diskObj^^.name,'');
   IF obj^^.kind = docPad THEN
      StopAlert(flrAlert,108)   { Unable to create new document ... }
   ELSE
      StopAlert(flrAlert,109);   { Unable to create new folder ... }
   ***)
   TearOffObject := FALSE;
   EXIT(TearOffObject);
   END;

{ create the new object icon }
WITH obj^^ DO
   BEGIN
   EndEdit;
   GetItem(flrMenus[xtraMenu],xUntitled,@itemString);
   newName := itemString;  { fix nr bug #9 -gb ( for translation ) }
   newLoc.h:=loc.h+icon2Width;
   newLoc.v:=loc.v+icon2Ht;
   WITH obj^^.container^^.objWindow^.portRect DO
      BEGIN
      IF newLoc.h + iconWidth > right THEN newLoc.h:=newLoc.h-iconWidth;
      IF newLoc.v + iconHt > bottom THEN newLoc.v:=newLoc.v-iconHt;
      END;
   IF kind = folderPad THEN newKind:=folderKind ELSE newKind:=docKind;
   curTime := TimeStamp;
   newObj:=MakeObject(container,newName,newKind,subKind,newLoc,windowRect,
                      hilited,srcVol,newCatRID,curTime,curTime,size,
                      (container <> deskObject));
   END;

{ if created on desk then choose a home location }
IF newObj^^.container = deskObject THEN
    ChooseHome(newObj,newHomeLoc)
ELSE
   newHomeLoc := newLoc;

newObj^^.dirty := TRUE;

{ change catalog entry to match new object kind, name, loc }
GetCatRec(err,srcVol,newCatRID,catRec);
CheckCatErr(err,'TearOffObject - Unable to get catRec');
WITH catRec DO
   BEGIN
   objKind := newKind;
   InsObjName(catRec,newName);
   closedPt := newHomeLoc;
   created := newObj^^.created;
   modified := newObj^^.modified;
   END;
UpdCatRec(err,srcVol,newCatRID,catRec);
CheckCatErr(err,'TearOffObject - Unable to Add catRec');

{ deselect pad }
obj^^.state := normal;
DrawObject(obj);

{ if created in a list then put in proper location }
WITH obj^^ DO
   IF container^^.viewMode <> spatialView THEN
      BEGIN
      SortContents(container,container^^.viewMode);
      DrawContents(container);
      END
   ELSE
      DrawObject(newObj);

SelectName(newObj, FALSE);  { my addition -gb }
RemoveAlert;
OPdObjEvt(obj, newObj);
SelObjEvt(newObj, 0);
TearOffObject := TRUE;
END;



{$S Filer }
PROCEDURE TextKey;
CONST ccEnter = 3;   {*** font mgr should define this ***}
VAR err: INTEGER;
    inList: BOOLEAN;
BEGIN
IF trcFiler THEN WRITELN('TextKey');
IF editObject = nilObject THEN EXIT(TextKey);

CASE ORD(curEvent.ascii) OF

   ccBS:
      IF curEvent.appleKey THEN
         IF curEvent.shiftKey THEN
            ForwardWord(hCurFld,hCurFstate,err)
         ELSE
            BackWord(hCurFld,hCurFstate,err)
      ELSE
         IF curEvent.shiftKey THEN
            ForwardSpace(hCurFld,hCurFstate,err)
         ELSE
            BackSpace(hCurFld,hCurFstate,err);

   ccEnter,ccHT,ccCR:;   { ignore }

   ccEsc:   { clear }
      ClearField(hCurFld,hCurFstate,err);

   OTHERWISE
      IF NOT curEvent.appleKey THEN
         InsCh(curEvent.ascii,hCurFld,hCurFstate,err);
   END;

ObscureCursor;
SetTimeout(0);    { cause chars to be drawn when typeahead buffer empties }
IF hCurFld^^.curLen > 0 THEN
   BEGIN
   IF trcFiler THEN WRITELN('   turn caret on');
   inList := (editObject^^.container^^.viewMode <> spatialView);
   IF inList THEN
      ClipRight(hCurFld^^.coords.right);
   IF NOT hCurFstate^^.selectOn THEN HilightSel(hCurFld,hCurFstate,TRUE);
   CaretOn(hCurFld,hCurFstate);
   IF inList THEN
      ClipContent(editObject^^.container);
   END;
END;



FUNCTION ThumbHpos{* obj: ObjectHandle; minH,maxH: INTEGER): INTEGER *};
{ computes the horizontal thumb position for a container }
VAR contentRect: Rect;
BEGIN
IF trcFiler THEN WRITELN('ThumbHpos "',obj^^.name,'"');
GetContentRect(obj,contentRect);
WITH contentRect DO
   BEGIN
   IF left <= minH THEN
      ThumbHpos := 0
   ELSE IF right >= maxH THEN
      ThumbHpos := maxThumb
   ELSE
      ThumbHpos := (left-minH)*maxThumb DIV ((maxH-minH)-(right-left));
   END;
END;



FUNCTION ThumbVpos{* obj: ObjectHandle; minV,maxV: INTEGER): INTEGER *};
{ computes the vertical thumb position for a container }
VAR contentRect: Rect;
BEGIN
IF trcFiler THEN WRITELN('ThumbVpos "',obj^^.name,'"');
GetContentRect(obj,contentRect);
WITH contentRect DO
   BEGIN
   IF top <= minV THEN
      ThumbVpos := 0
   ELSE IF (bottom >= maxV) OR
           ((obj^^.viewMode <> spatialView) AND ((maxV - bottom) < lineHt)) THEN
      ThumbVpos := maxThumb
   ELSE
      ThumbVpos := (top-minV)*maxThumb DIV ((maxV-minV)-(bottom-top));
   END;
END;



PROCEDURE ToggleObject{* obj: ObjectHandle *};
{ toggles the selection state of an object }
BEGIN
IF trcFiler THEN WRITELN('ToggleObject "',obj^^.name,'"');
WITH obj^^ DO
   BEGIN
   IF state = hilited THEN
      BEGIN
      state := normal;
      DslObjEvt(obj);
      DrawObject(obj);
      END
   ELSE IF state = normal THEN
      BEGIN
      state := hilited;
      SelObjEvt(obj, CTglSel);
      ObjToFront(obj,TRUE);   { hilited objects move to the front }
      END;
   END;
END;



FUNCTION TopPnlHt{* obj: ObjectHandle): INTEGER *};
{ returns the height in pixels of the status panel for this kind of object }
BEGIN
IF trcFiler THEN WRITELN('TopPnlHt "',obj^^.name,'"');
IF obj^^.kind IN diskSet THEN
   TopPnlHt := lineHt - 2
ELSE
   TopPnlHt := 0;
END;



FUNCTION TopVisible{* : WindowPtr *};
{ return topmost visible window }
VAR window: WindowPeek;
BEGIN
IF trcFiler THEN WRITELN('TopVisible');
window:=Pointer(ORD(dialogFolder));
window:=window^.nextWindow;   { point to first normal window }
WHILE window <> Nil DO
   BEGIN
   IF window^.visible THEN
      BEGIN
      TopVisible := Pointer(ORD(window));
      EXIT(TopVisible);
      END;
   window:=window^.nextWindow;
   END;
TopVisible:=Pointer(ORD(filerFolder));   { couldn't find one, return filer }
END;



PROCEDURE UnfileObject{* obj: ObjectHandle; deskPt: Point *};
{ animates icon being unfiled, moves it to the desktop }
VAR homeObj,placeObj: ObjectHandle;
    homePt: Point;
    dh,dv: INTEGER;
    savePort: GrafPtr;
    saveState: ObjectState;  {my fix -gb }
BEGIN
IF trcFiler THEN WRITELN('UnfileObject "',obj^^.name,'"');
GetPort(savePort);
IF NOT (obj^^.kind IN diskSet) THEN
   BEGIN
   SetPort(deskObject^^.objWindow);
   LocalToGlobal(deskPt);
   FindVisParent(obj,homePt,homeObj,placeObj);  { find first visible ancestor }
   IF homeObj^^.isOpen THEN
      BEGIN
      saveState := obj^^.state;
      ChangeObject(obj,limbo,0,0,TRUE);  { change to ghost as if dragging }
      dh := deskPt.h - homePt.h;
      dv := deskPt.v - homePt.v;
      IF NOT MoveObject(obj,dh,dv,deskObject,FALSE,FALSE,FALSE) THEN;
      ChangeObject(obj,saveState,0,0,FALSE);
      END;
   WalkObject(obj,homePt,deskPt);   { animate object to desk location }
   GlobalToLocal(deskPt);
   END;
obj^^.loc := deskPt;
DrawObject(obj);
SetPort(savePort);
END;



{$IFC R}
{$S DiskStuff }
FUNCTION UnmountAvolume{* device: Tdevice; eject,restartDocs: BOOLEAN;
                          alertNum: INTEGER *};

{ removes objects from the desktop and unmounts the volume.  returns FALSE is }
{ a document refuses to be put back }

VAR diskObj: ObjectHandle;
    volHdl: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('UnmountAvolume');
UnmountAvolume := FALSE;
IF Abort THEN EXIT(UnmountAvolume);

CASE device OF
   upperDrive: diskObj := floppy1Object;
   lowerDrive: diskObj := floppy2Object;
   OTHERWISE   diskObj := hardDiskObject;
   END;

volHdl := diskObj^^.volHdl;
eject := eject AND (volHdl <> bootVol);

IF diskObj <> nilObject THEN
   BEGIN
   IF volHdl <> NIL THEN  { make sure its mounted }
      { save state and put away unfiled objects }
      IF NOT CleanupDisk(diskObj) THEN EXIT(UnmountAvolume);

   { remove the disk icon if ejecting the disk }
   IF eject THEN
      KillObject(diskObj,TRUE,TRUE)
   ELSE
      diskObj^^.volHdl := NIL;   { mark as unmounted }
   END;

IF alertNum <> 0 THEN WaitAlert(flrAlert,alertNum);

IF volHdl <> bootVol THEN DismountVol(device,eject,restartDocs);

UpdateObject(deskObject,TRUE);
UnmountAvolume := TRUE;
END;
{$ENDC}



{$S Filer }
PROCEDURE UpdateContents{* obj: ObjectHandle *};
{ processes any outstanding updates for all descendants }
VAR son,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('UpdateContents "',obj^^.name,'"');
listHead := obj^^.contents;
son := listHead^^.next;
WHILE son <> listHead DO
   BEGIN
   UpdateObject(son,TRUE);
   son := son^^.next;
   END;
END;



{$S  }
PROCEDURE UpdateCursor;
{ changes cursor as appropriate }
VAR savePort: GrafPtr;
    pt: Point;
    whichCursor: INTEGER;
BEGIN
IF editObject = nilObject THEN EXIT(UpdateCursor);

GetPort(savePort);
SetPort(editObject^^.container^^.objWindow);

GetMouse(pt);

IF PtInRect(pt,editObject^^.nameRect) THEN
   whichCursor := icrsXIBeam
ELSE
   whichCursor := icrsInactive;

SetStdCursor(whichCursor);
SetPort(savePort);
END;


{$S Filer }
PROCEDURE UpdateField;
{ draws the current field and updates all copies }
VAR strg: FmaxStr;
    oldNameWidth: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('UpdateField');
DrawName(editObject);

GetFldStr(hCurFld,hCurFstate,strg);
editObject^^.name := strg;

{ update window title if a window exits }
IF editObject^^.objWindow <> NIL THEN
   SetFldrTitle(editObject^^.objWindow,strg);

{ Update extra image if one exists }
IF edit2Object <> nilObject THEN
   BEGIN
   IF edit2Object^^.objWindow <> NIL THEN
      SetFldrTitle(edit2Object^^.objWindow,strg);
   edit2Object^^.name := strg;
   { ??? IF edit2Obj^^.container^^.viewMode = spatialView THEN }
   { removed to allow updates in list view - nr bug #3 -gb 3/3/83 }
      BEGIN
      WITH edit2Object^^.nameRect DO oldNameWidth := right - left;
      IF NameWidth(edit2Object) < oldNameWidth THEN
         BEGIN
         ValidName(edit2Object,FALSE);
         UpdateObject(edit2Object^^.container,FALSE);
         EXIT(UpdateField);
         END;
      END;
   DrawName(edit2Object);
   END;
END;



PROCEDURE UpdateObject{* obj: ObjectHandle; sonsAlso: BOOLEAN *};
{ processes update for an object window, quits fast if nothing to update }
VAR window: WindowPtr;
    docHdl: TentryHdl;
BEGIN
IF trcFiler THEN WRITELN('UpdateObject "',obj^^.name,'"');
IF obj = nilObject THEN EXIT(UpdateObject);
IF sonsAlso THEN UpdateContents(obj);   { update any opened in place }
IF obj^^.isOpen THEN
   BEGIN
   window := obj^^.objWindow;
   IF window = NIL THEN
      BEGIN
      WRITELN('*** UpdateObject called with NIL window ptr');
      EXIT(UpdateObject);
      END;

   IF obj^^.kind IN docToolSet THEN
      BEGIN
{$IFC R}
      docHdl := WindowToDocEntry(window);
      IF docHdl <> NIL THEN
         BEGIN
         IF docHdl^^.state IN [opening,opened,closingFolder,closing] THEN
            EXIT(UpdateObject);   { window is managed by an application }
         END;
{$ENDC}
      END;
   BeginUpdate(window);
   IF NOT emptyRgn(window^.visRgn) THEN DrawInsides(obj);
   EndUpdate(window);
   END;
END;



PROCEDURE UpdateRec{* obj: ObjectHandle; VAR catRec: TcatRec *};
{ updates a catalog record from object record }
BEGIN
IF trcFiler THEN WRITELN('UpdateRec "',obj^^.name,'"');
WITH catRec,obj^^ DO
   BEGIN
   InsObjName(catRec,name);
   objKind  := kind;
   IF (NOT toBeCopied) AND isFiled THEN closedPt := loc;
   openRect := windowRect;
   END;
END;


{$S  }
PROCEDURE UpdateText;
{ draws chars or blinks caret if timeout }
VAR theTime: LongInt;
    inList: BOOLEAN;
BEGIN
IF editObject = nilObject THEN EXIT(UpdateText);
IF timeoutTime = noTimeout THEN EXIT(UpdateText);

theTime := Time;
IF trcFiler THEN WRITELN('UpdateText - time: ',theTime:1,'  timeoutTime: ',
                          timeoutTime:1);

IF theTime >= timeoutTime THEN
   BEGIN
   SetPort(editObject^^.container^^.objWindow);
   IF NOT hCurFstate^^.valid THEN
      UpdateField
   ELSE
      BEGIN
      IF trcFiler THEN WRITELN('   blink caret');
      inList := (editObject^^.container^^.viewMode <> spatialView);
      IF inList THEN
         ClipRight(hCurFld^^.coords.right);
      BlinkCaret(hCurFld,hCurFstate,timeoutInterval);
      IF inList
         THEN ClipContent(editObject^^.container);
      SetTimeout(timeoutInterval);
      END;
   END;
END;



{$S  }
PROCEDURE ValidContents{* obj: ObjectHandle; whichState: ObjectState;
                                                         good: BOOLEAN *};
{ validate/invalidate the area under all objects of a given state }
VAR son,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('ValidContents "',obj^^.name,'"');
listHead:=obj^^.contents;
son:=listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state=whichState THEN ValidObject(son,good);
   son:=son^^.prev;
   END;
END;



{$S  }
(*** DS
PROCEDURE ValidIcon{* obj: ObjectHandle; good: BOOLEAN *};
{ validate/invalidate the icon rect of an object }
VAR iconRect: Rect;
    pt: Point;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('ValidIcon "',obj^^.name,'"');
GetPort(savePort);
WITH obj^^ DO
   BEGIN
   SetPort(container^^.objWindow);
   IF container^^.viewMode = spatialView THEN
      BEGIN
      iconRect := iconHeader.iconInfo[kind].bounds;
      OffsetRect(iconRect,loc.h,loc.v);
      END
   ELSE
      BEGIN
      GetListPos(obj,TRUE,pt);
      SetRect(iconRect,pt.h,pt.v,pt.h+24,pt.v+16);
      END;
   IF good THEN ValidRect(iconRect) ELSE InvalRect(iconRect);
   END;
SetPort(savePort);
END;
***)


(*** DS ***)
PROCEDURE ValidIcon{* obj: ObjectHandle; good: BOOLEAN *};
{ validate/invalidate the icon rect of an object }
VAR iconRect: Rect;
    pt: Point;
    savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('ValidIcon');
GetPort(savePort);
WITH obj^^ DO
   BEGIN
   SetPort(container^^.objWindow);
   IF container^^.viewMode = spatialView THEN
      BEGIN
      iconRect := iconBoxes[kind];
      OffsetRect(iconRect,loc.h,loc.v);
      END
   ELSE
      BEGIN
      GetListPos(obj,TRUE,pt);
      SetRect(iconRect,pt.h,pt.v,pt.h+24,pt.v+16);
      {IF good
      {  THEN SetRect(iconRect,pt.h,pt.v,pt.h+24,pt.v+16)
      {  ELSE iconRect := container^^.objWindow^.PortRect; }
      END;
   IF good THEN ValidRect(iconRect) ELSE InvalRect(iconRect);
   END;
SetPort(savePort);
END;



{$S  }
PROCEDURE ValidName{* obj: ObjectHandle; good: BOOLEAN *};
{ validate/invalidate the name rect of an object }
VAR nameRect: Rect;
    nameWidth: INTEGER;
    savePort: GrafPtr;
BEGIN
{ IF LENGTH(obj^^.name) = 0 THEN EXIT(ValidName); removed for nr bug #3 -gb }
IF trcFiler THEN WRITELN('ValidName "',obj^^.name,'"');

IF NOT obj^^.container^^.isOpen THEN EXIT(ValidName); {invis obj hack -gb }

GetPort(savePort);
WITH obj^^ DO
   BEGIN
   SetPort(container^^.objWindow);
   InsetRect(nameRect, -1, -1);
   IF good THEN ValidRect(nameRect) ELSE InvalRect(nameRect);
   END;
SetPort(savePort);
END;



{$S  }
PROCEDURE ValidObject{* obj: ObjectHandle; good: BOOLEAN *};
{ vaildate/invalidate the area under a given object }
VAR savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('ValidObject "',obj^^.name,'"');

IF sDebug THEN IF NOT obj^^.container^^.isOpen  { my added checks -gb }
  THEN WRITELN('ValidObj "', obj^^.name, '" container closed');
WITH obj^^ DO
  IF (loc.h > 10000) OR (loc.h < -10000) OR
     (loc.v > 10000) OR (loc.v < -10000)
    THEN BEGIN
      IF sDebug THEN
        WRITELN('ValidObj "', name, '" loc out of range', loc.h, loc.v);
      HoldIt(cDebug);
      EXIT(ValidObject);
     END;

ValidIcon(obj,good);
IF obj^^.container^^.viewMode = spatialView THEN ValidName(obj,good);
  {  ELSE IF NOT good THEN BEGIN  { nr fix #3 3/3/83 -gb - ELSE added }
  {    GetPort(savePort);
  {    SetPort(container^^.objWindow);
  {    InvalRect(container^^.objWindow^.PortRect);
  {    SetPort(savePort);
  {   END;  This fix does not seem to be needed anymore -gb 3/9/83 }
END;



{$S Filer }
PROCEDURE ValidScrollBars{* window : WindowPtr; good: BOOLEAN *};
{ validate/invalidate scroll bar area }
VAR rH,rV,growRect: Rect;
    savePort: GrafPtr;
BEGIN
IF (window = filerFolder) THEN EXIT(ValidScrollBars);
IF trcFiler THEN WRITELN('ValidScrollBars');

GetPort(savePort);
SetPort(window);

FlushRects(rH,rV);
GetGrowRect(growRect);
UnionRect(growRect,rV,rV);

IF good THEN
   BEGIN
   ValidRect(rV);
   ValidRect(rH);
   END
ELSE
   BEGIN
   InvalRect(rV);
   InvalRect(rH);
   END;

SetPort(savePort);
END;



PROCEDURE ValidWindow{* window: WindowPtr; good: BOOLEAN *};
{ validate/invalidate an entire window }
VAR savePort: GrafPtr;
BEGIN
IF trcFiler THEN WRITELN('ValidWindow');
GetPort(savePort);
SetPort(window);
IF good THEN ValidRect(window^.portRect) ELSE InvalRect(window^.portRect);
SetPort(savePort);
END;



PROCEDURE WalkContents{* obj: ObjectHandle; whichState: ObjectState;
                         dhStart,dvStart,dhStop,dvStop: INTEGER *};
{ Drag the image of some icons, interpolating between start and stop deltas }
{ No net change to the screen or icons }

VAR dh1,dh2,dv1,dv2,step,nSteps,dist: LongInt;
    minTime: LongInt;
    tallyCount: INTEGER;
    tallySet: KindSet;
    tallyBBox: Rect;
    topObject: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('WalkContents "',obj^^.name,'"');
TallyContents(obj,whichState,tallyCount,tallySet,tallyBBox,topObject);
dist:= ABS(dhStart-dhStop) + (3*ABS(dvStart-dvStop) DIV 2); { approx for velocity }
If TallyCount <> 0 then             {if tallycount <> 0 then divide o.k. SPRING }
   nSteps:=dist DIV (15*tallyCount)
  else                              {else, avoid divide to protect from error   }
   nSteps:= 0;
IF nSteps < 8 THEN nSteps:=8;
dh2:=dhStart;
dv2:=dvStart;
XorContents(obj,whichState,dh2,dv2);  { draw initial image }
FOR step:=1 TO nSteps-1 DO
   BEGIN
   dh1:=dh2;
   dv1:=dv2;
   dh2:=(dhStop*step + dhStart*(nSteps-step)) DIV nSteps;
   dv2:=(dvStop*step + dvStart*(nSteps-step)) DIV nSteps;
   XorContents(obj,whichState,dh2,dv2);  { draw new image }
   XorContents(obj,whichState,dh1,dv1);  { erase old image }
   END;
XorContents(obj,whichState,dh2,dv2);  { erase final image }
END;



PROCEDURE WalkHome{* obj: ObjectHandle *};
{ animate icon moving to filing home }
VAR savePort: GrafPtr;
    curPt,destPt,deltaPt: Point;
    dh,dv: INTEGER;
    homeObj,placeObj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('WalkHome "',obj^^.name,'"');
GetPort(savePort);

IF obj = editObject THEN EndEdit;  {my fix - problem with invisible objects -gb }

{ change to hidden state as if user was dragging it }
ChangeObject(obj,hidden,0,0,TRUE);


{ convert current location to global }
curPt:=obj^^.loc;
SetPort(obj^^.container^^.objWindow);
LocalToGlobal(curPt);

{ determine destPt, either location in home or location of some parent icon }
FindVisParent(obj,destPt,homeObj,placeObj);

{ take care of any update now, looks better }
UpdateObject(deskObject,TRUE);

{ animate the icon to its home }
WalkObject(obj,curPt,destPt);

{ schedule update to erase old image }
ValidObject(obj,FALSE);

{ take care of new image }
IF homeObj^^.isOpen THEN
   BEGIN
   obj^^.loc := placeObj^^.loc;   { reset spatial home position }
   IF MoveObject(obj,0,0,homeObj,FALSE,FALSE,FALSE) THEN;
   ValidObject(obj,TRUE);   { cancel update scheduled for placeholder }
   ChangeObject(obj,normal,0,0,TRUE);
   END
ELSE
   BEGIN
   BlinkObject(homeObj);   { blink to show acceptance }
   { hack for  not killing invis objs -gb
     dont -- KillObject(obj,TRUE,FALSE);
     but do:  }
      placeObj := GetPlaceHolder(obj);
      IF (placeObj <> nilObject) THEN
        WITH obj^^ DO BEGIN     { splice back in at same location as before }
         loc := placeObj^^.loc;   { reset spatial home position }
         prev^^.next := next;   { splice it out of where it is  }
         next^^.prev := prev;
         prev:=placeObj^^.prev;
         next:=placeObj;
         container := placeObj^^.container;
         prev^^.next:=obj;
         next^^.prev:=obj;
         KillObject(placeObj,TRUE,FALSE);
         state := normal
         END;
   END;

SetPort(savePort);
END;



PROCEDURE WalkObject{* obj: ObjectHandle; fromPt,toPt: Point *};
{ animates icon, no net change to screen, expects points in global coords }
VAR step: LongInt;
    nSteps: INTEGER;
    dh,dv: LongInt;
    savePort: GrafPtr;
    saveLoc: Point;
BEGIN
IF trcFiler THEN WRITELN('WalkObject "',obj^^.name,'"   from ',fromPt.h:1,
                         fromPt.v:4,' to ',toPt.h:1,toPt.v:4);
GetPort(savePort);
saveLoc:=obj^^.loc;

dh:=toPt.h-fromPt.h;
dv:=toPt.v-fromPt.v;

nSteps:=MAX((ABS(dh) + (3*ABS(dv) DIV 2)) DIV 10,10);

SetPort(obj^^.container^^.objWindow);
GlobalToLocal(fromPt);
obj^^.loc:=fromPt;

{ do the animation, drawing and erasing }
FOR step:=1 TO nSteps DO  { walk it back }
  BEGIN
  XorObject(obj,(dh*step) DIV nsteps,(dv*step) DIV nSteps);
  XorObject(obj,(dh*step) DIV nSteps,(dv*step) DIV nSteps);
  END;

obj^^.loc:=saveLoc;
SetPort(savePort);
END;



{$S  }
FUNCTION WhichObject{* container:  ObjectHandle; pt: Point;
                       VAR hitName: BOOLEAN): ObjectHandle *};
{ returns the topmost object pointed to, nilObject if none }
VAR son,listHead,objHit: ObjectHandle;
    iconRect: Rect;
    savePort: GrafPtr;
    objNum: INTEGER;
BEGIN
IF trcFiler THEN WRITELN('WhichObject in "',container^^.name,'"');
hitName := FALSE;
WhichObject:=nilObject;  { not found }
IF container = nilObject THEN EXIT(WhichObject);

{ localize pt for this window }
GetPort(savePort);
LocalToGlobal(pt);
SetPort(container^^.objWindow);
GlobalToLocal(pt);
SetPort(savePort);


IF container^^.viewMode = spatialView THEN
   BEGIN
   IF pt.v < (thePort^.portRect.top + TopPnlHt(container)) THEN EXIT(WhichObject);
   listHead:=container^^.contents;
   son:=listHead^^.next;

   WHILE son <> listHead DO WITH son^^ DO
      BEGIN
      IF state <> limbo THEN
         BEGIN
         (*** DS
         iconRect := iconHeader.iconInfo[kind].bounds;
         ***)
         iconRect := iconBoxes[kind];   (*** DS ***)
         OffsetRect(iconRect,loc.h,loc.v);
         IF PtInRect(pt,iconRect) THEN
            BEGIN
            WhichObject:=son;
            EXIT(WhichObject);
            END;
         IF PtInRect(pt,nameRect) THEN
            BEGIN
            whichObject := son;
            hitName := TRUE;
            EXIT(WhichObject);
            END;
         END;
      son:=next;
      END;

   END
ELSE
   BEGIN
   IF pt.v < (thePort^.portRect.top + TopPnlHt(container) + lineHt) THEN
      EXIT(WhichObject);   { quit if in top panel or titles }

   IF pt.h < 250 THEN   { in tiny icon or name }
      BEGIN
      objNum := (pt.v-TopPnlHt(container)) DIV lineHt;
      objHit := ObjFromNum(container,objNum);
      WhichObject := objHit;
      hitName := (objHit <> nilObject) AND (pt.h > 40);
      END;
   END;
END;



{$S Filer }
FUNCTION WhichSubKind{* kind : ObjectKind; toolId : TtoolID) : ObjectKind *};
{ given an object and a toolId, return the subkind }
BEGIN
IF trcFiler THEN WRITELN('WhichSubKind');
IF kind IN [docKind,toolKind,docPad] THEN
   BEGIN
   CASE toolID OF
      1: WhichSubKind := wpDocKind;
      2: WhichSubKind := bgDocKind;
      3: WhichSubKind := lcDocKind;
      4: WhichSubKind := geDocKind;
      5: WhichSubKind := lmDocKind;
      OTHERWISE WhichSubKind := nilKind;
      END
   END
ELSE
   WhichSubKind := nilKind;
END;



FUNCTION WhichWindow{* pt: Point): WindowPtr *};

{ determines which window the given point is in }
{ pt is assumed to be in local coords of current port }
VAR window: WindowPeek;

BEGIN
IF trcFiler THEN WRITELN('WhichWindow');
WhichWindow := Nil;
LocalToGlobal(pt);
IF pt.v < menuHt THEN EXIT(WhichWindow);   { In menu bar }
window:=Pointer(ORD(alertFolder));

WHILE window <> Nil DO WITH window^ DO
   BEGIN
   IF visible THEN
     IF PtInRgn(pt,strucRgn) THEN
       IF PtInRgn(pt,contRgn) THEN
          BEGIN
          WhichWindow:=Pointer(ORD(window));
          EXIT(whichWindow);
          END;
   window:=nextWindow;
   END;
END;



{$S  }
PROCEDURE XorContents{* obj: ObjectHandle;
                        whichState: ObjectState; dh,dv: INTEGER *};
{ Xor all objects in whichState with an offset }
VAR son,listHead: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('XorContents "',obj^^.name,'"');
listHead:=obj^^.contents;
son:=listHead^^.prev;
WHILE son <> listHead DO
   BEGIN
   IF son^^.state=whichState THEN XorObject(son,dh,dv);
   son:=son^^.prev;
   END;
END;



{$S  }
(*** DS ***)
PROCEDURE XorIcon{* kind: ObjectKind; topLeft: Point *};
{ XOR an icon's data image onto the screen in the current port }
BEGIN
IF trcFiler THEN WRITELN('XorIcon');
TextFont(fIconFont);
TextMode(srcXor);
MoveTo(topLeft.h,topLeft.v);
DrawChar(iconData[kind]);
END;



{$S  }
PROCEDURE XorObject{* obj: ObjectHandle; dh,dv: INTEGER *};
{ draw an object in xor mode, offset dh,dv }
VAR savePort: GrafPtr;
    pt: Point;
    tempRect: Rect;
BEGIN
IF trcFiler THEN WRITELN('XorObject "',obj^^.name,'"');
GetPort(savePort);
WITH obj^^ DO
   BEGIN
   IF container^^.viewMode = spatialView THEN
      pt := loc
   ELSE
      GetListPos(obj,FALSE,pt);

   pt.h:=pt.h+dh;
   pt.v:=pt.v+dv;

   { allow Xor objects to be drawn outside window boundaries }
   SetPort(container^^.objWindow);
   LocalToGlobal(pt);
   SetPort(deskPort);
   GlobalToLocal(pt);

   XorIcon(kind,pt);
   END;
SetPort(savePort);
END;



{$S Filer }
PROCEDURE ZoomObject{* obj: ObjectHandle; zoomUp: BOOLEAN *};
{ performs zoom effect when an object is opened or closed }
VAR smallRect: Rect;
    savePort: GrafPtr;
    fobj, cobj: ObjectHandle;
BEGIN
IF trcFiler THEN WRITELN('ZoomObject "',obj^^.name,'"');

  cobj := obj;
  REPEAT
    fobj := cobj;
    cobj := fobj^^.container;
    UNTIL cobj^^.isOpen OR (cobj = deskObject);

  IF cobj^^.viewMode = spatialView THEN
     BEGIN
     smallRect.left:=fobj^^.loc.h + icon2Width;
     smallRect.top :=fobj^^.loc.v + icon2Ht;
     END
  ELSE
     BEGIN
     GetListPos(fobj,TRUE,smallRect.topLeft);
     smallRect.left := smallRect.left + 8;
     smallRect.top  := smallRect.top  + 6;
     END;

  { restrict small rect to be within window boundaries }
  WITH cobj^^.objWindow^ DO
     BEGIN
     smallRect.top :=  MIN(smallRect.top,portRect.bottom);
     smallRect.left := MIN(smallRect.left,portRect.right);
     END;

  GetPort(savePort);
  SetPort(cobj^^.objWindow);
  LocalToGlobal(smallRect.topLeft);
  SetPort(savePort);

  smallRect.botRight:=smallRect.topLeft;
  ZoomRect(smallRect,obj^^.windowRect,zoomUp);
END;



PROCEDURE ZoomRect{* VAR smallRect,bigRect: Rect; zoomUp: BOOLEAN *};

{ Given two rectangles in global coords, interpolate one into the other, }
{ making a zooming rectangle image on the screen.  The rectangles and the }
{ screen image are not altered }

CONST zoomSteps = 48;  { used to be 16 -gb }
VAR rect1,rect2,rect3,rect4: Rect;
    i,j: INTEGER;
    savePort: GrafPtr;
    fract,factor,one: Fixed;   { reals are too slow }
    waveLength,deltaWave: MicroSeconds;

   FUNCTION Blend(smallCoord,bigCoord: INTEGER): INTEGER;
   VAR smallFix,bigFix,tempFix: Fixed;
   BEGIN
     smallFix:=one * smallCoord;     { scale up to fixed point }
     bigFix  :=one * bigCoord;
     tempFix :=FixMul(fract,bigFix) + FixMul(one-fract,smallFix);
     Blend   :=FixRound(tempFix);
   END;

BEGIN
IF trcFiler THEN WRITELN('ZoomRect');
  GetPort(savePort);
  SetPort(deskPort);
  PenPat(gray);
  PenMode(notPatXor);

  one:=65536;   { fixed point 'const' }
  IF zoomUp
  THEN
    BEGIN
      rect1:=smallRect;
            {factor:=FixRatio(6,5);        { make bigger each time }
      factor:=FixRatio(18,17);        { make bigger each time }
            {fract:=FixRatio(541,10000);   { 5/6 ^16 = 0.0540877 }
      fract:=FixRatio(643,10000);   { 17/18 ^48 = 0.064338 }
      waveLength := bigWave;
      deltaWave := (smallWave - bigWave) DIV zoomSteps;
    END
  ELSE
    BEGIN
      rect1:=bigRect;
          {factor:=FixRatio(5,6);        { make smaller each time }
      factor:=FixRatio(17,18);        { make smaller each time }
      fract:=one;                   { start full size }
      waveLength := smallWave;
      deltaWave := (bigWave - smallWave) DIV zoomSteps;
    END;

  rect2:=rect1;
  rect3:=rect1;
  FrameRect(rect1);   { draw initial image }

  IF wantSound THEN Noise(waveLength);

  FOR i:=1 TO zoomSteps DO
    BEGIN
      rect4.left   :=Blend(smallRect.left,bigRect.left);
      rect4.right  :=Blend(smallRect.right,bigRect.right);
      rect4.top    :=Blend(smallRect.top,bigRect.top);
      rect4.bottom :=Blend(smallRect.bottom,bigRect.bottom);

      FrameRect(rect4);  { draw newest }
      FrameRect(rect1);  { erase oldest }
      rect1:=rect2;
      rect2:=rect3;
      rect3:=rect4;

      fract:=FixMul(fract,factor);  { bump interpolation fraction }

      waveLength := waveLength + deltaWave;
      IF wantSound THEN Noise(waveLength);
    END;
  FrameRect(rect1);  { erase final image }
  FrameRect(rect2);
  FrameRect(rect3);
  PenNormal;

  IF wantSound THEN Silence;
  SetPort(savePort);
END;
