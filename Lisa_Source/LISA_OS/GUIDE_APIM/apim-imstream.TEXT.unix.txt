{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}


{$s imstc }
{$r- }

UNIT IMStream;


INTERFACE

USES {$U UnitStd.obj}  UnitStd,
     {$U UnitHz.obj}   UnitHz,
     {$U Storage.obj}  Storage,
     {$U QuickDraw}    QuickDraw,
     {$U FontMgr.obj}  FontMgr,
     {$U libos/SysCall.obj}  SysCall,
     {$U libos/PSysCall.obj} PSysCall,
     {$U PmDecl     }  PmDecl,
     {$U PMM        }  PMM,
     {$U WM.Events}    Events,
     {$U WM.Folders}   Folders,
     {$U WM.Menus }    Menus,
     {$U WMLStd  }     WMLStd,
     {$U WMLSB   }     WMLSb,
     {$U WMLGrow }     WMLGrow,
     {$U AlertMgr.obj} AlertMgr,
     {$U dbenv.obj}    dbenv,
     {$U fedec.obj}    fedec,
     {$U fld.obj}      FieldEdit,
     {$U apim/unitimf.obj}  UnitImf,
     {$U apim/imcore.obj}   IMCore,
     {$U apim/immenus.obj}  IMMenus;



PROCEDURE PxIMS(imsObj: THIMS);
PROCEDURE PxField(hfld: hndField; hfstate: hndFState);
PROCEDURE PxFldLine(hFldLine: THIMSLine; prtField, prtFState: TF);
PROCEDURE PxIMSLine(fLine: THImsLine);
PROCEDURE WindRct(imwObj: THIMW; VAR portRct: Rect);
PROCEDURE WindPt(imwObj: THIMW; VAR portPt: Point);
FUNCTION  WindVPos(imwObj: THIMW; portV: TC): TC;
FUNCTION  WindHPos(imwObj: THIMW; portH: TC): TC;
PROCEDURE PortRct(imwObj: THIMW; VAR windRct: Rect);
PROCEDURE PortPt(imwObj: THIMW; VAR windPt: Point);
FUNCTION  PortVPos(imwObj: THIMW; windV: TC): TC;
FUNCTION  PortHPos(imwObj: THIMW; windH: TC): TC;
PROCEDURE SetLnIdx(idxVal: TC; fRel: TF);
FUNCTION  NxtLnIdx: TC;
FUNCTION  NewIMWindow(port: GrafPtr; hFldr: THFldrInfo): THIMW;
PROCEDURE FreeIMWindow(imwObj: THIMW; freeStream: TF);
FUNCTION  ActSel(imsObj: THIMS): BOOLEAN;
PROCEDURE UnSelect(imsObj: THIMS);
PROCEDURE ExitSelection(imsObj: THIMS);
PROCEDURE FreeIMSLine(imsObj: THIMS; fLine: THIMSLine);
PROCEDURE MakeWSLink(imsObj: THIMS; imwObj: THIMW);
PROCEDURE BreakWSLink(wsLink: THWSLink; freeStream: TF);
PROCEDURE ResetLineData(imsObj: THIMS; lWid: TC);
PROCEDURE IMSFont(imsObj: THIMS; fIdx: TC);
PROCEDURE IMSLineVDsp(imsObj: THIMS; lVDsp: TC);
PROCEDURE IMSLineHt(imsObj: THIMS; lHt: TC);
FUNCTION  LineIndent(cLine: THIMSLine): TC;
FUNCTION  LineCCount(cLine: THIMSLine): TC;
FUNCTION  LineChars(cLine: THIMSLine): TRgch;
FUNCTION  NewIMStream: THIMS;
PROCEDURE ClearIMStream(imsObj: THIMS);
PROCEDURE FreeIMStream(imsObj: THIMS);
FUNCTION  LnWindowPos(wsLink: THWSLink; posLine: THIMSLine;
                          VAR linePos: Point): TF;
FUNCTION  LineAtPos(wsLink: THWSLink; hitPos: Point;
                     VAR linePos: Point): THIMSLine;
FUNCTION  LineAtStrPos(imsObj: THIMS; hitPos: Point;
                        VAR linePos: Point): THIMSLine;
FUNCTION  OverIMButton(wsLink: THWSLink; hitPos: Point): THIMSLine;
FUNCTION  PrevLine(imsObj: THIMS; cLine: THIMSLine): THIMSLine;
PROCEDURE InsertBefore(newLine, atLine: THImsLine);
PROCEDURE InsertAfter(newLine, atLine: THImsLine);
PROCEDURE AddLnToPrtRect(imsObj: THIMS; prtLn: THImsLine);
PROCEDURE SetHThumbPos(wsLink: THWSLink; cThumb: TC);
PROCEDURE SetVThumbPos(wsLink: THWSLink; cThumb: TC);
PROCEDURE SetIMWClip(imWindow: THIMW);
PROCEDURE ScrollWindow(wsLink:THWSLink; sbHit:THSb; iconHit:TIcon; hitPt:TPt);
PROCEDURE ShowStreamEnd(imsObj: THIMS);
FUNCTION  AddNewTextLine(imsObj: THIMS; lrgch: TRgch; chrCt: TC;
                         fShowEnd: TF): THIMSLine;
FUNCTION  StreamHt(imsObj: THIMS): TC;
FUNCTION  StreamWid(imsObj: THIMS): TC;
PROCEDURE IMSDrawLine(wsLink: THWSLink; dLine: THIMSLine; portPt: Point;
                          vlim: TC);
PROCEDURE DrawDWindow(wsLink: THWSLink);
PROCEDURE ReDrawDWRect(wsLink: THWSLink; pRect: Rect);
PROCEDURE SetDWDispRect(imwObj: THIMW; dr: Rect);
PROCEDURE SetDWRect(imwObj: THIMW; dr: Rect);
PROCEDURE AddBtnLine(imsObj: THIMS; bidx, hpos: TC; fShowEnd: TF);
PROCEDURE SetTxtBoxSize(imsObj: THIMS; VAR name: TStr20; bxVDsp: TC);
PROCEDURE ClearTextBox(imsObj: THIMS; VAR name: TStr20);
PROCEDURE StartPosBox(imsObj: THIMS; name: TStr20; bpos: Point);
PROCEDURE StartTextBox(imsObj: THIMS; VAR name: TStr20; fExchange: TF);
PROCEDURE EndTextBox(imsObj: THIMS);
FUNCTION  GetFldFont(hFldLine: THImsLine; VAR onlyFont: TF): TC;
FUNCTION  NewFldLine(imsObj: THIMS; lrgch: TRgch;
                     chrCt, fIdx, ht, vdsp, indent: TC): THIMSLine;
FUNCTION  TxtToFldLine(imsObj: THIMS; hTxtLine: THIMSLine): THIMSLine;
FUNCTION  FldToTxtLine(imsObj: THIMS; hFldLine: THIMSLine): THIMSLine;


IMPLEMENTATION


CONST
  CRtSlop = 30;
  CLftSlop = 20;
  fldPad = 1;

  vScrollDist = 3;
  hScrollDist = 6;

VAR CurLineIdx: TC;


FUNCTION  GetActObjIdx(VAR objIdx: TC): BOOLEAN; EXTERNAL;
PROCEDURE FreeLineSeq(imsObj: THIMS; VAR lseq: TLineSeq); FORWARD;
PROCEDURE DrawFromLine(wsLink: THWSLink; dLine: THIMSLine;
                           VAR linePt: Point; vlim: TC);  FORWARD;
PROCEDURE FixScroll(imwObj: THIMW);     FORWARD;


{$s imstdbg }
PROCEDURE PxIMS;  { (imsObj: THIMS); }
VAR fKey: TKeyStr;
BEGIN
 {$IFC IMDebug }
  WITH imsObj^^ DO
    BEGIN
      GetFontKey(fKey, sLineData.dLFIdx);
      WRITELN('IMStream: ',ORD(imsObj),
               '  sTextBox:', ORD(sTextBox), '  sField:', ORD(sField));
      WRITELN('  sLineCount:', sLineCount, '  sKeepCt:', sKeepCt:5);
      WRITELN('  sLineSeq.sLstLine:', ORD(sLineSeq.sFstLine),
          '  sLineSeq.sFstLine:', ORD(sLineSeq.sLstLine),
          '  sLink:', ORD(sLink));
      WRITELN('  sPosLineSeq.sLstLine:', ORD(sPosLineSeq.sFstLine),
          '  sPosLineSeq.sFstLine:', ORD(sPosLineSeq.sLstLine));
      WRITELN('  sLineData.dLFIdx: ', sLineData.dLFIdx, '  (', fKey, ')' );
      WITH sLineData DO
        WRITELN('  dLHt:', dLHt, ' dLVDsp:', dLVDsp, ' dLIndent:', dLIndent);
    END;
 {$ENDC }
END;


{$IFC IMDebug }
{$s imstdbg }
PROCEDURE PxTxtLine(hTxtLine: THIMSLine);
VAR i: INTEGER;
BEGIN
 IF hTxtLine <> NIL
   THEN
     WITH hTxtLine^^ DO
       BEGIN
         WRITELN('TxtLine: ',  ORD(hTxtLine), 'lineIndex:', lIdx,
                 ' lHt:', lHt:4, ' lVDsp:', lVDsp:4);
 {$R-}
         FOR i := 0 TO txt.tChrCt - 1 DO WRITE(CHR(txt.tChars[i]));
 {$R+} {$r- }
         WRITELN;
       END
   ELSE WRITELN('PxTxtLine of null box');
END;
{$ENDC }


{$IFC IMDebug }
{$s imstdbg }
PROCEDURE PxBxInfo(hBoxLine: THIMSLine);
BEGIN
  WITH hBoxLine^^.box DO
    BEGIN
      WRITELN('  bName:', bName, '  box.lseq: ',  ORD(bLineSeq.sFstLine),
              ORD(bLineSeq.sLstLine));
    END;
END;
{$ENDC }


{$s imstdbg }
PROCEDURE PxBoxLine(hBoxLine: THIMSLine);
BEGIN
 {$IFC IMDebug }
 IF hBoxLine <> NIL
   THEN
     WITH hBoxLine^^ DO
       BEGIN
         WRITELN('BoxLine: ',  ORD(hBoxLine), 'lineIndex:', lIdx,
                 ' lHt:', lHt:4, ' lVDsp:', lVDsp:4);
         PxBxInfo(hBoxLine);
       END
   ELSE WRITELN('PxBoxLine of null box');
 {$ENDC }
END;


{$s imstdbg }
PROCEDURE PxPBxLine(hPBxLine: THIMSLine);
VAR i: INTEGER;
BEGIN
{$IFC IMDebug }
 IF hPBxLine <> NIL
   THEN
     WITH hPBxLine^^ DO
       BEGIN
         WRITELN('PBxLine: ',  ORD(hPBxLine), 'lineIndex:', lIdx,
                 ' lHt:', lHt:4, ' lVDsp:', lVDsp:4);
         WRITELN(' PBxPos: ',  pbxPos.h, pbxPos.v);
         PxBxInfo(hPBxLine);
       END
   ELSE WRITELN('PxPBxLine of null box');
{$ENDC }
END;


{$s imstdbg }
PROCEDURE PxBtnLine(hBtnLine: THIMSLine);
VAR bName: TKeyStr;
BEGIN
{$IFC IMDebug }
 IF hBtnLine <> NIL
   THEN
     WITH hBtnLine^^ DO
       BEGIN
         GetBtnKey(bName, btn.pBtnIdx);
         WRITELN('BtnLine: ',  ORD(hBtnLine), 'lineIndex:', lIdx,
                 ' lHt:', lHt:4, ' lVDsp:', lVDsp:4);
         WRITELN(' BtnIdx: ', btn.pBtnIdx:4, '(', bName,
                 ')   BtnHPos:', btn.pBtnHPos:5);
       END
   ELSE WRITELN('PxBtnLine of null line');
{$ENDC }
END;


{$IFC IMDebug }
{$s imstdbg }
PROCEDURE PxInterval(int: interval);
BEGIN
  WRITE('<', int.lpFst, ',', int.lpLim, '> ');
END;
{$ENDC }


{$IFC IMDebug }
{$s imstdbg }
PROCEDURE PxTxSel(txs: txSel);
BEGIN
  WRITE('TxSel: ');
  PxInterval(txs.int);
  WRITELN('tySel: ', ORD(txs.tySel), ' tyHilight: ', ORD(txs.tyHilight));
END;
{$ENDC }

{$IFC IMDebug }
{$s imstdbg }
PROCEDURE PxFState(hfs: hndFState);
BEGIN
  IF hfs <> NIL THEN
    WITH hfs^^ DO BEGIN
      WRITELN('Field State for field at: ', ORD(hfs^), '  handle:', ORD(hfs));
      WRITELN('select'); PxTxSel(select);
      WRITELN('anchor'); PxTxSel(anchor);
      WRITELN('selectOn: ', selectOn, ' VisCaret: ', VisCaret);
      WRITE('selectRect: '); PrintRect(selectRect);
      WRITELN('bsptr: ', bsptr, '  valid: ', valid, '  validLp: ', validLp);
      WRITE('space(interval) '); PxInterval(space);
      WRITELN;
      WRITELN('newSel: ', newSel, '  changed: ', changed);
    END
   ELSE WRITELN('Null Field State pointer.');
END;
{$ENDC }


{$s imstdbg }
PROCEDURE PxField;  { (hfld: hndField; hfstate: hndFState); }
VAR i,mx: TC;
    vrgch: TRgch;
BEGIN
 {$IFC IMDebug }
  IF hfld <> NIL THEN
    WITH hfld^^ DO BEGIN
      WRITELN('Field Record for field at: ', ORD(hfld^), '  handle:', ORD(hfld));
      WRITE('Field coords: '); PrintRect(coords);
      WRITELN('  maxlen:', maxlen, '  growLen:', growLen, ' curlen:', curlen);
      WRITELN('  maxfmts:', maxfmts, '  growFmts:', growFmts);
      WRITELN('  curfmts:', curfmts, '  fmtinfo(handle):', ORD(fmtinfo));
      WRITELN('  align: ', ORD(align), '  protect: ', protect);
      IF curlen > maxlen
        THEN BEGIN
          WRITELN('curlen larger than maxlen!! using maxlen for print limit');
          mx := maxlen;
         END
        ELSE mx := curlen;
      IF mx > 255 THEN BEGIN WRITELN('only printing first 255 chars.');
                         mx := 255;
                       END;
      WRITELN('Value - hdata:', ORD(curvalue), ' pdata:', ORD(curvalue^));
      vrgch := POINTER(ORD(curvalue^));
      WRITE('Value <');
      FOR i := 0 to (mx - 1) do WRITE(chr(vrgch^[i]));
      WRITELN('>');
    END
   ELSE WRITELN('Null Field pointer.');
  IF hfstate <> NIL THEN PxFState(hFState);
 {$ENDC }
END;


{$s imstdbg }
PROCEDURE PxFldLine; { (hFldLine: THIMSLine; prtField, prtFState: TF); }
BEGIN
 {$IFC IMDebug }
  WITH hFldLine^^ DO BEGIN
    WRITELN('FldLine: ',  ORD(hFldLine), 'lineIndex:', lIdx,
            ' lHt:', lHt:4, ' lVDsp:', lVDsp:4);
    WRITELN('  fhField: ', ORD(fld.fhField), ' fhFState:', ORD(fld.fhFState),
             '  fActSel: ', fld.fActSel);
    IF prtFState
      THEN BEGIN IF prtField THEN PxField(fld.fhField, fld.fhFState)
                             ELSE PxFState(fld.fhFState);
           END
      ELSE IF prtField
        THEN PxField(fld.fhField, NIL)
        ELSE WRITELN('  fhField: ', ORD(fld.fhField),
                     '  fhFState: ', ORD(fld.fhFState));
   END;
 {$ENDC }
END;


{$s imstdbg }
PROCEDURE PxIMSLine;  {  (fLine: THImsLine);  }
VAR fKey: TKeyStr;
    i: INTEGER;
BEGIN
 {$IFC IMDebug }
  IF fLine = NIL
    THEN BEGIN
      WRITELN('PxIMSLine of null line.');
      EXIT(PxIMSLine);
     END;
  CASE fLine^^.lType OF
    CTxtLine: PxTxtLine(fLine);
    CBoxLine: PxBoxLine(fLine);
    CPBxLine: PxPBxLine(fLine);
    CFldLine: PxFldLine(fLine, TRUE, FALSE);
    CBtnLine: PxBtnLine(fline);
    CFstLine: WRITELN('PxIMSLine of first line.');
    CLstLine: WRITELN('PxIMSLine of last line.');
   END;
 {$ENDC }
END;


{$s imsth }
PROCEDURE ZeroPt(VAR pt: Point);
BEGIN
  SetPt(pt, 0 ,0);
END;


{$s imstw }
PROCEDURE WindRct;  {(imwObj: THIMW; VAR portRct: Rect);}
BEGIN
  SubPt(imwObj^^.wDispRect.topLeft, portRct.topLeft);
  SubPt(imwObj^^.wDispRect.topLeft, portRct.botRight);
END;


{$s imstw }
PROCEDURE WindPt;  {(imwObj: THIMW; VAR portPt: Point);}
BEGIN
  SubPt(imwObj^^.wDispRect.topLeft, portPt);
END;


{$s imstw }
FUNCTION WindVPos;  {(imwObj: THIMW; portV: TC): TC;}
BEGIN
  WindVPos := portV - imwObj^^.wDispRect.top;
END;


{$s imstw }
FUNCTION WindHPos;  {(imwObj: THIMW; portH: TC): TC;}
BEGIN
  WindHPos := portH - imwObj^^.wDispRect.left;
END;


{$s imstw }
PROCEDURE PortPt;  {(imwObj: THIMW; VAR windPt: Point);}
BEGIN
  AddPt(imwObj^^.wDispRect.topLeft, windPt);
END;


{$s imstw }
PROCEDURE PortRct;  {(imwObj: THIMW; VAR windRct: Rect);}
BEGIN
  AddPt(imwObj^^.wDispRect.topLeft, windRct.topLeft);
  AddPt(imwObj^^.wDispRect.topLeft, windRct.botRight);
END;


{$s imstw }
FUNCTION PortVPos;  {(imwObj: THIMW; windV: TC): TC;}
BEGIN
  PortVPos := windV + imwObj^^.wDispRect.top;
END;


{$s imstw }
FUNCTION PortHPos;  {(imwObj: THIMW; windH: TC): TC;}
BEGIN
  PortHPos := windH + imwObj^^.wDispRect.left;
END;


{$s imstw }
PROCEDURE SetLnIdx;  { (idxVal: TC; fRel: TF); }
BEGIN
  IF fRel
    THEN CurLineIdx := CurLineIdx + idxVal
    ELSE CurLineIdx := idxVal;
END;


{$s imstw }
FUNCTION  NxtLnIdx;  { : TC; }
BEGIN
  CurLineIdx := CurLineIdx + 1;
  NxtLnIdx := CurLineIdx;
END;


{$s imstc }
FUNCTION  NewIMWindow; {(port: GrafPtr; hFldr: THFldrInfo): THIMW;}
VAR imwObj: THIMW;
    svPort: WindowPtr;
    sbPt: Point;
    rH, rV: Rect;
BEGIN
  imwObj := POINTER(ORD(HAllocate(StrHeap, SIZEOF(TIMWindow))));
  WITH imwObj^^ DO
    BEGIN
      wPort := port;
      wFldr := hFldr;
      wLink := NIL;
      wRect := port^.PortRect;
      wHSbar := hsbNil;
      wVSbar := hsbNil;
      WITH wRect DO SetRect(wDispRect, left, top, right, bottom);
    END;
  IF hFldr^^.fldrSBars
    THEN BEGIN
      GetPort(svPort);
      SetPort(port);
      FlushRects(rH, rV);
      SetPt(sbPt, 0, 0);
      imwObj^^.wVSbar := SbCreate(hFldr^^.fldrSBList, hsbNil, V, sbPt, 0);
      IF port = scrapFolder
        THEN SetSbIcons(imwObj^^.wVSbar, [])
        ELSE SetSbIcons(imwObj^^.wVSbar,
                 [iconArwA, iconPagA, iconThumb, iconPagB, iconArwB]);
      SetSbRect(imwObj^^.wVSbar, rV);
      SetThumb(imwObj^^.wVSbar, 0);
      imwObj^^.wHSbar := SbCreate(hFldr^^.fldrSBList, hsbNil, H, sbPt, 0);
      IF port = scrapFolder
        THEN SetSbIcons(imwObj^^.wHSbar, [])
        ELSE SetSbIcons(imwObj^^.wHSbar,
                  [iconArwA, iconPagA, iconThumb, iconPagB, iconArwB]);
      SetSbRect(imwObj^^.wHSbar, rH);
      SetThumb(imwObj^^.wHSbar, 0);
      SetPort(svPort);
    END;
  NewIMWindow := imwObj;
END;


{$s imstc }
PROCEDURE FreeIMWindow; { (imwObj: THIMW; freeStream: TF); }
BEGIN
  IF imwObj = NIL THEN EXIT(FreeIMWindow);
  BreakWSLink(imwObj^^.wLink, freeStream);
  FreeBk(StrHeap, POINTER(ORD(imwObj)), tyBkStd);
END;


{$s imstc }
PROCEDURE NewLnSeq(VAR lseq: TLineSeq);
BEGIN
  lseq.sFstLine := POINTER(ORD(
                     HAllocate(StrHeap, CBaseLineSize + SIZEOF(TFstLine))));
  lseq.sLstLine := POINTER(ORD(
                     HAllocate(StrHeap, CBaseLineSize + SIZEOF(TFstLine))));
  WITH lseq.sFstLine^^ DO BEGIN
    lType := CFstLine;
    lHt := 0;
    lVDsp := 0;
    lNext := lseq.sLstLine;
    lPrev := NIL;
    lIdx := 0;
  END;
  WITH lseq.sLstLine^^ DO BEGIN
    lType := CLstLine;
    lHt := 0;
    lVDsp := 0;
    lNext := NIL;
    lPrev := lseq.sFstLine;
    lIdx := 0;
  END;
END;


{$s imstc }
PROCEDURE FreeFState(fLine: THIMSLine);
BEGIN
  IF fLine = NIL THEN EXIT(FreeFState);
  IF fLine^^.lType <> CFldLine THEN EXIT(FreeFState);
  IF fLine^^.fld.fhFState <> NIL THEN
    FreeBk(StrHeap, POINTER(ORD(fLine^^.fld.fhFState)), tyBkStd);
END;


{$s imsth }
FUNCTION ActSel;  { (imsObj: THIMS): BOOLEAN; }
BEGIN
  WITH imsObj^^ DO
    IF sField <> NIL
      THEN ActSel := sField^^.fld.fActSel
      ELSE ActSel := FALSE;
END;


{$s imstw }
PROCEDURE UnSelect;  { (imsObj: THIMS); }
VAR hFldLine: THIMSLine;
    svPort: GrafPtr;
BEGIN
  IF IMStst THEN WRITELN('UnSelect for Stream: ', ORD(imsObj));
  IF imsObj = NIL THEN EXIT(UnSelect);
  IF ActSel(imsObj)
    THEN BEGIN
      hFldLine := imsObj^^.sField;
      WITH hFldLine^^.fld DO ExitField(fhField, fhFState);
      FreeFState(hFldLine);
      WITH hFldLine^^.fld DO
         OffsetRect(fhField^^.coords, -fSelOffset.h, -fSelOffset.v);
      hFldLine^^.fld.fSelOffset.h := 0;
      hFldLine^^.fld.fSelOffset.v := 0;
      hFldLine^^.fld.fActSel := FALSE;
     END;
  imsObj^^.sField := NIL;
END;


{$s imstw }
PROCEDURE ExitSelection;  { (imsObj: THIMS); }
VAR hFldLine: THIMSLine;
    svPort: GrafPtr;
BEGIN
  IF IMStst THEN WRITELN('ExitSelection for Stream: ', ORD(imsObj));
  IF imsObj = NIL THEN EXIT(ExitSelection);
  IF ActSel(imsObj)
    THEN BEGIN
      GetPort(svPort);
{ this is a kludge }
IF imsObj^^.sLink <> NIL
  THEN SetPort(imsObj^^.sLink^^.kWindow^^.wPort)
  ELSE SetPort(LGPort);
      hFldLine := imsObj^^.sField;
      UnSelect(imsObj);
      hFldLine := FldToTxtLine(imsObj, hFldLine);
      SetPort(svPort);
     END;
END;


{$s imstw }
PROCEDURE FreeTxtLine(imsObj: THIMS; fLine: THIMSLine);
BEGIN
  FreeBk(StrHeap, POINTER(ORD(fLine)), tyBkStd);
END;


{$s imstw }
PROCEDURE FreeXstLine(imsObj: THIMS; fLine: THIMSLine);
BEGIN
  FreeBk(StrHeap, POINTER(ORD(fLine)), tyBkStd);
END;


{$s imstw }
PROCEDURE FreeBtnLine(imsObj: THIMS; fLine: THIMSLine);
BEGIN
  ClearBtn(fLine^^.btn.pBtnIdx);
  FreeBk(StrHeap, POINTER(ORD(fLine)), tyBkStd);
END;


{$s imstw }
PROCEDURE FreeBoxLine(imsObj: THIMS; fLine: THIMSLine);
BEGIN
  FreeLineSeq(imsObj, fLine^^.Box.bLineSeq);
  FreeBk(StrHeap, POINTER(ORD(fLine)), tyBkStd);
END;


{$s imstw }
PROCEDURE FreeFldLine(imsObj: THIMS; fLine: THIMSLine);
BEGIN
  IF fLine^^.fld.fActSel THEN UnSelect(imsObj);
  RemoveField(fLine^^.fld.fHField);
  FreeBk(StrHeap, POINTER(ORD(fLine)), tyBkStd);
END;


{$s imstw }
PROCEDURE FreeIMSLine;  { (imsObj: THIMS; fLine: THIMSLine); }
BEGIN
  IF fLine = NIL THEN EXIT(FreeIMSLine);
  IF imsObj = NIL
    THEN InterpError('Cant free line with NIL imsObj')
    ELSE BEGIN
      CASE fLine^^.lType OF
        CFstLine, CLstLine: FreeXstLine(imsObj, fLine);
        CTxtLine: FreeTxtLine(imsObj, fLine);
        CFldLine: FreeFldLine(imsObj, fLine);
        CBtnLine: FreeBtnLine(imsObj, fLine);
        CBoxLine, CPBxLine: FreeBoxLine(imsObj, fLine);
       END;
     END;
END;


{$s imstw }
PROCEDURE ClearLineSeq(imsObj: THIMS; VAR lseq: TLineSeq);
VAR fLine, nLine: THIMSLine;
BEGIN
  fLine := lseq.sFstLine^^.lNext;
  WHILE fLine <> lseq.sLstLine DO
    BEGIN
      nLine := fLine^^.lNext;
      FreeIMSLine(imsObj, fLine);
      fLine := nLine;
     END;
  lseq.sFstLine^^.lNext := lseq.sLstLine;
  lseq.sLstLine^^.lPrev := lseq.sFstLine;
END;


{$s imstw }
PROCEDURE FreeLineSeq;  { imsObj: THIMS; VAR lseq: TLineSeq); }
VAR fLine, nLine: THIMSLine;
BEGIN
  fLine := lseq.sFstLine;
  WHILE fLine <> NIL DO
    BEGIN
      nLine := fLine^^.lNext;
      FreeIMSLine(imsObj, fLine);
      fLine := nLine;
     END;
  lseq.sFstLine := NIL;
  lseq.sLstLine := NIL;
END;


{$s imstc }
PROCEDURE MakeWSLink;  { (imsObj: THIMS; imwObj: THIMW); }
VAR nxtStream: THIMS;
    wsLink, prevLink: THWSLink;
BEGIN
  IF (imsObj = NIL) OR (imwObj = NIL)
    THEN EXIT(MakeWSLink);
  IF imwObj^^.wLink <> NIL
    THEN BEGIN
      IF IMStst THEN WRITELN('Window: ', ORD(imwObj),
             ' is already linked. MakeWSLink to:', ORD(imsObj), ' is ignored.');
      EXIT(MakeWSLink);
     END;
  wsLink := POINTER(ORD(HAllocate(StrHeap, SIZEOF(TWSLink))));
  WITH wsLink^^ DO
    BEGIN
      kNext := NIL;
      kOffset.h := 0;
      kOffset.v := 0;
      kWindow := imwObj;
      kStream := imsObj;
      kLPOffset := kOffset;
      kPrtRect := nullRect;
    END;
  imwObj^^.wLink := wsLink;
  prevLink := imsObj^^.sLink;  { append wsLink to stream link list }
  IF prevLink = NIL
    THEN BEGIN
      imsObj^^.sLink := wsLink;
     END
    ELSE BEGIN
      WHILE prevLink^^.kNext <> NIL DO prevLink := prevLink^^.kNext;
      prevLink^^.kNext := wsLink;
     END;
END;


{$s imstc }
PROCEDURE BreakWSLink;  { (wsLink: THWSLink; freeStream: TF); }
VAR prevLink: THWSLink;
BEGIN
  IF wsLink = NIL THEN EXIT(BreakWSLink);
  wsLink^^.kWindow^^.wLink := NIL;
  prevLink := wsLink^^.kStream^^.sLink;
  IF prevLink = wsLink
    THEN BEGIN
      IF (wsLink^^.kStream^^.sLink = NIL) AND freeStream
         THEN { the stream is not linked to any other window, let it go }
           FreeIMStream(wsLink^^.kStream)
         ELSE wsLink^^.kStream^^.sLink := wsLink^^.kNext;
     END
    ELSE BEGIN
      WHILE prevLink <> NIL DO
        BEGIN
          IF prevLink^^.kNext = wsLink
            THEN BEGIN
              prevLink^^.kNext := wsLink^^.kNext;
              prevLink := NIL;
             END
            ELSE prevLink := prevLink^^.kNext
        END;
     END;
  FreeBk(StrHeap, POINTER(ORD(wsLink)), tyBkStd);
END;


{$s imstc }
PROCEDURE ChangeWSOffsets(imsObj: THIMS; ct: TC; fDelta, fOff, fLPOff: TF);
VAR wsLink: THWSLink;
BEGIN
  IF imsObj = NIL THEN EXIT(ChangeWSOffsets);
  wsLink := imsObj^^.sLink;
  WHILE wsLink <> NIL DO
    BEGIN
      IF fDelta
        THEN WITH wsLink^^ DO BEGIN
          IF fOff   THEN kOffset.v := kOffset.v + ct;
          IF fLPOff THEN kLPOffset.v := kLPOffset.v + ct;
         END
        ELSE WITH wsLink^^ DO BEGIN
          IF fOff   THEN kOffset.v := ct;
          IF fLPOff THEN kLPOffset.v := ct;
         END;
       wsLink := wsLink^^.kNext;
    END;
END;


{$s imstw }
PROCEDURE ChopLine(imsObj: THIMS);
VAR cLine: THIMSLine;
    cHt: TC;
BEGIN
  cLine := imsObj^^.sLineSeq.sFstLine^^.lNext;
  IF cLine^^.lType = CLstLine
    THEN BEGIN
      EXIT(ChopLine);
     END;
  cHt := cLine^^.lVDsp;
  WITH imsObj^^.sLineSeq DO
    BEGIN
      sFstLine^^.lNext := cLine^^.lNext;
      sFstLine^^.lNext^^.lPrev := sFstLine;
     END;
  WITH imsObj^^ DO sLineCount := sLineCount - 1;
  ChangeWSOffsets(imsObj, cHt, TRUE, TRUE, TRUE);
  FreeIMSLine(imsObj, cLine);
END;


{$s imstc }
PROCEDURE FreeWSLinks(imsObj: THIMS);
VAR wsLink, nxWsLink: THWSLink;
BEGIN
  IF IMStst THEN WRITELN('Freeing WS Links for stream:', ORD(imsObj));
  IF imsObj = NIL THEN EXIT(FreeWSLinks);
  wsLink := imsObj^^.sLink;
  WHILE wsLink <> NIL DO
    BEGIN
      nxWsLink := wsLink^^.kNext;
      BreakWSLink(wsLink, FALSE);
      wsLink := nxWsLink;
    END;
END;


{$s imstc }
PROCEDURE ResetLineData;  { (imsObj: THIMS; lWid: TC); }
BEGIN
  IF imsObj = NIL THEN EXIT(ResetLineData);
  WITH imsObj^^.sLineData DO
    BEGIN
      dLFIdx := IMFontIdx;
      dLHt := -1;
      dLVDsp := -1;
      dLIndent := 0;
      IF lWid > 0 THEN dLWidth := lwid;
    END;
END;


{$s imstw }
PROCEDURE IMSFont; {  (imsObj: THIMS; fIdx: TC);  }
BEGIN
   imsObj^^.sLineData.dLFIdx := fIdx;
END;


{$s imstw }
PROCEDURE IMSLineVDsp; {  (imsObj: THIMS; lVDsp: TC);  }
BEGIN
   imsObj^^.sLineData.dLVDsp := lVDsp;
END;


{$s imstw }
PROCEDURE IMSLineHt; {  (imsObj: THIMS; lHt: TC);  }
BEGIN
   imsObj^^.sLineData.dLHt := lHt;
END;


{$s imstw }
FUNCTION  LineIndent;  { (cLine: THIMSLine): TC; }
BEGIN
  IF cLine = NIL THEN BEGIN LineIndent := 0; EXIT(LineIndent); END;
  CASE cLine^^.lType OF
    CTxtLine: LineIndent := cLine^^.txt.tIndent;
    CFldLine: WITH cLine^^.fld DO
                LineIndent := fhField^^.coords.left - fSelOffset.h + fldPad;
    OTHERWISE LineIndent := 0;
   END;
END;


{$s imstw }
FUNCTION  LineCCount;  { (cLine: THIMSLine): TC; }
BEGIN
  IF cLine = NIL THEN BEGIN LineCCount := 0; EXIT(LineCCount); END;
  CASE cLine^^.lType OF
    CTxtLine: LineCCount := cLine^^.txt.tChrCt;
    CFldLine: LineCCount := cLine^^.fld.fhField^^.curLen;
    OTHERWISE LineCCount := 0;
   END;
END;


{$s imstw }
FUNCTION  LineChars;  { (cLine: THIMSLine): TRgch; }
BEGIN
  IF cLine = NIL THEN BEGIN LineChars := NIL; EXIT(LineChars); END;
  CASE cLine^^.lType OF
    CTxtLine: LineChars := @cLine^^.txt.tChars;
    CFldLine: WITH cLine^^.fld DO BEGIN       { fixed 2/18/83 non-reported }
                ExitField(fhField, fhFState); { LisaGuide bug # 1        }
                HilightSel(fhField, fhFState, TRUE);
                fhFState^^.newSel := TRUE;
                LineChars := POINTER(ORD(cLine^^.fld.fhField^^.curValue^));
               END;
    OTHERWISE LineChars := NIL;
   END;
END;


{$s imstc }
FUNCTION NewIMStream;  {: THIMS; }
VAR imsObj: THIMS;
    fOK: TF;
BEGIN
  IF IMStst THEN WRITELN('Creating IMStream ');
  imsObj := POINTER(ORD(HAllocate(StrHeap, SIZEOF(TIMStream))));
  WITH imsObj^^ DO
    BEGIN
      sTextBox := NIL;
      sField := NIL;
      sLineCount := 0;
      sKeepCt := 0;
      NewLnSeq(sLineSeq);
      NewLnSeq(sPosLineSeq);
      sLink := NIL;
      sCanSelect   := TRUE;
      sCanAddLines := FALSE;
      sDontErase   := FALSE;
      ResetLineData(imsObj, 400);
    END;
  IF IMStst THEN PxIMS(imsObj);
  NewIMStream := imsObj;
END;


{$s imstw }
PROCEDURE ClearIMStream; { (imsObj: THIMS); }
VAR fLine, nLine: THIMSLine;
    wsLink: THWSLink;
BEGIN
  IF IMStst THEN WRITELN('ClearIMStream: ', ORD(imsObj));
  IF imsObj = NIL THEN EXIT(ClearIMStream);
  ClearLineSeq(imsObj, imsObj^^.sLineSeq);
  ClearLineSeq(imsObj, imsObj^^.sPosLineSeq);
  WITH imsObj^^ DO
    BEGIN
      UnSelect(imsObj);
      sLineCount := 0;
      sTextBox := NIL;
      wsLink := sLink;
      WHILE wsLink <> NIL DO
        WITH wsLink^^ DO WITH kWindow^^ DO BEGIN
          kOffset.h := 0;
          kOffset.v := 0;
          kLPOffset := kOffset;
          kPrtRect := nullRect;
          SetPort(wPort);
          EraseRect(wRect);
          wsLink := kNext;
        END;
    END;
END;


{$s imstc }
PROCEDURE FreeIMStream; { (imsObj: THIMS); }
BEGIN
  IF IMStst THEN WRITELN('FreeIMStream: ', ORD(imsObj));
  IF imsObj = NIL THEN EXIT(FreeIMStream);
  FreeWSLinks(imsObj);
  FreeLineSeq(imsObj, imsObj^^.sLineSeq);
  FreeLineSeq(imsObj, imsObj^^.sPosLineSeq);
  FreeBk(StrHeap, POINTER(ORD(imsObj)), tyBkStd);
END;


{$s imstw }
PROCEDURE PBxLineWPos(testLine: THImsLine; VAR linePos: Point;
                      wsLink: THWSLink);
BEGIN
  linePos := testLine^^.pbxPos;
  IF wsLink <> NIL THEN AddPt(wsLink^^.kLPOffset, linePos);
END;


{$s imstw }
FUNCTION LnPosInLSeq(lseq: TLineSeq; posLine: THIMSLine;
                     VAR linePos: Point; wsLink: THWSLink): TF;
LABEL 900, 910;
VAR thisLine: THIMSLine;
    curVPos: TC;
    pbxLPos: Point;
    fOk: TF;
BEGIN
  fOk := TRUE;
  curVPos := linePos.v;
  thisLine := lseq.sFstLine;
  WHILE thisLine <> NIL DO
    BEGIN
      IF posLine = thisLine THEN GOTO 900;
      IF thisLine^^.lType = CBoxLine
        THEN BEGIN
          linePos.v := curVPos;
          IF LnPosInLSeq(thisLine^^.box.blineSeq, posLine, linePos, wsLink)
            THEN GOTO 910;
         END;
      IF thisLine^^.lType = CPBxLine
        THEN BEGIN
          PBxLineWPos(thisLine, pbxLPos, wsLink);
IF IMStst THEN WRITELN('Checking linePos in pbxLine:', ORD(thisLine),
                       ' at:', pbxLPos.h, pbxLPos.v);
          IF LnPosInLSeq(thisLine^^.box.blineSeq, posLine, pbxLPos, wsLink)
            THEN BEGIN curVPos := pbxLPos.v; GOTO 910; END;
         END;
      curVPos := curVPos + thisLine^^.lVDsp;
      thisLine := thisLine^^.lNext;
    END;
  IF IMStst THEN WRITELN('LnPosInLSeq - cant find line:', ORD(posLine));
  fOk := FALSE;
900:
  linePos.v := curVPos;
  IF IMStst THEN
    WRITELN('LnPosInLSeq Found line :', ORD(thisLine), ' at: ',
              linePos.h, linePos.v);
910:
  LnPosInLSeq := fOk;
END;


{$s imstw }
FUNCTION LnWindowPos;  { (wsLink: THWSLink; posLine: THIMSLine;
                          VAR linePos: Point): TF; }
VAR thisLine: THIMSLine;
    lseq: TLineSeq;
    fOk: TF;
BEGIN
  linePos := wsLink^^.kLPOffset;
  lseq := wsLink^^.kStream^^.sLineSeq;
  IF posLine^^.lType = CPbxLine
    THEN BEGIN
      PBxLineWPos(posLine, linePos, wsLink);
     END
    ELSE BEGIN
      fOk := LnPosInLSeq(lseq, posLine, linePos, wsLink);
      IF NOT fOk THEN BEGIN
        IF IMStst THEN WRITELN('Checking LnWindowPos in PosLineSeq');
        lseq := wsLink^^.kStream^^.sPosLineSeq;
        fOk := LnPosInLSeq(lseq, posLine, linePos, wsLink);
       END;
     END;
  IF IMStst THEN
    WRITELN('LnWindowPos found :', ORD(posLine), ' at:',
             linePos.h, linePos.v);
  LnWindowPos := fOk;
END;


{$s imsth }
FUNCTION  TxWid(lrgch: TRgch; chrCt: TC; fIdx: TC): TC;
VAR chrFont, twid: TC;
BEGIN
  chrFont := FontFam(fIdx);
  twid := TxtWidth(lrgch, chrCt, chrFont);
  TxWid := twid;
  IF IMStst THEN WRITELN('TxWid of ', chrCt, ' chars returns:', twid);
END;


{$s imsth }
FUNCTION HitLine(testLine: THImsLine; hitPos: Point; curVPos: TC;
                 wsLink: THWSLink; fDoHit: TF): TF;
VAR rpos: TC;
    hit: TF;
    buttonPos: Point;
BEGIN
  hit := FALSE;  { innocent until proven guilty  }
  CASE testLine^^.lType OF
    CTxtLine:
       BEGIN
         IF hitPos.h >= testLine^^.txt.tIndent-CLftSlop
           THEN BEGIN
             WITH testLine^^.txt DO rpos := TxWid(@tChars, tChrCt, tFontIdx);
             { IF hitPos.h <= rpos+CRtSlop THEN skip right margin test here }
                 hit := TRUE;
            END;
       END;
    CBoxLine: hit := TRUE;
    CFldLine:
       WITH testLine^^.fld DO BEGIN
         IF  fActSel THEN
           OffsetRect( fhField^^.coords, - fSelOffset.h, - fSelOffset.v);
         IF IMStst THEN BEGIN
           WRITE ('Checking hit in fld line:', ORD(testLine));
             PrintRect(fhField^^.coords);
          END;
         WITH fhField^^.coords DO
           IF left-CLftSlop <= hitPos.h
             { THEN IF right+CRtSlop >= hitPos.h }
               THEN hit := TRUE;
         IF fActSel THEN
           OffsetRect(fhField^^.coords, fSelOffset.h, fSelOffset.v);
       END;
    CBtnLine:  BEGIN
                 WITH wsLink^^ DO
                   BEGIN
                       SetPt(buttonPos, testLine^^.btn.pBtnHPos+kOffset.h,
                             curVPos);
                     PortPt(kWindow, buttonPos);
                     PortPt(kWindow, hitPos);
                    END;
                 hit := HitInButton(testLine^^.btn.pBtnIdx, buttonPos, hitPos,
                                    fDoHit);
               END;
    OTHERWISE IF sDebug THEN
          WRITELN('Got HitLine for strange line type. Line:', ORD(testLine));
   END;
  HitLine := hit;
  IF IMStst THEN WRITELN('HitLine returns: ', hit);
END;


{$s imsth }
FUNCTION HitPBxLine(testLine: THImsLine; hitPos: Point; VAR linePos: Point;
                    wsLink: THWSLink): TF;
VAR bxTop, bxBottom: TC;
    boxWPos: Point;
BEGIN
  IF IMStst THEN BEGIN
     WRITELN('HitPBxPos line:', ORD(testLine), ' at hitPos:',
              hitPos.h:5, hitPos.v:5);
     WRITELN('  linePos:', linePos.h:5, linePos.v:5, ' wsLink:', ORD(wsLink));
    END;
  PBxLineWPos(testLine, boxWPos, wsLink); { boxPos now in window space }
  WITH testLine^^ DO BEGIN
    bxTop := boxWPos.v;
    bxBottom := bxTop + lHt;
   END;
  IF (bxTop <= hitPos.v) AND (bxBottom > hitPos.v)
    THEN BEGIN
      linePos := boxWPos;
      HitPBxLine := TRUE;
      IF IMStst THEN WRITELN('  hit pbx line at:', linePos.h:5, linePos.v:5);
    END
   ELSE HitPBxLine := FALSE;
END;


{$s imsth }
FUNCTION HitPosInLSeq(lseq: TLineSeq; hitPos: Point; VAR linePos: Point;
                      wsLink: THWSLink; fInVOrder, fDoHit: TF): THIMSLine;
LABEL 700, 800, 900;
VAR thisLine, pLine: THIMSLine;
    curVPos, botPos: TC;
BEGIN
  curVPos := linePos.v;
  thisLine := lseq.sFstLine^^.lNext;
  WHILE thisLine <> lseq.sLstLine DO
    BEGIN
      IF thisLine^^.lType = CPBxLine
        THEN BEGIN
          IF HitPBxLine(thisLine, hitPos, linePos, wsLink)
            THEN BEGIN
              curVPos := linePos.v;
              GOTO 900;
             END;
          GOTO 700;
         END;
      IF curVPos > hitPos.v THEN GOTO 800;
      botPos := curVPos + thisLine^^.lHt;
      IF botPos > hitPos.v
        THEN BEGIN
          IF HitLine(thisLine, hitPos, curVPos, wsLink, fDoHit) THEN GOTO 900;
         END;
700:  curVPos := curVPos + thisLine^^.lVDsp;
      thisLine := thisLine^^.lNext;
    END;
800:
  HitPosInLSeq := NIL;
  EXIT(HitPosInLSeq);
900:
  linePos.v := curVPos;
  HitPosInLSeq := thisLine;
END;


{$s imstw }
FUNCTION LineAtPos;
         { (wsLink: THWSLink; hitPos: Point; VAR linePos: Point): THIMSLine; }
VAR thisLine: THIMSLine;
  PROCEDURE HitLSeq(lseq: TLineSeq; fVorder: TF);
  BEGIN
    thisLine := HitPosInLSeq(lseq, hitPos, linePos, wsLink, fVOrder, TRUE);
    IF thisLine <> NIL THEN
      IF thisLine^^.lType >= CBoxLine  { a box line type }
        THEN thisLine := HitPosInLSeq(thisLine^^.box.bLineSeq, hitPos,
                                      linePos, wsLink, TRUE, TRUE);
    IF IMStst THEN WRITELN('HitLSeq returns:', ORD(thisLine));
  END;

BEGIN
  linePos := wsLink^^.kLPOffset;  { stream start in window space }
  HitLSeq(wsLink^^.kStream^^.sPosLineSeq, FALSE);
  IF thisLine = NIL THEN HitLSeq(wsLink^^.kStream^^.sLineSeq, TRUE);
  IF IMStst THEN
    WRITELN('LineAtPos Found line :', ORD(thisLine), ' at',
             hitPos.h, hitPos.v, ' line at:', linePos.h, linePos.v);
  LineAtPos := thisLine;
END;


{$s imstc }
FUNCTION LineAtStrPos;
   { (imsObj: THIMS; hitPos: Point; VAR linePos: Point): THIMSLine; }
VAR thisLine: THIMSLine;
  PROCEDURE HitSLSeq(lseq: TLineSeq; fVOrder: TF);
  BEGIN
    thisLine := HitPosInLSeq(lseq, hitPos, linePos, NIL, fVOrder, TRUE);
    IF thisLine <> NIL THEN
      IF thisLine^^.lType >= CBoxLine  { a box line type }
        THEN thisLine := HitPosInLSeq(thisLine^^.box.bLineSeq, hitPos,
                                      linePos, NIL, TRUE, TRUE);
    IF IMStst THEN WRITELN('HitSLSeq returns:', ORD(thisLine));
  END;

BEGIN
  SetPt(linePos, 0, 0);  { stream start in stream space }
  HitSLSeq(imsObj^^.sPosLineSeq, FALSE);
  IF thisLine = NIL THEN HitSLSeq(imsObj^^.sLineSeq, TRUE);
  IF IMStst THEN
    WRITELN('LineAtStrPos Found line :', ORD(thisLine), ' at',
             hitPos.h, hitPos.v, ' line at:', linePos.h, linePos.v);
  LineAtStrPos := thisLine;
END;


{$s imsth }
FUNCTION OverIMButton; { (wsLink: THWSLink; hitPos: Point): THIMSLine; }
VAR thisLine: THIMSLine;
    linePos: Point;
  PROCEDURE OverLSeq(lseq: TLineSeq; fVorder: TF);
  BEGIN
    thisLine := HitPosInLSeq(lseq, hitPos, linePos, wsLink, fVOrder, FALSE);
    IF thisLine <> NIL THEN
      IF thisLine^^.lType >= CBoxLine  { a box line type }
        THEN thisLine := HitPosInLSeq(thisLine^^.box.bLineSeq, hitPos,
                                      linePos, wsLink, TRUE, FALSE);
    IF IMStst THEN WRITELN('OverLSeq returns:', ORD(thisLine));
  END;

BEGIN
  linePos := wsLink^^.kLPOffset;  { stream start in window space }
  OverLSeq(wsLink^^.kStream^^.sPosLineSeq, FALSE);
  IF thisLine = NIL THEN OverLSeq(wsLink^^.kStream^^.sLineSeq, TRUE);
  IF thisLine <> NIL
    THEN IF thisLine^^.lType <> CBtnLine THEN thisLine := NIL;
  IF cDebug AND IMStst THEN
    WRITELN('OverIMButton Found line :', ORD(thisLine), ' at',
             hitPos.h, hitPos.v, ' line at:', linePos.h, linePos.v);
  OverIMButton := thisLine;
END;


{$s imstw }
FUNCTION LineBelowPos(wsLink: THWSLink; hitPos: Point;
                       VAR linePos: Point): THIMSLine;
LABEL 900;
VAR thisLine, lastLine: THIMSLine;
    lseq: TLineSeq;
    curVPos, botPos: TC;
    boxWPos: Point;
BEGIN
  linePos := wsLink^^.kLPOffset;  { stream start in window space }
  curVPos := linePos.v;
  WITH wsLink^^.kStream^^.sLineSeq
    DO BEGIN
      thisLine := sFstLine;
      lastLine := sLstLine;
     END;
  WHILE thisLine <> lastLine DO
    BEGIN
      IF thisLine = NIL THEN GOTO 900;
      IF thisLine^^.lType = CPBxLine
        THEN BEGIN
          PBxLineWPos(thisLine, boxWPos, wsLink);
          botPos := boxWPos.v + thisLine^^.lHt;
         END
        ELSE botPos := curVPos + thisLine^^.lHt;
      IF botPos > hitPos.v THEN GOTO 900;
      curVPos := curVPos + thisLine^^.lVDsp;
      thisLine := thisLine^^.lNext;
    END;
900:
  linePos.v := curVPos;
  IF IMStst THEN
    WRITELN('LineBelowPos Found line :', ORD(thisLine), ' at',
             hitPos.h, hitPos.v, ' line at:', linePos.h, linePos.v);
  LineBelowPos := thisLine;
END;


{$s imstw }
FUNCTION PrevLine;  { (imsObj: THIMS; cLine: THIMSLine): THIMSLine; }
BEGIN
  PrevLine := cline^^.lPrev;
END;


{$s imstw }
FUNCTION NewTextLine
  (imsObj: THIMS; lrgch: TRgch; chrCt, fIdx, ht, vdsp, indent: TC): THIMSLine;
VAR
  newLine: THIMSLine;
  i: TC;
BEGIN
  {$R-}
  IF IMStst THEN BEGIN WRITE('NewTextLine( imsObj:', ORD(imsObj), chrCt:4, ')- ');
       for i := 0 to (chrCt - 1) do WRITE(CHR(lrgch^[i])); WRITELN; END;
  {$R+}
{$r- }
  newLine := POINTER(ORD(HAllocate(StrHeap,
                               (CBaseLineSize+SIZEOF(TTxtLine)+chrCt))));
  WITH newLine^^ DO
    BEGIN
      lType := CTxtLine;
      lIdx := NxtLnIdx;
      lNext := NIL;
      lPrev := NIL;
      IF ht >= 0
        THEN lHt := ht
        ELSE lHt :=FontHt(fIdx);
      IF vdsp >= 0
        THEN lVDsp := vdsp
        ELSE lVDsp := lHt;
      txt.tChrCt := chrCt;
      txt.tIndent := indent;
      txt.tFontIdx := fIdx;
      MoveRgch(@txt.tChars,lrgch,chrCt);
      IF IMStst THEN
        WRITELN('Text Line', ORD(newLine), ' index', lIdx, ' made.');
      NewTextLine := newLine;
    END;
END;


{$s imstw }
PROCEDURE InsertBefore;  { (newLine, atLine: THImsLine); }
BEGIN
  IF atLine^^.lType = CFstLine
    THEN BEGIN
      WRITELN('InsertBefore - newLine: ', ORD(newLine),
              ' atLine:', ORD(atLine));
      InterpError('Cant insert line before a first line');
      EXIT(InsertBefore);
    END;
  newLine^^.lNext := atLine;
  newLine^^.lPrev := atLine^^.lPrev;
  atLine^^.lPrev := newLine;
  newLine^^.lPrev^^.lNext := newLine;
END;


{$s imstw }
PROCEDURE InsertAfter;  { (newLine, atLine: THImsLine); }
BEGIN
  IF atLine^^.lType = CLstLine
    THEN BEGIN
      WRITELN('InsertAfter - newLine: ', ORD(newLine),
              ' atLine:', ORD(atLine));
      InterpError('Cant insert line after a last line');
      EXIT(InsertAfter);
    END;
  newLine^^.lNext := atLine^^.lNext;
  newLine^^.lPrev := atLine;
  atLine^^.lNext := newLine;
  newLine^^.lNext^^.lPrev := newLine;
END;


{$s imstw }
PROCEDURE ReplaceLine(newLine, atLine: THImsLine);
BEGIN
  IF (atLine^^.lType = CLstLine) OR
     (atLine^^.lType = CFstLine)
    THEN BEGIN
      WRITELN('ReplaceLine - newLine: ', ORD(newLine),
              ' atLine:', ORD(atLine));
      InterpError('Cant replace a first or a last line');
      EXIT(ReplaceLine);
    END;
  newLine^^.lNext := atLine^^.lNext;
  newLine^^.lPrev := atLine^^.lPrev;
  newLine^^.lNext^^.lPrev := newLine;
  newLine^^.lPrev^^.lNext := newLine;
END;


{$s imstw }
PROCEDURE GetLineRect(wsLink: THWSLink; rLine: THImsLine; VAR lRect: Rect);
VAR lnPos: Point;
BEGIN
  IF LnWindowPos(wsLink, rLine, lnPos)
    THEN BEGIN
      WITH wsLink^^.kWindow^^.wDispRect DO
        SetRect(lRect, 0, 0, right-left, rLine^^.lHt);
      OffsetRect(lRect, lnPos.h, lnPos.v);
     END
    ELSE lRect := nullRect;
 IF IMStst THEN WITH lRect DO
  WRITELN(' line set to:', left:5, top:5, right:5, bottom:5,
  ' for line:', ORD(rline));
END;


{$s imstw }
PROCEDURE AddRToPrtRect(wsLink: THWSLink; prtRect: Rect);
BEGIN
  IF IsNull(wsLink^^.kPrtRect)
    THEN IF IMStst THEN WRITELN('Null kPrtRect - being reset');
  WITH wsLink^^ DO
    IF IsNull(kPrtRect)
     THEN kPrtRect := prtRect
     ELSE BEGIN
       IF prtRect.left < kPrtRect.left THEN kPrtRect.left := prtRect.left;
       IF prtRect.top < kPrtRect.top THEN kPrtRect.top := prtRect.top;
       IF prtRect.right > kPrtRect.right THEN kPrtRect.right := prtRect.right;
       IF prtRect.bottom > kPrtRect.bottom THEN kPrtRect.bottom := prtRect.bottom;
      END;
  IF IMStst THEN WITH wsLink^^.kPrtRect DO
    WRITELN('kPrtRect set to:', left:5, top:5, right:5, bottom:5,
             ' for link:', ORD(wsLink));
END;


{$s imstw }
PROCEDURE AddLnToPrtRect;  { (imsObj: THIMS; prtLn: THImsLine); }
VAR lnRect: Rect;
     wsl: THWSLink;
BEGIN
  wsl := imsObj^^.sLink;
  WHILE wsl <> NIL DO
    BEGIN
      GetLineRect(wsl, prtLn, lnRect);
      IF NOT IsNull(lnRect)
        THEN AddRToPrtRect(wsl, lnRect);
      wsl := wsl^^.kNext;
    END;
END;


{$s imstw }
PROCEDURE AppendLine(imsObj: THIMS; aLine: THIMSLine);
VAR pLine: THIMSLine;
BEGIN
  pLine := imsObj^^.sLineSeq.sLstLine^^.lPrev;
  { WITH imsObj^^ DO pLine := PrevSeqLine(sLineSeq, sLineSeq.sLstLine, FALSE); }
  IF pLine = NIL
    THEN BEGIN
      InterpError('AppendLine - Cant find last line of stream.');
      EXIT(AppendLine);
     END;
  IF aLine^^.lType = CPBxLine
    THEN InsertBefore(aLine, imsObj^^.sPosLineSeq.sLstLine)
    ELSE InsertBefore(aLine, imsObj^^.sLineSeq.sLstLine);
  imsObj^^.sLineCount := imsObj^^.sLineCount + 1;
  AddLnToPrtRect(imsObj, aLine);
  IF imsObj^^.sKeepCt > 0 THEN
    WHILE imsObj^^.sLineCount > imsObj^^.sKeepCt DO  ChopLine(imsObj);
END;


{$s imstw }
FUNCTION  LSeqHt(VAR lseq: TLineSeq):  TC;
VAR lsPos, lsHt, lBottom: TC;
    sLine: THImsLine;
BEGIN
  lsPos := 0;
  lsHt := 0;
  sLine := lseq.sFstLine^^.lNext;
  WHILE sLine <> lseq.sLstLine DO
    WITH sLine^^ DO BEGIN
      lBottom := lsPos + lHt;
      IF lBottom > lsHt THEN lsHt := lBottom;
      lsPos := lsPos + lVDsp;
      sLine := lNext;
    END;
  LSeqHt := lsHt;
END;


{$s imstw }
FUNCTION  PBxLSeqHt(VAR lseq: TLineSeq):  TC;
VAR lsHt, lBottom: TC;
    sLine: THImsLine;
BEGIN
  lsHt := 0;
  sLine := lseq.sFstLine^^.lNext;
  WHILE sLine <> lseq.sLstLine DO
    WITH sLine^^ DO BEGIN
      IF lType = CPBxLine
        THEN BEGIN
          lBottom := pbxPos.v + lHt;
          IF lBottom > lsHt THEN lsHt := lBottom;
         END
        ELSE IF sDebug THEN WRITELN('Non pbxLine in PBxLSeqHt:', ORD(sLine));
      sLine := lNext;
    END;
  PBxLSeqHt := lsHt;
END;


{$s imstw }
FUNCTION  StreamHt;  { (imsObj: THIMS): TC; }
VAR posHt, strHt: TC;
BEGIN
  strHt := LSeqHt(imsObj^^.sLineSeq);
  posHt := PBxLSeqHt(imsObj^^.sPosLineSeq);
  IF strHt > posHt THEN StreamHt := strHt ELSE StreamHt := posHt;
END;


{$s imstw }
FUNCTION  StreamWid;  { (imsObj: THIMS): TC; }
BEGIN
  StreamWid := imsObj^^.sLineData.dLWidth+300;
IF IMStst THEN WRITELN('StreamWid gets:', imsObj^^.sLineData.dLWidth:6+200);
END;


{$s imstw }
FUNCTION  BoxHt(boxLine: THImsLine): TC;
BEGIN
  BoxHt := LSeqHt(boxLine^^.box.bLineSeq);
END;


{$s imstw }
PROCEDURE AddBoxLine(imsObj: THIMS; boxLine, newLine: THIMSLine);
LABEL 500, 900;
VAR rLine: THImsLine;
BEGIN
  IF cDebug
    THEN IF newLine^^.lType >= CBoxLine
     THEN BEGIN
      WRITELN('AddBoxLine - boxLine:', ORD(boxLine), ' newLine:', ORD(newLine));
      InterpError('AddBoxLine - newLine cant be a box line');
      AppendLine(imsObj, newLine);
      EXIT(AddBoxLine);
     END;
  IF boxLine^^.box.bExchange
    THEN BEGIN
      rLine := boxLine^^.box.bXline^^.lNext;
      IF rLine^^.lType = CLstLine THEN GOTO 500;
      WITH boxLine^^ DO lHt := lHt + (newLine^^.lVDsp - rLine^^.lVDsp);
      ReplaceLine(newLine, rLine);
      boxLine^^.box.bXLine := newLine;
      IF IMStst THEN
        WRITELN('AddBoxLine:', ORD(newLine), ' replaces line:', ORD(rLine),
                ' in boxLine:', ORD(boxLine));
      FreeIMSLine(imsObj, rLine);
      GOTO 900;
     END;
500:
  InsertBefore(newLine, boxLine^^.box.bLineSeq.sLstLine);
  WITH boxLine^^.box DO bLineCount := bLineCount + 1;
  WITH boxLine^^ DO lHt := BoxHt(boxLine);
  IF IMStst THEN
    WRITELN('AddBoxLine:', ORD(newLine), ' inserted after line:', ORD(rLine),
            ' in boxLine:', ORD(boxLine));
900:
  WITH boxLine^^ DO IF NOT box.bFixedHt THEN lVDsp := lHt;
  AddLnToPrtRect(imsObj, boxLine);  { could use newLine too here }
END;


{$s imstw }
PROCEDURE FixThumb(sbar: THSb; offset, range: TC);
VAR lPos, lThumb: TL;
    cThumb: TC;
BEGIN
  IF range <> 1000
    THEN BEGIN
      lPos := ORD4(offset) * ORD4(1000);
      lThumb := lPos DIV ORD4(range);
      cThumb := lThumb;
      IF IMStst THEN
        WRITELN('FixThumb range adjust  lPos:', lPos:7,'  lThumb:', lThumb:7);
     END
    ELSE cThumb := offset;
  IF IMStst THEN
    WRITELN('FixThumb offset:',offset:5,' range:', range:5,' cThumb:', cThumb:5);
  SetupMvThumb(sbar);
  MoveThumb(cThumb);
END;


{$s imstw }
PROCEDURE ScrollLeft(wsLink: THWSLink; sDelta: TC; fPage: TF);
VAR strwid, wWid: TC;
    newOffset, scrollRange: TC;
BEGIN
  IF wsLink = NIL THEN EXIT(ScrollLeft);
  strWid := StreamWid(wsLink^^.kStream);
  WITH wsLink^^.kWindow^^.wDispRect DO wWid := right - left;
  IF fPage THEN sDelta := wWid;
  scrollRange := strWid - wWid;
  newOffset := wsLink^^.kOffset.h - sDelta;
  IF (scrollRange <= 0) OR (newOffset < -scrollRange)
    THEN BEGIN
      IF IMStst THEN WRITELN('ScrollLeft: scrolled to bottom');
      newOffset := -scrollRange;
     END;
IF IMStst THEN WRITELN('ScrollLeft: sDelta:', sDelta:5, ' fPage:', fPage);
IF IMStst THEN WRITELN(' sr:', scrollRange:5, ' newOffset:', newOffset:6,
' strWid:', strWid:5, ' wWid:', wWid:5);
  WITH wsLink^^ DO BEGIN
    kOffset.h := newOffset;
    WITH kWindow^^ DO BEGIN
      ClipRect(wPort^.PortRect);
      FixThumb(wHSbar, -newOffset, scrollRange);
    END;
  END;
END;

{$s imstw }
PROCEDURE ScrollRight(wsLink: THWSLink; sDelta: TC; fPage: TF);
VAR strWid, wWid: TC;
    newOffset, scrollRange: TC;
BEGIN
  IF wsLink = NIL THEN EXIT(ScrollRight);
  strWid := StreamWid(wsLink^^.kStream);
  WITH wsLink^^.kWindow^^.wDispRect DO wWid := right - left;
  IF fPage THEN sDelta := wWid;
  scrollRange := strWid - wWid;
  newOffset := wsLink^^.kOffset.h + sDelta;
  IF (scrollRange <= 0) OR (newOffset >= 0)
    THEN BEGIN
      newOffset := 0;
IF IMStst THEN WRITELN('ScrollRight: scrolled to end');
     END;
IF IMStst THEN WRITELN('ScrollRight: sDelta:', sDelta:5, ' fPage:', fPage);
IF IMStst THEN WRITELN(' sr:', scrollRange:5, ' newOffset:', newOffset:6,
' strWid:', strWid:5, ' wWid:', wWid:5);
  WITH wsLink^^ DO BEGIN
    kOffset.h := newOffset;
    WITH kWindow^^ DO BEGIN
      ClipRect(wPort^.PortRect);
      FixThumb(wHSbar, -newOffset, scrollRange);
    END;
  END;
END;


{$s imstw }
PROCEDURE ScrollUp(wsLink: THWSLink; sDelta: TC; fPage: TF);
VAR strHt, wHt: TC;
    newOffset, scrollRange: TC;
BEGIN
  IF wsLink = NIL THEN EXIT(ScrollUp);
  WITH wsLink^^ DO BEGIN
    strHt := StreamHt(kStream);
    WITH kWindow^^.wDispRect DO wHt := bottom - top;
    IF fPage THEN sDelta := wHt;
    scrollRange := strHt - wHt;
    { fix for bug # im57}
    IF scrollRange <= 0 THEN EXIT(ScrollUp);
    newOffset := wsLink^^.kOffset.v - sDelta;
    IF (scrollRange <= 0) OR (newOffset < -scrollRange)
      THEN BEGIN
        IF IMStst THEN WRITELN('ScrollUp: scrolled to bottom');
        newOffset := -scrollRange;
      END;
IF IMStst THEN WRITELN('ScrollUp: sDelta:', sDelta:5, ' fPage:', fPage);
IF IMStst THEN WRITELN(' sr:', scrollRange:5, ' newOffset:', newOffset:6,
' sht:', strHt:5, ' wHt:', wHt:5);
    kOffset.v := newOffset;
    WITH kWindow^^ DO BEGIN
      ClipRect(wPort^.PortRect);
      FixThumb(wVSbar, -newOffset, scrollRange);
     END;
  END;
END;

{$s imstw }
PROCEDURE ScrollDown(wsLink: THWSLink; sDelta: TC; fPage: TF);
VAR strHt, wHt: TC;
    newOffset, scrollRange: TC;
BEGIN
  IF wsLink = NIL THEN EXIT(ScrollDown);
  WITH wsLink^^ DO BEGIN
    strHt := StreamHt(kStream);
    WITH kWindow^^.wDispRect DO wHt := bottom - top;
    IF fPage THEN sDelta := wHt;
    scrollRange := strHt - wHt;
    { fix for bug # im57}
    IF scrollRange <= 0 THEN EXIT(ScrollDown);
    newOffset := wsLink^^.kOffset.v + sDelta;
    IF (scrollRange <= 0) OR (newOffset >= 0)
      THEN BEGIN
        newOffset := 0;
        IF IMStst THEN WRITELN('ScrollDown: scrolled to top');
       END;
IF IMStst THEN WRITELN('ScrollDown: sDelta:', sDelta:5, ' fPage:', fPage);
IF IMStst THEN WRITELN(' sr:', scrollRange:5, ' newOffset:', newOffset:6,
' sht:', strHt:5, ' wHt:', wHt:5);
    kOffset.v := newOffset;
    WITH kWindow^^ DO BEGIN
      ClipRect(wPort^.PortRect);
      FixThumb(wVSbar, -newOffset, scrollRange);
     END;
  END;
END;

{$s imstw }
PROCEDURE SetVThumbPos; { (wsLink: THWSLink; cThumb: TC); }
VAR strHt, wHt: TC;
    scrollRange, scrollPos: TL;
BEGIN
  IF cThumb < 0 THEN cThumb := 0
    ELSE IF cThumb > 1000 THEN cThumb := 1000;
  IF wsLink = NIL THEN EXIT(SetVThumbPos);
  IF wsLink^^.kWindow^^.wPort = NIL THEN EXIT(SetVThumbPos);
  SetPort(wsLink^^.kWindow^^.wPort);
  strHt := StreamHt(wsLink^^.kStream);
  WITH wsLink^^.kWindow^^.wDispRect DO wHt := bottom - top;
  IF wsLink = ActiveWSLink  { added to fix bug # IM62 }
    THEN ClipRect(wsLink^^.kWindow^^.wPort^.PortRect)
    ELSE ClipRect(NullRect);
  scrollRange := strHt - wHt;
  IF scrollRange <= 0
    THEN BEGIN
      wsLink^^.kOffset.v := 0;
      FixThumb(wsLink^^.kWindow^^.wVSbar, 0, 1000);
     END
    ELSE WITH wsLink^^ DO BEGIN
      ScrollPos := ScrollRange * cThumb;
IF IMStst THEN WRITE('SetVThumbPos: cT:', cThumb:5, ' sr:', ScrollRange:5,
           ' sp*1000:', ScrollPos:6);
      ScrollPos := ScrollPos DIV 1000;
      IF IMtst THEN WRITE(' ScrlPos:', ScrollPos:6);
      kOffset.v := -ScrollPos;
      FixThumb(wsLink^^.kWindow^^.wVSbar, cThumb, 1000);
    END;
  IF IMStst THEN
     WRITELN('SetVThumbPos: ', cThumb:5, ' sets offset: ',
             wsLink^^.kOffset.v:3, ' strHt:', strHt:3,
             ' windowHt:', wht:3, ' link:', ORD(wsLink));
END;

{$s imstw }
PROCEDURE SetHThumbPos; { (wsLink: THWSLink; cThumb: TC); }
VAR strWid, wWid: TC;
    scrollRange, scrollPos: TL;
BEGIN
  IF cThumb < 0 THEN cThumb := 0
    ELSE IF cThumb > 1000 THEN cThumb := 1000;
  IF wsLink = NIL THEN EXIT(SetHThumbPos);
  IF wsLink^^.kWindow^^.wPort = NIL THEN EXIT(SetHThumbPos);
  SetPort(wsLink^^.kWindow^^.wPort);
  strWid := StreamWid(wsLink^^.kStream);
  WITH wsLink^^.kWindow^^.wDispRect DO wWid := right - left;
  IF wsLink = ActiveWSLink  { added to fix bug # IM62 }
    THEN ClipRect(wsLink^^.kWindow^^.wPort^.PortRect)
    ELSE ClipRect(NullRect);
  scrollRange := strWid - wWid;
  IF scrollRange <= 0
    THEN BEGIN
      wsLink^^.kOffset.h := 0;
      FixThumb(wsLink^^.kWindow^^.wHSbar, 0, 1000);
     END
    ELSE WITH wsLink^^ DO BEGIN
      ScrollPos := ScrollRange * cThumb;
      IF IMStst THEN WRITE('SetHThumbPos: cT:', cThumb:5, ' sr:', ScrollRange:5,
           ' sp*1000:', ScrollPos:6);
      ScrollPos := ScrollPos DIV 1000;
      IF IMtst THEN WRITE(' ScrlPos:', ScrollPos:6);
      kOffset.h := -ScrollPos;
      FixThumb(wsLink^^.kWindow^^.wHSbar, cThumb, 1000);
    END;
  IF IMStst THEN
     WRITELN('SetHThumbPos: ', cThumb:5, ' sets offset: ',
             wsLink^^.kOffset.h:3, ' strWid:', strWid:3,
             ' windowWid:', wWid:3, ' link:', ORD(wsLink));
END;




{$s imstw }
PROCEDURE ScrollObjEvt(objOp: TC);
VAR objIdx: TC;
BEGIN
  IF fRObjects THEN
    IF GetActObjIdx(objIdx)
      THEN BEGIN
        Add4ObjEvt(curEvtBuf, objOp, objIdx);
       END;
END;


{$s imstw }
PROCEDURE SetIMWClip; { (imWindow: THIMW); }
VAR xRect: Rect;
BEGIN
  WITH imWindow^^ DO BEGIN
    SetPort(wPort);
    WITH wPort^.PortRect DO
      SetRect(xRect, left, top, right-dhSbox+1, bottom-dvSbox+1);
      { also set in immenus procedure fixwindow rects - use wRect here?? }
    ClipRect(xRect);
   END;
END;


{$s imstw }
PROCEDURE ScrollWindow;
    { (wsLink: THWSLink; sbHit: THSb; iconHit: TIcon; hitPt: TPt); }
VAR imWindow: THIMW;
    newThumbPos: TC;
BEGIN
  imWindow := wsLink^^.kWindow;
  IF imWindow = NIL THEN
    BEGIN
      IF sDebug THEN
        WRITELN('ScrollWindow - null window in wsLink:', ORD(wsLink));
      EXIT(ScrollWindow);
     END;
  WITH imWindow^^ DO BEGIN
    SetPort(wPort);
    BeginUpdate(wPort);
    IF NOT EmptyRgn(wPort^.visRgn)
      THEN ReDrawDWRect(wsLink, wPort^.visRgn^^.rgnBBox);
    EndUpdate(wPort);
    SetPort(wPort);
    ClipRect(wPort^.PortRect);
   END;
  IF sbHit = imWindow^^.wVSbar
   THEN BEGIN  { hit vert scroll bar }
       CASE iconHit OF
         iconArwA:
           BEGIN  { hit up arrow icon }
             IF IMStst THEN WRITELN('Hit up arrow icon. ');
             PaintArw(sbHit, iconHit, TRUE);
             ScrollDown(wsLink, vScrollDist, FALSE);
             FixScroll(imWindow);
             WHILE StillDown DO BEGIN
               ScrollDown(wsLink, vScrollDist, FALSE);
               FixScroll(imWindow);
              END;
             ClipRect(imWindow^^.wPort^.PortRect);
             PaintArw(sbHit, iconHit, FALSE);
             ScrollObjEvt(CObjArrow);
            END;
         iconPagA:
           BEGIN  { hit page up icon }
             IF IMStst THEN WRITELN('Hit page up icon. ');
             ScrollDown(wsLink, 0, TRUE);
             FixScroll(imWindow);
             WHILE StillDown DO BEGIN
               ScrollDown(wsLink, 0, TRUE);
               FixScroll(imWindow);
              END;
             ScrollObjEvt(CObjPage);
            END;
         iconThumb:
           BEGIN  { move thumb icon }
             IF IMStst THEN WRITELN('Hit vert thumb bar. ');
             DragThumb(sbHit, hitPt, newThumbPos);
             IF IMStst THEN WRITELN('Drag to thumb pos: ', newThumbPos);
             SetVThumbPos(wsLink, newThumbPos);
             FixScroll(imWindow);
             ScrollObjEvt(CObjThumb);
            END;
         iconPagB:
           BEGIN  { hit page icon }
             IF IMStst THEN WRITELN('Hit page down icon. ');
             ScrollUp(wsLink, 0, TRUE);
             FixScroll(imWindow);
             WHILE StillDown DO BEGIN
               ScrollUp(wsLink, 0, TRUE);
               FixScroll(imWindow);
              END;
             ScrollObjEvt(CObjPage);
            END;
         iconArwB:
           BEGIN  { hit down arrow icon }
             IF IMStst THEN WRITELN('Hit down arrow icon. ');
             PaintArw(sbHit, iconHit, TRUE);
             ScrollUp(wsLink, vScrollDist, FALSE);
             FixScroll(imWindow);
             WHILE StillDown DO BEGIN
               ScrollUp(wsLink, vScrollDist, FALSE);
               FixScroll(imWindow);
              END;
             ClipRect(imWindow^^.wPort^.PortRect);
             PaintArw(sbHit, iconHit, FALSE);
             ScrollObjEvt(CObjArrow);
            END;
        END;
      PaintSb(sbHit);
     END
   ELSE IF sbHit = imWindow^^.wHSbar
    THEN BEGIN
       CASE iconHit OF
         iconArwA:
           BEGIN  { hit left arrow icon }
             IF IMStst THEN WRITELN('Hit left arrow icon. ');
             PaintArw(sbHit, iconHit, TRUE);
             ScrollRight(wsLink, hScrollDist, FALSE);
             FixScroll(imWindow);
             WHILE StillDown DO BEGIN
               ScrollRight(wsLink, hScrollDist, FALSE);
               FixScroll(imWindow);
              END;
             ClipRect(imWindow^^.wPort^.PortRect);
             PaintArw(sbHit, iconHit, FALSE);
             ScrollObjEvt(CObjArrow);
            END;
         iconPagA:
           BEGIN  { hit page left icon }
             IF IMStst THEN WRITELN('Hit page left icon. ');
             ScrollRight(wsLink, 0, TRUE);
             FixScroll(imWindow);
             WHILE StillDown DO BEGIN
               ScrollRight(wsLink, 0, TRUE);
               FixScroll(imWindow);
              END;
             ScrollObjEvt(CObjPage);
            END;
         iconThumb:
           BEGIN  { move thumb icon }
             IF IMStst THEN WRITELN('Hit horiz thumb bar. ');
             DragThumb(sbHit, hitPt, newThumbPos);
             IF IMStst THEN WRITELN('Drag to thumb pos: ', newThumbPos);
             SetHThumbPos(wsLink, newThumbPos);
             FixScroll(imWindow);
             ScrollObjEvt(CObjThumb);
            END;
         iconPagB:
           BEGIN  { hit page right icon }
             IF IMStst THEN WRITELN('Hit page right icon. ');
             ScrollLeft(wsLink, 0, TRUE);
             FixScroll(imWindow);
             WHILE StillDown DO BEGIN
               ScrollLeft(wsLink, 0, TRUE);
               FixScroll(imWindow);
              END;
             ScrollObjEvt(CObjPage);
            END;
         iconArwB:
           BEGIN  { hit right arrow icon }
             IF IMStst THEN WRITELN('Hit right arrow icon. ');
             PaintArw(sbHit, iconHit, TRUE);
             ScrollLeft(wsLink, hScrollDist, FALSE);
             FixScroll(imWindow);
             WHILE StillDown DO BEGIN
               ScrollLeft(wsLink, hScrollDist, FALSE);
               FixScroll(imWindow);
              END;
             ClipRect(imWindow^^.wPort^.PortRect);
             PaintArw(sbHit, iconHit, FALSE);
             ScrollObjEvt(CObjArrow);
            END;
        END;
     FixScroll(imWindow);
     ClipRect(thePort^.PortRect);
     PaintSb(sbHit);
    END
   ELSE  { hit strange scroll bar }
     IF sDebug THEN
       WRITELN('ScrollWindow - scrollbar not in given window. wsLink:',
               ORD(wsLink), ' sbar: ', ORD(sbHit));
  SetIMWClip(imWindow);
END;


{$s imstw }
PROCEDURE ShowStreamEnd;  { (imsObj: THIMS); }
VAR wsLink: THWSLink;
    strHt: TC;
    wActive: TF;
  PROCEDURE ShowEnd;
  VAR wHt: TC;
  BEGIN
    WITH wsLink^^ DO BEGIN
      WITH kWindow^^ DO
        BEGIN
          wHt := wDispRect.bottom - wDispRect.top;
          SetPort(wPort);
          IF wActive THEN BEGIN
            ClipRect(wPort^.PortRect);
            SetupMvThumb(wHSbar);
            MoveThumb(0);
            SetupMvThumb(wVSbar);
           END;
        END;
      IF strHt > wHt
        THEN BEGIN
          kOffset.v := wHt - strHt;
          IF wActive THEN MoveThumb(1000);
         END
        ELSE BEGIN
          kOffset.v := 0;
          IF wActive THEN MoveThumb(0);
         END;
      IF IMStst THEN WITH wsLink^^ DO
         WRITELN('ShowEnd for link: ', ORD(wsLink), ' strHt:', strHt:3,
                 ' windowHt:', wht:3, ' kOffset:', kOffset.h:3, kOffset.v:3);
     END;
  END;

BEGIN
  wsLink := imsObj^^.sLink;
  IF wsLink <> NIL THEN strHt := StreamHt(imsObj);
  WHILE wsLink <> NIL DO
    BEGIN
      wActive := (wsLink = ActiveWSLink);
      ShowEnd;
      wsLink := wsLink^^.kNext;
    END;
END;


{$s imstw }
PROCEDURE AttachLine(imsObj: THIMS; newLine: THIMSLine; fShowEnd: TF);
BEGIN
  IF imsObj^^.sTextBox <> NIL
    THEN BEGIN
      AddBoxLine(imsObj, imsObj^^.sTextBox, newLine);
      IF imsObj^^.sTextBox^^.lType <> CPBxLine
        THEN IF fShowEnd THEN ShowStreamEnd(imsObj);
     END
    ELSE BEGIN
      AppendLine(imsObj, newLine);
      IF fShowEnd THEN ShowStreamEnd(imsObj);
     END;
END;


{$s imstw }
FUNCTION  AddNewTextLine; {(imsObj: THIMS; lrgch: TRgch; chrCt: TC;
                            fShowEnd: TF): THIMSLine;}
VAR newLine: THIMSLine;
BEGIN
  IF IMStst THEN WRITELN('AddNewTextLine for stream: ', ORD(imsObj));
  IF imsObj = NIL THEN
    BEGIN AddNewTextLine := NIL; EXIT(AddNewTextLine); END;
  WITH imsObj^^.sLineData DO
    newLine := NewTextLine(imsObj, lrgch, chrCt, dLFIdx, dLHt, dLVDsp, dLIndent);
  AttachLine(imsObj, newLine, fShowEnd);
  AddNewTextLine := newLine;
END;


{$s imstw }
PROCEDURE DrawFldLine(wsLink: THWSLink; dLine: THIMSLine; linePt: Point);
BEGIN
  IF IMStst THEN
    WRITELN('Drawing fld line: ', ORD(dLine), ' at:', linePt.h, linePt.v);
  PortPt(wsLink^^.kWindow, linePt);
  IF NOT dLine^^.fld.fActSel
    THEN OffsetRect(dLine^^.fld.fhField^^.coords, linePt.h, linePt.v-1);
  WITH dLine^^.fld DO
    IF fActSel
      THEN DrawField(fhField, fhFState, TRUE, TRUE)
      ELSE DrawField(fhField, NIL, FALSE, TRUE);
  IF NOT dLine^^.fld.fActSel
    THEN OffsetRect(dLine^^.fld.fhField^^.coords, -linePt.h, -linePt.v+1);
END;


{$s imstw }
PROCEDURE DrawBoxLine(wsLink: THWSLink; dLine: THIMSLine; linePt: Point;
                       vlim: TC);
BEGIN
  IF IMStst THEN
    WRITELN('Drawing box line: ', ORD(dLine), ' at:', linePt.h, linePt.v);
  DrawFromLine(wsLink, dLine^^.box.bLineSeq.sFstLine^^.lNext, linePt, vLim);
END;


{$s imstw }
PROCEDURE DrawPBxLine(wsLink: THWSLink; dLine: THIMSLine; vlim: TC);
VAR pbxWPos: Point;
BEGIN
  pbxWPos := dLine^^.pbxPos;
  AddPt(wsLink^^.kLPOffset, pbxWPos);  { box pos in window space }
  IF IMStst THEN
    WRITELN('Drawing PBx line: ', ORD(dLine), ' at:', pbxWPos.h, pbxWPos.v);
  WITH dLine^^ DO
    DrawFromLine(wsLink, box.bLineSeq.sFstLine^^.lNext, pbxWPos, vLim);
END;


{$s imstw }
PROCEDURE DrawTxtLine(wsLink: THWSLink; dLine: THIMSLine; linePt: Point);
BEGIN
  IF IMStst THEN
    WRITELN('Drawing text line: ', ORD(dLine), ' at:', linePt.h, linePt.v);
IF thePort = menuFolder THEN BEGIN
  WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
  TextFont(FontFam(dLine^^.txt.tFontIdx));
  WITH dline^^.txt DO
    BEGIN
      MoveTo(PortHPos(wsLink^^.kWindow, linePt.h + tIndent),
             PortVPos(wsLink^^.kWindow, linePt.v + FontBase(tFontIdx)));
      DrawText(@tChars, 0, tChrCt);
    END;
END;


{$s imstw }
PROCEDURE DrawBtnLine(wsLink: THWSLink; dLine: THIMSLine; linePt: Point);
BEGIN
  IF IMStst THEN
    WRITELN('Drawing button line: ', ORD(dLine), ' at:', linePt.h, linePt.v);
  linePt.h := linePt.h + dLine^^.btn.pBtnHPos;
  PortPt(wsLink^^.kWindow, linePt);
  DrawButton(dLine^^.btn.pBtnIdx, linePt);
END;


{$s imstw }
PROCEDURE DrawIMSLine(wsLink: THWSLink; dLine: THIMSLine; VAR linePt: Point;
                          vlim: TC);
BEGIN
  IF IMStst THEN
    WRITELN('DrawIMSLine: ', ORD(dLine), ' at wind pt:',
             linePt.h:5, linePt.v:5, ' vlim:', vlim:5);
  CASE dLine^^.lType OF
    CTxtLine: DrawTxtLine(wsLink, dLine, linePt);
    CFldLine: DrawFldLine(wsLink, dLine, linePt);
    CBtnLine: DrawBtnLine(wsLink, dLine, linePt);
    CBoxLine: DrawBoxLine(wsLink, dLine, linePt, vlim);
    CPBxLine: DrawPBxLine(wsLink, dLine, vlim);
   END;
IF IMStst THEN WRITELN('Line drawn at line pt =', linePt.h, linePt.v);
IF IMStst THEN WRITELN('Adding ', dLine^^.lVDsp:5, ' to line point.');
  linePt.v := linePt.v + dLine^^.lVDsp;
END;


{$s imstw }
PROCEDURE DrawPosBoxes(wsLink: THWSLink; dRect: Rect);
VAR bxWPos: Point;
    bxLine, lstLine: THIMSLine;
BEGIN
  WITH wsLink^^.kStream^^.sPosLineSeq DO
    BEGIN
      bxLine := sFstLine^^.lNext;
      lstLine := sLstLine;
     END;
  WHILE bxLine <> lstLine DO
    BEGIN
      IF bxLine^^.lType <> CPBxLine
        THEN BEGIN
          WRITELN('DrawPosBoxes wsLink:', ORD(wsLink), ' line:', ORD(bxLine));
          InterpError('Line in sPosLineSeq is not a PBxLine!!');
         END
        ELSE BEGIN
           IF IMStst THEN WRITELN('Trying to draw pos box:', ORD(bxLine));
           bxWPos := bxLine^^.pbxPos;
           AddPt(wsLink^^.kLPOffset, bxWPos);  { box pos in window space }
           IF bxWPos.v <= dRect.bottom
             THEN IF bxWPos.v + bxLine^^.lHt > dRect.top
               THEN DrawBoxLine(wsLink, bxLine, bxWPos, dRect.bottom);
         END;
      bxLine := bxLine^^.lNext;
    END;
END;


{$s imstw }
PROCEDURE IMSDrawLine; {(wsLink: THWSLink; dLine: THIMSLine; portPt: Point;
                          vlim: TC); }
VAR imsObj: THIMS;
    imwObj: THIMW;
BEGIN
  IF IMStst THEN
    WRITELN('IMSDrawLine: ', ORD(dLine), ' at port pt:', portPt.h, portPt.v);
  IF wsLink = NIL THEN EXIT(IMSDrawLine);
  imwObj := wsLink^^.kWindow;
  IF imwObj = NIL
    THEN BEGIN
      IF IMStst THEN
        WRITELN('IMSDrawLine No window attached to wsLink:', ORD(imwObj));
      EXIT(IMSDrawLine);
     END;
  imsObj := wsLink^^.kStream;
  SetIMWClip(imwObj);  { sets port }
  WindPt(imwObj, portPt);  { convert portPt to windowRect }
  DrawIMSLine(wsLink, dLine, portPt, PortVPos(imwObj, vlim));
END;


{$s imstw }
PROCEDURE DrawFromLine; { (wsLink: THWSLink; dLine: THIMSLine;
                           VAR linePt: Point; vlim: TC); }
BEGIN
  IF IMStst THEN
    WRITELN('Drawing lines from: ', ORD(dLine), ' at:', linePt.h, linePt.v);
  IF dLine = NIL THEN EXIT(DrawFromLine);
  WHILE (dLine^^.lType <> CLstLine) AND (linePt.v < vlim)
    DO BEGIN
      DrawIMSLine(wsLink, dLine, linePt, vlim);
      dLine := dLine^^.lNext;
     END;
END;


{$s imstw }
PROCEDURE ScrollSel(wsLink: THWSLink; scrollH, scrollV: TC);
VAR imStr: THIMS;
BEGIN
  { wsLink guaranteed non nil by FixScroll and FixOffsets }
  imStr := wsLink^^.kStream;
  IF imStr <> NIL
    THEN IF ActSel(imStr)
      THEN WITH imstr^^.sField^^.fld DO BEGIN
        OffsetRect(fhField^^.coords, scrollH, scrollV);
        OffsetRect(fhFState^^.selectRect, scrollH, scrollV);
        SetPt(fSelOffset, fSelOffset.h+scrollH, fSelOffset.v+scrollV);
      END;
END;


{$s imstw }
PROCEDURE FixScroll;  { (imwObj: THIMW); FORWARD }
  { assumes port and clip rect already set }
VAR scrollH, scrollV: TC;
    wsLink: THWSLink;
    upRgn: RgnHandle;
    pRect, dRect: Rect;
    dline: THIMSLine;
    linePt: Point;
    tout: TC;  {?? for field fix }
BEGIN
  wsLink := imwObj^^.wLink;
  IF wsLink = NIL
    THEN BEGIN
      EXIT(FixScroll);
    END;
  SetIMWClip(imwObj);  { sets port }
  WITH wsLink^^ DO BEGIN
    IF (kOffset.h = kLPOffset.h) AND (kOffset.v = kLPOffset.v)
      THEN BEGIN
        IF IMStst THEN WRITELN('FixScroll: no scroll');
        EXIT(FixScroll);
       END;
    scrollV := kOffset.v - kLPOffset.v;
    scrollH := kOffset.h - kLPOffset.h;
    OffsetRect(kPrtRect, scrollH, scrollV);  { ??? needed? }
    kLPOffset := kOffset;
    ScrollSel(wsLink, scrollH, scrollV);
   END;
  IF IMStst THEN WRITELN('FixScroll scroll dist:', scrollH, scrollV);
  upRgn := NewRgn;
  prect := thePort^.clipRgn^^.rgnBBox;
  ScrollRect(pRect, scrollH, scrollV, upRgn);
  prect := upRgn^^.rgnBBox;
  dRect := pRect;
  WindRct(imwObj, dRect);  { convert dRect to windowRect }
  dLine := LineBelowPos(wsLink, dRect.topLeft, linePt);
  EraseRect(pRect);
  DrawFromLine(wsLink, dLine, linePt, dRect.bottom);
  DrawPosBoxes(wsLink, dRect);
  DisposeRgn(upRgn);
END;


{$s imstw }
PROCEDURE FixOffsets(imwObj: THIMW; doScrollUp: TF);
  { assumes port and clip rect already set }
VAR scrollH, scrollV: TC;
    wsLink: THWSLink;
    upRgn: RgnHandle;
    upRect: Rect;
BEGIN
  wsLink := imwObj^^.wLink;
  IF wsLink = NIL
    THEN BEGIN
      EXIT(FixOffsets);
    END;
  WITH wsLink^^ DO BEGIN
    IF (kOffset.h = kLPOffset.h) AND (kOffset.v = kLPOffset.v)
      THEN BEGIN
        IF IMStst THEN WRITELN('FixOffsets: no scroll');
        EXIT(FixOffsets);
       END;
    scrollV := kOffset.v - kLPOffset.v;
    scrollH := kOffset.h - kLPOffset.h;
    IF scrollV > 0
      THEN IF NOT doScrollUp
        THEN BEGIN scrollV := 0; kOffset := kLPOffset; END;
    OffsetRect(kPrtRect, scrollH, scrollV);
    kLPOffset := kOffset;
    ScrollSel(wsLink, scrollH, scrollV);
   END;
  IF IMStst THEN WRITELN('FixOffsets scroll dist:', scrollH, scrollV);
  upRgn := NewRgn;
  ScrollRect(imwObj^^.wRect, scrollH, scrollV, upRgn);
  IF scrollV > 0
    THEN BEGIN
      IF IMStst THEN
        WRITELN('FixOffsets scrolling down, repaint top of window');
      ReDrawDWRect(wsLink, upRgn^^.rgnBBox);
     END
    ELSE BEGIN
      upRect := upRgn^^.rgnBBox;
      WindRct(imwObj, upRect);
      AddRToPrtRect(wsLink, upRect);
     END;
  DisposeRgn(upRgn);
END;


{$s imstw }
PROCEDURE DrawDWindow;  { (wsLink: THWSLink);  }
VAR imsObj: THIMS;
    imwObj: THIMW;
    dline: THIMSLine;
    drawPt, linePt: Point;
    dRect, pRect: Rect;
BEGIN
  IF wsLink = NIL THEN EXIT(DrawDWindow);
  IF IMStst THEN WRITE('DrawDWindow for link: ', ORD(wsLink), ' prtRect:');
  IF IMStst THEN PrintRect(wsLink^^.kPrtRect);
  imwObj := wsLink^^.kWindow;
  IF imwObj = NIL
    THEN BEGIN
      IF IMStst THEN
        WRITELN('DrawDWindow No window attached to wsLink:', ORD(imwObj));
      EXIT(DrawDWindow);
     END;
  imsObj := wsLink^^.kStream;
  SetIMWClip(imwObj);  { sets port }
  FixOffsets(imwObj, TRUE);
  dRect := wsLink^^.kPrtRect;
  drawPt := wsLink^^.kPrtRect.topLeft;
  pRect := dRect;
  PortRct(imwObj, pRect);  { make pRect the port rect }
  dLine := LineBelowPos(wsLink, drawPt, linePt);
  IF NOT imsObj^^.sDontErase THEN EraseRect(pRect);
  DrawFromLine(wsLink, dLine, linePt, dRect.bottom);
  DrawPosBoxes(wsLink, dRect);
  wsLink^^.kPrtRect := nullRect;
END;



{$s imstw }
PROCEDURE ReDrawDWRect;  { (wsLink: THWSLink; pRect: Rect);  }
VAR imsObj: THIMS;
    imwObj: THIMW;
    dline: THIMSLine;
    vpos: TC;
    drawPt, linePt: Point;
    dRect: Rect;
BEGIN
  IF wsLink = NIL THEN EXIT(ReDrawDWRect);
  imwObj := wsLink^^.kWindow;
  IF imwObj = NIL
    THEN BEGIN
      IF IMStst THEN
        WRITELN('ReDrawDWRect No window attached to wsLink:', ORD(imwObj));
      EXIT(ReDrawDWRect);
     END;
  imsObj := wsLink^^.kStream;
  SetIMWClip(imwObj);  { sets port }
  dRect := pRect;
  WindRct(imwObj, dRect);  { convert dRect to windowRect }
  dLine := LineBelowPos(wsLink, dRect.topLeft, linePt);
  IF NOT imsObj^^.sDontErase THEN EraseRect(pRect);
  DrawFromLine(wsLink, dLine, linePt, dRect.bottom);
  DrawPosBoxes(wsLink, dRect);
END;



{$s imstc }
PROCEDURE SetDWDispRect;  { (imwObj: THIMW; dr: Rect);  }
BEGIN
  IF imwObj = NIL
    THEN EXIT(SetDWDispRect)
    ELSE imwObj^^.wDispRect := dr;
END;


{$s imstc }
PROCEDURE SetDWRect;  { (imwObj: THIMW; dr: Rect);  }
BEGIN
  IF imwObj = NIL
    THEN EXIT(SetDWRect)
    ELSE imwObj^^.wRect := dr;
END;


{$s imstw }
FUNCTION NewBtnLine(imsObj: THIMS; btnIdx, btnH, btnVD: TC): THIMSLine;
VAR hBtnLine: THIMSLine;
    pbtnRec: TPButton;
    bsize: Point;
    bname: TKeyStr;
BEGIN
  pbtnRec := GetButtonRec(btnIdx);
  IF pbtnRec = NIL
    THEN BEGIN
      IF IMtst OR IMStst THEN
         WRITELN('NewBtnLine - No button with button index:', btnIdx);
      NewBtnLine := NIL;
      EXIT(NewBtnLine);
     END;
  bsize := pbtnRec^.btnSize;
  bname := pbtnRec^.btnName;
  hBtnLine := POINTER(ORD(
        HAllocate(StrHeap, (CBaseLineSize + SIZEOF(TBtnLine)))));
  IF IMStst THEN
     WRITELN('new button line for button: ', bname, ' btnIdx: ', btnIdx);
  WITH hBtnLine^^ DO
    BEGIN
      lType := CBtnLine;
      lIdx := NxtLnIdx;
      lNext := NIL;
      lPrev := NIL;
      lHt := bsize.v;
      IF btnVD < 0 THEN lVDsp := bsize.v ELSE lVDsp := btnVD;
      btn.pBtnIdx := btnIdx;
      btn.pBtnHPos := btnH;
      btn.pBtnSize := bsize;
    END;
  IF IMStst THEN
    WRITELN('Created button line: ', ORD(hBtnLine), ' buttonID: ', btnIdx);
  NewBtnLine := hBtnLine;
END;


{$s imstw }
PROCEDURE AddBtnLine; { (imsObj: THIMS; bidx, hpos: TC; fShowEnd: TF); }
VAR hBtnLine: THIMSLine;
BEGIN
  hBtnLine := NewBtnLine(imsObj, bidx, hpos, imsObj^^.sLineData.dLVDsp);
  IF hBtnLine <> NIL THEN AttachLine(imsObj, hBtnLine, fShowEnd);
END;


{$s imstw }
FUNCTION MakeBoxLine(imsObj: THIMS; VAR name: TStr20; posFlag: TF): THIMSLine;
VAR hBoxLine: THIMSLine;
    posSize: TC;
BEGIN
  IF posFlag THEN posSize := 4 ELSE posSize := 0;
  hBoxLine := POINTER(ORD(
        HAllocate(StrHeap, (CBaseLineSize + SIZEOF(TBoxLine) + posSize))));
  IF IMStst THEN WRITELN('Making box line ', name, ' handle: ', ORD(hBoxLine));
  WITH hBoxLine^^ DO
    BEGIN
      IF posFlag
        THEN lType := CPBxLine
        ELSE lType := CBoxLine;
      lIdx := NxtLnIdx;
      lNext := NIL;
      lPrev := NIL;
      lHt := 0;
      lVDsp := 0;
      box.bXLine := NIL;
      box.bLineCount := 0;
      box.bExchange := FALSE;
      box.bFixedHt := FALSE;
      box.bName := name;
      NewLnSeq(hBoxLine^^.box.bLineSeq);
    END;
  IF IMStst THEN
    WRITELN('Created text box named: ', hBoxLine^^.box.bName, ', ',
             ORD(hBoxLine), ' posBox: ', posFlag);
  MakeBoxLine := hBoxLine;
END;


{$s imstw }
FUNCTION NewBoxLine(imsObj: THIMS; VAR name: TStr20): THIMSLine;
VAR hBoxLine: THIMSLine;
BEGIN
  hBoxLine := MakeBoxLine(imsObj, name, FALSE);
  IF IMStst THEN
    WRITELN('Created text box named: ', hBoxLine^^.box.bName, ', ',
            ORD(hBoxLine));
  NewBoxLine := hBoxLine;
END;


{$s imstw }
FUNCTION NewPBxLine(imsObj: THIMS; VAR name: TStr20; bxPos: Point): THIMSLine;
VAR hPBxLine: THIMSLine;
BEGIN
  hPBxLine := MakeBoxLine(imsObj, name, TRUE);
  hPBxLine^^.pbxPos := bxPos;
  IF IMStst THEN WITH hPBxLine^^ DO
    WRITELN('Created pos box named: ', box.bName, ', ',
            ORD(hPBxLine), ' at:', pbxPos.h:5, pbxPos.v:5);
  NewPBxLine := hPBxLine;
END;


{$s imstw }
FUNCTION FindTextBox(imsObj: THIMS; VAR name: TStr20; newFlag: TF): THIMSLine;
LABEL 600, 800;
VAR hBoxLine: THIMSLine;
BEGIN
  IF name = '' THEN GOTO 600;
  hBoxLine := imsObj^^.sLineSeq.sFstLine^^.lNext;
  WHILE (hBoxLine^^.lType <> CLstLine)
    DO BEGIN
      IF hBoxLine^^.lType = CBoxLine
        THEN IF hBoxLine^^.box.bName = name
          THEN GOTO 800;
      hBoxLine := hBoxLine^^.lNext;
     END;
600:
  IF newFlag
    THEN BEGIN
      hBoxLine := NewBoxLine(imsObj, name);
      AppendLine(imsObj, hBoxLine);
     END
    ELSE hBoxLine := NIL;
800:
  IF IMStst
    THEN WRITELN('Found text box ', ORD(hBoxLine));
  FindTextBox := hBoxLine;
END;


{$s imstw }
PROCEDURE ClearBoxLine(imsObj: THIMS; hBoxLine: THIMSLine);
VAR fOK, lineRemoved: TF;
    pLine: THIMSLine;
BEGIN {ClearBoxLine}
  IF IMStst THEN WRITELN('Clearing text box: ', ORD(hBoxLine));
  IF IMStst THEN PxBoxLine(hBoxLine);
  ClearLineSeq(imsObj, hBoxLine^^.box.bLineSeq);
  hBoxLine^^.lHt := 0;
  IF (NOT hBoxLine^^.box.bFixedHt) THEN hBoxLine^^.lVDsp := 0;
  hBoxLine^^.box.bExchange := FALSE;
  hBoxLine^^.box.bXLine := NIL;
  hBoxLine^^.box.bLineCount := 0;
  IF IMStst THEN WRITELN('Cleared Text Box: ', hBoxLine^^.box.bName);
END;


{$s imstw }
PROCEDURE ClearTextBox;  { (imsObj: THIMS; VAR name: TStr20); }
VAR fOK, lineRemoved: TF;
    hBoxLine: THIMSLine;
BEGIN {ClearTextBox}
  IF IMStst THEN WRITELN('Clearing text box named: ', name);
  hBoxLine := FindTextBox(imsObj, name, FALSE);
  IF hBoxLine = NIL
    THEN BEGIN IF IMStst THEN WRITELN('cant find text box: ', name); END
    ELSE BEGIN
      ClearBoxLine(imsObj, hBoxLine);
     END;
END;


{$s imstw }
PROCEDURE SetTxtBoxSize; { (imsObj: THIMS; VAR name: TStr20; bxVDsp: TC); }
VAR hBoxLine: THIMSLine;
BEGIN
  IF IMStst THEN WRITELN('Setting size of: ', name, ' box to', bxVDsp);
  hBoxLine := FindTextBox(imsObj, name, FALSE);
  IF hBoxLine = NIL
    THEN BEGIN
      IF IMtst OR IMStst OR sDebug THEN
        WRITELN ('SetTxtBoxSize - Cant find text box line named:', name);
      EXIT(SetTxtBoxSize);
     END;
  hBoxLine^^.lVDsp := bxVDsp;
  hBoxLine^^.box.bFixedHt := (bxVDsp < 0);
END;



{$s imstw }
PROCEDURE StartPosBox; {(imsObj: THIMS; name: TStr20; bpos: Point); }
VAR hBoxLine: THIMSLine;
    fOK: TF;
    pLine: THIMSLine;
BEGIN
  IF IMStst THEN WRITELN('Starting text box at: ', bpos.h:5, bpos.v:5);
  hBoxLine := NewPBxLine(imsObj, name, bpos);
  IF hBoxLine = NIL
    THEN BEGIN
      InterpError('Cant create box line');
      EXIT(StartPosBox);
     END;
  AppendLine(imsObj, hBoxLine);
  imsObj^^.sTextBox := hBoxLine;
  IF IMStst THEN
    BEGIN WRITELN('Started pos box:'); PxPBxLine(hBoxLine); END;
END;



{$s imstw }
PROCEDURE StartTextBox; { (imsObj: THIMS; name: TStr20; fExchange: TF); }
VAR hBoxLine: THIMSLine;
    fOK: TF;
    pLine: THIMSLine;
BEGIN
  IF IMStst THEN WRITELN('Starting text box: ', name);
  hBoxLine := FindTextBox(imsObj, name, TRUE);
  IF hBoxLine = NIL
    THEN BEGIN
      InterpError('Cant create box line');
      EXIT(StartTextBox);
     END;
  imsObj^^.sTextBox := hBoxLine;
  IF fExchange
    THEN BEGIN
      hBoxLine^^.box.bXLine := hBoxLine^^.box.bLineSeq.sFstLine;
      hBoxLine^^.box.bExchange := TRUE;
     END
    ELSE BEGIN
      ClearBoxLine(imsObj, hBoxLine);
     END;
  IF IMStst THEN
    BEGIN WRITELN('Started text box:'); PxBoxLine(hBoxLine); END;
END;



{$s imstw }
PROCEDURE EndTextBox; { (imsObj: THIMS); }
BEGIN
  IF IMStst THEN
    BEGIN WRITELN('Ending text box:'); PxBoxLine(imsObj^^.sTextBox); END;
  imsObj^^.sTextBox^^.box.bExchange := FALSE;
  imsObj^^.sTextBox^^.box.bXLine := NIL;
  imsObj^^.sTextBox := NIL;
END;



{$s imstw }
FUNCTION GetFldFont;  { (hFldLine: THImsLine; VAR onlyFont: TF): TC; }
BEGIN
  { returns the font family of the first font in the field }
  IF hFldLine^^.fld.fhField^^.curFmts > 1
    THEN BEGIN
      IF IMStst THEN
        WRITELN('GetFldFont - more than 1 format - cant convert');
      onlyFont := FALSE;
     END
    ELSE onlyFont := TRUE;
  GetFldFont := hFldLine^^.fld.fhField^^.fmtInfo^^[0].font;
END;


{$s imstw }
FUNCTION GetFldFace(hFldLine: THImsLine; VAR fface: Style): TC;
BEGIN
  fface :=  hFldLine^^.fld.fhField^^.fmtInfo^^[0].face;
END;


{$s imstw }
FUNCTION NewFldLine;  { (imsObj: THIMS;
               lrgch: TRgch; chrCt, fIdx, ht, vdsp, indent: TC): THIMSLine; }
VAR hFldLine: THIMSLine;
    r: Rect;
    ffam, i: TC;
    ferr: TC;
BEGIN
  {$R-}
  IF IMStst THEN BEGIN
     WRITELN('NewFldLine: ChrCt:', chrCt:4, fIdx, ht, vdsp);
     WRITE('Init curVal:');
     for i := 0 to (chrCt - 1) do WRITE(CHR(lrgch^[i])); WRITELN;
    END;
  {$R+}
{$r- }
  hFldLine := POINTER(ORD(
     HAllocate(StrHeap, (CBaseLineSize + SIZEOF(TFldLine)))));
  WITH hFldLine^^ DO
    BEGIN
      lType := CFldLine;
      lIdx := NxtLnIdx;
      lNext := NIL;
      lPrev := NIL;
      IF ht >= 0
        THEN hFldLine^^.lHt := ht
        ELSE hFldLine^^.lHt := FontHt(fIdx);
      IF vdsp >= 0
        THEN hFldLine^^.lVDsp := vdsp
        ELSE hFldLine^^.lVDsp := hFldLine^^.lHt;
      fld.fActSel := FALSE;
      fld.fSelOffset.h := 0;
      fld.fSelOffset.v := 0;
      SetRect(r, indent-fldPad, 0, (indent + TxWid(lrgch, chrCt, fIdx)+2), ht+1);
       {the +2 is a fudge factor to make sure field rect will erase hilighting }
    END;
  ffam := FontFam(fIdx);
  hFldLine^^.fld.fhField :=
                    CreateField(r, chrCt+10, 20, left, fldPad, 1, 3, ffam, FALSE);
  MoveRgch(POINTER(ORD(hFldLine^^.fld.fhField^^.curvalue^)), lrgch, chrCt);
  hFldLine^^.fld.fhField^^.curLen := chrCt;
  hFldLine^^.fld.fhFState := NIL;
  SetFProtect(hFldLine^^.fld.fhField, NIL, FALSE);
  IF IMSTst THEN BEGIN WRITELN('NewFldLine created for stream: ', ORD(imsObj));
                     PxFldLine(hFldLine, TRUE, FALSE);
                   END;
  NewFldLine := hFldLine;
END;


{$s imstw }
FUNCTION TxtToFldLine; { (imsObj: THIMS; hTxtLine: THIMSLine): THIMSLine; }
VAR hFldLine, pLine: THIMSLine;
BEGIN
  WITH hTxtLine^^ DO
    hFldLine := NewFldLine(imsObj, @txt.tChars, txt.tChrCt,
                           txt.tFontIdx, lHt, lVDsp, txt.tIndent);
  ReplaceLine(hFldLine, hTxtLine);
  IF IMStst THEN
    WRITELN('TxtToFldLine converts textLine:', ORD(hTxtLine),
            ' to fieldLine:', ORD(hFldLine));
  FreeIMSLine(imsObj, hTxtLine);
  TxtToFldLine := hFldLine;
END;


{$s imstw }
FUNCTION FldToTxtLine; { (imsObj: THIMS; hFldLine: THIMSLine): THIMSLine; }
VAR hTxtLine, pline: THIMSLine;
     fldIdx, fldLen, fldIndent: TC;
     fldChars: TRgch;
BEGIN
  IF IMStst THEN
    WRITELN('FldToTxtLine stream:', ORD(imsObj), ' fldLine:', ORD(hFLdLine));
  IF hFldLine^^.fld.fActSel
    THEN BEGIN
      UnSelect(imsObj);
     END;
  IF hFldLine^^.fld.fhField^^.curFmts > 1
    THEN BEGIN
      FldToTxtLine := hFldLine;
      IF IMStst THEN
        WRITELN('FldToTxtLine - more than 1 format - cant convert');
      EXIT(FldToTxtLine);
     END;
  IF hFldLine^^.fld.fhField^^.fmtInfo^^[0].face <> []
    THEN BEGIN
      FldToTxtLine := hFldLine;
      IF IMStst THEN
        WRITELN('FldToTxtLine - non normal font face - cant convert');
      EXIT(FldToTxtLine);
     END;
  fldIdx := FontIndex(hFldLine^^.fld.fhField^^.fmtInfo^^[0].font);
  fldLen := hFldLine^^.fld.fhField^^.curLen;
  fldIndent := hFldLine^^.fld.fhField^^.coords.left+fldPad;
  fldChars := POINTER(ORD(hFldLine^^.fld.fhField^^.curValue^));
  WITH hFldLine^^ DO hTxtLine :=
    NewTextLine(imsObj, fldChars, fldLen, fldIdx, lHt, lVDsp, fldIndent);
  ReplaceLine(hTxtLine, hFldLine);
  IF IMStst THEN
    WRITELN('FldToTxtLine converts fldline:', ORD(hFldLine),
            ' to textLine:', ORD(hTxtLine));
  FreeIMSLine(imsObj, hFldLine);
  FldToTxtLine := hTxtLine;
END;


END.
