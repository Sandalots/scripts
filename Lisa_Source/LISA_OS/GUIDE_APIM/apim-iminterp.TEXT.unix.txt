{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}


{$s imic }
{$r- }

UNIT IMInterp;

INTERFACE

USES {$U HwInt        }  HwInt,
     {$U libos/SysCall      }  SysCall,
     {$U libos/PSysCall     }  PSysCall,
     {$U UnitStd.obj  }  UnitStd,
     {$U UnitHz.obj   }  UnitHz,
     {$U Storage.obj  }  Storage,
     {$U QuickDraw    }  QuickDraw,
     {$U FontMgr.obj  }  FontMgr,
     {$U PmDecl       }  PmDecl,
     {$U PMM          }  PMM,
     {$U FMgrUtil.obj }  FmgrUtil,
     {$U WM.Events    }  Events,
     {$U WM.Folders   }  Folders,
     {$U WM.Menus     }  Menus,
     {$U WMLStd       }  WMLStd,
     {$U WMLSB        }  WMLSb,
     {$U WMLGrow      }  WMLGrow,
     {$U AlertMgr.obj }  AlertMgr,
     {$U dbenv.obj    }  dbenv,
     {$U DBdecl1      }  DBdecl1,
     {$U fedec.obj    }  fedec,
     {$U fld.obj      }  FieldEdit,
     {$U apim/UnitImf.obj  }  UnitImf,
     {$U apim/imcore.obj   }  IMCore,
     {$U apim/IMMenus.obj  }  IMMenus,
     {$U apim/IMStream.obj }  IMStream,
     {$U apim/IMSEdit.obj  }  IMSEdit,
     {$U apim/IMFolders.obj}  IMFolders,
     {$U apim/TFGlobals    }  IFGlobals,  { Common routines & declarations }
     {$U apim/TFEntry      }  IFEntry,
     {$U apim/TCatalog     }  IFCatalog,
     {$U apim/TFiler       }  TFiler,     { TeachingFiler unit }
     {$U apim/IMScript.obj }  IMScript,
     {$U apim/IMPatMat.obj }  IMPatMat;


CONST
  CDefKeepCt = 100;
  logging = FALSE;

  noSound  = 0;
  demSound = 1;
  yesSound = 2;

  { The decode string is set as a constant in IMIntrpInit - to keep it in the init segment  }

TYPE
   TPObjDefRec = ^TObjDefRec;
   TObjDefRec  = RECORD
                  doName, dofName: TKeyStr;
                  doX, doY, doH, doW, doIx, doIy: TC;
                  doStrPos: TFPos;
                  doKind, doSubKind: ObjectKind;
                 END;



VAR

  fShowWords:   TF;

  LastExzPos:       TFPos;
  PrevExzPos:       TFPos;

  btnSound:         TC;

  LGobj:            ObjectHandle;

  simName:          TKeyStr;
  fSim:             TF;
  fSimEdit:         TF;
  fSimHold:         TF;
  fSimRunning:      TF;
  fSimWtPB:         TF;
  fSimWtRec:        TF;
  simPos:           TFPos;

  decode:           PACKED ARRAY[0..255] OF TB;



{$IFC IMCompile }
PROCEDURE ICCompComplete;
{$ENDC }

{$IFC IMDebug }
PROCEDURE DumpCScriptLesson(lesson: TC);
{$ENDC }

PROCEDURE DecodeStr(wordStr: TWordPtr; maxLen: TC);
PROCEDURE RgInt(int, pos: TC; drgch: TRgch);
PROCEDURE SysLog(logID: TB; logStr: TRgch);
PROCEDURE SysILog(logID: TB; li1, li2: TC);
PROCEDURE IMIntrpInit;
FUNCTION  AttachIMFldr(imHObj: ObjectHandle; vis, wind, sbars: TF; cKeep: TC):
                      THFldrInfo;
PROCEDURE InterpretCommand;
PROCEDURE doIMCommand;



IMPLEMENTATION
{$IFC IMDebug}
VAR
    DCSFile: TEXT;
    dcFile: Str255;
    dcLesson: TC;
    dcFirstLesson: TF;
    fEncoding: TF;
    dcCodeStr: Str255;
{$ENDC }


PROCEDURE DimHint;  EXTERNAL;

{$S imic }
{$IFC IMDebug }
  PROCEDURE IMIDbgOn;
  BEGIN
  END;
{$ENDC }


{$S imih }
PROCEDURE DecodeStr; { (wordStr: TWordPtr; maxLen: TC); }
VAR wp: TWordPtr;
    cchr: CHAR;
    wPos, wLen: TC;
BEGIN
cchr := wordStr^[1];
wPos := decode[ORD(cchr)]*128;     { hi half of word offset code }
cchr := wordStr^[2];
wPos := wPos + decode[ORD(cchr)];  { lo half of word offset code }
wp := POINTER(ORD(wordBuf^)+wPos);
wLen := LENGTH(wp^);
IF wLen > maxLen THEN wLen := maxLen;
MoveRgch(POINTER(ORD(wordStr)), POINTER(ORD(wp)),wLen+1);
IF IMtst THEN WRITELN('DecodeStr returns "', wordStr^, '"');
END;


{$S imic }
PROCEDURE LoadWordBuf(fName: PATHNAME);
VAR fErr, fRef: TC;
    bytesRead: TL;
    bufSize: INTEGER;
BEGIN
   OPEN(fErr, fName, fRef, [DRead]);
   IF (ferr <> 0) THEN
     WRITELN('LoadWordBuf OPEN error: ', fErr:1);
   IF fErr > 0 THEN EXIT(LoadWordBuf);
   Read_Data(fErr, fRef, ORD4(@bufSize), 2,bytesRead, Absolute, 0);
   IF (ferr <> 0) THEN
      WRITELN('LoadWordBuf error reading bufSize: ', fErr:1);
   IF fErr > 0 THEN EXIT(LoadWordBuf);
   NewWordBuf(bufSize);
   topWordPos := bufSize;
   Read_Data(fErr, fRef, ORD4(wordBuf^), topWordPos, bytesRead, Absolute, 0);
{$IFC IMDebug }
    IF fErr <> 0 THEN
       WRITELN('Error reading word buf from "', fName, '" size=', bufSize:1, ' error=', fErr:1,
               ' read ', bytesRead:1);
{$ELSEC }
   IF fErr <> 0 THEN
       WRITELN('Error reading word buf from "', fName, '" error=', fErr:1);
{$ENDC }
   IF fErr > 0 THEN fQuit := TRUE;
   CLOSE_OBJECT(fErr, fRef);
   IF fErr <> 0 THEN WRITELN('LoadWordBuf CLOSE error = ', fErr:1);
END;


{$IFC IMDebug}
{$S imdc }
PROCEDURE DumpWordBuf(fName: PATHNAME);
CONST FileExists = 890;
VAR fErr, fRef: TC;
    bytesWrit: TL;
    pInt: ^INTEGER;
BEGIN
   Make_File(fErr, fName, 0);
    IF (ferr <> 0) THEN WRITELN('DumpWordBuf Make_File error: ', fErr);
   IF fErr = FileExists THEN
       BEGIN
       IF IMScrTst THEN WRITELN('Overwriting word buf "', fName, '"');
       fErr := 0;
       END;
   IF fErr > 0 THEN EXIT(DumpWordBuf);
   OPEN(fErr, fName, fRef, [DWrite]);
   IF (ferr <> 0) THEN WRITELN('DumpWordBuf OPEN error: ', fErr:1);
   IF fErr > 0 THEN EXIT(DumpWordBuf);
   pInt := POINTER(ORD(wordBuf^));
   pInt^ := topWordPos;  { write word buf size into file }
   Write_Data(fErr, fRef, ORD4(wordBuf^), topWordPos, bytesWrit, Absolute, 0);
   IF (fErr <= 0) AND (bytesWrit=topWordPos) THEN
       WRITELN('Wrote word buf to "', fName, '" size = ', topWordPos:1, ' error=', fErr:1)
   ELSE
       WRITELN('Error writing word buf to "', fName, '" size=', topWordPos:1,
               ' error=', fErr:1, ' bytesWrit=', bytesWrit:1);
   CLOSE_OBJECT(fErr, fRef);
   IF fErr <> 0 THEN WRITELN('Dump word buf CLOSE error = ', fErr:1);
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
FUNCTION DCReadChar:CHAR;
VAR cchr: CHAR;
BEGIN
  WHILE (ScriptPos < 0) OR (ScriptPos > ScriptLineLen)
    DO NewScriptLine;  { this is really CheckScriptBuf; }
  IF ScriptPos = ScriptLineLen THEN
      DCReadChar := CHR(13)
  ELSE DCReadChar := CHR(ScriptPtr^[ScriptPos]);
  ScriptPos := ScriptPos + 1;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCSetLessonPos(lidx: TC);
VAR BlockKey: TKeyStr;
    TopicName: Str255;
BEGIN
  IF lidx > 0 THEN
      BEGIN
      GetItem(TopicsMInfo^^.mLookupInfo^, lidx, @BlockKey);
      IF IMTst THEN WRITELN('Skipping to Lesson named: ', BlockKey);
      SkipTo('L', BlockKey);
      IF TRUE OR fSkip THEN
         BEGIN
         GetItem(TopicsMInfo^^.mNameInfo^, lidx, @TopicName);
         ParamAlert (TopicName,'','');
         IMAlertUp;
         WaitAlert (imalert, 410);
         END
      END
  ELSE GoStartPos;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
FUNCTION DCOpenFile: INTEGER;
VAR ior: TC;
       { iStr: TStr20; }
BEGIN
       { IntStr20(lessonCounter, iStr); }
       { istr can be concatenated to dcfile to have lesson number in file name. }
       { Not used when using a single compressed script file  }
    IF dcFile <> '-console' THEN
        icOpenName := CONCAT('{T7}', dcFile, '.text')
    ELSE icOpenName := '-console';
    REWRITE(DCSFile, icOpenName);
    ior := IORESULT;
    WRITELN('IOResult of opening compile file "', icOpenName, '" is:', ior:4);
    DCOpenFile := ior;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCChar(cchr: CHAR);
BEGIN
    WRITE(DCSFile, cchr);
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCWord(word: TWordPtr);
VAR wIDx, hiIdx, loIdx: TC;
    cchr: CHAR;
BEGIN
wIdx := AddBufWord(word^);
hiIdx := (wIdx DIV 128) + 1;
loIdx := (wIdx MOD 128) + 1;
cchr := dcCodeStr[hiIdx];
DCChar(cchr);
cchr := dcCodeStr[loIdx];
DCChar(cchr);
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCStartArg;
{ called after the arg start char has been eaten. }
VAR pc, rc: CHAR;
BEGIN
  InArg := TRUE;
  pc := PeekScriptChar;
  CASE pc OF
    '[': BEGIN
         rc := DCReadChar;
         DCChar('(');
         DCChar(rc);
         ArgEndChar := ']';
         END;
    '<': BEGIN
         rc := DCReadChar;
         DCChar('(');
         DCChar(rc);
         ArgEndChar := '>';
         END;
    '*': BEGIN
         rc := DCReadChar;
         ArgEndChar := '*';
         END;
    OTHERWISE  BEGIN  DCChar('('); ArgEndChar := ')'; END;
  END;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
FUNCTION DCEndArg: BOOLEAN;
{ called after ArgEndChar has been eaten. If a sequence is needed to end the arg
  then EndArg will eat the rest of it }
VAR achr: CHAR;
BEGIN
  IF IMScrTst THEN WRITELN('ArgEndChar: ', ArgEndChar, ORD(ArgEndChar):4);
  IF ArgEndChar <> '*' THEN DCChar(ArgEndChar);
  IF ArgEndChar = ')'
    THEN InArg := FALSE
    ELSE
      BEGIN
        achr := PeekScriptChar;
        IF achr = ')'
          THEN
            BEGIN
              InArg := FALSE;
              achr := DCReadChar; { gobble the close paren. }
              IF ArgEndChar <> '*' THEN DCChar(achr);
              ArgEndChar := ')';
            END;
      END;
  IF IMScrTst THEN WRITELN('EndArg = ', (NOT InArg));
  DCEndArg := NOT InArg;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCFinishArg;
VAR achr: CHAR;
BEGIN
   WHILE InArg DO
      BEGIN
      achr := DCReadChar;
      IF achr = ArgEndChar THEN InArg := NOT DCEndArg
      ELSE IF ArgEndChar <> '*' THEN DCChar(achr);
      END;
END;
{$ENDC }

{$IFC IMDebug}
{$S imdc }
PROCEDURE DCCmdDone;
VAR achr: CHAR;
BEGIN
    DCChar('.');
    WRITELN(DCSFile);
    InCommand := FALSE;
END;
{$ENDC }

{$IFC IMDebug}
{$S imdc }
PROCEDURE DCDumpCommand;
VAR cchr: CHAR;
BEGIN
WHILE InCommand DO
    BEGIN
    cchr := DCReadChar;
    IF cchr = '(' THEN  BEGIN DCStartArg; DCFinishArg; END
    ELSE IF cchr = '.' THEN DCCmdDone
    ELSE DCChar(cchr);
    END;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCDumpWords;
VAR wIdx, wPos: TC;
    wp: TWordPtr;
BEGIN
WRITELN(DCSFile);
WRITELN(DCSFile);
wIdx := cMaxSpaces;
wPos := 2;
WHILE wPos < topWordPos DO
    BEGIN
    wp := POINTER(ORD(wordBuf^)+wPos);
    wIdx := wIdx+1;
    WRITELN(DCSFile, '   (*  word ',  wPos:4, ' = ''', wp^, ''';  usage: ',
                     wUseArray[wIdx]:4, ' *)');
    wPos := wPos + LENGTH(wp^) + 1;
    END;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCDisplayCommand(fDChar: TF);
LABEL 900;
VAR rgch: TRgch;
    word: Str255;
    cchr: CHAR;
    wIdx: TC;
    wLen: TC;
    wByte: TB;
    argDone: TF;
    spCount: TC;
    indCount: TC;
    strLen: TB;

    PROCEDURE DCDispWord;
    BEGIN
    IF spCount < 0 THEN spCount := 0;
    IF spCount <> 1 THEN
      BEGIN
      WHILE spCount > 9 DO
          BEGIN
          WRITE(DCSFile, '9');
          spCount := spCount - 9;
          END;
      WRITE(DCSFile, spCount:1);
      END;
    spCount := 0;
    DCWord(@word);
    END;


BEGIN
  IF NOT fDChar THEN DCChar('D');
  WHILE TRUE DO
    BEGIN
    cchr := DCReadChar;
    IF ORD(cchr) = 13 THEN WRITELN(DCSFile)
    ELSE CASE cchr OF
      'T', 't':
           BEGIN
           WRITE(DCSFile, CHR(ORD('†')));
           cchr := DCReadChar;  { should be a '(' }
           IF cchr <> '(' THEN
               CmdError('DCDumpCScript - error in display command - "T" not followed by "(".');
           DCStartArg;
           indCount := scriptPos;
           spCount := 0;
           argDone := FALSE;
           REPEAT
               StrWord(word, scriptPtr, scriptPos, scriptLineLen);
               wLen := LENGTH(word);
               IF wLen = 0 THEN
                 BEGIN
                 WRITELN(DCSFile);
                 spCount := -indCount;
                 NewScriptLine;
                 END
               ELSE IF wLen = 1 THEN
                 BEGIN
                   IF word[1] = ' ' THEN
                      BEGIN
                      spCount := spCount+1;
                      END
                   ELSE
                      BEGIN
                      IF (word[1] = ArgEndChar) THEN
                        IF DCEndArg THEN argDone := TRUE
                        ELSE DCDispWord
                      ELSE DCDispWord
                      END;
                 END
               ELSE DCDispWord;
               UNTIL argDone;
           END;
      '(': BEGIN DCStartArg; DCFinishArg; END;
      '.': BEGIN DCCmdDone; GOTO 900; END;
      OTHERWISE DCChar(cchr);
      END;
    END;
900:
DCDumpCommand;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCStopEncoding;
VAR cchr: CHAR;
    ior: TC;
BEGIN
   GoStartPos;
   ClearSkips;
   EndKrunch;
   fEncoding := FALSE;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCBeginCommand;
LABEL 200;
VAR cchr: CHAR;
    blkName: TLocStr;
    ior: TC;
BEGIN
cchr := ReadUCScriptChar;
IF (cchr = 'L') THEN
    BEGIN
    lessonCounter := lessonCounter + 1;
    CountAlert(9, lessonCounter);
    IF FALSE
     { NOT dcFirstLesson } THEN
        BEGIN
        CLOSE(DCSFile,LOCK);
        IF dcLesson = 0 THEN
            BEGIN
            ior := DCOpenFile;
            IF (ior > 0)
              THEN BEGIN
                  WRITELN('DumpCScriptLesson:  rewrite setup file - ',
                                dcFile, ' err:', ior);
                  DCStopEncoding;
                  GOTO 200;;
               END;
            END
        ELSE
            BEGIN
            DCStopEncoding;
            WRITELN;
            GOTO 200;
            END;
        END
    ELSE dcFirstLesson := FALSE;
    END;
DCChar('B');
CASE cchr OF
    'L': DCChar('¬');
    'E': DCChar('∑');
    'B': DCChar('∫');
    OTHERWISE CmdError('DCBeginCommand - not a lesson, exercise or block ');
    END;
IF ArgStr(@blkName, CLocSize, FALSE) THEN
    BEGIN
    DCChar('(');
    DCWord(@blkName);
    DCChar(')');
    CASE cchr OF
      'L': curLesson := blkName;
      'E': curExercise := blkName;
      'B': curBlock := blkName;
      END;
    END
ELSE CmdError('DCBeginCommand - cant read blkName');
DCDumpCommand;
200:
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCEndCommand;
LABEL 200;
VAR cchr: CHAR;
    blkName: TKeyStr;
    ior: TC;
BEGIN
DCChar('E');
cchr := ReadUCScriptChar;
IF cchr = 'Z' THEN
    BEGIN { end of script }
    DCCHar(cchr);
    cchr := DCReadChar;
    DCCHar('.');
    WRITELN(DCSFile, '(* End of script *)');
    dcFile := CONCAT('{T7}', dcFile, 'Words');
    DumpWordBuf(dcFile);
    WRITELN;
    WRITELN('End of script ');
    CLOSE(DCSFile, LOCK);
    DCStopEncoding;
    WRITELN;
    GOTO 200;
    END;
CASE cchr OF
    'L': DCChar('¬');
    'E': DCChar('∑');
    'B': DCChar('∫');
    OTHERWISE CmdError('DCEndCommand - not a lesson, exercise or block ');
    END;
IF ArgStr(@blkName, CLocSize, FALSE) THEN
    BEGIN
    DCChar('(');
    DCWord(@blkName);
    DCChar(')');
    END
ELSE CmdError('DCEndCommand - cant read blkName');
DCDumpCommand;
200:
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCFldrCommand;
LABEL 900;
VAR cchr: CHAR;
    fldrName: TKeyStr;
BEGIN
DCChar('F');
WHILE InCommand DO
    BEGIN
    cchr := ReadUCScriptChar;
    IF (cchr = 'N') THEN
        BEGIN
        IF ArgStr(@fldrName, CKeySize, FALSE) THEN
            BEGIN
            DCChar('Ñ');
            IF PeekUCScriptChar = '?' THEN
                BEGIN
                cchr := ReadUCScriptChar;
                DCChar('?');
                END;
            DCChar('(');
            DCWord(@fldrName);
            DCChar(')');
            END
        ELSE CmdError('DCFldrCommand - cant read folder obj name');
        END
    ELSE IF (cchr = 'S') THEN
        BEGIN
        IF ArgStr(@fldrName, CKeySize, FALSE) THEN
            BEGIN
            DCChar('ß');
            DCChar('(');
            DCWord(@fldrName);
            DCChar(')');
            END
        ELSE CmdError('DCFldrCommand - cant read folder Set obj name');
        END
    ELSE IF (cchr = 'M') THEN
        BEGIN
        IF ArgStr(@fldrName, CKeySize, FALSE) THEN
            BEGIN
            DCChar('∏');
            DCChar('(');
            DCWord(@fldrName);
            DCChar(')');
            END
        ELSE CmdError('DCFldrCommand - cant read Member obj name');
        END
    ELSE IF (cchr = 'Z') THEN
        BEGIN
        IF PeekUCScriptChar = 'X' THEN
            BEGIN
            DCChar('Z');
            cchr := DCReadChar;
            DCChar('X');
            END
        ELSE IF ArgStr(@fldrName, CKeySize, FALSE) THEN
            BEGIN
            DCChar('Ω');
            DCChar('(');
            DCWord(@fldrName);
            DCChar(')');
            END
        ELSE CmdError('DCFldrCommand - cant read zap obj name');
        END
    ELSE IF (cchr = 'D') THEN
        BEGIN
        DCChar('D');
        cchr := DCReadChar;
        IF cchr <> '(' THEN CmdError('DCFolderCommand - display sub command without argument')
        ELSE
           BEGIN
           DCStartArg;
           DCDisplayCommand(TRUE);
           InCommand := TRUE;
           InArg := TRUE;
           DCFinishArg;
           END;
        END
    ELSE IF cchr = '(' THEN
        BEGIN
        DCStartArg;
        DCFinishArg;
        END
    ELSE IF cchr = '.' THEN DCCmdDone
    ELSE DCChar(cchr);
    END;
900:
DCDumpCommand;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCMenuCommand;
LABEL 900;
VAR cchr: CHAR;
    fldrName: TKeyStr;
BEGIN
DCChar('M');
WHILE InCommand DO
    BEGIN
    cchr := ReadUCScriptChar;
    IF (cchr = 'F')THEN
        BEGIN
        IF ArgStr(@fldrName, CKeySize, FALSE) THEN
            BEGIN
            DCChar('ƒ');
            DCChar('(');
            DCWord(@fldrName);
            DCChar(')');
            END;
        END
    ELSE IF (cchr = 'M') THEN
        BEGIN
        IF ArgStr(@fldrName, CKeySize, FALSE) THEN
            BEGIN
            DCChar('∏');
            DCChar('(');
            DCWord(@fldrName);
            DCChar(')');
            END;
        END
    ELSE IF (cchr = 'I') THEN
        BEGIN
        IF ArgStr(@fldrName, CKeySize, FALSE) THEN
            BEGIN
            DCChar('|');
            DCChar('(');
            DCWord(@fldrName);
            DCChar(')');
            END;
        END
    ELSE IF cchr = '(' THEN
        BEGIN
        DCStartArg;
        DCFinishArg;
        END
    ELSE IF cchr = '.' THEN DCCmdDone
    ELSE DCChar(cchr);
    END;
900:
DCDumpCommand;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCGoCommand;
LABEL 900;
VAR cchr: CHAR;
    blkName: TLocStr;
BEGIN
DCChar('G');
WHILE InCommand DO
    BEGIN
    cchr := ReadUCScriptChar;
    IF (cchr = 'L') OR (cchr = 'E') OR (cchr = 'B') THEN
        BEGIN
        IF ArgStr(@blkName, CLocSize, FALSE) THEN
            BEGIN
            CASE cchr OF
                'L': DCChar('¬');
                'E': DCChar('∑');
                'B': DCChar('∫');
                END;
            DCChar('(');
            DCWord(@blkName);
            DCChar(')');
            END;
        END
    ELSE IF cchr = 'D' THEN
        BEGIN
        DCDisplayCommand(FALSE);
        END
    ELSE IF cchr = '.' THEN DCCmdDone
    ELSE CmdError('DCGoCommand invalid go sub command');
    END;
900:
DCDumpCommand;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DCIMStateCommand;
LABEL 900;
VAR cchr: CHAR;
    mapName: TKeyStr;
BEGIN
DCChar('I');
WHILE InCommand DO
    BEGIN
    cchr := DCReadChar;
    IF (cchr = 'L') OR (cchr = 'l') THEN
        BEGIN
        IF ArgStr(@mapName, CKeySize, FALSE) THEN
            BEGIN
            { dont dump the old IL(-) command. }
            END;
        END
    ELSE IF cchr = '(' THEN
        BEGIN
        DCStartArg;
        DCFinishArg;
        END
    ELSE IF cchr = '.' THEN DCCmdDone
    ELSE DCChar(cchr);
    END;
900:
DCDumpCommand;
END;
{$ENDC }


{$IFC IMDebug}
{$S imdc }
PROCEDURE DumpCScriptLesson; { (lesson: TC); }
LABEL 10, 20;
VAR cchr: CHAR;
    blkName: TLocStr;
    iStr: TStr20;
    ior: TC;
BEGIN
   IF cDebug THEN WRITELN('Length of dcCodeString: ', LENGTH(dcCodeStr));
   dcFile := 'LGCScript';
10:
   ParamAlert ('{T7}', dcFile, '.text');
   IF NOT CautionAlert(imAlert, 420) THEN EXIT(DumpCScriptLesson);
   IF cDebug THEN
        BEGIN
        WRITE('Starting script encoding to "', dcFile, '". OK? ');
        IF GetYorN THEN GOTO 20;
        WRITE('Do script encoding to another file? ');
        IF NOT GetYorN THEN EXIT(DumpCScriptLesson);
        WRITE('Please enter script file name: ');
        READLN(dcFile);
        GOTO 10;
        END
    ELSE WRITELN('Starting script encoding to "{T7}', dcFile, '".');
20:
  {$I- }
  lessonCounter := lesson;
  IF lessonCounter = 0 THEN lessonCounter := 1;
  ior := DCOpenFile;
  IF (ior > 0)
    THEN BEGIN
        WRITELN('DumpCScriptLesson:  rewrite setup file - ',
                      dcFile, ' err:', ior);
        EXIT(DumpCScriptLesson);
     END;
   topWordIdx := cMaxSpaces;
   IF (wordBuf = NIL) THEN NewWordBuf(cWBSize);
   SaveResetPos;
   dcLesson := lesson;
   DCSetLessonPos(lesson);
   SkipTo('L', 'no such lesson');
   fStepped    := FALSE;
   fWait       := FALSE;
   fEncoding := TRUE;
   dcFirstLesson := TRUE;
   IMAlertUp;
   WaitAlert (imAlert, 419);
   CountAlert(9, lessonCounter);
   WRITELN(DCSFile, 'IW(', dcFile, 'Words).');
   WRITELN(DCSFile, 'IL(', dcFile, 'Map).');
END;
{$ENDC }


{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICEndProc;
VAR blockNo: TC;
BEGIN
    WRITELN(icFile, 'END; { Blk', icBlockNumber:1, ' }');
    icInProc := FALSE;
END;
{$ENDC }

{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICNewProc(blockNo: TC);
BEGIN
IF fICompile THEN
     BEGIN
     IF icInProc THEN ICEndProc;
     IF blockNo = 0 THEN
         BEGIN
         icBlockNumber := icBlockNumber+1;
         blockNo := icBlockNumber;
         END;
     WRITELN(icfile);
     WRITELN(icFile, 'PROCEDURE Blk', blockNo:1, ';');
     WRITELN(icFile, 'BEGIN');
     icInProc := TRUE;
     END;
END;
{$ENDC }

{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICNewCase;
BEGIN
IF fICompile THEN
     BEGIN
    icBlockNumber := icBlockNumber+1;
     WRITELN(icfile);
     WRITELN(icFile, '  ', icBlockNumber:1, ':');
     WRITELN(icFile, '    BEGIN');
     icInProc := TRUE;
     END;
END;
{$ENDC }

{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICCase;
VAR blockNo: TC;
BEGIN
    WRITELN(icFile, '    CASE cBlockNum OF');
    icInBlock := TRUE;
END;
{$ENDC }

{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICEndCase;
VAR blockNo: TC;
BEGIN
    WRITELN(icFile, '    END; {CASE}');
    icInBlock := TRUE;
END;
{$ENDC }

{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICBegin;
VAR blockNo: TC;
BEGIN
    WRITELN(icFile, '    BEGIN');
    icInBlock := TRUE;
END;
{$ENDC }

{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICEnd;
VAR blockNo: TC;
BEGIN
    WRITELN(icFile, '    END;');
    icInBlock := FALSE;
END;
{$ENDC }

{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICBeginCommand(blkType: CHAR; blkName:CLocSize);
VAR plocRec: TPLocRec;
    bNameIdx: TC;
    s255:    Str255;
BEGIN
  IF fICompile THEN
      BEGIN
      s255 := blkName;
      bNameIdx := AddBufWord(s255);
      CASE blkType OF
        'L': BEGIN
             ICNewProc(0);
             WRITELN(icfile, '  {"  In Lesson: ', curLesson, '" }');
             WRITELN(icfile, 'CBeginLesson(', bNameIdx:1, ');');
             END;
        'E': BEGIN
             ICNewProc(0);
             WRITELN(icfile, '  {"  In Lesson: ', curLesson, '",  Exercise: "', curExercise, '" }');
             WRITELN(icfile, 'CBeginExercise(', bNameIdx:1, ');');
             ICCase;
             END;
        'B': BEGIN
             ICNewCase;
             WRITELN(icfile, 'CBeginBlock(', bNameIdx:1, ');');
             WRITELN(icfile, '  {"  In Lesson: ', curLesson, '",  Exercise: "', curExercise,
                                '",  Block: "',  curBlock, '" }');
             END;
        END;
      pLocRec := LookupLoc(blkType, blkName);
      IF pLocRec = NIL THEN
          CmdError('ICBeginCommand cant find new locrec for block');
      pLocRec^.blkNo := icBlockNumber;
      IF icSkipBlock THEN
          BEGIN
          icBlocknumber := icBlockNumber+1;
          pLocRec^.nxtBlkNo := icBlockNumber;
          icSkipBlock := FALSE;
          END;
      END;
END;
{$ENDC }


{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICEndCommand(blkType: CHAR; blkName:CLocSize);
VAR plocRec: TPLocRec;
    procNum: TC;
BEGIN
  IF fICompile THEN
      BEGIN
      pLocRec := LookupLoc(blkType, blkName);
      IF pLocRec = NIL THEN
          CmdError('ICEndCommand cant find locrec for block');
      procNum := pLocRec^.nxtBlkNo;
      IF procNum > 0 THEN ICNewProc(procNum);
      CASE blkType OF
          'B': BEGIN
               WRITELN(icFile, 'CEndBlock;');
               ICEnd;
               END;
          'E': BEGIN
               WRITELN(icFile, 'CEndExercise;');
               ICEndCase;
               ICEndProc;
               END;
          'L': BEGIN
               WRITELN(icFile, 'CEndLesson;');
               ICEndProc;
               CompLesson;
               END;
          'Z': BEGIN
               WRITELN(icFile, 'CEndScript;');
               ICEndProc;
               ICCompComplete;
               CloseComp;
               END;
          END;
      END;
END;
{$ENDC }


{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICCompComplete;
BEGIN
  IF fICompile THEN
      BEGIN
      ICDumpWords;
      END;
END;
{$ENDC }


{$IFC IMCompile }
{$S imcomp }
PROCEDURE ICAddStrLine(chars:TRgch; ct:TC; fShowEnd:TF; XPos:TC);
VAR wa: ARRAY[1..10] OF TC;
    wCt, wPos, spCount: TC;
    wStr: Str255;
    imHeapBytes: TC;

    PROCEDURE PutRest;
    VAR i: TC;
    BEGIN
    IF wCt = 0 THEN
        BEGIN
        WRITELN(icFile, 'CSkipLine;');
        EXIT(PutRest);
        END;
    i := 1;
    WRITE(icFile, 'CLD', wCt:1, 'Words(');
    WHILE i < wCt DO BEGIN WRITE(icFile, wa[i]:1, ', '); i:=i+1; END;
    WRITELN(icFile,  wa[wCt]:1, ');');
    wCt := 0;
    END;

    PROCEDURE Put10;
    BEGIN
    WRITELN(icFile, 'CDTenWords(', wa[1]:1, ',  ', wa[2]:1, ',  ', wa[3]:1, ',  ', wa[4]:1, ',  ',
            wa[5]:1, ',  ', wa[6]:1, ',  ', wa[7]:1, ',  ', wa[8]:1, ',  ', wa[9]:1, ',  ', wa[10]:1, ');');
    wCt := 0;
    END;

    PROCEDURE PutWord(wIdx: TC);
    BEGIN
    IF wIdx = 0 THEN EXIT(PutWord);
    WHILE spCount > 1 DO
        BEGIN
        IF wCt = 10 THEN Put10;
        wCt := wCt+1;
        IF spCount > cMaxSpaces THEN
            BEGIN
            wa[wCt] := cMaxSpaces;
            spCount := spCount - cMaxSpaces;
            END
        ELSE
            BEGIN
            wa[wCt] := spCount;
            spCount := 0;
            END;
        END;
    IF wCt = 10 THEN Put10;
    IF spCount = 0 THEN wIdx := -wIdx;
    wCt := wCt+1;
    wa[wCt] := wIdx;
    spCount := 0;
    END;

BEGIN
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('Entering ICAddStrLine - IMHeap is trashed STOP. hBytes:', imHeapBytes);
      Brk(3333);
      END;
  IF fICompile THEN
      BEGIN
      wPos := 0;
      wCt := 0;
      spCount := 0;
      WHILE wPos < ct DO
          BEGIN
          StrWord(wStr, chars, wPos, ct);
          IF wStr = '' THEN
              BEGIN
              PutRest;
  WRITELN(''''); { do we hit these?? }
              EXIT(ICAddStrLine);
              END;
          IF wStr = ' ' THEN
              BEGIN
              spCount := spCount+1;
              END
          ELSE
              BEGIN
              PutWord(AddBufWord(wStr));
              END;
          END;
      PutRest;
      END;
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('Leaving ICAddStrLine - IMHeap is trashed STOP. hBytes:', imHeapBytes);
      Brk(3333);
      END;
END;
{$ENDC }


PROCEDURE StopIM(msg: Str255);
BEGIN
  WRITELN(msg);
  fQuit := TRUE;
END;


{$S imih }
PROCEDURE RgInt; { (int, pos: TC; drgch: TRgch); }
VAR irgch: TRgch;
BEGIN
  irgch := @int;
  drgch^[pos] := irgch^[0];
  drgch^[pos+1] := irgch^[1];
END;


{$S imih }
PROCEDURE SysLog; { (logID: TB; logStr: TRgch); }
VAR logRec: ARRAY[0..15] OF TB;
    err, i: TC;
    lptr: TL;
BEGIN
  IF logID < 100 THEN logID := 100;
  IF logID > 125 THEN logID := 125;
  logrec[0] := logID;
  IF logStr <> NIL
   THEN FOR i := 1 TO 15 DO
     IF logStr <> NIL
       THEN logRec[i] := logStr^[i]
       ELSE logRec[i] := 0;
  lptr := ORD4(@logRec);
  Sys_Stat(err, 3, lptr);
  IF sDebug AND (err <> 0) THEN
    BEGIN WRITELN('Sys_Stat error: ', err); Holdit(cDebug); END;
END;


{$S imih }
PROCEDURE SysILog; { (logID: TB; li1, li2: TC); }
VAR logRec: ARRAY[0..15] OF TB;
    i: TC;
BEGIN
  FOR i := 0 TO 15 DO logRec[i] := 0;
  RgInt(li1, 0, @logrec);
  RgInt(li2, 2, @logrec);
  SysLog(logID, @logRec);
END;


{$S imih }
PROCEDURE GetWindStream(imFldr: THFldrInfo; fMake: TF;
                        VAR dWindow: THIMW; VAR dStream: THIMS);
VAR wsLink: THWSLink;
    dObj: ObjectHandle;
BEGIN
  dWindow := NIL;
  dStream := NIL;
  IF imFldr = NIL THEN EXIT(GetWindStream);
  dWindow := imFldr^^.fldrDispWindow;
  IF dWindow = NIL
    THEN BEGIN
      IF fMake THEN BEGIN
        dObj  := POINTER(ORD(imFldr^^.fldrFObj));
        dStream := NewFldrStream(imFldr, CDefKeepCt, IFIsContainer(dObj));
        dWindow := imFldr^^.fldrDispWindow;
       END;
     END
    ELSE BEGIN
      IF dWindow^^.wLink = NIL
       THEN BEGIN
         IF fMake
           THEN BEGIN
             dObj  := POINTER(ORD(imFldr^^.fldrFObj));
             dStream:=NewFldrStream(imFldr,CDefKeepCt,IFIsContainer(dObj));
            END;
        END
       ELSE dStream := dWindow^^.wLink^^.kStream;
     END;
END;


{$S imiw }
PROCEDURE ClearFolder(imFldr: THFldrInfo);
VAR cWind: THIMW;
    cStream: THIMS;
BEGIN
  GetWindStream(imFldr, FALSE, cWind, cStream);
  IF cStream <> NIL
    THEN BEGIN
      IF IMtst THEN WRITELN('Clearing folder: ', imFldr^^.fldrName);
      ClearIMStream(cStream);
      {  DrawFldrContents(imFldr); -- not needed ? }
     END;
END;


{$S imifld }
PROCEDURE GetObjRect(obj: ObjectHandle; VAR oRect: Rect);
VAR loc: Point;
BEGIN
  IF obj^^.isOpen
    THEN WITH obj^^.objWindow^ DO BEGIN
       WITH PortBits.bounds DO
         SetPt(loc, -left, -top);
       WITH PortRect DO
         SetRect(oRect, loc.h, loc.v, loc.h+right-left, loc.v+bottom-top);
      END
    ELSE oRect := obj^^.windowRect;
IF IMtst THEN WITH oRect DO
WRITELN('GetObjRect "', obj^^.name, left, top, right, bottom);
END;


{$S imic }
FUNCTION AttachIMFldr;
  {  (imHObj: ObjectHandle; vis, wind, sbars: TF; cKeep: TC):THFldrInfo; }
VAR imFldr: THFldrInfo;
BEGIN
  imFldr := AddIMFolder(imHObj, vis, wind, sbars, cKeep);
  IF (imFldr <> NIL) AND (NOT IFIsContainer(imHObj))
    THEN BEGIN
      AddFldrMenu(imFldr, FilingMInfo, FALSE);
      AddFldrMenu(imFldr, EditMInfo, FALSE);
      AddFldrMenu(imFldr, TopicsMInfo, FALSE);
     END;
  IF imHObj = activeObject THEN BEGIN
    hndActiveFldr := imFldr;
    IF wind THEN activeWSLink := imFldr^^.fldrDispWindow^^.wLink;
   END;
  AttachIMFldr := imFldr;
END;


{$S imih }
FUNCTION ReadFldrArg(VAR fldrHndl: THFldrInfo; VAR objHnd: ObjectHandle;
                     VAR fName: TKeyStr; fRead, fFirst, fDecode: TF): TF;
VAR fldrCt: TC;
    s255:   Str255;
BEGIN
  IF fRead THEN
    BEGIN
    IF NOT ArgStr(@fname, CKeySize, FALSE)
      THEN BEGIN
        CmdError('Cant read Folder/Object Name.');
        fName := '';
        ReadFldrArg := FALSE;
        EXIT(ReadFldrArg);
       END;
    fFirst := FALSE;
    IF fDecode THEN DecodeStr(@fName, CKeySize);
    IF PeekUCScriptChar = '('
      THEN IF NOT ArgInt(fldrCt, FALSE)
        THEN BEGIN
          CmdError('Cant read Folder/Object folderCount');
          ReadFldrArg := FALSE;
          EXIT(ReadFldrArg);
         END
        ELSE IF fldrCt = 1 THEN fFirst := TRUE;
   END;
  IF fName = NameLisaGuide
    THEN BEGIN
      fldrHndl := hndLGFldr;
      objHnd := LGobj;
{$IFC IMCompile }
      IF fICompile THEN
          BEGIN
          WRITELN(icFile, 'SetLGFldr;');
          END;
{$ENDC }
      IF objHnd = NIL
        THEN BEGIN
          InterpError('Cant find LisaGuide object!!!');
          ReadFldrArg := FALSE;
         END
        ELSE ReadFldrArg := TRUE;
      EXIT(ReadFldrArg);
     END;
  objHnd := GetNameObj(fName, fFirst);
  fldrHndl := objHnd^^.imFldr;
{$IFC IMCompile }
  IF fICompile THEN
      BEGIN
      IF fFirst THEN WRITELN(icFile, 'cFirstObj := TRUE;');
      s255 := fName;
      WRITELN(icFile, 'CGetNameObj(', AddBufWord(s255):1, ');');
      ENd;
{$ENDC }
  IF objHnd = nilObject
    THEN BEGIN
      ReadFldrArg := FALSE;
      EXIT(ReadFldrArg);
     END;
  ReadFldrArg := TRUE;
END;


{$S imiini }
PROCEDURE IMIntrpInit;
VAR i: TC;
    codeStr: Str255;
    cchr: CHAR;
BEGIN
 fShowWords := FALSE;
  btnSound := noSound;
  IF cDebug THEN WRITELN('address of decode array: ', ORD(@decode));
  for i := 0 TO 255 DO decode[i] := 0;
  codeStr :=
'!"#$%&*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\^_`abcdefghijklmnopqrstuvwxyz|~ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤';
  IF cDebug THEN WRITELN('Length of decode string: ', LENGTH(codeStr));
  for i := 1 TO 128 DO
      BEGIN
      cchr := codeStr[i];
      decode[ORD(cchr)] := i-1;
      END;
  {$IFC IMDebug }
  fEncoding := FALSE;
  dcCodeStr := codeStr;
  {$ENDC }


  hODefTable := CreateSrchTable(SIZEOF(TObjDefRec), 15, 3);

  fSim := FALSE;
  fSimHold := FALSE;
  fSimRunning := FALSE;
  fSimEdit := FALSE;
  fSimWtPB := FALSE;
  fSimWtRec := FALSE;
  simName := '';

END;


{$S imiw }
PROCEDURE PopBlock(bName: TLocStr);
VAR freeBlock: THBlockRec;
BEGIN
  IF TopBlock <> NIL
    THEN WITH TopBlock^^ DO
      BEGIN
        IF bName = blkName THEN
          BEGIN
            fTest := TopBlock^^.blkFTest;
            IF IMtst THEN WRITELN('Popping block: ', blkName,
                                  ' and setting fTest to: ', blkFTest);
            freeBlock := TopBlock;
            TopBlock := blkNext;
            FreeBk(IMHeap, POINTER(ORD(freeBlock)), tybkStd);
          END
        ELSE
          BEGIN
            IF IMtst THEN WRITELN('Trying to pop block: ', bName,
                      ' top block is: ', blkName);
            PopAllBlocks;
          END;
      END;
END;


{$S imiw }
PROCEDURE PushBlock(bName: TLocStr);
VAR newBlock: THBlockRec;
BEGIN
  newBlock := POINTER(ORD(HAllocate(IMHeap, SIZEOF(TBlockRec))));
  newBlock^^.blkNext := TopBlock;
  newBlock^^.blkName := bName;
  newBlock^^.blkFTest := fTest;
  TopBlock := newBlock;
END;


{$S imiw }
PROCEDURE JumpABlock(bType: CHAR; tName: TLocStr);
VAR plocRec: TPLocRec;
    fOK: TF;
    blockN: TC;
BEGIN
  pLocRec := LookupLoc(bType, tName);
  IF pLocRec = NIL
    THEN BEGIN
       IF cDebug THEN WRITELN('JumpABlock to name: ', bType, ' - ',
                               tName,' cant find locRec');
       IF fICompile THEN CmdError('Incomplete LocMap - no end pos. No locrec for this block');
     END
    ELSE IF pLocRec^.vEndPos = 0
      THEN BEGIN
        IF cDebug THEN WRITELN('JumpABlock to name: ', bType, ' - ',
                                tName,' no end pos in locrec for this block');
        IF fICompile THEN
            CmdError('Incomplete LocMap - no end pos. Cant jump block');
       END
    ELSE BEGIN
      IF cDebug THEN WRITELN('JumpABlock to name: ', bType, ' - ',
                             tName, ' PosRec: ', ORD(pLocRec));
      IF fICompile THEN fOK := TRUE  { dont really jump here }
      ELSE
        fOK := IMFSetPos(PIMFS, plocRec^.vEndPos);
      IF NOT fOK THEN CmdError('JumpABlock - Cant get to saved position in file')
        ELSE BEGIN
          IF cDebug THEN
            WRITELN('Jumping to end of block: ', tName, ' of type: ', bType);
          CommandDone;
          NewScriptLine;
          IF cDebug THEN IF PeekUCScriptChar <> 'E'
             THEN WRITELN('JumpABlock did not jump to an EndCommand');
         END;
    END;
END;


{$S imiw }
PROCEDURE SkipABlock(bType: CHAR; tName: TLocStr);
BEGIN
  ClearSkips;
  skipType := bType;
  skipEndType := GetLimitType(bType);
  skipToEnd := TRUE;
  skipName := tName;
  fSkip := TRUE;
  IF IMtst THEN WRITELN('Setting up skip to end ', bType, ' named: ', tName);
  JumpABlock(bType, tName);
END;


{$S imic }
PROCEDURE AssignCommand;
VAR pvarRec: TPVarRec;
    varName: TKeyStr;
    varSource, cchr: CHAR;
    chrCt: TC;
    aflag: TF;
BEGIN
  varSource := ReadUCScriptChar;
  pvarRec := GetVarRec(varSource);
  IF pvarRec = NIL THEN CmdError('Cant find variable in Assign var')
    ELSE BEGIN
      CASE pvarRec^.vType OF
        TVchar: BEGIN
                aFlag := ArgChar(pvarRec^.vChar);
{$IFC IMCompile }
                IF fICompile THEN
                    WRITELN(icfile, 'CAssignChar(''', pvarRec^.vKey, ''',''', varSource, ''');');
{$ENDC }
                END;
        TVint: BEGIN aFlag := ArgInt(pvarRec^.vInt, TRUE);
               IF IMtst THEN WRITELN('Assigned integer value:', pvarRec^.vInt);
{$IFC IMCompile }
               IF fICompile THEN
                    WRITELN(icfile, 'CAssignInt(''', pvarRec^.vKey, ''',''', varSource, ''');');
{$ENDC }
               END;
        TVstr: BEGIN
                cchr := PeekUCScriptChar;
                IF cchr = 'K' THEN
                   BEGIN
                   chrCt := KbdStr(pvarRec^.vHStr^, 255);
                   aflag := TRUE;
                   cchr := ReadUCScriptChar;
                   END
                ELSE aFlag := ArgStr(pvarRec^.vHStr^, 255, TRUE);
{$IFC IMCompile }
                IF fICompile THEN
                    WRITELN(icfile, 'CAssignStr(''', pvarRec^.vKey, ''',''', varSource, ''');');
{$ENDC }
                END;
        TVbool: BEGIN
                aFlag := ArgBool(pvarRec^.vBool);
                IF IMtst THEN WRITELN('Assigned Boolean value:', pVarRec^.vBool);
{$IFC IMCompile }
                IF fICompile THEN
                    WRITELN(icfile, 'CAssignBool(''', pvarRec^.vKey, ''',''', varSource, ''');');
{$ENDC }
                END;
      END;
     IF NOT aFlag THEN CmdError('Assign command unsuccessful.');
     IF IMtst THEN BEGIN WRITE(pvarRec^.vKey, ' set to ');
                         PrintVData(pvarRec);
                         END;
    END;
END;


{$S imiw }
PROCEDURE BeginCommand;
CONST
  iFPrvExz = 9;       { also in BeginCommand in IMInterp }
  iFLstExz = 10;      { also in BeginCommand in IMInterp }
VAR blkType: CHAR;
    blkName: TLocStr;
    blkAd: TFPos;
    nameFlag: TF;
BEGIN
  blkAd := IMFLinePos(PIMFS, (ScriptPos - 1));
  blkType := ReadUCScriptChar;
  CASE blkType OF
    'L', '¬': BEGIN IF IMtst THEN WRITE('Beginning Lesson.'); InLesson := TRUE; END;
    'E', '∑': BEGIN IF IMtst THEN WRITE('Beginning Exercise'); InExercise := TRUE; END;
    'B', '∫': BEGIN IF IMtst THEN WRITE('Beginning block'); END;
    OTHERWISE BEGIN WRITELN('Begin block type = ', blkType);
                    CmdError('Invalid Begin Block Type');
                    EXIT(BeginCommand);
                  END;
   END;
  nameFlag := ArgStr(@blkName, CLocSize, FALSE);
  IF nameFlag THEN
     CASE blkType OF
      'L': curLesson := blkName;
      'E': curExercise := blkName;
      'B': curBlock := blkName;
      '¬': BEGIN DecodeStr(@blkName, CLocSize); curLesson := blkName; blkType := 'L'; END;
      '∑': BEGIN DecodeStr(@blkName, CLocSize); curExercise := blkName; blkType := 'E'; END;
      '∫': BEGIN DecodeStr(@blkName, CLocSize); curBlock := blkName; blkType := 'B'; END;
      END
    ELSE blkName := 'unnamed';
  IF IMtst THEN WRITELN(' named ', blkName);
  IF nameFlag
    THEN SetStartLoc(blkType, blkName, blkAd)
    ELSE CmdError('Invalid name for lesson.');
  IF (blkType = 'B') THEN PushBlock(blkName);

{$IFC IMCompile }
  IF fICompile THEN ICBeginCommand(blkType, blkName);
{$ENDC }

  IF fSkip THEN IF (NOT skipToEnd) THEN
    IF skipType = blkType
      THEN IF skipNext OR (skipName = blkName) THEN StopSkip;
  IF fSkip THEN
    IF (skipType = 'L') OR (blkType = 'B') OR (skipType = blkType)
      THEN JumpABlock(blkType, blkName);
  IF (NOT fSkip) AND (blkType = 'E')
    THEN BEGIN
      PrevExzPos := LastExzPos;
      LastExzPos := blkAd;
      IF PrevExzPos <> 0 THEN SetAbleItem(FCtrlMInfo, iFPrvExz, TRUE);
      SetAbleItem(FCtrlMInfo, iFLstExz, TRUE);
     END;
END;


{$S imiw }
PROCEDURE ClearCommand;
VAR cchr: CHAR;
    clrName: TKeyStr;
    clrObj: ObjectHandle;
    clrFldr: THFldrInfo;
    clrWindow: THIMW;
    clrStream: THIMS;
    clrFirst: TF;

  PROCEDURE ClrGetName(VAR sName: TKeyStr; VAR fFlag: TF);
  VAR fCt: TC;
  BEGIN
     IF PeekUCScriptChar <> '('
       THEN BEGIN
         clrName := LGobj^^.name;
         clrFirst := FALSE;
         EXIT(ClrGetName);
       END;
    IF NOT ArgStr(@sName, CKeySize, FALSE)
      THEN BEGIN
        CmdError('Clear Command Cant read name');
        FinishCommand;
        EXIT(ClearCommand);
       END;
    fFlag := FALSE;
    IF PeekUCScriptChar = '('
      THEN IF NOT ArgInt(fCt, FALSE)
        THEN BEGIN
          CmdError('Clear Command Cant read first int');
          FinishCommand;
          EXIT(ClearCommand);
         END
        ELSE IF fCt = 1 THEN fFlag := TRUE;
  END;

BEGIN
  cchr := ReadUCScriptChar;
  IF IMScrTst THEN WRITELN('clear command char:', cchr, ORD(cchr));
  CASE cchr OF
    '.'    : CommandDone;
    'B': BEGIN
           IF IMtst THEN WRITELN('Clearing fButton');
{$IFC IMCompile }
           IF fICompile THEN
               WRITELN(icfile, 'fButton := FALSE;  { clear fButton }');
{$ENDC }
           fButton := FALSE;
         END;
    'F': BEGIN IF IMtst THEN WRITELN('Clearing Folder');
           ClrGetName(clrName, clrFirst);
           IF NOT ReadFldrArg(clrFldr, clrObj, clrName, FALSE, clrFirst, FALSE) THEN;
{$IFC IMCompile }
           IF fICompile THEN
               WRITELN(icfile, 'CClearFolder;');
{$ENDC }
           ClearFolder(clrFldr);
         END;
    'H': BEGIN
         IF IMtst THEN WRITELN('Clearing Hints');
         HintCount := 0; LastHint := 0;
         DimHint;
{$IFC IMCompile }
         IF fICompile THEN
             BEGIN
             WRITELN(icfile, 'HintCount := 0; { clear hints }');
             WRITELN(icfile, 'LastHint := 0;');
             WRITELN(icfile, 'DimHint;');
             END;
{$ENDC }
         END;
    'O': BEGIN IF IMtst THEN WRITELN('Clearing Scroll Offsets');
           ClrGetName(clrName, clrFirst);
           IF ReadFldrArg(clrFldr, clrObj, clrName, FALSE, clrFirst, FALSE)
             THEN BEGIN
               GetWindStream(clrFldr, FALSE, clrWindow, clrStream);
               IF clrwindow <> NIL
                 THEN BEGIN
                   SetVThumbPos(clrWindow^^.wLink, 0);
                   SetHThumbPos(clrWindow^^.wLink, 0);
                   DrawDWindow(clrWindow^^.wLink);
{$IFC IMCompile }  IF fICompile THEN WRITELN(icfile, 'CClearOffsets;');   {$ENDC }
                  END;
              END;
         END;
    OTHERWISE BEGIN CmdError('Invalid clear command modifier.'); FinishCommand; END;
  END;
END;


{$S imidsp }
FUNCTION TxtSize(tptr: QDPtr; spos, len: TC; ptStr: THIMS):TC;
VAR twid: TC;
    chrFont: TC;
BEGIN
  chrFont := FontFam(ptStr^^.sLineData.dLFIdx);
  twid := TxtWidth(POINTER(ORD(tptr) + spos), len, chrFont);
  TxtSize := twid;
END;


{$S imidsp }
FUNCTION StrSize(wstr: Str255; ptStr: THIMS):TC;
VAR swid: TC;
BEGIN
  swid := TxtStrWid(wstr, FontFam(ptStr^^.sLineData.dLFIdx));
  StrSize := swid;
END;


{$S imidsp }
PROCEDURE DisplayCommand(dispObj: ObjectHandle);
CONST dbMax = 255;
      dispRMrgn = 15;
TYPE DispType = (dtext, dgraf, danimate, cdtext);
VAR cchr: CHAR;
    formatFlag, boxStarted: BOOLEAN;
    doDraw: BOOLEAN;
    dtype: DispType;
    dStream: THIMS;
    dFldr: THFldrInfo;
    fName: TKeyStr;
    dObjHnd: ObjectHandle;
    dbuf: ARRAY[0..dbMax] OF TB;
    wLen, dbpos: TC;
    wWid, bufWid, spWid: TC;
    widthPixels, XPos: TC;
    fCr,argDone: TF;
    saveErase, changeErase, fShowEnd: TF;


  PROCEDURE AddStrLine(chars: TRgch; ct: TC);
  VAR saveIndent: TC;
  BEGIN
    PullAlert;
    IF XPos >= 0
      THEN BEGIN
        saveIndent := dStream^^.sLineData.dLIndent;
        dStream^^.sLineData.dLIndent := XPos;
       END;
    {$IFC IMCompile }
    IF fICompile THEN ICAddStrLine(chars, ct, fShowEnd, XPos);
    {$ENDC }
    lastLGLine := AddNewTextLine(dStream, chars, ct, fShowEnd);
    doDraw := TRUE;
    IF XPos >= 0
      THEN BEGIN
         dStream^^.sLineData.dLIndent := saveIndent;
         XPos := -1;
       END;
  END;

  PROCEDURE DumpLine;
  BEGIN
    AddStrLine(@dbuf, dbpos);
    dbpos := 0;
    bufWid := 0;
  END;

  PROCEDURE DumpPartLine;
  BEGIN
    IF dbpos > 0 THEN DumpLine;
  END;

  PROCEDURE StartBox;
  VAR fOK: TF;
      bxName: TStr20;
      pch: CHAR;
      fExchange: TF;
  BEGIN
    DumpPartLine;
    IF boxStarted THEN EndTextBox(dStream);
    fExchange := FALSE;
    pch := PeekUCScriptChar;
    IF pch = 'X'
      THEN BEGIN
        pch := ReadScriptChar;
        fExchange := TRUE;
       END;
    fOK := ArgStr(@bxName, 20, FALSE);
    IF fOK THEN
      BEGIN
        IF IMtst THEN
           WRITELN('Starting text box ', bxName, ' fExchange ', fExchange);
        StartTextBox(dStream, bxName, fExchange);
        IF IMtst THEN WRITELN('Text box: ', bxName, ' started.');
        boxStarted := TRUE;
{$IFC IMCompile }
        IF fICompile THEN
            BEGIN
            WRITELN(icFile, 'CStartTextBox;');
            END;
{$ENDC }
       END
     ELSE IF IMtst THEN CmdError('Cant read text box name.');
  END;


  PROCEDURE DispFont;
  VAR fIdx: TC;
      fontKey: TKeyStr;
      dch: CHAR;
      fOK: TF;
  BEGIN
    DumpPartLine;
    dch := PeekUCScriptChar;
    fOK := TRUE;
    IF dch = 'N'
      THEN BEGIN
        fontKey := 'TutorFont';
        dch := ReadScriptChar;
       END
      ELSE IF NOT ArgStr(@fontKey, CKeySize, FALSE)
        THEN BEGIN
          CmdError('Cant read font name.');
          FinishCommand;
          EXIT(DispFont);
         END;
    fIdx := FIdxFromName(fontKey);
    IF fIdx > 0
      THEN BEGIN  { changed to use dStream instead of LGStr? }
        dStream^^.sLineData.dLFIdx := fIdx;
{$IFC IMCompile }
        IF fICompile THEN
            WRITELN(icFile, 'CSetDspFont(', fIdx:1, ');');
{$ENDC }
        IF IMtst THEN WRITELN('Font changed to: ', fontKey, ' (', fIdx:1, ')');
       END
      ELSE CmdError('Cant find font. font not changed.');
  END;


  PROCEDURE DispWid;
  VAR dWidth: TC;
      dch: CHAR;
      fOK: TF;
  BEGIN
    dch := PeekUCScriptChar;
    fOK := TRUE;
    IF dch = 'N'
      THEN BEGIN
        WITH dFldr^^.fldrDispWindow^^.wDispRect DO
          dWidth := right - left;  { says use the current folder width. }
        dch := ReadScriptChar;
       END
      ELSE IF NOT ArgInt(dWidth, FALSE)
        THEN BEGIN
          CmdError('Cant read display line width.');
          FinishCommand;
          EXIT(DispWid);
         END;
    IF IMtst THEN WRITELN('Setting line width to ', dWidth);
    widthPixels := dWidth;
    dStream^^.sLineData.dLWidth := dWidth;
{$IFC IMCompile }
    IF fICompile THEN
        WRITELN(icFile, 'CSetDspWid(', dWidth:1, ');');
{$ENDC }
  END;


  PROCEDURE DispHt;
  VAR dHeight: TC;
      dch: CHAR;
      fOK: TF;
  BEGIN
    DumpPartLine;
    dch := PeekUCScriptChar;
    fOK := TRUE;
    IF dch = 'N'
      THEN BEGIN
        dHeight := -1;  { says use the currnet font height. }
        dch := ReadScriptChar;
       END
      ELSE IF NOT ArgInt(dHeight, FALSE)
        THEN BEGIN
          CmdError('Cant read display line height.');
          FinishCommand;
          EXIT(DispHt);
         END;
    IF IMtst THEN WRITELN('Setting line height to ', dHeight);
    dStream^^.sLineData.dLVDsp := dHeight;
{$IFC IMCompile }
    IF fICompile THEN
        WRITELN(icFile, 'CSetDspHeight(', dHeight:1, ');');
{$ENDC }
  END;


  PROCEDURE DispIndent;
  VAR dIndent: TC;
      dch: CHAR;
      fOK: TF;
  BEGIN
    DumpPartLine;
    dch := PeekUCScriptChar;
    fOK := TRUE;
    IF dch = 'N'
      THEN BEGIN
        dIndent := 0;  { says use the default (0) indentation. }
        dch := ReadScriptChar;
       END
      ELSE IF NOT ArgInt(dIndent, FALSE)
        THEN BEGIN
          CmdError('Cant read display line indent.');
          FinishCommand;
          EXIT(DispIndent);
         END;
    IF IMtst THEN WRITELN('Setting line height to ', dIndent);
    dStream^^.sLineData.dLIndent := dIndent;
{$IFC IMCompile }
    IF fICompile THEN
        WRITELN(icFile, 'CSetDspIndent(', dIndent:1, ');');
{$ENDC }
  END;


  PROCEDURE PosBox;
  VAR fOK: TF;
      bxYPos: TC;
      bxPos: Point;
  BEGIN
    DumpPartLine;
    IF boxStarted THEN EndTextBox(dStream);
{$IFC IMCompile }
    IF fICompile THEN icNameIntArg := 'dpbYPos';
{$ENDC }
    fOK := ArgInt(bxYPos, TRUE);
    IF fOK THEN
      BEGIN
        SetPt(bxPos, 0, bxYPos);
        StartPosBox(dStream, '', bxPos);
        IF IMtst THEN WRITELN('Pos box started at:', bxPos.h:5, bxPos.v:5);
        boxStarted := TRUE;
{$IFC IMCompile }
        IF fICompile THEN
            BEGIN
            WRITELN(icFile, 'CPosBox;');
            END;
{$ENDC }
       END
     ELSE IF IMtst THEN CmdError('Cant read X value.');
  END;


  PROCEDURE DispBtn;
  VAR fOK: TF;
      btnName: TStr20;
      pch: CHAR;
      bidx, hpos: TC;
      saveIndent: TC;
  BEGIN
    DumpPartLine;
    fOK := ArgStr(@btnName, 20, FALSE);
    IF NOT fOK
      THEN BEGIN
        CmdError('Cant read button name.');
      END;
    bidx := BtnIdxFromName(btnName);
    IF bidx = 0 THEN BEGIN
      CmdError('There is no button with this name');
      EXIT(DispBtn);
     END;
    hpos := dStream^^.sLineData.dLIndent;
    IF XPos >= 0
      THEN BEGIN
        hpos := XPos;
        XPos := 0;
       END;
    IF IMtst THEN
      WRITELN('New button line for button: ', btnName,
              '(', bidx:2, ') hpos:', hpos:5);
    AddBtnLine(dStream, bidx, hpos, fShowEnd);
    doDraw := TRUE;
{$IFC IMCompile }
    IF fICompile THEN
        BEGIN
        WRITELN(icFile, 'CAddBtnLine(', bidx:1, ', ', hpos:1, ', ',fShowEnd, ');');
        END;
{$ENDC }
  END;

  PROCEDURE DispArgLine;
  LABEL 100;
  VAR scanPos, scanStart, scanLim, argLen: INTEGER;
      argBuf, scanBuf: TRgChar;
  BEGIN
    argBuf := POINTER(ORD(ScriptPtr) + scanStart);
    argLen := 0;
  100:
    scanStart := scriptPos;
    scanBuf := POINTER(ORD(ScriptPtr) + scanStart);
    argBuf := scanBuf;
    scanStart := scriptPos;
    scanLim := ScriptLineLen - scanStart;
    IF IMScrTst THEN WRITELN('dataBuf:',  ORD(ScriptPtr), '  scanStart:',
         scanStart:4, '  scanBuf:', ORD(scanBuf), 'scanLim:', scanLim:4);
    scanPos := ScanEq(scanLim, ArgEndChar, scanBuf^);
    ScriptPos := scanStart + scanPos;
    IF scanPos < scanLim
      THEN
        BEGIN
          IF ReadScriptChar = ArgEndChar
            THEN BEGIN
               IF NOT EndArg THEN
                 BEGIN
                   argLen := argLen + scanPos + 1;
                   GOTO 100;
                 END;
              END
            ELSE BEGIN
               WRITELN('Strange error in DispArgLine');
               FinishCommand;
              END;
        END;
    AddStrLine(POINTER(ORD(argBuf)), scanPos + argLen);
  END;


  PROCEDURE DispFormatText;
  VAR cchr: CHAR;
      skipSpaces: TC;
  BEGIN
    DumpPartLine;
    skipSpaces := ScriptPos;
    DispArgLine;
    WHILE InArg DO
      BEGIN
        NewScriptLine;
        WHILE (ScriptPos < ScriptLineLen) AND (ScriptPos < skipSpaces)
               AND (ScriptPtr^[ScriptPos] = ORD(' '))
          DO ScriptPos := ScriptPos + 1;
        DispArgLine;
      END;
  END;


  PROCEDURE AddSp;
  BEGIN
    dbuf[dbpos] := chSp;
    dbpos := dbpos + 1;
    bufWid := bufWid + spWid;
  END;

  PROCEDURE AddWord(lWid: TC);
  VAR svDbpos: TC;
  BEGIN
    fCr := FALSE;
    wWid := TxtSize(@dbuf, dbpos, wLen, dStream);
    IF (bufWid + wWid) > lWid
      THEN BEGIN
         svDbpos := dbpos;
         DumpLine;  { sets dbpos to 0 }
         MoveOvRgch(@dbuf, POINTER(ORD(@dbuf)+svDbpos), wLen);
        END;
    bufWid := bufWid + wWid;
    dbpos := dbpos + wlen;
    AddSp;
  END;

  PROCEDURE DispText(lWid: TC);
  BEGIN
    spWid := StrSize(' ', dStream);
    argDone := FALSE;
    fCr := TRUE;
    REPEAT
      ScriptWord(POINTER(ORD(@dbuf)+dbpos),dbMax-dbpos,wLen,FALSE);
      IF wLen = 1 THEN
        BEGIN
          IF dbuf[dbpos] = 13 THEN
             BEGIN
               IF fCr THEN DumpPartLine;
               IF fCr THEN DumpLine;
               fCr := TRUE;
               NewScriptLine;
             END
            ELSE BEGIN
                 IF IMScrTst
                   THEN WRITELN('Checking arg end: ArgEndChar: ',
                                ORD(ArgEndChar), '  buf: ', dbuf[dbpos]);
                 IF (dbuf[dbpos] = ORD(ArgEndChar)) AND EndArg
                   THEN BEGIN argDone := TRUE; END
                   ELSE AddWord(lWid);
                 END;
        END
       ELSE AddWord(lWid);
    UNTIL argDone;
  END;


  PROCEDURE DispCText(lWid: TC);
  VAR cchr: CHAR;
      wPos, cLen: TC;
      wp: TWordPtr;
      fSameWord: BOOLEAN;
  BEGIN
    spWid := StrSize(' ', dStream);
    argDone := FALSE;
    fCr := TRUE;
    wLen := 0;
    fSameWord := TRUE;
    REPEAT
        IF scriptPos = ScriptLineLen THEN
            BEGIN
            IF fCr THEN DumpPartLine;
            IF fCr THEN DumpLine;
            fCr := TRUE;
            NewScriptLine;
            IF wLen > 0 THEN AddWord(lWid);
            wLen := 0;
            END
        ELSE
            BEGIN
            cchr := ReadScriptChar;
            IF cchr = ArgEndChar THEN argDone := EndArg;
            IF argDone THEN BEGIN END
            ELSE IF (cchr = '0') THEN BEGIN fSameWord := TRUE; END
            ELSE IF ((ORD(cchr) >= ORD('0')) AND (ORD(cchr) <= ORD('9'))) THEN BEGIN END
            ELSE
                BEGIN
                IF NOT fSameWord THEN
                    IF wLen > 0 THEN
                        BEGIN
                        AddWord(lWid);
                        wLen := 0;
                        END;
                fSameWord := FALSE;
                wPos := decode[ORD(cchr)]*128;     { hi half of word offset code }
                cchr := ReadScriptChar;
                wPos := wPos + decode[ORD(cchr)];  { lo half of word offset code }
                wp := POINTER(ORD(wordBuf^)+wPos);
                cLen := LENGTH(wp^);
                MoveRgch(POINTER(ORD(@dBuf)+dbPos+wLen), POINTER(ORD(wp)+1),cLen);
                wLen := wLen + cLen;
                END;
            END;
    UNTIL argDone;
    IF wLen > 0 THEN AddWord(lWid);
  END;


  PROCEDURE DispCFText;
  VAR cchr: CHAR;
      wPos, i: TC;
      wp: TWordPtr;
      fDoneSpaces: BOOLEAN;
  BEGIN
    DumpPartLine;
    spWid := StrSize(' ', dStream);
    argDone := FALSE;
    fDoneSpaces := TRUE;
    REPEAT
        IF scriptPos = ScriptLineLen THEN
            BEGIN
            DumpLine;
            NewScriptLine;
            END
        ELSE
            BEGIN
            cchr := ReadScriptChar;
            IF cchr = ArgEndChar THEN argDone := EndArg;
            IF argDone THEN BEGIN END
            ELSE IF ((ORD(cchr) >= ORD('0')) AND (ORD(cchr) <= ORD('9'))) THEN
                BEGIN
                fDoneSpaces := TRUE;
                FOR i := 1 TO ORD(cchr)-ORD('0') DO AddSp;
                END
            ELSE
                BEGIN
                IF NOT fDoneSpaces THEN AddSp;
                fDoneSpaces := FALSE;
                wPos := decode[ORD(cchr)]*128;     { hi half of word offset code }
                cchr := ReadScriptChar;
                wPos := wPos + decode[ORD(cchr)];  { lo half of word offset code }
                wp := POINTER(ORD(wordBuf^)+wPos);
                wLen := LENGTH(wp^);
                MoveRgch(POINTER(ORD(@dBuf)+dbPos), POINTER(ORD(wp)+1),wLen);
                dbPos := dbPos + wLen;
                END;
            END;
    UNTIL argDone;
    DumpLine;
  END;


  PROCEDURE DispVar(varSource: CHAR; lWid: TC);
  { for compiled version this needs to be fixed so that it just puts the var to
  { be displayed in the buffer rater than reproceessing the string.  Then we
  { need a mechanism that will put it in the display line  -- not easy, but
  { probably unnecessary for the current LisaGuide  (9/83)  }
  VAR cchr: CHAR;
      st1: TStr1;
      st5: TStr5;
      st20: TStr20;
      istr: Str255;
      varName: TKeyStr;
      pvarRec: TPVarRec;
  BEGIN
    pvarRec := GetVarRec(varSource);
    IF pvarRec = NIL THEN CmdError('Cant find variable')
      ELSE BEGIN
        CASE pvarRec^.vType OF
          TVStr: BEGIN
                  istr := CONCAT('T(', pvarRec^.vHStr^^, ') ');
                  InsertScrLine(@istr, TRUE, TRUE);
                END;
          TVInt: BEGIN
                  IntStr20(pvarRec^.vInt, st20);
                  IF IMtst THEN WRITELN('Displaying int variable:', pVarRec^.vKey,
                                        ' ', pVarRec^.vInt, ' string:', st20);
                  istr := CONCAT('T(', st20, ') ');
                  InsertScrLine(@istr, FALSE, TRUE);
                END;
          TVChar: BEGIN
                  CharStr1(pvarRec^.vChar, st1);
                  istr := CONCAT('T(', st1, ') ');
                  InsertScrLine(@istr, TRUE, TRUE);
                 END;
          TVBool: BEGIN
                  BoolStr5(pvarRec^.vBool, st5);
                  istr := CONCAT('T(', st5, ') ');
                  InsertScrLine(@istr, FALSE, TRUE);
                 END;
        END;
       END;
  END;


  PROCEDURE SkipLines;
  VAR nlines, i: TC;
  BEGIN
    DumpPartLine;
    IF NOT ArgInt(nlines, FALSE)
      THEN BEGIN
        CmdError('Cant read number of lines to skip in SkipLines.');
        FinishCommand;
        EXIT(SkipLines);
       END;
    IF (nlines < 0) OR (nlines > 50)
      THEN BEGIN
        CmdError('Invalid number of lines specified in SkipLines');
        FinishCommand;
        EXIT(SkipLines);
       END;
    FOR i := 1 to nlines DO DumpLine;
  END;


  PROCEDURE RedrwDFldr;
  BEGIN
    IF doDraw THEN DrawFldrContents(dFldr);
    doDraw := FALSE;
  END;


  PROCEDURE DontErase;
  BEGIN
    IF IMtst THEN WRITELN
      ('Setting sDontErase for display stream for this command');
    saveErase := dStream^^.sDontErase;
    changeErase := TRUE;
    dStream^^.sDontErase := TRUE;
{$IFC IMCompile } IF fICompile THEN WRITELN(icFile, 'CDontErase;'); {$ENDC }
  END;


  PROCEDURE ResetErase;
  BEGIN
    IF changeErase
      THEN BEGIN
        IF IMtst THEN WRITELN
          ('ReSetting sDontErase for display stream to:', saveErase);
        dStream^^.sDontErase := saveErase;
        saveErase := FALSE;
        changeErase := FALSE;
{$IFC IMCompile }
        IF fICompile THEN WRITELN(icFile, 'CResetErase;');
{$ENDC }
       END;
  END;


  PROCEDURE WindowName(newDObj: ObjectHandle);
  VAR dWindow: THIMW;
  BEGIN
    IF dFldr <> NIL THEN RedrwDFldr;
    ResetErase;
    IF newDObj <> NIL
      THEN BEGIN
        dObjHnd := newDObj;
        fName := dObjHnd^^.name;
        dFldr := dObjHnd^^.imFldr;
       END
      ELSE IF NOT ReadFldrArg(dFldr, dObjHnd, fName, TRUE, FALSE, FALSE)
        THEN BEGIN
          IF fName <> '' THEN CmdError('Cant find display filer object');
          FinishCommand;
          EXIT(WindowName);
         END;
    IF dFldr = NIL
     THEN dFldr := AttachIMFolder(dObjHnd, FALSE, TRUE, TRUE, CDefKeepCt);
    GetWindStream(dFldr, TRUE, dWindow, dStream);
    IF cDebug THEN
      IF dStream = NIL
        THEN BEGIN
          WRITELN('Nil displayStream in DisplyCommand - WindowName');
          FinishCommand;
         END;
    widthPixels := dStream^^.sLineData.dLWidth;
    IF IMtst THEN
      WRITELN('Display command stream set for folder:', fName,
              ' stream:', ORD(dStream));
  END;

  PROCEDURE DispXPos;
  BEGIN
{$IFC IMCompile }
    IF fICompile THEN icNameIntArg := 'dXPos';
{$ENDC }
    IF ArgInt(XPos, TRUE)
     THEN BEGIN
       IF IMtst THEN WRITELN('Display XPos set to:', XPos:1);
      END
     ELSE BEGIN
       CmdError('Cant read XPos value');
       FinishCommand;
      END;
  END;


  PROCEDURE DispNormal;
  BEGIN
    IF IMtst THEN WRITELN
      ('Resetting stream line defaults to normal font, height and indent');
    ResetLineData(dStream, -1);
{$IFC IMCompile }
    IF fICompile THEN WRITELN(icFile, 'CResetLineData;');
{$ENDC }
  END;


BEGIN {DisplayCommand }
{$IFC IMCompile }
  IF fICompile THEN WRITELN(icFile, 'CStartDisplay;');
{$ENDC }
  dFldr := NIL;
  changeErase := FALSE;
  saveErase := FALSE;
  IF dispObj = NIL THEN dispObj := LGobj;
  WindowName(dispObj);
  dtype := dtext;
  formatFlag := FALSE;
  boxStarted := FALSE;
  fShowEnd := TRUE;
  doDraw := FALSE;
  dbPos := 0;
  bufWid := 0;
  XPos := -1;
  widthPixels := dStream^^.sLineData.dLWidth;
  REPEAT
    cchr := ReadUCScriptChar;
    IF IMScrTst THEN WRITELN('display command char:', cchr, ORD(cchr));
    CASE cchr OF
      ' ': BEGIN END;
      '.': BEGIN DumpPartLine; CommandDone; END;
      'A': WindowName(NIL);
      'B': StartBox;
      'C': DispFont;
      'F': formatFlag := TRUE;
      'H': DispHt;
      'I': DispIndent;
      'K': DontErase;
      'L': SkipLines;
      'N': DispNormal;
      'O': fShowEnd := FALSE;
      'P': DispBtn;
      'T': dtype := dtext;
      '†': dtype := cdtext;
      'U': DispVar('U', widthPixels - dispRMrgn);
      'V': DispVar('V', widthPixels - dispRMrgn);
      'X': DispXPos;
      'W': DispWid;
      'Y': PosBox;
      '(': BEGIN
             StartArg;
             CASE dtype OF
               dtext: IF formatFlag THEN DispFormatText
                        ELSE DispText(widthPixels - dispRMrgn);
               cdtext: IF formatFlag THEN DispCFText
                        ELSE DispCText(widthPixels - dispRMrgn);
             END;
             formatFlag := FALSE;
           END;
      OTHERWISE
          BEGIN CmdError('Invalid display command modifier.');
            FinishCommand;
          END;
    END;
    IF InArg THEN FinishArg;
  UNTIL NOT InCommand;
  IF boxStarted THEN EndTextBox(dStream);
  ReDrwDFldr;
  ResetErase;
{$IFC IMCompile }
  IF fICompile THEN WRITELN(icFile, 'CEndDisplay;');
{$ENDC }
END;


{$S imiw }
PROCEDURE EndCommand;
VAR blkType,cchr: CHAR;
    blkName: TLocStr;
    nameFlag: TF;
    ePos: TFPos;
BEGIN
  ePos := IMFLinePos(PIMFS, (ScriptPos-1));
  blkType := ReadUCScriptChar;
  cchr := PeekScriptChar;
  nameFlag := FALSE;
  blkName := '';
  IF cchr = '(' THEN nameFlag := ArgStr(@blkName, CLocSize, FALSE);
  {$IFC IMCompile }
  IF fICompile THEN ICEndCommand(blkType, blkName);
  {$ENDC }

  IF blkType = '¬' THEN
      BEGIN DecodeStr(@blkName, CLocSize); blkType := 'L'; END
  ELSE IF blkType = '∑' THEN
      BEGIN DecodeStr(@blkName, CLocSize); blkType := 'E'; END
  ELSE IF blkType = '∫' THEN
      BEGIN DecodeStr(@blkName, CLocSize); blkType := 'B'; END;

  CASE blkType OF
    'L': BEGIN { end Lesson }
           InLesson := FALSE;
           IF IMtst THEN WRITE('End of lesson ');
           IF IMtst THEN IF nameFlag THEN WRITELN('named ', blkName)
                                     ELSE WRITELN('(not named).');
           IF NOT fFullLocMap THEN
             IF nameFlag THEN SetEndLoc('L', blkName, ePos);
           ClearLTables;
         END;
    'E': BEGIN { end Exercise }
           InExercise := FALSE;
           IF IMtst THEN WRITE('End of exercise ');
           IF IMtst THEN IF nameFlag THEN WRITELN('named ', blkName)
                                     ELSE WRITELN('(not named).');
           IF NOT fFullLocMap THEN
             IF nameFlag THEN SetEndLoc('E', blkName, ePos);
           ClearETables;
         END;
    'B': BEGIN { end Block }
           IF IMtst THEN WRITE('End of block ');
           IF IMtst THEN IF nameFlag THEN WRITELN('named ', blkName)
                                     ELSE WRITELN('(not named).');
           IF NOT fFullLocMap THEN
             IF nameFlag THEN SetEndLoc('B', blkName, ePos)
                         ELSE blkName := 'unnamed';
           ClearBTables;
           PopBlock(blkName);
         END;
    'Z': BEGIN { end of script }
           IF IMtst THEN WRITE('End of script ');
           StopSkip;
           IF fMakeLocMap THEN WriteLessonLoc(TRUE);
           EXIT(EndCommand);
         END;
    END;
  IF fSkip THEN
    IF skipToEnd
       THEN BEGIN
         IF (blkType = skipType) AND (skipNext OR (skipName = blkName))
           THEN StopSkip;
        END
       ELSE IF (blkType = skipEndType) OR ((blkType = 'L') AND (skipEndType = 'E'))
          THEN BEGIN
            CmdError('Found skip limit end before proper skip end.');
            StopSkip;
           END;
END;

{$S imic }
PROCEDURE AddODefRec(oName, ofName: TKeyStr; ox,oy,oh,ow, oix, oiy: TC;
                         oKind,oSubKind: ObjectKind; oStrPos: TFPos);
VAR pObjDefRec: TPObjDefRec;
    recIdx: TC;
    fNew: TF;
BEGIN
  pObjDefRec := POINTER(ORD(ReDefSrchTableRec(hODefTable, oName, recIdx, fNew)));
  IF pObjDefRec = NIL
    THEN BEGIN
      WRITELN('Cant add new object def!!!! not enough room in ObjDef table.');
      Exit(AddODefRec);
     END;
  WITH pObjDefRec^ DO
    BEGIN
      doName := oName;
      dofName := ofName;
      doX := ox; doY := oy; doH := oh; doW := ow;
      doIx := oix; doIy := oiy;
      doStrPos := oStrPos;
      doKind := oKind; doSubKind := oSubKind;
      IF IMtst THEN
        IF fNew
          THEN  WRITELN('ObjDef ', oName, ' added ')
          ELSE WRITELN('ObjDef ', oName, ' redefined');
    END;
END;



{$S imifld }
PROCEDURE FolderCommand;
VAR int, x, y, h, w, ix, iy: TC;
    fname, newName, fatherName: TKeyStr;
    fFirst, fLast, fatFirst: TF;
    cchr: CHAR;
    imFldr: THFldrInfo;
    imHObj: ObjectHandle;
    fport: WindowPtr;
    fXChange, fYChange, fHChange, fWChange, fIChange: TF;
    fOpen, fClose, fActivate, fPutback, f1Change: TF;
    kind, subKind: ObjectKind;
    fStrPos: TFPos;
    cKeep: TC;

  PROCEDURE GetName(VAR sName: TKeyStr; VAR fFlag, lFlag: TF; fDecode: TF);
  VAR fInt: TC;
  BEGIN
    IF NOT ArgStr(@sName, CKeySize, FALSE)
      THEN BEGIN
        CmdError('Folder command Cant read name');
        FinishCommand;
        EXIT(FolderCommand);
       END;
    IF fDecode THEN DecodeStr(@sName, cKeySize);
    fFlag := FALSE;
    lFlag := FALSE;
    IF PeekUCScriptChar = '('
      THEN IF NOT ArgInt(fInt, FALSE)
        THEN BEGIN
          CmdError('Folder command Cant read first int');
          FinishCommand;
          EXIT(FolderCommand);
         END
        ELSE BEGIN
          IF fInt = 1 THEN fFlag := TRUE;
          IF fInt = 0 THEN lFlag := TRUE;
         END;
  END;

  FUNCTION GetNum: TC;
  BEGIN
    IF NOT ArgInt(int, TRUE)
      THEN BEGIN
        CmdError('Cant read Folder Command number value.');
        FinishCommand;
        EXIT(FolderCommand);
       END;
    GetNum := int;
  END;

  PROCEDURE ClearCFlags;
  BEGIN
    f1Change := FALSE;
    fHChange := FALSE;
    fIChange := FALSE;
    fWChange := FALSE;
    fXChange := FALSE;
    fYChange := FALSE;
    fOpen    := FALSE;
    fActivate := FALSE;
    fClose   := FALSE;
    fPutBack := FALSE;
    newName := '';
    fatherName := '';
    fStrPos := 0;
    ix:=0; iy:=0;
    x:=10; y:=10; h:=75; w:= 150;
    kind := docKind;
    subKind := nilKind;
  END;

  PROCEDURE ShowFCVars;
  BEGIN
    WRITELN('fH: ',fHChange,' fI: ',fIChange,' fW: ',fWChange,' fX: ',fXChange,
            ' fY: ',fYChange);
    WRITELN(' fOpen: ',fOpen,' fActv: ',fActivate,' fCls: ',fClose,
            ' fPBk: ',fPutBack);
    WRITELN('fName: "', fName,'" newName: "', newName,
            '" fatherName: "', fatherName,'"');
    WRITELN(' openPos:', x:4, y:4, ' openSize:', x+h:4, w:4,
            ' iconPos:', ix:4, iy:4);
    WRITELN(' fStrPos:', fStrPos, ' kind:', kind:4, ' subKind:', subKind:4);
  END;

  PROCEDURE DoDispCommand;
  VAR inc, ina: TF;
      aec: CHAR;
      saveFilPos: TFPos;
  BEGIN
    IF imHObj = NIL THEN EXIT(DoDispCommand);
    IF kbdCommand THEN EXIT(DoDispCommand);
      { for the moment we cant do this - awaiting a macro facility }
    ClearFolder(imHObj^^.imFldr);
    inc := InCommand;
    ina := InArg;
    aec := ArgEndChar;
    saveFilPos := IMFLinePos(PIMFS, ScriptPos);
    IF NOT IMFSetPos(PIMFS, fStrPos)
      THEN BEGIN
        IF sDebug THEN WRITELN('Cant find script pos of folder display!');
       END
      ELSE BEGIN
        ScriptPos := ScriptLineLen+1;
        DisplayCommand(imHObj);
        IF NOT IMFSetPos(PIMFS, saveFilPos)
          THEN BEGIN
            IF sDebug THEN
              WRITELN('Cant find current pos after folder display!');
            StrangeError('Cant find script pos after folder display!');
           END
        ELSE  ScriptPos := ScriptLineLen+1;
       END;
    InCommand := inc;
    InArg := ina;
    ArgEndChar := aec;
  END;

  PROCEDURE ChangeFather;
  VAR ofObj: ObjectHandle;
      ofFldr: THFldrInfo;
  BEGIN
    IF IMtst THEN WRITELN('ChangeFather');
    IF NOT ReadFldrArg(ofFldr, ofObj, fatherName, FALSE, fatFirst, FALSE)
      THEN BEGIN
        CmdError('Cant find new fatherObject');
        EXIT(ChangeFather);
       END;
    IF NOT IFIsContainer(ofObj)
      THEN BEGIN
        CmdError('Father object is not a container');
        EXIT(ChangeFather);
       END;
    IF ofObj = imHObj^^.container
      THEN BEGIN
        IF IMtst THEN WRITELN('object alerady in specified container');
        EXIT(ChangeFather);
       END;
    IF IMtst THEN  WRITELN('Putting object ', fName, ' in container ',
                            fatherName, ' at: ', ix:5, iy:5);
    IF NOT IFChangeCont(imHObj, ofObj, ix, iy, (NOT fIChange))
      THEN CmdError('Cant change container of object')
      ELSE fIChange := FALSE;
{$IFC IMCompile }
    IF fICompile THEN WRITELN(icFile, 'CChangeCont;')
{$ENDC }

  END;

  PROCEDURE DoFolderChange;
  VAR oRect, rH, rV: Rect;
      fixRgn: RgnHandle;
      canChange: TF;
  BEGIN
    IF NOT f1Change THEN EXIT(DoFolderChange);
    IF newName <> ''
      THEN BEGIN
        CmdError
         ('Sample folder name set but not generated, changes ignored');
        ClearCFlags;
        EXIT(DoFolderChange);
      END;
    IF IMtst THEN BEGIN WRITELN('Doing FolderChange'); ShowFCVars; END;
    IF imHObj = nilObject
      THEN BEGIN
        IF IMtst THEN WRITELN('Cant do folder changes for nilObject');
        ClearCFlags;
        EXIT(DoFolderChange);
       END;
   IF imFldr <> NIL
     THEN fport := imFldr^^.fldrPort
     ELSE fPort := imHObj^^.objWindow;
   IF IMtst THEN IF fClose THEN WRITELN('Closing folder: ', fName);
   IF fClose
     THEN BEGIN
{$IFC IMCompile }
       IF fICompile THEN WRITELN(icFile, 'CFldrClose;');
{$ENDC }
       IF fport <> NIL THEN canChange:=CanFldrClose(fport) ELSE canChange:=TRUE;
       IF NOT canChange THEN SetFldrClose(fport, TRUE);
       IFCloseObj(imHObj, FALSE);
       IF NOT canChange THEN SetFldrClose(fport, FALSE);
      END;
   IF IMtst THEN IF fPutBack THEN WRITELN('Putting back folder: ', fName);
   IF fPutBack THEN
       BEGIN
{$IFC IMCompile }
       IF fICompile THEN WRITELN(icFile, 'CFldrBack;');
{$ENDC }
       IF IFPutBack(imHObj) THEN;
       END;
   IF (fatherName <> '') THEN
       BEGIN
{$IFC IMCompile }
       IF fICompile THEN WRITELN(icFile, 'CFldrChgFather;');
{$ENDC }
       ChangeFather;
       END;
   IF IMtst THEN IF fIChange THEN WRITELN('Changeing Icon Pos');
   IF fIChange THEN
       BEGIN
{$IFC IMCompile }
       IF fICompile THEN WRITELN(icFile, 'CFldrMvIcon;');
{$ENDC }
       IFMoveIcon(IMHobj, ix, iy);
       END;
   IF imFldr <> NIL  { re-set fport in case it was destroyed by IFClose }
     THEN fport := imFldr^^.fldrPort
     ELSE fPort := imHObj^^.objWindow;
   IF fport <> NIL THEN SetPort(fport);
   GetObjRect(imHObj, oRect);
   IF fXChange OR fYChange THEN BEGIN
     IF IMtst THEN WRITELN('Doing folder pos change');
     IF fport <> NIL THEN canChange:=CanFldrMove(fport) ELSE canChange:=TRUE;
     IF NOT canChange THEN SetFldrMove(fport, TRUE);
     IF NOT fXChange THEN x := oRect.left;
     IF NOT fYChange THEN y := oRect.top;
     IF IMTst THEN WRITELN('Moving folder to:', x, y);
     IF imFldr <> NIL THEN SetPt(imFldr^^.fldrDefPos, x, y);
     IF fport <> NIL THEN MoveFolder(fport, x, y);
{$IFC IMCompile }
     IF fICompile THEN WRITELN(icFile, 'CFldrMove;');
{$ENDC }
     IF NOT (fHChange OR fWChange)
       THEN SetRect(imHObj^^.windowRect, x, y, x+w, y+h);
     IF NOT canChange THEN SetFldrMove(fport, FALSE);
    END;
   IF fWChange OR fHChange THEN BEGIN
     IF IMtst THEN WRITELN('Doing folder size change');
     IF fport <> NIL THEN canChange:=CanFldrGrow(fport) ELSE canChange:=TRUE;
     IF NOT canChange THEN SetFldrGrow(fport, TRUE);
     IF NOT fWChange THEN WITH oRect DO w := right - left;
     IF NOT fHChange THEN WITH oRect DO h := bottom - top;
     IF IMTst THEN WRITELN('Resizing folder to:', w, h);
{$IFC IMCompile }
     IF fICompile THEN WRITELN(icFile, 'CFldrResize;');
{$ENDC }
     IF imFldr <> NIL THEN SetPt(imFldr^^.fldrDefSize, w, h);
     IF imFldr = hndLGFldr
       THEN SetFldrSize(imFldr, w, h, LGStr)
       ELSE
         IF imFldr <> NIL THEN SetFldrSize(imFldr, w, h, NIL)
         ELSE IF fport <> NIL
           THEN BEGIN
             fixRgn := NewRgn;
             FlushRects(rH, rV);
             WITH rH DO SetRectRgn(fixRgn, left-1, top-1, right, bottom);
             InvalRgn(fixRgn);
             WITH rV DO SetRectRgn(fixRgn, left-1, top-1, right, rH.bottom);
             InvalRgn(fixRgn);
             FolderSize(fport, w, h, TRUE);
             FlushRects(rH, rV);
             WITH rH DO SetRectRgn(fixRgn, left-1, top-1, right, bottom);
             InvalRgn(fixRgn);
             WITH rV DO SetRectRgn(fixRgn, left-1, top-1, right, rH.bottom);
             InvalRgn(fixRgn);
             DisposeRgn(fixRgn);
            END;
     SetRect(imHObj^^.windowRect, x, y, x+w, y+h);
     IF NOT canChange THEN SetFldrGrow(fport, FALSE);
    END;

   IF fStrPos <> 0  THEN DoDispCommand;
   IF fActivate AND (NOT imHObj^^.isOpen) THEN fOpen := TRUE;
   IF IMtst THEN IF fOpen THEN WRITELN('Opening folder: ', fName);
   IF fOpen THEN
       BEGIN
       IFOpenObj(imHObj);
{$IFC IMCompile }
       IF fICompile THEN WRITELN(icFile, 'CFldrOpen;');
{$ENDC }
       END;
   IF IMtst THEN IF fActivate THEN WRITELN('Activating folder: ', fName);
   IF fActivate THEN
       BEGIN
       MakeFldrActive(imHObj^^.objWindow, nilUserData);
{$IFC IMCompile }
       IF fICompile THEN WRITELN(icFile, 'CFldrActive;');
{$ENDC }
       END;
   ClearCFlags;
  END;

  PROCEDURE ChkFolderChange;
  VAR oRect: Rect;
  BEGIN
    IF IMtst THEN WRITELN('Checking FolderChange');
    IF imHObj = nilObject
      THEN BEGIN
        IF IMtst THEN WRITELN('Cant check folder changes for nilObject');
        ClearCFlags;
        EXIT(ChkFolderChange);
       END;
    IF (fatherName = imHObj^^.container^^.name) THEN fatherName := '';
    WITH imHObj^^.loc DO
      IF (ix = h) AND (iy = v) THEN fIChange := FALSE ELSE fIChange := TRUE;
    GetObjRect(imHObj, oRect);
    WITH oRect DO BEGIN
      IF x <> left THEN fXChange := TRUE ELSE fXChange := FALSE;
      IF y <> top  THEN fYChange := TRUE ELSE fYChange := FALSE;
      IF w <> right-left THEN fWChange := TRUE ELSE fWChange := FALSE;
      IF h <> bottom-top THEN fHChange := TRUE ELSE fHChange := FALSE;
     END;
   IF NOT (fOpen OR fClose OR fPutBack)
     THEN BEGIN fClose := TRUE; END;
   IF imHObj^^.kind <> kind THEN BEGIN
     IF IMtst THEN WRITELN(' Coercing kind from:', imHObj^^.kind, ' to ', kind);
     IFValidIcon(imHObj, FALSE);
     imHObj^^.kind := kind;
     fIChange := TRUE;
    END;
   DoFolderChange;
  END;

  PROCEDURE FolderName(fRead: TF; fDecode: TF);
  BEGIN
    DoFolderChange;
    IF fRead THEN
        BEGIN
        GetName(fName, fFirst, fLast, fDecode);
        fDecode := FALSE;
        END;
    IF NOT ReadFldrArg(imFldr, imHObj, fName, FALSE, fFirst, fDecode)
      THEN BEGIN
         IF IMtst THEN WRITELN('Warning!! - Cant find display filer object');
         EXIT(FolderName);
       END;
    IF imFldr <> NIL
      THEN fport := imFldr^^.fldrPort
      ELSE fPort := imHObj^^.objWindow;
{$IFC IMCompile }
    IF fICompile THEN
       BEGIN
       WRITELN(icFile, 'CFldrName;');
       END;
{$ENDC }
  END;

  PROCEDURE FoldrDisplay;
  VAR cchr: CHAR;
  BEGIN
    cchr := ReadUCScriptChar;
    IF cchr <> '('
      THEN BEGIN
        CmdError('Invalid initial folder display command');
        FinishCommand;
        EXIT(FolderCommand);
       END;
    StartArg;
    fStrPos := IMFLinePos(PIMFS, ScriptPos);
    MunchCommand;
    FinishArg;
  END;

  PROCEDURE ObjKind;
  VAR okind: TKeyStr;
      recIdx: TC;
      pKindRec: TPKindRec;
      oFirst: TF; { a dummy }
  BEGIN
    GetName(oKind, oFirst, fLast, FALSE);
    pKindRec := POINTER(ORD(FindNthSrchTableRec(hKindTable, oKind, recIdx)));
    IF pKindRec <> NIL
      THEN BEGIN
        kind := pKindRec^.kindID;
        IF IMtst THEN
          WRITELN('Object kind set to:', oKind, ' (', kind, ')');
{$IFC IMCompile }
        IF fICompile THEN WRITELN(icFile, 'fKind := ', kind:1, ';');
{$ENDC }
       END
      ELSE CmdError('Invalid object kind');

    IF PeekUCScriptChar <> '(' THEN EXIT(ObjKind);
{$IFC IMCompile }
    IF fICompile THEN
        WRITELN(icFile, '{**** called objKind in foilder command ****}');
{$ENDC }
    GetName(oKind, oFirst, fLast, FALSE);
    pKindRec := POINTER(ORD(FindNthSrchTableRec(hKindTable, oKind, recIdx)));
    IF pKindRec <> NIL
      THEN BEGIN
        subKind := pKindRec^.kindId;
        IF IMtst THEN
          WRITELN('Object kind set to:', oKind, ' (', kind, ')');
{$IFC IMCompile }
        IF fICompile THEN WRITELN(icFile, 'fSubKind := ', subKind:1, ';');
{$ENDC }
       END
      ELSE CmdError('Invalid object subKind');
  END;

 PROCEDURE GetNewFolder;
  VAR cObj: ObjectHandle;
      clsPos: Point;
      opnRect: Rect;
  BEGIN
    IF newName = ''
      THEN BEGIN
        CmdError('Cant generate sample folder without S name');
        ClearCFlags;
        EXIT(GetNewFolder);
      END;
    IF IMtst THEN BEGIN WRITELN('Generating new object:'); ShowFCVars; END;
    IF NOT ReadFldrArg(imFldr, cObj, fatherName, FALSE, fatFirst, FALSE)
      THEN BEGIN
        IF sDebug THEN WRITELN('Cant find fatherObject named  "',
                                fatherName, '" using deskObject.');
        cObj := deskObject;
       END;
    fName := newName;
    newName := '';
    IF ReadFldrArg(imFldr, imHObj, fName, FALSE, fFirst, FALSE)
      THEN BEGIN
        IF IMtst THEN
          WRITELN('Object "', fName, '" exists - coercing to Generate parameters');
        ChkFolderChange;
        IF (fStrPos <> 0) AND (imFldr = NIL)
          THEN imFldr := AttachIMFolder(imHObj, FALSE, TRUE, TRUE, cKeep);
       END
      ELSE BEGIN
        SetPt(clsPos, ix, iy);
        SetRect(opnRect, x, y, x+w, y+h);
        imHObj := IFMakeObject(fName,kind,subKind,cObj,clsPos, NIL, opnRect);
        IF fStrPos <> 0
          THEN imFldr := AttachIMFolder(imHObj, FALSE, TRUE, TRUE, cKeep)
          ELSE imFldr := NIL;
       END;
    IF fStrPos <> 0  THEN DoDispCommand;
    IF IMtst THEN IF fClose THEN WRITELN('Closing folder: ', fName);
    IF fClose THEN IFCloseObj(imHObj, FALSE);
    IF IMtst THEN IF fPutBack THEN WRITELN('Putting back folder: ', fName);
    IF fPutBack THEN IF IFPutBack(imHObj) THEN;
    IF fActivate AND (NOT imHObj^^.isOpen) THEN fOpen := TRUE;
    IF IMtst THEN IF fOpen THEN WRITELN('Opening folder: ', fName);
    IF fOpen THEN IFOpenObj(imHObj);
    IF IMtst THEN IF fActivate THEN WRITELN('Activating folder: ', fName);
    IF fActivate THEN ActiveFldr(imFldr);
    ClearCFlags;
  END;

  PROCEDURE SaveObjDef;
  BEGIN
    IF newName <> ''
      THEN BEGIN
        IF IMtst THEN
          BEGIN WRITELN('Saving current object def:'); ShowFCVars; END;
        AddODefRec(newName, fatherName, x, y, h, w, ix, iy,
                   kind, subKind, fStrPos);
       END
      ELSE IF sDebug THEN WRITELN('Cant save obj def without an S name');
    ClearCFlags;
  END;

  PROCEDURE SetObjDef(fDecode: TF);
  VAR pObjDefRec: TPObjDefRec;
      recIdx: TC;
      fNew: TF;
      newFirst: TF; { a dummy }
  BEGIN
    DoFolderChange;
    GetName(newName, newFirst, fLast, fDecode);
    pObjDefRec := POINTER(ORD(FindNthSrchTableRec(hODefTable, newName, recIdx)));
    IF pObjDefRec = NIL
      THEN BEGIN
        IF IMtst THEN WRITELN('Cant find object def record: ', newName);
        Exit(SetObjDef);
       END;
    WITH pObjDefRec^ DO
    BEGIN
      newName := doName;
      fatherName := dofName;
      x:=doX; y:=doY; h:=doH; w:=doW;
      ix:=doIx; iy:=doIy;
      fStrPos := doStrPos;
      kind:= doKind; subKind:=doSubKind;
      IF IMtst THEN
        WRITELN('ObjDef ', newName, ' loaded');
    END;
  END;

  PROCEDURE ZapObject(fDecode: TF);
  VAR zapName: TKeyStr;
      zapObj: ObjectHandle;
      zapFldr: THFldrInfo;
      zapFirst, zapLast: TF;
      s255:   Str255;
  BEGIN
    DoFolderChange;
    cchr := PeekUCScriptChar;
    IF cchr = 'X'
      THEN BEGIN
        IF IMtst THEN WRITELN(' Zapping eXtraneous objects');
        cchr := ReadScriptChar;
        IFKillXtras(deskObject);
{$IFC IMCompile }
        IF fICompile THEN WRITELN(icFile, 'CKillXtras;');
{$ENDC }
        EXIT(ZapObject);
       END;
    GetName(zapName, zapFirst, zapLast, fDecode);
    IF zapFirst OR zapLast
      THEN  BEGIN
        IF ReadFldrArg(zapFldr, zapObj, zapName, FALSE, zapFirst, fDecode)
          THEN BEGIN
            IF IMtst THEN WRITELN('Zapping folder "', zapName, '"');
            IFKillObj(zapObj);
{$IFC IMCompile }
            IF fICompile THEN WRITELN(icFile, 'CKillObj;');
{$ENDC }
           END
          ELSE IF IMtst THEN WRITELN('Cant find object "', zapName, '" to zap.');
       END
      ELSE BEGIN
        IF IMtst THEN WRITELN('Zapping all folders named "', zapName, '"');
        KillNameObj(zapName);
        IF fICompile THEN
            BEGIN
            IF zapFirst THEN WRITELN('cFirstObj := TRUE');
            s255 := zapName;
{$IFC IMCompile }
            WRITELN(icFile, 'CKillObj(', AddBufWord(s255):1, ');');
{$ENDC }
            END;
       END;
  END;

  PROCEDURE ObjView;
  VAR v: ViewType;
  BEGIN
    cchr := PeekUCScriptChar;
    CASE cchr OF
      'P': BEGIN v := spatialView;
                 IF IMtst THEN WRITELN(' folder view set to spatial'); END;
      'C': BEGIN v := chronView;
                 IF IMtst THEN WRITELN(' folder view set to chronological'); END;
      'A': BEGIN v := alphaView;
                 IF IMtst THEN WRITELN(' folder view set to alphabetical'); END;
      OTHERWISE BEGIN
        CmdError('Invalid or Missing Device code');
        FinishCommand;
        EXIT(FolderCommand);
       END;
     END;
    cchr := ReadScriptChar;
    IFSetView(imHObj, v);
{$IFC IMCompile }
    IF fICompile THEN
       CASE cchr OF
          'P': IF fICompile THEN WRITELN(icFile, 'CPicView;');
          'C': IF fICompile THEN WRITELN(icFile, 'CChronView;');
          'A': IF fICompile THEN WRITELN(icFile, 'CAlphaView;');
           END;
{$ENDC }
  END;

{ we dont need this anymore for anything  -gb 10/6/83 }
{ PROCEDURE LoadFldrState;
  VAR dev, fname: FMaxStr;
      fOk: TF;
      err: TC;
  BEGIN
    cchr := PeekUCScriptChar;
    CASE cchr OF
      'L': BEGIN dev := 'LOWER';   END;
      'P': BEGIN dev := 'PROFILE'; END;
      'U': BEGIN dev := 'UPPER';   END;
      OTHERWISE BEGIN
        CmdError('Invalid or Missing Device code');
        FinishCommand;
        EXIT(FolderCommand);
       END;
     END;
    cchr := ReadScriptChar;
    fOk := ArgStr(@fname, 40,FALSE);
    IF fOk
      THEN BEGIN
        err := IFLoadCat(@dev, @fname);
        IF err = 0
          THEN BEGIN
            IF IMtst THEN WRITELN('New object state loaded from file:', fname);
           END
          ELSE BEGIN
            IF sDebug THEN WRITELN('Error in IFLoadCat: ', err);
            CmdError('Missing or invalid object state file');
           END;
       END
      ELSE CmdError('No object state file name');
  END;  }


{ dont need this either....
{ PROCEDURE UnLoadDevice;
  VAR dev: FMaxStr;
      fOk: TF;
      err: TC;
  BEGIN
    cchr := ReadUCScriptChar;
    CASE cchr OF
      'L': BEGIN dev := 'LOWER';   END;
      'P': BEGIN dev := 'PROFILE';   END;
      'U': BEGIN dev := 'UPPER';   END;
      OTHERWISE BEGIN
         CmdError('Folder UnMount Invalid or Missing Device code');
         FinishCommand;
         EXIT(FolderCommand);
        END;
     END;
    IFUnMount(err, dev);
    IF err = 0
      THEN BEGIN
        IF IMtst THEN WRITELN('UnMounted IM device:', dev);
       END
      ELSE BEGIN
        IF sDebug THEN WRITELN('Error in IFUnMount: ', err);
        CmdError('Missing or invalid object state file');
       END;
  END; }  { end of obsolete code }

BEGIN  { FolderCommand }
{$IFC IMCompile }
  IF fICompile THEN WRITELN(icFile, 'CBeginFolder;');
{$ENDC }
  ClearCFlags;
  cKeep := CDefKeepCt;
  fname := LGobj^^.name;
  IF NOT ReadFldrArg(imFldr, imHObj, fname, FALSE, FALSE, FALSE)
    THEN BEGIN
      FinishCommand;
      EXIT(FolderCommand);
     END;
  IF imFldr <> NIL
    THEN fport := imFldr^^.fldrPort
    ELSE fPort := imHObj^^.objWindow;
  REPEAT
    cchr := ReadUCScriptChar;
    IF IMScrTst THEN WRITELN('folder command char:', cchr, ORD(cchr));
    CASE cchr OF
      'A': BEGIN
           fActivate := TRUE;  fClose := FALSE;
           fPutBack := FALSE;  f1Change := TRUE;
           END;
      'B': BEGIN
           fPutBack := TRUE;   fClose := FALSE;   fOpen := FALSE;
           fActivate := FALSE; f1Change := TRUE;
           END;
      'C': IF NOT fPutBack THEN
               BEGIN
               fClose := TRUE;      fOpen := FALSE;
               fActivate := FALSE;  f1Change := TRUE;
               END;
      'D': BEGIN FoldrDisplay; f1Change := TRUE; END;
      'E': BEGIN
           {$IFC IMCompile } IF fICompile THEN icNameIntArg := 'fcKeep'; {$ENDC }
           cKeep := GetNum;
           IF IMtst THEN WRITELN('Object keep count set to:', cKeep);
            END;
      'G': GetNewFolder;
      'H': BEGIN
           {$IFC IMCompile } IF fICompile THEN icNameIntArg := 'fhVal'; {$ENDC }
           h := GetNum;
           fHChange := TRUE;
           f1Change := TRUE;
           END;
      'I': BEGIN
           {$IFC IMCompile } IF fICompile THEN icNameIntArg := 'fixVal'; {$ENDC }
           ix := GetNum;
           {$IFC IMCompile } IF fICompile THEN icNameIntArg := 'fiyVal'; {$ENDC }
           iy := GetNum;
           fIChange := TRUE;
           f1Change := TRUE;
           END;
      'J': IFSelObject(imHObj, FALSE);
      'K': ObjKind;
    { 'L': LoadFldrState; }
      'M': BEGIN GetName(fatherName, fatFirst, fLast, FALSE); f1Change := TRUE; END;
      '∏': BEGIN GetName(fatherName, fatFirst, fLast, TRUE); f1Change := TRUE; END;
      'N': FolderName(TRUE, FALSE);
      'Ñ': FolderName(TRUE, TRUE);
      'O': BEGIN fOpen := TRUE; fPutBack := FALSE; fClose := FALSE;
                 f1Change := TRUE; END;
      'P': BEGIN
           IFDupObj(imHObj);
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CDupObj;');
           {IF fICompile THEN WRITELN(icFile, 'CFolderName(fObj^^.name, FALSE);');}
{$ENDC }
           fFirst := FALSE;
           FolderName(FALSE, FALSE);
           END;
      'Q': SaveObjDef;
      'R': BEGIN  { LisaGuide nr fix #5 for translation stuff 3/2/83 -gb }
             GetName(fName, fFirst, fLast, FALSE);
             IF IMtst THEN WRITELN('ReNaming object "', imHObj^^.name, '" (',
                                    ORD(imHObj), ') to "', fName, '"');
             IFReName(imHObj, fName);
           END;
      'S': BEGIN SetObjDef(FALSE); f1Change := TRUE; END;
      'ß': BEGIN SetObjDef(TRUE); f1Change := TRUE; END;
      'T': BEGIN
           IFTearOffObj(imHObj);
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CTearOffObj;');
{$ENDC }
           END;
    { 'U': UnLoadDevice; }
      'V': ObjView;
      'W': BEGIN
           {$IFC IMCompile } IF fICompile THEN icNameIntArg := 'fwVal'; {$ENDC }
           w := GetNum;
           fWChange := TRUE; f1Change := TRUE;
           END;
      'X': BEGIN
           {$IFC IMCompile } IF fICompile THEN icNameIntArg := 'fxVal'; {$ENDC }
           x := GetNum;
           fXChange := TRUE; f1Change := TRUE;
           END;
      'Y': BEGIN
           {$IFC IMCompile } IF fICompile THEN icNameIntArg := 'fyVal'; {$ENDC }
           y := GetNum;
           fYChange := TRUE; f1Change := TRUE;
           END;
      'Z': ZapObject(FALSE);
      'Ω': ZapObject(TRUE);
      '1': BEGIN
           SetFldrMove(fPort, TRUE);
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CSetFldMove;');
{$ENDC }
           END;
      '2': BEGIN
           SetFldrMove(fPort, FALSE);
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CNoFldrMove;');
{$ENDC }
           END;
      '3': BEGIN
           SetFldrGrow(fPort, TRUE);
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CSetFldGrow;');
{$ENDC }
           END;
      '4': BEGIN
           SetFldrGrow(fPort, FALSE);
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CNoFldrGrow;');
{$ENDC }
           END;
      '5': BEGIN
           SetFldrClose(fPort, TRUE);
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CSetFldClose;');
{$ENDC }
           END;
      '6': BEGIN
           SetFldrClose(fPort, FALSE);
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CNoFldrClose;');
{$ENDC }
           END;
      ' ': BEGIN END;
      '.': CommandDone;
      OTHERWISE BEGIN
         InvalidCmdChar(cchr, 'Invalid Folder');
         EXIT(FolderCommand);
        END;
    END;
  UNTIL NOT InCommand;
  DoFolderChange;
{$IFC IMCompile }
  IF fICompile THEN WRITELN(icFile, 'CEndFolder;');
{$ENDC }

END;


{$S imiw }
PROCEDURE CheckGoDisplay;
VAR sch: CHAR;
BEGIN
  sch := PeekUCScriptChar;
  IF sch = 'D'
    THEN BEGIN
      sch := ReadScriptChar;
      ClearFolder(hndLGFldr);
      DisplayCommand(LGobj);
     END
    ELSE IF sch = 'C'
      THEN BEGIN
        sch := ReadScriptChar;
        ClearFolder(hndLGFldr);
       END;
END;


{$S imic }
PROCEDURE GoNext(blkType: CHAR);
BEGIN
     IF IMtst THEN WRITELN('GoNext to block type: ', blkType);
     ClearSkips;
     skipType := blkType;
     skipEndType := GetLimitType(blkType);
     fSkip := TRUE;
     skipNext := TRUE;
     IF IMtst THEN PrintSkipStuff;
{$IFC IMCompile }
     IF fICompile THEN WRITELN(icFile, 'CGoNext(''', blkType, ''');');
{$ENDC }
END;


{$S imiw }
PROCEDURE GoNamed(blkType: CHAR; toName: TKeyStr);
VAR subBlk: CHAR;
    fOK: TF;
    exName, blkName: TLocStr;
BEGIN
  exName := '';
  blkName := '';
  IF IMtst THEN
    WRITELN('GoNamed block type: ', blkType, ' named: ', toName);
  IF InCommand AND (blkType = 'L')
    THEN BEGIN
      subBlk := PeekUCScriptChar;
      IF (subBlk = 'E') OR (subBlk = '∑')
        THEN BEGIN
          subBlk := ReadScriptChar;
          IF ArgStr(@exName, CLocSize, FALSE) THEN
              BEGIN
              IF subBlk = '∑' THEN
                  BEGIN
                  subBlk := 'E';
                  DecodeStr(@exName, CLocSize);
                  END;
              END
          ELSE BEGIN
              CmdError('Cant read Go Exercise after Go Lesson');
              FinishCommand;
              END;
         END;
     END;

  IF InCommand AND (blkType = 'E')
    THEN BEGIN
      subBlk := PeekUCScriptChar;
      IF (subBlk = 'B') OR (subBlk = '∫')
        THEN BEGIN
          subBlk := ReadScriptChar;
          IF ArgStr(@exName, CLocSize, FALSE) THEN
              BEGIN
              IF subBlk = '∫' THEN
                  BEGIN
                  subBlk := 'B';
                  DecodeStr(@blkName, CLocSize);
                  END;
              END
          ELSE BEGIN
             CmdError('Cant read Go Block after Go Exercise');
             FinishCommand;
             END;
         END;
     END;

  IF InCommand THEN CheckGoDisplay;
  IF NOT fICompile THEN
    SkipTo(blkType, toName);
  skipExzName := exName;
  skipBlkName := blkName;
  IF IMtst AND fSkip THEN PrintSkipStuff;

{$IFC IMCompile }
  IF fICompile THEN
      BEGIN
      CASE blkType OF
          'L': WRITELN(icFile, 'CGoLesson(''', toName, ''', ''',
                                      exName, ''', ''', blkName, ''');');
          'E': WRITELN(icFile, 'CGoExercise(''', toName, ''', ''', blkName, ''');');
          'B': WRITELN(icFile, 'CGoBlock(''', toName, ''');');
          END;
      END;
{$ENDC }
END;


{$S imiw }
PROCEDURE GoCommand;
VAR blkType: CHAR;
    blkName: TLocStr;
    blkAd: TFPos;
    nextFlag, nameFlag: TF;
BEGIN
  blkAd := IMFLinePos(PIMFS, (ScriptPos - 1));
  blkType := ReadUCScriptChar;
  IF blkType = 'R'
    THEN WRITELN('Go to restart point not implemented yet.')
    ELSE BEGIN
      IF blkType = 'N'
        THEN BEGIN nextFlag := TRUE; blkType := ReadUCScriptChar; END
        ELSE nextFlag := FALSE;
      IF NOT nextFlag THEN nameFlag := ArgStr(@blkName, CLocSize, FALSE);
      CASE blkType OF
          '¬': BEGIN DecodeStr(@blkName, CLocSize); blkType := 'L'; END;
          '∑': BEGIN DecodeStr(@blkName, CLocSize); blkType := 'E'; END;
          '∫': BEGIN DecodeStr(@blkName, CLocSize); blkType := 'B'; END;
      END;
      CheckGoDisplay;
      IF nextFlag
        THEN GoNext(blkType)
        ELSE IF nameFlag
               THEN GoNamed(blkType, blkName)
               ELSE CmdError('Invalid go command.');
     END;
END;


{$S imic }
PROCEDURE HintCommand;
VAR cchr: CHAR;
    fOK: TF;
    hNum: TC;
BEGIN
  cchr := PeekScriptChar;
  IF (cchr = 'R') OR (cchr = 'r') THEN
    BEGIN LastHint := 0;
      fOK := ArgInt(hNum, FALSE);
      IF fOK
        THEN BEGIN
          IF IMtst THEN WRITELN('Resetting hints to hint number: ', hNum); END
        ELSE BEGIN
          hNum := 1;
          IF IMtst THEN WRITELN('Resetting hints to beginning.');
         END;
      LastHint := hNum - 1;
    END
  ELSE IF cchr = 'D'
      THEN BEGIN
        IF HintCount >= CMaxHints
          THEN CmdError('Not enough space for hints. Call Programmer.')
          ELSE BEGIN
                 HintCount := HintCount + 1;
                 PHintList^[HintCount] := IMFLinePos(PIMFS, ScriptPos);
                 IF IMtst THEN
                   BEGIN WRITELN('Hint ', HintCount:3, ' saved at pos: ');
                     PxIMFPos(PHintList^[HintCount]);
                   END;
               END;
       END
    ELSE InvalidCmdChar(cchr, 'Invalid Hint Command');
  DimHint;
{$IFC IMCompile }
  IF fICompile THEN
      WRITELN(icFile, '{**** HintCommand  - compilation not implemented! ****}');
{$ENDC }
END;


{$S imic }
PROCEDURE IMStateCommand;
VAR cchr: CHAR;
    sVal: TC;

  PROCEDURE NewFontDef;
  VAR fName: TKeyStr;
      fNum, fKey: TC;
  BEGIN
    IF NOT ArgStr(@fName, CKeySize, FALSE)
      THEN BEGIN
        CmdError('Cant read font name');
        FinishCommand;
        EXIT(IMStateCommand);
       END;
    IF NOT ArgInt(fNum, FALSE)
      THEN BEGIN
        CmdError('Cant read font number');
        FinishCommand;
        EXIT(IMStateCommand);
       END;
    fKey := AddIMFont(fName, fNum);
{$IFC IMCompile }
    IF fICompile THEN
        WRITELN(icFile, 'cargInt := AddIMFont(''', fName, ''', ', fNum:1, ');');
{$ENDC }
    IF IMtst THEN
      WRITELN('Added font: ', fName, ' idx:', fNum:4, ' key:', fKey:4);
  END;

  PROCEDURE DumpMap;
  VAR mfil: PathName;
  BEGIN
    IF ArgStr(@mfil, 255, FALSE)
      THEN BEGIN
        IF NOT (cDebug OR sDebug) THEN EXIT(DumpMap);
        IF mfil[1] <> '-' THEN mfil := CONCAT('-', imVolName, '-', imToolName, mfil);
        IF DumpSrchTable(hLessonLocTable, mfil)
          THEN WRITELN(' hLessonLocTable dumped into ', mfil)
          ELSE WRITELN(' Cant dump lessonLocTable into ', mfil);
       END
      ELSE CmdError('Cant read lesson map file name');
  END;

  PROCEDURE LoadMap;
  VAR mfil: PathName;
  BEGIN
    IF ArgStr(@mfil, 255, FALSE)
      THEN BEGIN
        IF mfil[1] <> '-' THEN mfil := CONCAT('-', imVolName, '-', imToolName, mfil);
        {IF ReadSrchTable(hLessonLocTable, mfil)- old code replace by nxt 2 lns}
        ReadLessonLoc(mfil);
        IF fOpenLocMap
          THEN BEGIN
            IF IMtst THEN WRITELN(' hLessonLocTable read from ', mfil);
           END
          ELSE BEGIN
            IF sDebug THEN WRITELN(' Cant read lessonLocTable from ', mfil);
           END;
       END
      ELSE CmdError('Cant read lesson map file name');
  END;

  PROCEDURE LoadWB;
  VAR mfil: PathName;
  BEGIN
    IF ArgStr(@mfil, 255, FALSE)
      THEN BEGIN
        IF mfil[1] <> '-' THEN mfil := CONCAT('-', imVolName, '-', imToolName, mfil);
        LoadWordBuf(mfil);
       END
      ELSE CmdError('Cant read lesson map file name');
  END;

BEGIN
  REPEAT
    cchr := ReadUCScriptChar;
    IF IMScrTst THEN WRITELN('IMState command char:', cchr, ORD(cchr));
    CASE cchr OF
      'F': NewFontDef;
      'O': BEGIN  {IF sDebug OR cDebug THEN DumpMap;} END;
      'L': LoadMap;
      'W': LoadWB;
      'S': IF ArgInt(sVal, FALSE)
             THEN BEGIN
               IF sVal > yesSound THEN sVal := yesSound;
               IF sVal < noSound  THEN sVal := noSound;
               btnSound := sVal;
               IF IMtst THEN WRITELN('BtnSound set to: ', btnSound);
              END
             ELSE CmdError('Cant read Button sound value (0-2)');
      OTHERWISE GobbleCmd(cchr, 'Invalid IMState command ');
    END;
  UNTIL NOT InCommand;
END;


{$S imidbg }
PROCEDURE PrintLoopRec(dstr: Str255; plr: TPLoopRec);
BEGIN
{$IFC IMDebug }
  WITH plr^ DO
    BEGIN
      WRITELN(dstr);
      WRITELN('Loop record for loop named: ', pKey);
      WRITE('Start loc: ');
      PrintIMFPos(pStartPos);
      WRITE('End loc:   ');
      PrintIMFPos(pEndPos);
      WRITELN('pCounted: ', pCounted, ' pCount: ', pCount, ' pIter: ', pIter);
      WRITELN('pTested: ', pTested, ' pTestVar: ', pTestVar);
    END;
{$ENDC }
END;


{$S imic }
PROCEDURE LoopCommand;
VAR cchr: CHAR;
    blkName: TLocStr;
    hloopRec: THLoopRec;
    fOK: TF;

  PROCEDURE PushLoopRec;
  BEGIN
    hloopRec := POINTER(ORD(HAllocate(IMHeap, SIZEOF(TLoopRec))));
    hloopRec^^.pNextLoop := hTopLoopRec;
    hTopLoopRec := hloopRec;
    IF IMtst THEN WRITELN('Allocating loop rec handle at: ', ORD(hloopRec));
  END;

  PROCEDURE InitLoop;
  BEGIN
    WITH hTopLoopRec^^ DO
      BEGIN
        pKey := blkName;
        IF IMtst THEN WRITELN('Loop start name: ', pKey);
        pCounted := FALSE;
        pCount := 0;
        pTested := FALSE;
        pIter := 0;
        pTestVar := 'notestvar';
        pStartPos := 0;
        pEndPos := 0;
        REPEAT
          cchr := ReadUCScriptChar;
          CASE cchr OF
            'C': BEGIN
                   {$IFC IMCompile } IF fICompile THEN icNameIntArg := 'lpCount'; {$ENDC }
                   IF ArgInt(pCount, TRUE)
                     THEN BEGIN pCounted := TRUE;
                       IF IMtst THEN WRITELN('Loop iter counted to: ', pCount);
                      END
                     ELSE CmdError('Invalid Loop Count');
                 END;
            'W': BEGIN
                   IF ArgStr(@pTestVar, CLocSize, FALSE)
                     THEN BEGIN pTested := TRUE;
                       IF IMtst THEN WRITELN('Looping while ', pTestVar, ' is TRUE');
                      END
                     ELSE CmdError('Invalid Loop Test Variable');
                 END;
            OTHERWISE GobbleCmd(cchr, 'Invalid Loop');
          END;
        UNTIL NOT InCommand;
        pStartPos := IMFLinePos(PIMFS, ScriptPos);
      END;
  END;

  FUNCTION LoopTest: BOOLEAN;
  VAR testval, okTest: TF;
  BEGIN
    WITH hTopLoopRec^^ DO
      BEGIN
        IF IMtst THEN PrintLoopRec('Testing loop record', hTopLoopRec^);
        testval := TRUE;
        IF pCounted THEN
          BEGIN pIter := pIter + 1;
            IF pIter > pCount THEN testval := FALSE;
          END;
        IF pTested THEN IF NOT GetBoolVar(pTestVar, FALSE, okTest)
                          THEN testval := FALSE;
        IF IMtst AND pTested THEN WRITELN('Valid variable test: ', okTest);
        IF IMtst THEN WRITELN('Loop test result: ', testval);
        LoopTest := testval;
      END;
  END;

BEGIN
  cchr := ReadUCScriptChar;
{$IFC IMCompile }
  IF fICompile THEN WRITELN(icFile, '{***** LoopCommand not implemented!! *****}');
{$ENDC }
  CASE cchr OF
    'S': IF NOT fSkip THEN
           BEGIN
             IF IMtst THEN WRITELN('Loop Start');
             IF PeekScriptChar = '('
               THEN fOK := ArgStr(@blkName, CLocSize, FALSE)
               ELSE fOK := FALSE;
             IF NOT fOK THEN blkName := 'this';
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CLoopStart(''', blkName, ''');');
{$ENDC }
             PushLoopRec;
             InitLoop;
             IF NOT LoopTest THEN WRITELN('LoopTest failed for first iteration, ',
                                  'but Exit from loop start not yet implemented.');
           END;
    'E': BEGIN
           IF IMtst THEN WRITELN('Loop End  ');
           IF PeekScriptChar = '('
             THEN fOK := ArgStr(@blkName, CLocSize, FALSE)
             ELSE fOK := FALSE;
           IF NOT fOK THEN blkName := 'this';
{$IFC IMCompile }
           IF fICompile THEN WRITELN(icFile, 'CLoopEnd(''', blkName, ''');');
{$ENDC }
           IF fSkip THEN
             BEGIN
               IF hTopLoopRec <> NIL
                 THEN IF hTopLoopRec^^.pKey = blkName
                   THEN PopLoopRec;
             END
            ELSE BEGIN
              IF hTopLoopRec = NIL
                THEN CmdError('Loop never started! Exiting now.')
                ELSE WITH hTopLoopRec^^ DO
                  BEGIN
                    IF (blkName <> 'this') AND (blkName <> pKey)
                      THEN CmdError('Loop start and end names dont match - ignored.');
                    FinishCommand;
                    pEndPos := IMFLinePos(PIMFS, ScriptPos);
                    IF LoopTest THEN
                      BEGIN
                        PopAllBlocks;
                        IF NOT fICompile THEN
                          IF IMFSetPos(PIMFS, pStartPos)
                            THEN BEGIN
                                 IF IMtst THEN WRITELN('looping back.');
                                 END
                            ELSE BEGIN PopLoopRec;
                                 CmdError('Cant find start pos for loop!')
                                 END;
                      END
                     ELSE BEGIN PopLoopRec; IF IMFtst THEN WRITELN('exiting loop'); END;
                   END;
             END;
         END;
    OTHERWISE CmdError('Invalid Loop subcommand.');
  END;
END;


{$S imiw }
PROCEDURE AlterMenuCommand;
LABEL 888,900;
VAR cchr: CHAR;
    fldrName: TKeyStr;
    fldrObj: ObjectHandle;
    fldrHndl: THFldrInfo;
    menuName: TKeyStr;
    itemName: TKeyStr;
    s255:     Str255;
    hMenuDInf: THMenuDInf;
BEGIN
  fldrName := '';
  fldrHndl := hndLGFldr;
  fldrObj := POINTER(ORD(fldrHndl^^.fldrFObj));
  menuName := 'garbage';
  itemName := 'garbage';
  REPEAT
    cchr := ReadUCScriptChar;
    CASE cchr OF
      'F', 'ƒ':
           BEGIN
           IF NOT ReadFldrArg(fldrHndl, fldrObj, fldrName, TRUE, FALSE, (cchr = 'ƒ')) THEN
               BEGIN
               IF fldrName <> ''
                   THEN CmdError('MenuCommand - Cant find folder object');
               GOTO 900;
               END;
           IF fldrHndl = NIL
               THEN fldrHndl := AttachIMFldr(fldrObj,FALSE,FALSE,TRUE,CDefKeepCt);
           IF IMTst THEN WRITELN('Menu command for folder:', fldrName);
           END;
      'T', '†':
           BEGIN
           IF ArgStr(@menuName, CKeySize, FALSE) THEN
               BEGIN
               IF IMtst THEN WRITELN('Using menu title: ', menuName);
               IF cchr = '†' THEN DecodeStr(@menuName, CKeySize);
{$IFC IMCompile }
               IF fICompile THEN
                   BEGIN
                   s255 := menuName;
                   WRITELN(icFile, 'cmMenu := ', AddBufWord(s255):1, ';');
                   END;
{$ENDC }
               cchr := PeekUCScriptChar;
               IF cchr = 'A' THEN
                   BEGIN
                   cchr := ReadUCScriptChar;
                   IF NOT PutMenuFolder(menuName, fldrHndl)
                       THEN CmdError('Cant add menu to folder');
                   END;
               END
             ELSE BEGIN
                WRITELN('Cant read menu title');
                GOTO 888;
               END;
           END;
      'I', '|':
           BEGIN
           IF ArgStr(@itemName, CKeySize, FALSE) THEN
               BEGIN
               IF cchr = '|' THEN DecodeStr(@itemName, CKeySize);
{$IFC IMCompile }
               IF fICompile THEN
                   BEGIN
                   s255 := itemName;
                   WRITELN(icFile, 'cmItem := ', AddBufWord(s255):1, ';');
                   END;
{$ENDC }
               IF IMtst THEN WRITELN('Using menu item: ', itemName);
              END
             ELSE BEGIN
                WRITELN('Cant read menu item');
                GOTO 888;
               END;
           END;
      'S': BEGIN
             IF IMtst THEN WRITELN('showing menu named: ', menuName);
             IF NOT SetDspMenu(menuName, TRUE)
               THEN GOTO 888;
{$IFC IMCompile }
             IF fICompile THEN
                 WRITELN(icFile, 'CShowMenu;');
{$ENDC }
             IF IMtst THEN WRITELN('menu ', menuName, ' displayed.');
           END;
      'H': BEGIN
             IF IMtst THEN WRITELN('hiding menu named: ', menuName);
             IF NOT SetDspMenu(menuName, FALSE)
               THEN GOTO 888;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CHideMenu;');
{$ENDC }
             IF IMtst THEN WRITELN('menu ', menuName, ' hidden.');
           END;
      'E': BEGIN
             IF IMtst THEN
               WRITELN('Enabling menu: ', menuName, ' item: ', itemName);
             IF NOT SetActItem(menuName, itemName, TRUE)
               THEN GOTO 888;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CActItem;');
{$ENDC }
             IF IMtst THEN
               WRITELN(' menu ', menuName, ' ', itemName, ' enabled.');
           END;
      'D': BEGIN
             IF IMtst THEN
               WRITELN('Disabling menu: ', menuName, ' item: ', itemName);
             IF NOT SetActItem(menuName, itemName, FALSE)
               THEN GOTO 888;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'SetDeActItem;');
{$ENDC }
             IF IMtst THEN WRITELN(' menu ', menuName, ' ', itemName, ' disabled.');
           END;
      'C': BEGIN
             IF IMtst THEN
               WRITELN('Display item chars. Menu: ', menuName, ' item: ', itemName);
             IF NOT SetDspItem(menuName, itemName, TRUE)
               THEN GOTO 888;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CDispItem;');
{$ENDC }
             IF IMtst THEN WRITELN(' menu ', menuName, ' ', itemName, ' displayed.');
           END;
      'B': BEGIN
             IF IMtst THEN
               WRITELN('Blanking item chars. Menu: ', menuName, ' item: ', itemName);
             IF NOT SetDspItem(menuName, itemName, FALSE)
               THEN GOTO 888;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CBlankItem;');
{$ENDC }
             IF IMtst THEN WRITELN(' menu ', menuName, ' ', itemName, ' blanked.');
           END;
      OTHERWISE GobbleCmd(cchr, 'Invalid menu item activate');
    END;
  UNTIL NOT InCommand;
  { IF fldrIdx <> 0 THEN }
  IF fldrHndl^^.fldrPort = activeFolder THEN LoadMenuBar(fldrHndl);
  GOTO 900;
888: CmdError('Cant complete menu command');
900:
END;


{$S imic }
PROCEDURE ButtonDefCommand;
LABEL 900;
VAR cchr: CHAR;
    btnName, btnText, btnFont: TKeyStr;
    btnInt, btnFIdx, btnIdx: TC;
    fBtnFrame: TF;
    bSize, bOffset: Point;
    pBtnRec: TPButton;
BEGIN
  cchr := PeekUCScriptChar;
  fBtnFrame := FALSE;
  IF cchr = 'F'
    THEN BEGIN
      cchr := ReadUCScriptChar;
      fBtnFrame := TRUE;
     END;
  IF NOT ArgStr(@btnName, CKeySize, FALSE)
    THEN BEGIN
      CmdError('Cant read button name');
      FinishCommand;
      EXIT(ButtonDefCommand);
     END;
  IF NOT ArgStr(@btnText, CKeySize, FALSE)
    THEN BEGIN
      CmdError('Cant read button text');
      FinishCommand;
      EXIT(ButtonDefCommand);
     END;
  IF NOT ArgStr(@btnFont, CKeySize, FALSE)
    THEN BEGIN
      CmdError('Cant read button font');
      FinishCommand;
      EXIT(ButtonDefCommand);
     END;
  btnFIdx := FIdxFromName(btnFont);
  IF btnFIdx = 0
    THEN BEGIN
      CmdError('Cant invalid button font name');
      FinishCommand;
      EXIT(ButtonDefCommand);
     END;
  btnIdx := NewIMButton(btnName, btnText, btnFIdx, fBtnFramed);
  pBtnRec := GetButtonRec(btnIdx);
  bSize := pBtnRec^.btnSize;
  bOffset := pBtnRec^.btnOffset;
  IF IMtst THEN
       WRITELN('Defined button ', btnName, ' with button text ', btnText,
               ' font: ', btnFont, ' framed: ', fBtnFrame);
  REPEAT
    cchr := ReadUCScriptChar;
    CASE cchr OF
      'X': IF NOT ArgInt(btnInt, FALSE)
             THEN GOTO 900
             ELSE bOffset.h := btnInt;
      'Y': IF NOT ArgInt(btnInt, FALSE)
             THEN GOTO 900
             ELSE bOffset.v := btnInt;
      'W': IF NOT ArgInt(btnInt, FALSE)
             THEN GOTO 900
             ELSE bSize.h := btnInt;
      'H': IF NOT ArgInt(btnInt, FALSE)
             THEN GOTO 900
             ELSE bSize.v := btnInt;
      OTHERWISE GobbleCmd(cchr, 'Button size command');
    END;
  UNTIL NOT InCommand;
  SetBtnSize(btnIdx, bSize);
  SetBtnOffset(btnIdx, bOffset);
{$IFC IMCompile }
  IF fICompile THEN
      BEGIN
      WRITELN(icFile, 'cargFont := FIdxFromName(''', btnFont, ''');');
      WRITELN(icFile, 'cargInt := NewIMButton(''', btnName, ''', ''',
               btnText, ''', cargFont, ', fBtnFramed, ');');
      WRITELN(icFile, 'CSetBtnSize(cargInt, ', bSize.h:1, ', ', bSize.v:1, ', ',
                       bOffset.h:1, ', ', bOffset.v:1, ');');
      END;
{$ENDC }
  IF IMtst THEN WRITELN(' Button size:', bSize.h:5, bSize.v:5,
                        ' offset:', bOffset.h:5, bOffset.v:5);
  EXIT(ButtonDefCommand);
900:
  CmdError('Cant read button definition number');
  FinishCommand;
END;


{$S imiw }
PROCEDURE PauseCommand;
VAR argtime: TC;
BEGIN
  IF NOT fNoPause THEN
    BEGIN
      IF NOT ArgInt(argtime, FALSE)
        THEN BEGIN
             CmdError('Cant read pause time.  Using 2 seconds.');
             toWaitTime := 2;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'toWaitTime := 2;');
{$ENDC }
             END
        ELSE BEGIN
             toWaitTime := argtime;
             END;
      fPause := TRUE;
      toWaitTime := toWaitTime * CTicksPerSec;
{$IFC IMCompile }
      IF fICompile AND (toWaitTime > 0) THEN
          BEGIN
          WRITELN(icFile, 'fPause := TRUE;');
          WRITELN(icFile, 'toWaitTime := ', (toWaitTime * CTicksPerSec):1, ';');
          END;
{$ENDC }
    END;
END;


{$S imiw }
PROCEDURE RecordCommand;
VAR cchr: CHAR;
BEGIN
  REPEAT
    cchr := ReadUCScriptChar;
    CASE cchr OF
      'S': BEGIN
             IF IMtst THEN WRITELN('Recording Selections');
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'fRSelections := TRUE;');
{$ENDC }
             fRSelections := TRUE;
           END;
      'I': BEGIN
             IF IMtst THEN WRITELN('Recording Insertions');
             fRSelections := TRUE;
             fRInsertion := TRUE;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'fRSelections := TRUE;');
             IF fICompile THEN WRITELN(icFile, 'fRInsertion := TRUE;');
{$ENDC }
           END;
      'K': BEGIN
             IF IMtst THEN WRITELN('Recording Keyboard Input');
             fRKeyboard := TRUE;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'fRKeyboard := TRUE;');
{$ENDC }
           END;
      'E': BEGIN
             IF IMtst THEN WRITELN('Recording Edited Keyboard Input');
             fRKeyboard := TRUE;
             fREditKbd := TRUE;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'fRKeyboard := TRUE;');
             IF fICompile THEN WRITELN(icFile, 'fREditKbd := TRUE;');
{$ENDC }
           END;
      'C': BEGIN
             IF IMtst THEN WRITELN('Recording Commands');
             fRCommands := TRUE;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'fRCommands := TRUE;');
{$ENDC }
           END;
      'F': BEGIN
             IF IMtst THEN WRITELN('Recording Object Commands');
             fRObjects := TRUE;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'fRObjects := TRUE;');
{$ENDC }
             IF IMERTst THEN WRITELN('curObjTable is: ', ORD(curObjTable));
           END;
      OTHERWISE GobbleCmd(cchr, 'Invalid Record sub-command');
    END;
  UNTIL NOT InCommand;
END;


{$S imih }
PROCEDURE doIMCommand;
BEGIN
  IF fTstSim OR IMTst THEN WRITELN('Doing Interp command from simulation.');
  InterpretCommand;
  FinishCommand;
END;


{$S imiw }
PROCEDURE SimulateCommand;
VAR nameFlag: TF;
BEGIN
    nameFlag := ArgStr(@simName, CKeySize, FALSE);
    IF nameFlag THEN BEGIN
      FinishCommand;
{$IFC IMCompile }
      IF fICompile THEN
          BEGIN
          WRITELN(icFile, 'CDoSim(''', simName, ''');');
          EXIT(SimulateCommand);
          END;
{$ENDC }
      simPos := IMFPos(PIMFS);
      fSim := TRUE;
      IF IMtst THEN
        WRITELN('Entering simulation ', simName, ' fSimEdit: ', fSimEdit);
      IF fSimEdit
        THEN BEGIN
          fSimHold := TRUE; { set hold if in edit mode. }
          WRITELN('Now editing simulation file: ', simName);
         END
        ELSE fSimWtPB := TRUE;
     END
    ELSE BEGIN
      simName := '';
      fSim := FALSE;
      IF IMTst THEN WRITELN('Cant read sim file name.');
      CmdError('Cant read name of simulation file.');
     END;
END;


{$S imic }
PROCEDURE TagCommand;
VAR tagName: TLocStr;
    tagAd: TFPos;
    nameFlag: TF;
BEGIN
  tagAd := IMFPos(PIMFS) - 1;
  nameFlag := ArgStr(@tagName, CLocSize, FALSE);
  IF nameFlag
    THEN SetStartLoc('T', tagName, tagAd)
    ELSE CmdError('Cant read tag name.');
  IF IMtst THEN WRITELN(' Recording tag: ', tagName);
  IF fSkip THEN
    IF (skipType = 'T') AND (skipName = tagName) THEN StopSkip;
{$IFC IMCompile }
  IF fICompile THEN
      WRITELN(icFile,
              '{***** TagCommand not implemented in compiled version *****}');
{$ENDC }
END;


{$S imiw }
FUNCTION TestFolder: TF;
LABEL 100;
VAR cchr: CHAR;
    fName, cName: TKeyStr;
    posval, errval: TC;
    fldrInfo: THFldrInfo;
    fldrObj: ObjectHandle;
    fPos, fSize, fLoc: Point;
    fFail, fOption, fNoObj: TF;

  PROCEDURE SetFldr;
  VAR oRect: Rect;
  BEGIN
    GetObjRect(fldrObj, oRect);
    WITH oRect
      DO BEGIN
           SetPt(fPos, left, top);
           SetPt(fSize, right-left, bottom-top);
         END;
    fLoc := fldrObj^^.loc;
    IF IMtst THEN
      WRITELN('Folder ', fName, ' at:', fPos.h:5, fPos.v:5,
              ' size:', fSize.h:5, fSize.v:5);
   END;

BEGIN
  fFail := FALSE;
  fOption := FALSE;
  fNoObj := FALSE;
  fldrInfo := hndLGFldr;
  fName := fldrInfo^^.fldrName;
  IF NOT ReadFldrArg(fldrInfo, fldrObj, fName, FALSE, FALSE, FALSE)
    THEN BEGIN
      FinishCommand;
      TestFolder := FALSE;
     END;
  SetFldr;
  WHILE InCommand DO
    BEGIN
100:  cchr := ReadUCScriptChar;
      IF fNoObj
        THEN IF
          cchr IN ['A', 'C', 'H', 'M', 'O', 'W', 'X', 'Y']
            THEN GOTO 100;
      CASE cchr OF
        'N', 'Ñ':
             BEGIN
               IF PeekScriptChar = '?'
                 THEN BEGIN
                   fOption := TRUE;
                   cchr := ReadScriptChar;
                  END
                 ELSE fOption := FALSE;
               IF ReadFldrArg(fldrInfo, fldrObj, fName, TRUE, FALSE, (cchr = 'Ñ'))
                THEN SetFldr
                ELSE BEGIN
                  IF fOption
                    THEN fNoObj := TRUE
                    ELSE fFail := TRUE;
                 END;
             END;
        'M', '∏':
             IF ArgStr(@cName, CKeySize, TRUE)
                THEN BEGIN
                  IF cchr = '∏' THEN DecodeStr(@cName, CKeySize);
                  IF fldrObj^^.container^^.name <> cName
                    THEN BEGIN
                       fFail := TRUE;
                       IF IMtst THEN WRITELN('Folder ', fName,
                                         ' is not in container: ', cName);
                      END;
                 END
                ELSE BEGIN
                  fFail := TRUE;
                  CmdError('Folder command. Cant read container name');
                 END;
        'I': BEGIN
              IF ArgRange(posVal, errval, TRUE)
                THEN BEGIN
                   fFail := NOT ValInRange(fLoc.h, posval, errval);
                   IF IMtst THEN
                     WRITELN('Test icon H position: ', (NOT fFail));
                 END
                ELSE BEGIN
                  CmdError('Cant read icon H range');
                  fFail := TRUE;
                 END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFIHPos;');
{$ENDC }
              IF NOT fFail THEN
               IF ArgRange(posVal, errval, TRUE)
                THEN BEGIN
                   fFail := NOT ValInRange(fLoc.v, posval, errval);
                   IF IMtst THEN
                     WRITELN('Test icon V position: ', (NOT fFail));
                 END
                ELSE BEGIN
                  CmdError('Cant read icon V range');
                  fFail := TRUE;
                 END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFIVPos;');
{$ENDC }
            END;
        'X': BEGIN
             IF ArgRange(posVal, errval, TRUE)
                THEN BEGIN
                   fFail := NOT ValInRange(fPos.h, posval, errval);
                   IF IMtst THEN
                     WRITELN('Test folder X position: ', (NOT fFail));
                 END
                ELSE BEGIN
                  CmdError('Cant read X range');
                  fFail := TRUE;
                 END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFXPos;');
{$ENDC }
             END;
        'Y': BEGIN
             IF ArgRange(posVal, errval, TRUE)
               THEN BEGIN
                  fFail := NOT ValInRange(fPos.v, posval, errval);
                  IF IMtst THEN
                    WRITELN('Test folder Y position: ', (NOT fFail));
                END
               ELSE BEGIN
                 CmdError('Cant read Y range');
                 fFail := TRUE;
                END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFYPos;');
{$ENDC }
             END;
        'W': BEGIN
             IF ArgRange(posVal, errval, TRUE)
               THEN BEGIN
                  fFail := NOT ValInRange(fSize.h, posval, errval);
                  IF IMtst THEN
                    WRITELN('Test folder width: ', (NOT fFail));
                END
               ELSE BEGIN
                 CmdError('Cant read Width range');
                 fFail := TRUE;
                END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFWid;');
{$ENDC }
             END;
        'H': BEGIN
             IF ArgRange(posVal, errval, TRUE)
               THEN BEGIN
                  fFail := NOT ValInRange(fSize.v, posval, errval);
                  IF IMtst THEN
                    WRITELN('Test folder height: ', (NOT fFail));
                END
               ELSE BEGIN
                 CmdError('Cant read Height range');
                 fFail := TRUE;
                END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFHt;');
{$ENDC }
             END;
        'C': BEGIN
             IF NOT fldrObj^^.isOpen
               THEN BEGIN
                 IF IMtst THEN WRITELN('TestFolder - Folder closed');
                END
               ELSE BEGIN
                 fFail := TRUE;
                 IF IMtst THEN WRITELN('TestFolder - Folder not closed');
                END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFClosed;');
{$ENDC }
             END;
        'O': BEGIN
             IF fldrObj^^.isOpen
               THEN BEGIN
                 IF IMtst THEN WRITELN('TestFolder - Folder open');
                END
               ELSE BEGIN
                 fFail := TRUE;
                 IF IMtst THEN WRITELN('TestFolder - Folder not open');
                END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFOpen;');
{$ENDC }
             END;
        'A': BEGIN
             IF fldrObj = activeObject
               THEN BEGIN
                 IF IMtst THEN WRITELN('TestFolder - Folder active');
                END
               ELSE BEGIN
                 fFail := TRUE;
                 IF IMtst THEN WRITELN('TestFolder - Folder not active');
                END;
{$IFC IMCompile }
             IF fICompile THEN WRITELN(icFile, 'CTstFActive;');
{$ENDC }
             END;
        OTHERWISE BEGIN
              GobbleCmd(cchr, 'Invalid Folder Test');
             END;
       END;
      IF fFail THEN BEGIN
        TestFolder := FALSE;
        EXIT(TestFolder);
       END;
    END;
  IF IMtst THEN WRITELN('TestFolder returns true');
  TestFolder := TRUE;
END;


{$S imiw }
FUNCTION TestVar(varType: CHAR): TF;
VAR req, rne, rgt, rlt: TF;
    fVarRel: TF;
    rchar: CHAR;
    pVarRec: TPVarRec;
    strVal: Str255;
    tInt, intVal: TC;
    tBool, boolVal: TF;
    tChar, charVal: CHAR;

  PROCEDURE GetRel(scalarFlag: TF);
  LABEL 100, 500;
  BEGIN
    req := FALSE;
    rne := FALSE;
    rlt := FALSE;
    rgt := FALSE;
  100: rchar := PeekScriptChar;
       IF rchar = '=' THEN req := TRUE
         ELSE IF rchar = '<' THEN rlt := TRUE
           ELSE IF rchar = '>' THEN rgt := TRUE
             ELSE IF rchar = '#' THEN rne := TRUE
               ELSE GOTO 500;
       rchar := ReadScriptChar;
       GOTO 100;
  500: IF (rgt AND rlt) THEN BEGIN rgt := FALSE; rlt := FALSE; rne := TRUE; END;
       IF ((NOT scalarFlag) AND (rgt OR rlt))
         THEN CmdError('Invalid comparison of non-scalar variables');
       IF (req AND rne)
         THEN CmdError('Testing both eq and ne, Result will be TRUE!');
       IF ((NOT req) AND (NOT rne) AND (NOT rlt) AND (NOT rgt))
         THEN BEGIN
           req := TRUE;
           IF IMtst THEN WRITELN('No relations specified. = being used.');
         END;
       IF IMtst THEN BEGIN
         WRITE('Test var relations set to: ');
         IF rlt THEN WRITE('<');
         IF req THEN WRITE('=');
         IF rne THEN WRITE('#');
         IF rgt THEN WRITE('>');
        END;
  END;

BEGIN  pvarRec := GetVarRec(varType);
  fVarRel := FALSE;
  IF pvarRec <> NIL THEN
    CASE pvarRec^.vType OF
      TVInt: BEGIN
               GetRel(TRUE);
               IF ArgInt(intVal, TRUE)
                 THEN BEGIN
                   tInt := pvarRec^.vInt;
                   IF req THEN IF tInt = intVal THEN fVarRel := TRUE;
                   IF rne THEN IF tInt <> intVal THEN fVarRel := TRUE;
                   IF rlt THEN IF tInt < intVal THEN fVarRel := TRUE;
                   IF rgt THEN IF tInt > intVal THEN fVarRel := TRUE;
{$IFC IMCompile }
                   IF fICompile THEN
                     IF req THEN
                       IF rgt THEN
                         IF rlt THEN WRITELN(icFile, 'fTest := TRUE')
                         ELSE WRITELN(icFile, 'fTest := (cargVar^.vInt >= cargInt);')
                       ELSE
                         IF rlt THEN WRITELN(icFile, 'fTest := (cargVar^.vInt <= cargInt);')
                         ELSE WRITELN(icFile, 'fTest := (cargVar^.vInt = cargInt);')
                     ELSE
                       IF rgt THEN
                         IF rlt THEN WRITELN(icFile, 'fTest := (cargVar^.vInt <> cargInt);')
                         ELSE WRITELN(icFile, 'fTest := (cargVar^.vInt > cargInt);')
                       ELSE
                        IF rlt THEN WRITELN(icFile, 'fTest := (cargVar^.vInt < cargInt);')
                        ELSE WRITELN(icFile, 'fTest := (cargVar^.vInt <> cargInt);');
{$ENDC }
                  END
                 ELSE CmdError('Cant read integer variable test value');
             END;
      TVChar: BEGIN
                GetRel(TRUE);
                IF ArgChar(charVal)
                  THEN BEGIN
                   tChar := pvarRec^.vChar;
                   IF req THEN IF tChar = charVal THEN fVarRel := TRUE;
                   IF rne THEN IF tChar <> charVal THEN fVarRel := TRUE;
                   IF rlt THEN IF ORD(tChar)
                                   < ORD(charVal) THEN fVarRel := TRUE;
                   IF rgt THEN IF ORD(tChar)
                                   > ORD(charVal) THEN fVarRel := TRUE;
{$IFC IMCompile }
                   IF fICompile THEN
                     IF req THEN
                       IF rgt THEN
                         IF rlt THEN WRITELN(icFile, 'fTest := TRUE')
                         ELSE WRITELN(icFile, 'fTest := (ORD(cargVar^.vChar) >= ORD(cargChar));')
                       ELSE
                         IF rlt THEN WRITELN(icFile, 'fTest := (ORD(cargVar^.vChar) <= ORD(cargChar));')
                         ELSE WRITELN(icFile, 'fTest := (cargVar^.vChar = cargChar);')
                     ELSE
                       IF rgt THEN
                         IF rlt THEN WRITELN(icFile, 'fTest := (cargVar^.vChar <> cargChar);')
                         ELSE WRITELN(icFile, 'fTest := (ORD(cargVar^.vChar) > ORD(cargChar));')
                       ELSE
                        IF rlt THEN WRITELN(icFile, 'fTest := (ORD(cargVar^.vChar) < ORD(cargChar));')
                        ELSE WRITELN(icFile, 'fTest := (cargVar^.vChar <> cargChar);');
{$ENDC }
                   END
                  ELSE CmdError('Cant read char variable test value');
              END;
      TVBool: BEGIN
                GetRel(FALSE);
                IF ArgBool(boolVal)
                  THEN BEGIN
                   tBool := pVarRec^.vBool;
                   IF req THEN IF tBool = boolVal THEN fVarRel := TRUE;
                   IF rne THEN IF tBool <> boolVal THEN fVarRel := TRUE;
{$IFC IMCompile }
                   IF fICompile THEN
                     IF req THEN WRITELN(icFile, 'fTest := (cargVar^.vBool <= cargBool);')
                     ELSE IF rne THEN WRITELN(icFile, 'fTest := (cargVar^.vBool <> cargBool);');
{$ENDC }
                   END
                  ELSE CmdError('Cant read boolean variable test value');
              END;
      TVStr: BEGIN
               GetRel(FALSE);
                IF ArgStr(@strVal, 255, TRUE)
                  THEN BEGIN
                    IF req THEN IF pvarRec^.vHStr^^ = strVal THEN fVarRel := TRUE;
                    IF rne THEN IF pvarRec^.vHStr^^ <> strVal THEN fVarRel := TRUE;
{$IFC IMCompile }
                    IF fICompile THEN
                      IF req THEN WRITELN(icFile, 'fTest := (cargVar^.vHStr^^ = cargStr);')
                      ELSE IF rne THEN WRITELN(icFile, 'fTest := (cargVar^.vHStr^^ <> cargStr);');
{$ENDC }
                   END
                  ELSE CmdError('Cant read string variable test value');
             END;
      OTHERWISE CmdError('Cant get valid variable type from var (shouldnt happen!)');
     END;
   TestVar := fVarRel;
END;


{$S imiw }
FUNCTION CheckTag: BOOLEAN;
VAR cchr: CHAR;
BEGIN
  cchr := PeekScriptChar;
  IF cchr = '('
    THEN CheckTag := TRUE
    ELSE CheckTag := FALSE;
END;


{$S imiw }
PROCEDURE TestCommand;
VAR cchr: CHAR;
    matFailCode: TC;
    askStr: Str255;
BEGIN
  cchr := ReadUCScriptChar;
  CASE cchr OF
    'A': BEGIN
         fTest := TRUE;
{$IFC IMCompile }
         IF fICompile THEN
             BEGIN
             WRITELN(icFile, 'fTest := TRUE;');
             CmdError('Compiling TestAsk  command');
             END;
{$ENDC }
         {$IFC IMDebug}
         IF ArgStr(@askStr, 255, FALSE) THEN WRITELN(askStr);
         WRITELN('Enter value for test flag. ');
         fTest := GetYorN;
         IF IMtst THEN WRITELN('Asking for test result. fTest set to: ', fTest);
         {$ENDC }
         END;
    'V': BEGIN
           fTest := TestVar('V');
           IF IMtst THEN WRITELN('Testing variable. fTest set to: ', fTest);
         END;
    'U': BEGIN
           fTest := TestVar('U');
           IF IMtst THEN WRITELN('Testing user hist. fTest set to: ', fTest);
         END;
    'F': BEGIN
           fTest := TestFolder;
           IF IMtst THEN WRITELN('Testing folder. fTest set to: ', fTest);
         END;
    'T': BEGIN
         fTest := fTimeout;
{$IFC IMCompile }
         IF fICompile THEN WRITELN(icFile, 'fTest := fTimeout;');
{$ENDC }
         IF IMtst THEN WRITELN('Testing timeout. fTest set to: ', fTest);
         END;
    'B': BEGIN
         fTest := fButton;
{$IFC IMCompile }
         IF fICompile THEN WRITELN(icFile, 'fTest := fTimeout;');
{$ENDC }
         IF IMtst THEN WRITELN('Testing button. fTest set to: ', fTest);
         END;
    'C': BEGIN
         fTest := fContinue;
{$IFC IMCompile }
         IF fICompile THEN WRITELN(icFile, 'fTest := fContinue;');
{$ENDC }
         IF IMtst THEN WRITELN('Testing Continue. fTest set to: ', fTest);
         END;
    'M': BEGIN
           cchr := ReadUCScriptChar;
           CASE cchr OF
             'M': BEGIN
                  fTest := fMouseMoved;
{$IFC IMCompile }
                  IF fICompile THEN WRITELN(icFile, 'fTest := fMouseMoved;');
{$ENDC }
                  IF IMtst THEN WRITELN('Testing MouseMoved. fTest : ', fTest);
                  END;
             'S': BEGIN
                  fTest := fMouseStopped;
{$IFC IMCompile }
                  IF fICompile THEN WRITELN(icFile, 'fTest := fMouseStopped;');
{$ENDC }
                  IF IMtst THEN WRITELN('Testing MouseStopped fTest : ', fTest);
                  END;
             'L': BEGIN
                  fTest := fMMoveLeft;
{$IFC IMCompile }
                  IF fICompile THEN WRITELN(icFile, 'fTest := fMMoveLeft;');
{$ENDC }
                  IF IMtst THEN WRITELN('Testing MMoveLeft. fTest : ', fTest);
                  END;
             'R': BEGIN
                  fTest := fMMoveRight;
{$IFC IMCompile }
                  IF fICompile THEN WRITELN(icFile, 'fTest := fMMoveRight;');
{$ENDC }
                  IF IMtst THEN WRITELN('Testing MMoveRight. fTest : ', fTest);
                  END;
             'U': BEGIN
                  fTest := fMMoveUp;
{$IFC IMCompile }
                  IF fICompile THEN WRITELN(icFile, 'fTest := fMMoveUp;');
{$ENDC }
                  IF IMtst THEN WRITELN('Testing MMoveUp. fTest : ', fTest);
                  END;
             'D': BEGIN
                  fTest := fMMoveDown;
{$IFC IMCompile }
                  IF fICompile THEN WRITELN(icFile, 'fTest := fMMoveDown;');
{$ENDC }
                  IF IMtst THEN WRITELN('Testing MMoveDown. fTest : ', fTest);
                  END;
             OTHERWISE GobbleCmd(cchr, 'Invalid mouse test');
           END;
         END;
    'P': BEGIN {test pattern}
           IF IMtst THEN WRITELN(' Testing recorded pattern.');
             fTest := MatchPat(PartMatchNumber, matFailCode);
             IF IMtst OR fTstPat
               THEN WRITELN(' Match result: ', fTest, ' PartNum:',
                 PartMatchNumber:4, ' match fail code: ', matFailCode:4);
         END;
    OTHERWISE GobbleCmd(cchr, 'Invalid Test');
  END;
END;


{$S imiw }
PROCEDURE VarCommand(varSource: CHAR);
LABEL 900;
VAR
  varName: TKeyStr;
  varType: CHAR;
  vtp: TVarType;
  vtStr: TKeyStr;
  hstr: THStr255;
  hst: THVarTable;
  pvarRec: TPVarRec;
BEGIN
  IF (varSource = 'U') THEN hst := hUserVarTable
    ELSE IF InExercise THEN hst := hExzVarTable
    ELSE IF InLesson THEN hst := hLessonVarTable
    ELSE hst := hGlobalVarTable;
  varType := ReadUCScriptChar;
  CASE varType OF
    'I': vtp := TVInt;
    'B': vtp := TVBool;
    'S': vtp := TVStr;
    'C': vtp := TVChar;
    OTHERWISE BEGIN CmdError('Invalid variable type'); GOTO 900; END;
  END;
  IF NOT ArgStr(@varName, CKeySize, FALSE)
    THEN BEGIN CmdError('Cant read variable name'); GOTO 900; END;
  pvarRec := NewVarRec(varSource, varName, vtp);
  IF fICompile THEN
      BEGIN
      CASE varType OF
          'I': vtStr := 'TVInt';
          'B': vtStr := 'TVBool';
          'S': vtStr := 'TVStr';
          'C': vtStr := 'TVChar';
          END;
{$IFC IMCompile }
      WRITELN(icFile, 'cargVar := NewVarRec(''', varSource, ''', ''',
                                           varName, ''',', vtStr, ');');
{$ENDC }
      END;
  WITH pvarRec^ DO
    BEGIN
      CASE vtp OF
        TVInt: BEGIN
                 IF ArgInt(vInt, TRUE) THEN
                     BEGIN
{$IFC IMCompile }
                     IF fICompile THEN
                         WRITELN(icFile, 'cargVar^.vInt := cargInt;');
{$ENDC }
                     END
                 ELSE
                     BEGIN
                     CmdError('VarCommand Cant read number');
                     vInt := 0;
{$IFC IMCompile }
                     IF fICompile THEN
                         WRITELN(icFile, 'cargVar^.vInt := 0;');
{$ENDC }
                    END;
                 IF IMtst THEN WRITELN('Defined integer variable ', varName,
                              ' with initial value: ', vInt);
               END;
        TVChar: BEGIN
                  IF ArgChar(vChar) THEN
                      BEGIN
{$IFC IMCompile }
                      IF fICompile THEN
                           WRITELN(icFile, 'cargVar^.vChar := cargChar;');
{$ENDC }
                      END
                   ELSE BEGIN
                      CmdError('VarCommand Cant read char arg');
                      vChar := 'X';
{$IFC IMCompile }
                      IF fICompile THEN
                           WRITELN(icFile, 'cargVar^.vChar := ''X'';');
{$ENDC }
                      END;
                  IF IMtst THEN WRITELN('Defined char variable ', varName,
                              ' with initial value: ', vChar);
                END;
        TVBool: BEGIN
                  IF ArgBool(vBool) THEN
                     BEGIN
{$IFC IMCompile }
                     IF fICompile THEN
                         WRITELN(icFile, 'cargVar^.vBool := cargBool;');
{$ENDC }
                     END
                  ELSE
                     BEGIN
                     CmdError('VarCommand Cant read boolean arg');
                     vBool := FALSE;
{$IFC IMCompile }
                     IF fICompile THEN
                         WRITELN(icFile, 'cargVar^.vBool := FALSE;');
{$ENDC }
                     END;
                 IF IMtst THEN WRITELN('Defined boolean variable ', varName,
                              ' with initial value: ', vBool);
                END;
        TVStr: BEGIN
                 IF ArgStr(vHStr^, 255, TRUE) THEN
                     BEGIN
{$IFC IMCompile }
                     IF fICompile THEN
                         WRITELN(icFile, 'cargVar^.vHStr^^ := cargStr;');
{$ENDC }
                     END
                 ELSE
                     BEGIN
                     CmdError('VarCommand Cant read string arg.');
                     vHstr^^ := '';
{$IFC IMCompile }
                     IF fICompile THEN
                         WRITELN(icFile, 'cargVar^.vHStr^^ := '''';');
{$ENDC }
                     END;
                 IF IMtst THEN WRITELN('Defined string variable ', varName,
                              ' with initial value: ', vHStr^^);
               END;
      END;
    END;
  900:
END;


{$S imiw }
PROCEDURE WaitCommand;
VAR cchr: CHAR;
    argtime: TC;
BEGIN
  fWait := TRUE;
  REPEAT
    cchr := ReadUCScriptChar;
    CASE cchr OF
      'T': BEGIN
           IF NOT ArgInt(argtime, FALSE) THEN
               BEGIN
               CmdError('Cant read timeout time.  Using 10 seconds.');
               toWaitTime := 10;
               END
           ELSE toWaitTime := argtime;
           fWTimeout := TRUE;
           toWaitTime := toWaitTime * CTicksPerSec;
{$IFC IMCompile }
           IF fICompile THEN
               BEGIN
               WRITELN(icFile, 'toWaitTime := argTime;');
               WRITELN(icFile, 'fWTimeout := TRUE;');
               WRITELN(icFile, 'toWaitTime := toWaitTime * CTicksPerSec;');
               END;
{$ENDC }
           END;
      'B': BEGIN
           fWButton := TRUE;
           fWaitMouseResult := TRUE;
{$IFC IMCompile }
           IF fICompile THEN
               BEGIN
               WRITELN(icFile, 'fWButton := TRUE;');
               WRITELN(icFile, 'fWaitMouseResult := TRUE;');
               END;
{$ENDC }
           END;
{  Wait MouseMove/Stop - not currently used works in pre-copmpilation system
{  but no compilation has been implemented  -gb 10/14/83
{      'M': BEGIN
{             cchr := ReadUCScriptChar;
{             CASE cchr OF
{               'M': BEGIN
{                    fWMouseMoved := TRUE;
{                    fWaitMouseResult := TRUE;
{                    IF IMtst THEN WRITELN('Setting wait mouse moved');
{                    IF fWMouseStopped THEN
{                      WRITELN('Cant wait for both mouse moved and mouse stopped');
{                    fWMouseStopped := FALSE;
{                    msMoveTime := 0; { default msMoveTime in seconds }
{                    IF PeekScriptChar = '('
{                      THEN IF ArgInt(argtime, FALSE)
{                             THEN msMoveTime := argtime
{                             ELSE CmdError('Cant read mouse move time');
{                    msMoveTime := msMoveTime * CTicksPerSec;
{                    IF msMoveTime = 0 THEN msMoveTime := 20;
{                    END;
{               'S': BEGIN
{                      fWMouseStopped := TRUE;
{                      fWaitMouseResult := TRUE;
{                      IF IMtst THEN WRITELN('Setting wait mouse stopped');
{                      IF fWMouseMoved THEN
{                        WRITELN('Cant wait for both mouse moved and mouse stopped');
{                      fWMouseMoved := FALSE;
{                      msStopTime := 2; { default msStopTime in seconds }
{                      IF PeekScriptChar = '('
{                        THEN IF ArgInt(argtime, FALSE)
{                               THEN msStopTime := argtime
{                               ELSE CmdError('Cant read mouse stop time');
{                      msStopTime := msStopTime * CTicksPerSec;
{                    END;
{               OTHERWISE InvalidCmdChar(cchr, 'Invalid mouse wait sub command');
{             END;
{           END;
{  End of wait mouse-move/stop command  }
      'F': BEGIN
           fWFolder := TRUE;
           IF IMtst THEN WRITELN('Setting wait for folder operation.');
{$IFC IMCompile }
           IF fICompile THEN
               BEGIN
               WRITELN(icFile, 'fWFolder := TRUE;');
               END;
{$ENDC }
           END;
      'S': BEGIN
           fWSelection := TRUE;
           IF IMtst THEN WRITELN('Setting wait for selection.');
{$IFC IMCompile }
           IF fICompile THEN
               BEGIN
               WRITELN(icFile, 'fWSelection := TRUE;');
               END;
{$ENDC }
           END;
      'C': BEGIN
           fWCommand := TRUE;
           IF IMtst THEN WRITELN('Setting wait for Command.');
{$IFC IMCompile }
           IF fICompile THEN
               BEGIN
               WRITELN(icFile, 'fWCommand := TRUE;');
               END;
{$ENDC }
           END;
      OTHERWISE GobbleCmd(cchr, 'Invalid Wait');
    END;
  UNTIL NOT InCommand;
{$IFC IMCompile }
  IF fICompile THEN WRITELN(icFile, 'fWait := TRUE;');
  IF fICompile THEN ICNewProc(0);
{$ENDC }
END;


{$S imiw }
FUNCTION PartialMatchTest: TF;
VAR cchr: CHAR;
    fPart: TF;
BEGIN
  cchr := ReadUCScriptChar;
  IF (ORD(cchr) < ORD('0')) OR (ORD(cchr) > ORD('9'))
    THEN InvalidCmdChar(cchr, 'Missing partial match number')
    ELSE fPart := fTest OR ((ORD(cchr) - ORD('0')) = PartMatchNumber);
  IF IMtst THEN WRITELN('Partial match test ?', cchr, ' with partial match value:',
                  PartMatchNumber:3, ' returns: ', fPart);
{$IFC IMCompile }
  IF fICompile THEN
      WRITELN(icFile, 'IF fTest OR ', (ORD(cchr)-ORD('0')):1,
                       ' = PartMatchNumber) THEN');
{$ENDC }
  PartialMatchTest := fPart;
END;


{$S imiw }
FUNCTION SkipCommand(skipCode: CHAR): BOOLEAN;
VAR cchr: CHAR;
    bname: TLocStr;
    bpos: TFPos;
BEGIN
  SkipCommand := FALSE;
{$IFC IMCompile }
  IF fICompile THEN
      BEGIN
      CASE skipCode OF
         '+': WRITELN(icFile, 'IF fTest THEN');
         '-': WRITELN(icFile, 'IF NOT fTest THEN');
         '?': WRITELN(icFile, 'IF CPartTest THEN');
          END;
      cchr := ReadCmdChar;
      ScriptPos := ScriptPos-1; { we want to look at the command char again }
      IF cchr = 'B' THEN
          BEGIN
          WRITELN(icFile, '    CNextBlk(', icBlockNumber+2:1, ');');
          icSkipBlock := TRUE;
          END
      ELSE
          BEGIN
          ICBegin;
          icSkipCommand := TRUE;
          END;
      EXIT(SkipCommand);
      END;
{$ENDC }
  IF skipCode = '+' THEN
      BEGIN IF fTest THEN EXIT(SkipCommand); END
  ELSE IF skipCode = '-' THEN
      BEGIN IF (NOT fTest) THEN EXIT(SkipCommand); END
  ELSE IF skipCode = '?' THEN
      BEGIN IF PartialMatchTest THEN EXIT(SkipCommand); END;
  SkipCommand := TRUE;
  cchr := ReadCmdChar;
  IF cchr = 'B'
    THEN BEGIN
      bpos := IMFLinePos(PIMFS, (ScriptPos-1));
      cchr := ReadCmdChar;
      IF (cchr = 'B') OR (cchr = '∫')
        THEN BEGIN
          IF IMtst THEN WRITELN('Skipping a block');
          IF NOT ArgStr(@bname, CLocSize, FALSE) THEN bname := 'unnamed'
            ELSE BEGIN
                   IF cchr = '∫' THEN DecodeStr(@bname, CLocSize);
                   SetStartLoc('B', bname, bpos);
                   FinishCommand;
                 END;
          PushBlock(bname);
          SkipABlock('B', bname);
          IF IMtst THEN PrintSkipStuff;
         END
        ELSE BEGIN
          CmdError('Cant skip any structure except a Block in a conditional.');
          FinishCommand;
         END;
      END
     ELSE BEGIN
       IF IMtst THEN WRITELN('Skipping command.');
       FinishCommand;
      END;
END;


{$S imih }
PROCEDURE InterpretCommand;
LABEL 100;
VAR cchr: CHAR;
    imHeapBytes: TC;
BEGIN
{$IFC IMDebug }
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('Entering InterpretCommand - IMHeap is trashed STOP. hBytes:', imHeapBytes);
      Brk(3333);
      END;
{$ENDC }

{$IFC IMCompile }
  IF fICompile THEN IF NOT icInProc THEN ICNewProc(0);
{$ENDC }

100:
  InCommand := TRUE;
  cchr := ReadUCScriptChar;
{$IFC IMDebug }
  IF fEncoding THEN BEGIN
    IF IMtst
      THEN WRITELN('Encoding  command char: ', cchr, ORD(cchr));
    CASE cchr OF
      'B': DCBeginCommand;
      'D': DCDisplayCommand(FALSE);
      'E': DCEndCommand;
      'F': DCFldrCommand;
      'G': DCGoCommand;
      'I': DCIMStateCommand;
      'M': DCMenuCommand;
      'T': IF PeekUCScriptChar = 'F' THEN
               BEGIN
               DCChar(cchr);
               cchr := ReadUCScriptChar;
               DCFldrCommand;
               END
           ELSE BEGIN DCChar(cchr); DCDumpCommand; END;
      'A','C','H','K','O', 'P','R','S','U','V','W':
           BEGIN DCChar(cchr); DCDumpCommand; END;
      '+','-': BEGIN DCChar(cchr); GOTO 100; END;
      '?': BEGIN DCChar(cchr); cchr := ReadCmdChar; DCChar(cchr); {skip match number} GOTO 100; END;
      '(': IF CheckComment THEN GOTO 100;
      OTHERWISE CmdError('Invalid top level command char.');
    END;
   END
  ELSE
{$ENDC }

  IF fSkip AND (NOT fICompile) THEN BEGIN
    IF IMtst AND (cchr <> ' ')
      THEN WRITELN('Skipping  command char: ', cchr, ORD(cchr));
    CASE cchr OF
      ' '    : GOTO 100;
      'B': BeginCommand;
      'E': EndCommand;
      'L': LoopCommand;
      'T': IF CheckTag THEN TagCommand
              ELSE FinishCommand;  { skip test }
      'A','C','D','F','G','H','I','K','M','O', 'P','R','S','U','V','W':
           FinishCommand;
      '+','-': GOTO 100;
      '?': BEGIN cchr := ReadCmdChar; {skip match number} GOTO 100; END;
      '(': IF CheckComment THEN GOTO 100;
      '.': CommandDone;
      OTHERWISE CmdError('Invalid top level command char.');
    END;
   END
  ELSE BEGIN
    IF IMtst AND (cchr <> ' ')
      THEN WRITELN('Interpreting command char: ', cchr, ORD(cchr));
    IF logging THEN SysLog(102, @ScriptPtr^[ScriptPos-1]);
    CASE cchr OF
      ' ': GOTO 100;
      'A': AssignCommand;
      'B': BeginCommand;
      'C': ClearCommand;
      'D': DisplayCommand(LGobj);
      'E': EndCommand;
      'F': FolderCommand;
      'G': GoCommand;
      'H': HintCommand;
      'I': IMStateCommand;
      'L': LoopCommand;
      'M': AlterMenuCommand;
      'O': ButtonDefCommand;
      'P': PauseCommand;
      'R': RecordCommand;
      'S': SimulateCommand;
      'T': IF CheckTag THEN TagCommand ELSE TestCommand;
      'U': VarCommand(cchr);
      'V': VarCommand(cchr);
      'W': WaitCommand;
      '+', '-', '?': IF NOT SkipCommand(cchr) THEN GOTO 100;
      '(': IF CheckComment THEN GOTO 100;
      '.': CommandDone;
      OTHERWISE CmdError('Invalid top level command char.');
    END;
    fStepped := TRUE;
   END;
{$IFC IMCompile }
   IF fICompile THEN IF icInBlock THEN ICEnd;
{$ENDC }
END;


END.


ˇ