{******************************************************************************}
{*                                                                            *}
{*              LisaGuide : Copyright 1983, Apple Computer Inc.               *}
{*                                                                            *}
{******************************************************************************}



{$s im }
{$r- }

UNIT IMCore;


INTERFACE


USES {$U UnitStd.obj}   UnitStd,
     {$U UnitHz.obj}    UnitHz,
     {$U Storage.obj}   Storage,
     {$U QuickDraw.obj} QuickDraw,
     {$U FontMgr.obj}   FontMgr,
     {$U libos/SysCall.obj}   SysCall,
     {$U libos/PSysCall.obj}  PSysCall,
     {$U PmDecl       } PmDecl,
     {$U PMM          } PMM,
     {$U WM.Events}     Events,
     {$U WM.Folders}    Folders,
     {$U WM.Menus}      Menus,
     {$U WMLStd  }      WMLStd,
     {$U WMLSB   }      WMLSb,
     {$U WMLGrow }      WMLGrow,
     {$U AlertMgr.obj}  AlertMgr,
     {$U dbenv.obj}     dbenv,
     {$U fedec.obj}     fedec,
     {$U fld.obj}       FieldEdit,
     {$U apim/UnitIMF.obj}   UnitIMF;


CONST

  {$IFC NOT IMDebug }
    sDebug       = FALSE;
    cDebug       = FALSE;
    IMtst        = FALSE;
    IMERtst      = FALSE;
    IMMtst       = FALSE;
    IMStst       = FALSE;
    IMFldTst     = FALSE;
    fTstFldrs    = FALSE;
    IMScrTst     = FALSE;
    fTstSim      = FALSE;
    fTstPat      = FALSE;
    fTstTF       = FALSE;
    fTstTab      = FALSE;
    fScriptTrace = FALSE;
    fScriptPrint = FALSE;
    PrintEvtFlag = FALSE;
    ScriptEcho   = FALSE;
    kbdCommand   = FALSE;
  {$ENDC }

  NameLisaGuide = 'LisaGuide';
  blankItem = '.';

  ldsnPrint = 1; { LDSN for the print manager borrowed from lotus eventmgr -gb }

  CKeySize = 31;
  CMaxHints = 5;
  CMaxHeaps = 4;

  tySelCh = 5;  { kludge to replace value removed from field editor }

  CMaxIMFonts = 5;
  CMaxButtons = 5;

  CTicksPerSec = 50;

  CSBarHt = 15;
  CSBarWid = 23;

  CTEvtEvt = 1;
  CTCmdEvt = 2;
  CTSelEvt = 3;
  CTKeyEvt = 4;
  CTObjEvt = 5;
  CTNObEvt = 6;

  CBufDataSize = 500;

  CObjMove = 1;
  CObjSize = 2;
  CObjOpen = 3;
  CObjClose = 4;
  CObjKill = 5;
  CObjChgCont = 6;
  CObjSelect = 7;
  CObjDeSel = 8;
  CObjRename = 9;
  CObjDuplicate = 10;
  CObjOpnPad = 11;
  CObjPutBak = 12;
  CObjActivate = 13;
  CObjThumb = 14;
  CObjPage = 15;
  CObjArrow = 16;
  CObjDslAll = 17;
  CLastObjOp = 17;

  CGrpSel = 1;
  CHitSel = 2;
  CTglSel = 3;
  COpSel  = 4;

  CBaseLineSize = 16;

  CFstLine = 1;
  CLstLine = 2;
  CTxtLine = 3;
  CFldLine = 4;
  CBtnLine = 5;
  CBoxLine = 6; { this and higher are recursive (box) line types }
  CPBxLine = 7;

  btnOvalH = 14;
  btnOvalV = 10;
  CTextBtn = 1;

  CAlertHold = 20;

{ menu and item numbers }
  mTutor = 10;
  mEdit = 11;
  mControl = 12;
  mFControl = 13;
  mFlags = 14;
  mSim = 15;
  mTopics = 16;

  firstTMenu = mTutor;
  lastTMenu = mTopics;


TYPE
   TKeyStr = STRING[CKeySize];
   TFileStr = STRING[40];
   TStr40   = STRING[40];
   TStr1 = STRING[1];
   TStr5 = STRING[5];
   TStr20 = STRING[20];

   THStr255 = ^TPStr255;
   { TPStr255 = ^Str255; }
   TPF = ^TF;

   { these types are for the search table stuff }

   TPSrchRec = ^TSrchRec;
   TSrchRec = RECORD
                  key: TStr40;
                  data: TP;
                END;

   THSrchTable = ^TPSrchTable;
   TPSrchTable = ^TSrchTable;
   TSrchTable = RECORD
                  stNRecs, stMaxRecs, stGrowRecs, stStartRecs: TC;
                  stRecSize: TC;
                END;

   TPHintList = ^THintList;
   THintList = ARRAY[1..CMaxHints] OF TFPos;


  { these types are for the IMStream unit. }

   THButton = ^ TPButton;
   TPButton = ^TButton;
   TButton = RECORD
              btnName: TKeyStr;
              btnSize: Point;
              btnOffset: Point;
              btnFIdx: TC;
              btnFramed, btnPressed: TF;
              btnText: TKeyStr;
             END;


   TPFontRec = ^TFontRec;
   TFontRec = RECORD
                fontKey: TKeyStr;
                fontFam: TC;
                fontBase: TB;
                fontHt: TB;
              END;


   TPKindRec = ^TKindRec;
   TKindRec = RECORD
                kindKey: TKeyStr;
                kindId: TC;
              END;


  {  This is the imstream line definition stuff }

  THImsLine = ^TPImsLine;

  TLineType = TC;

  TLineSeq = RECORD
               sFstLine: THIMSLine;
               sLstLine: THIMSLine;
              END;

  TFstLine = TC;

  TLstLine = TC;

  TTxtLine = RECORD
               tChrCt: TC;
               tIndent, tFontIdx: TC;
               tChars: ARRAY [0..0] OF TB;
             END;

  TBoxLine = RECORD
               bLineSeq: TLineSeq;
               bXLine: THIMSLine;
               bLineCount: TC;
               bName: TStr20;
               bExchange, bFixedHt: TF;
             END;

  TBtnLine = RECORD
               pBtnIdx: TB;
               pBtnHPos: TC;
               pBtnSize: Point;
             END;

  TFldLine = RECORD
               fActSel: BOOLEAN;
               fSelOffset: Point;
               fBaseLine: TC;
               fhField: hndField;
               fhFState: hndFState;
             END;


  TPImsLine = ^TImsLine;
  TImsLine = RECORD
               lIdx: TC;
               lType: TC;
               lPrev, lNext: THIMSLine;
               lHt, lVDsp: TC;
               CASE TLineType OF
                 CFstLine:  (fst: TFstLine);
                 CLstLine:  (lst: TLstLine);
                 CTxtLine:  (txt: TTxtLine);
                 CBoxLine:  (box: TBoxLine);
                 CBtnLine:  (btn: TBtnLine);
                 CFldLine:  (fld: TFldLine);
                 CPBxLine:  (pbx: TBoxLine; pbxPos: Point);
             END;


  TLineData = RECORD
                dLFIdx: TC;
                dLHt, dLVDsp: TC;
                dLIndent: TC;
                dLWidth: TC;
              END;


  THWSLink = ^TPWSLink;

  THIMS = ^TPIMStream;
  TPIMStream = ^TIMStream;
  TIMStream =
    RECORD
      sTextBox: THImsLine;
      sField: THImsLine;
      sLineCount, sKeepCt: TC;
      sLineSeq: TLineSeq;
      sPosLineSeq: TLineSeq;
      sLink: THWSLink;
      sCanSelect: TF;
      sCanAddLines: TF;
      sDontErase: TF;
      sLineData: TLineData;
    END;


  THFldrInfo = ^TPFldrInfo;  { see below for record def }
  TPFldrInfo = ^TFldrInfo;

  THIMW      = ^TPIMWindow;
  TPIMWindow = ^TIMWindow;
  TIMWindow  =
    RECORD
      wPort: WindowPtr;
      wFldr: THFldrInfo;
      wLink: THWSLink;
      wRect: Rect;
      wDispRect: Rect;
      wHSbar: THSb;
      wVSbar: THSb;
    END;


  TPWSLink = ^TWSLink;
  TWSLink  =
    RECORD
      kNext: THWSLink;
      kOffset: Point;    { window pos of topLeft of stream }
      kWindow: THIMW;
      kStream: THIMS;
      kLPOffset: Point;  { kOffset at last display of window }
      kPrtRect: Rect; { window rect that needs to be reprinted }
    END;



  { Menu and Folder  data types }


  TMStr = STRING[30];

  TPMenuInfo = ^MenuInfo;

  THMenuDInf = ^TPMenuDInf;
  TPMenuDInf = ^TMenuDInf;
  TMenuDInf = RECORD
                mTitle: TMStr;
                nextMenu: THMenuDInf;
                mCItems: TC;
                mNumber: TC;
                mDispFlag: TF;
                mActiveFlag: TF;
                mLookupInfo: TPMenuInfo;
                mNameInfo: TPMenuInfo;
                mBarInfo: TPMenuInfo;
              END;

  THMenuLink = ^TPMenuLink;
  TPMenuLink = ^TMenuLink;
  TMenuLink = RECORD
                nextMenu: THMenuLink;
                menuInfo: THMenuDInf;
                fldrMDispFlag: TF;
               END;

  TPMenus   = ^TMenuList;
  TMenuList = RECORD
                firstMenu, lastMenu: THMenuLink;
                menuCount: TC;
              END;

  THFldrState = ^TPFldrState;
  TPFldrState = ^TFldrState;
  TFldrState = RECORD
                 fsInSelect, fsSelection: TF;
                 fsTimeout: TC;
                 fsNbrhood: Rect;
               END;

  THFilerObj = ^TPFilerObj;
  TPFilerObj = ^TFilerObj;
  TFilerObj  =  RECORD   { dummy place holder for ObjectHandle }
                 END;

  TFldrInfo = RECORD
                fldrName: TKeyStr;
                nextFldr: THFldrInfo;
                fldrID: TC;
                fldrHz: THz;
                fldrPort: WindowPtr;
                fldrDefPos: Point;
                fldrDefSize: Point;
                fldrDispWindow: THIMW;
                fldrMenuList: TMenuList;
                fldrState: THFldrState;
                fldrFObj:  THFilerObj;
                fldrSBList: TSBList;
                fldrVis, fldrActive, fldrSBars: TF;

              END;



  { Event recording data types }

  THEBufData = ^TPEBufData;
  TPEBufData = ^TEBufData;

  TEBufData = RECORD
              BufSize: TC;
              BufPos: TC;
              NxtBuf: THEBufData;
              BufData: TArgch;
            END;


  THEvtBuf = ^TPEvtBuf;
  TPEvtBuf = ^TEvtBuf;

  TEvtBuf = RECORD
              FirstBuf: THEBufData;
              LastBuf: THEBufData;
            END;


  TEvtRec = RECORD
              EvtType: TB;
              EvtSize: TB;
              EvtData: TArgch;
            END;


  TPAObj = ^TAObj;
  TAObj = RECORD
            toName:     TStr40;
            toLoc:      Point;
            toKind:     TB;
            toSubKind:  TB;
            toState:    TB;
            toNext:     TB;
            toPrev:     TB;
            toFather:   TB;
            toSons:     TB;
            toVol:      TP;
            toCatId:    TL;
            toCTime:    TL;
           END;

  THObjTable = THSrchTable;

  TPCmdRec = ^TCmdRec;
  TCmdRec = RECORD
              CmdType: TB;
              CmdSize: TB;
              CmdMenu: TB;
              CmdItem: TB;
              CmdKey:  TF;
            END;

  TPSelRec = ^TSelRec;
  TSelRec = RECORD
              SelType:  TB;
              SelSize:  TB;
              SelLnLen: TB;
              SelFldr:  TB;
              SelLnIdx: TC;
              SelLevel: TB;
              SelAdjust: TF;
              SelInt:   interval;
              SelLnData: TArgch;
            END;

  TPKeyRec = ^TKeyRec;
  TKeyRec = RECORD
              KeyType: TB;
              KeySize: TB;
              KeyCh:   TB;
              KeyFldr: TB;
              KeyShift:  TF;
              KeySpecial: TF;
              KeyCmd:  TF;
            END;

  TPObjRec = ^TObjRec;
  TObjRec = RECORD
              ObjType: TB;
              ObjSize: TB;
              ObjOp:   TB;
              ObjIdx:  TB;
              ObjInt1: TC;
              ObjInt2: TC;
            END;

  TPNObjRec = ^TObjRec;
  TNObjRec = RECORD
              ObjType: TB;
              ObjSize: TB;
              ObjOp:   TB;
              ObjIdx:  TB;
              ObjNName:TStr40;
            END;


  TPEvtRec = ^TEvtTypeRec;
  TEvtTypeRec = RECORD
               CASE TC OF
                 CTEvtEvt: (Evt: TEvtRec);
                 CTCmdEvt: (Cmd: TCmdRec);
                 CTSelEvt: (Sel: TSelRec);
                 CTKeyEvt: (Key: TKeyRec);
                 CTObjEvt: (Obj: TObjRec);
                 CTNObEvt: (NOb: TNObjRec);
               END;



VAR

  {$IFC IMDebug }
    sDebug:       BOOLEAN;
    cDebug:       BOOLEAN;
    IMtst:        BOOLEAN;
    IMERtst:      BOOLEAN;
    IMMtst:       BOOLEAN;
    IMStst:       BOOLEAN;
    IMFldTst:     BOOLEAN;
    fTstFldrs:    BOOLEAN;
    IMScrTst:     BOOLEAN;
    fTstPat:      BOOLEAN;
    fTstTF:       BOOLEAN;
    fTstTab:      BOOLEAN;
    fTstSim:      BOOLEAN;
    fScriptTrace: BOOLEAN;
    fScriptPrint: BOOLEAN;
    PrintEvtFlag: BOOLEAN;
    ScriptEcho:   BOOLEAN;
    kbdCommand:   BOOLEAN;

    TFCount:      INTEGER;
  {$ENDC }

    imLdsn:        TC;
    imHRefNum:     TC;
    imSegName:     e_name;

    IMHeap:        THz;
    StrHeap:       THz;

    scrollFont:    TC;
    IMFontFam:     TC;
    IMFontIdx:     TB;
    SysFontIdx:    TB;

    imVolName:     e_name;
    imToolName:    e_name;
    UnderFiler:    TF;

    IMAlert:       TAlertFile;
    phraseRef:     TC;
    alertDown:     TL;

    NullRect:      Rect;

    PHintList:     TPHintList;
    HintCount:     TC;
    LastHint:      TC;
    HintStr:       THIMS;
    HintDisplayed: TF;

    ContBtnIdx:    TC;
    DemoBtnIdx:    TC;
    PracBtnIdx:    TC;

    curEvtBuf:     THEvtBuf;
    curObjTable:   ThObjTable;
    ObjOpArray:    ARRAY[1..CLastObjOp] OF TStr20;

    hndLGFldr:     THFldrInfo;
    LGStr:         THIMS;
    LGWindow:      THIMW;
    LastLGLine:    THImsLine;
    LGPort:        GrafPtr;
    LGPortWidth:   TC;

    hndScriptFldr: THFldrInfo;
    ScriptStr:     THIMS;

    hndAlertFldr:  THFldrInfo;
    hScrapFldr:    THFldrInfo;
    hndDefFldr:    THFldrInfo;

    hndActiveFldr: THFldrInfo;
    ActiveWSLink:  THWSLink;
    ActivePort:    GrafPtr;

    fSelection:     TF;
    fInSelect:      TF;
    fAdjustSel:     TF;
    selTimeout:     TC;
    selNbrhood:     Rect;

    bigNbrhood:     Rect;
    curNbrhood:     Rect;

    WidPort:       GrafPtr;
    WidPortData:   GrafPort;

    hIMFontTable:  THSrchTable;
    hIMButtonTab:  THSrchTable;
    hKindTable:    THSrchTable;

    hODefTable:    THSrchTable; { initialized in iminterp }

    TutorBarMenus:    ARRAY [firstTMenu..lastTMenu] OF MenuInfo;
    TutorNameMenus:   ARRAY [firstTMenu..lastTMenu] OF MenuInfo;
    TopicLookupMenu:  MenuInfo;
    MasterMenuList:   TMenuList;

    TutorMInfo:    THMenuDInf;
    EditMInfo:     THMenuDInf;
    CtrlMInfo:     THMenuDInf;
    FCtrlMInfo:    THMenuDInf;
    FlagsMInfo:    THMenuDInf;
    SimMInfo:      THMenuDInf;
    TopicsMInfo:   THMenuDInf;
    FilingMInfo:   THMenuDInf;
    ViewMInfo:     THMenuDInf;
    FlrEditMInfo:  THMenuDInf;
    FlrDiskMInfo:  THMenuDInf;
    SpecMInfo:     THMenuDInf;

    UndoMItem:     TC;
    UndoEnabled:   TF;


{ Run Flags }
    fTest:             BOOLEAN;
    fWait:             BOOLEAN;
    fPause:            BOOLEAN;
    fQuit:             BOOLEAN;
    toldToDie:         TF;
    PartMatchNumber:   TC;


{Wait Flags}
    fWaitMouseResult:  TF;
    fWMouseMoved:      TF;
    fWMouseStopped:    TF;
    fWTimeout:         TF;
    fWButton:          TF; {wait for button down}
    fWFolderCmd:       TF;
    fWSelection:       TF; {wait for a selection to be made}
    fWCommand:         TF; {wait for a command to be executed}
    msMoveTime:        TL;
    msMoveStartTime:   TL;
    msMoveEndTime:     TL;
    msStopTime:        TL;
    msStopStartTime:   TL;
    msStopEndTime:     TL;
    toWaitTime:        TL;
    toWaitStartTime:   TL;
    toWaitEndTime:     TL;

{ Event recording flags }
    fRSelections:      TF;
    fRInsertion:       TF;
    fRKeyboard:        TF;
    fREditKbd:         TF;
    fRCommands:        TF;
    fRObjects:         TF;

{ Wait result flags }
    fTimeout:          TF;
    fButton:           TF;
    fContinue:         TF;
    fMouseMoved:       TF;
    fMouseStopped:     TF;
    fMMoveLeft:        TF;
    fMMoveRight:       TF;
    fMMoveUp:          TF;
    fMMoveDown:        TF;


PROCEDURE HoldIt(fTypeIn: TF);
PROCEDURE Brk(bnum: TC);
FUNCTION  GetYorN: BOOLEAN;
PROCEDURE AskFlag(PF: TPF; FName: Str255);
PROCEDURE ToggleFlag(PF: TPF; FName: Str255);
FUNCTION  IsNull(VAR rct: Rect): TF;
PROCEDURE FreeObjTable;
FUNCTION  ValInRange(numval, testval, errval: TC): TF;

{ event recording stuff }
PROCEDURE PxEvtBuf(ebuf: THEvtBuf);
PROCEDURE FreeEvtBuf(ebuf: THEvtBuf);
FUNCTION  CreateEvtBuf: THEvtBuf;
PROCEDURE ClearEvtBuf(ebuf: THEvtBuf);
PROCEDURE AddCmdRec(ebuf: THEvtBuf; menu, item: TB; keyflg: TF);
PROCEDURE AddSelRec(ebuf: THEvtBuf; lnIdx, lnLen:TC; lchars: TRgch;
                    sRec: txSel; fldr: THFldrInfo; fAdjust: TF);
PROCEDURE AddKeyEvt(ebuf: THEvtBuf; ch: TB; shftflg, specflg,
                    cmdflg: TF; fldr: THFldrInfo);
PROCEDURE Add4ObjEvt(ebuf: THEvtBuf; oOp: TB; oIdx: TB);
PROCEDURE Add6ObjEvt(ebuf: THEvtBuf; oOp: TB; oIdx: TB; int1: TC);
PROCEDURE Add8ObjEvt(ebuf: THEvtBuf; oOp: TB; oIdx: TB; int1, int2: TC);
PROCEDURE AddNObjEvt(ebuf: THEvtBuf; oOp: TB; oIdx: TB; rName: TStr40);

PROCEDURE ClearRecordingFlags;
PROCEDURE ClearWaitFlags;
PROCEDURE ClearResultFlags;
PROCEDURE StrangeError(estr: Str255);
FUNCTION  HeapError(hz: THz; bytesNeeded: TC): TC;
PROCEDURE InterpError(errStr: Str255);
PROCEDURE InterpIError(errStr: Str255; errInt: TC);
FUNCTION  HZCreate(cb: TL; heapSeg: e_name; hLDSN: TC; VAR hRefnum: TC): THz;

PROCEDURE IMAlertUp;
PROCEDURE PullAlert;

FUNCTION  TxtWidth(lrgch: TRgch; chrCt: TC; ffam: TC): TC;
FUNCTION  TxtStrWidth(tStr: Str255; ffam: TC): TC;

PROCEDURE GetBtnKey(VAR bKey: TKeyStr; bIdx: TC);
FUNCTION  BtnIdxFromName(bKey: TKeyStr): TC;
FUNCTION  GetButtonRec(bIdx: TC): TPButton;
FUNCTION  NewIMButton(bName, bText: TKeyStr; bFidx: TC; bFramed: TF): TC;
PROCEDURE SetBtnSize(bIdx: TC; bSize: Point);
PROCEDURE SetBtnOffset(bIdx: TC; bOffset: Point);
PROCEDURE PressBtn(bIdx: TC; fPress: TF; bPos: Point);
PROCEDURE ClearBtn(bIdx: TC);
PROCEDURE DrawButton(bIdx: TC; bPos: Point);
FUNCTION  HitInButton(bIdx: TC; bPos, hitPos: Point; fPress: TF): TF;
FUNCTION  TestIMButton(bIdx: TC; bPos, hitPos: Point; VAR pressFlag: TF): TF;

FUNCTION  AddIMFont(fKey: TKeyStr; fFam: TC): TC;
PROCEDURE GetFontKey(VAR fKey: TKeyStr; fIdx: TC);
FUNCTION  GetFontRec(fIdx: TC): TPFontRec;
FUNCTION  FIdxFromName(fKey: TKeyStr): TC;
FUNCTION  FontIndex(ffam: TC): TC;
FUNCTION  FontHt(fontIdx: TC): TC;
FUNCTION  FontBase(fontIdx: TC): TC;
FUNCTION  FontFam(fontIdx: TC): TC;

PROCEDURE AddKindRec(kKey: TKeyStr; kID: TC);

PROCEDURE ActiveFldr(hndFldr: THFldrInfo);
PROCEDURE GetFldr(hndFldr: THFldrInfo);
PROCEDURE HideFldr(hndFldr: THFldrInfo);

PROCEDURE IMCoreInit;
PROCEDURE CharStr1(sch: CHAR; VAR str1: TStr1);
PROCEDURE IntStr20(sint: TC; VAR str20: TStr20);
PROCEDURE BoolStr5(sbool: TF; VAR str5: TStr5);

{ lookup table stuff }
FUNCTION  CreateSrchTable(recSize, maxRecs, growRecs: TC): THSrchTable;
PROCEDURE ReSizeSrchTable(hst: THSrchTable; newRecCt: TC);
FUNCTION  DumpSrchTable(hsTable: THSrchTable; fName: PathName): TF;
FUNCTION  ReadSrchTable(hsTable: THSrchTable; fName: PathName): TF;
FUNCTION  NewSrchTableRec(hst: THSrchTable; VAR recN: TC): TPSrchRec;
FUNCTION  NthSrchTableRec(hst: THSrchTable; rIdx: TC): TPSrchRec;
FUNCTION  FindSrchTableRec(hst: THSrchTable; srchKey: TStr40): TPSrchRec;
FUNCTION  FindNthSrchTableRec(hst: THSrchTable; srchKey: TStr40;
                              VAR rIdx: TC): TPSrchRec;
FUNCTION  ReDefSrchTableRec(hst: THSrchTable; srchKey: TStr40;
                            VAR rIdx: TC; VAR fNew: TF): TPSrchRec;
PROCEDURE ClearSrchTable(hst: THSrchTable);
PROCEDURE FreeSrchTable(hst: THSrchTable);

{***  Exported Debugging Functions ***}

FUNCTION SorocChar: CHAR;
PROCEDURE WaitForSpaceBar;
PROCEDURE Hold(ticks: INTEGER);
PROCEDURE PrintPoint(pt: Point);
PROCEDURE PrintRect(r: Rect);
PROCEDURE PrtRgnBBox(regn: RgnHandle);
PROCEDURE PrintPort(gp: GrafPtr);
PROCEDURE PrtEvtType(eptr: EventPtr);
PROCEDURE PrintEvent(eptr: EventPtr);
PROCEDURE IdRegion(name: Str255; regn: RgnHandle; htime: INTEGER;
           gprt, deskPort: GrafPtr);



IMPLEMENTATION


{$IFC NOT IMDebug }
CONST
    fMemRes      = TRUE;
{$ENDC }

{$IFC IMDebug }
VAR
    fMemRes:      BOOLEAN;
{$ENDC }

PROCEDURE FailedInit; EXTERNAL;


{$S imcdbg }
PROCEDURE HoldIt; { (fTypeIn: TF); }
VAR x, i: TC;
BEGIN
  IF fTypeIn THEN BEGIN
     WRITELN('Type <cr> to continue');
     READLN;
    END
   ELSE FOR i := 1 to 1000 DO BEGIN x := i; END;
END;


{$S imcdbg }
PROCEDURE Brk; { (bnum: TC); }
BEGIN
  IF sDebug  THEN WRITELN('IM Break ', bnum:4);
  IF cDebug THEN BREAK(bnum);
END;


{$S imcdbg }
FUNCTION GetYorN; {: BOOLEAN;}
VAR ans, gotans: BOOLEAN;
    ch: CHAR;
BEGIN
  ans := FALSE;
  gotans := FALSE;
  REPEAT
    WRITE(' Y or N ... ');
    READ(ch);
    IF (ch = 'y') OR (ch = 'Y') THEN BEGIN gotans := TRUE; ans := TRUE; END;
    IF (ch = 'n') OR (ch = 'N')  OR (ch = ' ')
      THEN BEGIN gotans := TRUE; ans := FALSE; END;
  UNTIL gotans;
  WRITELN;
  GetYorN := ans;
END;


{$S imcdbg }
PROCEDURE AskFlag; {(PF: TPF; FName: Str255);}
BEGIN
  WRITE('Enter value for ', FName, ': ');
  PF^ :=  GetYorN;
  IF PF^
    THEN WRITELN(FName, ' set to True')
    ELSE WRITELN(FName, ' set to False');
END;

{$S imcdbg }
PROCEDURE ToggleFlag; {(PF: TPF; FName: Str255);}
BEGIN
  IF PF^
    THEN BEGIN PF^ := FALSE; WRITELN(FName, ' changed to False'); END
    ELSE BEGIN PF^ :=  TRUE; WRITELN(FName, ' changed to True'); END;
END;

{$S imch }
FUNCTION IsNull;  { (VAR rct: Rect): TF; }
BEGIN
  IsNull := FALSE;
  IF rct.top = 0
    THEN IF rct.left = 0
      THEN IF rct.right = 0
        THEN IF rct.bottom = 0
          THEN IsNull := TRUE;
END;


{$S imcw }
FUNCTION ValInRange;  { (numval, testval, errval: TC): TF; }
BEGIN
  IF numval >= testval-errval
    THEN BEGIN
      IF numval <= testval+errval
        THEN BEGIN
          IF IMtst THEN
            WRITELN(numval, ' is in range', testval, ' +/-', errval);
          ValInRange := TRUE;
         END
        ELSE BEGIN
          IF IMtst THEN
            WRITELN(numval, ' above range', testval, ' +/-', errval);
          ValInRange := FALSE;
         END;
     END
    ELSE BEGIN
      IF IMtst THEN
        WRITELN(numval, ' below range', testval, ' +/-', errval);
      ValInRange := FALSE;
     END;
END;

{  event recording code }

{$S imrini }
PROCEDURE LoadOpsList;
BEGIN
  ObjOpArray[1] := 'ObjMove';
  ObjOpArray[2] := 'ObjSize';
  ObjOpArray[3] := 'ObjOpen';
  ObjOpArray[4] := 'ObjClose';
  ObjOpArray[5] := 'ObjKill';
  ObjOpArray[6] := 'ObjChgCont';
  ObjOpArray[7] := 'ObjSelect';
  ObjOpArray[8] := 'ObjDeSel';
  ObjOpArray[9] := 'ObjRename';
  ObjOpArray[10] := 'ObjDuplicate';
  ObjOpArray[11] := 'ObjOpnPad';
  ObjOpArray[12] := 'ObjPutBak';
  ObjOpArray[13] := 'ObjActivate';
  ObjOpArray[14] := 'ObjThumb';
  ObjOpArray[15] := 'ObjPage';
  ObjOpArray[16] := 'ObjArrow';
  ObjOpArray[17] := 'ObjDslAll';
END;


{$S imrw }
PROCEDURE FreeDataBuf(buf: THEBufData);
BEGIN
  IF IMERTst THEN WRITELN('Freeing event data buf: ', ORD(buf));
  FreeBk(IMHeap, POINTER(ORD(buf)), tybkStd);
END;


{$S imrw }
FUNCTION NewDataBuf(dsize: TC): THEBufData;
VAR dbuf: THEBufData;
BEGIN
  dbuf := POINTER(ORD(HAllocate(IMHeap, SIZEOF(TEBufData) + dsize)));
  IF IMERTst THEN WRITELN('New event data buf: ', ORD(dbuf), ' size: ', dsize);
  WITH dbuf^^ DO
    BEGIN
      BufSize := dsize;
      BufPos := 0;
      NxtBuf := NIL;
    END;
  NewDataBuf := dbuf;
END;

{$S imrh }
PROCEDURE StepDataBuf(VAR dbuf: THEBufData; VAR bpos: TC);
BEGIN
  IF dbuf <> NIL THEN
    WITH dbuf^^ DO
      BEGIN
        IF bpos < 0
          THEN bpos := 0
          ELSE
            bpos := bpos + BufData[bpos+1];
        IF bpos >= BufPos
          THEN BEGIN
             dbuf := NxtBuf;
             bpos := -1;
             StepDataBuf(dbuf, bpos);
           END
      END;
END;

{  Internal print routines - not compiled when IMDebug is off }

{$S imrdbg }
  PROCEDURE PxCmdRec(pcrec: TPEvtRec);
  BEGIN
   {$IFC IMDebug }
    WITH pcrec^.Cmd DO
      WRITELN('Cmd event: size=', CmdSize:4, ' menu:', CmdMenu:4, ' item:', CmdItem:4,
                 ' keyFlag: ', CmdKey);
   {$ENDC }
  END;

{$S imrdbg }
  PROCEDURE PxSelRec(psrec: TPEvtRec);
  VAR i: TC;
  BEGIN
   {$IFC IMDebug }
    WITH psrec^.Sel DO
      BEGIN
        WRITELN('Select event: size=', SelSize:4, ' LnLen:', SelLnLen:4,
                 ' SelLnIdx: ', ORD(SelLnIdx));
        WRITELN('  select level: ', ORD(SelLevel):2, ' startPos:', SelInt.lpFst,
                 ' limPos:', SelInt.lpLim);
        WRITE('  - ');
        FOR i := 0 TO SelLnLen-1 DO
          WRITE(CHR(SelLnData[i]));
        WRITELN;
      END;
   {$ENDC }
  END;


{$S imrdbg }
  PROCEDURE PxKeyRec(pkrec: TPEvtRec);
  BEGIN
   {$IFC IMDebug }
    WITH pkrec^.Key DO
      BEGIN
        WRITELN('Key event: size=', KeySize:4, ' Char:', KeyCh,
                 ' (ascii: ', ORD(KeyCh):3);
        WRITELN('  shift flag: ', KeyShift, ' special flag:', KeySpecial,
                 ' cmd flag: ', KeyCmd);
      END;
   {$ENDC }
  END;


{$S imrdbg }
  PROCEDURE PxObjRec(pfrec: TPEvtRec);
  BEGIN
   {$IFC IMDebug }
    WITH pfrec^.Obj DO
      BEGIN
        WRITELN('Obj event ', ObjOpArray[ObjOp], ' ObjIdx: ', ObjIdx,
                ' evtSize=', ObjSize:4);
        IF ObjSize > 4 THEN BEGIN
          WRITE('  ObjInt1: ', ObjInt1);
          IF ObjSize > 6 THEN WRITE(' ObjInt2:', ObjInt2);
          WRITELN;
         END;
      END;
   {$ENDC }
  END;


{$S imrdbg }
  PROCEDURE PxEvtRec(perec: TPEvtRec);
  BEGIN
   {$IFC IMDebug }
    WITH perec^.Evt DO
      CASE EvtType OF
        CTCmdEvt: PxCmdRec(perec);
        CTSelEvt: PxSelRec(perec);
        CTKeyEvt: PxKeyRec(perec);
        OTHERWISE WRITELN('Invalid event rec at: ', ORD(perec), ' type:', EvtType);
      END;
   {$ENDC }
  END;



{$S imrdbg }
PROCEDURE PxEvtBuf; { (ebuf: THEvtBuf); }
VAR dbuf: THEBufData;
    bpos: TC;
BEGIN
 {$IFC IMDebug }
  WITH ebuf^^ DO
    BEGIN
      WRITELN('Event buffer handle: ', ORD(ebuf));
      WRITELN(' FirstBuf: ', ORD(FirstBuf), '  LastBuf: ', ORD(LastBuf));
      dbuf := FirstBuf;
      bpos := -1;
      StepDataBuf(dbuf, bpos);
      WHILE dbuf <> NIL DO
        BEGIN
          IF bpos = 0 THEN
            WRITELN('**DataBuf:', ORD(dbuf), ' with BufPos: ', dbuf^^.BufPos);
          PxEvtRec(@dbuf^^.BufData[bpos]);
          WRITELN('  at buf pos: ', bpos);
          StepDataBuf(dbuf, bpos);
        END;
      WRITELN;
    END;
 {$ENDC }
END;


{$S imrw }
{PROCEDURE AddEvtBufRec; { (ebuf: THEvtBuf; recType, recSize: TC;  recData: TRgch); }
{VAR nbuf: THEBufData;
{BEGIN
{  recSize := recSize + 2; { add in the bytes for recType and recSize. }
{  WITH ebuf^^ DO
{    IF LastBuf^^.BufPos + recSize > LastBuf^^.BufSize
{      THEN BEGIN
{        nbuf := NewDataBuf(CBufDataSize);
{        LastBuf^^.NxtBuf := nbuf;
{        LastBuf := nbuf;
{       END;
{  WITH ebuf^^.LastBuf^^ DO
{    BEGIN
{      BufData[0] := recType;
{      BufData[1] := recSize;
{      MoveRgch(@BufData[2], recData, recSize);
{      BufPos := BufPos + recSize;
{    END;
{END;
}


{$S imrc }
FUNCTION  CreateEvtBuf; { :THEvtBuf; }
VAR ebuf: THEvtBuf;
    dbuf: THEBufData;
BEGIN
  IF IMERTst THEN WRITELN('Creating Event Buf');
  ebuf := POINTER(ORD(HAllocate(IMHeap, SIZEOF(TEvtBuf))));
  IF IMERTst THEN WRITELN('Creating new Event buf: ', ORD(ebuf));
  WITH ebuf^^ DO
    BEGIN
      FirstBuf := NewDataBuf(CBufDataSize);
      LastBuf := FirstBuf;
    END;
  LoadOpsList;  { really a once only initialization }
  CreateEvtBuf := ebuf;
END;


{$S imrw }
PROCEDURE ClearEvtBuf; { (ebuf: THEvtBuf); }
VAR rbuf, nbuf: THEBufData;
BEGIN
  WITH ebuf^^ DO
    BEGIN
      IF IMERTst THEN
        WRITELN('Clearing event buf:', ORD(ebuf), ' FirstBuf:', ORD(FirstBuf),
                 ' LastBuf:', ORD(LastBuf));
      IF LastBuf <> FirstBuf
        THEN BEGIN
          rbuf := FirstBuf^^.NxtBuf;
          WHILE rbuf <> NIL
            DO BEGIN nbuf := rbuf^^.NxtBuf;
                 FreeDataBuf(rbuf);
                 rbuf := nbuf;
               END;
          LastBuf := FirstBuf;
         END;
      FirstBuf^^.BufPos := 0;
      FirstBuf^^.NxtBuf := NIL;
    END;
END;


{$S imrh }
FUNCTION NextEvtBufRec(ebuf: THEvtBuf; recType, recSize: TC): TPEvtRec;
VAR nbuf: THEBufData;
BEGIN
  { recSize := recSize + 2; add in the bytes for recType and recSize. }
  IF IMERTst THEN WRITELN('Getting next evt buf pos. ebuf:', ORD(ebuf),
        'size: ', recSize, ' type:', recType);
  WITH ebuf^^ DO IF LastBuf^^.BufPos + recSize > LastBuf^^.BufSize
      THEN BEGIN
        nbuf := NewDataBuf(CBufDataSize);
        LastBuf^^.NxtBuf := nbuf;
        LastBuf := nbuf;
       END;
  WITH ebuf^^.LastBuf^^ DO
    BEGIN
      NextEvtBufRec := @BufData[BufPos];
      IF IMERTst THEN WRITELN('NextEvtBuf in data buf:', ORD(ebuf^^.LastBuf),
                       ' at pos:', BufPos, ' address:', ORD(@BufData[BufPos]));
      BufData[BufPos] := recType;
      BufData[BufPos + 1] := recSize;
      BufPos := BufPos + recSize;
    END;
END;


{$S imrw }
PROCEDURE FreeEvtBuf; { (ebuf: THEvtBuf); }
VAR rbuf, nbuf: THEBufData;
BEGIN
  rbuf := ebuf^^.FirstBuf;
  WHILE rbuf <> NIL
    DO BEGIN nbuf := rbuf^^.NxtBuf;
         FreeDataBuf(rbuf);
         rbuf := nbuf;
       END;
  FreeBk(IMHeap, POINTER(ORD(ebuf)), tybkStd);
END;


{$S imrh }
PROCEDURE AddCmdRec; { (ebuf: THEvtBuf; menu, item: TB; keyflg: TF); }
VAR rsiz: TC;
    pcrec: TPEvtRec;
BEGIN
  rsiz := SIZEOF(TCmdRec);
  rsiz := rsiz + (rsiz MOD 2); { makle sure its an even length - or else! }
  pcrec := NextEvtBufRec(ebuf, CTCmdEvt, rsiz);
  WITH pcrec^.Cmd DO
    BEGIN
      CmdMenu := menu;
      CmdItem := item;
      CmdKey := keyflg;
    END;
  IF IMERTst THEN WRITELN('Adding cmd event to buf:', ORD(ebuf), ' at pos:',
                           ebuf^^.LastBuf^^.BufPos);
  IF IMERTst THEN PxCmdRec(pcrec);
END;


{$S imrh }
PROCEDURE AddSelRec; { (ebuf: THEvtBuf; lnIdx, lnLen:TC; lchars: TRgch;
                        sRec: txSel; fldr: THFldrInfo; fAdjust: TF); }
VAR rsiz: TC;
    psrec: TPEvtRec;
BEGIN
  rsiz := SIZEOF(TSelRec) + lnLen + 1;
  rsiz := rsiz - (rsiz MOD 2);  {we allocated an extra word above}
  IF IMERTst THEN WRITELN('Add Sel event of size: ', rsiz, ' for buf:',
                           ORD(ebuf));
  psrec := NextEvtBufRec(ebuf, CTSelEvt, rsiz);
  IF IMERTst THEN WRITELN('sel rec goes at:', ORD(psrec));
  WITH psrec^.Sel DO
    BEGIN
      SelLnLen := lnLen;
      SelFldr := fldr^^.fldrID;
      SelLnIdx :=  lnIdx;
      SelLevel := ORD(sRec.tySel);
      SelInt := sRec.int;
      IF (SelLevel = ORD(tySelPt)) AND (SelInt.lpFst < SelInt.lpLim)
        THEN SelLevel := tySelCh;
      MoveRgch(@SelLnData, lchars, SelLnLen);
      SelAdjust := fAdjust;
    END;
  IF IMERTst THEN WRITELN('Adding sel event to buf:', ORD(ebuf), ' at adr:',
                           ORD(psrec));
  IF IMERTst THEN PxSelRec(psrec);
END;


{$S imrh }
PROCEDURE AddKeyEvt;  { (ebuf: THEvtBuf; ch: TB; shftflg, specflg,
                         cmdflg: TF; fldr: THFldrInfo);  }
VAR rsiz: TC;
    pkrec: TPEvtRec;
BEGIN
  rsiz := SIZEOF(TKeyRec);
  rsiz := rsiz + (rsiz MOD 2); { makle sure its an even length - or else! }
  pkrec := NextEvtBufRec(ebuf, CTKeyEvt, rsiz);
  WITH pkrec^.Key DO
    BEGIN
      KeyCh := ch;
      KeyFldr := fldr^^.fldrID;
      KeyShift := shftflg;
      KeySpecial := specflg;
      KeyCmd := cmdflg;
    END;
  IF IMERTst THEN WRITELN('Adding key event to buf:', ORD(ebuf), ' at pos:',
                           ebuf^^.LastBuf^^.BufPos);
  IF IMERTst THEN PxKeyRec(pkrec);
END;


{$S imrh }
PROCEDURE Add4ObjEvt; { (ebuf: THEvtBuf; oOp: TB; oIdx: TB); }
VAR rsiz: TC;
    pfrec: TPEvtRec;
BEGIN
  rsiz := 4;
  pfrec := NextEvtBufRec(ebuf, CTObjEvt, rsiz);
  WITH pfrec^.Obj DO
    BEGIN
      ObjOp := oOp;
      ObjIdx := oIdx;
    END;
  IF IMERTst THEN WRITELN('Adding obj event to buf:', ORD(ebuf), ' at pos:',
                           ebuf^^.LastBuf^^.BufPos);
  IF IMERTst THEN PxObjRec(pfrec);
END;


{$S imrh }
PROCEDURE Add6ObjEvt; { (ebuf: THEvtBuf; oOp: TB; oIdx: TB; int1: TC); }
VAR rsiz: TC;
    pfrec: TPEvtRec;
BEGIN
  rsiz := 6;
  pfrec := NextEvtBufRec(ebuf, CTObjEvt, rsiz);
  WITH pfrec^.Obj DO
    BEGIN
      ObjOp := oOp;
      ObjIdx := oIdx;
      ObjInt1 := int1;
    END;
  IF IMERTst THEN WRITELN('Adding obj event to buf:', ORD(ebuf), ' at pos:',
                           ebuf^^.LastBuf^^.BufPos);
  IF IMERTst THEN PxObjRec(pfrec);
END;


{$S imrh }
PROCEDURE Add8ObjEvt; { (ebuf: THEvtBuf; oOp: TB; oIdx: TB;
                        int1, int2: TC); }
VAR rsiz: TC;
    pfrec: TPEvtRec;
BEGIN
  rsiz := 8;
  pfrec := NextEvtBufRec(ebuf, CTObjEvt, rsiz);
  WITH pfrec^.Obj DO
    BEGIN
      ObjOp := oOp;
      ObjIdx := oIdx;
      ObjInt1 := int1;
      ObjInt2 := int2;
    END;
  IF IMERTst THEN WRITELN('Adding obj event to buf:', ORD(ebuf), ' at pos:',
                           ebuf^^.LastBuf^^.BufPos);
  IF IMERTst THEN PxObjRec(pfrec);
END;


{$S imrh }
PROCEDURE AddNObjEvt; { (ebuf: THEvtBuf; oOp: TB; oIdx: TB;
                        rName: TStr40); }
VAR rsiz: TC;
    pfrec: TPEvtRec;
BEGIN
  rsiz := SIZEOF(TNObjRec) - 40 + LENGTH(rName);
  rsiz := rsiz + (rsiz MOD 2); { makle sure its an even length - or else! }
  pfrec := NextEvtBufRec(ebuf, CTObjEvt, rsiz);
  WITH pfrec^.NOb DO
    BEGIN
      ObjOp := oOp;
      ObjIdx := oIdx;
      MoveRgch(@ObjNName, @rName, LENGTH(rName));
    END;
  IF IMERTst THEN WRITELN('Adding Obj name event to buf:', ORD(ebuf),
                          ' at pos:', ebuf^^.LastBuf^^.BufPos);
  IF IMERTst THEN PxObjRec(pfrec);
END;


{  core flag reset code }

{$S imcw }
PROCEDURE ClearWaitFlags;
BEGIN
  { Initialize Wait Flags}
    fWaitMouseResult := FALSE;
  fWMouseMoved := FALSE;
  fWMouseStopped:= FALSE;
  fWTimeout := FALSE;
  fPause := FALSE;
  fWButton := FALSE;
  fWFolderCmd := FALSE;
  fWSelection := FALSE;
  fWCommand := FALSE;
  msMoveTime := 0;
  msStopTime := 0;
  toWaitTime := 0;
  msMoveStartTime := 0;
  msStopStartTime := 0;
  toWaitStartTime := 0;
END;

{$S imcw }
PROCEDURE FreeObjTable;
BEGIN
  IF CurObjTable <> NIL
    THEN FreeBk(IMHeap, POINTER(ORD(curObjTable)), tyBkStd);
  IF IMERTst THEN WRITELN('Freeing curObjTable');
  curObjTable := NIL;
END;


{$S imcw }
PROCEDURE ClearRecordingFlags;
BEGIN
  { Event recording flags }
  fRSelections := FALSE;
  fRInsertion := FALSE;
  fRKeyboard := FALSE;
  fREditKbd := FALSE;
  fRCommands := FALSE;
  fRObjects := FALSE;
END;



{$S imcw }
PROCEDURE ClearResultFlags;
BEGIN
  { Wait result flags }
  fTimeout := FALSE;
  fButton := FALSE;
  fContinue := FALSE;
  fMouseMoved := FALSE;
  fMouseStopped := FALSE;
  fMMoveLeft := FALSE;
  fMMoveRight := FALSE;
  fMMoveUp := FALSE;
  fMMoveDown := FALSE;
  ClearEvtBuf(curEvtBuf);
END;



{$S imcc }
PROCEDURE StrangeError; {(estr: Str255);}
BEGIN
 {$IFC IMDebug}
  WRITELN(estr);
  WRITELN('This error shouldnt happen. Check with programmer.');
  WRITELN('You can type any char to go on, but things may not work.');
  Brk(888);
 {$ELSEC }
  HALT;
 {$ENDC}
END;


{$S imcc }
PROCEDURE InterpError; {(errStr: Str255);}
VAR i: INTEGER;
BEGIN
 {$IFC IMDebug}
  WRITELN('LisaGuide Interpreter Error - call programmer');
  WRITELN(errstr);
 {$ELSEC }
  WRITELN('LisaGuide Interpreter Error - call programmer');
  WRITELN(errstr);
  HALT;
 {$ENDC}
END;


{$S imcc }
PROCEDURE InterpIError; {(errStr: Str255; errInt: TC);}
VAR i: INTEGER;
BEGIN
 {$IFC IMDebug}
  WRITELN('LisaGuide Interpreter Error - call programmer ');
  WRITELN(errstr, errInt);
 {$ELSEC }
  WRITELN('LisaGuide Interpreter Error - call programmer ');
  WRITELN(errstr, errInt);
  HALT;
 {$ENDC}
END;


{$S imcc }
FUNCTION GrowHeap( hz: Thz; bytesNeeded, refNum: TC; segName: e_name): TC;
  {we got too many args here for a grow heap proc }
VAR errNum: INTEGER;
    newMemSize: LongInt;
    newDiskSize: LongInt;
    dsInfo: DsInfoRec;
BEGIN
IF IMtst THEN WRITELN('GrowHeap');
Info_DataSeg(errNum,refNum,dsInfo);
IF cDebug THEN
  WRITELN('"',segName,'" is full.   Current size = ',dsInfo.mem_size:1,
        '  bytesNeeded = ',bytesNeeded:1);
Size_Dataseg(errNum,refnum,bytesNeeded,newMemSize,bytesNeeded,newDiskSize);
IF errNum <= 0 THEN
   BEGIN
   IF cDebug THEN WRITELN('"',segName,'" has been expanded to ',newMemSize:1);
   GrowHeap := newMemSize - dsInfo.mem_Size;
   END
ELSE
   BEGIN
   IF cDebug THEN WRITELN;
   IF cDebug THEN
     WRITELN('Unable to expand "',segName,'" by ',bytesNeeded:1,' bytes.  err: ',
              errNum:1);
   IF cDebug THEN WRITELN('Current data segment size = ',dsInfo.mem_size:1);
   GrowHeap := 0;
   END;
END;


{$S imcc }
FUNCTION HeapError;  { (hz: THz; bytesNeeded: TC): TC; }
VAR segName: e_name;
BEGIN
  { fix before a4 }
  {$IFC IMDebug }
    WRITELN('The heap is full. Heap handle: ', ORD(hz),
          ' bytesNeeded:', bytesNeeded);
  {$ENDC}
  IF hz = IMHeap
    THEN BEGIN
      segName := imSegName;  {ugly hack -- need to generalize }
      HeapError := GrowHeap(hz, bytesNeeded, imHRefNum, segName);
     END
    ELSE HeapError := 0;
END;


{$S imcini }
FUNCTION  PAllocCb(cbAlloc: TL; sSegName: pathname; hLdsn: TC;
                   VAR cRefnum: TC): TP;
   VAR cErrnum: TC;
      lSegptr: LONGINT;
      dsinfo: DsInfoRec;
      lNewMemSize, lNewDiscSize: LONGINT;

  BEGIN
   IF IMtst THEN WRITELN('OS version of PAllocCb');
   IF (cbAlloc MOD 512) <> 0 THEN Brk(1002);
   IF NOT fMemRes THEN BEGIN
    (* Creates disk resident data seg for heap  *)
     IF IMtst THEN WRITELN('Allocating disk resident data segment');
     OPEN_DATASEG(cErrnum, sSegname, cRefnum, lSegptr, hLdsn);
     IF cDebug THEN IF IMtst THEN
       WRITELN('OPEN_DATASEG returned; cErrnum = ', cErrnum);
     IF cErrnum <> 0 THEN { dataseg did not already exist }
        BEGIN
        IF IMtst THEN WRITELN('about to make a new dataseg...');
        MAKE_DATASEG(cErrnum, sSegname, cbAlloc, cbAlloc,
                       cRefnum, lSegptr, hLdsn, ds_private);
        IF cErrnum <> 0 THEN
           BEGIN
           IF sDebug THEN WRITELN('In PAllocate: MAKE_DATASEG error #', cErrnum);
           IF cDebug THEN Brk(1001);
           lsegPtr := ORD4(NIL);
           END;
        END
       ELSE { dataseg opened successfully ... is it the right size ? }
        BEGIN
        INFO_DATASEG(cErrnum, cRefnum, dsinfo);
        IF cErrnum <> 0 THEN
          BEGIN
           IF sDebug THEN WRITELN('In PAllocate: INFO_DATASEG error #', cErrnum);
           IF cDebug THEN Brk(1001);
           lsegPtr := ORD4(NIL);
          END;
        IF dsinfo.mem_size <> cbAlloc THEN { must resize the dataseg }
          BEGIN
           IF IMtst THEN WRITELN('about to resize an old dataseg...');
           SIZE_DATASEG(cErrnum, cRefnum, cbAlloc - dsinfo.mem_size,
                        lNewMemSize, 0, lNewDiscSize);
           IF cErrnum <> 0 THEN
             BEGIN
              IF sDebug THEN
                WRITELN('In PAllocate: SIZE_DATASEG error #', cErrnum);
              IF cDebug THEN Brk(1001);
              lsegPtr := ORD4(NIL);
             END;
           END
         ELSE IF IMtst THEN WRITELN('old dataseg was the right size...');
        END;
     PAllocCb := POINTER(lSegptr);
    END
   ELSE BEGIN
    (* ...and this version creates 'memory-only' segments. *)
     IF IMtst THEN WRITELN('Allocating memory resident data segment');
     IF IMtst THEN
       WRITELN('about to make a new dataseg...');
     MAKE_DATASEG(cErrnum, sSegname, cbAlloc, 0, cRefnum, lSegptr,
                          hLdsn, ds_private);
     IF cErrnum <> 0 THEN
       BEGIN
        IF sDebug THEN
          WRITELN('In PAllocate: MAKE_DATASEG error #', cErrnum);
        IF cDebug THEN Brk(1001);
        lsegPtr := ORD4(NIL);
       END;
     PAllocCb := POINTER(lSegptr);
     IF cDebug THEN IF IMtst THEN
       WRITELN('PAllocate about to return: ',lSegptr);
    END;
END;


{$S imcini }
PROCEDURE FlrInitHeap(hRefNum, hLDSN: TC; hSegName: e_name);

{ Initialize the heap for filer objects }

CONST dsSize = $4000;   { 16K bytes for now }

VAR errNum:             INTEGER;
    openErrNum:         INTEGER;
    dsAddr:             LongInt;
    dsName:             PathName;
    dsInfo:             DsInfoRec;
    newMemSize:         LongInt;
    newDiskSize:        LongInt;

BEGIN
IF IMtst THEN WRITELN('InitFlrHeap');
dsName := hSegName;
Open_DataSeg(openErrNum,dsName,hRefnum,dsAddr,hLDSN);
IF openErrNum <= 0 THEN
   BEGIN
   SetAccess_DataSeg(errNum,hRefnum,FALSE);    { allow write access }
   Info_DataSeg(errNum,hRefnum,dsInfo);        { how big is is it? }
   Size_Dataseg(errNum,hRefnum,                { set it to its initial size }
                dsSize - dsInfo.mem_Size, newMemSize,
                dsSize - dsInfo.disc_size, newDiskSize);
   IF errNum <> 0 THEN
      BEGIN
      IF cDebug THEN
        WRITELN('InitFlrHeap failed on Size_Dataseg.  err = ',errNum:1);
      Halt;
      END;
   END
ELSE
   BEGIN  { openErrNum > 0  --> hard error }
   Kill_DataSeg(errNum,dsName);
   Make_DataSeg(errNum,dsName,dsSize,dsSize,hRefnum,dsAddr,hLDSN,
                ds_private);   {*** shared to guarantee space?? ***}
   IF errnum <> 0 THEN
      BEGIN
      IF cDebug THEN
        WRITELN('FlrInitHeap failed on Make_DataSeg. err = ',errNum);
      Halt;
      END
   END;

InitHeap(Pointer(dsAddr),Pointer(dsAddr+dsSize),@GrowHeap);
END;


{$S imcini }
FUNCTION HZCreate;  {(cb: TL; heapSeg: e_name; hLDSN: TC; VAR hRefnum: TC): THz; }
VAR hzSpace, hzTop: TP;
    heapz: THz;
BEGIN
    {  allocate a chunk of pascal data space which is cb bytes long }
  IF (cb MOD 512) <> 0 THEN cb := cb + 512 - (cb MOD 512);
  hzSpace := pAllocCb(cb, heapSeg, hLDSN, hRefnum);
  IF hzSpace = NIL
    THEN BEGIN
      WRITELN(' LisaGuide initialization failed during storage allocation.');
      FailedInit;
     END;
  hzTop := POINTER(ORD(hzSpace)+cb);
  IF IMtst THEN WRITELN(' heap space from ', ORD(hzSpace), '  for ', cb);
  heapz := HzInit(hzSpace, hzTop, hzSpace, (cb DIV 30),3,
                  @heapError, NIL, NIL, NIL);
  IF cDebug THEN IF IMtst THEN
    WRITELN('Heap zone created: ', ORD(heapz));
  HZCreate := heapz;
END;


{$S imch }
PROCEDURE PullAlert;
BEGIN
  IF AlertDown <> 0
    THEN BEGIN
      REPEAT UNTIL TIME > AlertDown;
      AlertDown := 0;
      HideFolder(AlertFolder);
     END;
END;

{$S imcw }
PROCEDURE IMAlertUp;
BEGIN
  PullAlert;
  AlertDown := TIME + CAlertHold;
END;


{$S imch }
FUNCTION  TxtWidth;  { (lrgch: TRgch; chrCt: TC; ffam: TC): TC; }
VAR twid: TC;
    gp: GrafPtr;
BEGIN
  GetPort(gp);
  SetPort(WidPort);
IF thePort = menuFolder THEN BEGIN
  IF sDebug THEN WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
  TextFont(ffam);
  twid := TextWidth(POINTER(ORD(lrgch)), 0, chrCt);
  SetPort(gp);
  TxtWidth := twid;
END;



{$S imch }
FUNCTION  TxtStrWidth;  { (tStr: Str255; ffam: TC): TC; }
VAR swid: TC;
    gp: GrafPtr;
BEGIN
  GetPort(gp);
  SetPort(WidPort);
IF thePort = menuFolder THEN BEGIN
  IF sDebug THEN WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
  TextFont(ffam);
  swid := StringWidth(tStr);
  SetPort(gp);
  TxtStrWid := swid;
END;



{$S imcw }
PROCEDURE GetBtnKey; { (VAR bKey: TKeyStr; bIdx: TC); }
VAR pBtnRec: TPButton;
    i: TC;
BEGIN
  pBtnRec := POINTER(ORD(NthSrchTableRec(hIMButtonTab, bIdx)));
  IF pBtnRec = NIL
    THEN bKey := '?font'
    ELSE bKey := pBtnRec^.btnName;
END;



{$S imcw }
FUNCTION BtnIdxFromName;  { (bKey: TKeyStr): TC; }
VAR pBtnRec: TPButton;
    bIdx: TC;
BEGIN
  pBtnRec := POINTER(ORD(FindNthSrchTableRec(hIMButtonTab, bKey, bIdx)));
  IF pBtnRec = NIL
    THEN BEGIN
      IF cDebug THEN IF IMtst THEN
        WRITELN('BtnIdxFromName - cant find button named: ', bKey);
      BtnIdxFromName := 0;   { failure value }
      EXIT(BtnIdxFromName);
     END;
  IF cDebug THEN IF IMtst THEN
    WRITELN('BtnIdxFromName of: ', bKey, ' returns: ', bIdx);
  BtnIdxFromName := bIdx;
END;


{$S imch }
FUNCTION GetButtonRec;  { (bIdx: TC): TPButton; }
VAR pBtnRec: TPButton;
BEGIN
  pBtnRec := POINTER(ORD(NthSrchTableRec(hIMButtonTab, bIdx)));
  GetButtonRec := pBtnRec;
END;


{$S imcw }
FUNCTION  NewIMButton;  { (bName, bText: TKeyStr; bFidx: TC; bFramed: TF): TC; }
VAR pBtnRec: TPButton;
    recIdx: TC;
    btnTxtWid: TC;
BEGIN
  pBtnRec := POINTER(ORD(FindNthSrchTableRec(hIMButtonTab, bName, recIdx)));
  IF pBtnRec = NIL
    THEN pBtnRec := POINTER(ORD(NewSrchTableRec(hIMButtonTab, recIdx)))
    ELSE IF IMtst THEN WRITELN('ReDefining button: ', bName);
  IF pBtnRec = NIL
    THEN BEGIN
      IF cDebug THEN WRITELN('No button table - cant add button record!!!');
      Exit(NewIMButton);
     END;
  btnTxtWid := TxtStrWid(bText, FontFam(bFidx));
  WITH pBtnRec^ DO
    BEGIN
      btnName := bName;
      SetPt(btnSize, btnTxtWid + btnOvalH, FontHt(bFidx) + btnOvalV);
      SetPt(btnOffset, 0, 0);
      btnFramed := bFramed;
      btnPressed := FALSE;
      btnFIdx := bFidx;
      btnText := bText;
      IF IMtst
        THEN WRITELN('TextButton named', bName, ' added with index: ', recIdx,
                   ' btnText: ', bText, ' btnSize: ', btnSize.h:5, btnSize.v:5);
    END;
  NewIMButton := recIdx;
END;


{$S imcw }
PROCEDURE SetBtnSize;  { (bIdx: TC; bSize: Point); }
VAR pBtnRec: TPButton;
BEGIN
  pBtnRec := GetButtonRec(bIdx);
  IF pBtnRec = NIL
    THEN BEGIN
      IF (sDebug OR IMtst)
        THEN WRITELN('SetBtnSize - no such button:', bIdx);
        EXIT(SetBtnSize);
       END;
  pBtnRec^.btnSize := bSize;
  IF cDebug THEN IF IMtst THEN
     WRITELN('Button:', bIdx:4, ' size set to:', bSize.h:5, bSize.v:5);
END;


{$S imcw }
PROCEDURE SetBtnOffset;  { (bIdx: TC; bOffset: Point); }
VAR pBtnRec: TPButton;
BEGIN
  pBtnRec := GetButtonRec(bIdx);
  IF pBtnRec = NIL
    THEN BEGIN
      IF cDebug THEN IF IMtst
        THEN WRITELN('SetBtnOffset - no such button:', bIdx);
      EXIT(SetBtnOffset);
     END;
  pBtnRec^.btnOffset := bOffset;
  IF IMtst THEN
     WRITELN('Button:', bIdx:4, ' offset set to:', bOffset.h:5, bOffset.v:5);
END;


{$S imch }
PROCEDURE GetBtnRect(VAR bRect: Rect; bIdx: TC; bPos: Point);
VAR pBtnRec: TPButton;
    bposh, bposv: TC;
BEGIN
  pBtnRec := POINTER(ORD(NthSrchTableRec(hIMButtonTab, bIdx)));
  IF pBtnRec <> NIL
    THEN WITH pBtnRec^ DO BEGIN
       bposh := bPos.h + btnOffset.h;
       bposv := bPos.v + btnOffset.v;
       SetRect(bRect, bposh, bposv+2, bposh+btnSize.h, bposv+btnSize.v-2);
     END
    ELSE BEGIN
      SetRect(bRect, 0, 0, 0, 0);
     END;
END;


{$S imch }
PROCEDURE PressBtn;  { (bIdx: TC; fPress: TF; bPos: Point); }
VAR pBtnRec: TPButton;
    bRect: Rect;
BEGIN
  pBtnRec := POINTER(ORD(NthSrchTableRec(hIMButtonTab, bIdx)));
  IF pBtnRec^.btnPressed <> fPress
    THEN BEGIN
      GetBtnRect(bRect, bIdx, bPos);
      InvertRoundRect(bRect, btnOvalH, btnOvalV);
      pBtnRec^.btnPressed := fPress;
    END;
END;


{$S imch }
PROCEDURE ClearBtn;  { (bIdx: TC); }
VAR pBtnRec: TPButton;
BEGIN
  pBtnRec := POINTER(ORD(NthSrchTableRec(hIMButtonTab, bIdx)));
  pBtnRec^.btnPressed := FALSE;
END;


{$S imch }
PROCEDURE DrawButton;  { (bIdx: TC; bPos: Point); }
VAR pBtnRec: TPButton;
    bRect: Rect;
    bText: TKeyStr;
    bOFfset: Point;
    bFIdx, bFFam: TC;
    bFramed, bPressed: TF;
BEGIN
  IF cDebug THEN IF IMtst THEN
    WRITELN('DrawButton:', bIdx, ' at:', bPos.h, bPos.v);
  pBtnRec := GetButtonRec(bIdx);
  IF pBtnRec = NIL THEN BEGIN
    IF cDebug THEN IF IMtst THEN
      WRITELN('DrawButton - no such button:', bIdx);
    EXIT(DrawButton);
   END;
  WITH pBtnRec^ DO BEGIN
     bText := btnText;  { these are saved locally in case of relocation of }
     bFIdx := btnFIdx;  { the button table  }
     bOffset := btnOffset;
     bFramed :=  btnFramed;
     bPressed := btnPressed; { save to call PressBtn later if needed }
     btnPressed := FALSE;    { its drawn un-pressed }
    END;
  bFFam := FontFam(bFIdx);
  GetBtnRect(bRect, bIdx, bPos);
  EraseRoundRect(bRect, btnOvalH, btnOvalV);
  MoveTo((bRect.left + bOffset.h +
          ((bRect.right-bRect.left-TxtStrWidth(bText, bFFam)) DIV 2)),
         (bRect.top + bOffset.v +
          (((bRect.bottom-bRect.top)*FontBase(BFIdx)) DIV FontHt(bFIdx))));
IF thePort = menuFolder THEN BEGIN
  WRITELN('Changing font of menu folder!!!'); Holdit(sDebug); END;
  TextFont(bFFam);
  DrawString(bText);
  IF bFramed
    THEN BEGIN
      PenSize(2, 2);
      FrameRoundRect(bRect, btnOvalH, btnOvalV);
      PenNormal;
     END;
  IF bPressed THEN PressBtn(bIdx, bPressed, bPos);
END;


{$S imch }
FUNCTION  HitInButton; {(bIdx: TC; bPos, hitPos: Point; fPress: TF): TF;}
VAR bRect: Rect;
BEGIN
  IF cDebug THEN IF IMtst
        THEN WRITELN('HitInButton:', bIdx, ' at:', bPos.h, bPos.v);
  GetBtnRect(bRect, bIdx, bPos);
  IF NOT PtInRect(hitPos, bRect)
    THEN BEGIN
      PressBtn(bIdx, FALSE, bPos);
      HitInButton := FALSE;
     END
    ELSE BEGIN
      PressBtn(bIdx, fPress, bPos);
      HitInButton := TRUE;
     END;
END;


{$S imch }
FUNCTION  TestIMButton; {(bIdx: TC; bPos, hitPos: Point; VAR pressFlag: TF): TF;}
VAR bRect: Rect;
    fIn: TF;
    i: TC;
    ht: TL;
BEGIN
  {  proper port should have been set befire this is called }
  IF cDebug THEN IF IMtst THEN
    WRITELN('TestIMButton:', bIdx, ' at:', bPos.h, bPos.v);
  IF NOT HitInButton(bIdx, bPos, hitPos, TRUE)
    THEN BEGIN
      pressFlag := FALSE;
      TestIMButton := FALSE;
      EXIT(TestIMButton);
     END;
  fIn := TRUE;
  GetBtnRect(bRect, bIdx, bPos);
  PressBtn(bIdx, TRUE, bPos);
  ht := TIME + 25;
  REPEAT BEGIN END; UNTIL (TIME > ht);
     { pause a moment for inversion to sink in }
  WHILE StillDown DO BEGIN
    GetMouse(hitPos);
    IF PtInRect(hitPos, bRect)
      THEN BEGIN
        IF NOT fIn THEN BEGIN
           fIn := TRUE;
           PressBtn(bIdx, TRUE, bPos);
          END;
       END
      ELSE BEGIN
        IF fIn THEN BEGIN
          fIn := FALSE;
          PressBtn(bIdx, FALSE, bPos);
         END;
       END;
   END;
  pressFlag := fIn;
  TestIMButton := TRUE;
  IF cDebug THEN IF IMtst THEN
    WRITELN('TestIMButton - hit button:', bIdx:5, ' pressFlag: ', pressFlag);
END;


{$S imcini }
FUNCTION  AddIMFont; { (fKey: TKeyStr; fFam: TC): TC; }
VAR pFontRec: TPFontRec;
    fIdx: TC;
    recIdx: TC;
    fErr: TC;
    fontID: TLFntid;
    fInfo: FontInfo;
    fNew: TF;
BEGIN
  pFontRec := POINTER(ORD(ReDefSrchTableRec(hIMFontTable, fKey, recIdx, fNew)));
  IF pFontRec = NIL
    THEN BEGIN
      IF cDebug THEN
        WRITELN('Cant add new font!!!! not enough room in font table.');
      Exit(AddIMFont);
     END;
  fIdx := recIdx;
  WITH pFontRec^ DO
    BEGIN
      fontKey := fKey;
      fontFam := fFam;
      fontID.fam := fFam;
      fontID.seteface := [];
      fontID.Dev := devScreen;
      IF FMFontMetrics(fontID, fInfo, fErr)
        THEN BEGIN
          IF fErr = 0
            THEN WITH fInfo DO BEGIN
              IF fFam = systext THEN ascent := ascent - 2;
                { ugly hack because of ascent change for eurpoean chars }
              fontBase := ascent;
              fontHt := ascent + descent;
             END
            ELSE BEGIN
              { random defaults - this shouldnt occur!!! }
              IF cDebug THEN
                WRITELN('Error getting font metrics for font:', fFam);
              InterpIError('FontManager (FontMetrics) error in AddIMFont:', fErr);
              fontBase := 8;
              fontHt := 12;
             END;
          END
         ELSE BEGIN
           { random defaults - this shouldnt occur!!! }
           IF cDebug THEN WRITELN('Cant get font metrics for font:', fFam);
           InterpIError('Cant get FontMetrics error in AddIMFont:', fErr);
           fontBase := 8;
           fontHt := 12;
          END;
      IF IMtst THEN
        IF fNew
          THEN  WRITELN('font ', fKey, ' added with index: ', fIdx,
                        ' fontFam: ', fontFam)
          ELSE WRITELN('font ', fKey, ' redefined with index: ', fIdx,
                       ' fontFam: ', fontFam);
      IF IMtst THEN WRITELN('  fontBase:', fontBase, '  fontHt:', fontHt);
    END;
  AddIMFont := fIdx;
END;


{$S imcw }
PROCEDURE GetFontKey; { (VAR fKey: TKeyStr; fIdx: TC); }
VAR pFontRec: TPFontRec;
    i: TC;
BEGIN
  pFontRec := POINTER(ORD(NthSrchTableRec(hIMFontTable, fIdx)));
  IF pFontRec = NIL
    THEN fKey := '?font'
    ELSE fKey := pFontRec^.fontKey;
END;


{$S imch }
FUNCTION  GetFontRec;  {(fIdx: TC): TPFontRec; }
VAR pFontRec: TPFontRec;
BEGIN
  pFontRec := POINTER(ORD(NthSrchTableRec(hIMFontTable, fIdx)));
  IF pFontRec = NIL
    THEN BEGIN
      GetFontRec := NIL;
      InterpError('GetFontRec - Cant find font');
      EXIT(GetFontRec);
     END;
  GetFontRec := pFontRec;
END;


{$S imch }
FUNCTION  FIdxFromName;  { (fKey: TKeyStr): TC; }
VAR pFontRec: TPFontRec;
    fIdx: TC;
BEGIN
  pFontRec := POINTER(ORD(FindNthSrchTableRec(hIMFontTable, fKey, fIdx)));
  IF pFontRec = NIL
    THEN BEGIN
      IF IMtst THEN WRITELN('FIdxFromName - cant find font named: ', fKey);
      FIdxFromName := 0;   { failure value }
      EXIT(FIdxFromName);
     END;
  IF cDebug THEN IF IMtst THEN
    WRITELN('FIdxFromName of: ', fKey, ' returns: ', fIdx);
  FIdxFromName := fIdx;
END;


{$S imch }
FUNCTION  FontIndex;  { (ffam: TC): TC; }
LABEL 600;
VAR pFontRec: TPFontRec;
    i: TC;
BEGIN
  FOR i := 1 TO CMaxIMFonts DO
    BEGIN
      pFontRec := GetFontRec(i);
      IF pFontRec = NIL THEN GOTO 600;
      IF pFontRec^.fontFam = ffam
        THEN BEGIN
          IF cDebug THEN
             WRITELN('FontIndex for fam:', ffam, ' is:', i);
          FontIndex := i;
          EXIT(FontIndex);
        END;
    END;
600:
  IF cDebug THEN IF IMtst THEN
    WRITELN('Cant find FontIndex for fam:', ffam, ' using:', IMFontIdx);
  FontIndex := IMFontIdx;  { random default }
END;


{$S imch }
FUNCTION FontHt;  { (fontIdx: TC): TC; }
VAR pFontRec: TPFontRec;
BEGIN
  pFontRec := GetFontRec(fontIdx);
  IF pFontRec = NIL THEN FontHt := 12  { random default!!!}
    ELSE FontHt := pFontRec^.fontHt;
END;


{$S imch }
FUNCTION  FontBase;  { (fontIdx: TC): TC; }
VAR pFontRec: TPFontRec;
BEGIN
  pFontRec := GetFontRec(fontIdx);
  IF pFontRec = NIL THEN FontBase := 10  { random default!!!}
    ELSE FontBase := pFontRec^.fontBase;
END;


{$S imch }
FUNCTION  FontFam;  { (fontIdx: TC): TC; }
VAR pFontRec: TPFontRec;
BEGIN
  pFontRec := GetFontRec(fontIdx);
  IF pFontRec = NIL THEN FontFam := IMFontFam  { random default!!!}
    ELSE FontFam := pFontRec^.fontFam;
END;


{$S imcini }
PROCEDURE AddKindRec; { (kKey: TKeyStr; kID: TC); }
VAR pKindRec: TPKindRec;
    recIdx: TC;
    fNew: TF;
BEGIN
  pKindRec := POINTER(ORD(ReDefSrchTableRec(hKindTable, kKey, recIdx, fNew)));
  IF pKindRec = NIL
    THEN BEGIN
      IF cDebug THEN
        WRITELN('Cant add new kind!!!! not enough room in font table.');
      Exit(AddKindRec);
     END;
  WITH pKindRec^ DO
    BEGIN
      kindKey := kKey;
      kindID := kID;
      IF cDebug THEN IF IMtst THEN
        IF fNew
          THEN  WRITELN('kind ', kKey, ' added with ID: ', kID)
          ELSE WRITELN('kind ', kKey, ' redefined with ID: ', kID);
    END;
END;



{$S imcw }
PROCEDURE ActiveFldr; { (hndFldr: THFldrInfo); }
BEGIN
  IF IMTst THEN WRITELN('activating folder: ', ORD(hndFldr));
  IF hndFldr <> NIL THEN MakeFldrActive(hndFldr^^.fldrPort, nilUserData);
END;

{$S imcw }
PROCEDURE GetFldr; { (hndFldr: THFldrInfo); }
BEGIN
  IF IMTst THEN WRITELN('showing folder: ', ORD(hndFldr));
  hndFldr^^.fldrVis := TRUE;
  ShowFolder(hndFldr^^.fldrPort);
END;

{$S imcw }
PROCEDURE HideFldr; { (hndFldr: THFldrInfo); }
BEGIN
  IF IMTst THEN WRITELN('hiding folder: ', ORD(hndFldr));
  HideFolder(hndFldr^^.fldrPort);
  hndFldr^^.fldrVis := FALSE;
END;



{$S imcini }
PROCEDURE IMCoreInit;
VAR fErr: TC;
BEGIN

  SetRect(NullRect,0,0,0,0);

{$IFC fDbgOK}
  fTstStd := FALSE;
  fTstHz := FALSE;
{$ENDC }

  imLdsn := ldsnPrint+2;  { be safe? }
  imSegName := 'IMDataSeg';

 {$IFC IMDebug }
  kbdCommand := FALSE;
  fTstSim := FALSE;
  fMemRes := TRUE; { for right now }
 {$ENDC }

  StrHeap := HZCreate(60000, imSegName, imLdsn, imHRefNum);
  IMHeap  := StrHeap;
  SetHeap(IMHeap);

  AlertDown := 0;

  MasterMenuList.firstMenu := NIL;
  MasterMenuList.lastMenu := NIL;
  MasterMenuList.menuCount := 0;
  InitMenus;

  SetRect(WidPortData.portRect, 0, 0, 0, 0);
  WidPort := @WidPortData;
  OpenPort(WidPort);

  scrollFont:=3;
  IMFontFam := 8;
  hIMFontTable := CreateSrchTable(SIZEOF(TFontRec), CMaxIMFonts, 2);
  IMFontIdx := AddIMFont('TutorFont', IMFontFam);
  SysFontIdx := AddIMFont('SystemFont', sysText);

  hndActiveFldr := NIL;
  ActiveWSLink := NIL;
  ActivePort := NIL;

  hIMButtonTab := CreateSrchTable(SIZEOF(TButton), CMaxButtons, 2);
  ContBtnIdx := NewIMButton('CONT', 'Continue', SysFontIdx, TRUE);
  DemoBtnIdx := NewIMButton('DEMO', 'Demo', SysFontIdx, TRUE);
  PracBtnIdx := NewIMButton('PRAC', 'Practice', SysFontIdx, TRUE);

  curEvtBuf := CreateEvtBuf;
  curObjTable := NIL;
  ClearWaitFlags;
  ClearRecordingFlags;
  ClearResultFlags;

  fTest := FALSE;
  fWait :=  FALSE;
  PartMatchNumber := 0;
  fQuit := FALSE;
  toldToDie := FALSE;

  UndoEnabled := FALSE;
  UndoMItem := 0;

  NEW(PHintList);
  HintCount := 0;
  LastHint := 0;
  HintStr := NIL;
  HintDisplayed := FALSE;
END;


{$S imcc }
PROCEDURE CharStr1; {(sch: CHAR; VAR str1: TStr1);}
BEGIN
  str1 := 'x';
  str1[1] := sch;
END;

{$S imcc }
PROCEDURE IntStr20; {(sint: TC; VAR str20: TStr20);}
VAR ndigs, nxtDig: TB;
    srgch, drgch: TRgch;
BEGIN
  ndigs := 0;
  srgch := POINTER(ORD(@str20) + 1);
  drgch := POINTER(ORD(@str20) + 2);
  REPEAT
    nxtDig := sint MOD 10;
    sint := sint DIV 10;
    ndigs := ndigs + 1;
    IF ndigs > 0 THEN MoveOvRgch(drgch,srgch,ndigs);
    srgch^[0] := nxtDig + ORD('0');
  UNTIL sint = 0;
  str20[0] := CHR(ndigs);
END;

{$S imcc }
PROCEDURE BoolStr5; {(sbool; VAR str5: TStr5);}
BEGIN
  IF sbool THEN str5 := 'TRUE' ELSE str5 := 'FALSE';
  IF cDebug THEN IF IMTst THEN
    WRITELN('BoolStr5 of:', sbool, ' sets str5 to: ', str5);
END;




{ lookup table stuff }

{$S imcini }
FUNCTION CreateSrchTable;
    {(recSize, maxRecs, growRecs: TC): THSrchTable;}
VAR stSize: TC;
    hstable: THSrchTable;
    imHeapBytes: TC;
BEGIN
{$IFC IMDebug }
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('Entering CreateSrchTable - IMHeap is trashed STOP. hBytes:',
               imHeapBytes);
      Brk(3333);
      END;
{$ENDC }
  stSize := SIZEOF(TSrchTable) + (recSize * maxRecs);
  hstable := POINTER(ORD(HAllocate(IMHeap, stSize)));
  WITH hstable^^ DO
    BEGIN
      stNRecs := 0;
      stStartRecs := maxRecs;
      IF growRecs < 1 then growRecs := 1;
      stGrowRecs := growRecs;
      stMaxRecs := maxRecs;
      stRecSize := recSize;
      CreateSrchTable := hstable;
    END;
{$IFC IMDebug }
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('Leaving CreateSrchTable - IMHeap is trashed STOP. hBytes:',
               imHeapBytes);
      Brk(3333);
      END;
{$ENDC }
END;

{$S imcw }
PROCEDURE ReSizeSrchTable; { (hst: THSrchTable; newRecCt: TC); }
VAR stSize: TC;
    imHeapBytes: TC;
BEGIN
{$IFC IMDebug }
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('ReSizeSrchTable - IMHeap is trashed STOP. hBytes:',
               imHeapBytes);
      Brk(3333);
      END;
{$ENDC }
  IF hst = NIL THEN EXIT(ReSizeSrchTable);
  IF hst^^.stNRecs > newRecCt THEN newRecCt := hst^^.stNRecs;
  hst^^.stMaxRecs := newRecCt;
  WITH hst^^ DO stSize := SIZEOF(TSrchTable) + (stRecSize * stMaxRecs);
  ChangeSizeH(IMHeap, POINTER(ORD(hst)), stSize);
  IF fTstTab THEN
     WRITELN('ReSizing search table: ', ORD(hst), 'by:', newRecCt:4, ' to:',
             hst^^.stMaxRecs:4, ' records. Already has ', hst^^.stNRecs:5);
END;


{$S imcc }
FUNCTION DumpSrchTable; {(hsTable: THSrchTable; fName: PathName): TF;}
CONST FileExists = 890;
VAR fErr, fRef: TC;
    tableSize, bytesWrit: TL;
BEGIN
   DumpSrchTable := FALSE;
   Make_File(fErr, fname, 0);
   IF cDebug  THEN IF (ferr <> 0)
     THEN WRITELN('DumpSrchTable Make_File error: ', fErr);
   IF ferr = FileExists THEN fErr := 0;
   IF fErr > 0 THEN EXIT(DumpSrchTable);
   OPEN(fErr, fname, fRef, [DWrite]);
   IF cDebug  THEN IF (ferr <> 0)
     THEN WRITELN('DumpSrchTable open error: ', fErr);
   IF fErr > 0 THEN EXIT(DumpSrchTable);
   tableSize := hsTable^^.stRecSize;
   tableSize := tableSize * hsTable^^.stNRecs;
   tableSize := tableSize + SIZEOF(TSrchTable);
   IF cDebug THEN
     WRITELN('DumpSrchTable - table: ', fName, ' from: ', ORD(hsTable),
             ' tableSize: ', tableSize);
   Write_Data(fErr, fRef, ORD4(hsTable^), tableSize,
              bytesWrit, Absolute, 0);
   IF cDebug THEN
     WRITELN('DumpSrchTable - table: bytesWrit: ', bytesWrit);
   Compact(fErr, fRef);
   IF cDebug  { AND (ferr <> 0) }
     THEN WRITELN('DumpSrchTable compact error: ', fErr);
   Close_Object(fErr, fRef);
   IF cDebug  { AND (ferr <> 0) }
     THEN WRITELN('DumpSrchTable close error: ', fErr);
   IF (fErr <= 0) AND (bytesWrit = tableSize) THEN DumpSrchTable := TRUE;
END;


{$S imcini }
FUNCTION ReadSrchTable; {(hsTable: THSrchTable; fName: PathName): TF;}
VAR fErr, fRef: TC;
    tableSize, bytesRead: TL;
BEGIN
   ReadSrchTable := FALSE;
   OPEN(fErr, fname, fRef, [DRead]);
   IF cDebug  THEN IF (ferr <> 0)
     THEN WRITELN('ReadSrchTable open error: ', fErr);
   IF fErr > 0 THEN EXIT(ReadSrchTable);
   Read_Data(fErr, fRef, ORD4(hsTable^), SIZEOF(TSrchTable),
             bytesRead, Absolute, 0);
   IF cDebug  THEN IF (ferr <> 0)
     THEN WRITELN('ReadSrchTable read header error: ', fErr,
                  ' bytesRead: ', bytesRead);
   IF fErr > 0 THEN EXIT(ReadSrchTable);
   tableSize := hsTable^^.stRecSize;
   tableSize := tableSize * hsTable^^.stNRecs;
   tableSize := tableSize + SIZEOF(TSrchTable);
   ReSizeSrchTable(hsTable, hsTable^^.stMaxRecs);
   IF cDebug THEN
     WRITELN('ReadSrchTable - table: ', fName, ' from: ', ORD(hsTable),
             ' tableSize: ', tableSize);
   Read_Data(fErr, fRef, ORD4(hsTable^), tableSize,
             bytesRead, Absolute, 0);
   IF cDebug THEN
     WRITELN('ReadSrchTable - table: bytesRead: ', bytesRead);
   Close_Object(fErr, fRef);
   IF cDebug  THEN IF (ferr <> 0)
     THEN WRITELN('ReadSrchTable close error: ', fErr);
   IF (fErr <= 0) AND (bytesRead = tableSize) THEN ReadSrchTable := TRUE;
END;


{$S imcw }
FUNCTION NewSrchTableRec; {(hst: THSrchTable; VAR recN: TC): TPSrchRec;}
VAR recPos: TPSrchRec;
    imHeapBytes: TC;
BEGIN
{$IFC IMDebug }
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('NewSrchTableRec - IMHeap is trashed STOP. hBytes:',
               imHeapBytes);
      Brk(3333);
      END;
{$ENDC }
  recN := 0;
  IF hst <> NIL THEN
    BEGIN
      IF hst^^.stNRecs >= hst^^.stMaxRecs THEN
        BEGIN
          WITH hst^^ DO ReSizeSrchTable(hst, stMaxRecs+stGrowRecs);

          IF fTstTab THEN
             WRITELN('Expanding search table: ', ORD(hst), ' to:',
                  hst^^.stMaxRecs:4, ' records. Already has ', hst^^.stNRecs:5);
        END;
      WITH hst^^ DO
        BEGIN
          recPos := POINTER(ORD(hst^) + SIZEOF(TSrchTable)
                                          + (stRecSize * stNRecs));
          NewSrchTableRec := recPos;
          stNRecs := stNRecs + 1;
          recN := stNRecs;
          IF fTstTab THEN
             WRITELN('Adding record', stNRecs:4, ' to table: ', ORD(hst));
        END;
    END
   ELSE NewSrchTableRec := NIL;
END;

{$S imch }
FUNCTION NthSrchTableRec; {(hst: THSrchTable; rIdx: TC): TPSrchRec;}
VAR recPos: TPSrchRec;
    i: TC;
    imHeapBytes: TC;
BEGIN
{$IFC IMDebug }
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('NthSrchTableRec - IMHeap is trashed STOP. hBytes:',
               imHeapBytes);
      Brk(3333);
      END;
{$ENDC }
  IF hst <> NIL THEN
    WITH hst^^ DO
      BEGIN
        recPos := POINTER(ORD(hst^) + SIZEOF(TSrchTable));;
        rIdx := rIdx - 1;  { make index zero based not one based }
        IF (rIdx >= 0) AND (rIdx < stNRecs)
          THEN BEGIN
            recPos := POINTER(ORD(hst^) + SIZEOF(TSrchTable)
                                            + (stRecSize * rIdx));
            NthSrchTableRec := recPos;
           END
          ELSE BEGIN
            NthSrchTableRec := NIL;
            IF fTstTab THEN
              WRITELN('NthSrchTableRec - recIdx ', rIdx,
                      ' out of range for table ', ORD(hst));
           END;
      END
    ELSE BEGIN
      IF fTstTab THEN
        WRITELN('Attempt to access a NULL search table.');
      NthSrchTableRec := NIL;
     END;
END;

{$S imch }
FUNCTION  FindNthSrchTableRec; { (hst: THSrchTable; srchKey: TStr40;
                                  VAR rIdx: TC): TPSrchRec; }
LABEL 900;
VAR recPos: TPSrchRec;
    i: TC;
    imHeapBytes: TC;
BEGIN
{$IFC IMDebug }
  IF cDebug THEN
    IF NOT fCheckHzOk(imHeap, imHeapBytes) THEN
      BEGIN
      WRITELN('FindNthSrchTableRec - IMHeap is trashed STOP. hBytes:',
               imHeapBytes);
      Brk(3333);
      END;
{$ENDC }
  IF hst <> NIL THEN
    WITH hst^^ DO
      BEGIN
        recPos := POINTER(ORD(hst^) + SIZEOF(TSrchTable));;
        IF fTstTab THEN
          WRITELN('Searching table: ', ORD(hst), ' for key: ', srchKey);
        FOR i := 0 TO stNRecs - 1 DO
          BEGIN
            IF recPos^.key = srchKey
              THEN BEGIN
                FindNthSrchTableRec := recPos;
                rIdx := i + 1;
                IF fTstTab THEN
                  WRITELN(' found rec: ',  i+1:3, ' at ', ORD(recPos));
                GOTO 900;
               END;
            recPos := POINTER(ORD(recPos) + stRecSize);
          END;
        FindNthSrchTableRec := NIL;
      END
    ELSE BEGIN
      IF fTstTab THEN
        WRITELN('Attempt to search a NULL search table.');
      FindNthSrchTableRec := NIL;
     END;
900:
END;

{$S imch }
FUNCTION FindSrchTableRec; {(hst: THSrchTable; srchKey: TStr40): TPSrchRec;}
VAR recPos: TPSrchRec;
    rIdx: TC;
BEGIN
  recPos := FindNthSrchTableRec(hst, srchKey, rIdx);
  FindSrchTableRec := recPos;
END;


{$S imcw }
FUNCTION  ReDefSrchTableRec; { (hst: THSrchTable; srchKey: TStr40;
                              VAR rIdx: TC; VAR fNew: TF): TPSrchRec; }
VAR recPos: TPSrchRec;
BEGIN
  recPos := FindNthSrchTableRec(hst, srchKey, rIdx);
  IF recPos <> NIL
    THEN fNew := FALSE
    ELSE BEGIN
      recPos := NewSrchTableRec(hst, rIdx);
      fNew := TRUE;
     END;
  ReDefSrchTableRec := recPos;
END;


{$S imcw }
PROCEDURE ClearSrchTable; {(hst: THSrchTable);}
VAR stSize: TC;
BEGIN
  IF hst = NIL THEN EXIT(ClearSrchTable);
  hst^^.stNRecs := 0;
  IF hst^^.stMaxRecs > hst^^.stStartRecs THEN
    BEGIN
      ReSizeSrchTable(hst, hst^^.stStartRecs);
    END;
END;

{$S imcc }
PROCEDURE FreeSrchTable; {(hst: THSrchTable);}
BEGIN
  IF hst = NIL THEN EXIT(FreeSrchTable);
  FreeBk(IMHeap, POINTER(ORD(hst)), tybkStd);
END;


{  Debugging procedures  }

{$S imcdbg }
FUNCTION SorocChar;  {: CHAR; }
VAR ch: CHAR;
BEGIN
  READ(ch);
  SorocChar := ch;
END;


{$S imcdbg }
PROCEDURE WaitForSpaceBar;
VAR ch: CHAR;
BEGIN
  REPEAT
    WRITE('...');
    ch := SorocChar;
  UNTIL ch = ' ';
END;


{$S imcdbg }
PROCEDURE Hold;  {(ticks: INTEGER); }
VAR tim, lticks: LongInt;
BEGIN
  lticks := Time + ticks;
  REPEAT
    tim := Time;
  UNTIL tim >= lticks;
END;


{$S imcdbg }
PROCEDURE PrintPoint;  {(pt: Point); }
BEGIN
  WRITE('h: ', pt.h:4, ' v: ', pt.v:4, ' ');
END;


{$S imcdbg }
PROCEDURE PrintRect;  {(r: Rect); }
BEGIN
  WRITE('topLeft.');
  PrintPoint(r.topLeft);
  WRITE('botRight.');
  PrintPoint(r.botRight);
  WRITELN;
END;


{$S imcdbg }
PROCEDURE PrtRgnBBox;  {(regn: RgnHandle); }
BEGIN
  PrintRect(regn^^.rgnBBox);
END;


{$S imcdbg }
PROCEDURE PrintPort;  {(gp: GrafPtr); }
VAR i: INTEGER;
BEGIN
  WITH gp^ DO
    BEGIN
      WRITELN('GrafPort for device: ', device);
      WRITE('  port bounds: ');
      PrintRect(PortBits.bounds);
      WRITE('  portRect: ');
      PrintRect(portRect);
      WRITE('  vis rgn bbox: ');
      PrintRect(visRgn^^.rgnBBox);
      WRITE('  clip rgn bbox: ');
      PrintRect(clipRgn^^.rgnBBox);
      WRITE('   bkPat: ');
      FOR i := 0 TO 7 DO WRITE(bkPat[i]:5);
      WRITELN;
      WRITELN('  txFont:', txFont, '  txFace: ???', '  txMode:', txMode);
      WRITE('  penloc:');
      PrintPoint(pnLoc);
      WRITE('  pnSize:');
      PrintPoint(pnSize);
      WRITELN('  pnMode:', pnMode:3);
      WRITE('  pnPat: ');
      FOR i := 0 TO 7 DO WRITE(pnPat[i]:5);
      WRITELN;
    END;
END;



{$S imcdbg }
PROCEDURE PrtEvtType;  {(eptr: EventPtr); }
VAR et: STRING[20];
BEGIN
  WITH eptr^ DO
    BEGIN
      et := '????';
      CASE what OF
        nilEvent: et := 'nilEvent';
        buttonDown: et := 'buttonDown';
        buttonUp: et := 'buttonUp';
        keyDown: et := 'keyDown';
        folderActivate: et := 'folderActivate';
        folderDeactivate: et := 'folderDeactivate';
        folderUpdate: et := 'folderUpdate';
        folderMoved: et := 'folderMoved';
        filerEvent: et := 'filerEvent';
        abortEvent: et := 'abortEvent';
        diedEvent: et := 'diedEvent';
        private1: et := 'private1';
        private2: et := 'private2';
        private3: et := 'private3';
       END;
      WRITE(et, ' event for window ', ORD(who));
    END;
END;



{$S imcdbg }
PROCEDURE PrintEvent;  {(eptr: EventPtr); }
BEGIN
  WITH eptr^ DO
    BEGIN
      PrtEvtType(eptr);
      WRITE('  at point: ');
      PrintPoint(where);
      WRITELN(' when:', when);
      WRITELN;
      WRITELN('  shiftKey: ', shiftKey, '  alphaKey: ', alphaKey,
              '  codeKey: ', codeKey, '  appleKey: ', appleKey);
      WRITELN('  keyCap:', keyCap, '  ascii:', ascii);
      WRITELN('  fromFolder:', ORD(fromFolder), '  fromProcess:', fromProcess,
              '  userData:', userData);
    END;
END;


{$S imcdbg }
PROCEDURE IdRegion;  {(name: Str255; regn: RgnHandle; htime: INTEGER;
                       gprt, deskPort: GrafPtr); }
VAR i: INTEGER;
    savePort: GrafPtr;
BEGIN
  GetPort(savePort);
  SetPort(deskPort);
  WITH gprt^.PortBits.bounds.topLeft DO
    BEGIN
      OffsetRgn(regn, -h, -v);
      WRITELN('Showing region ', name);
      FOR I := 1 TO 9 DO BEGIN InvertRgn(regn); Hold(2); END;
      IF htime = -1
        THEN WaitForSpaceBar
        ELSE Hold(100 * htime);
      FOR I := 1 TO 9 DO BEGIN InvertRgn(regn); Hold(2); END;
      OffsetRgn(regn, h, v);
    END;
  SetPort(savePort);
END;


{$S imcdbg }
PROCEDURE PrintMD;  {(PMD: MenuHandle); }
BEGIN
 {  This needs to be updated for new menu structure.
  WRITELN('MenuDescriptor:', ORD(PMD), '  Count = ', PMD^.MenuCount:3,
    ' active: ', PMD^.CActive:3);
  WRITE('  MD.barRect '); PrintRect(PMD^.barRect);
 }
END;

END.


