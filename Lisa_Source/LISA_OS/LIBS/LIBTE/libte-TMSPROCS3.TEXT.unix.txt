{$S TEwork2}
PROCEDURE NewTimOut{VAR delta : INTEGER};
      {-------------------------------------------------------------------------}
      {Timeout event detected.                                                  }
      {                                                                         }
      {-------------------------------------------------------------------------}
   VAR
       t:integer;
   BEGIN

{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('tmsprocs NewTimOut' );


      CASE typeOfSel of
         aCellTxtSl,
         aRowHedSl,
         aColHedSl:
            BEGIN
            IF NOT selFstateH^^.valid OR (WavActive AND NOT wavFstateH^^.valid) THEN
               BEGIN

               IF WavActive AND NOT wavFstateH^^.valid THEN
                  BEGIN
                  SetPnlPort(widePnl);
                  DrawField(wavFieldH,wavFstateH,TRUE, true);
                  StartBlink(delta);
                  END;
               SetPnlPort(CellPnl);
               DrawField(selFieldH,selFstateH,TRUE, true);
               StartBlink(delta);
               NewRgImg(currRg);
               END
            ELSE
               BEGIN
               SetPnlPort(widePnl);
               t := delta;
               If wavActive Then BlinkCaret(wavFieldH,wavFstateH,delta);
               SetPnlPort(CellPnl);
               BlinkCaret(selFieldH,selFstateH,t);
               NewRgImg(CurrRg);
               END;
            END;

         a1CellSl,
         aRectRgSl,
         aColRgSl,
         aRowRgSl:
            BEGIN
            delta := dflttimeout;
            END;
         aColGrdSl:
            BEGIN
            Flicker(tGridH);
            Delta := nullTimeout;
            END;
         aRowGrdSl:
            BEGIN
            delta := dfltTimeout;
            END;
         end;{case}

   END;



{$S TEwork2}
PROCEDURE NewWSel {P: point; Pnl:PnlIndex;VAR Nbh : Rect; VAR timeout: integer};
      {-------------------------------------------------------------------------}
      {Second click of double click.  In panel Pnl at point P.                  }
      {                                                                         }
      {-------------------------------------------------------------------------}
   VAR
       inCell:        boolean;
       relPoint:      point;
       mouseLP:       integer;
       wordIntrvl:    interval;
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if tracesmgr then writeln('tmsprocs newwsel');
      if (Pnl = tblPnl) then begin
         {Make point relative to lower left corner of first character}
         SetPnlPort(CellPnl);
         TransPoint(P, frstCellRect, inCell, relPoint);
         selectWord(relPoint, selFieldH,selFstateH, nbh, timeout);
         offsetrect(nbh,frstcellrect.left,frstcellrect.top);
         IF wavActive THEN
            BEGIN
            SetPnlPort(widePnl);
            RepWordSelect(selfstateh^^.select.int, wavFieldH, wavFstateH);
            END;
         if tracesmgr then
            begin
            writeln('p ',p.h,p.v);
            writeln('relpoint.h  ',relpoint.h, ' mouselp ',mouselp);
            writeln('selField is:');
            {$IFC FldDebug }
            DumpFldInfo(selFieldH, selFstateH);
            {$ENDC }
            writeln('wordIntrvl is ', wordIntrvl.lpFst, ' /', wordIntrvl.lpLim);
            writeln('wavField is:');
            {$IFC FldDebug }
            DumpFldInfo(wavFieldH, wavFstateH);
            {$ENDC }
            {$IFC tedebug}
            writeln('frstcellrect');
            prntrect(frstcellrect);
            writeln('nbh');
            prntrect(nbh);
            {$ENDC}
            end;
         end
      else begin
         SetPnlPort(widePnl);
         selectWord(P, wavFieldH, wavFstateH, nbh, timeout);
         SetPnlPort(cellPnl);
         RepWordSelect(wavfstateh^^.select.int, selFieldH, selFstateH);
         (* if traceSmgr then begin
            writeln('wordIntrvl is ', wordIntrvl.lpFst, '/', wordIntrvl.lpLim);
            writeln('selField is:');
            {$IFC FldDebug }
            DumpFldInfo(selFieldH, selFstateH);
            {$ENDC}
            end; *)
         end;
      NewRgImg(currRg);
   END;


{$S TEwork2}
PROCEDURE NullCR;
      {-------------------------------------------------------------------------}
      {Constructs a null selection when mouse goes down out of table            }
      {                                                                         }
      {-------------------------------------------------------------------------}

   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('tmsprocs nullcr');
   EndCR;
   SetRg(currRg, aNullRg, NullSnip, NullSnip, NullSnip, NullSnip);
   END;


{$S TEwork2}
PROCEDURE NullSel;
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('tmsprocs nullsel');
   TypeOfSel := aNullSl;
   END;


{$S TEcold}
Procedure PackSMGR{hndsusdata:hnddata;offset:integer;curlen:integer;
                       var leninstalled:integer; var newlen:integer};
   VAR
       sptr : psmgrState;
       hr : hndruns;
       hd : hnddata;
       pd : ptrdata;

   BEGIN

{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('%tmsprocs packsmgr','offset: ',offset:4);
   LenInstalled := sizeOF(smgrstate)+selfieldH^^.maxlen + wavfieldH^^.maxlen
          + (selfieldH^^.maxfmts+wavfieldH^^.maxfmts)*sizeOF(run);
   if Odd(selfieldH^^.maxlen) then lenInstalled := lenInstalled + 1;
   if Odd(wavfieldH^^.maxlen) then lenInstalled := lenInstalled + 1;

   {make space for this stuff}
   IF (curlen-offset)< lenInstalled then
      BEGIN
      {expand handle}
      ChangeSizeH(hzFromH(POINTER(ORD(hndsusdata))),POINTER(ORD(hndsusdata)),
                  curlen+LenInstalled);
      newlen := curlen + lenInstalled;
      END
   ELSE newlen := curlen;


   sptr := Pointer(ORD(hndsusdata^)+offset);
   With sptr^ do
      BEGIN
      sFolderPnl := FolderPnl;
      sCellPnl := CellPnl;
      sTblPnl := TblPnl;
      sWidePnl := WidePnl;
      sDialogPnl := DialogPnl;
      swavactive := wavactive;
      stypeofsel := typeofSel;
      sgrowfield := GrowField;
      sselcircled := SelCircled;
      seditrow := EditRow;
      seditcol := EditCol;
      sgridcollo := GridColLo;
      sstrow := StRow;
      sstcol := StCol;
      slastrow := LastRow;
      slastcol := Lastcol;
      stgridH := TGridH;
      sinitGrdH := InitGrdH;
      sselmode := SelMode;
      slasthilite := LastHilite;
      sfrstcellrect := frstCellRect;
      sfrstscrnrect := frstScrnRect;
      sselRect := SelRect;
      sCurrRg := CurrRg;
      sselfstate := SelFstateH^^;
      swavfstate := WavFstateH^^;
      sselfield := SelFieldH^^;
      swavfield := WavFieldH^^;
      END;

   {save run info}
   hr := selfieldH^^.fmtinfo;
   pd := POINTER(ORD(hndsusdata^) + offset + sizeOF(smgrstate));
   moveleft(hr^^,pd^,selfieldH^^.maxfmts*sizeOF(run));
   pd := POINTER(ORD(pd) + selfieldH^^.maxfmts*sizeOF(run));
   hr := wavfieldH^^.fmtinfo;
   moveleft(hr^^,pd^,wavfieldH^^.maxfmts*sizeOF(run));
   pd := POINTER(ORD(pd) + wavfieldH^^.maxfmts*sizeOF(run));

   {save value}
   hd := selfieldH^^.curvalue;
   moveleft(hd^^,pd^,selfieldH^^.maxlen);
   if Odd(selfieldH^^.maxlen) then selfieldH^^.maxlen := selfieldH^^.maxlen + 1;
   pd := POINTER(ORD(pd) + selfieldH^^.maxlen);
   hd := wavfieldH^^.curvalue;
   moveleft(hd^^,pd^,wavfieldH^^.maxlen);

   END;


{$S TEwork2}
PROCEDURE PasteSel{pasteruns:boolean ;PasteLimit:integer; var status : integer };
   VAR errnum : integer;
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   IF TraceSMGR then Writeln('%tmsprocs Pastesel' );

   PasteField(selFieldH,selFstateH,errnum, pasteruns, pastelimit );
   if selcircled then
      begin
      selfstateH^^.validlp := 0;
      selcircled := false;
      end;
   PasteField(wavFieldH,wavFstateH,errnum, pasteruns, pastelimit );

   Status := errnum;
   END;


{$S TEcold}
Procedure PointAtRg{P: Point; var pRg: range; var nbh: rect};
        {The mouse has gone down at P (with the option key pressed).  Return
         the range (pRg) that would be selected by this mouse-down, and the
         nbh for further dragging of the mouse.  Do not change any selections
         or current ranges, but remember where this pointing began to support
         MovePointer.}
      var
         pTPart: TblPart;
         pFrstCellRect, pFrstScrnRect: rect;
      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if tracesmgr then writeln('%tmsprocs pointatrg');
         FindTblPt(P, pTPart, pRg, pFrstCellRect, pFrstScrnRect);
         with pRg do
            case rKind of
               aRowHedRg : rKind := aRowRg;
               aColHedRg : rKind := aColRg;
               aWTBoxRg  : setRg(pRg, aNullRg, nullSnip, nullSnip, nullSnip, nullSnip);
            end;
         nbh := pFrstScrnRect;
         pStRow := pRg.loRow;
         pStCol := prg.loCol;
      end;


{$S TEwork2}
Procedure redrawSel{showselect:boolean};
   VAR T:INTEGER;
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('tmsprocs redrawsel');
   SetPnlPort(cellPnl);
   DrawField(selFieldH, selFstateH, showselect, true);
   if wavactive then
      begin
      SetPnlPort(widePnl);
      DrawField(wavFieldH, wavFstateH, showselect, true);
      end;
   if selcircled then circlecell(t);
   NewRgImg(currRg);
   END;


{$S TEwork2}
PROCEDURE ReSelCR{VAR timeout : INTEGER;
                  hilite : cellseltype};
      {-------------------------------------------------------------------------}
      {Sets Selection based upon the current range  Highlight cell as           }
      {Designated by the hilite param                                           }
      {-------------------------------------------------------------------------}
   VAR
             row : idtype;
             col : idtype;
             fullrect:rect;
             t:integer;
             xrect:rect;
             saveport : grafptr;

   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then
         BEGIN
         Writeln( '%tmsprocs', 'reselcr');
         {$IFC tedebug}
         prntRg( 'CurrRg', CurrRg);
         {$ENDC}
         END;
      timeout := nullTimeout;
      frstCellRect := aNullRect;
      frstScrnRect := aNullRect;
      case CurrRg.rkind of
         a1CellRg:
              BEGIN
              if (hilite <> selectCell) then
                 BEGIN
                 SetPnlPort(CellPnl);
                 hiLightSel(selFieldH,selFstateH,False);
                 SetPnlPort(WidePnl);
                 hiLightSel(wavFieldH,wavFstateH,False);
                 END;
              case hilite of
                 selectContents:
                    BEGIN
                    TypeOfSel := aCelltxtSl;
                    ChgRgBorders(CurrRg,false);
                    SelAllTxt(timeout);
                    END;
                 selectCell:
                    BEGIN
                    {LisaCAlc/BusGraphics 'select whole cell'}
                    TypeOfSel := a1CellSl;
                    ChgRgBorders(CurrRg,true);
                    timeout := dflttimeout;
                    END;
                 PutCaretAtEnd:
                    BEGIN
                    TypeOfSel := aCellTxtSl;
                    ChgRgBorders(CurrRg,false);
                    CircleCell(timeout);
                    END
                 END; {cAse}
              newRgImg(CurrRg);
              END;
         aColHedRg,
         aRowHedRg:
              BEGIN
              IF NOT ((currRg.lorow = CurrRg.lorow) AND (currRg.locol = CurrRg.locol)) THEN
                 BEGIN
                 IF CurrRg.rkind = aColHedRg then TypeOfSel := aColHedSl
                 ELSE IF CurrRg.rkind = aRowHedRg then TypeOFSel := aRowHedSL;
                 ChgRgBorders(CurrRg,False);
                 row := CurrRg.lorow;
                 col := CurrRg.locol;
                 END
             ELSE
                BEGIN
                SetPnlPort(CellPnl);
                hiLightSel(selFieldH,selFstateH,False);
                SetPnlPort(WidePnl);
                hiLightSel(wavFieldH,wavFstateH,False);
                END;

              case hilite of
                 selectContents,
                 selectCell:
                    BEGIN
                    SelAllTxt(timeout);
                    END;
                 PutCaretAtEnd:  (*ELSE IF (hilite = PutCaretAtEnd) Then*)
                    BEGIN
                    CircleCell(timeout);
                    END;
                 END; {case}
              newRgImg(CurrRg);
              END;
         aRectRg,
         aRowRg,
         aColRg,
         aWTBoxRg:
              BEGIN
              Case CurrRg.RKind of
                 aRectRg:  typeOfSel := aRectRgSl;
                 aRowRg:   typeOfSel := aRowRgSl;
                 aColRg:   typeOfSel := aColRgSl;
                 aWTBoxRg: typeOfSel := aWTBoxSl;
                 END; {case}

              chgRgBorders(CurrRg,true);
              timeout := dflttimeout;
              END;

         aRowGrid:
              BEGIN
              TypeOfSel := aRowGrdSl;
              chgrgborders(currrg,true);
              timeout := dflttimeout;
              END;

         aColGrid:
              BEGIN
              TypeOfSel := aColGrdSl;
              chgrgborders(currrg,true);
              timeout := dflttimeout;
              END;

         END;
   END;


{$S TEopen2}
PROCEDURE ReInitSelMgr;
        {reinitialize static stuff}
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('%tmsprocs reinitselmgr');
   tGridh := -1;
   TypeOfSel := aNullSl;
   editRow := nullSnip;
   editCol := nullSnip;
   {SetRg(currRg,anullRg,nullSnip,nullSnip,nullSnip,nullSnip);} {hard coded so as not to bring in smgrseg}
   With CurrRg do
      begin
      rkind := anullRg;
      loRow := nullsnip;
      loCol := nullsnip;
      hiRow := nullsnip;
      hiCol := nullsnip;
      end;
   SetRect(aNullRect, 0, 0, 0, 0);
   selcircled := false;
   end;


{$S TEwork2}
PROCEDURE restoreRgFB {var timeout: integer};
        {Tell the table mgr to restore its info on the current range feedback for the
        current range and selection.  Assume that all range border info has
        been removed, but that the screen still shows the range feedback.}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if TraceSmgr then Writeln('%tmsprocs restoreRgFB' );
        timeout := nullTimeout;
        case TypeOfSel of
           aCellTxtSl,
           aRowHedSl,
           aColHedSl:  begin
                           tmSetRgFB(currRg, false);
                           StartBlink(timeout);
                           end;
           Otherwise       begin
                           tmSetRgFB(currRg, true);
                           timeout := dflttimeout;
                           end;
           end;
     end;


{$S TEwork2}
PROCEDURE ReSizeFlds;
   VAR
        xrect:rect;

   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('%tmsprocs changeCellFont');

   {this routine called after mxmgr can return revised cell widths and fonts}
   {note : panels should also have been resized  }
   {it is the responsibility of the caller to redraw the selection sometime}
   { after this routine is called, though it is setupp to do so on the }
   {next timeout}

   CASE TypeOFSel of
      a1CellSl,
      aCellTxtSl,
      aRowHedSl,
      aColHedSl:
         BEGIN


         {fix up new cell rectangle}
         setRect(xrect,0,0,snipwidth(colkind,CurrRg.locol),
                           snipwidth(rowkind,CurrRg.lorow));
         SetFCoords(selfieldH,nil,xrect);
         getPnlRect(widePnl,xrect);
         setFcoords(wavFieldH,nil,xRect);

         selfstateh^^.validlp := 0;
         wavfstateh^^.validlp := 0;

         selfstateh^^.valid := FALSE;
         wavfstateh^^.valid := FALSE;

         END;
      END; {case}
   END;

{$S TEcold}
PROCEDURE RestoreFlds{var curtimeout:integer};
   var fullrect : rect;
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('%tmsprocs restoreflds');
   with currRg do
      begin
      getHedRect(currRg.lorow,currRg.locol,fullrect);
      SetCellField(CurrRg.lorow,CurrRg.locol,fullrect,selfieldH,selfstateH);
      end;

   if selcircled then
      begin
      selfstateH^^.validlp := 0;
      selcircled := false;
      end;
   redrawsel(false);
   selFstateH^^.changed := true;
   wavFstateH^^.changed := true;
   setsel(selfieldh,selfstateh,0,0,tyselpt);
   setsel(wavfieldh,wavfstateh,0,0,tyselpt);
   END;

{$S TEwork2}
PROCEDURE RowGridSel{rowLo, rowHi : IdType};
      {-------------------------------------------------------------------------}
      {Mouse Down on row grid handle.  Set up grid selection.                   }
      {                                                                         }
      {-------------------------------------------------------------------------}
   VAR
       Status : INTEGER;

   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('tmsprocs RowGridSel' );
      TypeOfSel := aRowGrdSl;
      setRg(currRg, aRowGrid, rowLo , mInfSnip, rowHi , pInfSnip);
      chgrgborders(currrg,true);

   END;



{$S TEwork2}
PROCEDURE RowSel{Row : IdType;
                 V : INTEGER;
                 VAR nbh : Rect;
                 scrnrect : rect;
                 VAR timeout: integer};
      {-------------------------------------------------------------------------}
      {Mouse down in row handle. set up selection.                              }
      {                                                                         }
      {-------------------------------------------------------------------------}
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('tmsprocs RowSel' );
      EndCR;
      setRg(currRg, aRowRg  ,   row , mInfSnip,    row, pInfSnip);
      newrgBorders(currRg,true);

      TypeOfSel := aRowRgSl;
      timeout := dflttimeout;
      nbh := scrnrect;
      stRow := row;
      stCol := minfSnip;

   END;



{$S TEwork2}
PROCEDURE SelAllTxt{VAR timeout : INTEGER};
      {-------------------------------------------------------------------------}
      {selects all of the text in the cell which has the current selection.     }
      {Assumes selField and currRg are set up                                   }
      {-------------------------------------------------------------------------}
   VAR selchanged,
       wavchanged : boolean;
      BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('tmsprocs SelAllTxt' );
         SetPnlPort(CellPnl);
         selchanged := selFstateH^^.changed;
         ExitField(selFieldH,selFstateH);
         SelectAll(selFieldH,selFstateH,timeout);
         selFstateH^^.changed := selchanged;
         NewRgImg(currRg);
         IF wavActive then
            BEGIN
            SetPnlPort(widePnl);
            wavchanged := wavFstateH^^.changed;
            ExitField(wavFieldH,wavFstateH);
            SelectAll(wavFieldH,wavFstateH,timeout);
            wavFstateH^^.changed := wavchanged;
            END;

   END;




{$S TEwork2}
PROCEDURE selFromWav;
        {Produce selField and selFstate from wavField and wavFstate, copying
        everything but the alignment and coords and the "constants" in
        the fields.  The hilight in sel will be left off.}
     var
        i: integer;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     if tracesmgr then writeln('tmsprocs selfromwav');
        with wavFieldH^^ do begin
           selFieldH^^.curLen := curLen;
           for i := 0 to maxLen - 1 do
              selFieldH^^.curvalue^^[i] := curvalue^^[i];
           selFieldH^^.curFmts := curFmts;
           for i := 0 to maxFmts - 1 do
              selFieldH^^.fmtInfo^^[i] := fmtInfo^^[i];
           selFieldH^^.protect := protect;
           end;
        HilightSel(selFieldH, selFstateH, false);
        selFstateH^^ := wavFstateH^^;
     end;




{$S TEwork2}
PROCEDURE SelInTbl{P: point;
                   hilite: cellseltype;
                   VAR nbh: Rect;
                   VAR timeout:integer};
        {The mouse has gone down at P.  Do the appropriate selection, according
        to selMode and return nbh and timeout.}

VAR
      rg: range;
      cellRect : Rect;
      scrnrect: rect;
      TPart : TblPart;

   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('tmsprocs SelInTbl' );
      if traceSmgr then writeln('Called with point: ', P.h, '/', P.v);
      FindTblPt(P, TPart, rg, cellRect,scrnrect);
      {$IFC tedebug}
      if TraceSmgr then prntRg('FindTblPt returned: ', rg);
      {$ENDC}

      if tracesmgr then
         begin
         writeln('tpart ',ord(tpart));
         writeln('hilite ',ord(hilite));
         writeln('row, title ', tblpars.editrowtitle,tblpars.editcoltitle);
         end;
      with rg do
         begin
         if ((tpart = rowhed  )  AND (hilite = selectcell)) OR
            ((tpart = rowhed ) AND NOT Tblpars.editrowtitle AND Tblpars.RowRangeOk) then
            begin
            {force tpart and rg to rowheader}

            tpart := rowhandl;
            rkind := aRowRg;
            hicol := pinfsnip;
            end;
         if ((tpart = colhed  )  AND (hilite = selectcell)) OR
            ((tpart = colhed ) AND NOT Tblpars.editcoltitle AND Tblpars.ColRangeOk) then
            begin
            tpart := colhandl;
            rkind := acolrg;
            hirow := pinfsnip;
            end;


         frstCellRect := cellRect;
         frstScrnRect := scrnRect;
         strow := lorow;
         stcol := locol;

         CASE Tpart OF

            outOfTbl:
                  BEGIN
                  NullCR;
                  END;

            cellArea:
                  BEGIN
                  If ValidCoord(rg) Then begin
                     if (selMode = selText) then
                         MsSel(P,Tpart,rg,cellRect,scrnrect,Nbh,Timeout)
                     else begin
                        nbh := frstScrnRect;
                        DoSelCR(rg, timeout, hilite);
                        end;
                     end
                  ELSE
                      NullCR;
                  END;
            rowGrid:
                  BEGIN
                  RowGridSel(loRow, hiRow);
                  END;

            ColGrid:
                  BEGIN
                  ColGridSel(loCol, hiCol, scrnRect,P,  Nbh);
                  END;

            rowHandl:
                  BEGIN
                  if Tblpars.rowrangeok then
                     RowSel(loRow, P.v, Nbh, scrnrect, timeout);
                  END;

            colHandl:
                  BEGIN
                  if Tblpars.colrangeok then
                     ColSel(loCol, P.h, Nbh, scrnrect, timeout);
                  END;

            rowHed:
                  BEGIN
                  IF TblPars.editRowTitle THEN
                    BEGIN
                    if (selMode = selText) then
                       MsSel(P,Tpart,rg,cellRect,scrnrect,Nbh,Timeout)
                    else begin
                       nbh := frstScrnRect;
                       DoSelCR(rg, timeout, hilite);
                       end;
                    END
                  ELSE NullCR;

                  END;

            colHed:
                  BEGIN
                  IF TblPars.editColTitle THEN
                    BEGIN
                    if (selMode = selText) then
                       MsSel(P,Tpart,rg,cellRect,scrnrect,Nbh,Timeout)
                    else begin
                       nbh := frstScrnRect;
                       DoSelCR(rg, timeout, hilite);
                       end;
                    END
                  ELSE NullCR;
                  END;

            whTbBox:
                  BEGIN
                  NullCR;
                  END;

            END;{case}
         end;{with}
   END;{DoTblSel}





{$S TEwork2}
PROCEDURE SelNewCell{P: point; hilite: cellseltype; VAR nbh: Rect;
                     VAR timeout: integer};
        {Select the cell at P with hilite and return nbh and timeout.  Save
        the hilite setting in lastHilite in case the user drags out and then
        back into this cell.}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     if tracesmgr then writeln('tmsprocs selnewsel');
        lastHilite := hilite;
        selMode := selCells;
        SelInTbl(P, hilite, nbh, timeout);
     end;


{$S TEcold}
PROCEDURE SetAnchorCell {RowId, colId: idtype};
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('tmsprocs setAnchorCell');
   strow  := rowid;
   stcol  := colid;
   END;



{$S TEwork2}
PROCEDURE SetCellField{row : Idtype;
                       col : IdType;
                       cellRect : Rect;
                       VAR cfieldH : hndField;
                       VAR cfstateH:hndFstate};
      {-------------------------------------------------------------------------}
      { Set up field record for field editing routines. Also set up editrow     }
      { and editcol to the row and col being edited                             }
      {-------------------------------------------------------------------------}

   VAR
          Length : Integer;
          CellInf : cellrecord;
          status:integer;
          I : integer;
          xrect: rect;
          backgpat : pattern;
          saveport : Grafptr;
          fontHand:  Handle;
          errnum:    integer;
          maxnumruns : integer;
          wideRect:  rect;
          newrunsize:integer;



   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('tmsprocs SetCellField' );

      CellInfo( CRecord, MMRead,row,col,cellinf);
      with cfieldh^^ do
         begin
         Length := maxlen;
         drawPad := tblPars.fieldPad;      {This statement will be unnecessary
                                                 once we've settled on a single,
                                                 unchanging fieldPad value}
         CellValue(MMRead,row,col,curvalue^,TRUE,Length,status);
         end;
      if (status = cvnotenuff ) and growfield then
         begin
         if tracesmgr then writeln('expanding data field length returned ',length:4);
         i := 1;
         while (i*maxwav) <= length do i := i + 1;
         length := i*maxwav;
         if tracesmgr then writeln('expanding data field new length ',length:4);
         changesizeh(theheap,POINTER(ORD(cfieldh^^.curvalue)),length);
         changesizeh(theheap,POINTER(ORD(wavfieldh^^.curvalue)),length);
         with cfieldh^^ do
            begin
            maxlen := length;
            wavfieldh^^.maxlen := length;
            CellValue(MMRead,row,col,curvalue^,TRUE,Length,status);
            if fwriteln then if status <> 0 then writeln('2nd cellvalue status',status:4);
            end;
         end
      ELSE if fwriteln then if status <> 0 then writeln('setcellfield cellvalue status',status:4);

      cfieldH^^.curlen := Length;
      SetFAlign(cfieldH,nil,cellinf.align);
      setRect(xrect,0,0,cellrect.botright.h-cellrect.topleft.h,
                                cellrect.botright.v-cellrect.topleft.v);
      SetFCoords(cfieldH,nil,xrect);
      cfieldH^^.protect := false;
      with wavfieldh^^ do
         begin
         Length := maxlen;
         CellValue(MMRead,row,col,curvalue^,TRUE,Length,status);
         if fwriteln then if status <> 0 then writeln('setwavfield cellvalue status',status:4);
         curlen := Length;
         SetFAlign(wavFieldH,nil,left);
         getPnlRect(widePnl,widerect);
         setFcoords(wavFieldH,nil,wideRect);
         protect := false;
         end;
     if cellinf.numruns > 0 then
         begin
         maxnumruns := cfieldh^^.maxfmts;
         CellRun(MMRead,row,col,cfieldH^^.fmtInfo^,maxnumruns,status);
         if (status = crnotenuff) and growfield then
            begin
            if tracesmgr then writeln('expanding run handle');
            newrunsize := maxnumruns*sizeof(run);
            changesizeh(theheap,POINTER(ORD(cfieldh^^.fmtinfo)),newrunsize);
            changesizeh(theheap,POINTER(ORD(wavfieldh^^.fmtinfo)),newrunsize);
            cfieldh^^.maxfmts := maxnumruns;
            wavfieldh^^.maxfmts := maxnumruns;
            CellRun(MMRead,row,col,cfieldH^^.fmtInfo^,maxnumruns,status);
            if fwriteln then if status <> 0 then writeln('2nd cellrun status',status:4);
            end
         ELSE if fwriteln then if status <> 0 then writeln('setcellfield cellrun status',status:4);

         selFieldH^^.curfmts:= maxnumruns;
         wavFieldH^^.curfmts:= maxnumruns;
         maxnumruns := wavfieldh^^.maxfmts;
         CellRun(MMRead,row,col,wavfieldH^^.fmtInfo^,maxnumruns,status);
         end
      ELSE
         begin
         selFieldH^^.curfmts := 1;
         wavFieldH^^.curfmts := 1;
         SetRunFormat(cfieldH, nil, cellinf.font.fam, setnormal, errnum);
         SetRunFormat(wavfieldH, nil, cellinf.font.fam, setnormal, errnum);
         end;


      {run info may have wrong font, so always use correct one}                    {#lm187}
      SetRunFormat(cfieldH, nil, cellinf.font.fam, setfont, errnum);
      SetRunFormat(wavfieldH, nil, cellinf.font.fam, setfont, errnum);

      if (row = minfsnip) or (col=minfsnip) then
         SetRunFormat(cfieldH, nil, cellinf.font.fam, setbold, errnum);
      SetFProtect(cfieldH,nil,cellinf.protected);
      InitFstate(cfieldH,cfstateH);
      if (row = minfsnip) or (col=minfsnip) then
          SetRunFormat(wavfieldH, nil, cellinf.font.fam, setbold, errnum);
      SetFProtect(wavFieldH,nil,cellinf.protected);
      InitFstate(wavFieldH,wavFstateH);
      setPnlPort(CellPnl);
      getport(saveport);
      xrect := cFieldH^^.coords;
      rectrgn(saveport^.cliprgn,xrect);
      if cellInf.hilite then
         Begin
         {put a round rect around the field}
         pennormal;
         pensize(3,2);
         frameroundrect(xrect,15,10);
         insetrect(xrect,3,2);
         pennormal;
         penmode(-1);
         openrgn;
         frameroundrect(xrect,15,10);
         closergn(saveport^.cliprgn);
         pennormal;
         selcircled := true;
         end
      else selcircled := false;
      EditRow := row;
      EditCol := col;

      {fix undo stuff}
      uinfo.lastop := noOp;


      if traceSMgr then begin
         writeln('At end of SetCellField, SelField is');
         {$IFC FldDebug }
         DumpFldInfo(cfieldH,cfstateH);
         {$ENDC}
         {$IFC tedebug}
         writeln('cellrect');
         prntrect(cellrect);
         {$ENDC}
         end;


   END;

{$S TEwork2}
PROCEDURE SetCellStr  {str:str40 };
      {-------------------------------------------------------------------------}
      { Set up field record for field editing routines. Also set up editrow     }
      { and editcol to the row and col being edited                             }
      {-------------------------------------------------------------------------}

   VAR
          Leng : Integer;
          CellInf : cellrecord;
          status:integer;
          I : integer;
          xrect: rect;
          row,col : Idtype;
          ptrd : ptrdata;


   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('tmsprocs SetCellStr' );
      IF currRg.rkind = a1CellRg then
         BEGIN
         with selfieldh^^ do
            begin
            curlen := Length(str);
            ptrd := @str;
            ptrd := @ptrd^[1];
            FOR i := 0 to curlen-1 do
               curvalue^^[i] := ptrd^[i];
            InitFstate(selFieldH,selFstateH);
            FOR i := 0 to curlen-1  do
               wavFieldH^^.curvalue^^[i] := curvalue^^[i];
            wavFieldH^^.curlen := curlen;
            InitFstate(wavFieldH,wavFstateH);
            selFstateH^^.changed := true;
            wavFstateH^^.changed := true;
            redrawsel(false);
            end;
         END;
   END;






{$S TEwork2}
PROCEDURE TransPoint{TblPoint : Point;
                     cellRect : Rect;
                     VAR InRect : BOOLEAN;
                     VAR relPoint : Point};
      {-------------------------------------------------------------------------}
      { Translate point which is relative to upper left of table to be upper    }
      { left relative to cellrect.  If pt not in cellrect then inrect := false  }
      {-------------------------------------------------------------------------}

   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('tmsprocs transPoint' );
      with cellrect do
         begin
         relPoint.h := tblPoint.H - topleft.h;
         relPoint.v := tblPoint.v - topleft.v;

         IF (Tblpoint.h < topleft.h) OR
              (tblPoint.h > botRight.h) OR
              (tblPoint.v < topleft.v) OR
              (tblPoint.v > botRight.v)
            THEN
              inRect := FALSE
            ELSE inRect := TRUE;
        end;
   END;



{$S TEwork2}
PROCEDURE UnBoldFlds{status:integer};

   VAR
       errnum : integer;
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   IF TraceSMGR then Writeln('%tmsprocs unboldflds' );
   SetRunFormat(selFieldH,selFstateH,p12tile, setnormal,errnum);
   SetRunFormat(wavFieldH,wavFstateH,p12tile, setnormal,errnum);
   status := errnum;
   END;


{$S TEcold}
PROCEDURE UndoSel{ var status : integer};
   VAR errnum : integer;
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   IF TraceSMGR then Writeln('%tmsprocs undosel');
   SetPnlPort(widePnl);
   undoEdit(wavFieldH,wavFstateH, errnum);
   Status := errnum;
   changecellfont;
   if selcircled then
      begin
      selfstateH^^.validlp := 0;
      selcircled := false;
      end;

   selFromWav;
   redrawsel(true);
   END;

{$S TEcold}
Procedure UnpackSMGR{ HndSdata:Hnddata; offset:integer};
   VAR
       sptr : psmgrState;
       selcurvh,
       wavcurvh: hnddata;
       selcurfh,
       wavcurfh: hndruns;
       xlen : integer;

       ptrd : ptrdata;

   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if tracesmgr then writeln('%tmsprocs unpacksmgr: offset: ',offset:4);

   sptr := Pointer(ORD(hndsdata^)+ offset);


   xlen := sptr^.sselfield.maxfmts * sizeOF(run);

   IF sptr^.sselfield.maxfmts > selfieldH^^.maxfmts then
      BEGIN
      {expand handle size}
      changesizeH(hzfromH(POINTER(ORD(selfieldh^^.fmtinfo))),
                          POINTER(ORD(selfieldh^^.fmtinfo)),
                          xlen);
      END;

   sptr := Pointer(ORD(hndsdata^)+ offset);
   xlen := sptr^.swavfield.maxfmts * sizeOF(run);
   IF sptr^.swavfield.maxfmts > selfieldH^^.maxfmts then
      BEGIN
      {expand handle size}
      changesizeH(hzfromH(POINTER(ORD(wavfieldh^^.fmtinfo))),
                          POINTER(ORD(wavfieldh^^.fmtinfo)),
                          xlen);
      END;


   sptr := Pointer(ORD(hndsdata^)+ offset);
   xlen := sptr^.sselfield.maxlen;
   if ODD(xlen) then xlen := xlen + 1;

   IF xlen > selfieldH^^.maxlen then
      BEGIN
      {expand handle size}
      changesizeH(hzfromH(POINTER(ORD(selfieldh^^.curvalue))),
                          POINTER(ORD(selfieldh^^.curvalue)),
                          xlen);
      END;

   sptr := Pointer(ORD(hndsdata^)+ offset);
   xlen := sptr^.swavfield.maxlen;
   if ODD(xlen) then xlen := xlen + 1;
   IF xlen > selfieldH^^.maxlen then
      BEGIN
      {expand handle size}
      changesizeH(hzfromH(POINTER(ORD(wavfieldh^^.curvalue))),
                          POINTER(ORD(wavfieldh^^.curvalue)),
                          xlen);
      END;

   sptr := Pointer(ORD(hndsdata^)+ offset);
   With sptr^ do
      BEGIN
      FolderPnl := sFolderPnl;
      CellPnl := sCellPnl;
      TblPnl := sTblPnl;
      WidePnl := sWidePnl;
      DialogPnl := sDialogPnl;
      wavactive := swavactive;
      typeofsel := stypeofSel;
      growfield := sGrowField;
      selcircled := sSelCircled;
      editrow := sEditRow;
      editcol := sEditCol;
      gridcollo := sGridColLo;
      strow := sStRow;
      stcol := sStCol;
      lastrow := sLastRow;
      lastcol := sLastcol;
      tgridH := sTGridH;
      initGrdH := sInitGrdH;
      selmode := sSelMode;
      lasthilite := sLastHilite;
      frstcellrect := sfrstCellRect;
      frstscrnrect := sfrstScrnRect;
      selRect := sSelRect;
      CurrRg := sCurrRg;
      selfstateh^^ := sSelFstate;
      wavfstateh^^ := sWavFstate;
      END;

   {save handles in field data structures;}
   selcurvh := selfieldH^^.curvalue;
   wavcurvh := wavfieldH^^.curvalue;
   selcurfh := selfieldH^^.fmtinfo;
   wavcurfh := wavfieldH^^.fmtinfo;

   {restore fields}
   selfieldH^^ := sptr^.sSelField;
   wavfieldH^^ := sptr^.sWavField;

   {restore handles}
   with SelfieldH^^ do
     begin
     curvalue := selcurvh;
     fmtinfo := selcurfh;
     end;

   with WavfieldH^^ do
     begin
     curvalue := wavcurvh;
     fmtinfo := wavcurfh;
     end;


   ptrd := POINTER(ORD(sptr) + sizeOF(smgrstate));
   {ptrd points to run info for selfield}

   moveleft(ptrd^,selfieldH^^.fmtinfo^^,selfieldh^^.maxfmts*sizeOF(run));
   ptrd := POINTER(ord(ptrd) + selfieldh^^.maxfmts*sizeOF(run));

   moveleft(ptrd^,wavfieldH^^.fmtinfo^^,wavfieldh^^.maxfmts*sizeOF(run));
   ptrd := POINTER(ord(ptrd) + wavfieldh^^.maxfmts*sizeOF(run));

   moveleft(ptrd^,selfieldH^^.curvalue^^,selfieldh^^.maxlen);
   ptrd := POINTER(ord(ptrd) + selfieldh^^.maxlen);
   IF ODD(ORD(ptrd)) then ptrd := POINTER(ORD(ptrd) + 1);

   moveleft(ptrd^,wavfieldH^^.curvalue^^,wavfieldh^^.maxlen);


   IF (typeofSel = aCellTxtSl) or (TypeofSel = a1CellSl) OR
      (typeofSel = aColHedSl) OR (TypeofSel = aRowHedSl) then
      begin
      {draw field into offscreen bitmap}
      selfstateh^^.validlp := 0;
      wavfstateh^^.validlp := 0;
      end;
   END;

{$S TEwork2}
Function ValidCoord{(rg:range): Boolean};
      {-------------------------------------------------------------------------}
      {Returns true if coord is valid , ie no minf ,pinf, or null snips.        }
      {Hence, coord is in a cell not gray area of cellsrect                     }
      {-------------------------------------------------------------------------}
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   IF TraceSMGR then Writeln('tmsprocs validcoord');
   with rg do
      begin
      IF (rkind <> a1CellRg) OR
         (lorow = minfSnip) OR
         (locol = minfSnip) OR
         (lorow = pinfSnip) OR
         (locol = pinfSnip) OR
         (lorow = nullSnip) OR
         (locol = nullSnip) THEN ValidCoord := False


      ELSE ValidCoord := TRUE;
      end;

   END;


{$S TEcold}
PROCEDURE WhTblSel{rg: range; var nbh: Rect; var timeout: integer};
      {-----------------------------------------------------------------------}
      {    Select whole table                                                 }
      {-----------------------------------------------------------------------}
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
      IF TraceSMGR then Writeln('%tmsprocs whtblsel' );
      currRg := rg;
      TypeOfSel := aWTBoxSl;
      NewRgBorders(currRg, true);
      GetPnlRect(tblPnl, nbh);
      timeout := dfltTimeout;
   END;


{$S TEwork2}
FUNCTION WideLogPos{(mouseLoc: point) : Integer};
   {-------------------------------------------------------------------------}
   {Translates the logical position of the mouse in the cell to a logical    }
   {position in the wide angle view                                          }
   {-------------------------------------------------------------------------}
   VAR
       wideE, cellE : Integer;
       cellLp, wideLp : Integer;
       valid: boolean;
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   IF TraceSMGR then Writeln('tmsprocs WideLogPos' );
   cellLP := LpFromX(mouseLoc.h, selFieldH, selFstateH,selFstateh^^.select.tysel);          {#lm185}
   cellLp := compressedLp(cellLP, selFieldH, selFstateH, valid);
   if fwriteln then if not valid then begin
      writeln('tmsprocs    WideLogPos    Bad compressedLP');
      writeln('After WideLogPos, cellLP = ', cellLP);
      end;
   wideLP := cMin(wavFieldH^^.curlen, cellLP);
   wideLogPos := ExpandedLp(wideLP, wavFieldH, wavFstateH);
   END;


ÿ