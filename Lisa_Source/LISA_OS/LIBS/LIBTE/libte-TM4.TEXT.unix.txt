                {libte/tm4.text}

              {this file included from libte/tm.text}




{******************************************************}
{$S TEwork1}

procedure shoJRg{aSide: snipSide; aSnip: idType; aBandX: bandX;
                 isGrid: boolean};
        {scroll data+screen of aBand so as to show aSnip on
        aSide of aBand;
        isGrid => grid to hiside of aSnip is to be shown AND
         there is room for aSnip in aBand}
     var
        aHideP, adjBHiP:        pixel;
        bSnip:                  idType;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aBandX^ do begin
        if isGrid and (aSide = hiSide) and (aSnip <> pInfSnip) then begin
           getSnipId(bKind, mmNext, 0, aSnip, bSnip);
           if snipWidth(bKind, bSnip)+2 < (bHiP - bLoP) then
              aSnip := bSnip
           else
              aSide := loSide;
        end;

        if aSide = hiSide then
           ifScrSnN(aBandX, aSnip, aSnip, aHideP)
        else
           aHideP := 0;
        adjBHiP := cMax( bLoP,
                  cMin(bHiP,
                         tblRect.botRight.vh[axisOfSKind[bKind]]
                      )
               );
        dontOverScroll(aBandX, aSnip, aHideP, adjBHiP);
        scrToSnip(aBandX, aSnip, aHideP);
     end; end;



{******************************************************}
{$S TEwork1}

procedure shoNear {aBandX: bandX; aSnip: idType; isGrid: boolean};
        {Assure that aSnip is wholly visible (if possible) in aBand;
        scroll only if necessary and then only minimally;
        isGrid => we want to show the grid line to the right of aSnip
        and there is room for all of aSnip in aBand}
     var aSnipX   : snipX;
         tempSide : snipSide;
         doShoJRg : boolean;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        doShoJRg := true;
        aSnipX   := snipXOfId(aBandX, aSnip);
        with aSnipX^, aBandX^ do begin
           if aSnipX <> nil then begin          {aSnip is at least partially visible}
              if sLoP < bLoP then tempSide := loSide
              else if bHiP < sLoP+sDp then tempSide := hiSide
              else doShoJRg := false
           end          {aSnip is not at all visible, scroll minimally}
           else if snipLT(bKind, aSnip, bLoId) then tempSide := loSide
           else tempSide := hiSide;

           if doShoJRg then shoJRg(tempSide, aSnip, aBandX, isGrid)
        end
     end;






{******************************************************}
{$S TEwork1}

procedure shoNewRg {oldRg: range; newRg: range; just: rgJust};
        {assure newRg is showing in curr view according to
         rgJust; ignore oldRg}
var aView : view;
begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
   {$IFC tedebug}
   if traceXTmgr then begin
      writeln('tm shoNewRg, just = ',ord(just));
      prntRg( 'newRg', newRg);
   end;
   {$ENDC}

   setPnlPort(tblPnl);
   getCurView(aView);
   with newRg, aView do begin
      case rKind of
        a1CellRg,
        aRectRg : begin
                     {make upper left cell visible}
                     curShoState := ShoIfClose;
                     shoSnip(just, vBandX[rowKind], loRow,  False);
                     shoSnip(just, vBandX[colKind], loCol,  False);
                  end;
        aRowRg,
        aRowHedRg,  {make initial row visible}
        aRowGrid  : shoSnip(just, vBandX[rowKind], loRow,  rKind = aRowGrid);

        aColRg,
        aColHedRg,  {make initial column visible}
        aColGrid  : shoSnip(just, vBandX[colKind], loCol,  rKind = aColGrid)

     (* aWTBoxRg  : begin {don't scroll at all} end;
     *)
      end;

      if curShoState = ShoAllTbl then shoTbl(tblRgnH);
      curShoState := ShoNormally
   end
end;




{******************************************************}
{$S TEwork1}

procedure ShoNewWid {aKind: snipKind; loSnip, hiSnip: idType};
        {The widths of snips loSnip through hiSnip have changed.  Totally
        reconstruct and redisplay any bands containing any of loSnip through
        hiSnip}
      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
           if traceXTMgr then begin
              Writeln('tm ShoNewWid; kind, lo, hi:');
              writeln('     ',ord(aKind),loSnip,hiSnip);
           end;

           tmReDoViews;
      end;



{******************************************************}
{$S TEwork1}


procedure shoSelCell {vCellRect: rect};
        {display at vCellRect the current (single cell) selection;
        clipping is already ok -- don't modify it;
        if useMarq then set the background pattern to shadePat;
        otherwise, set it to white}
     var
        sRect:          rect;
        selBitsX,
           tblBitsX:    bitptr;
        backgPat:       pattern;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        getSelCell(selBitsX, sRect);
        GetPnlBits(tblPnl, tblBitsX);
        (*  Old Line was ==> XferRect(selBitsX^, tblBitsX^, sRect, vCellRect, 0, White); *)
        CopyBits(selBitsX^, tblBitsX^, sRect, vCellRect, 0, Nil); {!New QuickDraw Fix. Eric Zarakov 11/1/83}

        {$IFC tedebug}
        if traceXTMgr then
              if (oldSRect.left <> sRect.left) or
                 (oldSRect.top <> sRect.top) then begin
           oldSRect := sRect;
           writeln('tm shoSelCell, sRect, vRect = ');
           prntRect(sRect);
           prntRect(vCellRect);
        end;
        {$ENDC}


     end;



{******************************************************}
{$S TEwork1}

procedure shoSnip {just: rgJust; aBandX: bandX; aSnip: idType;
                   isGrid: boolean};
        {assure aSnip is showing in aBand, according to just;
         isGrid => target isGrid line: be sure grid line following
         aSnip is visible}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aBandX^ do begin
        if isGrid then begin
           if aSnip = mInfSnip then begin
              getSnipId(bKind, mmFirst, 0, aSnip, aSnip);
              scrToSnip(aBandX, aSnip, 0);
           end else if (snipWidth(bKind, aSnip)+2) > (bHiP - bLoP) then
              scrToSnip(aBandX, aSnip, snipWidth(bKind, aSnip) -
                        ((bHiP - bLoP) div 2) )
           else if just = nearJ then
              shoNear(aBandX, aSnip, True)
           else
              scrToSnip(aBandX, aSnip, 0)
        end else if just = nearJ then
           shoNear(aBandX, aSnip, False)
        else
           scrToSnip(aBandX, aSnip, 0)
     end; end;




{******************************************************}
{$S TEscrol}

procedure shoSnipHnd {aKind: snipKind; aSnipX: snipX};
        {show (aKind) aSnip's handle, within vwRect; only shoRgn need be
         updated}
     var
        startP:         pixel;   {starting pixel of handle}
        sizeP:          pixel;   {extent of handle}
        dRect:          rect;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     if snipHndDp[aKind] > 0 then with aSnipX^ do begin
         sizeP := 2*buttonD[axisOfSKind[aKind]];
         startP := sLoP + ((sDp - sizeP) div 2);
         dRect:= snipHndRect[aKind];
         trimSRect(aKind, startP, startP+sizeP, dRect);
         PenNormal;
         frameRect(dRect);
     end; end;




{**************  8:15 am   rkm   5/19/82  ****************************************}
{$S TEscrol}

procedure shoSplit {aBandX: bandX};
        {display the split line of aBand, if its not the
        title band AND if another band follows}
     var
        splitRect:      rect;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        splitRect := tblRect;   insetRect(splitRect, -4, -4);
        with aBandX^, splitRect do begin
           mkSnipPt(bKind, bHiP, topLeft, topLeft);
           mkSnipPt(bKind, bHiP+splitWidth[bKind], botRight, botRight);
           if (bNxtBandX <> nil) and (bLoId <> mInfSnip)
                 then begin {a split line is appropriate}
              ClipRect(tblRect);
              EraseRect(splitRect);
              PenNormal;
              FrameRect(splitRect);
           end;
        end;
     end;



{******************************************************}
{$S TEscrol}

procedure ShoTbl{shoRgnH: RgnHandle};
        {display from scratch the table, clipping
         to shoRgn}
     var
        jBandX:                 bandX;
        jKind:                  snipKind;
        aView:                  view;
        saveHLState:            boolean;

     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then Writeln('tm ShoTbl   ');
        setPnlPort(tblPnl);
        BackPat(offTblPat);
        clipRect(tblRect);
        sectClipRgn(shoRgnH);
        EraseRect(tblRect);
        BackPat(white);
        shoWhTbBox;

        HLHide(nullRgnH);  { (don't flash the hilite twice) }

        aView := nullView;
        while eachView(aView) do
           shoView(aView, shoRgnH);

        HLRestore(shoRgnH);

     end;





{****************************************************************************}
{$S TEscrol}

procedure shoView {aView: view; shoRgnH: RgnHandle};
        {display aView (including grids, splits, values,
         borders, marquees); clip to shoRgn}

        var
           aKind:       snipKind;
           isTitles:    boolean;
           vwRect:      rect;
           grayRect:    rect;
           rowSnipX:    snipX;
           colSnipX:    snipX;
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with aView do begin

           setPnlPort(tblPnl);
           backPat(White);
           getVwRect(aView, vwRect);
           clipRect(vwRect);
           sectClipRgn(tblRgnH);

          {show any split lines (else they may always be clipped)}
           shoSplit(vBandX[rowKind]);
           shoSplit(vBandX[colKind]);

          {paint this view's off-table gray (keep gray in phase over scroll)}
           for aKind := rowKind to colKind do
                 with vBandX[aKind]^ do begin
              grayRect := vwRect;
              trimSRect (aKind, bLoOffP, bHiP, grayRect);
              trimSRect (aKind, bLoP, bLoOffP, vwRect);
              fillRect(grayRect, offTblPat);
           end;

          {observe new clipping for titles, cells, grids and hilite}
           clipRect(vwRect);  {gray now omitted}
           sectClipRgn(shoRgnH);
           eraseRect(vwRect);
           if (not emptyrgn(theport^.cliprgn)) then begin

              if traceTMgr then begin
                 InvertRect(vwRect);
                 writeln('tm shoView: vwRect = ');
                 {$IFC tedebug}
                 prntRect(vwRect);
                 {$ENDC}
                 InvertRect(vwRect);
              end;

              isTitles := false;

             {show titles}
              for aKind := rowKind to colKind do begin
                 if vBandX[aKind]^.bLoId = mInfSnip then begin
                   {this is a title view}
                    isTitles := true;
                    shoDes(aView, shoRgnH);
                 end;
              end;

             {shoView, cont.}

             {show unhiglighted grid lines, white ones first}
              if not isTitles then begin
                 if useGrids[colKind] then begin
                    shoGrid(aView, rowKind, False,   -1, shoRgnH);
                    shoGrid(aView, colKind, False  , -1, shoRgnH);
                 end else begin
                    shoGrid(aView, colKind, False,   -1, shoRgnH);
                    shoGrid(aView, rowKind, False  , -1, shoRgnH);
                 end;
              end;

             {show each of the cells}
              rowSnipX := vBandX[rowKind]^.bLoSnipX;
              while rowSnipX <> nil do begin
                    colSnipX := vBandX[colKind]^.bLoSnipX;
                    if rowSnipX^.sId <> pInfSnip then while colSnipX <> nil do begin
                       if colSnipX^.sId <> pInfSnip then
                          shoCell(rowSnipX, colSnipX, shoRgnH);
                       colSnipX := colSnipX^.sNxtSnipX;
                    end;
                    rowSnipX := rowSnipX^.sNxtSnipX;
             end;

             if hl.isOn then
                shoAHiLite(False, aView, shoRgnH);
           end;

        end; end {shoView};





{******************************************************}
{$S TEscrol}

procedure shoWhTbBox;
        {display the whole table box}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        clipRect(whTbBoxRect);
        PenNormal;
        eraseRect(whTbBoxRect);
        FrameRect(whTbBoxRect);
     end;




{******************************************************}
{$S TEwork1}

function snipAllInBand{
        aKind:  snipKind;       band orientation
        aP:     pixel;          band locator
        snipId: idType          snip of interest
        ):      boolean;        is it's whole width visible?};

     {Tell whether or not the width of snipId is entirely visible
      within the band}
   var
      aBandX:   bandX;
      aSnipX:   snipX;

   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        aBandX := bandXAtP(aKind, aP);
        aSnipX := snipXOfId(aBandX, snipId);
        if aSnipX = nil then
           snipAllInBand := False
        else with aBandX^, aSnipX^ do
          {it's at least partially there}
           snipAllInBand := (sLoP >= bLoP) and
                            (sLoP+sDp <= bHiP);
   end;





{******************************************************}
{$S TEwork1}

function snipRgIsect {(aKind: snipKind; rg1,rg2: range; var loSnipId,
           hiSnipId: idType): boolean};
        {return true if the included rows (or included columns --
        if aKind = colKind) of rg1 and rg2 overlap; if true, set loSnipId
        and hiSnipId to the bounds of the overlap,  INCLUDING mInf-
        or pInf-Snips.
        Called by getPerim (and others)}

     var
        loSnip1: idType;
        loSnip2: idType;
        hiSnip1: idType;
        hiSnip2: idType;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
if tracetmgr then
   begin
   writeln('tm snipRgIse');
   end;
        if (rg1.rKind = aNullRg) OR (rg2.rKind = aNullRg) then
           snipRgIsect := false
        else begin
           loSnip1 := rgLoSnip(aKind, rg1);
           hiSnip1 := rgHiSnip(aKind, rg1);
           loSnip2 := rgLoSnip(aKind, rg2);
           hiSnip2 := rgHiSnip(aKind, rg2);
           if snipLT(aKind, hiSnip1, loSnip2)
                 OR snipLT(aKind, hiSnip2, loSnip1)
              then snipRgIsect := false
              else begin
                 if snipLT(aKind, loSnip1, loSnip2)
                    then loSnipId := loSnip2
                    else loSnipId := loSnip1;
                 if snipLT(aKind, hiSnip1, hiSnip2)
                    then hiSnipId := hiSnip1
                    else hiSnipId := hiSnip2;
                    snipRgIsect := true; end; end;
     end;







{******************************************************}
{$S TEwork1}

function snipXAtP {(aKind: snipKind; p: pixel): snipX};
        {return a pointer to the snip of aKind which is at pixel p;
        if p is between snips, the earlier snip will be returned;
        if p is prior to the table, return the earliest displayed snip;
        if p is beyond the table, return the last displayed (including
        off-table gray) snip}

    var
       aBandX: bandX;
       aSnipX: snipX;
       found: boolean;
       status: integer;
       snipId: idType;
    begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
    {take advantage of fact that snips and bands are threaded
           in loP order and that bandXAtP returns the earlier band
           when given a p on a band boundary}

       aBandX := bandXAtP(aKind, p);
       with aBandX^ do begin
          found := false;
          aSnipX := bLoSnipX;
          while (aSnipX^.sNxtSnipX <> nil ) and (not found) do
             if p <= aSnipX^.sLoP + aSnipX^.sDp then
                found := true
             else
                aSnipX := aSnipX^.sNxtSnipX;
          snipXAtP := aSnipX;
       end;
    end;



{******************************************************}
{$S TEwork1}

function snipXOfId {(aBandX: bandX; snipId: idType): snipX};
        {return a pointer to the snip with snipId within aBand;
        if none, return nil}


     var
        aSnipX: snipX;
        found: boolean;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with aBandX^ do begin
           aSnipX := bLoSnipX;
           found := false;
           while (aSnipX <> nil) and (found = false) do begin
              if (aSnipX^.sId = snipId) then found := true
              else aSnipX := aSnipX^.sNxtSnipX; end;
           snipXOfId := aSnipX; {this will be nil when not found}  end;
     end;



{******************************************************}
{$S TEcold}

procedure SplitBand{
        aKind:  snipKind;       band orientation
    var atP:     pixel;         band locator and split location
    var didSplit: boolean);     did it go through?};

     {Try to split the band at atP; tell if didSplit; if did split,
      set atP to the actual new boundary of the band (it might differ
      from the input atP value due to character boundary rounding or
      other considerations); the successor band will begin at
      atP + dxSkewer}

   var
      aBandX:   bandX;

   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if traceXTMgr then
         writeln('%tm SplitBand.  aKind, atP', ord(aKind), atP);

      if freeBandX = nil then
         didSplit := False
      else begin
         aBandX := bandXAtP(aKind, atP);
         with aBandX^ do begin

            if traceXTMgr then begin
               writeln('    ','bLoId, bHiId, bLoP, bHiP');
               writeln('    ',bLoId, bHiId, bLoP, bHiP);
            end;

            if bLoId = mInfSnip then
               didSplit := False   {don't split the titles!  }
            else begin
               if (atP < bLoP+2*splitWidth[aKind]) or
                     (atP > bHiP-2*splitWidth[aKind]) then
                  didSplit := False
               else begin
                  splitP(aKind, atP);
                  didSplit := True
               end;
            end;
         end;
      end;
   end;




{******************************************************}
{$S TEcold}

procedure splitP {aKind: snipKind; p: pixel};
        {If p is not near the end of the folder and is
        not already too near a split line, then split at
        coordinate p.  Change both the data
        structures and the picture}
     var
        nearTol:     pixel;
        aBandX:      bandX;
        aSnipX:      snipX;
        snip1:       idType;
        status:      integer;
        hideP:       pixel;
        oldBHiP:     pixel;
        pBandX:      bandX;

     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then Writeln('%tm SplitP, at: ', p);
        aSnipX := snipXAtP(aKind, p);
        nearTol := 2*splitWidth[aKind];
        with aSnipX^ do begin
           snip1 := sId;
           aBandX := sBandX;
           if snip1 = pInfSnip then begin
             {split over gray -- duplicate aBandX}
              snip1 := aBandX^.bLoId;
              hideP := bHideP(aBandX);
           end else if (p = sLoP + sDp) then begin
              GetSnipId(aKind, MMNext, 0, snip1, snip1);
              hideP := 0;
           end else
              hideP := p - sLoP + 1;
        end;

       {the new band is to start with snip1/hideP}
        with aBandX^ do
           if (p+nearTol+splitWidth[aKind] < bHiP) and
                 (p - nearTol > bLoP) and
                 (snip1 <> mInfSnip) then begin
              oldBHiP := bHiP;
             {Adjust hi boundary of band with p to location p}
              adjBBound(aBandX, bLoP, p);
             {Add a band following aBand that starts where aBand left off}
                 addBand(aKind, snip1, bHiP + splitWidth[aKind],
                       oldBHiP, hideP);
           end;

       {Redisplay the part of the table that changed}

        shoTbl(tblRgnH);
     end;





{******************************************************}
{$S TEwork1}

procedure tmCurVwPt {var vwPt: point};
        {set vwPt to a point within the currently active view}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        vwPt := lastCellPt;
     end;



{******************************************************}
{$S TEwork1}

procedure tmCurVwSet {vwPt: point};
        {set cur view to indicated point}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then writeln('tmCurVwSet - vwPt = ',
                                    vwPt.h, vwPt.v);
        lastCellPt.h := cmax(vwPt.h, cellsRect.topleft.h + 4);
        lastCellPt.v := cmax(vwPt.v, cellsRect.topleft.v + 4);
     end;




{******************************************************}
{$S TEcold}

procedure tmFAct{fActivate: boolean};
        {fActivate true => activate folder is happening;
            "      false => de-activate  "      "      ;

            set selection feedback state appropriate to that
            and current hilite state}

      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      with hl do begin

         if traceXTMgr then begin
            writeln('%tmFAct of: ', fActivate);
            writeln('        ','issel,ison,isborder, marqSaved = ',
                                isSel,ison,isborder, marqSaved);
         end;

         if (not fActivate) then
            if isSel then begin
              {deactivate and save away marquee}
               TurnOffMarquee;
               marqSaved := True;
            end else
               marqSaved := False
         else if marqSaved then begin
           {re-activate and restore a saved marquee}
            TurnOnMarquee;
            marqSaved := False;
         end;
      end; end;

{******************************************************}
{$S TEinit}

procedure tmInit;
        {set up  those tm internal data structures which are table
        independent; allocate internally used regions; Also sets up
        aField for shoCell.
       Note: tmInit must be the first call made on TM, and must only
        be made once for each instantiation of the TM process.}
     var
        aKind:  snipKind;
        str : string[40];
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        str := 'Copyright 1983, Apple Computer Inc.';
        if traceXTMgr then writeln('%tm tmInit');

        {$IFC tmdebug}
        fwriteln := TRUE;
        {$ENDC }


        useGridIcon := False;

        nSnaps := 0;
        shoCTicks := 0;
        cValTicks := 0;

        marqSaved := False;
        saveHLOn  := False;


        buttonD[h] := 4;
        buttonD[v] := 2;

        arrowD[h] := 9;
        arrowD[v] := 3;

        {Set up regions}
        tblRgnH := newRgn;
        rgnNew := newRgn;
        rgnOld := newRgn;
        rgnUnion := newRgn;
        rgnISect := newRgn;
        nullRgnH := newRgn;
           setRectRgn ( nullRgnH, 0, 0, 0, 0);


        tmbBandX := nil;

      {init the convenience variables}
        setRect (nullRect, 0,0,0,0);
        setRg (nullRg, aNullRg, nullSnip, nullSnip, nullSnip, nullSnip);
        setRg (allRg, aRectRg, mInfSnip, mInfSnip, pInfSnip, pInfSnip);

        for aKind := rowKind to colKind do
              with loBand[aKind], titleSnip[aKind] do begin
           nullView.vBandX[aKind] := nil;

          {set up structural part of title bands&snips}
           bKind := aKind;
           bLoId := mInfSnip;
           bHiId := mInfSnip;
           bLoSnipX := @titleSnip[aKind];

           sBandX := @loBand[aKind];
           sId := mInfSnip;
           sNxtSnipX := nil;

        end;



        orthKind[rowKind]  := colKind;
        orthKind[colKind]  := rowKind;

        axisOfSKind[rowKind] := v;
        axisOfSKind[colKind] := h;

        sKindOfAxis[v] := rowKind;
        sKindOfAxis[h] := colKind;

        orthAxis[h] := v;
        orthAxis[v] := h;

      {set split-line widths}
        splitWidth[rowKind] := splitDv;
        splitWidth[colKind] := splitDh;

      {initialize patterns}
        stuffHex (@gridPat[h, normGr],     'AA55AA55AA55AA55');
        stuffHex (@gridPat[h, selGr ],     'FFFFFFFFFFFFFFFF');
        stuffHex (@gridPat[h, brkGr ],     'F0F0F0F0F0F0F0F0');
        stuffHex (@gridPat[h, curCelGr ],  'FCFCFCFCFCFCFCFC');
        stuffHex (@gridPat[h, whiteGr ],   '0000000000000000');
        stuffHex (@gridPat[v, normGr],     'AA55AA55AA55AA55');
        stuffHex (@gridPat[v, selGr ],     'FFFFFFFFFFFFFFFF');
        stuffHex (@gridPat[v, brkGr ],     'FFFFFFFF00000000');
        stuffHex (@gridPat[v, curCelGr ],  'FFFFFFFFFFFF0000');
        stuffHex (@gridPat[v, whiteGr ],   '0000000000000000');

        stuffHex (@maskPat[selMask],       'FFFFFFFFFFFFFFFF');
        stuffHex (@maskPat[crgMask],       'AA55AA55AA55AA55');

        stuffHex (@splitPat,     'FFFFFFFFFFFFFFFF');
        buttonPat    :=          DkGray;
        offTblPat    :=          ltGray;

        {Set up the field for drawing each cell, giving it dummy parameters
         at this point}
         { change for 4.0 }
         aFieldH := CreateField(nullRect, maxString + 1, 0, left,
                               tblPars.fieldPad, maxrun, 0, p12tile, true);
    end;


{******************************************************}
{$S TEscrol}

procedure tmLoadBands;
        {tmLoadBands, which should be called soon after tmNewPars, releases
        any existing band data structures and prepares to accept new ones
        via tmLoadNextBand calls.}

        {rls all screen data structures}
     var
        i:      integer;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then writeln('tm rlsAllBands');
       {put all snips on free list}
        for i := 1 to maxSnips-1 do
                snipHeap[i].sNxtSnipX := @snipHeap[i+1];
        snipHeap[maxSnips].sNxtSnipX := nil;
        freeSnipX := @snipHeap[1];

       {put all bands on free list}
        for i := 1 to maxBands-1 do begin
           bandHeap[i].bLoSnipX := nil;
           bandHeap[i].bNxtBandX := @bandHeap[i+1];
        end;
        bandHeap[maxBands].bNxtBandX := nil;
        bandHeap[maxBands].bLoSnipX := nil;
        freeBandX := @bandHeap[1];
        loBand[rowKind].bNxtBandX := nil;
        loBand[colKind].bNxtBandX := nil;
     end;



{******************************************************}
{$S TEscrol}

procedure tmLoadNextBand{aTmBand: tmBand};
        {Calls to tmLoadNextBand, which should follow soon after
        tmLoadBands, install bands into TM's screen layout; a null
        snip id signals that all bands have been loaded}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aTmBand do begin
        if traceXTMgr then
           writeln('tm tmLoadNextBand, loSnip = ', tmbLoId);
        if tmbLoId <> nullSnip then
           addBand(tmbKind, tmbLoId, tmbLoP, tmbHiP, tmbHideP);
     end; end;


{******************************************************}
{$S TEscrol}
procedure tmloadstate{ atmstate:tmstate};
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   marqsaved := atmstate.marqsaved;
   hl.rg := atmstate.rg;
   hl.issel := atmstate.issel;
   hl.ison := atmstate.ison;
   hl.isborder := atmstate.isborder;
   END;

{******************************************************}
{$S TEscrol}

procedure tmNewPars;
        {tmNewPars initiates the loading of a new table. It sets up
        those internal data structures which are table dependent and
        which can be gleaned from tableData. It doesn't allocate regions
        (that was done by tmInit) and it doesn't set up screen layout
        (that will be done by tmLoadBands)

        NOTE:   This routine is called by tmReDoViews; this implies that
                no change should be made without considering implications
                for tmReDoViews, as well as the more obvious case of
                the LoadBands initialization sequence.}
     var
        aKind:          snipKind;
        dRect:          rect;
        niceDh, badDh:  pixel;

     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTmgr then writeln('tm tmNewPars');

        curShoState := ShoNormally;
        {release highlight}

        hl.rg    := nullRg;
        hl.isSel := False;
        hl.isOn  := False;


      {initialize table-part rectangles, regions, and points}
        getPnlRect(tblPnl, tblRect);

        useGrids[rowKind]  := tblPars.RowGrids;
        useGrids[colKind]  := tblPars.ColGrids;

        marqsaved := false;

        if tblPars.ColHandles
           then snipHndDp[colKind] := buttonD[v]
           else snipHndDp[colKind] := 0;
        if tblPars.RowHandles
           then snipHndDp[rowKind] := buttonD[h]
           else snipHndDp[rowKind] := 0;



      {set grid width array}
        gridHndWid[rowKind] := 1;

        if tblPars.colGridHandles then
           gridHndWid[colKind] := 3
        else
           gridHndWid[colKind] := 1;


      {the rest of tmNewPars assumes that tblRect.topLeft is (0,0)}
        setRect (whTbBoxRect, 0, 0,
                snipHndDp[rowKind] + snipWidth(colKind, mInfSnip),
                snipHndDp[colKind] + snipWidth(rowKind, mInfSnip));

       {let xTblRect be like tblRect, but big enough to insure that no
        table parts are degenerate}
        xTblRect := tblRect;
        with xTblRect do begin
           right := cmax(right, 10 + whTbBoxRect.right);
           bottom := cmax(bottom, 10 + whTbBoxRect.bottom);
        end;


        whTbButton := whTbBoxRect;
        insetRect(whTbButton, 1, 0);

        setRect (snipHndRect[colKind], whTbBoxRect.right,
                0, xTblRect.right, snipHndDp[colKind]);

        setRect (desRect[colKind], snipHndRect[colKind].left,
                snipHndRect[colKind].bottom,
                xTblRect.right, whTbBoxRect.bottom);

        arrowV := (desRect[colKind].bottom) - 2*buttonD[v];

        setRect (snipHndRect[rowKind], tblRect.left,
                whTbBoxRect.bottom,
                tblRect.left+snipHndDp[rowKind], xTblRect.bottom);

        setRect (desRect[rowKind], snipHndRect[rowKind].right,
                snipHndRect[rowKind].top,
                whTbBoxRect.right, xTblRect.bottom);

        setRect (cellsRect, whTbBoxRect.right,
                whTbBoxRect.bottom,
                xTblRect.right, xTblRect.bottom);


       {set up initial current view -- lastCellPt: }
        with lastCellPt do begin
           lastCellPt := cellsRect.topLeft;
           h := h+10;    {be sure it's seen as being in a view}
           v := v+10;
        end;

       {set up screen-portion of title bands&snips}
        for aKind := rowKind to colKind do
              with loBand[aKind], titleSnip[aKind] do begin
           dRect := desRect[orthKind[aKind]];
           sLoP := dRect.topLeft.vh[axisOfSKind[aKind]];
           sDp := (dRect.botRight.vh[axisOfSKind[aKind]]-1) - sLoP;
           bLoP := snipHndRect[orthKind[aKind]].topLeft.vh[axisOfSKind[aKind]];
           bHiP := sLoP + sDp + 1;
           bLoOffP := bHiP;
        end;

        if tblPars.rowRangeOk and (not tblPars.rowHandles) then
          {we want to use tiles as snip handles}
           snipHndRect[rowKind] := desRect[rowKind];

        if tblPars.colRangeOk and (not tblPars.colHandles) then
          {we want to use tiles as snip handles}
           snipHndRect[colKind] := desRect[colKind];


        cellsEnd[rowKind] := cellsRect.bottom;
        cellsEnd[colKind] := cellsRect.right;

        SetRectRgn(tblRgnH, tblRect.left, tblRect.top,
                            tblRect.right, tblRect.bottom);


     end;



{***********************************************************************}
{$S TEwork1}

procedure tmNewSnips {aKind: snipKind; priorSnip: idType; scrollit:boolean};
        {snips of aKind after priorSnip may have been deleted, renamed
         or assigned new snip id's, due to Cut, Paste, etc;
         create new band data structures}
     var
        cView:          view;
        aHideP:         pixel;
        activeSnip:        idType;
        aBandX:         bandX;
        repSnip:        idType;
        status:         integer;
        lastOkSnipX,
           aNewSnipX:   snipX;
        updRgnH:        rgnHandle;
        updRect:        rect;
        activeRg:       range;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then
           writeln('tmNewSnips, aKind = ', ord(aKind), ' priorSnip = ',
                    priorSnip);

       {get rid of any hilite -- snip transformation is too tricky to
        maintain hilites}
        endRgBorders;

       {determine first existing snip either inserted or not deleted: }
        getSnipId(aKind, mmNext, 0, priorSnip, activeSnip);


        aBandX := @loBand[aKind];
        while eachBandX(aBandX, nil) do
              with aBandX^ do begin
           aHideP := bHideP(aBandX);
           ImmMapSnip(aKind, bLoId, repSnip, status, ProcInfo.mmMapSnip);
           case status of
              rmDel: begin
                {our first snip is gone! start with ActiveSnip}
                 chgBand(aBandX, ActiveSnip, 0);
                 shoBand(aBandX, tblRgnH);
                 end;
              rmReName: begin
                {first band is still here, but name is different}
                 chgBand(aBandX, repSnip, aHideP);
                 shoBand(aBandX, tblRgnH);
              end; rmOk: begin
                {initial snip is ok as is, see how far we can go without
                 needing to repaint}

                 lastOkSnipX := snipXOfId(aBandX, priorSnip);
                 if lastOkSnipX <> nil then
                    begin
                    aNewSnipX := lastOkSnipX^.sNxtSnipX;
                    if aNewSnipX <> nil then with aNewSnipX^ do
                       begin
                       {rebuild band and display from aNewSnipX}
                       updRgnH := newRgn;
                       getBRect(aBandX, updRect);
                       trimSRect(aKind, sLoP, bHiP, updRect);
                       with updRect do
                          setRectRgn(updRgnH, left, top,
                                right, bottom);
                       chgBand(aBandX, repSnip, aHideP);
                       shoBand(aBandX, updRgnH);
                       disposeRgn(updRgnH);
                       end;
                    end
                 else
                    begin
                    {snip is off screen
                    if scrollit then inserted at top before first snip so rebuild structures
                     from activesnip}
                    (*
                    if scrollit then
                       begin
                       chgBand(aBandX, ActiveSnip, 0);
                       shoBand(aBandX, tblRgnH);
                       end;
                    *)
                    end;
              end;
           end;
        end;

        if scrollit then
           begin
           if activeSnip = pInfSnip then
              getSnipId(aKind, mmPrior, 0, activeSnip, activeSnip);
           if activeSnip <> mInfSnip then begin
              if aKind = rowkind then
                 setRg(activeRg, aRowRg, activeSnip, mInfSnip,
                                                    activeSnip, pInfSnip)
              ELSE {colKind:}   setRg(activeRg, aColRg, mInfSnip, activeSnip,
                                                    pInfSnip, activeSnip);
              shoNewRg(activeRg, activeRg, nearJ);
           end;
        end;
     end;



{******************************************************}
{$S TEwork1}
procedure tmNextBandRg{var bandsnip : snipKind; var bandloId, bandhiId : idType};
        {Send the next band range to our client}
begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if traceTMgr then writeln('tm tmSaveRgBand');
   if tmbBandX = nil then bandLoId := nullsnip
   else with tmbBandX^ do begin
           bandsnip := bKind;
           bandLoId := bLoId;
           bandHiId := bHiId;
           tmbBandX := bNxtBandX;
           if traceXTMgr then writeln('tmNextBandRg: lo,hi: ',bLoId:1,',',bHiId:1);
           if (tmbBandX = nil) and (bKind = rowKind) then tmbBandX := loBand[colKind].bNxtBandX
        end
end;


{******************************************************}
{$S TEwork1}

procedure tmReDoViews;
        {recompute and display views from their origins}

     var
        jKind:          snipKind;
        aBandX:         bandX;
        prevHiP:        pixel;
        savRg:          range;
        savMarq:        boolean;
        savLCPt:        point;          {point where mouse was last seen}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then writeln('%tmReDoViews');

       {get rid of range borders: they will need
        to be re-built}
        savRg := hl.rg;
        savMarq := hl.isSel;
        EndRgBorders;
        savLCPt := lastCellPt; {protect cur view from tmNewPars}

        tmNewPars;
        lastCellPt := savLCPt;
        for jKind := rowKind to colKind do begin
           aBandX := @loBand[jKind];
           prevHiP := aBandX^.bHiP;
           while eachBandX(aBandX, nil) do begin
              adjBBound(aBandX, prevHiP, aBandX^.bHiP);
              prevHiP := aBandX^.bHiP + splitWidth[jKind];
           end;
        end;
        shoTbl(tblRgnH);

        SetNewHiLite(savRg, savMarq, False, True);

     end;



{******************************************************}
{$S TEwork1}

procedure tmResize;
        {the size of the table panel may have changed; rebuild and
         redisplay accordingly. Later only redisplay the part changed;
         for now rebuild data structures and display everything.}
      var
         tbLim:         array[snipKind] of pixel;
         jKind:         snipKind;
         jBandX:        bandX;
         endFound:      boolean;
         sucBandX:      bandX;
         savLCPt:       point;          {point where mouse was last seen}
      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
         if traceXTMgr then writeln('%tmResize');
         savLCPt := lastCellPt; {protect cur view from tmNewPars}

        {Recompute all rectangles and other parameters}
         tmNewPars;

         tbLim[rowKind] := cellsRect.bottom;
         tbLim[colKind] := cellsRect.right;
         lastCellPt.h := cMin(savLCPt.h, cellsRect.right);
         lastCellPt.v := cMin(savLCPt.v, cellsRect.bottom);
         lastCellPt.h := cmax(lastcellpt.h, cellsRect.topleft.h + 4);
         lastCellPt.v := cmax(lastcellpt.v, cellsRect.topleft.v + 4);

         for jKind := rowKind to colKind do begin
            endFound := false;
            jBandX := loBand[jKind].bNxtBandX;
            while jBandX <> nil do with jBandX^ do begin
               sucBandX := bNxtBandX;
               if endFound then begin
                  rlsBand(jBandX);
               end else begin
                  if (bNxtBandX = nil) or
                        (tbLim[jKind] < bHiP + 3*splitWidth[jKind])
                        then begin
                     bHiP := tbLim[jKind];
                     endFound := true;
                     chgBand(jBandX, bLoId, bHideP(jBandX));
                  end;
               end;
               jBandX := sucBandX;
            end;
         end;

      end;



{******************************************************}
{$S TEwork1}

procedure tmSaveBands;
        {Prepare to send TM's band data structures to our client
        via calls to tmSaveNextBand}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then writeln('tm tmSaveBands');
       {we always do rows before cols}
        tmbBandX := loBand[rowKind].bNxtBandX;
     end;


{************** 9:43 am  6/2/82   rkm ******************************}
{$S TEwork1}

procedure tmSaveNextBand{var aTmBand: tmBand};
        {Send the next band data structure to our client}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aTmBand do begin
        if traceTMgr then
           writeln('tm tmSaveNextBand');
        if tmbBandX = nil then
           tmbLoId := nullSnip
        else with tmbBandX^ do begin
           tmbKind := bKind;
           tmbLoP := bLoP;
           tmbHiP := bHiP;
           tmbHideP := bHideP(tmbBandX);
           tmbLoId := bLoId;
           if traceXTMgr then
              writeln('     lo snip = ', tmbLoId);
           tmbBandX := tmbBandX^.bNxtBandX;
           if (tmbBandX = nil) and (tmbKind = rowKind) then
              tmbBandX := loBand[colKind].bNxtBandX;
        end;
     end; end;



{******************************************************}
{$S TEscrol}
procedure tmsavestate{ var atmstate:tmstate};
   BEGIN
{$IFC fTraceTE}    LogCall;     {$ENDC}
   atmstate.marqsaved := marqsaved;
   atmstate.rg := hl.rg;
   atmstate.issel := hl.issel;
   atmstate.ison := hl.ison;
   atmstate.isborder := hl.isborder;
   END;


{******************************************************}
{$S TEscrol}

procedure tmSetRgFB {cRg: range; useMarquee: boolean};
        {cRg is the current range for the table just loaded -- set
        up hl appropriately; useMarquee tells whether the range
        should have a marquee around it; put it on the screen
                OLD:'do nothing to the screen'}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then writeln('TmSetRgFb');
        setNewHiLite(cRg, (useMarquee and (not marqSaved) ), False, False);
     end;



{******************************************************}
{$S TEcold}

procedure tmShoBreaks;
        {there may be a change in which snips to break on;
         be sure break-snip feedback, if any is called for, is current}
      var
         aView: view;

      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if tracetmgr then writeln('tm tmShoBreaks');
        setPnlPort(tblPnl);

        HLHide(tblRgnH);

        aView := nullView;
        while eachView(aView) do begin
           shoGrid(aView, rowKind, False, -1, tblRgnH);
           shoGrid(aView, colKind, False, -1, tblRgnH);
        end;

        HLRestore(tblRgnH);

      end;



{******************************************************}
{$S TEscrol}

procedure tmShoNewTbl;
        {display the just-loaded table}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then writeln('tm tmShoNewTbl');
        shoTbl(tblRgnH);
     end;





{******************************************************}
{$S TEwork1}

procedure trimSRect {aKind: snipKind; aLoP, aHiP: pixel; var aRect: rect};
        {trim the aKind edges of aRect to aLoP and aHiP}

     var
        u: axis;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        u := axisOfSKind[aKind];
        aRect.topLeft.vh[u] := aLoP;
        aRect.botRight.vh[u] := aHiP;
     end;


{******************************************************}
{$S TEwork1}

procedure turnOffMarquee;
          {Remove any current marquees from the screen.  Until
          TurnOnMarquee is called, do not display any marquees}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with hl do begin
        if traceXTMgr then Writeln('tm turnOffMa');
        if isSel then begin
           if isOn then begin
             {turn off selection feedback} reShoHiLites(False, tblRgnH);
              isSel := False;
              isBorder := useBorder(rg, False);
             {turn on cur-rg feedback} reShoHiLites(False, tblRgnH);
           end;
           isSel := False;
        end;
     end; end;


{******************************************************}
{$S TEcold}

procedure turnOnMarquee;
          {Until TurnOffMarquee is called, display marquees
          wherever there are visible range borders}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with hl do begin
        if traceXTMgr then Writeln('tm turnOnMar');
        if not isSel then begin
           if isOn then begin
              reShoHiLites(False, tblRgnH); {turn off current mask}
              isSel := True;
              isBorder := useBorder(rg, True );
              reShoHiLites(False, tblRgnH); {turn on new mask}
           end;
           isSel := True;
        end;
     end; end;




{******************************************************}
{$S TEwork1}

function underEdit {(aRow, aCol: idType): boolean};
        {is the cell or title (aRow, aCol) currently undergoing editing?}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
{*tr* then Writeln('tm underEdit*tr*}
        if not tblPars.EditTable then underEdit := false
        else begin
           case typeOfSel of
              aCellTxtSl,
              aRowHedSl,
              aColHedSl,
              aTblHedSl,
              a1CellSl,
              aRectRgSl:
                 underEdit := (aRow = editRow) and (aCol = editCol);
              otherwise
                 underEdit := false;
           end;
        end;
     end;


{******************************************************}
{$S TEwork1}

function useBorder {(aRange: range; useMarquee: boolean): boolean};
        {should aRange use border for a hilite instead of XOR?}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aRange do begin
        useBorder :=  (not useMarquee);
     end; end;




{******************************************************************************}
{$S TEwork1}

procedure visRgOfView{
        aPt:    point;          view locator
    var aRg:    range);         the range visible};

   {Set aRg to the (rectangular) range consisting of all those cells
    which are at least partially visible within that view which
    contains aPt}

 var
    aView:              view;
    rBandX, cBandX:     bandX;

 begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
 with aRg do begin

    rBandX := bandXAtP(rowKind, aPt.v);
    cBandX := bandXAtP(colKind, aPt.h);
    mkView(rBandX, cBandX, aView);
    rgOfView(aView, aRg);
    if hirow = pInfSnip then
       getSnipId(rowKind, mmPrior, 0, pInfSnip, hirow);
    if hicol = pInfSnip then
       getSnipId(colKind, mmPrior, 0, pInfSnip, hicol);

 end; end;


{******************************************************}



{ end tm4}

ÿ