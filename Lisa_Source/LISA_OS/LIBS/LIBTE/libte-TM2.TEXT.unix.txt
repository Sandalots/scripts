                {libte/tm2.text}


              {this file included from libte/tm.text}

{******************************************************}
{$S TEscrol}



procedure dontOverScroll {aBandX: bandX; var newLoId: idType;
                                var newHideP, adjBHiP: pixel};
        {back up (newLoId, newHideP), if necessary,
         to preserve 3/4 gray limit}
     var
        whiteShown:     pixel;
        aSnip:          idType;
        wNeeded:        pixel;
        delta:          pixel;

        { ---------------------------------------- }
{$S TEscrol}
                function whiteNeeded: pixel;
                        {how many more pixels of white (non-gray) do we need? -- return it
                         and put it in wNeeded }
                   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
                   with aBandX^ do begin
                        wNeeded := ( (adjBHiP-BLoP) - 4*whiteShown ) div 4;
                        whiteNeeded := wNeeded;
                   end; end;
        { ---------------------------------------- }

{$S TEscrol}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aBandX^ do if newLoId <> mInfSnip then begin
        aSnip := newLoId;
        whiteShown := - newHideP;

       {find out out how much white is being shown if newLoId and newHideP are observed}
        while (whiteNeeded > 1) and (aSnip <> pInfSnip) do begin
           whiteShown := whiteShown + 1 + snipWidth(bKind, aSnip);
           getSnipId(bKind, mmNext, 0, aSnip, aSnip);
        end;

       {if that's not enough, get what we can by backing up the initial snip}
        if whiteNeeded > 1 then begin
           delta := cMin(wNeeded, newHideP);
           whiteShown := whiteShown + delta;
           newHideP := newHideP - delta;
        end;

       {if that's not enough, scroll in new leading snips until we have enough}
        while whiteNeeded > 1 do begin
           getSnipId(bKind, mmPrior, 0, newLoId, aSnip);
           if aSnip = mInfSnip then
              exit(dontOverScroll);
           newLoId := aSnip;
           delta := 1 + snipWidth(bKind, newLoId);
           newHideP := cMax( 0, delta - wNeeded );
           whiteShown := whiteShown + delta - newHideP;
        end;
     end; end {dontOverScroll};



{******************************************************}
{$S TEwork1}


procedure DragGrid {loCol: idType; fromH, toH: pixel; var scrnRect: rect};
        {Remove the temporary grid line at fromH, put one at toH
        and flicker it. If fromH <= 0, then there's none to remove;
        if toH <= 0, then there's
        none to put.  If loCol=mInfSnip, then do nothing.  If loCol=nullSnip
        or pInfSnip, then fatal error.
           Return in scrnRect the new nbh for further dragging of the grid line
        (analogous to scrnRect in FindTblPt for a column grid selection).
        scrnRect is undefined if toH <= 0}
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if traceXTMgr then writeln('tm DragGrid');
           {$IFC tmdebug}
           if (loCol = nullSnip) or (loCol = pInfSnip) then
              begin
              if fwriteln then writeln('** tm/dragGrid -- bad loCol');
              end
           else
           {$ENDC }
                if (loCol <> mInfSnip) then begin
              setPnlPort(tblPnl);
              clipRect(cellsRect);
              sectClipRgn(tblRgnH);
              {Set pen parameters to complement bits in line}
              PenPat(gray);
              PenSize(1,1);
              PenMode(14);
              if (fromH > 0) then begin
                 MoveTo(fromH, cellsRect.topLeft.v);
                 LineTo(fromH, cellsRect.botRight.v); end;
              if (toH > 0) then begin
                 MoveTo(toH, cellsRect.topLeft.v);
                 LineTo(toH, cellsRect.botRight.v);
                 SetRect(scrnRect, toH, desRect[colKind].topLeft.v,
                         toH, desRect[colKind].botRight.v);
                 Flicker(toH); end;
              end;
        end;



{******************************************************}
{$S TEwork1}


procedure DumpSel;
        {Break the connection between tm and tmsprocs for the current
        selection. I.E., the answer to UnderEdit should be NO.}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then writeln('tm DumpSel');
        editRow := nullSnip;
        editCol := nullSnip;
     end;


{******************************************************}
{$S TEwork1}

function eachBandX {(var jBandX: bandX; firstBandX: bandX): boolean};
        {eachBandX is an iterator function, and is to be used thusly:

                xBandX := nil;
                while eachBandX(xBandX, startBandX) do begin
                   <some block of statements>
                end;

         eachBandX will see that xBandX varies from startBandX to each
         successive value (linking on .bNxtBandX), each time returning
         with true as a value; when a nil is found, xBandX will be left
         at the last non-nil value and a false will be returned. In the
         case startBandX itself is nil, then a value of false will be
         returned the first time and xBandX will be left nil. xBandX
         must originally be set to nil by the caller so that eachBandX
         knows it's starting a new iteration}

      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
         eachBandX := true; {start out optimistically}
         if jBandX = nil then {initiate iteration}
            if firstBandX = nil
               then eachBandX := false
               else jBandX := firstBandX
         else if jBandX^.bNxtBandX = nil
            then eachBandX := false
            else jBandX := jBandX^.bNxtBandX;
      end;







{******************************************************}
{$S TEwork1}

function eachView {(var jView: View): boolean};
         {eachView iterates jView thru all Views similar
         to how eachBandX iterates thru a linked list of Bands --
         jView should be init'd by client to nullView;
         the iteration includes title views}

      var
         jKind: snipKind;
      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
         eachView := true; {start optimistic}
         with jView do
            if vBandX[rowKind] = nil then begin
                 {start with upper-left title view}
                  vBandX[rowKind] := @loBand[rowKind];
                  vBandX[colKind] := loBand[colKind].bNxtBandX;
            end else if not eachBandX(vBandX[colKind], nil) then
              {a row-band is done, step to next}
               if eachBandX(vBandX[rowKind], nil) then
                 {start at col titles of the new row-band}
                  vBandX[colKind] := @loBand[colKind]
               else {all row-bands (hence all views) are done}
                  eachView := false;

      end;





{******************************************************}
{$S TEwork1}

procedure EndGridArrows {loCol: idType};
        {In every band in which the right grid of loCol is visible, remove a grid
        arrow over the grid handle for this grid.  If loCol=mInfSnip, do nothing.
        If loCol= pInfSnip or nullSnip, then fatal error}
        var
           aTitleView:  view;
           hiCol:    idType;
           status:   integer;
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
           if traceXTMgr then Writeln('tm EndGridArrows');
           {$IFC tmdebug }
           if (loCol = nullSnip) or (loCol = pInfSnip) then
              begin
              if fwriteln then
               writeln('** tm/endGridArrows: bad loCol');
              end
           else
           {$ENDC }
                with aTitleView do begin
              GetSnipId(colKind, MMNext, 0, loCol, hiCol);
              vBandX[rowKind] := @loBand[rowKind];
              vBandX[colKind] := @loBand[colKind];
              while eachBandX(vBandX[colKind], nil) do begin
                 if (gridPixl(loCol, hiCol, vBandX[colKind]) <> -1)
                    then shoView(aTitleView, tblRgnH); end; end;
        end;



{******************************************************}
{$S TEwork1}

procedure EndRgBorders;
        { get rid of any current hilight display and release their
          data structures
   Note: this routine should be called BEFORE (not AFTER) beginning
        the establishment of new selections or ranges}
     var
        rBandX, cBandX,
        abandX, jBandX:         bandX;
        tView:                  view;
        aKind:                  snipKind;
        vwRect:                 rect;
        rSnipX, cSnipX,
        aSnipX:                 snipX;
        loOffP:                 pixel;


     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then Writeln('tm EndRgBord');
        setPnlPort(tblPnl);
        PenNormal;
        if hl.isOn then begin
           reShoHiLites(False, tblRgnH);

          {show all orthog grids, if a grid was selected}
           case hl.rg.rKind of
              aRowGrid:    jBandX := @loBand[rowKind];
              aColGrid:    jBandX := @loBand[colKind];
              otherwise    jBandX := nil;
           end;
           if jBandX <> nil then begin {it was a grid}
              while eachBandX(jBandX, nil) do shoBandGrids(jBandX);
           end else begin {It wasn't a grid}
              if hl.isborder then begin
                { show the edges of the border in each band.}
                 rBandX := @loBand[rowKind];
                 while eachBandX(rBandX, nil) do if rBandX^.curHL.hasHL then begin
                    cBandX := @loBand[colKind];
                    while eachBandX(cBandX, nil) do if cBandX^.curHL.hasHL then begin
                       mkView(rBandX, cBandX, tView);
                       getVwRect(tView, vwRect);
                       clipRect(vwRect);
                       SectClipRgn(tblRgnH);
                       for aKind := rowKind to colKind do begin
                          aBandX := tView.vBandX[aKind];
                          loOffP := tView.vBandX[orthKind[aKind]]^.bLoOffp;
                          aSnipX := snipXAtP(aKind, aBandX^.curHL.loHLP);
                          if asnipX <> nil then
                             begin
                               shoAGrid(aKind, aBandX^.curHL.loHLP-1, aSnipX, vwRect, loOffP);
                             end;

                          aSnipX := snipXAtP(aKind, aBandX^.curHL.hiHLP);
                          if asnipX <> nil then
                             begin
                             aSnipX := aSnipX^.sNxtSnipX;
                             if asnipX <> nil then
                                shoAGrid(aKind, aBandX^.curHL.hiHLP, aSnipX, vwRect, loOffP);
                             end;
                       end;
                    end;
                 end;
              end;
           end;
        end;
        {rlsHL;}
        hl.rg    := nullRg;
        hl.isSel := False;
        hl.isOn  := False;

     end;

{******************************************************}
{$S TEwork1}

procedure EnterCellVal {var status: integer};
        {If the current range is a single cell, enter its new (edited)
        value into the matrix.  Otherwise, do nothing.  Set status to 0
        if all goes well, (implying that the current range is permitted
        to change).  If there was an error in entering, status will be
        set non-zero by matMgr/CellValue}

        var
           aRowId, aColId:  idType;
           val:           ptrdata;
           length:        integer;
           i :            integer;
           aRg:           range;
           numruns : integer;

        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
              if traceXTMgr then Writeln('tm enterCell');
           getseltxt(aRowId, aColId, val, length);
           numruns := selfieldH^^.curfmts;
           cellrun(mmwrite,arowid,acolid,selFieldH^^.fmtInfo^, numruns, status);
           CellValue(MMWrite, aRowId, aColId, val, TRUE, length, status);
           IF status = OK THEN BEGIN
              DumpSel;
              setRg(aRg, a1CellRg, aRowId, aColId, aRowId, aColId);
              reDrawRg(aRg);
           end;

        end;



{******************************************************}
{$S TEwork1}

procedure FindTblPt {hv: point; var PrtOfTbl: tblPart;
           var rg: range;
           var virtRect, screenRect: rect};
       {look up the point hv within the current table display and
        tell us about where it is. There are two kinds of information
        to return. The first kind is about table-parts and
        virtual rectangles:

           Set PrtOfTbl according to where hv is; if that turns
           out to be the (non-gray) cellArea [gray shows up as
           OutOfTbl], then set virtRect to the virtual rectangle
           of the indicated cell.

        The other kind of information is about the range:

           For row/col handles, row/col grids, row/col titles,
           wh-table-box, table-title and non-gray cells, set rg
           to the defined range value, and screenRect to
           the exact rectangle on the screen devoted to
           the indicated part. Everywhere else, set rg
           to a1CellRg with the row and column id's set as follows:

              If h/v lies in the extended domain of a col/row, then that
              col/row id is used; if h/v is prior to or after the non-gray
              cells, then mInfSnip or pInfSnip is used.

           Thus the areas outside the non-gray cells are divided into virtual
           extensions of the table, for purposes of mouse-dragging during
           cell selection. Set screenRect appropriately according to the
           extended bounds of the grid lines and the limits of tblRect}

    var
       cSnipX, rowSnipX, colSnipX:      snipX;
       sigP:                            pixel;
       status:                          integer;
       drect: array[snipkind] of rect;


       procedure getSSRect (aKind: snipKind; var snipId: idType);
                {Set snipId and cSnipX to that snip of aKind which
                includes hv. Clip screenRect as follows: ignore the
                two edges of screenRect which limit the "long"
                direction of the snip; clip the other two edges
                to what's actually on the screen, omitting the
                boundary grid pixels; set the same edges of
                virtRect, except without clipping.
                *> If hv is outside the non-gray cell display,
                (in the aKind direction), set
                snipId to mInfSnip or pInfSnip, as appropriate}
            begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
                if aKind = rowKind
                   then sigP := hv.v
                   else sigP := hv.h;

                cSnipX := snipXAtP(aKind, sigP);

               {check for out of non-gray cell area}
                with cSnipX^, cSnipX^.sBandX^ do begin
                   if sigP < sBandX^.bLoP then begin
                      snipId := mInfSnip;
                      prtOfTbl := outOfTbl
                   end else if sigP > bLoOffP then begin
                      snipId := pInfSnip;
                      prtOfTbl := outOfTbl;
                   end else
                      snipId := sId;

                  {this code is similar to getCRect/tm}
                   trimSRect(bKind, cMax(sLoP, bLoP),
                            cMin(sLoP+sDp, bHiP), screenRect);
                   trimSRect(bKind, sLoP, sLoP+sDp, virtRect);
                end;
            end {getSSRect};

      begin with rg, screenRect do begin
               if traceTMgr then Writeln('tm FindTblPt');

       {first assume we're in cell area to set up the needed
       range information}
        PrtOfTbl := cellArea;
        rKind := a1CellRg;
        getSSRect(rowKind, loRow); rowSnipX := cSnipX;
        getSSRect (colKind, loCol); colSnipX := cSnipX;
        hiRow := loRow;
        hiCol := loCol;
        drect[rowkind] := desrect[rowkind];
        drect[colkind] := desrect[colkind];

        if tblpars.colgridhandles then drect[colkind].left := drect[colkind].left - gridhndwid[colkind];
        if tblpars.rowgridhandles then drect[rowkind].top  := drect[rowkind].top  - gridhndwid[rowkind];

        if tracetmgr then
           begin
           writeln('hv',hv.h,hv.v);
           writeln('desrect[colkind]');
           {$IFC tedebug}
           prntrect(desrect[colkind]);
           {$ENDC}
           end;

       {now let's see where we really are}
        if prtOfTbl = outOfTbl then begin end

        else if PtInRect(hv, cellsRect) then begin
           if tblPars.shoFormulas then {don't allow editing}
              prtOfTbl := outOfTbl;

        end else if PtInRect(hv, dRect[rowKind]) and
                    inHandle(rowKind, hv.v, loRow, hiRow) then begin
           {we are in a row grid-handle}
             PrtOfTbl := rowGrid;
             topLeft.h := desRect[rowKind].topLeft.h;
             botRight.h := desRect[rowKind].botRight.h;
             virtRect := screenRect;
             rKind := aRowGrid;
             hiCol := pInfSnip;
             topLeft.v := hv.v; botRight.v := hv.v

        end else if PtInRect(hv, dRect[colKind]) and
                    inHandle(colKind, hv.h, loCol, hiCol) then begin
           {we are in a Col grid-handle}
             PrtOfTbl := ColGrid;
             topLeft.v := desRect[colKind].topLeft.v;
             botRight.v := desRect[colKind].botRight.v;
             virtRect := screenRect;
             rKind := aColGrid;
             hiRow := pInfSnip;
             topLeft.h := hv.h; botRight.h := hv.h

        end else if PtInRect(hv, desRect[rowKind]) then begin

           {we are in a row title}

             PrtOfTbl := rowHed;
             topLeft.h := desRect[rowKind].topLeft.h;
             botRight.h := desRect[rowKind].botRight.h;

             rKind := aRowHedRg;
            { ** !! CF - getCRect ** }
             InsetRect(virtRect, 0, gridHndWid[rowKind] div 2);
             topLeft.v := cMax(virtRect.topLeft.v,
                   rowSnipX^.sBandX^.bLoP);
             botRight.v := cMin(virtRect.botRight.v,
                   rowSnipX^.sBandX^.bHiP);

        end else if PtInRect(hv, snipHndRect[rowKind]) then begin

           {we are in a row handle}

             PrtOfTbl := rowHandl;
             topLeft.h := snipHndRect[rowKind].topLeft.h;
             botRight.h := snipHndRect[rowKind].botRight.h;
             rKind := aRowRg;
             hiCol := pInfSnip;

         end else if PtInRect(hv, desRect[colKind]) then begin

           {we are in a col title}
             PrtOfTbl := colHed;
             rKind := aColHedRg;
             topLeft.v := desRect[colKind].topLeft.v;
             botRight.v := desRect[colKind].botRight.v;

            { ** !! CF - getCRect ** }
             virtRect.left := virtRect.left + 1 + gridHndWid[colKind] div 2;
             virtRect.right := virtRect.right - gridHndWid[colKind] div 2;
             topLeft.h := cMax(virtRect.topLeft.h,
                   colSnipX^.sBandX^.bLoP);
             botRight.h := cMin(virtRect.botRight.h,
                   colSnipX^.sBandX^.bHiP);

        end else if PtInRect(hv, snipHndRect[colKind]) then begin

           {we are in a col handle}

             PrtOfTbl := colHandl;
             topLeft.v := snipHndRect[colKind].topLeft.v;
             botRight.v := snipHndRect[colKind].botRight.v;
             rKind := aColRg;
             hiRow := pInfSnip;

         end else if PtInRect(hv, whTbBoxRect) then begin

           {we are in whole-table box}
             PrtOfTbl := whTbBox;
             setRg(rg, aWTBoxRg, minfSnip, minfSnip, pinfSnip, pinfSnip);
             screenRect := WhTbBoxRect;

         end else

           {we are out of the table}
             PrtOfTbl := outOfTbl;

   end; end;


{******************************************************}
{$S TEwork1}
procedure Flicker {flickH: pixel};
        {"Flicker" the temporary grid line at flickH by turning the line off,
        then on again (assuming it is on to begin with; if it is off, then this
        routine turns it on, then off again).}
        var
           i:  integer;
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
           if traceSMgr then Writeln('tm Flicker');
           setPnlPort(tblPnl);
           PenSize(1,1);
           PenPat(gray);
           PenMode(14);
           clipRect(cellsRect);
           sectClipRgn(tblRgnH);
           for i:= 1 to 2 do begin
              MoveTo (flickH, cellsRect.topLeft.v);
              LineTo (flickH, cellsRect.botRight.v); end;
        end;


{******************************************************}
{$S TEwork1}
procedure getBRect {aBandX: bandX; var bandRect: rect};
     {set bandRect to the rectangle of this band.  The rectangle
     includes the cells and split-lines within the band
     as well as the designator area and the column (or row) handles;
     it does not include any bounding split line(s)}

    begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
       with aBandX^ do begin
          if bKind = rowkind then
             SetRect(bandRect, snipHndRect[rowKind].topLeft.h,
                              bLoP, xTblRect.botRight.h, bHiP)
          else
             SetRect(bandRect, bLoP, snipHndRect[colKind].topLeft.v,
                              bHiP, xTblRect.botRight.v);
         end;
    end;



{******************************************************}
{$S TEwork1}
procedure GetCR {var rg: range};
        {set rg to the current range}
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if traceXTMgr then Writeln('tm GetCR');
      rg := CurrRg;
   end;



{******************************************************}
{$S TEwork1}
procedure getCRect {rowSnipX, colSnipX: snipX;
                var vCellRect, cCellRect: rect};
        {set vCellRect/cCellRect to the virtual/clipped rectangle
        of the cell (rowSnip, colSnip); omit grid and split lines}
        {## consolidate trimming code with other trimmers}
     var
        aBandX: bandX;
     begin  { ** !! CF: FindTblPt, setHLRect ** }
{$IFC fTraceTE}    LogCall;     {$ENDC}
           SetRect(vCellRect, colSnipX^.sLoP, rowSnipX^.sLoP,
                   colSnipX^.sLoP + colSnipX^.sDp ,
                   rowSnipX^.sLoP + rowSnipX^.sDp );
           cCellRect := vCellRect;
           with cCellRect do begin
              with colSnipX^.sBandX^ do begin
                {make room for grid handles if we're doing col title}
                 if rowSnipX^.sId = mInfSnip then begin
                    vCellRect.left := vCellRect.left + 1 +
                                gridHndWid[colKind] div 2;
                    vCellRect.right := vCellRect.right -
                                gridHndWid[colKind] div 2;
                 end;
                 left := cMax(vCellRect.left, bLoP);
                 right  := cMin(vCellRect.right, bHiP);
              end;
              with rowSnipX^.sBandX^ do begin
                {make room for grid handles if we're doing row title}
                 if colSnipX^.sId = mInfSnip then
                    InsetRect(vCellRect, 0, gridHndWid[rowKind] div 2);
                 topLeft.v := cMax(vCellRect.topLeft.v, bLoP);
                 botRight.v := cMin(vCellRect.botRight.v, bHiP);
              end;
           end;
     end;



{******************************************************}
{$S TEwork1}
procedure getCurView {var cView: view};
        {set cView to that view which contains lastCellPt; if none
         does, set it to the upper-left-hand view}
     var
        vRect:  rect;
        found:  boolean;
        jView:  view;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        jView := nullView;
        found := false;
        while eachView(jView) and (not found) do begin
           getVwRect(jView, vRect);
           if ptInRect(lastCellPt, vRect) then begin
              cView := jView;
              found := true;
           end;
        end;

        if not found then
           mkView(loBand[rowKind].bNxtBandX,
                 loBand[colKind].bNxtBandX, cView);
     end;




{******************************************************}
{$S TEwork1}
procedure getEditCell {var theRow: idType; var theCol: idType};
        {Return the row and column of the cell that is under edit,
         ie, the one that will be entered when the enter happens.
         theRow and theCol may be nullSnip's.}
      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
         theRow := editRow;
         theCol := editCol;
      end;

{******************************************************}

{$S TEwork1}
Procedure gethedrect{row,col:idtype; var r:rect};
   var

      aView:            view;
      rBandX, cBandX:   bandX;
      rSnipX, cSnipX:   snipX;
      cr:               rect;
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if traceTMgr then writeln('tm gethedrect ');

      cBandX := @loBand[colKind];
      while (cBandX <> nil) do
         begin
         if not snipLT(colKind, cBandX^.bHiId, col) then
            if not snipLT(colKind, Col, cBandX^.bLoId) then
               begin
               rBandX := @loBand[rowKind];
               while (rBandX <> nil) do
                  begin
                  if not snipLT(rowKind, rBandX^.bHiId, row) then
                    if not snipLT(rowKind, row, rBandX^.bLoId) then
                     begin
                     cSnipX := snipXOfId(cBandX, Col);
                     rSnipX := snipXOfId(rBandX, Row);
                     getCrect(rsnipx,csnipx,r,cr);
                    end;
                 rBandX := rBandX^.bNxtBandX;
                 end;
              end;
           cBandX := cBandX^.bNxtBandX;
        end;
   end; {gethedrect}

{******************************************************}

{$S TEwork1}
procedure getSelCell{var selbitsX: bitptr; var sRect: Rect};
        {return the bitmap and rectangle of the current text selection}

   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      sRect := selFieldH^^.coords;
      GetPnlBits (cellPnl, selBitsX);
   end;




{******************************************************}
{$S TEwork1}
procedure getSelTxt{var rowid: idtype; var colId:idtype; var val:ptrdata;
            var length: integer};
        {if the current range is a 1-cell range, then set status to OK and
        return the values and row col id for current selection; otherwise
        set status to -1}
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        {$ifc tmdebug }
        if (editRow = nullSnip) or (editCol = nullSnip) then
           fatalError('tm', ' getSelTxt', ' Nothing to enter');
        {$endc }
        rowid := editRow;
        colid := editCol;
        length := selFieldH^^.curlen;
        val := selFieldH^^.curvalue^;

   end;




{******************************************************}
{$S TEwork1}
procedure getSnipRg {aKind: snipKind; loSnipId: idType; hiSnipId: idType;
           var rg: range};
        {makes the row range or column range implied by the two snipId's
        into a true range}

   var
      status:        integer;
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if loSnipId = nullSnip then
         rg := nullRg
      else
         with rg do
            begin
            if aKind = rowkind then
               begin
                  rKind := aRowRg;
                  loRow := loSnipId;
                  hiRow := hiSnipId;
                  loCol := mInfSnip;
                  hiCol := pInfSnip;
               end
            else
               begin
                  rKind := aColRg;
                  loRow := mInfSnip;
                  hiRow := pInfSnip;
                  loCol := loSnipId;
                  hiCol := hiSnipId;
               end;
            end;
   end;


{******************************************************}
{$S TEwork1}
procedure getVwRect {aView: view; var vwRect: rect};
        {set vwRect to the rectangle of this view -- does not include
        designator area or split lines}

      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
         SetRect(vwRect, aView.vBandX[colKind]^.bLoP, aView.vBandX[rowKind]^.bLoP,
                         aView.vBandX[colKind]^.bHiP, aView.vBandX[rowKind]^.bHiP);
     end;


{******************************************************}
{$S TEscrol}
function grayOfBand{
        aKind:  snipKind;       band orientation
        aP:     pixel           band locator
        ):      fract;          permil of gray in band};

     {Return the permil of gray currently showing in the
      specified band}

   var
      aBandX:   bandX;
      longHiP:  longInt;        {avoid overflow when mult by 1000}
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      aBandX := bandXAtP(aKind, aP);
      with aBandX^ do begin
         longHiP := bHiP;
         grayOfBand := (1000*(longHiP-bLoOffP)) div (longHiP-bLoP);
      end;
   end;





{******************************************************}
{$S TEscrol}
function gridPixl {(loSnipId, hiSnipId: idType; aBandX: bandX): pixel};
        {return the pixel of the grid line within aBand which lies
        between lo and hi snips;
        return -1 if the grid line doesn't appear within the band}

     var
        p: pixel;
        aSnipX: snipX;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        aSnipX := aBandX^.bLoSnipX;
        p := -1;
        with aBandX^ do begin
           while (aSnipX <> nil) and (p = -1) do
              with aSnipX^ do begin
                 if (sId = loSnipId)
                    then p := sLoP + sDp
                    else if (sId = hiSnipId)
                       then p := sLoP - 1
                       else aSnipX := sNxtSnipX;
              end;
          {be sure the grid is really visible}
           if (p < bLoP) or (p >= bHiP) then p := -1;
        end;

        gridPixl := p;
     end;




{******************************************************}
{$S TEcold}

procedure growBand{
        aKind:  snipKind;       band orientation
        aP:     pixel;          band locator
   var  newP:   pixel;          new upper bound
   var  result: BGrowResult);   how it came out};

     {Try to resize the indicated band so that it's new upper
      boundary (beginning of skewer) is newP; indicate the outcome;
      if that's BGrew, set newP to the new bound (the successor
      band will then begin at newP+dxSkewer, for x = h or v);
      If newP is -1 on input, specifically delete the band (provided
      there's at least one other band around)}

     var
        lftBandX, rtBandX: bandX;
        lftLoP, lftHiP:    pixel;
        rtLoP, rtHiP:      pixel;
        savRg:           range;
        savMarq:         boolean;

     begin

{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then Writeln('%tm growBand ; aP, newP = ', aP, newP);

       {get rid of range borders: simplify
        code and performance}
        savRg := hl.rg;
        savMarq := hl.isSel;
        EndRgBorders;

        lftBandX := bandXAtP(aKind, aP);
        with lftBandX^ do begin
           lftLoP := bLoP;
           lftHiP := bHiP;
           rtBandX := bNxtBandX;
           {$ifc tmdebug}
           if rtBandX = nil then
              fatalError('tm','growBand','no band to right');
           {$endc}
           rtLoP := rtBandX^.bLoP;
           rtHiP := rtBandX^.bHiP;
           if newP < lftLoP + 2*splitWidth[aKind] then begin
             {assume intention is to remove lftBand}
              result := BWent;
              rlsBand(lftBandX);
              adjBBound(rtBandX, lftLoP, rtHiP);
           end else if newP > rtHiP - 2*splitWidth[aKind] then begin
             {assume intention is to remove rtBand}
              result := nxtBWent;
              rlsBand(rtBandX);
              adjBBound(lftBandX, lftLoP, rtHiP);
           end else if newP = lftHiP then begin
             {no-op}
              result := BSame;
           end else begin
             {an actual skewer slide is wanted}
              result := BGrew;;
              adjBBound(lftBandX, lftLoP, newP);
              adjBBound(rtBandX, newP+splitWidth[aKind], rtHiP);
           end;

           if result <> BSame then begin
             {update screen}
              shoTbl(tblRgnH);
           end;
        end;

        SetNewHiLite(savRg, savMarq, False, True);

     end;






{******************************************************}
{$S TEwork1}
procedure HLHide {shoRgn: rgnHandle};
        {turn off any highlight within shoRgn; set flag to
         inhibit showing highlight}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        saveHLOn := hl.isOn;
        hl.isOn := False;
        if saveHLOn then
           reShoHiLites(False, shoRgn);
     end;


{******************************************************}
{$S TEwork1}
procedure HLRestore {shoRgn: rgnHandle};
        {turn back on any highlight which goes in shoRgn; set flag to
         allow showing highlight}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if saveHLOn then begin
           hl.IsOn := True;
           reShoHiLites(False, shoRgn);
        end;
     end;


{******************************************************}


{*************************************************************************}
{$S TEwork1}
procedure hiLiteRect{aRect, vwRect: rect; ShoRgnH: RgnHandle};
        {properly highlight aRect (within vwRect & ShoRgn) }
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with hl do begin
        clipRect(vwRect);
        sectClipRgn(shoRgnH);
        PenNormal;
        PenMode(10); {pattern xor dest -> dest}

        if isSel or isBorder then
           PenPat(maskPat[selMask])
        else
           PenPat(maskPat[crgMask]);

        if isBorder and (aRect.left <> aRect.right) then begin
           penSize(4, 3);
           case rg.rKind of
              aRowHedRg: InsetRect(aRect, -8, -3);
              aColHedRg: InsetRect(aRect, -4, -8);
              otherwise  begin
                            InsetRect(aRect, -3, -2);
                            penSize(3,2);
                         end;
           end;
           FrameRect(aRect);
        end else
           paintRect(aRect);
        PenNormal;
     end; end;



{******************************************************}
{$S TEscrol}
procedure ifScrSnN {aBandX: bandX; snipNId: idType; var snip1Id: idType;
           var hideP: pixel};
        {If we scroll aBand so that snipN is right- or bottom-justified,
        what will be the first snip (snip1Id) shown in the view, and
        how many pixels will be hidden (hideP)?}
        {assume aBand is not a title band}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with aBandX^ do begin
           hideP := 2 + SnipWidth(bKind, snipNId) - (bHiP - bLoP);
           snip1Id := snipNId;
           while (hideP < 0) do begin
              GetSnipId(bKind, MMPrior, 0, snip1Id, snip1Id);
              if (snip1Id = mInfSnip) then begin
                 GetSnipId(bKind, MMFirst, 0, snip1Id, snip1Id);
                 hideP := 0; end
              else hideP := hideP + 1 + SnipWidth(bKind, snip1Id); end;
           if (snip1Id = snipNId) then hideP := 0; end;
     end;




{******************************************************}
{$S TEscrol}
procedure ifScrSn1 {aBandX: bandX; snipId: idType; hideP: pixel;
           var dp: pixel; var jump: boolean};
        {If we scroll aBand so that snipId starts the band with hideP pixels
        hidden, how many pixels (dp) will we have scrolled?  Also sets jump to
        true if dp is greater than the bandwidth (ie, we should jump to the
        new display rather than scroll to it). If we return true for jump,
        then dp is undefined}
        {assume aBand is not a title band}
     var
        snipNext:    idType;
        distance:    pixel;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with aBandX^ do begin
           snipNext := bLoSnipX^.sId;
           dp := -(bLoP - bLoSnipX^.sLoP) -1 + hideP;
           if SnipLT(bKind, bLoId, snipId) then begin
              {Search forward}
              while (snipNext <> pInfSnip) and (snipNext <> snipId) do begin
                 dp := dp + SnipWidth(bKind, SnipNext) + 1;
                 GetSnipId(bKind, MMNext, 0, snipNext, snipNext); end; end
           else begin
              {Search backward}
              while (snipNext <> mInfSnip) and (snipNext <> snipId) do begin
                 GetSnipId(bKind, MMPrior, 0, snipNext, snipNext);
                 dp := dp - SnipWidth(bKind, snipNext) - 1; end; end;
           dp := -dp;
           if (dp >= 0) then distance := dp
                        else distance := -dp;
           if (distance > bHiP - bLoP) then jump := true
                                       else jump := false; end;
     end;





{******************************************************}
{$S TEwork1}
function inHandle {(aKind: snipKind; p: pixel;
                var loSnipId, hiSnipId: idType): boolean};
        {if p is in a grid handle (of orientation aKind), set
        lo and hi snipId's to the snips which surround p and return
        true; otherwise set both snip Id's to the snip p is
        in and return false}

  var
     aSnipX, newSnipX:  snipX;
     status:            integer;
     dP:                integer;
     closeGrid:         pixel;
  begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     dP := gridHndWid[aKind];
     aSnipX := snipXAtP(aKind, p);
     with aSnipX^ do begin {first let's just set loSnipId and hiSnipId}
        loSnipId := sId;
        hiSnipId := loSnipId;
        if abs(p - sLoP) > abs(p - (sLoP + sDp)) then begin
          {we're closer to high end}
           if loSnipId <> minfsnip then begin
               getSnipId(aKind,MMNext,0,loSnipId,hiSnipId);
           end else begin
              hisnipid := loband[akind].bNxtBandX^.bloid;
              getsnipid(akind,MMPRIOR,0,hisnipid,losnipid);
           end;
           closeGrid := sLoP + sDp;
        end else begin
          {we're closer to low end}
           getSnipId(aKind,MMPrior,0,hiSnipId,loSnipId);
           closeGrid := sLoP-1;
        end;

        if aKind = colKind then
           if (not underEdit(mInfSnip, loSnipId) ) and
              (not underEdit(mInfSnip, hiSnipId) ) and
              (sDp > 18)        {don't use wide grid hndles for 1 char cols}
                 then
              dP := dP + 4;

        if  ((aKind=rowKind) and not tblPars.rowGridHandles) or
                 ((aKind=colKind) and not tblPars.colGridHandles) or
                 (p < closeGrid - dP - 1) or (p > closeGrid + dP)
              then begin
           if tracetmgr then writeln('inhandle returns false');
           inHandle := false;
           hiSnipId := sId;
           loSnipId := sId;
        end else
           begin
           if tracetmgr then writeln('inhandle returns true');
           inHandle := True;
           end;
     end;
  end;


{******************************************************}
{$S TEwork1}


procedure LDtmgr;
begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
end;

{******************************************************}
{$S TEcold}


procedure LDtmLoFreq;
begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
end;




{******************************************************}
{$S TEwork1}

procedure mkSnipPt {aKind: snipKind; aSnipP: pixel; aPt: point;
                    var newPt: point};
        {set newPt to a point which in the aKind direction is equal
        to aSnipP, and in the orthogonal direction is equal to aPt}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        newPt := aPt;
        newPt.vh[axisOfSKind[aKind]] := aSnipP;
     end;




{******************************************************}
{$S TEwork1}

procedure mkView {aBandX, bBandX: bandX; var aView: view};
        {aBand and bBand are orthogonal bands -- set aView to
        these two bands, in the proper order, i.e., row, col}
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aView do
        if aBandX^.bKind = rowKind then begin
             vBandX[rowKind] := aBandX; vBandX[colKind] := bBandX end
        else begin
             vBandX[rowKind] := bBandX; vBandX[colKind] := aBandX end;
   end;


{******************************************************}
{$S TEwork1}

procedure MoveGrid {loCol: idType; initH, toH: pixel};
        {Change the right-boundary of column loCol from initH to toH (if loCol <>
        mInfSnip; matMgr may say otherwise.  This routine
        updates both the data structures and the picture.
           If loCol = pInfSnip or nullSnip, then fatal error.}
        var
           hiCol:          idType;
           status:         integer;
           aSnipX:         snipX;
           aBandX:         bandX;
           newWid, oldWid: pixel;
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
           if traceXTMgr then begin
              writeln('tm MoveGrid, loCol, initH, toH =');
              writeln('           ',loCol, initH, toH);
           end;

           {$IFC tmdebug}
           if (loCol = pInfSnip) or (loCol = nullSnip) then
              begin
              if fwriteln then
                writeln('** tm/moveGrid: bad loCol');
              end

           else
           {$ENDC }
              if (loCol <> mInfSnip) then
                 begin
                 aBandX := bandXAtP(colKind, initH+gridhndwid[colkind]);
                 aSnipX := snipXOfId(aBandX, loCol);
                 if (aSnipX <> nil) then with aSnipX^ do
                    begin
                    if (toH <> sLoP + sDp)
                      then NewColWid(loCol, loCol, cMax(0, toH-sLoP));
                    end
                 else with aBandX^ do
                    begin
                    {we're changing the width of a column whose right grid
                    only is showing; the column itself is immediately to
                    the left of the band, ie, not visible}
                    oldWid := SnipWidth(colKind, loCol);
                    NewColWid(loCol, loCol, oldWid + cMax(0, toH - bLoP -1));
                    chgBand (aBandX, loCol, oldWid + 1);
                    end;
                 ShoNewWid(colKind, loCol, loCol);
                 end;
        end;

{******************************************************}


{ end tm2}


ÿ