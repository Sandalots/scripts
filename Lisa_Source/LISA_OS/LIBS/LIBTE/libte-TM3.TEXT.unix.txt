                {libte/tm3.text}

              {this file included from libte/tm.text}





{******************************************************}
{$S TEscrol}

function newBandX {(aKind: snipKind): bandX};
        {create a new band data structure of aKind; set its
        successor and loSnipX to nil, but
        don't thread it in anywhere nor set its snips
        or screen pixels; return its pointer}
     var
        tBandX: bandX;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then writeln ('%tm newBandX');
        {$ifc tmdebug}
        if freeBandX = nil then
             fatalError('tm',' newBandX', 'out of bands');
        {$endc}
        tBandX := freeBandX;
        freeBandX := freeBandX^.bNxtBandX;
        with tBandX^ do begin
           bKind  := aKind;
           bNxtBandX := nil;
           bLoSnipX := nil;
        end;
        newBandX := tBandX;
     end;


{******************************************************}
{$S TEwork1}

procedure NewColWid {aLoCol, aHiCol: idType; newWid: pixel};
        {This is a matMgr interface routine.  It, in effect, simplifies the
        matMgr interface for tMgr and fexec.
           Set the column-width of columns loCol through hiCol to newWid pixels
        (or to whatever more "appropriate" values the matMgr may choose)}
        var
           aRg:         range;
           undoState:   integer;
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with aRg do begin
           if traceXTMgr then begin
              writeln('tm newColWid; loCol, hiCol, newWid = ');
              writeln('            ', aLoCol, aHiCol, newWid);
           end;

           rKind := aColRg;
           loRow := mInfSnip;
           loCol := aLoCol;
           hiRow := pInfSnip;
           hiCol := aHiCol;
           setSnipWidth(aRg, newWid) ;
        end; end;



{******************************************************}
{$S TEcold}

procedure NewRgBorders {newRg: range; useMarquee: boolean};
        {no border currently exists; create data structures for
        the range feedback for each view and display it (modulo
        tblPars general instructions); cases:
                shoMarquee: selection feedback
                not " "   : only curr-rg feedback

        }
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
         {$IFC tedebug}
         if traceXTMgr then begin
            prntRg( 'tm NewRgBorders:  newRg = ',newRg);
         end;
         {$ENDC}
         setNewHiLite(newRg,  useMarquee, False, True);
         if traceXTMgr then writeln('exiting tm NewRgBorders');
     end;




{********************************************************************}
{$S TEwork1}

procedure NewRgImg {rg: range};
        {contents of cells within range may have changed;
        redisplay them all. [if rg is under edit, performance
        is optimized due to virtRect and clipRect in rgBrd]}
var jView     : view;
     vwRect   : rect;
     hlRect   : rect;
     doReDraw : boolean;
begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
{$IFC tedebug}
        if traceTMgr then
           prntRg('tm newRgImg of:',rg);
{$ENDC}
{$IFC tmDebug }
                   times[0].start := elapstime;
{$ENDC }
    case rg.rKind of
       a1CellRg,
       aRowHedRg,
       aColHedRg : begin
                      doReDraw := true;
                      if UnderEdit(rg.loRow, rg.loCol) then begin
                         if rgEq(rg, hl.rg) then begin
                            doreDraw := false;
                            if traceTMgr  then
                               writeln('Redrawing cell-with-selection in rgBrds');
                            SetPnlPort(tblPnl);
                            jView := nullView;
                            while eachView(jView) do with jView do begin
                               if setHLRect(vBandX[rowKind]^.curHL, vBandX[colKind]^.curHL, hlRect) then begin
                                  getVwRect(jView, vwRect);
                                  clipRect (vwRect);
                                  sectClipRgn(tblRgnH);
                                  shoSelCell(HLRect);
                                  if hl.isOn and (not hl.isBorder) then
                                     hiLiteRect(HLRect, vwRect, tblRgnH);
                               end;
                            end;
                         end
                      end;
                      if doReDraw then
                         if rg.rKind = a1CellRg then reDraw1cRg(rg)
                         else reDrawRg(rg)
                   end;
       aRectRg,
       aRowRg,
       aColRg,
       aWTBoxRg  : reDrawRg(rg)
    end;
    {$IFC tmDebug }
       times[0].diff := elapstime - times[0].start + times[0].diff - 100;
       times[0].cnt  := times[0].cnt + 1
    {$ENDC }
 end;



{******************************************************************************}
{$S TEscrol}

function newSnipX {(parBandX: bandX): snipX};
       {create a new snip data structure; set its parent
        band to parBandX and its successor to nil, but
        don't thread it in anywhere nor set its snip id
        or screen pixels; return its pointer}
var tSnipX : snipX;
begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
   {$ifc tmdebug}
   if freeSnipX = nil then
        fatalerror('tMgr', 'newSnipX', 'Please increase my snip budget.');
   {$endc}

   tSnipX    := freeSnipX;
   freeSnipX := freeSnipX^.sNxtSnipX;
   with tSnipX^ do begin
      sBandX := parBandX;
      sNxtSnipX := nil
   end;
   newSnipX := tSnipX;
end;




{******************************************************}
{$S tmcold}

{$IFC tmdebug}
procedure prntBand {( aBandX: bandX)};
        {if traceFlg, print out the attributes of the band}
     var
        aSnipX: snipX;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with aBandX^ do begin
           if bKind = rowKind
              then writeln('a rowKind band:')
              else writeln('a colKind band:');
           writeln('bLoP=', bLoP, '  bHiP=', bHiP, '  bLoOffP=', bLoOffP);
           writeln('bLoId=', bLoId, '  bHiId=', bHiId);
           writeln('bHideP=', bLoP - bLoSnipX^.sLoP + 1);

           writeln('  Snips:');
           aSnipX := bLoSnipX;
           while aSnipX <> nil do begin
              writeln('      ', aSnipX^.sId);
              aSnipX := aSnipX^.sNxtSnipX;
           end;
        end;
     end;
{$ENDC }





{******************************************************}
{$S TEwork1}

function PtIn1CRg {(hv: point; targRg: range): boolean};
        {Is targRg a field-like object (cell, row/col title,
        table title) and does hv fall within
        a display of it?}

  var
     prtOfTbl:       tblPart;
     hvRg:           range;
     vRect, cRect:   rect;
     bool : boolean;

  begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
  with targRg do begin
         if traceTMgr then Writeln('tm ptIn1CRg');
         {$IFC tedebug}
         if traceTMgr Then PrntRg( 'targrg',targrg);
         {$ENDC }

    findTblPt(hv, prtOfTbl, hvRg, vRect, cRect);
    case rKind of
       a1CellRg,
       aRowHedRg,
       aColHedRg,
       aTblHedRg:
          begin
          ptIn1CRg := rgEq(hvRg, targRg);
          bool := rgEq(hvrg,targrg);
          end;
       aRowRg: begin
               if (hvrg.rkind = arowhedrg) and (rkind = arowrg) and
                  (hvrg.lorow = lorow) and (hvrg.hirow = hirow) and
                  tblPars.editRowTitle then
                  begin
                  ptIn1CRg := true;
                  bool:= true;
                  end;
               end;

       aColRg: begin
               if  (hvrg.rkind = acolhedrg) and (rkind = acolrg) and
                  (hvrg.locol = locol) and (hvrg.hicol = hicol)  and
                  tblPars.editColTitle then
                  begin
                  ptIn1CRg := true;
                  bool:= true;
                  end;
               end;
       otherwise
               begin
               bool := false;
               ptIn1CRg := false;
               end;
    end;
  end;
  if tracetmgr then writeln('ptin1crg returns ',bool);

  end;




{******************************************************}
{$S TEwork1}

procedure reBldTbl {initRg: range};
        {Load parameters of a new table.  Set up screen to show the upper
        left hand corner of initRg at the upper left hand corner of
        a single view filling the whole table panel; don't affect screen;
       Note: reBldTbl is a shorthand for calling
                tmNewPars;
                tmLoadBands;
                   tmLoadNextBand;
        }
     var
        aTmBand:        tmBand;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then Writeln('tm ReBldTbl ');

        tmNewPars;
        tmLoadBands;
        with aTmBand do begin
           tmbKind := rowKind;
           tmbLoP := cellsRect.topLeft.v;
           tmbHiP := cellsRect.botRight.v;
           tmbHideP := 0;
           tmbLoId := rgLoSnip(rowKind, initRg);
           tmLoadNextBand(aTmBand);

           tmbKind := colKind;
           tmbLoP := cellsRect.topLeft.h;
           tmbHiP := cellsRect.botRight.h;
           tmbHideP := 0;
           tmbLoId := rgLoSnip(colKind, initRg);
           tmLoadNextBand(aTmBand);

           tmbLoId := nullSnip;
           tmLoadNextBand(aTmBand);

        end;
     end;


{***********************************************************************************}
{$S TEwork1}


procedure reDraw1cRg {rg: range};
        {redraw any displays of the 1-cell rg;
         shoCell worries about exceptional ranges such as titles or the
         whole table box, but don't feed it gray;
      ! ASSUMES: tblPnl NOT already set!}
   var

      aView:            view;
      rBandX, cBandX:   bandX;
      rSnipX, cSnipX:   snipX;
      pnlNotSet:           boolean;
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
   with rg do begin
      if traceTMgr then writeln('tm reDraw1cRg ');

      {$IFC tmDebug }
              times[7].start := elapstime;
      {$ENDC }

      pnlNotSet := True; {don't call setPnlPort except when absolutely necessary!}
      cBandX := loBand[colKind].bNxtBandX;
      while (cBandX <> nil) do begin
         if not snipLT(colKind, cBandX^.bHiId, loCol) then
                if not snipLT(colKind, loCol, cBandX^.bLoId) then begin
            rBandX := loBand[rowKind].bNxtBandX;
            while (rBandX <> nil) do begin
               if not snipLT(rowKind, rBandX^.bHiId, lorow) then
                      if not snipLT(rowKind, lorow, rBandX^.bLoId) then begin
                  cSnipX := snipXOfId(cBandX, loCol);
                  rSnipX := snipXOfId(rBandX, loRow);
                  if pnlNotSet then begin
                     SetPnlPort(tblPnl);   pnlNotSet := False;
                  end;
                  shoCell(rSnipX, cSnipX, tblRgnH);
               end;
               rBandX := rBandX^.bNxtBandX;
            end;
         end;
         cBandX := cBandX^.bNxtBandX;
      end;

      {$IFC tmDebug }
         times[7].diff := elapstime - times[7].start +
                          times[7].diff - 100;
         times[7].cnt  := times[7].cnt + 1
      {$ENDC }

   end; end {reDraw1cRg};



{***********************************************************************************}
{$S TEwork1}


procedure reDrawRg {rg: range};
        {redraw any displays of rg; some may be under edit;
         shoCell worries about exceptional ranges such as titles or the
         whole table box, but don't feed it gray}
   var
      aView:            view;
      rBandX, cBandX:      bandX;
      bRowRg, bColRg:      range;
      rowLo, rowHi:        idType;
      colLo, colHi:        idType;
      rSnipX, cSnipX:      snipX;
      cShown, rShown:      idType;
      clpRct:              rect;
      hidIt:               boolean;
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
       if traceTMgr then writeln('tm reDrawRg ');

      {$IFC tmDebug }
              times[6].start := elapstime;
      {$ENDC }

      setPnlPort(tblPnl);
      hidIt := hl.isBorder and not(rgeq(rg,hl.rg) and (hl.rg.rKind = a1CellRg));
      if hidIt then HLHide(tblRgnH);
      cBandX := @loBand[colKind];
      while (cBandX <> nil) do
         with cBandX^ do begin
            getSnipRg(colKind, bLoId, bHiId, bColRg);
            if snipRgIsect(colKind, rg, bColRg, colLo, colHi) then begin
               rBandX := @loBand[rowKind];
               while (rBandX <> nil) do begin
                  getSnipRg(rowKind, rBandX^.bLoId, rBandX^.bHiId, bRowRg);
                  if snipRgIsect(rowKind, rg, bRowRg, rowLo, rowHi) then begin
                     cSnipX := snipXOfId(cBandX, colLo);

                     repeat
                        rSnipX := snipXOfId(rBandX, rowLo);
                        if cSnipX^.sId <> pInfSnip then repeat
                           if rSnipX^.sId <> pInfSnip then
                              shoCell(rSnipX, cSnipX, tblRgnH);
                           rShown := rSnipX^.sId;
                           rSnipX := rSnipX^.sNxtSnipX;
                        until (rShown = rowHi);
                        cShown := cSnipX^.sId;
                        cSnipX := cSnipX^.sNxtSnipX;
                     until (cShown = colHi); end;
                  rBandX := rBandX^.bNxtBandX; end; end;
            cBandX := cBandX^.bNxtBandX; end;
            if hidIt then HLRestore(tblRgnH);
      {$IFC tmDebug }
         times[6].diff := elapstime - times[6].start + times[6].diff - 100;
         times[6].cnt  := times[6].cnt + 1
      {$ENDC }
   end;




{******************************************************}
{$S TEwork1}

procedure reShoHiLites {useOldHiLite: boolean; shoRgnH: rgnHandle};
        {complement all selection highlights:
           the client is responsible for appropriateness of hiLiteOn;
           observe useOldHiLite and clip to shoRgn}
     var
        aView:                  view;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        setPnlPort(tblPnl);
        aView := nullView;
        while eachView(aView) do
           shoAHiLite(useOldHiLite, aView, shoRgnH);
     end;



{******************************************************}
{$S TEwork1}

function  rgHiSnip {(aKind: snipKind;  rg: range): idType};
        {return the ending snip id (of aKind) in rg}
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
   if akind = rowkind then
           rgHiSnip := rg.hiRow
   else
           rgHiSnip := rg.hiCol;
   end;


{******************************************************}
{$S TEwork1}

function rgIsect {(aRg, bRg: range; var xRg: range): boolean};
        {set xRg to (aRg Intersect bRg); the result type will be one of
        aNullRg, a1CellRg, aWTBoxRg, aRowGrid, aColGrid or aRectRg;
        return false if aNullRg (or if it is aSnipGrid and the higher
        snip doesn't intersect), else true;
        handle minfsnip and pinfsnip as uniform cases}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with xRg do begin
           if snipRgIsect(rowKind, aRg, bRg, loRow, hiRow) then
              if snipRgIsect(colKind, aRg, bRg, loCol, hiCol) then
                 if aRg.rKind = aRowGrid then begin
                    if hiRow = aRg.hiRow then rKind := aRowGrid
                    else rKind := aNullRg
                 end
                 else if aRg.rKind = aColGrid then begin
                         if hiCol = aRg.hiCol then rKind := aColGrid
                         else rKind := aNullRg
                      end
                 else if (loRow = hiRow) and (loCol = hiCol) then rKind := a1CellRg
                 else rKind := aRectRg
              else xRg := nullRg
           else xRg := nullRg;

           if rKind = aNullRg then rgIsect := false
           else rgIsect := true;
        end;
     end;




{******************************************************}
{$S TEwork1}

function  rgLoSnip {(aKind: snipKind;  rg: range): idType};
        {return the initial aKind snip id of rg}
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     if akind = rowkind then
           rgLoSnip := rg.lorow
     else
           rgLoSnip := rg.locol;
   end;





{******************************************************}

{$S TEwork1}

procedure rgOfView {aView: view; var aRg: range};
        {set aRg to the range shown in aView (includes partially
         displayed cells)}
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aView, aRg do begin
        rKind := aRectRg;
        loRow := vBandX[rowKind]^.bLoId;
        loCol := vBandX[colKind]^.bLoId;
        hiRow := vBandX[rowKind]^.bHiId;
        hiCol := vBandX[colKind]^.bHiId;
     end; end;




{******************************************************}
{$S TEcold}

procedure rlsBand {aBandX: bandX};
        {Removes a band, along with its snips, from the band list, returning
        the band and the snips to the free lists.  Does not change the picture.}
     var
        pBandH:  ^bandX;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with aBandX^ do begin
           rlsSnips(bLoSnipX);
           pBandH := @loBand[bKind].bNxtBandX;
           while (pBandH^ <> aBandX) do
              pBandH := @pBandH^^.bNxtBandX;
           pBandH^ := bNxtBandX;
           bNxtBandX := freeBandX;
           freeBandX := aBandX; end;
     end;





{******************************************************}
{$S TEscrol}

procedure rlsSnips {var oldSnipX: snipX};
        {oldSnipX points to a linked list of snipX's, release them
        all and set oldSnipX to nil}
     var
        sX:     snipX;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if oldSnipX <> nil then begin
                sX:= oldSnipX;
                while sX^.sNxtSnipX <> nil do sX := sX^.sNxtSnipX;
                sX^.sNxtSnipX := freeSnipX;
                freeSnipX := oldSnipX;
                oldSnipX := nil; end;
     end;



{ ----------------  9:45 am     8/17/82         rkm  -------------- }
{$S TEscrol}
procedure ScrBand{
                aKind:          snipKind;       band orientation
                aP:             pixel;          band locator
                scrScale:       ScrollType;     kind of scroll
                scrDir:         ScrollDir;      which way to scroll
                scrFract:       fract;          new thumb (if jmp)
            var  didMove:       boolean);       did anything really move?};
                        { ---------------------- }
      {scroll the indicated band in the indicated manner; tell if it
       actually moved; (it won't move, for example, if it's already
       pinned in the indicated direction) }
                        { ---------------------- }
   var
      aBandX:                   bandX;
      newLoId, hiSnip,
          penUltSnip:           idType;
      hiSnipX:                  snipX;
      newHideP, loShowing,
         curHideP,
         adjBHiP, bigIncr,
         L, scrGoal, step,
         DTrailing, DLeading,
         curwid:   pixel;

   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if traceXTMgr then begin
         writeln('tm scrBand.  aKind, ap, scrScale, scrDir, scrFract');
         writeln('  ',ord(akind), ap, ord(scrScale), ord(scrDir), scrFract);
      end;
      aBandX := bandXAtP(aKind, aP);
      with aBandX^ do if (bLoId <> mInfSnip) and (bLoId <> PinfSnip) then begin

         curHideP := bHideP(aBandX);   {how much of 1st snip is hidden}
         loShowing := 1 + snipWidth(aKind, bLoId) - curHideP; {amt of 1st snip showing}
         adjBHiP := cMax( bLoP,        {adjusted to displayed table boundaries}
                           cMin(bHiP,
                                  tblRect.botRight.vh[axisOfSKind[aKind]]
                               )
                        );
         bigIncr := cMin ( (tblPars.scrollIncr[aKind]) ,
                           ( ( 3*( adjBHiP - bLoP) ) div 4)
                         );
         hiSnipX := snipXAtP(aKind, adjBHiP);
         hiSnip := hiSnipX^.sId;


        { defaults: }
         newLoId := bLoId;
         newHideP := 0;

         case scrScale of
            incrScroll: begin
               if scrDir = scrollFwd then
                  begin
                     if loShowing <= bigIncr then
                        getSnipId(aKind, mmNext, 0, bLoId, newLoId)
                     else
                        newHideP := curHideP+bigIncr;
                  end

                  ELSE {ScrollBak}
                     begin
                     if curHideP > 0 then
                        newHideP := curHideP - cMin(curHideP, bigIncr)
                     else
                        begin
                        getSnipId(aKind, mmPrior, 0, bLoId, newLoId);
                        if newLoId = mInfSnip then
                           newLoId := bLoId
                        else
                           newHideP := cMax(0,
                                             (snipWidth(aKind, newLoId) - bigIncr)
                                           );
                        end;
                     end;
            end {incrScroll case};

            jmpScroll: begin
                       if tracextmgr then writeln('getsnipid fract: scrfract newid ',scrfract, newloid);
                       GetSnipId(aKind, MMFraction, scrFract, newLoId, newLoId);
                       if tracextmgr then writeln('getnsipid returns snipid ',newloid);
                       end;

            pageScroll:  begin
              { compute Larry's flip parameters --  and since snips are not
                of uniform width, the formula is adjusted to:
                      MAX ( L/2 , L - DTrailing, DLeading )    }

               {l is width of band}
               {d is width of row} {dleading width of thing at top}
                                   {dtrailing }
               L := adjBHiP - bLoP;
               if scrDir = SCrollFwd then with hiSnipX^ do
                  begin
                     DLeading := cMin(loShowing, bigIncr);
                     DTrailing := adjBHiP - (*hiSnipX^.*)sLoP;
                     if ((*hiSnipX^.*)sLoP + (*hiSnipX^.*)sDp) > adjBHiP + 2 then begin
                       { hi snip is only partially visible, keep prev visible }
                        getSnipId(aKind, mmPrior, 0, hiSnip, penUltSnip);
                        if penUltSnip <> mInfSnip then
                           begin
                           dTrailing := dTrailing + snipWidth(aKind, penUltSnip);
                           end;
                     end;
                  end
               else

                  {ScrollBak}
                  begin
                     DLeading  := cMin(bigIncr, adjBHiP-hiSnipX^.sLoP);
                     DTrailing := loShowing;
                     if curHideP > 1 then begin {lo snip only partially visible}
                        getSnipId(aKind, mmNext, 0, bLoId, penUltSnip);
                        if penUltSnip <> pInfSnip then
                           dTrailing := dTrailing + snipWidth(aKind, penUltSnip);
                     end;
                  end;
               scrGoal := cMax( (L div 2) , ( L - DTrailing) );
               scrGoal := cMax( scrGoal, DLeading);

              {we now know how many pixels to scroll -- next compute what snip
               that leads to:   }

               newHideP := curHideP;
               curWid := snipwidth(aKind, newLoId)+1;
               repeat {step things along}
                  if scrDir = ScrollFwd then
                     {scrollFwd: }
                     begin
                        step := curWid - newHideP;
                        if step >= scrGoal then begin
                           newHideP := newHideP + scrGoal;
                           if newHideP < 10 then newHideP := 0;
                           scrGoal := 0;
                        end else begin
                           scrGoal := scrGoal - step;
                           newHideP := 0;
                           penUltSnip := newLoId;
                           getSnipId(aKind, mmNext, 0, penUltSnip, newLoId);
                           if newLoId = pInfSnip then begin
                              newLoId := penUltSnip;
                              newHideP := curwid - 2;
                              scrGoal := 0;
                           end;
                           curWid := 1+snipWidth(aKind, newLoId);
                        end;
                     end {scrollFwd}
                  ELSE
                     {scrollBak}
                      begin
                        step := newHideP;
                        if step >= scrGoal then begin
                           newHideP := newHideP - scrGoal;
                           scrGoal := 0;
                        end else begin
                           scrGoal := scrGoal - step;
                           penUltSnip := newLoId;
                           getSnipId(aKind, mmPrior, 0, penUltSnip, newLoId);
                           if newLoId = mInfSnip then begin
                              newLoId := penUltSnip;
                              newHideP := 0;
                              scrGoal := 0;
                           end else begin
                              curWid := 1+snipWidth(aKind, newLoId);
                              newHideP := curWid;
                           end;
                        end;
                     end ;{scrollBak}
               until ( scrGoal <= 0 );
            end {pageScroll case};
         end {scrScale cases};

         if tracextmgr then
            begin
            writeln('before dontoverscroll');
            writeln('newlowid,newhidep,adjbhip', newloid,newhidep,adjbhip);
            end;
         dontOverScroll(aBandX, newLoId, newHideP, adjBHiP);
         if tracextmgr then
            begin
            writeln('after dontoverscroll');
            writeln('newlowid,newhidep', newloid,newhidep);
            end;
         scrToSnip(aBandX, newLoId, newHideP);
      end;
      didMove := tblDidScroll;
   end {ScrBand};

{---------------------------------------------------------------------------}
{$S TEscrol}

procedure scrToSnip {aBandX: bandX; aLoId: idType; hideP: pixel};
        {Scroll (both the data structures and the picture) aBand so that
        it starts with aLoId, omitting the first hideP pixels.
        Assumes that aLoId in not a nullSnip or mInfSnip.
        Set tblDidScroll to truth of "picture actually moved"}
     var
        updRect:     rect;
        updRgnH,
          bandRgnH:  rgnHandle;
        dh, dv, dp:  pixel;
        jump:        boolean;
        hideHL,
           bndHadHL: boolean;
        aSnip:      idtype;
        visrg, isrg :range;
        hlvisible : boolean;
        pt:point;
        obandX : bandX;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if traceXTMgr then begin
           writeln('tm scrToSnip.    aLoId,   curShoState');
           writeln('                ', aLoId, ord(curShoState));
        end;

        if traceXTMgr then
           begin
           if (aLoId=nullSnip) or (aLoId=mInfSnip) then
              begin
              writeln(' ** null or minf Snip ** ');
              exit(scrtosnip);
              end;
           end;
       setPnlPort(tblPnl);
       hideHL := False;
       getBRect(aBandX, updRect);
       if sectRect(updRect, tblRect, updRect) then {naught};
       updRgnH := newRgn;
       bandRgnH := newRgn;
       SetRectRgn(updRgnH, updRect.left, updRect.top,
                  updRect.right, updRect.bottom);
       SetRectRgn(bandRgnH, updRect.left, updRect.top,
                  updRect.right, updRect.bottom);
       ClipRect(updRect); {this clips to the whole visible band}

       ifScrSn1(aBandX, aLoId, hideP, dp, jump);

       with aBandX^, curHL do
          begin
          bndHadHL := hasHL;

          hlvisible := false;
          obandX := @loband[orthkind[bkind]];
          {skip title band}
          obandX := obandX^.bnxtband;
          pt.vh[axisofskind[bkind]] := blop+1;
          while (obandx <> nil) and not hlvisible do
             begin
             pt.vh[axisofSkind[obandX^.bkind]] := obandX^.blop+1;
             visrgofview(pt,visrg);
             if rgisect(hl.rg,visrg,isrg) then hlvisible := true;
             obandX := obandX^.bnxtband;
             end;


          {be carefull not to go next of currrg if it is not on the screen}
          if (hasHL) and (hl.isBorder) and (HL.ison) and hlvisible
              then
             begin


             if bkind = rowkind then
                 getsnipid(colkind,mmnext,0,hl.rg.hicol,aSnip)
             else {colkind:}  getsnipid(rowkind,mmnext,0,hl.rg.hirow,aSnip);


             if ( (loHLP + dp + 4 > bHiP) or
                     (hiHLP + dp - 4 < bLoP) or
                     (hiHLP + 4 > bLoOffP  )  or
                     (aSnip = PinfSnip     )
                   ) then
                begin
                {we seem to have a border which is in danger of
                scrolling mostly off the screen (or which intersects
                gray) -- we'd best not take the chance of creating
                an untraceable residue}

                hideHL := True;
                HLHide(bandRgnH);
                end;
             end;
          end;

       ClipRect(updRect); {this clips to the whole visible band}
       BackPat(offTblPat);

       if jump then
          begin
          tblDidScroll := True;
          EraseRect(updRect)
          end
       else
          begin
          if aBandX^.bKind = rowKind then
             begin
             dh := 0;
             dv := dp;
             end
          else
             begin
             dh := dp;
             dv := 0;
             end;
          tblDidScroll := (dh <> 0) or (dv <> 0);
          ScrollRect(updRect, dh, dv, updRgnH);
          end;
       BackPat(white);
       if traceTmgr then writeln('scrToSnip just scrolled');

       chgBand(aBandX, aLoId, hideP);
       if (curShoState = ShoIfClose) and (not jump) then
          curShoState := ShoNormally;
       case curShoState of
          ShoAllTbl:
             begin
             if traceTMgr then writeln('shoAllTbl');
             shoTbl(tblRgnH);
             curShoState := ShoNormally;
             end;
          ShoNormally:
             begin
             if traceTMgr then
                begin
                writeln('ShoNormally; updRgn will flash: ');
                clipRect(tblRect);
                sectClipRgn(updRgnH);
                penNormal;
                invertRect(tblRect);
                writeln('it flashed.');
                invertRect(tblRect);
                end;
             hl.isOn := False;
             shoBand(aBandX, updRgnH);
             if traceTMgr then writeln('showed update area without hilite');
             if not hideHL then
                begin
                hl.isOn := True;
                if bndHadHL then
                   reShoHiLites(False, updRgnH)
                else
                   reShoHiLites(False, bandRgnH);
                if traceTMgr then writeln(' hilited ');
                end;
             end;
          ShoIfClose:
             begin
             if traceTMgr then writeln('ShoIfClose');
             curShoState := ShoAllTbl;
             end;
          end;
       if hideHL then HLRestore(bandRgnH);
       disposeRgn(updRgnH);
       disposeRgn(bandRgnH);
       shoBandGrids(aBandX);  {avoid gray-phase problems}
     end {scrToSnip};




{******************************************************}
{$S TEwork1}

procedure sectClipRgn {aRgnH: rgnHandle};
        {set the current clipping region [using the global tMgr clipping
        region: clippRgn] to the intersection [which must
        at this point in development be rectangular]
        of clippRgn with aRgn; if aRgnH = nil, do nothing}
     var saveport : grafptr;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        if (aRgnH <> nil) then sectRgn(theport^.cliprgn,aRgnH,theport^.cliprgn);
     end;


{******************************************************}
{$S TEwork1}

procedure setAllHLPs;
        {set HL bounds for each band, saving the old values in OHL fields}
     var
        aKind:          snipKind;
        aBandX:         bandX;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        for aKind := rowKind to colKind do begin
           aBandX := nil;
           while eachBandX(aBandX, @loBand[aKind]) do
              setHLP(aBandX);
        end;
     end;


{******************************************************}
{$S TEopen2}

procedure setCR {rg: range};
        {set current range to rg}
   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
      if traceXTMgr then Writeln('tm setCR');
      CurrRg := rg;
   end;



{************************************************************************}
{$S TEwork1}

procedure setHLP{aBandX: bandX};
        {properly set aBandX^.curHL according to hl;
         save prev values in .prevHL}
     var
        bandRg:         range;
        trimGray:       boolean;
        loSnip, hiSnip: idType;
        offset:         pixel;
        aSnipX:         snipX;

     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     with aBandX^, curHL do begin
        prevHL := curHL;
        hlBandX := aBandX;

        bandRg := allRg;
        with bandRg do
           begin
           if bKind = rowkind then
              begin
              loRow := bLoId; hiRow := bHiId;
              trimGray := hl.rg.rKind <> aRowGrid;
              end
           else {colKind:}
              begin
              loCol := bLoId; hiCol := bHiId;
              trimGray := hl.rg.rKind <> aColGrid;
              end;
           end;

        hasHL := (bLoId <> pInfSnip) and ( trimGray or (bLoId <> mInfSnip) );
        if hasHL then
           hasHL := snipRgIsect (bKind, hl.rg, bandRg, loSnip, hiSnip);

        if hasHL then begin
           if trimGray and (hiSnip = pInfSnip) then {don't hilite gray}
              getSnipId(bKind, mmPrior, 0, hiSnip, hiSnip);
           if loSnip <> rgLoSnip(bKind, hl.rg) then
              offset := -1
           else
              offset := 0;
           aSnipX := snipXOfId(aBandX, loSnip);
           loHLP := aSnipX^.sLoP + offset;
           aSnipX := snipXOfId(aBandX, hiSnip);
           hiHLP := aSnipX^.sLoP + aSnipX^.sDp;

           if    ((bKind = rowKind) and (hl.rg.rKind = aRowGrid)) or
                 ((bKind = colKind) and (hl.rg.rKind = aColGrid)) then begin
              if hiSnip = rgHiSnip(bKind, hl.rg) then
                 loHLP := aSnipX^.sLoP - 2
              else { hiSnip is rgLoSnip(bKind, hl.rg) }
                 loHLP := aSnipX^.sLoP + aSnipX^.sDp - 1;
              hiHLP := loHLP + 3;
           end;
        end;
     end; end {setHLP};



{*************************************************************************}
{$S TEwork1}

function setHLRect {rowHLS, colHLS: aBHLState; var hlRect: rect): boolean};
        {set the highlight rect according to the row and column higlight
         state records; return true if a hilite in present, if false,
         set hlRect to nullRect}
      begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
         if rowHLS.hasHL and colHLS.hasHL then begin
            setHLRect := True;
            setRect(hlRect, colHLS.loHLP,
                            rowHLS.loHLP,
                            colHLS.hiHLP,
                            rowHLS.hiHLP);
            if (rowHLS.hlBandX^.bLoId = mInfSnip) then with hlRect do begin
              {we are dealing with the column title band}
               case hl.rg.rKind of
                  aColGrid: {a col-grid handle}
                             insetRect(hlRect, 1, 0);
                  aColHedRg: begin
                    {make room for col handle; *!CF: getCRect!*}
                     left := left + 1 + gridHndWid[colKind] div 2;
                     right := right - gridHndWid[colKind] div 2;
                  end;

               end;
            end;
         end else begin
            hlRect := nullRect;
            setHLRect := False;
         end;
      end;


{******************************************************}
{$S TEwork1}

procedure setNewHiLite {newRg: range; showMarquee,
                useOldHiLite, showIt: boolean};
          {compute newRg highlighting from scratch;
           showMarquee =>
               Selection hilite, as opposed to Curr-Range or text-sel hilite;
           showIt =>
               screen should be updated;
               useOldHilite =>
                  A similar hilite already exists and we should try to
                  XOR the difference in the ranges without turning off
                  the old hilite;
            }

        var
           aView: view;
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with newRg do begin
           if tracextmgr then begin
              writeln('tm setNewHiLIte. showMarquee, useOldHiLite, showIt =');
              writeln('               ', ord(showMarquee), ord(useOldHiLite), ord(showIt));
              {$IFC tedebug}
              prntRg('     new rg: ',newrg);
              {$ENDC }
           end;
           setPnlPort(tblPnl);
           hl.rg := newRg;
           hl.isSel := showMarquee;
           hl.isBorder := useBorder(newRg, showMarquee);
           setAllHLPs;
           if showIt then reShoHiLites(useOldHiLite, tblRgnH);
           hl.isOn := True;
        end; end;



{***********************************************************************}
{$S TEwork1}

procedure shoAGrid {aKind: snipKind; gridP: pixel; aSnipX: snipX;
                    vwRect: rect; loOffP:pixel};
      {show the grid of aKind at gridP (which begins aSnip);
       begin at the appropriate edge of vwRect and go to loOffp.}
   var
      gridT:    gridType;
      gridPt:   Point;

   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
   with aSnipX^ do begin
      {set the proper pattern type}
          penSize(1,1);
          if ImmBreakSnip(aKind, sId, Procinfo.mmBreakSnip) then
             gridT := brkGr
          else if useGrids[aKind] then
             gridT := normGr
          else
             exit(shoAGrid);

       mkSnipPt(aKind, gridP, vwRect.topLeft, gridPt);
          MoveTo(gridPt.h, gridPt.v);
       mkSnipPt(orthKind[aKind], loOffP, gridPt, gridPt);
       PenPat(gridPat[orthAxis[axisOfSKind[aKind]], gridT]);
          LineTo(gridPt.h, gridPt.v)

   end; end {shoAGrid};


{***********************************************************************}
{$S TEwork1}

procedure shoAHiLite {useOldHiLite: boolean; aView: view; shoRgnH: rgnHandle};
        {complement aView's hilite, clipping to shoRgn, and observing useOldHilite}
        {Do nothing if tblPars.EditTable is false}
     var
        rectNew, rectOld, rectSho, vwRect:        rect;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
     if tblPars.EditTable then with aView do begin

        if setHLRect( vBandX[rowKind]^.curHL, vBAndx[colKind]^.curHl, rectNew) then ;
        if setHLRect( vBandX[rowKind]^.prevHL, vBAndx[colKind]^.prevHL, rectOld) then ;

        if useOldHiLite then begin
           RectRgn(rgnNew, rectNew);
           RectRgn(rgnOld, rectOld);
           XorRgn(rgnOld, rgnNew, rgnNew);
           SectRgn(rgnNew, shoRgnH, rgnNew);
           rectSho := tblRect;
        end else begin
           CopyRgn(shoRgnH, rgnNew);
           rectSho := rectNew;
        end;
        getVwRect(aView, vwRect);
        if traceTMgr then begin
           writeln('tm shoAHiLite');
        end;
        hiLiteRect(rectSho, vwRect, rgnNew);
     end; end {shoAHiLite};

{******************************************************}
{$S TEscrol}

procedure shoBand {aBandX: bandX; shoRgnH: rgnHandle};
        {Display aBand (including designator bars, grids, splits, values,
         borders, marquees); save time by only displaying within updRgn}

     var
        tBandX:         bandX;
        tView:          view;
        bRect:          rect;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        setPnlPort(tblPnl);
        getBRect(aBandX, bRect);
        clipRect(bRect);
        SectClipRgn (shoRgnH);
        if not emptyrgn(theport^.cliprgn) then begin
           BackPat(white);
           tBandX := nil;
           while eachBandX(tBandX,
                 @loBand[orthKind[aBandX^.bKind]]) do begin
              mkView(aBandX, tBandX, tView);
              shoView(tView, shoRgnH);
           end;
        end;
     end;



{******************************************************}
{$S TEscrol}

procedure shoBandGrids{aBandX: bandX};
        {for each view of aBand, display the grid lines
         orthogonal to bKind}
     var
        tBandX:         bandX;
        tView:          view;
        oKind:          snipKind;
     begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        setPnlPort(tblPnl);
        BackPat(white);
        tBandX := nil;
        oKind := orthKind[aBandX^.bKind];
        while eachBandX(tBandX,
              @loBand[oKind]) do begin
           mkView(aBandX, tBandX, tView);
           shoGrid(tView, oKind, False, -1, tblRgnH);
        end;
     end;





{******************************************************}
{$S TEscrol}

procedure shoDes {aTitleView: view; shoRgnH: RgnHandle};
        {show split line and designator bar for aBand, including column
        row and grid handles; clip to shoRgn, modulo gray phasing;
        }
   var
      vwRect:      rect;
      aBandX:      bandX;
      dRect:       rect;
      aSnipX:      snipX;
      tempLoOffP : Pixel;
      tempP : Pixel;
      akind : snipkind;

   begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
   with aTitleView do begin

      if vBandX[rowKind]^.bLoId = mInfSnip then
         aBandX := vBandX[colKind]
      else
         aBandX := vBandX[rowKind];

      with aBandX^ do begin
         getVwRect(aTitleView, vwRect);

         PenNormal;
         clipRect(vwRect);
         sectClipRgn(shoRgnH);
         if not emptyrgn(theport^.cliprgn) then begin

           {put line after titles}
            tempLoOffP := aTitleView.vBandX[bkind]^.bLoOffp;
            dRect := cellsRect;
            tempP := drect.topleft.vh[axisofSkind[bkind]];
            trimsrect(bkind,tempP,temploOffP,drect);
            {$IFC tedebug}
            if traceTMgr then begin
               writeln ('tm shoDes: cellsRect = ');
               prntRect( cellsRect);
               prntrect( drect );

            end;
            {$ENDC}
            insetRect(dRect, -1, -1);
            FrameRect(dRect);

            if traceTMgr then writeln('   did it get +framed?');

            if snipHndDp[bKind] > 0 then {there truly is a handle}
               EraseRect(snipHndRect[bKind]);

            aSnipX := bLoSnipX;
            shoGrdHnd(bKind, aSnipX^.sLoP-1);
            while aSnipX <>  nil do begin
               with aSnipX^ do begin
                 {draw a grid handle at the end of the snip}
                  shoGrdHnd(bKind, sLoP+sDp);
                  if (sId <> pInfSnip) then shoSnipHnd (bKind, aSnipX);
                  aSnipX := sNxtSnipX;
               end;
            end;
         end;
      end;
   end; end;




{******************************************************}
{$S TEscrol}

procedure shoGrdHnd {aKind: snipKind; p: pixel};
        {show a grid handle of aKind at p;
         leave clipping alone}
        var
           gRect:       rect;
           u:           axis;
           butSize:     pixel;
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
           gRect := desRect[aKind];
           insetRect(gRect, -1, -1);    {let handle be of full length}
           butSize := gridHndWid[aKind];
           trimSRect(aKind, p-butSize div 2,
                    1+p+butSize div 2, gRect);

           PenNormal;
          if butSize < 2 then
              FillRect(gRect, black)
           else
              begin
              PenNormal;
              frameRect(gRect);
              end;
        end;


{******************************************************}
{$S TEscrol}

procedure shoGrid {aView: view; aKind: snipKind; selected: boolean;
                   shoP: pixel; shoRgnH: RgnHandle};
        {display the "selected?", aKind, grid line of aView which
         passes through shoP; if shoP < 0, then show all the aKind
         grid lines of aView, using gridPat for most of them
         and selGridPat for the currently selected one; clip to shoRgnH;
        Note: grids will only be shown as per useGrids[], though
         the gray extensions of grids will always be displayed, so
         as to avoid white trails thru gray
        Note: if tblPars.EditTable is false, then all grids will be shown in
         gridPat and none in selGridPat.}

        var
           vwRect:              rect;
           aBandX:              bandX;
           aSnipX:              snipX;
           gridP, loOffP:       pixel;
           gridPt:              point;

        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
        with tblPars, aView do begin
           if (vBandX[rowKind]^.bLoId <> mInfSnip) and
                 (vBandX[colKind]^.bLoId <> mInfSnip) then begin
              getVwRect(aView, vwRect);
              clipRect(vwRect);
              SectClipRgn(tblRgnH);
              PenNormal;
              aBandX := aView.vBandX[aKind];
              loOffP := aView.vBandX[orthKind[aKind]]^.bLoOffp;

              if shoP >= 0 then begin {we're just doing one grid}
                 aSnipX := snipXAtP(aKind, shoP);
                 aSnipX := aSnipX^.sNxtSnipX;
                 shoAGrid(aKind, shoP, aSnipX, vwRect, loOffP);
              end else begin {we're doing all the view's grids}
                {start with the grid preceding the first snip}
                 aSnipX := aBandX^.bLoSnipX;
                 while aSnipX <> nil do begin
                    gridP := aSnipX^.sLoP-1;
                    shoAGrid(aKind, gridP, aSnipX, vwRect, loOffP);
                    aSnipX := aSnipX^.sNxtSnipX;
                 end;
              end;
           end;
        end; end {shoGrid};


{******************************************************}
{$S TEwork1}

procedure ShoGridArrows {loCol: idType};
        {In every band in which the right grid of loCol is visible, show a grid
        arrow over the grid handle for this grid.  If loCol=mInfSnip, do nothing.
        If loCol= pInfSnip or nullSnip, then fatal error}
        var
           gridH, leftH, rightH: pixel;
           hiCol:                idType;
           status:               integer;
           bandRect:             rect;
           aBandX:               bandX;
        begin
{$IFC fTraceTE}    LogCall;     {$ENDC}
           if traceXTMgr then writeln('tm ShoGridArrows');
           {$ifc tmdebug}
           if (loCol = nullSnip) or (loCol = pInfSnip) then
              begin
              if  fwriteln then
               writeln('** tm/shoGridArrows: bad loCol');
              end
           else
           {$ENDC }
                if (loCol <> mInfSnip) then begin
              setPnlPort(tblPnl);
              aBandX := @loBand[colKind];
              while eachBandX(aBandX, nil) do begin
                 GetSnipId(colKind, MMNext, 0, loCol, hiCol);
                 gridH := gridPixl(loCol, hiCol, aBandX);
                 if (gridH <> -1) then begin
                    getBRect(aBandX, bandRect);
                    clipRect(bandRect);
                    sectClipRgn(tblRgnH);
                    PenNormal;
                    leftH := gridH - arrowWid div 2;
                    rightH := gridH + 1 + arrowWid div 2;
                    MoveTo(leftH, arrowV);
                    LineTo(rightH, arrowV);
                    MoveTo(leftH + arrowD[h], arrowV - arrowD[v]);
                    LineTo(leftH, arrowV);
                    LineTo(leftH + arrowD[h], arrowV + arrowD[v]);
                    MoveTo(rightH - arrowD[h], arrowV - arrowD[v]);
                    LineTo(rightH, arrowV);
                    LineTo(rightH - arrowD[h], arrowV + arrowD[v]); end; end; end;
        end;




ÿ