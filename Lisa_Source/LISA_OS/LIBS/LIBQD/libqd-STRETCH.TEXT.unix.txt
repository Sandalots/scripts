
        .INCLUDE libqd/GRAFTYPES.TEXT
;------------------------------------------------------------------
;
;  -->  STRETCH.TEXT
;

        .PROC StretchBits,8
        .REF  RgnBlt,RSect,ShieldCursor,ShowCursor
        .REF  InitRgn,SeekRgn,StretchRow,XorSlab,ColorMap
;--------------------------------------------------------------
;
;  PROCEDURE StretchBits(srcBits,dstBits: BitMap;
;                        srcRect,dstRect: Rect;
;                        mode:            INTEGER
;                        rgnA,rgnB,rgnC:  RgnHandle);
;
;  Transfer a rectangle of bits from srcBits to dstBits,
;  stretching or compressing according to srcRect and dstRect.
;  The transfer is clipped to the intersection of rgnA, rgnB, and rgnC.
;
;
;  Restrictions:
;
;     transfer mode 0..7 only.
;     if numer <> denom, then src and dst bitmaps do not overlap.
;
;
;  COPYRIGHT APPLE COMPUTER INC.
;  DESIGNED AND WRITTEN BY BILL ATKINSON
;


;----------------------------------------------------
;
;  A6 OFFSETS OF PARAMETERS AFTER LINK:
;
PARAMSIZE       .EQU    30                      ;TOTAL BYTES OF PARAMETERS
SRCBITS         .EQU    PARAMSIZE+8-4           ;LONG, ADDR OF BITMAP
DSTBITS         .EQU    SRCBITS-4               ;LONG, ADDR OF BITMAP
SRCRECT         .EQU    DSTBITS-4               ;LONG, ADDR OF RECT
DSTRECT         .EQU    SRCRECT-4               ;LONG, ADDR OF RECT
MODE            .EQU    DSTRECT-2               ;WORD
RGNA            .EQU    MODE-4                  ;RGNHANDLE
RGNB            .EQU    RGNA-4                  ;RGNHANDLE
RGNC            .EQU    RGNB-4                  ;RGNHANDLE


;-------------------------------------------------
;
;  A6 OFFSETS OF LOCAL VARIABLES AFTER LINK:
;
NUMER           .EQU    -4                      ;POINT
DENOM           .EQU    NUMER-4                 ;POINT
VERROR          .EQU    DENOM-4                 ;INTEGER
MINRECT         .EQU    VERROR-8                ;RECT
SRCBUF          .EQU    MINRECT-4               ;LONG
DSTBUF          .EQU    SRCBUF-4                ;LONG
SRCLONGS        .EQU    DSTBUF-2                ;WORD
DSTLONGS        .EQU    SRCLONGS-2              ;WORD
STATEA          .EQU    DSTLONGS-RGNREC         ;RGN STATE RECORD
STATEB          .EQU    STATEA-RGNREC           ;RGN STATE RECORD
STATEC          .EQU    STATEB-RGNREC           ;RGN STATE RECORD
SAVESTK         .EQU    STATEC-4                ;LONG
RECTFLAG        .EQU    SAVESTK-2               ;WORD
MASKBUF         .EQU    RECTFLAG-4              ;LONG
BUFLEFT         .EQU    MASKBUF-2               ;WORD
BUFSIZE         .EQU    BUFLEFT-2               ;WORD
SRCADDR         .EQU    BUFSIZE-4               ;LONG
DSTADDR         .EQU    SRCADDR-4               ;LONG
SRCROW          .EQU    DSTADDR-4               ;LONG
DSTROW          .EQU    SRCROW-4                ;LONG
SRCLIMIT        .EQU    DSTROW-4                ;LONG
VERT            .EQU    SRCLIMIT-2              ;WORD
MODECASE        .EQU    VERT-4                  ;LONG
PAT             .EQU    MODECASE-4              ;LONG, ADDR OF PAT
VARSIZE         .EQU    PAT                     ;SIZE OF LOCAL VARIABLES


        CHECKSTACK VARSIZE                      ;EXPAND STACK
        LINK    A6,#VARSIZE                     ;ALLOCATE LOCAL VARIABLES
        MOVEM.L D0-D7/A1-A4,-(SP)               ;SAVE REGS
        MOVE.L  SP,SAVESTK(A6)                  ;REMEMBER STACK FOR LATER

;----------------------------------------------------------------
;
;  CALC NUMER AND DENOM BASED ON DSTRECT AND SRCRECT.
;  IF NUMER = DENOM THEN JUST CALL RGNBLT.
;
        MOVE.L  DSTRECT(A6),A0                  ;POINT TO DSTRECT
        MOVE    BOTTOM(A0),D0
        SUB     TOP(A0),D0                      ;CALC DST HEIGHT
        SWAP    D0                              ;PUT IN HI WORD
        MOVE    RIGHT(A0),D0
        SUB     LEFT(A0),D0

        MOVE.L  SRCRECT(A6),A0                  ;POINT TO SRCRECT
        MOVE    BOTTOM(A0),D1
        SUB     TOP(A0),D1                      ;CALC SRC HEIGHT
        SWAP    D1                              ;PUT IN HI WORD
        MOVE    RIGHT(A0),D1
        SUB     LEFT(A0),D1

        CMP.L   D0,D1
        BNE.S   STRETCH
XRGNBLT MOVE.L  SRCBITS(A6),-(SP)               ;PUSH SRCBITS
        MOVE.L  DSTBITS(A6),-(SP)               ;PUSH DSTBITS
        MOVE.L  SRCRECT(A6),-(SP)               ;PUSH SRCRECT
        MOVE.L  DSTRECT(A6),-(SP)               ;PUSH DSTRECT
        MOVE    MODE(A6),-(SP)                  ;PUSH MODE
        MOVE.L  PAT(A6),-(SP)                   ;PAT ONLY USED FROM BELOW
        MOVE.L  RGNA(A6),-(SP)                  ;PUSH RGNA
        MOVE.L  RGNB(A6),-(SP)                  ;PUSH RGNB
        MOVE.L  RGNC(A6),-(SP)                  ;PUSH RGNC
        JSR     RGNBLT                          ;CALL RGNBLT
        JMP     GOHOME                          ;AND QUIT


;----------------------------------------------------------------
;
;  ADJUST MODE AND PAT FOR COLOR SEPARATION.
;
STRETCH MOVE    MODE(A6),-(SP)                  ;PUSH INPUT MODE
        MOVE.L  PAT(A6),-(SP)                   ;PUSH ADDR OF DUMMY PATTERN
        JSR     COLORMAP                        ;ALTER FOR COLOR SEPARATION
        MOVE.L  (SP)+,PAT(A6)                   ;GET (ALTERED) PATTERN
        MOVE    (SP)+,D2                        ;GET (ALTERED) MODE
        MOVE    D2,D3                           ;COPY MODE
        AND     #8,D3                           ;IS PATTERN BIT SET ?
        BNE.S   XRGNBLT                         ;YES, USE RGNBLT TO DO PAT
        MOVE    D2,MODE(A6)                     ;NO, UPDATE (ALTERED) MODE


;-------------------------------------------------------------------
;
;  CALC MINRECT = INTERSECTION OF DSTRECT, DSTBITS.BOUNDS, AND THREE
;  REGION BOUNDING BOXES.  QUIT IF THE INTERSECTION IS EMPTY.
;
        MOVE.L  D0,NUMER(A6)                    ;NUMER := DST SIZE
        MOVE.L  D1,DENOM(A6)                    ;DENOM := SRC SIZE
        MOVE.L  DSTBITS(A6),A3                  ;POINT TO DST BITMAP
        MOVE.L  DSTRECT(A6),-(SP)               ;PUSH ADDR OF DSTRECT
        PEA     BOUNDS(A3)                      ;PUSH ADDR OF DSTBITS.BOUNDS
        MOVE.L  RGNA(A6),A0                     ;GET RGNHANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        PEA     RGNBBOX(A0)                     ;PUSH RGN BBOX
        MOVE.L  RGNB(A6),A0                     ;GET RGNHANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        PEA     RGNBBOX(A0)                     ;PUSH RGN BBOX
        MOVE.L  RGNC(A6),A0                     ;GET RGNHANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        PEA     RGNBBOX(A0)                     ;PUSH RGN BBOX
        MOVE    #5,-(SP)                        ;PUSH NRECTS
        PEA     MINRECT(A6)                     ;PUSH WHERE TO PUT RESULT
        JSR     RSECT                           ;INTERSECT ALL RECTS
        BEQ     GOHOME                          ;QUIT IF RESULT IS EMPTY


;----------------------------------------------------
;
;  HIDE THE CURSOR IF IT INTERSECTS MINRECT
;
        PEA     MINRECT(A6)                     ;PUSH SHIELD RECT
        MOVE.L  BOUNDS+TOPLEFT(A3),-(SP)        ;PUSH DELTA TO CONVERT TO GLOBAL
        JSR     SHIELDCURSOR                    ;REMOVE CURSOR IF INTERSECT


;----------------------------------------------------------------
;
;  CALC NUMER AND DENOM BASED ON DSTRECT AND SRCRECT.
;
        MOVE.L  DSTRECT(A6),A0                  ;POINT TO DSTRECT
        MOVE    RIGHT(A0),D0
        SUB     LEFT(A0),D0
        MOVE    D0,NUMER+H(A6)                  ;NUMER.H := DST WIDTH
        MOVE    BOTTOM(A0),D0
        SUB     TOP(A0),D0
        MOVE    D0,NUMER+V(A6)                  ;NUMER.V := DST HEIGHT

        MOVE.L  SRCRECT(A6),A0                  ;POINT TO SRCRECT
        MOVE    RIGHT(A0),D0
        SUB     LEFT(A0),D0
        MOVE    D0,DENOM+H(A6)                  ;DENOM.H := SRC WIDTH
        MOVE    BOTTOM(A0),D0
        SUB     TOP(A0),D0
        MOVE    D0,DENOM+V(A6)                  ;DENOM.V := SRC HEIGHT


;-----------------------------------------------------------------------
;
;  ALLOCATE AND CLEAR SRCBUF TO HOLD SRCWIDTH.
;
        MOVE    DENOM+H(A6),D0                  ;GET SRC WIDTH
        SUB     #1,D0                           ;SUBTRACT 1 PIXEL
        LSR     #5,D0                           ;AND DIV BY 32 FOR LONGS
        MOVE    D0,SRCLONGS(A6)                 ;SAVE FOR LATER

;---------------------------------------------
;
;  EXPAND STACK IF NECESSARY
;
        .IF     FORMAC=0
        LSL     #2,D0                           ;QUAD FOR BYTECOUNT
        NEG     D0                              ;MAKE OFFSET NEGATIVE
        TST.W   0(SP,D0)                        ;EXPAND STACK
        MOVE    SRCLONGS(A6),D0                 ;RESTORE SRCLONGS
        .ENDC

        CLR.L   -(SP)                           ;CLEAR A LONG OF SLOP AT RIGHT
CLRSRC  CLR.L   -(SP)                           ;ALLOCATE AND CLEAR A LONG
        DBRA    D0,CLRSRC                       ;LOOP ENTIRE BUFFER
        MOVE.L  SP,SRCBUF(A6);                  ;REMEMBER WHERE SRCBUF IS


;-----------------------------------------------------------------------
;
;  ALLOCATE AND CLEAR DSTBUF TO HOLD DSTWIDTH.
;
        MOVE    NUMER+H(A6),D0                  ;GET DST WIDTH
        SUB     #1,D0                           ;SUBTRACT 1 PIXEL
        LSR     #5,D0                           ;AND DIV BY 32 FOR LONGS
        MOVE    D0,DSTLONGS(A6)                 ;SAVE FOR LATER

;---------------------------------------------
;
;  EXPAND STACK IF NECESSARY
;
        .IF     FORMAC=0
        LSL     #2,D0                           ;QUAD FOR BYTECOUNT
        NEG     D0                              ;MAKE OFFSET NEGATIVE
        TST.W   0(SP,D0)                        ;EXPAND STACK
        MOVE    DSTLONGS(A6),D0                 ;RESTORE DSTLONGS
        .ENDC

        CLR.L   -(SP)                           ;CLEAR A LONG OF SLOP AT RIGHT
        CLR.L   -(SP)                           ;CLEAR ANOTHER LONG OF SLOP
CLRDST  CLR.L   -(SP)                           ;ALLOCATE AND CLEAR A LONG
        DBRA    D0,CLRDST                       ;LOOP ENTIRE BUFFER
        MOVE.L  SP,DSTBUF(A6);                  ;REMEMBER WHERE DSTBUF IS


;--------------------------------------------------------
;
;  CALC BUFLEFT AND BUFSIZE FOR RGN SCANLINE BUFFERS
;
        MOVE.L  DSTRECT(A6),A0                  ;POINT TO DSTRECT
        MOVE    LEFT(A0),D1                     ;GET DSTRECT LEFT
        SUB     BOUNDS+LEFT(A3),D1              ;CONVERT TO GLOBAL COORDS
        AND     #$FFF0,D1                       ;TRUNC TO MULT OF 16
        ADD     BOUNDS+LEFT(A3),D1              ;CONVERT BACK TO LOCAL
        MOVE    D1,BUFLEFT(A6)                  ;SAVE AS BUFLEFT

        MOVE    MINRECT+RIGHT(A6),D0            ;GET MINRECT RIGHT
        SUB     D1,D0                           ;CALC WIDTH IN DOTS
        LSR     #5,D0                           ;DIV BY 32 FOR LONGS
        MOVE    D0,BUFSIZE(A6)                  ;BUFSIZE = # LONGS -1


;---------------------------------------------
;
;  EXPAND STACK IF NECESSARY
;
        .IF     FORMAC=0
        LSL     #2,D0                           ;QUAD FOR BYTECOUNT
        NEG     D0                              ;MAKE OFFSET NEGATIVE
        TST.W   0(SP,D0)                        ;EXPAND STACK
        MOVE    BUFSIZE(A6),D0                  ;RESTORE BUFSIZE
        .ENDC


;-----------------------------------------------------------------------
;
;  ALLOCATE AND CLEAR A SCANLINE BUFFER FOR THE COMPOSITE MASK.
;
CLRMASK CLR.L   -(SP)                           ;ALLOCATE AND CLEAR
        DBRA    D0,CLRMASK                      ;LOOP TILL DONE
        MOVE.L  SP,MASKBUF(A6);                 ;REMEMBER WHERE MASKBUF IS


;-------------------------------------------------------------------
;
;  INIT STATE RECORDS VERT0 AND VERT1 IN CASE RECTANGULAR
;
        MOVE    #-32767,STATEA+THISV(A6);
        MOVE    #-32767,STATEB+THISV(A6);
        MOVE    #-32767,STATEC+THISV(A6);
        MOVE    #32767,STATEA+NEXTV(A6);
        MOVE    #32767,STATEB+NEXTV(A6);
        MOVE    #32767,STATEC+NEXTV(A6);


;----------------------------------------------------------------------
;
;  ALLOCATE BUFFERS AND INIT STATE RECORDS FOR EACH NON-RECT REGION
;
        CLR     RECTFLAG(A6)                    ;INIT ALL 3 REGIONS RECT
        MOVE.L  RGNA(A6),A0                     ;GET RGNHANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        CMP     #10,RGNSIZE(A0)                 ;IS RGNA RECTANGULAR ?
        BEQ.S   ARECT                           ;YES, SKIP IT
        ADD     #2,RECTFLAG(A6)                 ;NO, SET UP FLAG
        LEA     STATEA(A6),A1                   ;POINT TO STATE RECORD A
        MOVE    MINRECT+LEFT(A6),D0             ;GET MINH
        MOVE    MINRECT+RIGHT(A6),D1            ;GET MAXH
        MOVE    BUFLEFT(A6),D2                  ;GET BUFLEFT
        JSR     INITRGN                         ;INIT STATE, ALLOC BUFFER
ARECT

        MOVE.L  RGNB(A6),A0                     ;GET RGNHANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        CMP     #10,RGNSIZE(A0)                 ;IS RGNB RECTANGULAR ?
        BEQ.S   BRECT                           ;YES, SKIP IT
        ADD     #4,RECTFLAG(A6)                 ;NO, BUMP FLAG
        LEA     STATEB(A6),A1                   ;POINT TO STATE RECORD B
        MOVE    MINRECT+LEFT(A6),D0             ;GET MINH
        MOVE    MINRECT+RIGHT(A6),D1            ;GET MAXH
        MOVE    BUFLEFT(A6),D2                  ;GET BUFLEFT
        JSR     INITRGN                         ;INIT STATE, ALLOC BUFFER
BRECT

        MOVE.L  RGNC(A6),A0                     ;GET RGNHANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        CMP     #10,RGNSIZE(A0)                 ;IS RGNC RECTANGULAR ?
        BEQ.S   CRECT                           ;YES, SKIP IT
        ADD     #8,RECTFLAG(A6)                 ;NO, BUMP FLAG
        LEA     STATEC(A6),A1                   ;POINT TO STATE RECORD C
        MOVE    MINRECT+LEFT(A6),D0             ;GET MINH
        MOVE    MINRECT+RIGHT(A6),D1            ;GET MAXH
        MOVE    BUFLEFT(A6),D2                  ;GET BUFLEFT
        JSR     INITRGN                         ;INIT STATE, ALLOC BUFFER
CRECT


;--------------------------------------------------------------------
;
;  IF ALL REGIONS ARE RECTANGULAR, THEN DRAW MINRECT INTO MASK BUFFER
;
        TST     RECTFLAG(A6)                    ;ARE ALL RGNS RECT ?
        BNE.S   NOTRECT                         ;NO, CONTNUE
        MOVE.L  MASKBUF(A6),A0                  ;YES, POINT TO MASK BUFFER
        MOVE    MINRECT+LEFT(A6),D3             ;SET UP LEFT
        SUB     BUFLEFT(A6),D3                  ;MAKE IT BUFFER RELATIVE
        MOVE    MINRECT+RIGHT(A6),D4            ;SET UP RIGHT
        SUB     BUFLEFT(A6),D4                  ;MAKE IT BUFFER RELATIVE
        JSR     XorSlab                         ;AND XOR BETWEEN THEM
NOTRECT


;------------------------------------------------------
;
;  SET UP INVERT FLAG IN D7 TO REFLECT MODE BIT 2
;
        CLR.L   D7                              ;SAY NOT INVERTED
        MOVE    MODE(A6),D2                     ;GET TRANSFER MODE
        BMI     DONE                            ;QUIT IF MODE NEGATIVE
        BCLR    #2,D2                           ;TEST AND CLR INVERT BIT
        BEQ.S   SETMODE                         ;SKIP IF NOT INVERTED
        NOT.L   D7                              ;INVERTED; D7 GETS ALL 1'S


;--------------------------------------------------
;
;  CALCULATE CASE JUMP FOR DIFFERENT TRANSFER MODES
;
SETMODE CMP     #7,D2                           ;IS MODE > 7 ?
        BGT     DONE                            ;YES, QUIT
        MOVE    D2,D0                           ;COPY MODE
        AND     #3,D0                           ;MASK FOR LOW BITS ONLY
        ADD     D0,D2                           ;MODIFY FOR INDEX
        LEA     MODETAB,A0                      ;POINT TO MODE TABLE
        ADD     0(A0,D2),A0                     ;GET CASE JUMP ADDRESS
        MOVE.L  A0,MODECASE(A6)                 ;SAVE FOR LATER


;------------------------------------------------
;
;  SET UP SRCROW, SRCLIMIT, SRCSHIFT, AND SRCADDR
;
        MOVE.L  SRCBITS(A6),A2                  ;POINT TO SRCBITS
        MOVE    ROWBYTES(A2),D0                 ;GET SRC ROWBYTES
        EXT.L   D0                              ;AND EXTEND TO LONG
        MOVE.L  D0,SRCROW(A6)                   ;SRCROW := SRC ROWBYTES

        MOVE    BOUNDS+BOTTOM(A2),D1            ;GET SRCBITS.BOUNDS.BOTTOM
        SUB     BOUNDS+TOP(A2),D1               ;MAKE IT GLOBAL
        MULU    D0,D1                           ;MULT BY SRC ROWBYTES
        ADD.L   BASEADDR(A2),D1                 ;ADD BASEADDR
        ADD.L   #2,D1                           ;ADJUST FOR -2(A0) SRC PICKUP
        MOVE.L  D1,SRCLIMIT(A6)                 ;SAVE RESULT AS SRCLIMIT

        MOVE.L  SRCRECT(A6),A0                  ;POINT TO SRCRECT
        MOVE    LEFT(A0),D1                     ;GET SRCRECT LEFT
        SUB     BOUNDS+LEFT(A2),D1              ;CONVERT TO SRC GLOBAL
        MOVE    D1,D5                           ;MAKE A COPY
        NEG     D5                              ;NEGATE IT AND
        AND     #$F,D5                          ;TREAT MOD 16 FOR SRCSHIFT

        MOVE    TOP(A0),D0                      ;GET SRCRECT TOP
        SUB     BOUNDS+TOP(A2),D0               ;CONVERT TO SRC GLOBAL
        MULU    ROWBYTES(A2),D0                 ;MULT BY SRC ROWBYTES
        MOVE.L  BASEADDR(A2),A0                 ;GET START OF SRC BITMAP
        ADD.L   D0,A0                           ;ADD VERTICAL OFFSET

        ADD     D5,D1                           ;ADJUST SRCLEFT FOR SRCSHIFT
        ASR     #4,D1                           ;CONVERT DOTS TO WORDS
        ADD     D1,A0                           ;ADD HORIZONTAL OFFSET
        ADD     D1,A0                           ;TWICE FOR BYTES
        MOVE.L  A0,SRCADDR(A6)                  ;SAVE AS SRCADDR


;----------------------------------------------------
;
;  CALC STARTING DSTROW, DSTSHIFT, AND DSTADDR
;
        MOVE    ROWBYTES(A3),D0                 ;GET DST ROWBYTES
        EXT.L   D0                              ;EXTEND TO LONG
        MOVE.L  D0,DSTROW(A6)                   ;DSTROW := DST ROWBYTES

        MOVE.L  DSTRECT(A6),A0
        MOVE    TOP(A0),VERT(A6)                ;INIT CURRENT VERTICAL
        MOVE    LEFT(A0),D1                     ;GET DSTRECT LEFT
        SUB     BOUNDS+LEFT(A3),D1              ;CONVERT TO GLOBAL COORDS
        MOVEQ   #$F,D6
        AND     D1,D6                           ;TREAT MOD 16 FOR SHIFTCNT

        MOVE    MINRECT+TOP(A6),D0              ;GET MINRECT TOP
        SUB     BOUNDS+TOP(A3),D0               ;CONVERT TO GLOBAL COORDS
        MULU    ROWBYTES(A3),D0                 ;MULT BY DST ROWBYTES
        MOVE.L  BASEADDR(A3),A0                 ;GET START OF DST BITMAP
        ADD.L   D0,A0                           ;ADD VERTICAL OFFSET

        ASR     #4,D1                           ;CONVERT DOTS TO WORDS
        ADD     D1,A0                           ;ADD HORIZ OFFSET
        ADD     D1,A0                           ;TWICE FOR BYTES
        MOVE.L  A0,DSTADDR(A6)                  ;SAVE AS DSTADDR


;-----------------------------------------------------
;
;  INIT ERROR TERM FOR DDA
;
        MOVE    DENOM+V(A6),D0
        LSR     #1,D0
        NEG     D0
        MOVE    D0,VERROR(A6)                  ;VERROR := -DENOM.V/2


;-----------------------------------------------------
;
;  GET FIRST SCANLINE OF SRC INTO SRCBUF
;
NEXTSRC MOVE.L  SRCADDR(A6),A0                  ;POINT TO SRC BITMAP
        CMP.L   SRCLIMIT(A6),A0                 ;IS IT EXHAUSTED ?
        BHS.S   DONE                            ;YES, QUIT
        MOVE.L  SRCBUF(A6),A1                   ;POINT TO SRCBUF
        MOVE    SRCLONGS(A6),D1                 ;GET COUNT OF LONGS
NXTSRC2 MOVE.L  -2(A0),D0                       ;GET A LONG OF SRC
        LSR.L   D5,D0                           ;ALIGN TO SRCBUF
        MOVE    D0,(A1)+                        ;PUT A WORD TO SRCBUF
        MOVE.L  (A0)+,D0                        ;GET A SECOND LONG
        LSR.L   D5,D0                           ;ALIGN TO SRCBUF
        MOVE    D0,(A1)+                        ;PUT A WORD TO SRCBUF
        DBRA    D1,NXTSRC2                      ;LOOP FOR ALL LONGS
        MOVE.L  SRCROW(A6),D2                   ;GET SRC ROWBYTES
        ADD.L   D2,SRCADDR(A6)                  ;BUMP SRC TO NEXT ROW
        MOVE    NUMER+V(A6),D0                  ;GET NUMER.V
        ADD     D0,VERROR(A6)                   ;VERROR := VERROR + NUMER.V
        BGT.S   SRCOK                           ;SKIP IF VERROR > 0


;-----------------------------------------------------
;
;  WHILE (VERROR < 0) DO MERGE OTHER SCANLINES INTO SRCBUF.
;
SRCLOOP MOVE.L  SRCADDR(A6),A0                  ;POINT TO SRC BITMAP
        CMP.L   SRCLIMIT(A6),A0                 ;IS IT EXHAUSTED ?
        BHS.S   SRCOK                           ;YES, DONT GET ANY MORE
        MOVE.L  SRCBUF(A6),A1                   ;POINT TO SRCBUF
        MOVE    SRCLONGS(A6),D1                 ;GET COUNT OF LONGS
NXTSRC3 MOVE.L  -2(A0),D0                       ;GET A LONG OF SRC
        LSR.L   D5,D0                           ;ALIGN TO SRCBUF
        OR      D0,(A1)+                        ;OR A WORD TO SRCBUF
        MOVE.L  (A0)+,D0                        ;GET A SECOND LONG
        LSR.L   D5,D0                           ;ALIGN TO SRCBUF
        OR      D0,(A1)+                        ;OR A WORD TO SRCBUF
        DBRA    D1,NXTSRC3                      ;LOOP FOR ALL LONGS
        ADD.L   D2,SRCADDR(A6)                  ;BUMP SRC TO NEXT ROW
        MOVE    NUMER+V(A6),D0                  ;GET NUMER.V
        ADD     D0,VERROR(A6)                   ;VERROR := VERROR + NUMER.V
MORESRC BLE.S   SRCLOOP                         ;LOOP WHILE VERROR <= 0
SRCOK


;----------------------------------------------------------
;
;  HORIZONTALLY STRETCH SRCBUF INTO DSTBUF
;
        MOVE.L  SRCBUF(A6),-(SP)                ;PUSH ADDR OF SRCBUF
        MOVE.L  DSTBUF(A6),-(SP)                ;PUSH ADDR OF DSTBUF
        MOVE    DSTLONGS(A6),-(SP)              ;PUSH DSTLONGS
        MOVE    NUMER+H(A6),-(SP)               ;PUSH NUMER.H
        MOVE    DENOM+H(A6),-(SP)               ;PUSH DENOM.H
        JSR     STRETCHROW                      ;STRETCH SRCBUF INTO DSTBUF


;-------------------------------------------------------
;
;  TRANSFER ONE OR MORE COPIES OF DSTBUF INTO DSTBITS
;
NXTMASK MOVE    VERT(A6),D0                     ;GET CURRENT VERT COORD
        CMP     MINRECT+TOP(A6),D0              ;IS VERT < MINV ?
        BLT.S   NODRAW                          ;YES, DON'T DRAW

        JSR     SEEKMASK                        ;MAKE MASK BUFFER CURRENT
        MOVE.L  DSTBUF(A6),A3                   ;INIT SRCPTR
        MOVE.L  DSTADDR(A6),A4                  ;INIT DSTPTR FOR ROW
        MOVE.L  MASKBUF(A6),A2                  ;INIT MASKPTR FOR ROW
        MOVE    BUFSIZE(A6),D2                  ;INIT COUNT OF LONGS
        MOVE.L  MODECASE(A6),A0                 ;GET MODE CASE JUMP
        JMP     (A0)                            ;TAKE MODE JUMP
NEXTDST MOVE.L  DSTROW(A6),D0                   ;GET DST ROWBYTES
        ADD.L   D0,DSTADDR(A6)                  ;BUMP DST TO NEXT ROW

NODRAW  ADD     #1,VERT(A6)                     ;BUMP TO NEXT VERT
        MOVE    VERT(A6),D0                     ;GET VERT
        CMP     MINRECT+BOTTOM(A6),D0           ;ARE WE AT THE LAST SCAN LINE ?
        BEQ.S   DONE                            ;YES, QUIT
        MOVE    DENOM+V(A6),D0
        SUB     D0,VERROR(A6)                   ;VERROR := VERROR - DENOM.V
        BGE     NXTMASK                         ;IF VERROR >= 0 THEN DRAW MORE
        BRA     NEXTSRC                         ;ELSE GET NEXT SRC


;-----------------------------------------------------------------
;
;  ENTIRE STRETCHBITS COMPLETE. RESTORE REGS AND STACK AND GO HOME.
;
DONE    JSR     SHOWCURSOR                      ;RESTORE CURSOR
GOHOME  MOVE.L  SAVESTK(A6),SP                  ;STRIP VARIABLE SIZED BUFFER
        MOVEM.L (SP)+,D0-D7/A1-A4               ;RESTORE REGISTERS
        UNLINK  PARAMSIZE,'STRETCHB'



;-----------------------------------------------------------
;
;  ROUTINE TO UPDATE MASK BUFFER TO CURRENT VERTICAL COORD.
;
SEEKMASK MOVE   RECTFLAG(A6),D0
         MOVE   RECTJMP(D0),D0
         JMP    RECTJMP(D0)
RECTJMP .WORD   SEEKOK-RECTJMP
        .WORD   A-RECTJMP
        .WORD   B-RECTJMP
        .WORD   AB-RECTJMP
        .WORD   C-RECTJMP
        .WORD   AC-RECTJMP
        .WORD   BC-RECTJMP
        .WORD   ABC-RECTJMP

SEEKOK  RTS                                     ;ALL 3 ARE RECT, DO NOTHING


;--------------------------------------------------------------------
;
;  ONLY REGION A IS NON RECTANGULAR.  UPDATE IT AND USE IT AS THE MASK
;
A       MOVE    VERT(A6),D0
        LEA     STATEA(A6),A1
        MOVE.L  MASKBUF(A6),SCANBUF(A1)         ;PLAY DIRECTLY INTO MASKBUF
        JSR     SEEKRGN
        RTS


;--------------------------------------------------------------------
;
;  ONLY REGION B IS NON RECTANGULAR.  UPDATE IT AND USE IT AS THE MASK
;
B       MOVE    VERT(A6),D0
        LEA     STATEB(A6),A1
        MOVE.L  MASKBUF(A6),SCANBUF(A1)         ;PLAY DIRECTLY INTO MASKBUF
        JSR     SEEKRGN
        RTS


;--------------------------------------------------------------------
;
;  ONLY REGION C IS NON RECTANGULAR.  UPDATE IT AND USE IT AS THE MASK
;
C       MOVE    VERT(A6),D0
        LEA     STATEC(A6),A1
        MOVE.L  MASKBUF(A6),SCANBUF(A1)         ;PLAY DIRECTLY INTO MASKBUF
        JSR     SEEKRGN
        RTS


;-------------------------------------------------------------------
;
;  REGIONS A AND B ARE NON-RECTANGULAR. UPDATE EACH,
;  THEN FORM INTERSECTION IN THE MASK BUFFER.
;
AB      MOVE    VERT(A6),D0
        LEA     STATEA(A6),A1
        JSR     SEEKRGN
        MOVE    D1,-(SP)                        ;REMEMBER IF RGN CHANGED
        LEA     STATEB(A6),A1
        JSR     SEEKRGN
        OR      (SP)+,D1                        ;HAS EITHER RGN CHANGED ?
        BEQ.S   ABDONE                          ;NO, WE'RE DONE
        MOVE.L  STATEA+SCANBUF(A6),A0
        MOVE.L  STATEB+SCANBUF(A6),A1
        MOVE.L  MASKBUF(A6),A2
        MOVE    BUFSIZE(A6),D1
ABLOOP  MOVE.L  (A0)+,D0
        AND.L   (A1)+,D0
        MOVE.L  D0,(A2)+
        DBRA    D1,ABLOOP
ABDONE  RTS


;-------------------------------------------------------------------
;
;  REGIONS A AND C ARE NON-RECTANGULAR. UPDATE EACH,
;  THEN FORM INTERSECTION IN THE MASK BUFFER.
;
AC      MOVE    VERT(A6),D0
        LEA     STATEA(A6),A1
        JSR     SEEKRGN
        MOVE    D1,-(SP)                        ;REMEMBER IF RGN CHANGED
        LEA     STATEC(A6),A1
        JSR     SEEKRGN
        OR      (SP)+,D1                        ;HAS EITHER RGN CHANGED ?
        BEQ.S   ACDONE                          ;NO, WE'RE DONE
        MOVE.L  STATEA+SCANBUF(A6),A0
        MOVE.L  STATEC+SCANBUF(A6),A1
        MOVE.L  MASKBUF(A6),A2
        MOVE    BUFSIZE(A6),D1
ACLOOP  MOVE.L  (A0)+,D0
        AND.L   (A1)+,D0
        MOVE.L  D0,(A2)+
        DBRA    D1,ACLOOP
ACDONE  RTS


;-------------------------------------------------------------------
;
;  REGIONS B AND C ARE NON-RECTANGULAR. UPDATE EACH,
;  THEN FORM INTERSECTION IN THE MASK BUFFER.
;
BC      MOVE    VERT(A6),D0
        LEA     STATEB(A6),A1
        JSR     SEEKRGN
        MOVE    D1,-(SP)                        ;REMEMBER IF RGN CHANGED
        LEA     STATEC(A6),A1
        JSR     SEEKRGN
        OR      (SP)+,D1                        ;HAS EITHER RGN CHANGED ?
        BEQ.S   BCDONE                          ;NO, WE'RE DONE
        MOVE.L  STATEB+SCANBUF(A6),A0
        MOVE.L  STATEC+SCANBUF(A6),A1
        MOVE.L  MASKBUF(A6),A2
        MOVE    BUFSIZE(A6),D1
BCLOOP  MOVE.L  (A0)+,D0
        AND.L   (A1)+,D0
        MOVE.L  D0,(A2)+
        DBRA    D1,BCLOOP
BCDONE  RTS


;-------------------------------------------------------------------
;
;  REGIONS A, B AND C ARE ALL NON-RECTANGULAR. UPDATE EACH,
;  THEN FORM INTERSECTION IN THE MASK BUFFER.
;
ABC     MOVE    VERT(A6),D0
        LEA     STATEA(A6),A1
        JSR     SEEKRGN
        MOVE    D1,-(SP)                        ;REMEMBER IF RGN CHANGED
        LEA     STATEB(A6),A1
        JSR     SEEKRGN
        OR      D1,(SP)                         ;REMEMBER IF RGN CHANGED
        LEA     STATEC(A6),A1
        JSR     SEEKRGN
        OR      (SP)+,D1                        ;HAS EITHER RGN CHANGED ?
        BEQ.S   ABCDONE                         ;NO, WE'RE DONE
        MOVE.L  STATEA+SCANBUF(A6),A0
        MOVE.L  STATEB+SCANBUF(A6),A1
        MOVE.L  STATEC+SCANBUF(A6),A2
        MOVE.L  MASKBUF(A6),A3
        MOVE    BUFSIZE(A6),D1
ABCLOOP MOVE.L  (A0)+,D0
        AND.L   (A1)+,D0
        AND.L   (A2)+,D0
        MOVE.L  D0,(A3)+
        DBRA    D1,ABCLOOP
ABCDONE RTS




;---------------------------------------------------------------;
;                                                               ;
;  INTERFACE TO EACH OF THE STRETCHBITS SCANLINE LOOPS:         ;
;                                                               ;
;  REGISTERS:   A0:                     D0:                     ;
;               A1:                     D1:                     ;
;               A2: MASKPTR             D2: LONGCNT             ;
;               A3: SRCPTR              D3:                     ;
;               A2: DSTPTR              D4:                     ;
;               A4:                     D5: SRCSHIFT            ;
;               A6:                     D6: DSTSHIFT            ;
;               A7:                     D7: INVERT              ;
;                                                               ;
;---------------------------------------------------------------;

MODETAB .WORD    MASK0-MODETAB
        .WORD    MASK1-MODETAB
        .WORD    MASK2-MODETAB
        .WORD    MASK3-MODETAB


;-------------------------------------------------------
;
;  MODE 0 OR 4: SRC --> DST
;
MASK0   MOVE.L  -2(A3),D0       ;GET SRC FROM BITMAP
        LSR.L   D6,D0           ;ALIGN TO DST
        SWAP    D0              ;PUT INTO HI HALF OF D0
        MOVE.L  (A3)+,D1        ;GET SRC FROM BITMAP AND BUMP RIGHT
        LSR.L   D6,D1           ;ALIGN TO DST
        MOVE    D1,D0           ;ASSEMBLE ONE LONG
        EOR.L   D7,D0           ;INVERT SRC IF MODE BIT 2 SET
        MOVE.L  (A2)+,D1        ;GET MASK
        AND.L   D1,D0           ;MASK SRC
        NOT.L   D1              ;FORM NOTMASK
        AND.L   (A4),D1         ;GET DST DATA
        OR.L    D1,D0           ;MERGE WITH SRC DATA
        MOVE.L  D0,(A4)+        ;PUT RESULT IN DST
        DBRA    D2,MASK0        ;LOOP ALL LONGS THIS ROW
        BRA     NEXTDST         ;GO FOR NEXT ROW


;-------------------------------------------------------
;
;  MODE 1 OR 5: SRC OR DST --> DST
;
MASK1   MOVE.L  -2(A3),D0       ;GET SRC FROM BITMAP
        LSR.L   D6,D0           ;ALIGN TO DST
        SWAP    D0              ;PUT INTO HI HALF OF D0
        MOVE.L  (A3)+,D1        ;GET SRC FROM BITMAP
        LSR.L   D6,D1           ;ALIGN TO DST
        MOVE    D1,D0           ;ASSEMBLE ONE LONG
        EOR.L   D7,D0           ;INVERT SRC IF MODE BIT 2 SET
        AND.L   (A2)+,D0        ;AND WITH MASK
        OR.L    D0,(A4)+        ;OR RESULT INTO DST
        DBRA    D2,MASK1        ;LOOP ALL LONGS THIS ROW
        BRA     NEXTDST         ;LOOP FOR NEXT ROW


;-------------------------------------------------------
;
;  MODE 2 OR 6: SRC XOR DST --> DST
;
MASK2   MOVE.L  -2(A3),D0       ;GET SRC FROM BITMAP
        LSR.L   D6,D0           ;ALIGN TO DST
        SWAP    D0              ;PUT INTO HI HALF OF D0
        MOVE.L  (A3)+,D1        ;GET SRC FROM BITMAP
        LSR.L   D6,D1           ;ALIGN TO DST
        MOVE    D1,D0           ;ASSEMBLE ONE LONG
        EOR.L   D7,D0           ;INVERT SRC IF MODE BIT 2 SET
        AND.L   (A2)+,D0        ;AND WITH MASK
        EOR.L   D0,(A4)+        ;XOR RESULT INTO DST
        DBRA    D2,MASK2        ;LOOP ALL LONGS THIS ROW
        BRA     NEXTDST         ;LOOP FOR NEXT ROW


;-------------------------------------------------------
;
;  MODE 3 OR 7: SRC BIC DST --> DST
;
MASK3   MOVE.L  -2(A3),D0       ;GET SRC FROM BITMAP
        LSR.L   D6,D0           ;ALIGN TO DST
        SWAP    D0              ;PUT INTO HI HALF OF D0
        MOVE.L  (A3)+,D1        ;GET SRC FROM BITMAP
        LSR.L   D6,D1           ;ALIGN TO DST
        MOVE    D1,D0           ;ASSEMBLE ONE LONG
        EOR.L   D7,D0           ;INVERT SRC IF MODE BIT 2 SET
        AND.L   (A2)+,D0        ;AND WITH MASK
        NOT.L   D0              ;INVERT FOR BIC
        AND.L   D0,(A4)+        ;BIC RESULT INTO DST
        DBRA    D2,MASK3        ;LOOP ALL LONGS THIS ROW
        BRA     NEXTDST         ;LOOP FOR NEXT ROW



        .PROC XorSlab
        .REF  LeftMask,RightMask
;-----------------------------------------------------------
;
;  LOCAL PROCEDURE XorSlab(bufAddr: Ptr; left,right: INTEGER);
;
;  Enter with:
;
;       A0:  bufAddr
;       D3:  left coord
;       D4:  right coord
;
;  Clobbers:
;
;       A0,D0,D1,D2,D3,D4,D5,D6
;

        FAKEHEAD
;------------------------------------------
;
;  GET LEFTMASK AND RIGHTMASK
;
        MOVE    D3,D0                           ;GET LEFT COORD
        JSR     LEFTMASK                        ;GET LEFTMASK
        MOVE    D0,D5                           ;PUT LEFTMASK IN D5
        MOVE    D4,D0                           ;GET RIGHT COORD
        JSR     RIGHTMASK                       ;GET RIGHTMASK
        MOVE    D0,D6                           ;PUT RIGHTMASK IN D6


;------------------------------------------
;
;  CALC LEFTWORD, BUFPTR, WORDCOUNT
;
        ASR     #4,D3                           ;CONVERT DOTS TO WORDS
        ADD     D3,A0                           ;ADD TO BUFSTART
        ADD     D3,A0                           ;TWICE FOR BYTE OFFSET
        ASR     #4,D4                           ;CALC RIGHT DIV 16
        SUB     D3,D4                           ;WORDCOUNT:=RIGHTWORD-LEFTWORD
        BGT.S   NOTIN1                          ;BR IF NOT ALL IN ONE


;------------------------------------------
;
;  LEFT AND RIGHT ARE ALL IN ONE WORD
;
        AND     D5,D6                           ;COMBINE LEFT AND RIGHT MASKS
        EOR     D6,(A0)                         ;XOR COMBINATION INTO BUFFER
        RTS


;------------------------------------------
;
;  NOT ALL IN ONE WORD.  DO LEFT, MIDDLE IF ANY, THEN RIGHT
;
NOTIN1  EOR     D5,(A0)+                        ;XOR LEFTMASK INTO BUFFER
        BRA.S   TEST                            ;SEE IF ANY FULL WORDS
INVLONG NOT.L   (A0)+                           ;INVERT 2 WHOLE WORDS
TEST    SUBQ    #2,D4                           ;ANY FULL WORDS LEFT ?
        BGT     INVLONG                         ;YES, AT LEAST 2
        BLT.S   ENDWORD                         ;NO, FINISH UP LAST WITH MASK
        NOT     (A0)+                           ;YES, DO LAST FULL WORD
ENDWORD EOR     D6,(A0)                         ;XOR RIGHTMASK INTO BUFFER
        RTS
        FAKETAIL 'XORSLAB '




        .PROC StretchRow,6
;--------------------------------------------------------------
;
;  PROCEDURE StretchRow(srcPtr,dstPtr:  Ptr;
;                       dstLongs:       INTEGER;
;                       numer,denom:    INTEGER);
;
;  STRETCH OR SHRINK A HORIZONTAL SCAN LINE
;  FROM ONE SCANLINE BUFFER INTO ANOTHER
;
;  D0: SRC DATA                 A0:  SRCPTR
;  D1: DST DATA                 A1:  DSTPTR
;  D2: HERROR                   A2:
;  D3: NUMER                    A3:  DSTLIMIT
;  D4: DENOM                    A4:
;  D5: DSTBIT                   A5:
;  D6: SHIFTCNT                 A6:  LOCALS
;  D7: TOPMASK, SCALE           A7:  STACK PTR
;
;  CLOBBERS ONLY A0.
;
;  A6 OFFSETS OF PARAMETERS AFTER LINK:
;
PARAMSIZE       .EQU    14                      ;TOTAL BYTES OF PARAMS
SRCPTR          .EQU    PARAMSIZE+8-4           ;LONG
DSTPTR          .EQU    SRCPTR-4                ;LONG
DSTLONGS        .EQU    DSTPTR-2                ;WORD
NUMER           .EQU    DSTLONGS-2              ;WORD
DENOM           .EQU    NUMER-2                 ;WORD


        LINK    A6,#0                           ;NO LOCALS
        MOVEM.L D0-D7/A1-A4,-(SP)               ;SAVE REGISTERS
        MOVE    NUMER(A6),D3                    ;GET NUMERATOR
        BEQ     DONE                            ;OOPS !
        MOVE    DENOM(A6),D4                    ;GET DENOMINATOR
        BEQ     DONE                            ;OOPS !
        MOVE.L  SRCPTR(A6),A0                   ;GET SRCPTR
        MOVE.L  DSTPTR(A6),A1                   ;GET DSTPTR
        MOVE    DSTLONGS(A6),D0                 ;GET DSTLONGS
        ADD     #1,D0
        LSL     #2,D0                           ;QUAD FOR BYTE OFFSET
        MOVE.L  A1,A3
        ADD     D0,A3                           ;SET UP DSTLIMIT
        MOVE    D3,D0                           ;GET NUMERATOR
        SUB     D4,D0                           ;SUBTRACT DENOMINATOR
        BNE.S   NOTSAME                         ;BR IF NOT SAME

;-----------------------------------------------
;
;  NUMERATOR = DENOMINATOR, JUST COPY LONGS
;
COPY    MOVE.L  (A0)+,(A1)+                     ;COPY ONE LONG
        MOVE.L  (A0)+,(A1)+                     ;COPY ANOTHER LONG
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     COPY                            ;NO, LOOP FOR MORE
        BRA     DONE                            ;ALL DONE
NOTSAME BGT     STRETCH                         ;NUMERATOR BIGGER, STRETCH


;----------------------------------------------------------
;
;  WE WILL BE SHRINKING.  CHECK FOR FAST MULTIPLES.
;
        .IF     FORMAC<>9
;
;  MACINTOSH VERSION OPTIMIZES ONLY  1/3
;
SHRINK  ADD     D3,D0
        ADD     D3,D0
        BEQ.S   THIRD                           ;SHRINK TO ONE THIRD
        BRA     RATIO                           ;ELSE USE FULL RATIO SCALING


        .ELSE
;
;  LISA VERSION OPTIMIZES  3/4, 2/3, 1/2, 3/8, 1/3, 1/4, 1/8
;
SHRINK  ADD     D3,D0
        BEQ     HALF                            ;SHRINK TO HALF
        ADD     D3,D0
        BEQ     THIRD                           ;SHRINK TO ONE THIRD
        CMP     D4,D0
        BEQ.S   TWO3RDS                         ;SHRINK TO TWO THIRDS
        ADD     D3,D0
        BEQ     QRTR                            ;SHRINK TO ONE QUARTER
        SUB     D4,D0
        SUB     D4,D0
        BEQ.S   THREE4                          ;SHRINK TO THREE FOURTHS
        ADD     D3,D0
        ADD     D3,D0
        ADD     D3,D0
        ADD     D3,D0
        BEQ     THREE8                          ;SHRINK TO THREE EIGHTHS
        ADD     D4,D0
        ADD     D4,D0
        BEQ     EIGHTH                          ;SHRINK TO ONE EIGHTH
        BRA     RATIO                           ;ELSE USE FULL RATIO SCALING


;---------------------------------------------------
;
;  SHRINK TO THREE QUARTERS.
;
THREE4  MOVE.L  #$C0000000,D7                   ;MASK FOR HI 2 BITS
        CLR.L   -(SP)                           ;ALLOCATE A LONG OF TEMP
THREE4A MOVE.L  (A0)+,D0                        ;GET A LONG OF SRC
        MOVEQ   #7,D2                           ;INIT COUNT OF 24 DST BITS
THREE4B ADD.L   D0,D0                           ;GET 1 BIT OF SRC
        ADDX.L  D1,D1                           ;PUT 1 BIT TO DST
        ADD.L   D7,D0                           ;PUT HI 2 BITS INTO CARRY
        ADDX.L  D1,D1                           ;SHIFT INTO DST
        LSL.L   #3,D0                           ;SHIFT LEFT 3 BITS
        ADDX.L  D1,D1                           ;PUT CARRY BIT INTO DST
        DBRA    D2,THREE4B                      ;LOOP 8 TIMES
        MOVE.L  D1,(SP)                         ;STASH 3 DST BYTES IN TEMP
        MOVE.B  1(SP),(A1)+                     ;PUT FIRST BYTE TO DST
        MOVE.B  2(SP),(A1)+                     ;PUT SECOND BYTE TO DST
        MOVE.B  3(SP),(A1)+                     ;PUT THIRD BYTE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     THREE4A                         ;NO, CONTINUE
        ADD     #4,SP                           ;YES, STRIP TEMP
        BRA     DONE                            ;AND QUIT


;---------------------------------------------------
;
;  SHRINK TO TWO THIRDS.
;
TWO3RDS MOVE.L  #$C0000000,D7                   ;MASK FOR HI 2 BITS
TWO3RD1 MOVE.B  (A0)+,D0                        ;GET A BYTE OF SRC
        LSL.L   #8,D0                           ;ASSEMBLE 3 BYTES OF SRC
        MOVE.B  (A0)+,D0
        LSL.L   #8,D0                           ;INTO A LONG REGISTER
        MOVE.B  (A0)+,D0
        LSL.L   #8,D0
        MOVEQ   #7,D2                           ;INIT COUNT OF 16 DST BITS
TWO3RD2 ADD.L   D7,D0                           ;PUT HI 2 BITS INTO CARRY
        ADDX    D1,D1                           ;SHIFT INTO DST
        LSL.L   #3,D0                           ;SHIFT LEFT 3 BITS
        ADDX    D1,D1                           ;PUT CARRY BIT INTO DST
        DBRA    D2,TWO3RD2                      ;LOOP 8 TIMES
        MOVE    D1,(A1)+                        ;THEN PUT A WORD TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     TWO3RD1                         ;NO, CONTINUE
        BRA     DONE                            ;YES, QUIT


;---------------------------------------------------
;
;  SHRINK TO ONE HALF.
;
HALF    MOVE.L  #$C0000000,D7                   ;MASK FOR HI 2 BITS
HALF1   MOVE.L  (A0)+,D0                        ;GET A LONG OF SRC
        MOVEQ   #7,D2                           ;INIT COUNT OF 16 DST BITS
HALF2   ADD.L   D7,D0                           ;PUT OR OF HI BITS INTO CARRY
        ADDX    D1,D1                           ;SHIFT BIT INTO DST
        LSL.L   #2,D0                           ;SHIFT LEFT 2 BITS
        ADD.L   D7,D0                           ;PUT OR OF HI BITS INTO CARRY
        ADDX.L  D1,D1                           ;SHIFT BIT INTO DST
        LSL.L   #2,D0                           ;SHIFT LEFT 2 BITS
        DBRA    D2,HALF2                        ;LOOP 8 TIMES
        MOVE    D1,(A1)+                        ;THEN PUT A WORD TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     HALF1                           ;NO, CONTINUE
        BRA     DONE                            ;YES, QUIT


;---------------------------------------------------
;
;  SHRINK TO THREE EIGHTHS.
;
THREE8  CLR.L   -(SP)                           ;ALLOCATE A LONG OF TEMP
THREE8A MOVEQ   #7,D2                           ;INIT COUNT OF 8 SRC BYTES
THREE8B MOVE.B  (A0)+,D0                        ;GET A BYTE OF SRC
        ADD.B   #$C0,D0                         ;GET OR OF HI 2 BITS IN CARRY
        ADDX.L  D1,D1                           ;PUT ONE BIT TO DST
        LSL.B   #2,D0                           ;CLEAN OUT THE 2 BITS
        ADD.B    #$E0,D0                        ;GET OR OF HI 3 BITS IN CARRY
        ADDX.L  D1,D1                           ;PUT ONE BIT TO DST
        LSL.B   #3,D0                           ;CLEAN OUT THE 3 BITS
        ADD.B    #$E0,D0                        ;GET OR OF HI 3 BITS IN CARRY
        ADDX.L  D1,D1                           ;PUT ONE BIT TO DST
        DBRA    D2,THREE8B                      ;LOOP FOR 8 BYTES OF SRC
        MOVE.L  D1,(SP)                         ;STASH 3 DST BYTES IN TEMP
        MOVE.B  1(SP),(A1)+                     ;PUT FIRST BYTE TO DST
        MOVE.B  2(SP),(A1)+                     ;PUT SECOND BYTE TO DST
        MOVE.B  3(SP),(A1)+                     ;PUT THIRD BYTE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     THREE8A                         ;NO, CONTINUE
        ADD     #4,SP                           ;YES, STRIP TEMP
        BRA     DONE                            ;AND QUIT


;---------------------------------------------------
;
;  SHRINK TO ONE QUARTER.
;
QRTR    MOVE.L  #$F0000000,D7                   ;MASK FOR HI 4 BITS
QRTR1   MOVE.L  (A0)+,D0                        ;GET A LONG OF SRC
        MOVEQ   #7,D2                           ;INIT COUNT OF 16 DST BITS
QRTR2   ADD.L   D7,D0                           ;PUT OR OF HI BITS INTO CARRY
        ADDX.L  D1,D1                           ;SHIFT BIT INTO DST
        LSL.L   #4,D0                           ;SHIFT LEFT 4 BITS
        DBRA    D2,QRTR2                        ;LOOP 8 TIMES
        MOVE.B  D1,(A1)+                        ;THEN PUT A BYTE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     QRTR1                           ;NO, CONTINUE
        BRA     DONE                            ;YES, QUIT


;--------------------------------------------------
;
;  SHRINK TO ONE EIGHTH.  (ENTER WITH D0=0)
;
EIGHTH  MOVEQ   #-1,D3                          ;GET SOME ONES
EIGHTH1 MOVEQ   #7,D2                           ;INIT COUNT OF 8 DST BITS
EIGHTH2 MOVE.B  (A0)+,D0                        ;GET A BYTE OF SRC
        ADD.B   D3,D0                           ;SET CARRY IF SRC NON-ZERO
        ADDX    D1,D1                           ;SHIFT BIT INTO DST
        DBRA    D2,EIGHTH2                      ;REPEAT 8 TIMES
        MOVE.B  D1,(A1)+                        ;PUT A BYTE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     EIGHTH1                         ;NO, CONTINUE
        BRA     DONE                            ;YES, QUIT


        .ENDC                                   ;END OF LISA CONDITIONAL ASSY


;---------------------------------------------------
;
;  SHRINK TO ONE THIRD.
;
THIRD   MOVE.L  #$E0000000,D7                   ;MASK FOR HI 3 BITS
THIRD1  MOVE.B  (A0)+,D0                        ;GET A BYTE OF SRC
        LSL.L   #8,D0                           ;ASSEMBLE 3 BYTES OF SRC
        MOVE.B  (A0)+,D0
        LSL.L   #8,D0                           ;INTO A LONG REGISTER
        MOVE.B  (A0)+,D0
        LSL.L   #8,D0
        MOVEQ   #7,D2                           ;INIT COUNT OF 8 DST BITS
THIRD2  ADD.L   D7,D0                           ;PUT OR OF HI BITS INTO CARRY
        ADDX    D1,D1                           ;SHIFT BIT INTO DST
        LSL.L   #3,D0                           ;SHIFT LEFT 3 BITS
        DBRA    D2,THIRD2                       ;LOOP 8 TIMES
        MOVE.B  D1,(A1)+                        ;THEN PUT A BYTE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     THIRD1                          ;NO, CONTINUE
        BRA     DONE                            ;YES, QUIT


;----------------------------------------------------------
;
;  WE WILL BE STRETCHING.  CHECK FOR FAST MULTIPLES.
;

        .IF     FORMAC<>9
;
;  MACINTOSH VERSION OPTIMIZES ONLY 2x
;
STRETCH SUB     D4,D0
        BEQ     DOUBLE                          ;STRETCH TO DOUBLE
        BRA     RATIO                           ;ELSE USE FULL RATIO


        .ELSE
;
;  LISA VERSION OPTIMIZES 1.5, 2x, 3x, 4x, 6x, 8x, 16x, any mult of 8
;
STRETCH SUB     D4,D0
        BEQ     DOUBLE                          ;STRETCH TO DOUBLE
        SUB     D4,D0
        BEQ     TRIPLE                          ;STRETCH TO TRIPLE
        ADD     D3,D0
        BEQ     ONE.5                           ;STRECH ONE AND A HALF
        SUB     D4,D0
        SUB     D3,D0
        BEQ     QUAD                            ;STRETCH TO QUADRUPLE
        ADD     D4,D4                           ;CALC 2*DENOM
        SUB     D4,D0
        BEQ     SIX                             ;STRETCH TIMES SIX
        SUB     D4,D0
        BEQ     EIGHT                           ;STRETCH TIMES 8
        LSL     #2,D4                           ;CALC 8*DENOM
        SUB     D4,D0
        BEQ     SIXTEEN                         ;STRETCH TIMES 16

        MOVE    DENOM(A6),D4                    ;GET DENOMINATOR AGAIN
        MOVE    D3,D0                           ;COPY NUMERATOR
        EXT.L   D0                              ;CLEAR HI WORD
        DIVS    D4,D0                           ;CALC NUMER DIV DENOM
        MOVE    D0,D7                           ;SAVE QUOTIENT
        AND.L   #$FFFF0007,D0                   ;IS SCALE AN EVEN MULT OF 8 ?
        BEQ     EIGHTS                          ;YES, GO TO IT
        BRA     RATIO                           ;NO, DO SLOW RATIO SCALING


;-----------------------------------------------
;
;  STRETCH TO 1.5 TIMES AS WIDE
;
ONE.5   MOVE.B  (A0)+,D0                        ;GET FIRST BYTE FROM SRC
        MOVE    D0,D1                           ;MAKE AN EXTRA COPY
        LSR.B   #4,D1                           ;GET HI NIBBLE
        MOVE.B  TABLE15(D1),D2                  ;EXPAND TO 6 BITS
        LSL.L   #6,D2                           ;SHIFT OVER 6
        AND     #$F,D0                          ;GET LO NIBBLE
        MOVE.B  TABLE15(D0),D2                  ;EXPAND TO 6 BITS
        LSL.L   #6,D2                           ;SHIFT OVER 6
        MOVE.B  (A0)+,D0                        ;GET SECOND BYTE FROM SRC
        MOVE    D0,D1                           ;MAKE AN EXTRA COPY
        LSR.B   #4,D1                           ;GET HI NIBBLE
        MOVE.B  TABLE15(D1),D2                  ;EXPAND TO 6 BITS
        LSL.L   #6,D2                           ;SHIFT OVER 6
        AND     #$F,D0                          ;GET LO NIBBLE
        MOVE.B  TABLE15(D0),D2                  ;EXPAND TO 6 BITS
        LSR.L   #2,D2                           ;RIGHT JUSTIFY
        SWAP    D2                              ;FLIP WORDS
        MOVE.B  D2,(A1)+                        ;PUT FIRST BYTE TO DST
        SWAP    D2                              ;FLIP BACK AGAIN
        MOVE    D2,D1
        ROR     #8,D1
        MOVE.B  D1,(A1)+                        ;PUT SECOND BYTE TO DST
        MOVE.B  D2,(A1)+                        ;PUT THIRD BYTE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     ONE.5                           ;NO, LOOP FOR MORE
        BRA     DONE                            ;ALL DONE

TABLE15 .BYTE   $00,$0C,$10,$1C                 ;1.5 TIMES TABLE
        .BYTE   $60,$6C,$70,$7C
        .BYTE   $80,$8C,$90,$9C
        .BYTE   $E0,$EC,$F0,$FC


;-----------------------------------------------
;
;  TRIPLE USING TABLE LOOKUP
;
TRIPLE  MOVE.B  (A0)+,D0                        ;GET A BYTE FROM SRC
        MOVE    D0,D1                           ;MAKE AN EXTRA COPY
        MOVE    D0,D2                           ;MAKE A THIRD COPY
        LSR.B   #5,D2                           ;GET 3 HI BITS
        MOVE.B  TABLE3A(D2),(A1)+               ;PUT FIRST BYTE TO DST
        LSR.B   #2,D1
        AND     #$F,D1                          ;GET MIDDLE 4 BITS
        MOVE.B  TABLE3B(D1),(A1)+               ;PUT SECOND BYTE TO DST
        AND     #$7,D0                          ;GET 3 LO BITS
        MOVE.B  TABLE3C(D0),(A1)+               ;PUT THIRD BYTE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     TRIPLE                          ;NO, LOOP FOR MORE
        BRA     DONE                            ;ALL DONE

TABLE3A .BYTE   $00,$03,$1C,$1F                 ;TRIPLING TABLE
        .BYTE   $E0,$E3,$FC,$FF
TABLE3B .BYTE   $00,$01,$0E,$0F
        .BYTE   $70,$71,$7E,$7F
        .BYTE   $80,$81,$8E,$8F
        .BYTE   $F0,$F1,$FE,$FF
TABLE3C .BYTE   $00,$07,$38,$3F
        .BYTE   $C0,$C7,$F8,$FF



;-----------------------------------------------
;
;  QUADRUPLE USING TABLE LOOKUP
;
QUAD    MOVE.B  (A0)+,D0                        ;GET A BYTE FROM SRC
        MOVE    D0,D1                           ;MAKE AN EXTRA COPY
        AND     #$F0,D1                         ;MASK FOR HI NIBBLE
        LSR     #3,D1                           ;SHIFT FOR TABLE INDEX
        MOVE.W  TABLE4(D1),(A1)+                ;PUT FIRST WORD TO DST
        AND     #$F,D0                          ;MASK FOR LO NIBBLE
        ADD     D0,D0                           ;DOUBLE FOR TABLE INDEX
        MOVE.W  TABLE4(D0),(A1)+                ;PUT SECOND WORD TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     QUAD                            ;NO, LOOP FOR MORE
        BRA     DONE                            ;ALL DONE

TABLE4  .WORD   $0000,$000F,$00F0,$00FF         ;QUADRUPLING TABLE
        .WORD   $0F00,$0F0F,$0FF0,$0FFF
        .WORD   $F000,$F00F,$F0F0,$F0FF
        .WORD   $FF00,$FF0F,$FFF0,$FFFF

;-----------------------------------------------
;
;  STRETCH BY SIX USING TABLE LOOKUP
;
SIX     MOVE.B  (A0)+,D0                        ;GET A BYTE FROM SRC
        MOVE    D0,D1                           ;MAKE AN EXTRA COPY
        AND     #$E0,D1                         ;MASK FOR HI 3 BITS
        LSR.B   #4,D1                           ;SHIFT FOR TABLE INDEX
        MOVE.W  TABLE6A(D1),(A1)+               ;PUT A WORD TO DST
        MOVE    D0,D1                           ;GET SRC BYTE AGAIN
        AND     #$3C,D1                         ;MASK FOR MIDDLE 4 BITS
        LSR.B   #1,D1                           ;SHIFT FOR TABLE INDEX
        MOVE.W  TABLE6B(D1),(A1)+               ;PUT A WORD TO DST
        MOVE    D0,D1                           ;GET SRC BYTE AGAIN
        AND     #7,D1                           ;MASK FOR LO 3 BITS
        ADD     D1,D1                           ;DOUBLE FOR TABLE INDEX
        MOVE.W  TABLE6C(D1),(A1)+               ;PUT A WORD TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     SIX                             ;NO, LOOP FOR MORE
        BRA     DONE                            ;ALL DONE

TABLE6A .WORD   $0000,$000F,$03F0,$03FF         ;SIX TIMES TABLE
        .WORD   $FC00,$FC0F,$FFF0,$FFFF
TABLE6B .WORD   $0000,$0003,$00FC,$00FF
        .WORD   $3F00,$3F03,$3FFC,$3FFF
        .WORD   $C000,$C003,$C0FC,$C0FF
        .WORD   $FF00,$FF03,$FFFC,$FFFF
TABLE6C .WORD   $0000,$003F,$0FC0,$0FFF
        .WORD   $F000,$F03F,$FFC0,$FFFF



;-----------------------------------------------
;
;  SCALE UP BY EIGHT USING TABLE LOOKUP
;
EIGHT   MOVE.B  (A0)+,D0                        ;GET A BYTE OF SRC
        MOVE    D0,D1                           ;MAKE AN EXTRA COPY
        AND     #$F0,D1                         ;MASK FOR HI NIBBLE
        LSR     #2,D1                           ;SHIFT FOR TABLE INDEX
        MOVE.L  TABLE8(D1),(A1)+                ;PUT FIRST LONG TO DST
        AND     #$0F,D0                         ;MASK FOR LO NIBBLE
        LSL     #2,D0                           ;SHIFT FOR TABLE INDEX
        MOVE.L  TABLE8(D0),(A1)+                ;PUT SECOND LONG TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     EIGHT                           ;NO, GO FOR MORE
        BRA     DONE                            ;THEN QUIT

TABLE8  .LONG   $00000000,$000000FF,$0000FF00,$0000FFFF
        .LONG   $00FF0000,$00FF00FF,$00FFFF00,$00FFFFFF
        .LONG   $FF000000,$FF0000FF,$FF00FF00,$FF00FFFF
        .LONG   $FFFF0000,$FFFF00FF,$FFFFFF00,$FFFFFFFF


;-------------------------------------------------
;
;  SCALE UP BY 16
;
SIXTEEN MOVEQ   #-1,D1                          ;GET SOME BLACK
        MOVE.L  #$80000000,D0                   ;INIT SRC DATA
SIXTENA ADD.L   D0,D0                           ;GET ONE BIT OF SRC
        BCC.S   WHITE16                         ;BR IF WHITE
        BNE.S   BLACK16                         ;BR IF BLACK
        MOVE.L  (A0)+,D0                        ;ELSE GET NEXT LONG
        ADDX.L  D0,D0                           ;SHIFT SRC BIT OUT, 1 BIT IN
        BCS.S   BLACK16                         ;BR IF BLACK
WHITE16 CLR.W   (A1)+                           ;PUT A WORD OF WHITE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     SIXTENA                         ;NO, GO FOR MORE
        BRA     DONE                            ;THEN QUIT
BLACK16 MOVE    D1,(A1)+                        ;PUT A WORD OF BLACK TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     SIXTENA                         ;NO, GO FOR MORE
        BRA     DONE                            ;THEN QUIT


;-----------------------------------------------
;
;  SCALE UP BY ANY MULTIPLE OF 8 GREATER THAN 2
;
EIGHTS  LSR     #3,D7                           ;DIVIDE SCALE FACTOR BY 8
        SUB     #1,D7                           ;SUB 1 FOR LOOP COUNT
        MOVE.L  #$80000000,D0                   ;INIT SRC DATA
EIGHTS1 ADD.L   D0,D0                           ;GET ONE SRC BIT IN CARRY
        BNE.S   EIGHTS2                         ;TIME FOR NEW SRC ?
        MOVE.L  (A0)+,D0                        ;YES, GET NEXT SRC LONG
        ADDX.L  D0,D0                           ;SHIFT SRC BIT OUT, 1 BIT IN
EIGHTS2 SCS     D1                              ;SET OR CLR A BYTE
        MOVE    D7,D2                           ;INIT LOOP COUNT
EIGHTS3 MOVE.B  D1,(A1)+                        ;PUT ONE BYTE TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        DBHI    D2,EIGHTS3                      ;LOOP TILL SCALE OR DST FULL
        BLS     EIGHTS1                         ;MORE SRC IF DST NOT FULL
        BRA     DONE                            ;THEN QUIT



        .ENDC                                   ;END OF LISA CONDITIONAL ASSY


;-----------------------------------------------
;
;  DOUBLE USING TABLE LOOKUP
;
DOUBLE  MOVE.B  (A0)+,D0                        ;GET A BYTE FROM SRC
        MOVE    D0,D1                           ;MAKE AN EXTRA COPY
        LSR.B   #4,D1                           ;GET HI NIBBLE
        MOVE.B  TABLE2(D1),(A1)+                ;DOUBLE FOR A BYTE
        AND     #$F,D0                          ;GET LO NIBBLE
        MOVE.B  TABLE2(D0),(A1)+                ;DOUBLE FOR A BYTE
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BLO     DOUBLE                          ;NO, LOOP FOR MORE
        BRA     DONE                            ;ALL DONE

TABLE2  .BYTE   $00,$03,$0C,$0F                 ;DOUBLING TABLE
        .BYTE   $30,$33,$3C,$3F
        .BYTE   $C0,$C3,$CC,$CF
        .BYTE   $F0,$F3,$FC,$FF


;------------------------------------------------------------------
;
;  DO FULL RATIO SCALING, EXPANDING OR SHRINKING ONE BIT AT A TIME
;
RATIO   MOVE.L  #$80000000,D0                   ;INIT SRC LONG
        MOVEQ   #1,D1                           ;INIT DST LONG
        MOVE    D4,D2                           ;GET DENOM
        LSR     #1,D2
        NEG     D2                              ;HERROR := -DENOM/2

SRCBIT  ADD.L   D0,D0                           ;GET ONE BIT FROM SRC
        BCC.S   WHITE1                          ;BR IF WHITE
        BNE.S   BLACK1                          ;BR IF BLACK
        MOVE.L  (A0)+,D0                        ;ELSE GET NEXT SRC LONG
        ADDX.L  D0,D0                           ;SHIFT SRC BIT OUT, 1 BIT IN
        BCS.S   BLACK1                          ;BR IF BLACK
WHITE1  ADD     D3,D2                           ;HERROR := HERROR + NUMER
        BLT     SRCBIT                          ;LOOP FOR MORE SRC BITS
        CLR     D5                              ;DSTBIT=0
        BRA.S   PUTBITS                         ;PUT WHITE BITS TO DST

BLACK2  ADD.L   D0,D0                           ;GET SRC BIT
        BNE.S   BLACK1                          ;BR IF SRC NOT EXHAUSTED
        MOVE.L  (A0)+,D0                        ;GET NEXT SRC LONG
        ADDX.L  D0,D0                           ;SHIFT SRC BIT OUT, 1 IN
BLACK1  ADD     D3,D2                           ;HERROR := HERROR + NUMER
        BLT     BLACK2                          ;LOOP FOR MORE SRC BITS
        MOVEQ   #1,D5                           ;DSTBIT=1, PUT BLACK BITS

PUTBITS ADD.L   D1,D1                           ;SHIFT DSTLONG LEFT
        BCC.S   DSTOK                           ;BR IF SAME LONG
        ADD     D5,D1                           ;PUT A WHITE OR BLACK BIT
        MOVE.L  D1,(A1)+                        ;PUT LONG TO DST
        CMP.L   A3,A1                           ;IS DSTPTR >= DSTLIMIT ?
        BHS.S   DONE                            ;YES, QUIT
        MOVE.L  #1,D1                           ;RESET DSTLONG TO FLAG
        BRA.S   DSTOK2
DSTOK   ADD     D5,D1                           ;PUT A WHITE OR BLACK BIT
DSTOK2  SUB     D4,D2                           ;HERROR := HERROR - DENOM
        BGT     PUTBITS                         ;PUT MORE BITS TO DST
        BRA     SRCBIT                          ;THEN GET NEXT SRC BIT

DONE    MOVEM.L (SP)+,D0-D7/A1-A4               ;RESTORE REGISTERS
        UNLINK  PARAMSIZE,'STRETCHR'


        .END


