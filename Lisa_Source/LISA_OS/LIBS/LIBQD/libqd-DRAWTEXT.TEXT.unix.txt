
        .INCLUDE libqd/GRAFTYPES.TEXT
;--------------------------------------------------------------
;
;  --> DRAWTEXT.TEXT
;
;  QuickDraw Character Generator
;
;

        .PROC DrText,4
        .REF  LeftMask,RightMask,RSect,ShieldCursor,ShowCursor
        .REF  StdTxMeas,RectInRgn,MapRect,StretchBits,TrimRect
;------------------------------------------------------------
;
;  PROCEDURE DrText(count: INTEGER; textAddr: Ptr; numer,denom: Point);
;
;  DRAWS CHARACTERS INTO THE CURRENT PORT'S BITMAP.
;  THE FONT AND ATTRIBUTES ARE GIVEN IN THE CURRENT PORT'S CHARSTYLE.
;


;-------------------------------------------
;
;  KERNED STRIKE FONT FORMAT OFFSETS:
;
FORMAT          .EQU    0               ;WORD
MINCHAR         .EQU    2               ;WORD
MAXCHAR         .EQU    4               ;WORD
MAXWD           .EQU    6               ;WORD
FBBOX           .EQU    8               ;WORD
FBBOY           .EQU    10              ;WORD
FBBDX           .EQU    12              ;WORD
FBBDY           .EQU    14              ;WORD
LENGTH          .EQU    16              ;WORD
ASCENT          .EQU    18              ;WORD
DESCENT         .EQU    20              ;WORD
XOFFSET         .EQU    22              ;WORD
RASTER          .EQU    24              ;WORD


;------------------------------------------------------
;
;  A6 OFFSETS OF PARAMETERS AFTER LINK:
;
PARAMSIZE       .EQU    14                      ;SIZE OF PARAMETERS
COUNT           .EQU    PARAMSIZE+8-2           ;WORD
TEXTADDR        .EQU    COUNT-4                 ;LONG
NUMER           .EQU    TEXTADDR-4              ;LONG, POINT
DENOM           .EQU    NUMER-4                 ;LONG, POINT


;-----------------------------------------------------------
;
;  A6 OFFSETS OF LOCAL VARIABLES AFTER LINK:
;
SAVESTK         .EQU    -4                      ;LONG
TEXTRECT        .EQU    SAVESTK-8               ;RECT
TEXTR2          .EQU    TEXTRECT-8              ;RECT
MINRECT         .EQU    TEXTR2-8                ;RECT
BUFEND          .EQU    MINRECT-4               ;LONG
BUFSTART        .EQU    BUFEND-4                ;LONG
BUFSIZE         .EQU    BUFSTART-2              ;WORD
BUFROW          .EQU    BUFSIZE-2               ;WORD
BUFLEFT         .EQU    BUFROW-2                ;WORD
BUF2START       .EQU    BUFLEFT-4               ;LONG
BUF2END         .EQU    BUF2START-4             ;LONG
HEIGHT1         .EQU    BUF2END-2               ;WORD
SRCBITS         .EQU    HEIGHT1-14              ;BITMAP
DSTBITS         .EQU    SRCBITS-14              ;BITMAP
FAKERGN         .EQU    DSTBITS-10              ;RECTANGULAR REGION
FAKEPTR         .EQU    FAKERGN-4               ;LONG, FAKE MASTER POINTER
SRCADDR         .EQU    FAKEPTR-4               ;LONG
SRCROW          .EQU    SRCADDR-2               ;WORD
FASTFLAG        .EQU    SRCROW-2                ;BYTE
PENLOC          .EQU    FASTFLAG-4              ;POINT
PORT            .EQU    PENLOC-4                ;LONG
SRCPTR          .EQU    PORT-4                  ;LONG
DSTPTR          .EQU    SRCPTR-4                ;LONG
STRETCH         .EQU    DSTPTR-2                ;BOOLEAN
FROMRECT        .EQU    STRETCH-8               ;RECT
TORECT          .EQU    FROMRECT-8              ;RECT
SRCRECT         .EQU    TORECT-8                ;RECT
DSTRECT         .EQU    SRCRECT-8               ;RECT
SPWIDTH         .EQU    DSTRECT-4               ;FIXED POINT
CHARLOC         .EQU    SPWIDTH-4               ;FIXED POINT
INFO            .EQU    CHARLOC-8               ;4 WORDS
WIDTAB          .EQU    INFO-4                  ;LONG
VARSIZE         .EQU    WIDTAB                  ;SIZE OF VARIABLES


        CHECKSTACK VARSIZE
        LINK    A6,#VARSIZE                     ;ALLOCATE TEMP VARS
        MOVEM.L D0-D7/A1-A4,-(SP)               ;SAVE REGS
        MOVE.L  SP,SAVESTK(A6)                  ;REMEMBER WHERE STACK WAS
        MOVE.L  GRAFGLOBALS(A5),A4              ;POINT TO QUICKDRAW GLOBALS
        MOVE.L  THEPORT(A4),A3                  ;GET CURRENT GRAFPORT


;-------------------------------------------------------------
;
;  Call StdTxMeas to swap font and measure width.
;
        CLR     -(SP)                           ;ROOM FOR FCN RESULT
        MOVE    COUNT(A6),-(SP)                 ;PUSH COUNT
        BLE     GOHOME                          ;QUIT IF COUNT <= 0
                                                ;STACK CLEANED UP BY SAVESTK
        MOVE.L  TEXTADDR(A6),-(SP)              ;PUSH TEXTADDR
        PEA     NUMER(A6)                       ;PUSH VAR NUMER
        PEA     DENOM(A6)                       ;PUSH VAR DENOM
        PEA     INFO(A6)                        ;PUSH VAR INFO
        JSR     StdTxMeas                       ;MEASURE TEXT AND ALSO
                                                ;LEAVE FMOUTPTR IN 'FONTPTR'
        MOVE    (SP)+,D1                        ;POP UNSCALED WIDTH RESULT
        MOVE.L  FONTPTR(A4),A4                  ;POINT TO FMOUTPUT
        TST.L   2(A4)                           ;IS FONTHANDLE NIL ?
        BEQ     GOHOME                          ;YES, QUIT

        MOVE    D1,TEXTRECT+RIGHT(A6)           ;SAVE WIDTH FOR LATER
        MOVE.L  PNLOC(A3),PENLOC(A6)            ;COPY PEN LOCATION
        MULU    NUMER+H(A6),D1                  ;MULT WIDTH BY NUMER
        DIVU    DENOM+H(A6),D1                  ;DIV BY DENOM
        ADD     D1,PNLOC+H(A3)                  ;BUMP PEN BY SCALED TEXT WIDTH
;
;  QUIT IF PEN HIDDEN
;
        TST     PNVIS(A3)                       ;IS PNVIS < 0 ?
        BLT     GOHOME                          ;YES, QUIT
        MOVE.L  2(A4),A2                        ;GET FONT HANDLE
        MOVE.L  (A2),A2                         ;DE-REFERENCE IT

;-------------------------------------------------------
;
;  SET UP TEXTRECT, THE RECTANGLE BOUNDING THE ENTIRE STRING.
;
        MOVE    PENLOC+V(A6),D0
        SUB     ASCENT(A2),D0                   ;TOP := PNLOC.V - ASCENT
        MOVE    D0,TEXTRECT+TOP(A6)
        ADD     FBBDY(A2),D0                    ;BOTTOM := TOP + HEIGHT
        MOVE    D0,TEXTRECT+BOTTOM(A6)
        MOVE    PENLOC+H(A6),D0
        MOVE    D0,TEXTRECT+LEFT(A6)            ;LEFT := PNLOC.H
        ADD     #32,D0                          ;SLOP FOR ITALIC,BOLD,OVERSTRIKE
        ADD     D0,TEXTRECT+RIGHT(A6)           ;RIGHT := LEFT + TXTWD
        MOVE.L  TEXTRECT(A6),TEXTR2(A6)
        MOVE.L  TEXTRECT+4(A6),TEXTR2+4(A6)     ;TEXTR2 := TEXTRECT


;------------------------------------------------------------
;
;  Take the slow way if color filtering or bit stretching.
;  no color change if foreground = 1 and background = 0.
;
        MOVE.L  BKCOLOR(A3),D0                  ;GET BACKGROUND COLOR
        NOT.L   D0                              ;INVERT IT
        AND.L   FGCOLOR(A3),D0                  ;AND WITH FOREGROUND COLOR
        MOVE    COLRBIT(A3),D1                  ;WHICH PLANE ARE WE IN ?
        BTST    D1,D0                           ;CHECK THAT PLANE'S RESULT
        SNE     FASTFLAG(A6)                    ;SET FASTFLAG IF COLOR OK

        MOVE.L  NUMER(A6),D0                    ;GET NUMERATOR
        CMP.L   DENOM(A6),D0                    ;IS IT SAME AS DENOMINATOR ?
        SNE     STRETCH(A6)                     ;REMEMBER THE ANSWER
        BEQ.S   NOSTRCH                         ;YES, CONTINUE
        CLR.B   FASTFLAG(A6)                    ;NO, FORCE SLOW WAY


;-------------------------------------------------------
;
;  WE WILL BE STRETCHING.  SET UP FROMRECT AND TORECT AND MAP TEXTR2.
;
        MOVE.L  PENLOC(A6),D0                   ;GET PENLOC
        MOVE.L  D0,TORECT+TOPLEFT(A6)           ;SET UP TORECT TOPLEFT
        ADD     NUMER+H(A6),D0
        MOVE    D0,TORECT+RIGHT(A6)             ;SET UP TORECT RIGHT
        SWAP    D0
        ADD     NUMER+V(A6),D0
        MOVE    D0,TORECT+BOTTOM(A6)            ;SET UP TORECT BOTTOM

        MOVE.L  PENLOC(A6),D0                   ;GET PENLOC
        MOVE.L  D0,FROMRECT+TOPLEFT(A6)         ;SET UP FROMRECT TOPLEFT
        ADD     DENOM+H(A6),D0
        MOVE    D0,FROMRECT+RIGHT(A6)           ;SET UP FROMRECT RIGHT
        SWAP    D0
        ADD     DENOM+V(A6),D0
        MOVE    D0,FROMRECT+BOTTOM(A6)          ;SET UP FROMRECT BOTTOM

        PEA     TEXTR2(A6)
        PEA     FROMRECT(A6)
        PEA     TORECT(A6)
        JSR     MAPRECT                         ;MAP TEXTR2
NOSTRCH


;----------------------------------------------------------
;
;  CALC MINRECT, THE INTERSECTION OF TEXTRECT, BITMAP BOUNDS,
;  CLIPRGN BBOX AND VISRGN BBOX.  QUIT IF NO INTERSECTION.
;
        PEA     TEXTR2(A6)                      ;PUSH (MAPPED) TEXTRECT
        PEA     PORTBOUNDS(A3)                  ;PUSH BITMAP BOUNDS
        MOVE.L  CLIPRGN(A3),A0                  ;GET CLIPRGN HANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        PEA     RGNBBOX(A0)                     ;PUSH CLIPRGN BBOX
        MOVE.L  VISRGN(A3),A0                   ;GET VISRGN HANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        PEA     RGNBBOX(A0)                     ;PUSH VISRGN BBOX
        MOVE    #4,-(SP)                        ;PUSH NRECTS=4
        PEA     MINRECT(A6)                     ;PUSH DST ADDR
        JSR     RSECT                           ;CALC INTERSECTION
        BEQ     GOHOME                          ;QUIT IF NO INTERSECTION

;--------------------------------------------------------
;
;  SET UP SRCADDR, SRCROW, AND HEIGHT.
;
        LEA     26(A2),A0                       ;GET START OF FONT BITMAP
        MOVE.L  A0,SRCADDR(A6)                  ;SAVE FOR LATER
        MOVE    RASTER(A2),D1                   ;GET WORDS PER ROW IN FONT
        ADD     D1,D1                           ;DOUBLE FOR BYTES PER ROW
        MOVE    D1,SRCROW(A6)                   ;REMEMBER FOR LATER
        MOVE    FBBDY(A2),HEIGHT1(A6)           ;SAVE HEIGHT FOR LATER


;------------------------------------------------------
;
;  TEST FOR FAST CASE:
;  NOT STRETCHED, NO COLOR MAPPING, TXMODE = srcOr,  BOLD = 0, ITALIC = 0,
;  ULTHICK = 0, SHADOW = 0, VISRGN RECTANGULAR, CLIPRGN RECTANGULAR.
;
        TST.B   FASTFLAG(A6)                    ;STRETCHED OR COLOR FILTERED ?
        BEQ     NOTFAST                         ;YES, CAN'T GO FAST
        TST.W   6(A4)                           ;TEST BOLD AND ITALIC
        BNE     NOTFAST                         ;NOT FAST UNLESS BOTH ZERO
        TST.W   10(A4)                          ;TEST ULTHICK AND SHADOW
        BNE     NOTFAST                         ;NOT FAST UNLESS BOTH ZERO
        CMP     #1,TXMODE(A3)                   ;IS TEXT MODE SRCOR ?
        BNE.S   NOTFAST                         ;NO, NOT FAST
        MOVE.L  CLIPRGN(A3),A0                  ;GET CLIPRGN HANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        CMP     #10,RGNSIZE(A0)                 ;IS CLIPRGN RECTANGULAR ?
        BNE.S   NOTFAST                         ;NO, NOT FAST
        MOVE.L  VISRGN(A3),A0                   ;GET VISRGN HANDLE
        MOVE.L  (A0),A0                         ;DE-REFERENCE IT
        CMP     #10,RGNSIZE(A0)                 ;IS VISRGN RECTANGULAR ?
        BEQ.S   FAST                            ;YES, TAKE FAST OPTIMIZATION
;
;  All systems go except for VisRgn not rectangular.
;  Check if visRgn sect minRect is rectangular.
;  IF TrimRect(visRgn,minRect) THEN take the fast way.
;
        CLR.B   -(SP)                           ;ROOM FOR FCN RESULT
        MOVE.L  VISRGN(A3),-(SP)                ;PUSH VISRGN
        PEA     MINRECT(A6)                     ;PUSH MINRECT
        JSR     TRIMRECT                        ;CALL TRIMRECT
        TST.B   (SP)+                           ;IS INTERSECTION RECTANGULAR ?
        BEQ.S   NOTFAST                         ;NO, DO IT THE SLOW WAY


;--------------------------------------------------------------
;
;  SET UP TO GO DIRECTLY TO SCREEN.  SUBSTITUTE CLIPPED SRCADDR
;
FAST    MOVE    MINRECT+TOP(A6),D0              ;GET MINV
        SUB     TEXTRECT+TOP(A6),D0             ;WAS IT CLIPPED ?
        BLE.S   CHTOPOK                         ;NO, CONTINUE
        MULU    D1,D0                           ;CALC VERT OFFSET
        ADD.L   D0,SRCADDR(A6)                  ;ADD TO BITMAP START
CHTOPOK
;
;  SUBSTITUTE CLIPPED HEIGHT
;
        MOVE    MINRECT+BOTTOM(A6),D0           ;GET BOTTOM
        SUB     MINRECT+TOP(A6),D0              ;CALC HEIGHT
        BLE     GOHOME                          ;IN CASE TRIMRECT RETURNED EMPTY
        MOVE    D0,HEIGHT1(A6)                  ;SAVE FOR LATER
;
;  SET UP DSTADDR INSTEAD OF BUFSTART
;
        MOVE    MINRECT+TOP(A6),D0                ;GET DST TOP
        SUB     PORTBOUNDS+TOP(A3),D0             ;CONVERT TO GLOBAL COORDINATES
        MULU    PORTBITS+ROWBYTES(A3),D0          ;MULT BY ROWBYTES
        ADD.L   PORTBITS+BASEADDR(A3),D0          ;ADD START OF DST BITMAP
        MOVE.L  D0,BUFSTART(A6)                   ;SET UP BUFSTART FOR LATER
        MOVE    PORTBITS+ROWBYTES(A3),BUFROW(A6)  ;SET UP BUFROW FOR LATER
        MOVE    PORTBOUNDS+LEFT(A3),BUFLEFT(A6)
        PEA     MINRECT(A6)                       ;PUSH SHIELD RECT
        MOVE.L  PORTBOUNDS+TOPLEFT(A3),-(SP)      ;PUSH DELTA TO CONVERT TO GLOBAL
        JSR     SHIELDCURSOR                      ;HIDE CURSOR IF IT INTERSECTS
        BRA.S   GETPTRS



;----------------------------------------------------------
;
;  CALC BUFLEFT:  WORD-ALIGN TO AVOID SHIFT
;
NOTFAST CLR.B   FASTFLAG(A6)                    ;NOT GOING DIRECTLY TO SCREEN
        MOVE    TEXTRECT+LEFT(A6),D0            ;GET TEXTRECT LEFT
        SUB     PORTBOUNDS+LEFT(A3),D0          ;CONVERT TO GLOBAL
        AND     #$FFF0,D0                       ;TRUNC TO WORD BOUND
        SUB     #32,D0                          ;SLOP FOR SLANT & SHADOW
        ADD     PORTBOUNDS+LEFT(A3),D0          ;RETURN TO LOCAL COORDS
        MOVE    D0,BUFLEFT(A6)                  ;REMEMBER FOR LATER


;-----------------------------------------
;
;  CALC SIZE OF BUFFER
;
        MOVE    TEXTRECT+RIGHT(A6),D1           ;BUFRIGHT := TEXTRECT RIGHT
        SUB     D0,D1                           ;WIDTH:=BUFRIGHT-BUFLEFT
        LSR     #5,D1                           ;CONVERT DOTS TO LONGS
        ADD     #2,D1                           ;ROUND UP PLUS EXTRA LONG
        MOVE    HEIGHT1(A6),D3                  ;GET HEIGHT
        MULU    D1,D3                           ;BUFSIZE:=HEIGHT*BUFROW LONGS
        MOVE    D3,BUFSIZE(A6)                  ;SAVE FOR LATER
        LSL     #2,D1                           ;QUAD BUFROW FOR BYTES
        MOVE    D1,BUFROW(A6)                   ;SAVE FOR LATER


;---------------------------------------------
;
;  EXPAND STACK IF NECESSARY
;
        .IF     FORMAC=0
        CLR.L   D0                              ;CLEAR LONG COUNT
        MOVE    D3,D0                           ;COPY LONGCOUNT
        LSL.L   #2,D0                           ;QUAD FOR BYTECOUNT
        ADD.L   #1024,D0                        ;ADD SLOP FOR STACK
        NEG.L   D0                              ;MAKE OFFSET NEGATIVE
        TST.W   0(SP,D0.L)                      ;EXPAND STACK
        .ENDC


;----------------------------------------
;
;  ALLOCATE AND CLEAR BUFFER.
;
        SUB     #1,D3                           ;INIT DBRA LOOP COUNT
        CLR.L   -(SP)                           ;PAD BUFFER WITH AN EXTRA ZERO
        MOVE.L  SP,BUFEND(A6)                   ;REMEMBER WHERE BUFFER ENDS
CLRLOOP CLR.L   -(SP)
        DBRA    D3,CLRLOOP                      ;ALLOCATE AND CLEAR BUFFER
        MOVE.L  SP,BUFSTART(A6)                 ;REMEMBER START OF BUFFER
        CLR.L   -(SP)                           ;PAD BUFFER WITH AN EXTRA ZERO


;----------------------------------------------------------------
;
;  GET POINTERS TO LOCATION TABLE AND WIDTH TABLE IN FONT
;
GETPTRS LEA     26(A2),A1                       ;GET START OF FONT BITMAP
        MOVE    FBBDY(A2),D0                    ;GET HEIGHT OF FONT BITMAP
        MULU    SRCROW(A6),D0                   ;CALC TOTAL SIZE OF STRIKE
        ADD.L   D0,A1                           ;A1:=START OF LOC TABLE
        MOVE    LENGTH(A2),D0                   ;HOW MANY WORDS IN STRIKE BODY
        ADD     D0,D0                           ;DOUBLE FOR BYTECOUNT
        LEA     16(A2,D0),A0                    ;GET START OF WIDTH TABLE
        MOVE.L  A0,WIDTAB(A6)                   ;SAVE FOR LATER


;----------------------------------------------
;
;   SET UP SPACE WIDTH
;
        MOVE    #32,D0                          ;GET A SPACE CHARACTER
        CMP     MAXCHAR(A2),D0                  ;IS SPACE > MAXCHAR ?
        BLE.S   OKSPACE                         ;NO, CONTINUE
SPMISS  MOVE    MAXCHAR(A2),D0                  ;YES, USE MISSING SYMBOL
        ADD     #1,D0                           ;WHICH IS ONE PAST MAXCHAR
OKSPACE SUB     MINCHAR(A2),D0                  ;CALC SPACE - MINCHAR
        BLT.S   SPMISS                          ;MISSING IF SPACE < MINCHAR
        ADD     D0,D0                           ;INDEX:=(SPACE-MINCHAR)*2
        MOVE.L  WIDTAB(A6),A0                   ;POINT TO WIDTH TABLE
        MOVE    0(A0,D0),D5                     ;GET OFFSET AND WIDTH BYTES
        CMP     #-1,D5                          ;-1 MEANS CH NOT IN FONT
        BEQ     SPMISS                          ;USE WIDTH OF MISSING SYMBOL
        AND     #$FF,D5                         ;GET WIDTH BYTE 0..255
        ADD.B   12(A4),D5                       ;ADD FONT EXTRA
        SWAP    D5                              ;PUT INT PART IN HI WORD
        CLR.W   D5                              ;CLEAR LO WORD
;
;
;  --->  CLEAN THIS UP
;
;
        MOVE.L  GRAFGLOB(A5),A0
        ADD.L   FONTADJ(A0),D5                  ;ADD ADJUSTED SPEXTRA
        MOVE.L  D5,SPWIDTH(A6)                  ;SAVE WIDTH OF SPACE FOR LATER


;-------------------------------------------------------------
;
;  SET UP MISC STUFF IN REGISTERS FOR SPEED
;
        MOVE    PENLOC+H(A6),D0                 ;GET PEN LOCATION
        ADD     FBBOX(A2),D0                    ;ADJUST FOR KERNING
        MOVE.W  D0,CHARLOC(A6)                  ;INIT INT PART OF CHARLOC
        MOVE    #$8000,CHARLOC+2(A6)            ;SET FRACT PART TO ONE HALF
        SUB     #1,HEIGHT1(A6)                  ;MAKE HEIGHT-1 FOR LOOP


;---------------------------------------------------------------
;
;  GET NEXT CHARACTER AND CALC SRCLEFT, DSTLEFT, DSTRIGHT.
;
NEXTCH  MOVE.L  TEXTADDR(A6),A0                 ;GET CURRENT TEXTPTR
        MOVE.B  (A0)+,D0                        ;GET NEXT CHAR
        MOVE.L  A0,TEXTADDR(A6)                 ;UPDATE TEXTPTR
        CMP.B   #32,D0                          ;IS IT A SPACE ?
        BNE.S   NOTSP                           ;NO, CONTINUE
        MOVE.L  SPWIDTH(A6),D1                  ;YES, GET SPACE WIDTH
        ADD.L   D1,CHARLOC(A6)                  ;JUST BUMP CHARLOC
        BRA     BUMP2                           ;AND SKIP

NOTSP   AND     #$FF,D0                         ;MASK OFF HI BYTE
        CMP     MAXCHAR(A2),D0                  ;IS ASCII > MAXCHAR ?
        BLE.S   OKCHAR                          ;NO, CONTINUE
MISSING MOVE    MAXCHAR(A2),D0                  ;YES, PRINT MISSING SYMBOL
        ADD     #1,D0                           ;WHICH IS ONE PAST MAXCHAR
OKCHAR  SUB     MINCHAR(A2),D0                  ;CALC ASCII - MINCHAR
        BLT.S   MISSING                         ;MISSING IF ASCII < MINCHAR
        ADD     D0,D0                           ;INDEX:=(ASCII-MINCHAR)*2
        MOVE.L  WIDTAB(A6),A0                   ;POINT TO WIDTH TABLE
        MOVE    0(A0,D0),D5                     ;GET OFFSET AND WIDTH BYTES
        CMP     #-1,D5                          ;-1 MEANS CH NOT IN FONT
        BEQ     MISSING                         ;PRINT MISSING SYMBOL
        MOVE    0(A1,D0),D1                     ;GET SRCLEFT
        MOVE    2(A1,D0),D2                     ;GET SRCRIGHT
        SUB     D1,D2                           ;CALC WIDTH OF BITS
        BLE     BUMP                            ;SKIP CHARBLT IF WIDTH <= 0
        MOVE    D5,D3                           ;COPY OFFWID
        LSR     #8,D3                           ;GET OFFSET BYTE
        ADD.W   CHARLOC(A6),D3                  ;DSTLEFT := CHARLOC + OFFSET
        ADD     D3,D2                           ;DSTRIGHT :=DSTLEFT + WIDTH
;
;  AT THIS POINT:
;     D1: SRCLEFT LOCAL
;     D2: DSTRIGHT LOCAL
;     D3: DSTLEFT LOCAL
;

;-----------------------------------------------------------------------
;
;  IF GOING DIRECTLY TO SCREEN, THEN HORIZONTAL CLIP.
;  SKIP IF HIDDEN ON LEFT, STRING DONE IF HIDDEN ON RIGHT
;
        TST.B   FASTFLAG(A6)                    ;ARE WE GOING DIRECT TO SCREEN ?
        BEQ.S   LEFTOK                          ;NO, SKIP TESTING
        CMP     MINRECT+LEFT(A6),D2             ;IS DSTRIGHT <= MINRECT.LEFT ?
        BLE     BUMP                            ;YES, JUST BUMP AND RUN
        CMP     MINRECT+RIGHT(A6),D3            ;IS DSTLEFT >= MAXH ?
        BGE     STRDONE                         ;YES, IGNORE REST OF STRING
        CMP     MINRECT+RIGHT(A6),D2            ;IS DSTRIGHT > MAXH ?
        BLE.S   RIGHTOK                         ;NO, CONTINUE
        MOVE    MINRECT+RIGHT(A6),D2            ;YES, DSTRIGHT:=MAXH
RIGHTOK CMP     MINRECT+LEFT(A6),D3             ;IS DSTLEFT < MINRECT.LEFT ?
        BGE.S   LEFTOK                          ;NO, CONTINUE
        MOVE    MINRECT+LEFT(A6),D0             ;YES, GET MINRECT.LEFT
        SUB     D3,D0                           ;DISCARD:=MINRECT.LEFT-DSTLEFT
        ADD     D0,D1                           ;SRCLEFT:=SRCLEFT+DISCARD
        ADD     D0,D3                           ;DSTLEFT:=DSTLEFT+DISCARD
LEFTOK

        SUB     BUFLEFT(A6),D3                  ;MAKE DSTLEFT RELATIVE TO BUFFER
        SUB     BUFLEFT(A6),D2                  ;MAKE DSTRIGHT RELATIVE TO BUFFER


;--------------------------------------------------------------
;
;  LOCAL BLOCK CharBlt(srcAddr,srcRow,srcLeft,
;                    dstAddr,dstRow,dstLeft,dstRight,height1);
;
;  INPUTS TO CHARBLT BLOCK:
;
;     SRCADDR(A6)               already accounts for starting vert
;     SRCROW(A6)
;     D1 = SRCLEFT
;     BUFSTART(A6)=dstAddr      dstAddr, already accounts for starting vert
;     BUFROW(A6)=dstRow
;     D3 = dstLeft              relative to buffer
;     D2 = dstRight             relative to buffer, > DSTLEFT
;     HEIGHT1(A6)               height-1, >= 0
;
;     CLOBBERS:  D0,D1,D2,D3,D4,D6,D7,A0
;     PRESERVES: D5,A1,A2,A3,A4,A5,A6,A7
;
;  RESTRICTIONS:
;     transfer is always in OR-mode
;     no overlap of src and dst
;     height1 is given as height-1, and is >= 0
;     width > 0
;     srcAddr and dstAddr already account for starting vert
;     srcLeft,dstLeft,dstRight are in global coordinates
;
;

        MOVEM.L D5/A1-A5,-(SP)                  ;SAVE REGS

;-----------------------------------------------------
;
;  SET UP SHIFTCNT IN D5 (RELATIVE SHIFT BETWEEN SRC & DST)
;
        MOVE    D3,D5                           ;GET DSTLEFT
        SUB     D1,D5                           ;SUB SRC LEFT
        AND     #$F,D5                          ;SHIFTCNT:=DELTA HORIZ MOD 16


;------------------------------------------------------------
;
;  SET UP SRCPTR IN A4, ADDR OF LEFTMOST SRC WORD
;
        MOVE.L  SRCADDR(A6),A4                  ;GET START OF SRC BITMAP
        ADD     D5,D1                           ;CALC SRCLEFT+SHIFTCNT
        ASR     #4,D1                           ;CONVERT FROM DOTS TO WORDS
        ADD     D1,D1                           ;DOUBLE FOR BYTES
        SUB     #2,D1                           ;BACK UP 1 WORD SINCE PICKING UP LONG
        ADD     D1,A4                           ;LEAVE SRCPTR IN A4


;------------------------------------------------------------
;
;  SET UP DSTPTR IN A5, ADDR OF LEFTMOST DST WORD
;
        MOVE.L  BUFSTART(A6),A5                 ;GET START OF DST BITMAP
        MOVE    D3,D1                           ;GET DSTLEFT
        MOVE    D1,D0                           ;COPY DSTLEFT
        ASR     #4,D1                           ;CONVERT FROM DOTS TO WORDS
        ADD     D1,A5                           ;ADD TO DSTPTR
        ADD     D1,A5                           ;TWICE FOR BYTES


;-------------------------------------
;
;  SET UP LEFTMASK IN D3 AND RIGHTMASK IN D4
;
        JSR     LEFTMASK                        ;GET LEFTMASK
        MOVE    D0,D3                           ;PUT LEFTMASK IN D3
        MOVE    D2,D6                           ;GET DSTRIGHT
        MOVE    D6,D0                           ;MAKE AN EXTRA COPY
        JSR     RIGHTMASK                       ;GET RIGHT MASK
        MOVE    D0,D4                           ;PUT RIGHT MASK IN D4


;----------------------------------------------
;
;  GET SRCROW, DSTROW AND HEIGHT1 INTO REGISTERS
;
        MOVE    SRCROW(A6),A2
        MOVE    BUFROW(A6),A3
        MOVE    HEIGHT1(A6),D7


;------------------------------------------------
;
;  BRANCH BASED ON TOTAL NUMBER OF DST WORDS
;
        ASR     #4,D6                           ;CALC (DSTRIGHT) DIV 16
        SUB     D1,D6                           ;CALC TOTAL NUMBER OF WORDS-1
        BEQ.S   WORD1                           ;BR IF DST ALL IN ONE WORD
        SUB     #1,D6
        BEQ.S   LONG1                           ;BR IF DST ALL IN ONE LONG
        ADD     #1,D7                           ;COMPENSATE FOR EXTRA DBRA
        BRA.S   WIDE1                           ;DST WIDER THAN ONE LONG


;-------------------------------------------------------------------
;
;  SLOW LOOP ONLY TAKEN IN WIERD OCASIONS WHERE DST WIDER THAN A LONG
;
MAIN1   MOVE.L  (A4),D0                         ;GET SRC FROM BITMAP
        ADD     #2,A4                           ;BUMP SRCPTR RIGHT
        LSR.L   D5,D0                           ;ALIGN TO DST
        AND     D1,D0                           ;MASK EXTRA TO ZEROS
        OR      D0,(A5)+                        ;OR SRC INTO DST
        MOVEQ   #-1,D1                          ;FLUSH MASK
        DBRA    D2,MAIN1                        ;LOOP TILL LAST WORD
        MOVE.L  (A4),D0                         ;GET SRC FROM BITMAP
        LSR.L   D5,D0                           ;ALIGN TO DST
        AND     D4,D0                           ;MASK WITH RIGHTMASK
        OR      D0,(A5)                         ;OR SRC INTO DST
        MOVE.L  SRCPTR(A6),A4                   ;RESTORE SRCPTR TO LEFT
        ADD     A2,A4                           ;BUMP TO NEXT ROW
        MOVE.L  DSTPTR(A6),A5                   ;RESTORE DSTPTR TO LEFT
        ADD     A3,A5                           ;BUMP DST TO NEXT ROW
WIDE1   MOVE.L  A4,SRCPTR(A6)                   ;REMEMBER SRCPTR AT LEFT
        MOVE.L  A5,DSTPTR(A6)                   ;REMEMBER DSTPTR AT LEFT
        MOVE    D3,D1                           ;MASK:=LEFTMASK
        MOVE    D6,D2                           ;GET WORDCOUNT
        DBRA    D7,MAIN1                        ;LOOP ALL ROWS
        BRA     CHDONE                          ;THEN QUIT


;-----------------------------------------
;
;  OPTIMIZE IF DST FITS IN ONE LONG
;
LONG1   SUB     #2,A3                           ;ADJUST DSTEND FOR WORD BUMP
LONG1A  MOVE.L  (A4),D0                         ;GET SRC DATA
        LSR.L   D5,D0                           ;ALIGN TO DST
        AND     D3,D0                           ;MASK EXTRA WITH LEFTMASK
        OR      D0,(A5)+                        ;OR RESULT INTO DST
        MOVE.L  2(A4),D0                        ;GET SECOND WORD OF SRC
        LSR.L   D5,D0                           ;ALIGN IT
        AND     D4,D0                           ;MASK EXTRA WITH RIGHTMASK
        OR      D0,(A5)                         ;OR RESULT INTO DST
        ADD     A2,A4                           ;BUMP SRCPTR TO NEXT ROW
        ADD     A3,A5                           ;BUMP DSTPTR TO NEXT ROW
        DBRA    D7,LONG1A                       ;LOOP ALL ROWS
        BRA     CHDONE


;--------------------------------------
;
;  OPTIMIZE IF DST FITS IN ONE WORD  (72% of normal characters do)
;
WORD1   AND     D4,D3                           ;COMBINE LEFT AND RIGHT MASKS
WORD1B  MOVE.L  (A4),D0                         ;GET SRC DATA
        LSR.L   D5,D0                           ;ALIGN TO DST
        AND     D3,D0                           ;MASK EXTRA TO ZEROS
        OR      D0,(A5)                         ;OR SRC INTO DST
        ADD     A2,A4                           ;BUMP SRCPTR TO NEXT ROW
        ADD     A3,A5                           ;BUMP DSTPTR TO NEXT ROW
        DBRA    D7,WORD1B                       ;LOOP ALL ROWS


;------------------------------------------------------
;
;  BUMP PEN LOCATION AND LOOP FOR MORE CHARACTERS
;
CHDONE  MOVEM.L (SP)+,D5/A1-A5                  ;RESTORE REGS
BUMP    AND     #$FF,D5                         ;LO BYTE = LOGICAL WIDTH
        ADD.B   12(A4),D5                       ;ADD EXTRA DOTS IF ANY
        ADD.W   D5,CHARLOC(A6)                  ;BUMP CHARLOC INT PART
BUMP2   SUB     #1,COUNT(A6)                    ;DECREMENT CHAR COUNT
        BGT     NEXTCH                          ;LOOP TILL ALL CHARS DONE

        MOVE    CHARLOC(A6),D7                  ;GET FINAL CHARLOC INT PART
        SUB     FBBOX(A2),D7                    ;UN-ADJUST FROM KERNING
        TST.B   FASTFLAG(A6)                    ;WERE WE GOING DIRECT TO SCREEN ?
        BEQ.S   CKBOLD                          ;NO, CHECK FOR BOLD
        JSR     SHOWCURSOR                      ;YES, RESTORE CURSOR
        BRA     GOHOME                          ;AND QUIT

STRDONE CLR     COUNT(A6)                       ;TERMINATE EARLY
        BRA     BUMP                            ;FINISH UP AND GO HOME


;--------------------------------------
;
;  MAKE BUFFER BOLD IF NECESSARY
;
CKBOLD  CLR     D2                              ;GET READY FOR BYTE
        MOVE.B  6(A4),D2                        ;GET NUMBER OF OVERSTRIKES
        BRA.S   NXTBOLD                         ;BOLD BUFFER IF ANY
BOLDIT  MOVE.L  BUFSTART(A6),A0                 ;POINT TO START OF BUFFER
        MOVE    BUFSIZE(A6),D1                  ;HOW MANY LONGS IN BUF
        SUB     D0,D0                           ;CLEAR X-BIT
BOLDLP  MOVE.L  (A0),D0                         ;GET ONE LONG
        ROXR.L  #1,D0                           ;ROTATE RIGHT WITH EXTEND
        OR.L    D0,(A0)+                        ;OR BACK INTO BUFFER
        DBRA    D1,BOLDLP                       ;LOOP ENTIRE BUFFER
NXTBOLD DBRA    D2,BOLDIT                       ;LOOP FOR EACH OVERSTRIKE


;-------------------------------------
;
;  SLANT THE BUFFER IF NECESSARY:
;  WORK FROM BOTTOM OF BUFFER UP, SHIFTING EACH ROW RIGHT
;  WORK RIGHT TO LEFT TO AVOID CLOBBERING SRC.
;
        CLR     D2                              ;GET READY FOR BYTE
        MOVE.B  7(A4),D2                        ;DO WE NEED ITALIC ?
        BEQ.S   CHECKUL                         ;NO, CONTINUE

        MOVE.L  BUFEND(A6),A1                   ;DSTPTR:=END OF BUFFER
        MOVE    BUFROW(A6),D3                   ;GET BUFFER ROWBYTES
        SUB     D3,A1                           ;BACK UP DSTPTR TO END OF 2ND ROW
        LSR     #1,D3                           ;WORDCNT:=ROWBYTES DIV 2
        SUB     #1,D3                           ;WORDCOUNT-1 FOR DBRA LOOP

        MOVE    HEIGHT1(A6),D6                  ;INIT ROW COUNTER
        CLR     D4                              ;INIT OFFSET
NXTROW  ADD     D2,D4                           ;OFFSET:=OFFSET+ITALIC
        MOVE    D4,D0                           ;COPY OFFSET
        LSR     #4,D0                           ;DELTA := OFFSET SCALED BY 16
        MOVEQ   #$F,D5
        AND     D0,D5                           ;SHIFTCNT:=DELTA MOD 16
        LSR     #4,D0                           ;DELWORD:=DELTA DIV 16
        MOVE.L  A1,A0                           ;SRCPTR:=DSTPTR
        SUB     #4,A0                           ;BACK UP ONE LONG
        SUB     D0,A0                           ;SUBTRACT DELWORD
        SUB     D0,A0                           ;TWICE BECAUSE WORDS

        MOVE    D3,D1                           ;INIT LOOP TO WORDCNT
NXTWORD MOVE.L  (A0),D0                         ;GET A LONG OF SRC
        SUB     #2,A0                           ;BUMP SRCPTR LEFT ONE WORD
        LSR.L   D5,D0                           ;SHIFT SRC TO ALIGN WITH DST
        MOVE    D0,-(A1)                        ;STORE IN DST AND BUMP DSTPTR
        DBRA    D1,NXTWORD                      ;LOOP ALL WORDS THIS ROW
        DBRA    D6,NXTROW                       ;LOOP FOR ALL ROWS IN BUFFER


;-----------------------------------------------------
;
;  UNDERLINE CHARACTERS IN BUFFER IF NECESSARY.
;
;  USE CHARACTERS IN BUFFER TO HIDE PARTS OF THE UNDERLINE.
;
CHECKUL TST.B   10(A4)                          ;IS ULTHICK ZERO ?
        BEQ     NOTUL                           ;YES, CONTINUE
        MOVE.L  BUFSTART(A6),A0                 ;POINT TO BUFFER START
        MOVE    BUFROW(A6),D1                   ;GET BYTES PER ROW OF BUFFER
        MOVE    ASCENT(A2),D0                   ;GET ASCENT
        MOVE    DESCENT(A2),D2                  ;GET DESCENT
        MULU    D1,D0
        ADD.L   D0,A0                           ;POINT TO BASELINE ROW
        MOVE.L  A0,A1
        MOVE.L  A0,A2
        ADD     D1,A1                           ;POINT TO BASELINE+1
        CMP     #2,D2                           ;IS DESCENT AT LEAST 2 ?
        BLT.S   NOTUL                           ;NO, SKIP UNDERLINE
        BEQ.S   ONLY2                           ;ONLY USE 2 IF DESCENT=2
        ADD     D1,A2
        ADD     D1,A2                           ;POINT TO BASELINE+2
ONLY2
        .IF     FORMAC=0
        CLR.L   D0                              ;CLEAR LONG COUNT
        MOVE    D1,D0                           ;COPY BYTECOUNT
        ADD.L   #1024,D0                        ;ADD SLOP FOR STACK
        NEG.L   D0                              ;CALC NEG OFFSET
        TST.W   0(SP,D0.L)                        ;EXPAND STACK
        .ENDC

        SUB     D1,SP                           ;ALLOCATE TEMP SCANBUF
        MOVE.L  A3,-(SP)                        ;SAVE GRAFPORT
        LEA     4(SP),A3                        ;POINT TO START OF TEMP
        LSR     #2,D1                           ;CONVERT BYTES TO LONGS
        SUB     #1,D1                           ;INIT DBRA LOOP COUNT
        MOVE    D1,D2                           ;COPY LOOP COUNT
        SUB     D0,D0                           ;CLEAR X-BIT
UL1     MOVE.L  (A0)+,D0                        ;GET FROM BASELINE
        OR.L    (A1)+,D0                        ;OR WITH BASELINE+1
        OR.L    (A2)+,D0                        ;OR WITH BASELINE+2
        MOVE.L  D0,(A3)                         ;PUT RESULT TO TEMP
        ROXR.L  #1,D0                           ;SHIFT WITH CARRY
        OR.L    D0,(A3)+                        ;OR INTO TEMP
        DBRA    D1,UL1                          ;LOOP ALL LONGS IN ROW

        MOVE.L  A1,A0                           ;COPY END PTR
        SUB     D0,D0                           ;CLEAR X-BIT
UL2     MOVE.L  -(A3),D0                        ;GET FROM TEMP
        ROXL.L  #1,D0                           ;SHIFT LEFT WITH CARRY
        OR.L    (A3),D0                         ;OR WITH TEMP
        NOT.L   D0                              ;INVERT
        OR.L    D0,-(A1)                        ;DRAW SOME UNDERLINE
        DBRA    D2,UL2                          ;LOOP ALL LONGS IN ROW
        MOVE.L  (SP)+,A3                        ;RESTORE GRAFPORT
;
;  TRIM RIGHT EDGE OF UNDERLINE.  (LEFT EDGE TRIMMED BY StretchBits)
;
        MOVE    BUFROW(A6),D0                   ;GET BYTES PER ROW OF BUFFER
        LSL     #3,D0                           ;TIMES 8 FOR DOTS WIDE
        ADD     BUFLEFT(A6),D0                  ;BUFRIGHT:=BUFLEFT+BUFWIDTH
        SUB     D7,D0                           ;OVERSHOOT:=BUFRIGHT-LASTRIGHT
        SUB     #1,D0                           ;BACK UP 1 SO MASK COMES OUT RIGHT
        LSR     #4,D0                           ;CONVERT DOTS TO WORDCOUNT
        BRA.S   UL3                             ;GO TO LOOP START
ULTRIM  CLR     -(A0)                           ;ERASE SOME UNDERLINE
UL3     DBRA    D0,ULTRIM                       ;LOOP ALL FULL WORDS
        MOVE    D7,D0                           ;GET LAST RIGHT COORD
        SUB     PORTBOUNDS+LEFT(A3),D0          ;CONVERT TO GLOBAL COORDS
        JSR     RIGHTMASK                       ;COMPUTE A MASK
        AND     D0,-(A0)                        ;ERASE LAST PARTIAL WORD


;-------------------------------------------------
;
;  SET UP FAKERGN, A DUMMY RECTANGULAR REGION
;
NOTUL   MOVE    #10,FAKERGN+RGNSIZE(A6)         ;SIZE=10 BYTES FOR RECT RGN
        MOVE.L  PORTBOUNDS(A3),FAKERGN+RGNBBOX(A6)
        MOVE.L  PORTBOUNDS+4(A3),FAKERGN+RGNBBOX+4(A6)
        LEA     FAKERGN(A6),A0                  ;GET ADDR OF FAKERGN
        MOVE.L  A0,FAKEPTR(A6)                  ;POINT FAKE MASTERPTR TO IT


;-------------------------------------------------------------
;
;  SET UP BITMAPS TO TRANSFER FROM BUFFER TO SCREEN.
;
;  SRCBITS:=BUFFER
;
        LEA     SRCBITS(A6),A0                  ;POINT TO SRCBITS
        MOVE.L  BUFSTART(A6),(A0)+              ;SET UP BASEADDR
        MOVE    BUFROW(A6),(A0)+                ;SET UP ROWBYTES
        MOVE    TEXTRECT+TOP(A6),(A0)+          ;SET UP BOUNDS TOP
        MOVE    BUFLEFT(A6),(A0)+               ;SET UP BOUNDS LEFT
        MOVE.L  TEXTRECT+BOTRIGHT(A6),(A0)+     ;SET UP BOTTOM RIGHT

;
;  DSTBITS:=PORTBITS
;
        LEA     PORTBITS(A3),A2                 ;POINT TO PORTBITS
        LEA     DSTBITS(A6),A0                  ;POINT TO DSTBITS
        MOVE.L  (A2)+,(A0)+                     ;COPY BASEADDR
        MOVE    (A2)+,(A0)+                     ;COPY ROWBYTES
        MOVE.L  (A2)+,(A0)+                     ;COPY BOUNDS.TOPLEFT
        MOVE.L  (A2)+,(A0)+                     ;COPY BOUNDS.BOTRIGHT


;--------------------------------------------------------------
;
;  CHECK IF ANY SHADOWING.
;
        CLR     D3                              ;GET READY FOR BYTE
        MOVE.B  11(A4),D3                       ;GET SHADOW COUNT
        BEQ     NOSHAD                          ;SKIP IF NO SHADOWING


;---------------------------------------------
;
;  EXPAND STACK IF NECESSARY
;
        .IF     FORMAC=0
        CLR.L   D0                              ;CLEAR FOR LONG COUNT
        MOVE    BUFSIZE(A6),D0                  ;COPY LONGCOUNT
        ADD     BUFROW(A6),D0                   ;ADD 4 SCANLINES PER CHAR
        LSL.L   #2,D0                           ;QUAD FOR BYTECOUNT
        ADD.L   #1024,D0                        ;ADD SLOP FOR STACK
        NEG.L   D0                              ;MAKE OFFSET NEGATIVE
        TST.W   0(SP,D0.L)                      ;EXPAND STACK
        .ENDC


;------------------------------------------------------------------------
;
;  SHADOWING WILL BE USED. ALLOCATE BUF2, 4 SCANS TALLER THAN BUF1.
;  CLEAR OUT NEW 4 SCANLINES, AND COPY BUF1 INTO THE REST.
;
        MOVE    BUFROW(A6),D0                   ;GET 4 * NUMBER OF LONGS PER ROW
        SUB     #1,D0                           ;INIT LOOP COUNTER
        CLR.L   -(SP)                           ;ALLOW ONE LONG OF SLOP
        MOVE.L  SP,BUF2END(A6)                  ;REMEMBER END OF BUF2
CLR2    CLR.L   -(SP)                           ;ALLOCATE AND CLEAR A LONG
        DBRA    D0,CLR2                         ;CLEAR 4 SCANLINES WORTH
        MOVE    BUFSIZE(A6),D0                  ;GET NUMBER OF LONGS IN BUF1
        SUB     #1,D0                           ;INIT DBRA COUNTER
        MOVE.L  BUFEND(A6),A0                   ;POINT TO END OF BUF1
COPYLP  MOVE.L  -(A0),-(SP)                     ;COPY FROM BUF1 TO NEW BUF2
        DBRA    D0,COPYLP                       ;COPY ALL OF BUF1
        MOVE.L  SP,BUF2START(A6)                ;REMEMBER START OF BUF2
        CLR.L   -(SP)                           ;ALLOW ONE LONG OF SLOP


;----------------------------------------------------------------------
;
;  BOLD BUF2 ACROSS TO THE RIGHT ENOUGH FOR SHADOW
;
        AND     #3,D3                           ;RESTRICT SHADOW COUNT TO 1..3
        MOVE    D3,D2                           ;INIT BOLD COUNTER
ACROSS1 MOVE.L  BUF2START(A6),A0                ;POINT TO START OF BUFFER2
        MOVE    BUFSIZE(A6),D1                  ;INIT COUNT OF LONGS
        SUB     D0,D0                           ;CLEAR X-BIT
ACROSS2 MOVE.L  (A0),D0                         ;GET A LONG FROM BUF2
        ROXR.L  #1,D0                           ;SHIFT IT RIGHT EXTENDED
        OR.L    D0,(A0)+                        ;OR IT BACK INTO BUFFER
        DBRA    D1,ACROSS2                      ;LOOP FOR ALL LONGS
        DBRA    D2,ACROSS1                      ;BOLD RIGHT 2,3, OR 4 TIMES


;---------------------------------------------------------------------
;
;  BOLD BUF2 DOWN ENOUGH FOR SHADOW
;
        MOVE.L  BUF2START(A6),A2                ;GET LIMIT POINTER
DOWN1   MOVE.L  BUF2END(A6),A1                  ;DSTPTR:=END OF BUF2
        MOVE.L  A1,A0
        SUB     SRCBITS+ROWBYTES(A6),A0         ;SRCPTR:=END - 1 SCANLINE
DOWN2   MOVE.L  -(A0),D0                        ;GET A LONG FROM LINE ABOVE
        OR.L    D0,-(A1)                        ;OR INTO THIS LINE
        CMP.L   A2,A0                           ;IS SRCPTR <= BUF2START ?
        BGT     DOWN2                           ;NO, LOOP ALL LONGS
        DBRA    D3,DOWN1                        ;BOLD DOWN 2,3, OR 4 TIMES


;-------------------------------------------
;
;  ALTER SRCBITS TO USE BUF2
;
        MOVE.L  A2,SRCBITS+BASEADDR(A6)         ;SRC BASEADDR:=BUF2START
        ADD     #4,SRCBITS+BOUNDS+BOTTOM(A6)    ;4 SCANS TALLER


;----------------------------------------------------
;
;  PUSH PARAMS AND CALL StretchBits TO TRANSFER SHADOW TO SCREEN
;
        MOVE.L  TEXTRECT(A6),SRCRECT(A6)        ;SRCRECT := TEXTRECT
        MOVE.L  TEXTRECT+4(A6),SRCRECT+4(A6)
        ADD     #4,SRCRECT+BOTTOM(A6)           ;PLUS 4 SCANS TALLER

        MOVE.L  SRCRECT(A6),DSTRECT(A6)         ;DSTRECT := SRCRECT
        MOVE.L  SRCRECT+4(A6),DSTRECT+4(A6)
        SUB     #1,DSTRECT+TOP(A6)              ;OFFSET (-1,-1)
        SUB     #1,DSTRECT+LEFT(A6)
        SUB     #1,DSTRECT+BOTTOM(A6)
        SUB     #1,DSTRECT+RIGHT(A6)

        TST.B   STRETCH(A6)
        BEQ.S   @1
        PEA     DSTRECT(A6)
        PEA     FROMRECT(A6)
        PEA     TORECT(A6)
        JSR     MAPRECT                         ;THEN MAPPED FOR SCALING
@1

        PEA     SRCBITS(A6)                     ;PUSH SRCBITS
        PEA     DSTBITS(A6)                     ;PUSH DSTBITS
        PEA     SRCRECT(A6)                     ;PUSH SRCRECT
        PEA     DSTRECT(A6)                     ;PUSH DSTRECT
        MOVEQ   #3,D0
        AND     TXMODE(A3),D0                   ;GET TEXTMODE MOD 4
        MOVE    D0,-(SP)                        ;PUSH SHADOW MODE
        MOVE.L  CLIPRGN(A3),-(SP)               ;PUSH CLIPRGN HANDLE
        MOVE.L  VISRGN(A3),-(SP)                ;PUSH VISRGN HANDLE
        PEA     FAKEPTR(A6)                     ;PUSH FAKE HANDLE
        JSR     StretchBits                     ;TRANSFER BUFFER TO SCREEN


;-------------------------
;
;  RESTORE ALTERED SRCBITS
;
        MOVE.L  BUFSTART(A6),SRCBITS+BASEADDR(A6)
        SUB     #4,SRCBITS+BOUNDS+BOTTOM(A6)


;----------------------------------------------------
;
;  PUSH PARAMS AND CALL StretchBits TO TRANSFER BUFFER TO SCREEN
;
NOSHAD  PEA     SRCBITS(A6)                     ;PUSH SRCBITS
        PEA     DSTBITS(A6)                     ;PUSH DSTBITS
        PEA     TEXTRECT(A6)                    ;PUSH SRCRECT = TEXTRECT
        PEA     TEXTR2(A6)                      ;PUSH DSTRECT = TEXTR2
        MOVE    TXMODE(A3),D0                   ;GET TEXTMODE
        TST.B   11(A4)                          ;ARE WE USING SHADOW ?
        BEQ.S   MODEOK                          ;NO, CONTINUE
        NEG     D0                              ;YES ALTER TXMODE
MODEOK  AND     #3,D0                           ;LIMIT TO 0..3
        MOVE    D0,-(SP)                        ;PUSH MODE
        MOVE.L  CLIPRGN(A3),-(SP)               ;PUSH CLIPRGN HANDLE
        MOVE.L  VISRGN(A3),-(SP)                ;PUSH VISRGN HANDLE
        PEA     FAKEPTR(A6)                     ;PUSH FAKE HANDLE
        JSR     StretchBits                     ;TRANSFER BUFFER TO SCREEN


GOHOME  MOVE.L  SAVESTK(A6),SP                  ;STRIP BUFFER
        MOVEM.L (SP)+,D0-D7/A1-A4               ;RESTORE REGS
        UNLINK  PARAMSIZE,'DRTEXT  '


        .END


ÿ