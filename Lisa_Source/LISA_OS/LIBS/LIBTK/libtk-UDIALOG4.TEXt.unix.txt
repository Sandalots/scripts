{UDialog4}   {Handles Page Headings & Page Margins}  {Copyright 1984 by Apple Computer, INC}

(*

 ORDER OF METHODS:

      CLASS              SUBCLASS OF      WHICH IS IN
    ------------------   -------------    -----------
    TStdPrintManager     TPrintManager    UABC3
    TLegendHeading       THeading         UABC3
    TPageDesignWindow    TDialogWindow    UDialog2
    TPagePlannerView     TPlannerView     UDialog3
    TPageLayoutBox       TLayoutBox       UDialog3
    TLgHdngLayoutBox     TPageLayoutBox   UDialog4
    TPageStatusDialog    TDialog          UDialog2

*)
{04/25/84 19:00 TLgHdngLayoutBox.MousePress -- don't invalidate the layout box
                    TPageStatusDialog.CREATE explicitly sets extentLRect's topLeft to zeroLPt}
{04/24/84 23:51  TPageDesignWindow.CREATE sets the status view's scrollPastEnd to zeroPt}
{04/24/84 18:00  TPageDesignWindow.CREATE allows scrolling in the status panel}
{04/23/84 12:18  In TStdPrintManager.SetDfltHeadings, supply a blank space before and after the
                    the '{TITLE)', so that a select-all followed by a font change will result in
                    the new font applying to the substituted string at print or page-preview time}
{04/17/84 17:16  Make the TPagePlannerView show no gray at the end.}
{04/15/84 0200   TPageDesignWindow.NewCommand frees panel's undoSelection as well as main selection}
{04/14/84 03:00  Removed pilotHeading from TPageLayoutBox; removed TPageLayoutBox.Free, consequently,
                        as well as TPageLayoutBox.Fields
                  Offset master as well as current Legend in TLegendHeading.OffsetBy}
{changed 04/14/84 0102 Major rewrite of TLgHdngLayoutBox.RecalcExtent & TP }
{changed 04/13/84 2230 TLgHdngLayoutBox.RecalcExtent doesn't call SetParaExtent; just uses legend's extent
                        & TPageLayoutBox.FreeManipulee sets SELF.manipulee to NIL after freeing
                        & TPageDesignWindow.NewCommand sets plannerView.currentLayoutBox to NIL
                            after freeing the LgHdngLayoutBox...}
{changed 04/13/84 1630 Changed to not using bolding on the margins-dialog heading}
{changed 04/11/84 2315 Do TopToBaseLine stuff in hdngs recalculation only if not fExperimenting...}
{changed 04/11/84 1700 Use dfltNewHeading global var in laucnhing new heading in TDialogDesignWindow.NewCmd,
                         and varPage and varTitle in TStdPrintManager.SetDfltHeadings;
                       In TPageStatusDialog.CREATE, use a CONST depending on libraryVersion to determine
                         the spacing between the boxes in the margins checkbox dialog}
{04/04/84 2300  Spring Prelim Release}
{01/29/84 1800  RELEASE TK8D}
{12/21/83 1657  RELEASE TK8A}


METHODS OF TStdPrintManager;


{$S DlgAlloc}
    FUNCTION TStdPrintManager.CREATE(object: TObject; heap: THeap): TStdPrintManager;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TStdPrintManager(TPrintManager.CREATE(object, heap));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
    PROCEDURE  TStdPrintManager.SetDfltHeadings;
        CONST   topFudge = 0;
                bottomFudge = 0;
        VAR anOffset:   LPoint;
            margins:    LRect;
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        margins := SELF.pageMargins;
        SetLPt(anOffset, 0, (margins.top + topFudge) DIV 2);
        SELF.headings.InsLast(TLegendHeading.CREATE(NIL, SELF.Heap, SELF, CONCAT(' {', varTitle, '} '), {+SW+}
            stdHdngTypeStyle, aTopCenter, anOffset, stdHdngBorders));

        SetLPt(anOffset, 0, - (ABS(margins.bottom + bottomFudge) DIV 2));
        SELF.headings.InsLast(TLegendHeading.CREATE(NIL, SELF.Heap, SELF,  CONCAT('-{', varPage, '}-'),
            stdHdngTypeStyle, aBottomCenter, anOffset, stdHdngBorders));

        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
    PROCEDURE TStdPrintManager.Init(itsMainView: TView; itsDfltMargins: LRect);
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        SUPERSELF.Init(itsMainView, itsDfltMargins);
        SELF.canEditPages := TRUE;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE  TStdPrintManager.EnterPageEditting;
        VAR window:             TWindow;
            pageDesignWindow:   TPageDesignWindow;
            pagePlannerView:    TPagePlannerView;
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        window := SELF.view.panel.window;
        window.CommitLast;
        IF SELF.layoutDialogBox = NIL THEN
            BEGIN
            pageDesignWindow := TPageDesignWindow.CREATE(NIL, SELF.Heap, SELF.view);
            SELF.layoutDialogBox := pageDesignWindow;
            END;
        window.PutUpDialogBox(SELF.layoutDialogBox);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S TK2Start}
    PROCEDURE  TStdPrintManager.ReactToPrinterChange;
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        SUPERSELF.ReactToPrinterChange;
        IF SELF.layoutDialogBox <> NIL THEN
            TPageDesignWindow(SELF.layoutDialogBox).layoutPanel.view.Resize(SELF.pageView.extentLRect);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TLegendHeading;

{$S DlgAlloc}
    FUNCTION  TLegendHeading.CREATE(object: TObject; heap: THeap; itsPrintManager: TPrintManager;
                     itsString: S255; itsTypeStyle: TTypeStyle;
                     itsPageAlignment: TPageAlignment; itsOffsetFromAlignment: LPoint;
                     itsBorders: Rect): TLegendHeading;
        VAR newMaster:  TLegend;
            newCurrent: TLegend;
            extent:     LRect;
            view:       TView;
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        view := itsPrintManager.pageView;
        SetLRect(extent, 0, 0, 100, 100);  {meaningless at this point}

        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TLegendHeading(THeading.CREATE(object, heap, itsPrintManager, extent, itsPageAlignment,
                                               itsOffsetFromAlignment));

        newMaster:= TLegend.CREATE(NIL, heap, itsString, view, zeroLPt, itsTypeStyle);
        newCurrent := TLegend.CREATE(NIL, heap, itsString, view,  zeroLPt, itsTypeStyle);
        newMaster.HaveView(view);
        newCurrent.HaveView(view);

        SetParaExtent(newMaster.paragraph, view, zeroLPt, extent);

        WITH SELF DO
            BEGIN
            masterLegend := newMaster;
            currentLegend := newCurrent;
            borders := itsBorders;
            minPage := 1;   {readjusts from std 2, for demo purposes}
            topToBaseline :=  - itsBorders.top - extent.top; {both tops are negative}
            END;

        newMaster.wouldBeDraggable := FALSE;
        newCurrent.wouldBeDraggable := FALSE;

        SELF.RecalcExtent;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE TLegendHeading.Free;
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        Free(SELF.masterLegend);
        Free(SELF.currentLegend);
        SUPERSELF.Free;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TLegendHeading.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('masterLegend: TLegend');
        Field('currentLegend: TLegend');
        Field('topToBaseline: INTEGER');
        Field('borders: Rect');
        Field('');
    END;
    {$ENDC}


{$S DlgRes}
    PROCEDURE TLegendHeading.AdjustForPage(pageNumber: LONGINT; editing: BOOLEAN);
        VAR currS255:           S255;
            aVariable:          S255;
            leftBracePos:       INTEGER;
            rightBracePos:      INTEGER;
            newValue:           S255;
            restOfString:       S255;
            newExtent:          LRect;
            currentParagraph:   TParagraph;
            masterParagraph:    TParagraph;
            substituted:        BOOLEAN;
            lastPosition:       INTEGER;
    BEGIN
        {$IFC fTrace}BP(9);{$ENDC}
        substituted := FALSE;  {still flawed}
        lastPosition := 0;
        SELF.masterLegend.GetString(currS255);
        currentParagraph := SELF.currentLegend.paragraph;
        masterParagraph := SELF.masterLegend.paragraph;
        currentParagraph.ReplPara(0, currentParagraph.size, masterParagraph, 0,
            masterParagraph.size);  {download entire master into current}
        IF NOT editing THEN
            BEGIN
            REPEAT
            leftBracePos := POS('{', currS255);
            IF leftBracePos > 0 THEN
                IF leftBracePos < lastPosition THEN {was within the previous variable}
                    currS255[leftBracePos] := '$'    {... so we won't get it next time}
                ELSE
                    BEGIN
                    restOfString := COPY(currS255, leftBracePos + 1, LENGTH(currS255) - leftBracePos);
                    rightBracePos := POS('}', restOfString);
                    IF rightBracePos > 0 THEN
                        BEGIN
                        aVariable := COPY(restOfString, 1, rightBracePos - 1);
                        SELF.printManager.view.SetFunctionValue(aVariable, newValue);
                        substituted := TRUE;
                        currentParagraph.ReplPString(leftBracePos - 1, rightBracePos + 1,
                            @newValue);

                        DELETE(currS255, leftBracePos, rightBracePos + 1);  {get rid of the var code}
                        INSERT(newValue, currS255, leftBracePos);  {substitute the variable's value}
                        currS255[leftBracePos] := '$';
                        lastPosition := leftBracePos + LENGTH(newValue);
                        END
                    ELSE
                        lastPosition := LENGTH(currS255) + 1;
                    END;
            UNTIL
                leftBracePos = 0;

            END   {not editing}

        ELSE  {editing}
            SELF.masterLegend.GetBoxRight;

        SELF.RecalcExtent;  {tells currentLegend to get box right, then adds in my borders}
       {we only need worry about our extentLRect, our location, and our current legend all
         being in synch; THeading.LocateOnPage will then find the exact page location,
         taking into account my offsetFromAlignment}

        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgRes}
    PROCEDURE TLegendHeading.Draw;
    BEGIN
        {$IFC fTrace}BP(9);{$ENDC}
        IF SELF.ShouldFrame THEN
            FrameLRect(SELF.extentLRect);
        SELF.currentLegend.Draw;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    FUNCTION TLegendHeading.LaunchLayoutBox(view: TView): TImage;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        LaunchLayoutBox := TLgHdngLayoutBox.CREATE(NIL, SELF.Heap, view, SELF);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE TLegendHeading.OffsetBy(deltaLPt: LPoint);
    BEGIN
        {$IFC fTrace}BP(9);{$ENDC}
        SELF.currentLegend.OffsetBy(deltaLPt);
        SUPERSELF.OffsetBy(deltaLPt);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S TK2Start}
    PROCEDURE TLegendHeading.RecalcExtent;
        VAR newExtent:  LRect;
    BEGIN
        {$IFC fTrace}BP(9);{$ENDC}
        SELF.currentLegend.GetBoxRight;
        LRectAddBorders(SELF.currentLegend.extentLRect, SELF.borders, newExtent);
        SELF.Resize(newExtent);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgRes}
    FUNCTION TLegendHeading.ShouldFrame;
    BEGIN
        {$IFC fTrace}BP(9);{$ENDC}
        ShouldFrame := FALSE;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TPageDesignWindow;


{$S DlgAlloc}
    FUNCTION TPageDesignWindow.CREATE(object: TObject; heap: THeap; itsHostView: TView): TPageDesignWindow;
        CONST   cPgWindowHeight = 340;
                cPgControlHeight = 130; {height of the control (status) panel}
                cHtStatusView = 220;

        VAR controlPanel:   TPanel;
            layoutPanel:    TPanel;
            hdngDialog:     THeadingDialog;
            plannerView:    TPlannerView;
            dialogView:     TDialogView;
            extentLRect:    LRect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TPageDesignWindow(TDialogWindow.CREATE(object, heap, TRUE, cPgWindowHeight, diAccept,
                                                       diAccept, diRefuse));

        SELF.hostView := itsHostView;

        layoutPanel := TPanel.CREATE(NIL, heap, SELF, 0, 0, [aScroll, aSplit], [aScroll, aSplit]);
        plannerView := TPagePlannerView.CREATE(NIL, heap, itsHostView.printManager, layoutPanel);
        SELF.layoutPanel := layoutPanel;

        controlPanel  := layoutPanel.Divide(v, cPgControlHeight, pixelsFromEdge,
                [userCanResizeIt], 10 {min size}, [aScroll], [aScroll]);  {+SW+}
        SELF.controlPanel := controlPanel;
        SetLRect(extentLRect, 0, 0, screenBits.bounds.right, cHtStatusView);
        dialogView := TDialogView.CREATE(NIL, heap, extentLRect, controlPanel, NIL, screenRes);
        dialogView.scrollPastEnd := zeroPt; {+SW+}
        dialogView.AddDialog(TPageStatusDialog.CREATE(NIL, heap, dialogView.panel));

        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    PROCEDURE TPageDesignWindow.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('hostView: TView');
        Field('layoutPanel: TPanel');
        Field('');
    END;
   {$ENDC}


    PROCEDURE TPageDesignWindow.Disappear;
        VAR panel:  TPanel;
     BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        panel := TPagePlannerView(SELF.layoutPanel.view).viewBeingPlanned.panel;
        IF panel.previewMode = mPrvwMargins THEN {make sure headings are updated}
            panel.Invalidate;
        SUPERSELF.Disappear;
        {$IFC fTrace}EP;{$ENDC}
     END;


{$S HdgMarg}
    FUNCTION  TPageDesignWindow.NewCommand(cmdNumber: TCmdNumber): TCommand;
    {unusually, uClear is armed by TLayPickSelection.NewCommand but dealt with by the PageDesignWindow}
        VAR s:              TListScanner;
            layoutBox:      TLayoutBox;
            plannerView:    TPlannerView;
            noSelection:    TSelection;
            command:        TCommand;
            selectedBox:    TLayoutBox;
            panel:          TPanel;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        CASE cmdNumber OF
            uClear:  {not undoable at present...}
                BEGIN
                SELF.CommitLast; {The committal might require a to-be-freed textImage}
                plannerView := TPlannerView(SELF.layoutPanel.view);
                panel := plannerView.panel;
                selectedBox := plannerView.currentLayoutBox;
                s := plannerView.rootDialogImage.children.Scanner;
                WHILE s.Scan(layoutBox) DO
                    IF layoutBox = selectedBox THEN
                        BEGIN
                        panel.selection.Deselect;
                        noSelection := panel.undoSelection.FreedAndReplacedBy(panel.view.NoSelection);
                        panel.InvalLRect(layoutBox.extentLRect);
                        layoutBox.FreeManipulee;   {Delete heading from the printManager}
                        s.Delete(TRUE);            {Delete heading's layout box from the plannerView}
                        s.Done;
                        END;
                command := TCommand.CREATE(NIL, plannerView.Heap, uClear, plannerView, FALSE,
                                            revealNone);
                NewCommand := command;
                plannerView.currentLayoutBox := NIL;
                TPageStatusDialog(SELF.mainDialog).currentHeading := NIL;
                END;

            OTHERWISE
                NewCommand := SUPERSELF.NewCommand(cmdNumber);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;

{$S DlgInit}
END;


METHODS OF TPagePlannerView;


{$S DlgAlloc}
    FUNCTION TPagePlannerView.CREATE(object: TObject; heap: THeap; itsPrintManager: TPrintManager;
                                        itsPanel: TPanel): TPagePlannerView;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TPagePlannerView(TPlannerView.CREATE(object, heap, itsPrintManager.pageView, itsPanel,
                                                     FALSE, TRUE));
        PushFocus;
        TPane(itsPrintManager.view.panel.panes.First).Focus;  {so that thePad will be set to something}
        SELF.Init(itsPrintManager.headings);
        PopFocus;

        SELF.scrollPastEnd := zeroPt;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE TPagePlannerView.Draw;
        VAR contentLRect:   LRect;
            pat:            Pattern;
            contentRect:    Rect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        contentLRect := SELF.viewBeingPlanned.printManager.contentLRect;   {screen embellishments}
        thePad.LPatToPat(marginPattern, pat);
        thePad.LRectToRect(contentLRect, contentRect);
        FillRect(contentRect, pat);

        PenNormal;
        FrameLRect(SELF.extentLRect);
        FrameLRect(contentLRect);

        SUPERSELF.Draw;   {draw LayoutBoxes}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TPageLayoutBox;

{$S HdgMarg}
    FUNCTION  TPageLayoutBox.CREATE(object: TObject; heap: THeap; itsView: TView; itsHeading: THeading;
                itsResizable: BOOLEAN): TPageLayoutBox;
            VAR baseExtent: LRect;
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        baseExtent := itsHeading.extentLRect;
        baseExtent.top := baseExtent.top + stdSlimTitleHeight;
        IF object = NIL THEN
            object := NewObject(itsHeading.Heap, THISCLASS);
        SELF := TPageLayoutBox(TLayoutBox.CREATE(object, heap, baseExtent, noID, NIL,
                                            itsView, itsHeading, stdPlainBorders, itsResizable,
                                            TRUE, TRUE));
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TPageLayoutBox.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('');
    END;
    {$ENDC}


{$S HdgMarg}
    PROCEDURE TPageLayoutBox.FreeManipulee;
        VAR s:          TListScanner;
            heading:    THeading;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        s := TPlannerView(SELF.view).viewBeingPlanned.view.printManager.headings.Scanner;
        WHILE s.Scan(heading) DO
            IF heading = SELF.manipulee THEN
                BEGIN
                s.Delete(TRUE);
                s.Done;
                SELF.manipulee := NIL;
                END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE TPageLayoutBox.TabGrabbed;
        VAR heading:            THeading;
            pageStatusDialog:   TPageStatusDialog;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        heading := THeading(SELF.manipulee);
        pageStatusDialog := TPageStatusDialog(TDialogView(TDialogWindow(SELF.view.panel.window
            ).controlPanel.view).rootDialog.children.First);
        IF heading <> pageStatusDialog.currentHeading THEN
            BEGIN
            WITH heading DO
       {$H-}    pageStatusDialog.SetHeadingParms(oddOnly, evenOnly, pageAlignment, minPage, maxPage); {$H+}
            pageStatusDialog.currentHeading := heading;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TLgHdngLayoutBox;

{$S HdgMarg}
    FUNCTION  TLgHdngLayoutBox.CREATE(object: TObject; heap: THeap; itsView: TView;
                itsLegendHeading: TLegendHeading): TLgHdngLayoutBox;
        VAR myExtent:           LRect;
            itsTitleTab:        TTitleTab;
            masterLegend:       TLegend;
            legendLayoutBox:    TLegendLayoutBox; {= SELF.children.First}
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        itsLegendHeading.AdjustForPage(0, TRUE);
        itsLegendHeading.LocateOnPage(TRUE);
        masterLegend := itsLegendHeading.masterLegend;
        masterLegend.location := itsLegendHeading.currentLegend.location;
        masterLegend.GetBoxRight;

        LRectAddBorders(masterLegend.extentLRect, itsLegendHeading.borders, myExtent);

        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TLgHdngLayoutBox(TImageWithID.CREATE(object, heap, myExtent, noID,
                itsView, TRUE));

        itsTitleTab := TTitleTab.CREATE(NIL, heap, SELF,  stdSlimTitleHeight, noID);

        WITH SELF DO
            BEGIN
            titleTab := itsTitleTab;
            manipulee := itsLegendHeading;
            suppressDrawingManipulee := TRUE;
            wouldMakeSelection := TRUE;
            isResizable := FALSE;
            isDraggable := TRUE;
            shouldFrame := TRUE;
            borders := zeroRect;
            END;

        legendLayoutBox := TLegendLayoutBox(itsLegendHeading.masterLegend.LaunchLayoutBox(itsView));
        SELF.legendLayoutBox := legendLayoutBox;
        SELF.AddImage(legendLayoutBox);

        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TLgHdngLayoutBox.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('legendLayoutBox: TLegendLayoutBox');
        Field('');
    END;
    {$ENDC}


{$S HdgMarg}
    FUNCTION TLgHdngLayoutBox.CursorAt(mouseLPt: LPoint): TCursorNumber;
        BEGIN
            {$IFC fTrace}BP(11);{$ENDC}
            IF SELF.Hit(mouseLPt) THEN
                IF SELF.titleTab.Hit(mouseLPt) THEN
                    CursorAt := arrowCursor
                ELSE
                    CursorAt := textCursor
            ELSE
                CursorAt := noCursor;
            {$IFC fTrace}EP;{$ENDC}
        END;


{$S HdgMarg}
    PROCEDURE TLgHdngLayoutBox.Draw;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF LRectIsVisible(SELF.extentLRect) THEN
            BEGIN
            SELF.titleTab.Draw;
            PenNormal;
            FrameLRect(SELF.extentLRect);  {draw overall box}
            SELF.legendLayoutBox.Draw;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE TLgHdngLayoutBox.MousePress(mouseLPT: LPoint);
        VAR layoutBox:              TLayoutBox;
            s:                      TListScanner;
            editLegendSelection:    TEditLegendSelection;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        LRectHaveLPt(SELF.legendLayoutBox.extentLRect, mouseLPt);
        editLegendSelection := TEditLegendSelection(SELF.view.panel.selection.FreedAndReplacedBy(
                                           TEditLegendSelection.CREATE(NIL, SELF.Heap,
                                               SELF.legendLayoutBox,
                                               mouseLPT)));
        SELF.TabGrabbed; {get report on me right in the page status panel}
        editLegendSelection.textDialogImage.MousePress(mouseLPt);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE TLgHdngLayoutBox.Move(deltaLPt: LPoint);
        VAR legendHeading:  TLegendHeading;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        SUPERSELF.Move(deltaLPt);  {offsets and invalidates}
        legendHeading := TLegendHeading(SELF.manipulee);
        legendHeading.masterLegend.OffsetBy(deltaLPt);
  {$H-} LPtPlusLPt(legendHeading.offsetFromAlignment, deltaLPt, legendHeading.offsetFromAlignment);  {$H+}
    {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE TLgHdngLayoutBox.RecalcExtent;
        VAR newExtent:          LRect;
            oldExtent:          LRect;
            deltaLPt:           LPoint;
            newBaseLPoint:      LPoint;
            borders:            Rect;
            masterLegend:       TLegend;
            oldTopToBaseline:   LONGINT;
            newTopToBaseline:   LONGINT;
            legendHeading:      TLegendHeading;
            textExtent:         LRect;
            alignedToTop:       BOOLEAN;
            oldDescent:         INTEGER;
        PROCEDURE InvalOldAndNew;
            BEGIN
            thePad.InvalLRect(oldExtent);
            thePad.InvalLRect(newExtent);
            END;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        oldExtent := SELF.extentLRect;
        legendHeading := TLegendHeading(SELF.manipulee);
        masterLegend := legendHeading.masterLegend;

        borders := legendHeading.borders;
        oldTopToBaseline := legendHeading.topToBaseline;

        SetParaExtent(masterLegend.paragraph, SELF.view, zeroLpt, textExtent);
        newTopToBaseline :=  - borders.top - textExtent.top;

        alignedToTop := legendHeading.pageAlignment IN [aTopLeft, aTopCenter, aTopRight];

        IF newTopToBaseline <> oldTopToBaseline THEN
            BEGIN
            IF alignedToTop THEN
                legendHeading.offsetFromAlignment.v := legendHeading.offsetFromAlignment.v +
                    oldTopToBaseline - newTopToBaseline
            ELSE {bottom alignment}
                BEGIN
                WITH oldExtent DO
                    oldDescent := bottom - top - oldTopToBaseline;
                legendHeading.offsetFromAlignment.v := legendHeading.offsetFromAlignment.v -
                    textExtent.bottom + oldDescent;
                END;
            legendHeading.topToBaseline := newTopToBaseline;
            END;

        LRectAddBorders(SELF.legendLayoutBox.extentLRect, borders, newExtent);
        legendHeading.Resize(newExtent);

        legendHeading.LocateOnPage(TRUE);
        newExtent := legendHeading.extentLRect;

        SetLPt(newBaseLPoint, newExtent.left - borders.left, newExtent.top + newTopToBaseline);
        masterLegend.location := newBaseLPoint;
        masterLegend.GetBoxRight;
        SELF.Resize(newExtent);

        LPtMinusLPt(newExtent.topLeft, oldExtent.topLeft, deltaLPt);
        SELF.legendLayoutBox.OffsetLayoutBoxBy(deltaLPt, FALSE);   {its manipulee already ok}


        IF NOT equalLRect(oldExtent, newExtent) THEN
            SELF.view.panel.OnAllPadsDo(InvalOldAndNew);

        SELF.TabGrabbed; {update page-status-dialog report panel}
        {$IFC fTrace}EP;{$ENDC}
    END;



{$S DlgInit}
END;


METHODS OF TPageStatusDialog;   {the status dialog in the PageDesign window}


{$S DlgAlloc}
    FUNCTION TPageStatusDialog.CREATE(object: TObject; heap: THeap; itsPanel: TPanel): TPageStatusDialog;
        CONST
{$IFC libraryVersion <= 20}
            spcAdjustment = -1;
{$ELSEC}                            { S P R I N G }
            spcAdjustment = -1;
{$ENDC}
        VAR cluster:        TCluster;
            aNumberString:  S255;
            inputFrame:     TInputFrame;
            button:         TButton;
            promptLoc:      LPoint;
            inputLoc:       LPoint;
            borders:        Rect;
            checkbox:       TCheckbox;
            newImage:       TDialogImage;
            typeStyle:      TTypeStyle;
            labelOffset:    Point;
            legend:         TLegend;
            boxSpacing:     INTEGER;
            itsID:          S255;
            itsLocation:    LPoint;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TPageStatusDialog(TDialog.CREATE(object, heap, 'PAGE', itsPanel.view));

        SELF.currentHeading := NIL;

        MakeTypeStyle(famModern, size12Pitch, [], typeStyle);

        SetPt(labelOffset, 6, 0);
        cluster := SELF.NewCluster(phOddEven);
        checkbox := cluster.NewCheckbox(phOddOnly, stdBoxWidth - 3, stdBoxHeight - 2,
            TRUE, labelOffset, typeStyle, FALSE);
        checkbox := cluster.NewAlignedCheckbox(phEvenOnly, FALSE);
        checkbox := cluster.NewAlignedCheckbox(phOddOrEven, TRUE);
        SELF.oddEvenCluster := cluster;

        SetRect(borders, -18, -2, 18, 2);
        inputFrame := SELF.NewInputFrame(phMinPage, typeStyle, stdFrmeOffset, stdInputTypeStyle, 6,
             borders, FALSE, FALSE);
        LIntToStr(2, @aNumberString);
        inputFrame.SupplantContents(aNumberString);
        SELF.minPageFrame := inputFrame;

        inputFrame := SELF.NewInputFrame(phMaxPage, typeStyle, stdFrmeOffset, stdInputTypeStyle, 6,
            borders, FALSE, FALSE);
        inputFrame.SupplantContents('------');
        SELF.maxPageFrame := inputFrame;

        cluster := SELF.NewCluster(phAlignment);
        checkbox := cluster.NewCheckbox(phTopLeft, stdBoxWidth - 3, stdBoxHeight - 2, TRUE,
            labelOffset, typeStyle, FALSE);
        checkbox := cluster.NewAlignedCheckbox(phTopCenter, TRUE);
        checkbox := cluster.NewAlignedCheckbox(phTopRight, FALSE);

        checkbox := cluster.NewCheckbox(phBotLeft, stdBoxWidth - 3, stdBoxHeight - 2, TRUE,
            labelOffset, typeStyle, FALSE); {for second row}
        checkbox := cluster.NewAlignedCheckbox(phBotCenter, FALSE);
        checkbox := cluster.NewAlignedCheckbox(phBotRight, FALSE);
        SELF.alignCluster := cluster;

        button := SELF.NewButton(phLaunchHeading, stdButtonMetrics, NIL, NoCmdNumber);
        SELF.AddOKButton(noCmdNumber);

        MakeTypeStyle(famModern, size10Pitch, [bold], typeStyle);
        legend := SELF.NewLegend(phPageMargins, typeStyle);

        MakeTypeStyle(famModern, size12Pitch, [bold], typeStyle);
        cluster := SELF.NewCluster(phUnits);
        SELF.unitsCluster := cluster;
        checkbox := cluster.NewCheckbox(phInches, stdBoxWidth - 3, stdBoxHeight - 2, TRUE,
            labelOffset, typeStyle, TRUE);
        checkbox := cluster.NewAlignedCheckbox(phCentimeters, FALSE);

        MakeTypeStyle(famModern, size15Pitch, [], typeStyle);
        legend := SELF.AddStdLegend('0.25  0.50  0.75  1.00  1.25  1.50  1.75  2.00  2.25  2.50',
                    96, 140, typeStyle);
        SELF.marginTitle := legend;

        boxSpacing := stdBoxSpacing + spcAdjustment;

        legend := SELF.NewLegend(phLeft, sysTypeStyle);
        cluster := SELF.NewRowOfBoxes(phLeftCluster, 10, 100, stdBoxWidth,
            stdBoxHeight, boxSpacing);
        cluster.selectBox(TCheckbox(cluster.ObjectWithIDNumber(103)));  {make this the real thing someday}
        SELF.leftCluster := cluster;

        legend := SELF.NewLegend(phTop, sysTypeStyle);
        cluster := SELF.NewRowOfBoxes(phTopCluster, 10, 200, stdBoxWidth, stdBoxHeight, boxSpacing);
        cluster.selectBox(TCheckbox(cluster.ObjectWithIDNumber(203)));  {make this the real thing someday}
        SELF.topCluster := cluster;

        legend := SELF.NewLegend(phRight, sysTypeStyle);
        cluster := SELF.NewRowOfBoxes(phRightCluster, 10, 300, stdBoxWidth, stdBoxHeight, boxSpacing);
        cluster.selectBox(TCheckbox(cluster.ObjectWithIDNumber(303)));  {make this the real thing someday}
        SELF.rightCluster := cluster;

        legend := SELF.NewLegend(phBottom, sysTypeStyle);
        cluster := SELF.NewRowOfBoxes(phBotCluster, 10, 400, stdBoxWidth, stdBoxHeight, boxSpacing);
        cluster.selectBox(TCheckbox(cluster.ObjectWithIDNumber(403)));  {make this the real thing someday}
        SELF.bottomCluster := cluster;

        button := SELF.NewButton(phInstallMargins, stdButtonMetrics, NIL, noCmdNumber);
        SELF.extentLRect.topLeft := zeroLPt; {+SW+}
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TPageStatusDialog.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('currentHeading: THeading');
        Field('oddEvenCluster: TCluster');
        Field('minPageFrame: TInputFrame');
        Field('maxPageFrame: TInputFrame');
        Field('alignCluster: TCluster');
        Field('unitsCluster: TCluster');
        Field('marginTitle: TLegend');
        Field('leftCluster: TCluster');
        Field('topCluster: TCluster');
        Field('rightCluster: TCluster');
        Field('bottomCluster: TCluster');
        Field('');
    END;
    {$ENDC}


{$S HdgMarg}
    PROCEDURE TPageStatusDialog.ButtonPushed(button: TButton);
        VAR heading:        THeading;
            cluster:        TCluster;
            hitBoxID:       INTEGER;
            theS255:        S255;
            inputFrame:     TInputFrame;
            minPage:        LONGINT;
            maxPage:        LONGINT;
            pane:           TPane;
            pageDesignWindow:   TPageDesignWindow;
            plannerView:     TPlannerView;
            offset:         LPoint;
            layoutBox:      TLayoutBox;
            pageAlignment:  TPageAlignment;
            checkbox:       TCheckbox;
            oddOnly:        BOOLEAN;
            evenOnly:       BOOLEAN;
            newMargins:     LRect;
            panel:          TPanel;
            inches:         BOOLEAN;
            plannerPanel:   TPanel;
            editLegendSelection: TEditLegendSelection;
            noSelection:    TSelection;
        FUNCTION Margin(cluster: TCluster; baseID: INTEGER; vhs: vhSelect): INTEGER;
                VAR hitBox: TCheckbox;
                    boxOrd: INTEGER;
            BEGIN
            hitBox := cluster.hiLitBox;
            IF hitBox = NIL THEN
                boxOrd := 1
            ELSE
                boxOrd := hitBox.idNumber - baseID + 1;
            IF inches THEN
                Margin := (pageDesignWindow.hostView.res.vh[vhs] * boxOrd) DIV 4
                {because it's in quarter of inches right now}
            ELSE {operating in centimeters}
                Margin := LIntDivInt(pageDesignWindow.hostView.res.vh[vhs] * boxOrd * ORD4(100), 508);
            END;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        pageDesignWindow := TPageDesignWindow(SELF.view.panel.window);
        plannerView := TPlannerView(pageDesignWindow.layoutPanel.view);
        IF button.idNumber = phLaunchHeading THEN  {launch a heading AND a corresponding new layout box}
            BEGIN
            offset := zeroLPt;  {default in case no ...}

            cluster := SELF.alignCluster;
            IF cluster.hiLitBox = NIL THEN
                cluster.SelectBox(TCheckbox(cluster.ObjectWithIDNumber(phTopCenter)));    {bulletproofing?}

            SELF.InspectHeadingParms(oddOnly, evenOnly, pageAlignment, minPage, maxPage);

            CASE pageAlignment OF
                aTopLeft:       SetLPt(offset, 80, 30);
                aTopCenter:     SetLPt(offset, 0, 30);
                aTopRight:      SetLPt(offset, -80, 30);
                aBottomLeft:    SetLPt(offset, 80, -30);
                aBottomCenter:  SetLPt(offset, 0, -30);
                aBottomRight:   SetLPt(offset, -80, -30);
                END; {CASE}

            IF minPage = maxPage THEN
                IF odd(minPage) THEN
                    evenOnly := FALSE
                ELSE
                    oddOnly := FALSE;  {keep user from launching a nowhere-printable heading}

            heading := TLegendHeading.CREATE(NIL, SELF.Heap, pageDesignWindow.hostView.printManager,
                dfltNewHeading, stdHdngTypeStyle, pageAlignment, offset, stdHdngBorders);

            heading.minPage := minPage;
            heading.maxPage := maxPage;

            heading.oddOnly := oddOnly;
            heading.evenOnly := evenOnly;

            PushFocus;
            TPane(SELF.view.panel.panes.First).Focus;  {so that thePad will be set to something}

            pageDesignWindow.hostView.printManager.headings.InsLast(heading);
            heading.AdjustForPage(0, TRUE);
            heading.LocateOnPage(TRUE);

            SELF.currentHeading := heading;
            layoutBox := plannerView.NewLayoutBox(heading);
            IF layoutBox <> NIL THEN
                BEGIN
                plannerPanel := plannerView.panel;
                plannerView.rootDialog.AddImage(layoutBox);
                plannerPanel.BeginSelection;
                editLegendSelection := TEditLegendSelection(plannerPanel.selection.FreedAndReplacedBy(
                                TEditLegendSelection.CREATE(NIL, SELF.Heap,
                                TLgHdngLayoutBox(layoutBox).legendLayoutBox, zeroLPt)));
                editLegendSelection.coSelection.Become(
                        editLegendSelection.textDialogImage.textImage.text.SelectAll(
                        editLegendSelection.textDialogImage.textImage));
                plannerPanel.InvalLRect(layoutBox.extentLRect);
                plannerView.currentLayoutBox := layoutBox;
                END;

            TDialogView(SELF.view).AbandonThatButton; {turn off highlighting}

            PopFocus;

            currentWindow.PerformCommand(TCommand.CREATE(NIL, SELF.Heap, uCmdLaunchHeading, plannerView,
                FALSE, revealAll));
            END

        ELSE

        IF button.idNumber = phInstallMargins THEN
            BEGIN
            inches := SELF.unitsCluster.hilitBox.idNumber = phInches;
            newMargins.left := Margin(SELF.leftCluster, 100, h);
            newMargins.top := Margin(SELF.topCluster, 200, v);
            newMargins.right := Margin(SELF.rightCluster, 300, h);
            newMargins.bottom := Margin(SELF.bottomCluster, 400, v);
            pageDesignWindow.hostView.printManager.ChangeMargins(newMargins);
            TDialogView(SELF.view).AbandonThatButton; {turn off highlighting}
            plannerView.panel.InvalLRect(plannerView.extentLRect);   {redraw layout panel with chgd margins}
            currentWindow.PerformCommand(TCommand.CREATE(NIL, SELF.Heap, uCmdInstallMargins, plannerView,
                FALSE, revealNone));
            END

        ELSE  {ok button}

            BEGIN
            panel := plannerView.panel;
            panel.window.CommitLast;
            noSelection := panel.undoSelection.FreedAndReplacedBy(panel.view.NoSelection);
            panel.selection.Deselect;
            SUPERSELF.ButtonPushed(button);  {will give OK dismissal to dialog}
            END;

       {$IFC fTrace}EP;{$ENDC}
   END;


{$S HdgMarg}
    PROCEDURE TPageStatusDialog.InspectHeadingParms(VAR oddOnly, evenOnly: BOOLEAN;
                    VAR pageAlignment: TPageAlignment; VAR minPage, maxPage: LONGINT);
        VAR heading:            THeading;
            newPageAlignment:   TPageAlignment;
            theS255:            S255;
            checkbox:           TCheckbox;
            cState:             TConvResult;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        checkbox := SELF.oddEvenCluster.hiLitBox;

        IF checkbox = NIL THEN
            BEGIN
            oddOnly := FALSE;
            evenOnly := FALSE;
            END
        ELSE
            BEGIN
            oddOnly := (checkbox.idNumber = phOddOnly);
            evenOnly := (checkbox.idNumber = phEvenOnly);
            END;

        checkbox := SELF.alignCluster.hiLitBox;
        IF checkbox = NIL THEN
            pageAlignment := aTopCenter
        ELSE
        CASE checkbox.idNumber OF
            phTopLeft:       pageAlignment := aTopLeft;
            phTopCenter:     pageAlignment := aTopCenter;
            phTopRight:      pageAlignment := aTopRight;
            phBotLeft:       pageAlignment := aBottomLeft;
            phBotCenter:     pageAlignment := aBottomCenter;
            phBotRight:      pageAlignment := aBottomRight;
            END;

        SELF.maxPageFrame.GetContents(theS255);
        StrToLInt(@theS255, maxPage, cState);
        IF (cState <> cvValid) OR (maxPage <= 0) THEN
            BEGIN
            maxPage := MAXLINT;
            SELF.maxPageFrame.SupplantContents('------');
            END;

        SELF.minPageFrame.GetContents(theS255);
        StrToLInt(@theS255, minPage, cState);
        IF (cState <> cvValid) OR (minPage > maxPage) THEN
            BEGIN
            minPage := 1;
            SELF.minPageFrame.SupplantContents('1');
            END;

       {$IFC fTrace}EP;{$ENDC}
   END;


{$S HdgMarg}
    PROCEDURE TPageStatusDialog.SetHeadingParms(oddOnly, evenOnly: BOOLEAN;
                        pageAlignment: TPageAlignment;  minPage, maxPage: LONGINT);
        VAR heading:            THeading;
            newPageAlignment:   TPageAlignment;
            theS255:            S255;
            checkbox:           TCheckbox;
            targetID:           INTEGER;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF oddOnly THEN
            targetID := phOddOnly
        ELSE
        IF evenOnly THEN
            targetID := phEvenOnly
        ELSE
            targetID := phOddOrEven;
        SELF.oddEvenCluster.SelectBox(TCheckbox(SELF.oddEvenCluster.ObjectWithIDNumber(targetID)));

        CASE pageAlignment OF
            aTopLeft:       targetID := phTopLeft;
            aTopCenter:     targetID := phTopCenter;
            aTopRight:      targetID := phTopRight;
            aBottomLeft:    targetID := phBotLeft;
            aBottomCenter:  targetID := phBotCenter;
            aBottomRight:   targetID := phBotRight;
            END;

        SELF.alignCluster.SelectBox(TCheckbox(SELF.alignCluster.ObjectWithIDNumber(targetID)));

        IntToStr(minPage, @theS255);
        SELF.minPageFrame.SupplantContents(theS255);

        IF maxPage = maxLInt THEN
            theS255 := '------'
        ELSE
            IntToStr(maxPage, @theS255);
        SELF.maxPageFrame.SupplantContents(theS255);
       {$IFC fTrace}EP;{$ENDC}
   END;


{$S HdgMarg}
    PROCEDURE TPageStatusDialog.CheckboxHit(checkbox: TCheckbox; toggleDirection: BOOLEAN);
        VAR heading:            THeading;
            newPageAlignment:   TPageAlignment;
            newTitle:           S255;
            phIndex:            INTEGER;
            dummy:              LPoint;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF checkBox.parent = SELF.unitsCluster THEN
            BEGIN
            IF checkbox.idNumber = phInches THEN
                phIndex := phInchTitle
            ELSE
                phIndex := phCmTitle;
            GetTextAndLocation(phIndex, newTitle, dummy);
            SELF.marginTitle.ChangeString(newTitle);
            END;
       {$IFC fTrace}EP;{$ENDC}
   END;


{$S HdgMarg}
    FUNCTION TPageStatusDialog.DownAt(mouseLPt: LPoint): TDialogImage;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.currentHeading := NIL;
        DownAt := SUPERSELF.DownAt(mouseLPt);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S HdgMarg}
    PROCEDURE TPageStatusDialog.Draw;
        CONST   horizLine = 100;
                vertLine = 570;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SUPERSELF.Draw; {draw the dialog}
        MoveToL(0, horizLine);
        PenNormal;
        PenSize(3, 2);
        LineToL(SELF.view.extentLRect.right, horizLine);
        MoveToL(vertLine, 0);
        LineToL(vertLine, horizLine);
       {$IFC fTrace}EP;{$ENDC}
   END;



{$S DlgInit}
END;


ÿ