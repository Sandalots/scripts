UNIT UDraw;
{Copyright 1983, 1984, Apple Computer, Inc.}

{changed 05/01 1503 Changes to allow people to use Clascal on the Workshop}

{$Setc IsIntrinsic := TRUE }

{$IFC IsIntrinsic}
INTRINSIC;
{$ENDC}

INTERFACE

USES
    {$U UnitStd     } UnitStd,      {Client should not USE UnitStd}
    {$U UnitHz      } UnitHz,       {Client should not USE UnitHz and MUST NOT USE Storage}
    {$U libtk/UObject} UObject,           {Client must USE UObject}
    {$U LIBOS/SysCall} SysCall,     {Client may USE SysCall}
{$IFC LibraryVersion > 10}
    {$U LIBPL/PaslibCall} PaslibCall,
    {$U LIBPL/PPasLibc } PPasLibC,
{$ENDC}
{$IFC LibraryVersion <= 20}
    {$U FontMgr     } FontMgr,      {Client should USE UFont instead of FontMgr before QuickDraw}
{$ENDC}
    {$U QuickDraw   } QuickDraw,    {Client must USE QuickDraw (unless we provide a type-stub for it)}
{$IFC LibraryVersion > 20}
    {$U FontMgr     } FontMgr,      {Client should USE UFont instead of FontMgr after QuickDraw}
{$ENDC}
    {$U WM.Events   } Events,
    {$U WM.Folders  } Folders,
    {$U FilerComm   } FilerComm;

{$SETC fDbgDraw     := fDbgOK}
{$SETC fRngDraw     := fDbgOK}
{$SETC fSymDraw     := fSymOK}

{$SETC fDebugMethods := fDbgDraw} {if VAR also true, trace entries and/or exits}

CONST
    {there should be at most 10 families and they should be in consecutive order; otherwise
            the command number constants in UABC should be changed}
    famSystem       =   0;

    famMin          =   1;  {minimum family number that appears in the font menu}
    famModern       =   1;
    famClassic      =   2;
    famMax          =   2;

    {there should be at most 20 families and they should be in consecutive order; otherwise
            the command number constants in UABC should be changed}
    sizeMin         =   1;
    size20Pitch     =   1;  { 8 Point 20 Pitch      NOTE: Modern available only}
    size15Pitch     =   2;  { 8 Point 15 Pitch      NOTE: Modern available only}
    size12Pitch     =   3;  {10 Point 12 Pitch}
    size10Pitch     =   4;  {12 Point 10 Pitch}
    size12Point     =   5;  {12 Point proportional}
    size14Point     =   6;  {14 Point proportional}
    size18Point     =   7;  {18 Point proportional}
    size24Point     =   8;  {24 Point proportional}
    sizeMax         =   8;

    {font IDs to be used in QuickDraw}
    fIDSystem       =    0;     {Reserved for application generated text, that cannot be edited by user;
                                    does not print properly}
    fID20Pitch      =   19;
    fID15Pitch      =    7;
    fIDm12Pitch     =    8;
    fIDc12Pitch     =   13;
    fIDm10Pitch     =    9;
    fIDc10Pitch     =   14;
    fIDm12Point     =    4;
    fIDc12Point     =   10;
    fIDm14Point     =   15;
    fIDc14Point     =   16;
    fIDm18Point     =    5;
    fIDc18Point     =   11;
    fIDm24Point     =    6;
    fIDc24Point     =   12;

    fIDRulers       =   25;     {Ruler Icons}

    {fontIDs below this line are to be used only in special cases, there is no guarantee that these
            will print properly}
    fIDSysPatterns  =    2;     {System Patterns, ie. LisaDraw}
    fIDSysCursors   =    3;     {System Cursors}
    fIDLT20Graphics =   23;     {LisaTerminal 20 Pitch VT100 graphics}
    fIDLT12Graphics =   17;     {LisaTerminal 12 Pitch VT100 graphics}
    fIDLT20Text     =   27;     {LisaTerminal 20 Pitch VT100 text}
    fIDLT12Text     =   26;     {LisaTerminal 12 Pitch VT100 text}
    fIDDeskIcons    =   22;     {Desktop Icon font}
    fIDWM           =    1;     {Window Manager font}
    fIDCalculator   =   18;     {Calculator font}
    fIDIconName     =   21;     {Icon Name font}
    fIDMarker       =   20;     {Marker Font}
    fIDLisaGuide    =   24;     {LisaGuide Font}


TYPE

    TFontIDArray = ARRAY[famMin..famMax, sizeMin..sizeMax] OF INTEGER;

    TScaler =
        RECORD   {scale-definition}
        numerator:      point; {numerator.h DIV denominator.h is the scale factor in horiz direction}
        denominator:    point; {numerator.v DIV denominator.v is the scale factor in the vert. direction}
        END;

    TRectCoords = ARRAY[FALSE..TRUE] OF Point; {TRectCoords(aRect)[FALSE] = aRect.topLeft; [TRUE] = botRight}

    LPoint =
            RECORD
                CASE INTEGER OF
                    0: (v, h: LONGINT);
                    1: (vh: ARRAY [VHSelect] OF LONGINT)
            END;

    LRect =
            RECORD
                CASE INTEGER OF
                    0: (top, left, bottom, right: LONGINT);
                    1: (topLeft, botRight: LPoint)
            END;

    LPattern = PACKED ARRAY[0..7] OF 0..255;

    TLRectCoords = ARRAY[FALSE..TRUE] OF LPoint; {TLRectCoords(anLRect)[FALSE] = anLRect.topLeft; etc.}

    TEnumActions =  (rErase, rFrame, rBackground, rDraw);
    TActions = SET OF TEnumActions;

    THighTransit = (hNone, hOffToDim, hOffToOn, hDimToOn, hDimToOff, hOnToOff, hOnToDim);
    {Refresh assumes that the last four and only the last four start with already-highlighted stuff}

    TEnumResizability = (userCanResizeIt, windowCanResizeIt);
    TResizability = SET OF TEnumResizability;       {arg for TBranchArea.CREATE & TPanel.Divide}

    TFontRecord =
        PACKED RECORD
        CASE BOOLEAN OF
            FALSE:  (fontNum:       INTEGER);
            TRUE:   (fontFamily:    Byte;
                     fontSize:      Byte)
        END;

    TTypeStyle =
        RECORD
{$IFC LibraryVersion <= 20}
        onFaces:    TSeteface;
{$ELSEC}
        onFaces:    Style;
{$ENDC}
        font:       TFontRecord;
        END;

    TArea = SUBCLASS OF TObject

      {Variables}
        innerRect:      Rect;                       {window(usually)-relative bounds excluding borders}
        outerRect:      Rect;                       {bounding box in ancestral coordinates}
        parentBranch:   TBranchArea;                {only used for TPanels and TBranchAreas}

      {Creation/Destruction}
        FUNCTION  TArea.CREATE(object: TObject; heap: THeap; itsRect: Rect): TArea; ABSTRACT;

      {Attributes}
        FUNCTION  TArea.ChildWithPt(pt: Point; childList: TList; VAR nearestPt: Point): TArea;
        PROCEDURE TArea.GetBorder(VAR border: Rect); DEFAULT;
                                {Return the deltas of the border bars, etc. (outer=inner+border)}
                                {windows, bands, panes: 1 all around;
                                 panels: 1 on left/top, scroll bars on right/bottom}
        PROCEDURE TArea.GetMinExtent(VAR minExtent: Point; windowIsResizingIt: BOOLEAN); ABSTRACT;
        PROCEDURE TArea.SetOuterRect(newOuterRect: Rect);
        PROCEDURE TArea.SetInnerRect(newInnerRect: Rect);

      {Display}                 {Other methods assume grafPort, origin, & clipping were preset by Focus}
        PROCEDURE TArea.Erase;
                                {Erase the interior}
        PROCEDURE TArea.Focus; ABSTRACT;
                                {Set up the grafPort for this window or pad}
        PROCEDURE TArea.Frame; DEFAULT;
                                {Draw outlines, scroll bars, etc. outside the bounding box}
        PROCEDURE TArea.Refresh(rActions: TActions; highTransit: THighTransit); ABSTRACT;

      {Buttoning}
        FUNCTION  TArea.DownAt(mousePt: Point): BOOLEAN; ABSTRACT;

      {Resizing}
        PROCEDURE TArea.ResizeInside(newInnerRect: Rect); ABSTRACT;
        PROCEDURE TArea.ResizeOutside(newOuterRect: Rect); ABSTRACT;

        END;


    TPad = SUBCLASS OF TArea

      {Variables}
        port:           GrafPtr;                    {the GrafPort used by this pad}
        viewedLRect:    LRect;                      {The portion of view that is displayed in innerRect}
        visLRect:       LRect;                      {viewedLRect sect visRgn while focused}
        availLRect:     LRect;                      {The larger part of view that fits in a 16-bit Rect}
        scrollOffset:   LPoint;                     {The distance scrolled from the view topLeft}
        origin:         Point;                      {What to set the grafport origin to when focused}
        cdOffset:       LPoint;                     {What to subtract from coordinates to get port coords}
        clippedRect:    rect;                       {additional clipping to apply at Focus time}

        padRes:         Point;                      {spots/inch in the pad coordinate space}
        viewedRes:      Point;                      {spots/inch in the 32-bit space being projected}

        scaled:         BOOLEAN;                    {the net scale factor, combining zooming}
        scaleFactor:    TScaler;                    {and aspect ratio, etc.}

        zoomFactor:     TScaler;

      {Creation/Destruction}
        FUNCTION  TPad.CREATE(object: TObject; heap: THeap; itsInnerRect: Rect; itsViewedLRect: LRect;
                           itsPadRes, itsViewRes: Point;
                           itsPort: GrafPtr): TPad;

        PROCEDURE TPad.Redefine(itsInnerRect: Rect; itsViewedLRect: LRect;
                            itsPadRes, itsViewRes: Point;
                     itsZoomFactor: TScaler; itsPort: GrafPtr);


      {Coordinate Mapping -- grafPort to view}
        PROCEDURE TPad.DistToLDist(distInPort: Point; VAR lDistInView: LPoint);
        PROCEDURE TPad.PatToLPat(patInPort: Pattern; VAR lPatInView: LPattern);
        PROCEDURE TPad.PtToLPt(ptInPort: Point; VAR lPtInView: LPoint);
        PROCEDURE TPad.RectToLRect(rectInPort: Rect; VAR lRectInView: LRect);

      {Coordinate Mapping -- view to grafPort}
        PROCEDURE TPad.LDistToDist(lDistInView: LPoint; VAR distInPort: Point);
        PROCEDURE TPad.LPatToPat(lPatInView: LPattern; VAR patInPort: Pattern);
        PROCEDURE TPad.LPtToPt(lPtInView: LPoint; VAR ptInPort: Point);
        PROCEDURE TPad.LRectToRect(lRectInView: LRect; VAR rectInPort: Rect);

      {Scrolling}
        PROCEDURE TPad.OffsetBy(deltaLPt: LPoint);   {offset viewedLRect -- no effect on display}
        PROCEDURE TPad.SetScrollOffset(VAR newOffset: LPoint);
                        {recalculates the origin and cdOffset fields; does not change arg}

      {Display}
        PROCEDURE TPad.ClipFurtherTo(rBand: rect);  {narrows down clip area at next Focus}
        PROCEDURE TPad.Focus; OVERRIDE;
        PROCEDURE TPad.InvalLRect(r: LRect);              {Force redraw of r at next update}
        PROCEDURE TPad.InvalRect(r: Rect);                {Force redraw of r at next update}
        PROCEDURE TPad.SetPen(pen: PenState);    {NB: We should later augment this so that it scales
                                                        pensizes}
        PROCEDURE TPad.SetPenToHighlight(highTransit: THighTransit); {SetPenState to highlight this way}

        PROCEDURE TPad.SetZoomFactor(zoomNumerator, zoomDenominator: point); DEFAULT;

      {Drawing}
        PROCEDURE TPad.DrawLText(textBuf: Ptr; startByte, numBytes: INTEGER);
        PROCEDURE TPad.DrawLLine(newLPt: LPoint);
        PROCEDURE TPad.DrawLPicture(pic: PicHandle; r:LRect);
        PROCEDURE TPad.DrawLRect(verb: GrafVerb; r: LRect);
        PROCEDURE TPad.DrawLRRect(verb: GrafVerb; r: LRect; ovalWidth, ovalHeight: INTEGER);
        PROCEDURE TPad.DrawLOval(verb: GrafVerb; r: LRect);
        PROCEDURE TPad.DrawLArc(verb: GrafVerb; r: LRect; startAngle, arcAngle: INTEGER);
        PROCEDURE TPad.DrawLBits(VAR srcBits: BitMap; VAR srcRect: Rect;
                                   VAR dstLRect: LRect; mode: INTEGER; maskRgn: RgnHandle);

      {Process termination and Debugging Assistance}
        PROCEDURE TPad.Crash; ABSTRACT;
        FUNCTION  TPad.BindHeap(activeVsClip, doBind: BOOLEAN): THeap; ABSTRACT;

        END;

    TBranchArea = SUBCLASS OF TArea

      {Variables}
        arrangement:    VHSelect;       {v means above one another}
        elderFirst:     BOOLEAN;        {TRUE IFF elderChild is above or to the left of youngerChild}
        resizability:   TResizability;
        elderChild:     TArea;
        youngerChild:   TArea;

      {Creation/Destruction}
        FUNCTION  TBranchArea.CREATE(object: TObject; heap: THeap; vhs: VHSelect; hasElderFirst: BOOLEAN;
                                        whoCanResizeIt: TResizability;
                                        itsElderChild, itsYoungerChild: TArea): TBranchArea;

      {Attributes}
        PROCEDURE TBranchArea.GetMinExtent(VAR minExtent: Point; windowIsResizingIt: BOOLEAN); OVERRIDE;
        FUNCTION  TBranchArea.OtherChild(child: TArea): TArea;
        PROCEDURE TBranchArea.ReplaceChild(child, newChild: TArea);
        FUNCTION  TBranchArea.TopLeftChild: TArea;

      {Resizing}
        PROCEDURE TBranchArea.ResizeOutside(newOuterRect: Rect); OVERRIDE;
        PROCEDURE TBranchArea.Redivide(newCd: INTEGER);

        END;



VAR

    amPrinting:         BOOLEAN;                    {Iff TRUE, we are currently printing rather than drawing}

    zeroPt:             Point;                      {(0,0)}
    zeroRect:           Rect;                       {(0,0)-(0,0)}
    hugeRect:           Rect;                       {(0,0)-(MAXINT/2,MAXINT/2)}

    zeroLPt:            LPoint;                     {(0,0)}
    zeroLRect:          LRect;                      {(0,0)-(0,0)}
    hugeLRect:          LRect;                      {(0,0)-(MAXLINT/2,MAXLINT/2)}

    orthogonal:         ARRAY [v..h] OF VHSelect;   {Maps v to h and vice versa}

    highPen:            ARRAY [THighTransit] OF PenState; {standard highlight-feedback transitions}

    lPatWhite:          LPattern;                   {Maps to QuickDraw pattern white}
    lPatBlack:          LPattern;                   {Maps to QuickDraw pattern black}
    lPatGray:           LPattern;                   {Maps to QuickDraw pattern gray}
    lPatLtGray:         LPattern;                   {Maps to QuickDraw pattern ltGray}
    lPatDkGray:         LPattern;                   {Maps to QuickDraw pattern dkGray}

    focusStack:         ARRAY [1..10] OF TArea;     {PushFocus pushes and PopFocus pops focusArea}
    focusStkPtr:        INTEGER;                    {Index of last thing on focusStack}
    focusArea:          TArea;                      {The currently focused area}
    focusRgn:           RgnHandle;                  {either padRgn or visRgn}
    padRgn:             RgnHandle;                  {intersection of pane and visRgn}
    altVisRgn:          RgnHandle;                  {If useAltVisRgn, use this instead of visRgn in Focus}
    useAltVisRgn:       BOOLEAN;                    {If TRUE, use altVisRgn instead of visRgn in Focus}
    thePad:             TPad;                       {focusArea, if a TPad, else NIL}

    noPad:              TPad;                       {maps every point to itself}
    crashPad:           TPad;                       {an object willing to handle process termination}

    screenRes:          Point;                      {screen resolution, pixels per inch}

    sysTypeStyle:       TTypeStyle; {system font, normal face}

    printerPseudoPort:  GrafPtr;

    cArea:              TClass;
    cPad:               TClass;
    cBranchArea:        TClass;



{The next four are declared EXTERNAL in UOBJECT2}
PROCEDURE InitQDWM;
PROCEDURE TrmntExceptionHandler;
PROCEDURE InitErrorAbort(error: INTEGER);
{$IFC fDbgDraw}
FUNCTION  BindHeap(activeVsClip, doBind: BOOLEAN): THeap;
{$ENDC}

PROCEDURE Reduce(VAR numerator, denominator: INTEGER);   {reduce fraction to lowest terms}

FUNCTION  FPtPlusPt(operand1, operand2: Point): LONGINT;    {       p3 := Point(FPtPlusPt(p1, p2));       }
FUNCTION  FPtMinusPt(operand1, operand2: Point): LONGINT;   { F stands for FUNCTION }

FUNCTION  FPtMulInt(operand1: Point; operand2: INTEGER): LONGINT;
FUNCTION  FPtDivInt(operand1: Point; operand2: INTEGER): LONGINT;
            {e.g.:        center := Point(FPtDivInt(POINT(FPtPlusPt(p1, p2)), 2);           }

FUNCTION  FPtMaxPt(operand1, operand2: Point): LONGINT;     { each coordinate is max'ed separately }
FUNCTION  FPtMinPt(operand1, operand2: Point): LONGINT;

FUNCTION  FDiagRect(operand1: Rect): LONGINT;               { FPtMinusPt(botRight-topLeft) }

PROCEDURE BoolToStr(bool: BOOLEAN; str: TPstring);

FUNCTION  LIntDivLInt(i, j: LONGINT): LONGINT;
FUNCTION  LIntDivInt(i: LONGINT; j: INTEGER): LONGINT;
FUNCTION  LIntMulInt(i: LONGINT; j: INTEGER): LONGINT;

FUNCTION  LIntOvrInt(i: LONGINT; j: INTEGER): LONGINT;
    {This returns LIntDivInt(i+(j DIV 2), j) if i>0 and
                  LIntDivInt(i-(j DIV 2), j) if i<0}

PROCEDURE PtPlusPt(operand1, operand2: Point; VAR result: Point);
PROCEDURE PtMinusPt(operand1, operand2: Point; VAR result: Point);
PROCEDURE PtMulInt(operand1: Point; operand2: INTEGER; VAR result: Point);
PROCEDURE PtDivInt(operand1: Point; operand2: INTEGER; VAR result: Point);
{$IFC LibraryVersion <= 20}
FUNCTION  EqualPt(operand1, operand2: Point): BOOLEAN;  {Will be in QuickDraw eventually}
{$ENDC}

PROCEDURE RectPlusRect(operand1, operand2: Rect; VAR result: Rect);
PROCEDURE RectMinusRect(operand1, operand2: Rect; VAR result: Rect);
{$IFC LibraryVersion <= 20}
FUNCTION  EqualRect(rectA, rectB: Rect): BOOLEAN;       {Will be in QuickDraw eventually}
FUNCTION  EmptyRect(r: Rect): BOOLEAN;                  {Will be in QuickDraw eventually}
{$ENDC}

PROCEDURE AlignRect(VAR dstRect: Rect; srcRect: Rect; vhs: VHSelect);
FUNCTION  LengthRect(r: Rect; vhs: VHSelect): INTEGER;
FUNCTION  RectHasPt(dstRect: Rect; pt: Point): BOOLEAN;
PROCEDURE RectHavePt(dstRect: Rect; VAR pt: Point);    {change pt so that topLeft <= pt <= botRight}
FUNCTION  RectsNest(outer, inner: Rect): BOOLEAN;
PROCEDURE RectifyRect(VAR dstRect: Rect);              {exchange coordinates until topLeft <= botRight}
FUNCTION  RectIsVisible(rectInPort: Rect): BOOLEAN;

PROCEDURE PointToStr(pt: Point; str: TPstring);   {Referenced as EXTERNAL by UABC2}
PROCEDURE RectToStr(r: Rect; str: TPstring);      {Referenced as EXTERNAL by UABC2}

PROCEDURE LPtPlusLPt(operand1, operand2: LPoint; VAR result: LPoint);
PROCEDURE LPtMinusLPt(operand1, operand2: LPoint; VAR result: LPoint);
PROCEDURE LPtMulInt(operand1: LPoint; operand2: INTEGER; VAR result: LPoint);
PROCEDURE LPtDivInt(operand1: LPoint; operand2: INTEGER; VAR result: LPoint);
FUNCTION  EqualLPt(operand1, operand2: LPoint): BOOLEAN;

PROCEDURE LRectPlusLRect(operand1, operand2: LRect; VAR result: LRect);
PROCEDURE LRectMinusLRect(operand1, operand2: LRect; VAR result: LRect);
FUNCTION  EqualLRect(rectA, rectB: LRect): BOOLEAN;
FUNCTION  EmptyLRect(r: LRect): BOOLEAN;

PROCEDURE AlignLRect(VAR destLRect: LRect; srcLRect: LRect; vhs: VHSelect);
FUNCTION  LengthLRect(r: LRect; vhs: VHSelect): LONGINT;
FUNCTION  LRectHasLPt(destLRect: LRect; pt: LPoint): BOOLEAN;
PROCEDURE LRectHaveLPt(destLRect: LRect; VAR pt: LPoint);    {change pt so that topLeft <= pt <= botRight}
FUNCTION  LRectsNest(outer, inner: LRect): BOOLEAN;
PROCEDURE RectifyLRect(VAR destLRect: LRect);              {exchange coordinates until topLeft <= botRight}
FUNCTION  LRectIsVisible(srcLRect: LRect): BOOLEAN;

PROCEDURE LPointToStr(pt: LPoint; str: TPstring);   {Referenced as EXTERNAL by UOBJECT2}
PROCEDURE LRectToStr(r: LRect; str: TPstring);      {Referenced as EXTERNAL by UOBJECT2}

PROCEDURE SetLPt(VAR destPt: LPoint; itsH, itsV: LONGINT);
PROCEDURE SetLRect(VAR dstRect: LRect; itsLeft, itsTop, itsRight, itsBottom: LONGINT);
PROCEDURE OffsetLRect(VAR dstRect: LRect; dh, dv: LONGINT);
PROCEDURE InsetLRect(VAR dstRect: LRect; dh, dv: LONGINT);
FUNCTION  SectLRect(srcRectA, srcRectB: LRect; VAR dstRect: LRect): BOOLEAN;
PROCEDURE UnionLRect(srcRectA, srcRectB: LRect; VAR dstRect: LRect);
FUNCTION  LPtInLRect(pt: LPoint; r: LRect): BOOLEAN;


FUNCTION  IsSmallPt(srcPt: LPoint): BOOLEAN;
FUNCTION  IsSmallRect(srcRect: LRect): BOOLEAN;


(*PROCEDURE ClipLRect(r: LRect);  {Not yet implementable}*)


{Drawing text}

PROCEDURE DrawLText(textBuf: Ptr; startByte, numBytes: INTEGER);

{Drawing lines, rectangles, and ovals}

PROCEDURE MoveToL(h, v: LONGINT);
PROCEDURE MoveL(dh, dv: LONGINT);
PROCEDURE LineToL(h, v: LONGINT);
PROCEDURE LineL(dh, dv: LONGINT);

PROCEDURE FrameLRect(r: LRect);
PROCEDURE PaintLRect(r: LRect);
PROCEDURE EraseLRect(r: LRect);
PROCEDURE InvrtLRect(r: LRect);
PROCEDURE FillLRect(r: LRect; lPat: LPattern);

PROCEDURE FrameLOval(r: LRect);
PROCEDURE PaintLOval(r: LRect);
PROCEDURE EraseLOval(r: LRect);
PROCEDURE InvrtLOval(r: LRect);
PROCEDURE FillLOval(r: LRect; lPat: LPattern);

PROCEDURE FrameLRRect(r: LRect; ovalWidth, ovalHeight: INTEGER);
PROCEDURE PaintLRRect(r: LRect; ovalWidth, ovalHeight: INTEGER);
PROCEDURE EraseLRRect(r: LRect; ovalWidth, ovalHeight: INTEGER);
PROCEDURE InvrtLRRect(r: LRect; ovalWidth, ovalHeight: INTEGER);
PROCEDURE FillLRRect(r: LRect; ovalWidth, ovalHeight: INTEGER; lPat: LPattern);

PROCEDURE FrameLArc(r: LRect; startAngle, arcAngle: INTEGER);
PROCEDURE PaintLArc(r: LRect; startAngle, arcAngle: INTEGER);
PROCEDURE EraseLArc(r: LRect; startAngle, arcAngle: INTEGER);
PROCEDURE InvrtLArc(r: LRect; startAngle, arcAngle: INTEGER);
PROCEDURE FillLArc(r: LRect; startAngle, arcAngle: INTEGER; lPat: LPattern);

FUNCTION  ClonePicture(pic: PicHandle; toHeap: THeap): PicHandle;

PROCEDURE ResizeFeedback(mousePt: Point; minPt, maxPt: Point; outerRect: Rect;
                         tabHeight, sbWidth, sbHeight: INTEGER; VAR newPt: Point);

PROCEDURE PushFocus;            {Save old focusArea on focusStack}
PROCEDURE PopFocus;             {Restore old focusArea from focusStack and focus on it}

{$IFC LibraryVersion <= 20}
PROCEDURE MakeTypeStyle(itsFamily: INTEGER; itsSize: INTEGER;
            itsFaces: TSetEFace;
            VAR typeStyle: TTypeStyle);
{$ELSEC}
PROCEDURE MakeTypeStyle(itsFamily: INTEGER; itsSize: INTEGER;
            itsFaces: Style;
            VAR typeStyle: TTypeStyle);
{$ENDC}

FUNCTION  QDFontNumber(typeStyle: TTypeStyle): INTEGER;
PROCEDURE SetQDTypeStyle(typeStyle: TTypeStyle);

IMPLEMENTATION

{$I libtk/UDRAW2.TEXT}

END.




ÿ