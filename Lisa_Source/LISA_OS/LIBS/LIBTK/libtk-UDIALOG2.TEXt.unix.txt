(*           Copyright 1984 by Apple Computer, Inc

UDialog2

TDialogWindow  -- TDialogView  -- TDialogImage  -- TImageWithID  -- TDialog  --
TButton  -- TCheckbox  -- TCluster  -- TInputFrame  -- TLegend

*)

{04/23/84 1210  SetParaExtent uses thePad rather than view's screenPad if amPrinting}
{04/23/84 1210  Removed all references to 'underEdit' field of TDialogImage}
{04/15/84 2345  Spring Release latest}
{04/04/84 2300  Spring Prelim Release}
{01/29/84 1750  RELEASE TK8D}
{12/22/83 1927  RELEASE TK8A}

{$IFC fRngABC}
{$R+}
{$ELSEC}
{$R-}
{$ENDC}

{$IFC fSymABC}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}

VAR copyRight: STRING[45];

{----------------------------------------------------------------------------------------------------------}

{$S DlgAlloc}
PROCEDURE GetTextAndLocation(phraseNumber: INTEGER; VAR itsChars: S255; VAR itsLocation: LPoint);
    VAR rawPhrase:  S255;
        restOfIt:   S255;
        morsel:     S255;
        semiColon:  INTEGER;
        comma:      INTEGER;
        aLocation:  LPoint;
        FUNCTION OKIntegerValue(Str: S255; VAR itsValue: LONGINT): BOOLEAN;
                VAR result: TConvResult;
            BEGIN
            StrToLInt(@str, itsValue, result);
            OkIntegerValue := (result = cvValid);
            END;
    BEGIN  {someone please optimize this someday}
    {$IFC fTrace}BP(11);{$ENDC}
    process.GetAlert(phraseNumber, rawPhrase);
    semiColon := POS('@',rawPhrase);
    IF semiColon = 0 THEN
        semiColon := LENGTH(rawPhrase) + 1;
    itsChars := COPY(rawPhrase, 1, semiColon - 1);
    restOfIt := COPY(rawPhrase, semiColon + 1, LENGTH(rawPhrase) - semiColon);
    comma := POS( ',', restOfIt);

    morsel := COPY(restOfIt, 1, comma - 1);
    IF OKIntegerValue(morsel, aLocation.h) THEN
        BEGIN
        morsel := COPY(restOfIt, comma + 1, LENGTH(restOfIt) - comma);
        IF NOT OKIntegerValue(morsel, aLocation.v) THEN
            aLocation.v := 100;
        END
    ELSE
        SetLPt(aLocation, 100, 100);

    itsLocation := aLocation;
    {$IFC fTrace}EP;{$ENDC}
    END;


{$S TK2Start}
PROCEDURE LRectAddBorders(baseLRect: LRect; borders: Rect; VAR resultLRect: LRect);
    BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    resultLRect.left := baseLRect.left + borders.left;
    resultLRect.top := baseLRect.top + borders.top;
    resultLRect.right := baseLRect.right + borders.right;
    resultLRect.bottom := baseLRect.bottom + borders.bottom;
    {$IFC fTrace}EP;{$ENDC}
    END;


{$S TK2Start}
{"temporary" implementation, slow, unwieldy}
PROCEDURE SetParaExtent(paragraph: TParagraph; view: TView; location: LPoint; VAR extentLRect: LRect);
    VAR extent:     Rect;
        lExtent:    LRect;
        pad:        TPad; {+SW+}
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        paragraph.BuildExtentLRect(zeroLPt, lExtent); {assumes grafPort device is SCREEN for textWidth}
        noPad.LRectToRect(lExtent, extent);
(*      view.screenPad.RectToLRect(extent, extentLRect);  *)
        IF amPrinting THEN
            pad := thePad
        ELSE
            pad := view.screenPad;
        pad.RectToLRect(extent, extentLRect);   {+SW+}
        OffsetLRect(extentLRect, location.h, location.v);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
FUNCTION  NewStdDialogWindow(heap: THeap; itsHeight: INTEGER; itsKeyResponse,
                itsMenuResponse, itsDownInMainWindowResponse: TDiResponse):  TDialogWindow;
    VAR dialogWindow:   TDialogWindow;
        panel:          TPanel;
        dialogView:     TDialogView;
        extentLRect:    LRect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        dialogWindow := TDialogWindow.CREATE(NIL, heap, FALSE {not resizable}, itsHeight,
                itsKeyResponse, itsMenuResponse, itsDownInMainWindowResponse);
        panel := TPanel.CREATE(NIL, heap, dialogWindow, 0, screenBits.bounds.right, [], []);
        dialogWindow.controlPanel := panel;

        SetLRect(extentLRect, 0, 0, screenBits.bounds.right, screenBits.bounds.bottom - 40);
        dialogView := TDialogView.CREATE(NIL, heap, extentLRect, panel, NIL, screenRes);
        dialogWindow.dialogView := dialogView;
        NewStdDialogWindow := dialogWindow;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
    FUNCTION  NewSysLegend(heap: THeap; itsChars: S255; itsXLoc, itsYLoc: LONGINT; itsView: TView): TLegend;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        NewSysLegend := NewStdLegend(heap, itsChars, itsXLoc, itsYLoc, itsView, sysTypeStyle);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
    FUNCTION  NewStdLegend(heap: THeap; itsChars: S255; itsXLoc, itsYLoc: LONGINT; itsView: TView;
                itsTypeStyle: TTypeStyle): TLegend;
        VAR itsString:      S255;
            itsLocation:    LPoint;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SetLPt(itsLocation, itsXLoc, itsYLoc); {=}
        NewStdLegend := TLegend.CREATE(NIL, heap, itsChars, itsView, itsLocation, itsTypeStyle);
        {$IFC fTrace}EP;{$ENDC}
    END;



METHODS OF TDialogWindow;


{$S DlgAlloc}
FUNCTION  TDialogWindow.CREATE(object: TObject; heap: THeap; itsResizability: BOOLEAN; itsHeight: INTEGER;
          itsKeyResponse, itsMenuResponse, itsDownInMainWindowResponse: TDiResponse): TDialogWindow;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TDialogWindow(TDialogBox.CREATE(object, heap, itsResizability, itsHeight, itsKeyResponse,
                                                itsMenuResponse, itsDownInMainWindowResponse));

        SELF.controlPanel := SELF.selectPanel; {If not holding a TDialogView, client must reset}
        SELF.dialogView := NIL;
        SELF.mainDialog := NIL;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TDialogWindow.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('controlPanel: TPanel');
    Field('dialogView: TDialogView');
    Field('mainDialog: TDialog');
    Field('');
END;
{$ENDC}


{$S DlgHot}
PROCEDURE TDialogWindow.Appear;
    PROCEDURE TellYourView(obj: TObject);
        PROCEDURE YouPrepare(obj: TObject);
            BEGIN
            TDialogImage(obj).PrepareToAppear;
            END;
    BEGIN
    IF InClass(TPanel(obj).view, TDialogView) THEN
        TDialogView(TPanel(obj).view).EachActualPart(YouPrepare);
    END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SUPERSELF.Appear;
    SELF.panels.Each(TellYourView);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogWindow.BeDismissed;
    VAR dialogView:     TDialogView;
        defaultButton:  TButton;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    PushFocus;
    SELF.Focus;
    IF InClass(SELF.controlPanel.view, TDialogView) THEN
        BEGIN
        dialogView := TDialogView(SELF.controlPanel.view);
        defaultButton := dialogView.defaultButton;
        IF defaultButton <> NIL THEN
            dialogView.PushButton(defaultButton)
            {may want to put in a delay loop here to assure hilit button seen}

        ELSE {dialog box has no default button; just take it down}
            currentWindow.TakeDownDialogBox;
        END
    ELSE   {not a dialogView up there--must be a layout view}
        currentWindow.TakeDownDialogBox;
    PopFocus;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION TDialogWindow.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    CASE cmdNumber OF
        uEditDialog:
            CanDoCommand := TRUE;
        OTHERWISE
            CanDoCommand := currentWindow.CanDoCommand(cmdNumber, checkIt);
        END;
    {$IFC fTrace}EP;{$ENDC}
 END;


{$S DlgHot}
PROCEDURE TDialogWindow.Disappear;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SUPERSELF.Disappear;
    IF SELF.controlPanel <> NIL THEN
        IF InClass(SELF.controlPanel.view, TDialogView) THEN
            TDialogView(SELF.controlPanel.view).isShowing := FALSE;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TDialogWindow.NewCommand(cmdNumber: TCmdNumber): TCommand;
BEGIN
    {$IFC fTrace}BP(12);{$ENDC}
    CASE cmdNumber OF
        uEditDialog:
            BEGIN
            IF SELF.controlPanel = NIL THEN
{$IFC fDbgOK}
                ABCBreak('DialogWindow.NewCommand NIL ctl pnl', 0)
{$ENDC}
            ELSE
            IF NOT InClass(SELF.controlPanel.view, TDialogView) THEN
{$IFC fDbgOK}
                ABCBreak('DialogWindow.NewCommand, not a dialog view', 0)
{$ENDC}
            ELSE
                TDialogDesignWindow.CREATE(NIL, SELF.Heap, TDialogView(SELF.controlPanel.view)).SeizeControl;
            NewCommand := NIL;
            END;
        OTHERWISE
            NewCommand := currentWindow.NewCommand(cmdNumber);
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
BEGIN
    SetRect(stdPlainBorders, - stdLeftRightMargin, -stdSlimTitleHeight - stdBottomBorder, stdLeftRightMargin,
                stdBottomBorder);
    SetRect(stdIDBorders , - stdLeftRightMargin, -stdTitleHeight - stdBottomBorder, stdLeftRightMargin,
                stdBottomBorder);
    SetRect(stdThinBorders , 0, -stdSlimTitleHeight, 0, 0);
    SetPt(stdLabelOffset, 8, -2);
    SetPt(stdFrmeOffset, 20, 0);
    SetRect(stdFrameBorders, -30, -16, 30, 16);
    SetRect(stdHdngBorders, -6, -12, 6, 4);

    MakeTypeStyle(famModern, size12Pitch, [], stdInputTypeStyle);
    MakeTypeStyle(famModern, size15Pitch, [], titleTypeStyle);
    MakeTypeStyle(famModern, size12Pitch, [], stdHdngTypeStyle);

    copyright := 'Copyright 1983, 1984 by Apple Computer, Inc.';

END;


METHODS OF TDialogView;


{$S DlgAlloc}
FUNCTION TDialogView.CREATE{(object: TObject; heap: THeap;  itsExtentLRect: LRect; itsPanel: TPanel;
                    itsPrintManager: TPrintManager; itsRes: Point)};
    VAR rootDialog:     TDialog;
        dialogWindow:   TDialogWindow;
        styleSheet:     TStyleSheet;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}

    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TDialogView(TView.CREATE(object, heap, itsPanel, itsExtentLRect, itsPrintManager, stdMargins,
                         (itsPrintManager <> NIL), itsRes, TRUE));

    SELF.nonDialogExtent := itsExtentLRect;

    rootDialog := TDialog.CREATE(NIL, heap, 'ROOT', SELF);
    SELF.rootDialog := rootDialog;  {create an empty master}

    styleSheet := TStyleSheet.CREATE(NIL, heap);
    SELF.styleSheet := styleSheet;

    WITH SELF DO
        BEGIN
        isShowing := FALSE; {not yet actually put up}
        currentDialogImage := NIL;
        defaultButton := NIL;
        hitButton := NIL;

        paintFreeBoxes := FALSE;  {client can set this to TRUE after the CREATE call}
        paintSense := FALSE;
        startedPainting := FALSE;

        mouseIsDown := FALSE;
        magnetCursor := noCursor;
        END;

    IF InClass(itsPanel.window, TDialogWindow) THEN
        BEGIN
        dialogWindow := TDialogWindow(itsPanel.window);
        IF dialogWindow.controlPanel = NIL THEN
            dialogWindow.controlPanel := itsPanel;
        IF dialogWindow.dialogView = NIL THEN
            dialogWindow.dialogView := SELF;
        END;
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgCold}
PROCEDURE TDialogView.Free;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    Free(SELF.rootDialog);
    Free(SELF.styleSheet);
    SUPERSELF.Free;
    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TDialogView.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('rootDialog: TDialog');
    Field('nonDialogExtent: LRect');
    Field('currentDialogImage: TDialogImage');
    Field('defaultButton: TButton');
    Field('hitButton: TButton');
    Field('isShowing: BOOLEAN');
    Field('paintFreeBoxes: BOOLEAN');
    Field('paintSense: BOOLEAN');
    Field('startedPainting: BOOLEAN');
    Field('styleSheet: TStyleSheet');
    Field('mouseIsDown: BOOLEAN');
    Field('magnetCursor: INTEGER');
    Field('');
END;
{$ENDC}


{$S DlgHot}
PROCEDURE TDialogView.AbandonThatButton;
    PROCEDURE TurnOutTheLights;
        BEGIN
        SELF.hitButton.Highlight(hOnToOff);
        END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.hitButton <> NIL THEN
        BEGIN
        SELF.panel.OnAllPadsDo(TurnOutTheLights);
        IF SELF.currentDialogImage = SELF.hitButton THEN
            SELF.currentDialogImage := NIL;
        SELF.hitButton := NIL;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialogView.AddDialog(dialog: TDialog);
    VAR dialogWindow:   TDialogWindow;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.rootDialog.AddImage(dialog);
    IF InClass(SELF.panel.window, TDialogWindow) THEN
        BEGIN
        dialogWindow := TDialogWindow(SELF.panel.window);
        IF dialogWindow.mainDialog = NIL THEN
            dialogWindow.mainDialog := dialog;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION TDialogView.AddNewDialog(itsKey: S4): TDialog;
    VAR dialogWindow:   TDialogWindow;
        dialog:         TDialog;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    dialog := TDialog.CREATE(NIL, SELF.Heap, itsKey, SELF);
    SELF.AddDialog(dialog);
    AddNewDialog := dialog;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialogView.ActivateDialog(dialog: TDialog; whichWay: BOOLEAN);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.rootDialog.ActivateImage(dialog, whichWay);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.ButtonPushed(button: TButton);
    CONST   delayTime = 50000;
VAR dialogView: TDialogView;
    command:    TCommand;
    sink:       LONGINT;
    i:          LONGINT;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF currentWindow.dialogBox <> NIL THEN
        BEGIN
        dialogView := TDialogView(TDialogWindow(currentWindow.dialogBox).controlPanel.view);
        command := NIL;
        IF dialogView = SELF THEN
            BEGIN
            sink := 124395;
            FOR i := 1 TO delayTime DO
                sink := sink - sink;
            dialogView.AbandonThatButton; {turn off highlighting just in case the dialog will be reused}
            IF button.cmdNumber <> noCmdNumber THEN
                command := currentWindow.selectPanel.selection.NewCommand(button.cmdNumber);
            currentWindow.TakeDownDialogBox;
            IF command <> NIL THEN
                currentWindow.PerformCommand(command);
            END;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.CheckboxHit(checkbox: TCheckbox; toggleDirection: BOOLEAN);
{The client will occasionally want to override this, in order to change the display as an
 immediate consequence of a Checkbox being toggled}
    BEGIN
       {$IFC fTrace}BP(11);{$ENDC}
       { ... }
       {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgHot}
FUNCTION TDialogView.CursorAt(mouseLPt: LPoint): TCursorNumber;
    VAR cursorNumber:   TCursorNumber;
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
    cursorNumber := noCursor;
    IF SELF.mouseIsDown AND (SELF.magnetCursor <> noCursor) THEN
        cursorNumber := SELF.magnetCursor
    ELSE
        BEGIN
        IF LRectHasLPt(SELF.rootDialog.extentLRect, mouseLPt) THEN
           cursorNumber := SELF.rootDialog.CursorAt(mouseLPt);
        IF cursorNumber = noCursor THEN
            cursorNumber := SELF.XCursorAt(mouseLPt);
        END;

   CursorAt := cursorNumber;
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.Draw;
    VAR s:             TListScanner;
        dialogImage:   TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.isShowing := TRUE;  {update event triggered this}
    SELF.rootDialog.Draw;  {draw dialogs}
    SELF.XDraw;            {draw other stuff}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.EachActualPart(PROCEDURE DoToObject(filteredObj: TObject));
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.rootDialogImage.EachActualPart(doToObject);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.MouseMove(mouseLPt: LPoint);
    VAR currentDialogImage: TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    currentDialogImage := SELF.currentDialogImage;
    IF currentDialogImage <> NIL THEN
        IF NOT currentDialogImage.StillMyMouse(mouseLPt) THEN
           currentDialogImage := NIL;

    IF currentDialogImage = NIL THEN
        BEGIN
        currentDialogImage := SELF.rootDialog.DownAt(mouseLPt);
        IF currentDialogImage = NIL THEN
            SELF.XMouseMove(mouseLPt);
        END;

    SELF.currentDialogImage := currentDialogImage;
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.MousePress(mouseLPt: LPoint);
    VAR panel:              TPanel;
        takenBySelection:   BOOLEAN;
        currentDialogImage: TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    panel := SELF.panel;
    SELF.startedPainting := FALSE;
    takenBySelection := FALSE;

    SELF.mouseIsDown := TRUE;
    SELF.magnetCursor := noCursor;

    currentDialogImage := SELF.currentDialogImage;

    IF (currentDialogImage <> NIL) AND (SELF.panel.selection.kind <> nothingKind) THEN
        IF currentDialogImage.Hit(mouseLPt) THEN
            BEGIN
            SELF.panel.selection.MousePress(mouseLPt);
            takenBySelection := TRUE;
            END;

    IF NOT takenBySelection THEN
        BEGIN
        panel.BeginSelection;
        currentDialogImage := SELF.rootDialog.DownAt(mouseLPt);
        IF currentDialogImage = NIL THEN
            SELF.XMousePress(mouseLPt)
        END;

    SELF.currentDialogImage := currentDialogImage;
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.MouseRelease;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.mouseIsDown := FALSE;
    SELF.magnetCursor := noCursor;
    IF SELF.currentDialogImage <> NIL THEN
        SELF.currentDialogImage.MouseRelease
    ELSE
        SELF.XMouseRelease;
    {$IFC fTrace}EP;{$ENDC}
END;

{$S DlgHot}

PROCEDURE TDialogView.PushButton(button: TButton);          {client or ToolKit may call}
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF InClass(button.parent, TDialog) THEN
        TDialog(button.parent).PushButton(button);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialogView.RecalcExtent;
    VAR newExtent:  LRect;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF NOT EmptyLRect(SELF.rootDialog.extentLRect) THEN
        BEGIN
        IF NOT EmptyLRect(SELF.nonDialogExtent) THEN
            UnionLRect(SELF.rootDialog.extentLRect, SELF.nonDialogExtent, newExtent);
        SELF.Resize(newExtent);
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialogView.RemoveDialog(dialog: TDialog; andFree: BOOLEAN);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.rootDialog.DeleteImage(dialog, andFree);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialogView.ReplaceDialog(oldDialog, newDialog: TDialog);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.rootDialog.ReplaceImage(oldDialog, newDialog);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialogView.SetDefaultButton(button: TButton);
    VAR thickPnSize:   point;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.defaultButton := button;
    SetPt(thickPnSize, 3, 2);
    IF button <> NIL THEN
        button.buttonMetrics.penState.pnSize := thickPnSize;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION TDialogView.XCursorAt(mouseLPt: LPoint): TCursorNumber;
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
   XCursorAt := arrowCursor;
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.XDraw;
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.XMousePress(mouseLPt: LPoint);
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.XMouseMove(mouseLPt: LPoint);
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogView.XMouseRelease;
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;

{----------------------------------------------------------------------------------------------------------}


METHODS OF TDialogImage;


{$S TK2Start}
FUNCTION  TDialogImage.CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsId: S255;
                itsView: TView; withChildren: BOOLEAN): TDialogImage;
    VAR newList:    TList;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TDialogImage(TImage.CREATE(object, heap, itsExtent, itsView));

    WITH SELF DO
        BEGIN
        parent := NIL;
        isActive := TRUE;
        isEditable := TRUE;
        withID := FALSE;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TDialogImage.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('parent: TDialogImage');
    Field('isActive: BOOLEAN');
    Field('isEditable: BOOLEAN');
    Field('withID: BOOLEAN');
    Field('');
END;
{$ENDC}


{$S DlgCold}
PROCEDURE TDialogImage.AddImage(dialogImage: TDialogImage);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialogImage.ActivateImage(dialogImage: TDialogImage; whichWay: BOOLEAN);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF dialogImage.isActive <> whichWay THEN {state needs to change}
        BEGIN
        dialogImage.isActive := whichWay;
        SELF.view.panel.InvalLRect(dialogImage.extentLRect);  {??? Want to recalc my extent here???}
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgCold}
PROCEDURE TDialogImage.BringToFront(dialogImage: TDialogImage);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgCold}
PROCEDURE TDialogImage.ComeForward;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.parent <> NIL THEN
        SELF.parent.BringToFront(SELF);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogImage.ControlHit(control: TDialogImage; toggleDirection: BOOLEAN);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.parent <> NIL THEN
        SELF.parent.ControlHit(control, toggleDirection);
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialogImage.DeleteImage(dialogImage: TDialogImage; andFree: BOOLEAN);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    {$IFC fTrace}EP;{$ENDC}
 END;


{$S DlgHot}
FUNCTION  TDialogImage.DownAt(mouseLPt: LPoint):  TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.Hit(mouseLPt) THEN
        BEGIN
        SELF.MousePress(mouseLPt);
        DownAt := SELF;
        END
    ELSE
        DownAt := NIL;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogImage.Draw;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.DrawJustMe;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgDbg} {by design}
PROCEDURE TDialogImage.DrawJustMe;
BEGIN
    {$IFC fTrace}BP(113);{$ENDC}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogImage.EachActualPart(PROCEDURE DoToObject(filteredObj: TObject));
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    {overrides TImage's version, does specifically Nothing; TImageWithID redefines}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION TDialogImage.HasId(id: S255): BOOLEAN;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    HasID := FALSE;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S SgLayout}
FUNCTION TDialogImage.LaunchLayoutBox(view: TView): TImage;
    VAR myLayoutBox:    TLayoutBox;
        plannerView:    TPlannerView;
BEGIN
    {$IFC fTrace}BP(10);{$ENDC}
    IF NOT SELF.isActive THEN
        LaunchLayoutBox := NIL
    ELSE
        LaunchLayoutBox :=  TLayoutBox.CREATE(NIL, view.Heap, SELF.extentLRect, '', NIL,
            view, SELF, stdPlainBorders, FALSE, FALSE, FALSE);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TDialogImage.ObjectWithIDNumber(idNumber: INTEGER):  TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    ObjectWithIDNumber := NIL;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TDialogImage.ObjWithId(id: S255):  TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    ObjWithId := NIL;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogImage.PrepareToAppear;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialogImage.RecalcExtent;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.parent <> NIL THEN
        SELF.parent.RecalcExtent;
    {$IFC fTrace}EP;{$ENDC}
END;

{$S DlgCold}
PROCEDURE TDialogImage.ReplaceImage(replacee, newValue: TDialogImage);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    {$IFC fTrace}EP;{$ENDC}
END;

{$S DlgHot}
FUNCTION  TDialogImage.StillMyMouse(mouseLPt: LPoint): BOOLEAN;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.Hit(mouseLPt) THEN
        StillMyMouse := TRUE {I've handled it}
    ELSE
        StillMyMouse := FALSE; {give it to someone else}
   {default; this will usually be overridden in subclass}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;



METHODS OF TImageWithID;

{$S DlgHot}
FUNCTION  TImageWithID.CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsId: S255;
                itsView: TView; withChildren: BOOLEAN): TImageWithID;
    VAR newList:        TList;
        newID:          TId;
        cState:         TConvResult;
        newIDNumber:    INTEGER;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TImageWithID(TDialogImage.CREATE(object, heap, itsExtent, itsID, itsView, withChildren));

    newID :=  Copy(itsId, 1, MIN(idLength, LENGTH(itsId)));
    StrUpperCased(@newID);
    StrToInt(@newID, newIDNumber, cState);
    IF cState <> cvValid THEN
        newIDNumber := noIDNumber;

    WITH SELF DO
        BEGIN
        id :=  newID;
        idNumber := newIDNumber;
        withId := TRUE;
        END;
    IF withChildren THEN
        BEGIN
        newList := TList.CREATE(NIL, heap, 0);
        SELF.children := newList;
        END
    ELSE
        SELF.children := NIL;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgWarm}
FUNCTION TImageWithID.Clone(heap: THeap): TObject;
    VAR children:       TList;
        copyOfMyself:   TImageWithID;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    copyOfMyself := TImageWithID(SUPERSELF.Clone(heap));
    IF SELF.children <> NIL THEN
        BEGIN
        children := TList(SELF.children.Clone(heap));
        copyOfMyself.children := children;
        END;
    Clone := copyOfMyself;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgWarm}
PROCEDURE TImageWithID.Free;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    Free(SELF.children);
    SUPERSELF.Free;
    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TImageWithID.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('children: TList');
    Field('id: STRING[9]');
    Field('idNumber: INTEGER');
    Field('');
END;
{$ENDC}


{$S DlgHot}
PROCEDURE TImageWithID.ActivateImage(dialogImage: TDialogImage; whichWay: BOOLEAN);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF dialogImage.isActive <> whichWay THEN {state needs to change}
        BEGIN
        dialogImage.isActive := whichWay;
        SELF.view.panel.InvalLRect(dialogImage.extentLRect);
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TImageWithID.AddImage(dialogImage: TDialogImage);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.children.InsLast(dialogImage);
    dialogImage.parent := SELF;
    dialogImage.HaveView(SELF.view);
    IF EmptyLRect(SELF.extentLRect) THEN
        SELF.extentLRect := dialogImage.extentLRect
    ELSE
{$H-}   UnionLRect(SELF.extentLRect, dialogImage.extentLRect, SELF.extentLRect); {$H+}
    IF SELF.parent <> NIL THEN
        SELF.parent.RecalcExtent;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TImageWithID.BringToFront(dialogImage: TDialogImage);
    VAR s:      TListScanner;
        image:  TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.children <> NIL THEN
        BEGIN
        s := SELF.children.Scanner;
        WHILE s.Scan(image) DO
            IF image = dialogImage THEN
                BEGIN
                s.Delete(FALSE);
                s.Done;
                SELF.children.insLast(dialogImage);
                END;
        END;
    IF SELF.parent <> NIL THEN
        SELF.parent.BringToFront(SELF);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TImageWithID.CursorAt(mouseLPt: LPoint): TCursorNumber;
    VAR s:              TListScanner;
        dialogImage:    TDialogImage;
        cursorNumber:   TCursorNumber;
{default: just passes the request on to children until one sets it}
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    cursorNumber := noCursor;
    IF LRectHasLPt(SELF.extentLRect, mouseLPt) THEN
        IF SELF.children <> NIL THEN
            BEGIN
            s := SELF.children.Scanner;
            WHILE s.Scan(dialogImage) DO
                IF dialogImage.isActive THEN
                    BEGIN
                    cursorNumber := dialogImage.CursorAt(mouseLPt);
                    IF cursorNumber <> noCursor THEN
                        s.Done;
                    END;
            END;
    CursorAt := cursorNumber;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgCold}
PROCEDURE TImageWithID.DeleteImage(dialogImage: TDialogImage; andFree: BOOLEAN);
{deletes the indicated dialogImage from my children}
    VAR s:              TListScanner;
        aDialogImage:   TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    s:= SELF.children.Scanner;
    WHILE s.Scan(aDialogImage) DO
        IF aDialogImage = dialogImage THEN
            BEGIN
            IF (TDialogView(SELF.view).isShowing) AND (dialogImage.isActive) THEN
                SELF.view.panel.InvalLRect(dialogImage.extentLRect);
            s.Delete(andFree);
            s.Done;
            END;
    {$IFC fTrace}EP;{$ENDC}
 END;


{$S DlgHot}
PROCEDURE TImageWithID.Draw;
    PROCEDURE YouDraw(obj: TObject);
        VAR dialogImage: TDialogImage;
    BEGIN
        dialogImage := TDialogImage(obj);
        IF dialogImage.isActive THEN
            dialogImage.Draw;
    END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF LRectIsVisible(SELF.extentLRect) THEN
        BEGIN
        SELF.EachActualPart(YouDraw);
        SELF.DrawJustMe;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TImageWithID.EachActualPart(PROCEDURE DoToObject(filteredObj: TObject));
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.children <> NIL THEN
        SELF.children.Each(DoToObject);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TImageWithID.EachVirtualPart(PROCEDURE DoToObject(filteredObj: TObject));
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.EachActualPart(DoToObject); {???}
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION TImageWithID.HasId(id: S255): BOOLEAN;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
{$H-} id :=  Copy(id, 1, MIN(idLength, LENGTH(id))); {$H+}
    StrUpperCased(@id);

    IF SELF.id = id THEN
        HasId := TRUE
    ELSE
        HasId := FALSE;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE  TImageWithID.HaveView(view: TView);
    PROCEDURE YouHaveView(obj: TObject);
        VAR dialogImage:  TDialogImage;
    BEGIN
        dialogImage := TDialogImage(obj);
        dialogImage.HaveView(view);
    END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.view := view;
    SELF.EachActualPart(YouHaveView);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S SgLayout}
FUNCTION TImageWithID.LaunchLayoutBox(view: TView): TImage;
    VAR dialogImage:        TDialogImage;
        newExtent:          LRect;
        boxTitle:           S255;
        theString:          TLegend;
        childsLayoutBox:    TLayoutBox;
        myLayoutBox:        TLayoutBox;
        plannerView:        TPlannerView;
        postChildExtent:    LRect;
        withChildren:       BOOLEAN;
    PROCEDURE YouMakeLayoutBoxes(obj: TObject);
            VAR dialogImage:    TDialogImage;
                interimImage:   TImage;
        BEGIN
        dialogImage := TDialogImage(obj);
        interimImage := dialogImage.LaunchLayoutBox(view);
        IF interimImage <> NIL THEN
            BEGIN
            childsLayoutBox := TLayoutBox(interimImage);
            myLayoutBox.AddImage(childsLayoutBox);
            UnionLRect(postChildExtent, childsLayoutBox.extentLRect, postChildExtent);
            END;
        END;
BEGIN
    {$IFC fTrace}BP(10);{$ENDC}
    IF NOT SELF.isActive THEN
       LaunchLayoutBox := NIL
    ELSE
        BEGIN {=}
        plannerView := TPlannerView(view);
        IF SELF.ID <> '' THEN
            boxTitle := SELF.id
        ELSE
        IF SELF.idNumber = noIDNumber THEN
            boxTitle := ''
        ELSE
            IntToString(SELF.idNumber, @boxTitle);

        withChildren := (SELF.children <> NIL);
        IF withChildren THEN
            withChildren := SELF.children.Size > 0;

        myLayoutBox := TLayoutBox.CREATE(NIL, SELF.Heap, SELF.extentLRect, boxTitle, NIL, plannerView, SELF,
                        stdIDBorders, FALSE, withChildren, withChildren);
                   {default for a dialogImage is for the layout box to SUPPRESS drawing the manipulee}

        postChildExtent := SELF.extentLRect; {i.e., WITHOUT my borders}
        SELF.EachActualPart(YouMakeLayoutBoxes); {tells my children to make their own layout
                                                  boxes; may grow postChildExtent}

        myLayoutBox.RecalcExtent;
        LaunchLayoutBox := myLayoutBox;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TImageWithID.ObjectWithIDNumber(idNumber: INTEGER):  TDialogImage;
    VAR s:              TListScanner;
        dialogImage:    TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    ObjectWithIDNumber := NIL;
    IF SELF.children <> NIL THEN
        BEGIN
        s := SELF.children.Scanner;
        WHILE s.Scan(dialogImage) DO
            IF dialogImage.withID THEN
                IF TImageWithID(dialogImage).idNumber = idNumber THEN
                    BEGIN
                    ObjectWithIDNumber := dialogImage;
                    s.Done;
                    END;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TImageWithID.ObjWithId(id: S255):  TDialogImage;
    VAR s:              TListScanner;
        dialogImage:    TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    id :=  Copy(id, 1, MIN(idLength, LENGTH(id)));
    StrUpperCased(@id);
    ObjWithId := NIL;
    IF SELF.children <> NIL THEN
        BEGIN
        s := SELF.children.Scanner;
        WHILE s.Scan(dialogImage) DO
            IF dialogImage.withID THEN
                IF TImageWithID(dialogImage).id = id THEN
                    BEGIN
                    ObjWithId := dialogImage;
                    s.Done;
                    END;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TImageWithID.OffSetBy(deltaLPt: LPoint);
    PROCEDURE YouOffset(obj: TObject);
    BEGIN
        TDialogImage(obj).OffsetBy(deltaLPt);
    END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
{$H-} OffsetLRect(SELF.extentLRect, deltaLPt.h, deltaLPt.v); {$H+}
    SELF.EachActualPart(YouOffset);  {tells children}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgWarm}
PROCEDURE TImageWithID.RecalcExtent;  {a bottom-up communication line; child who changes tells
                                         his parent, who changes himself and then tells HIS parent}
    VAR s:              TListScanner;
        dialogImage:    TDialogImage;
        newExtent:      LRect;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    {can be speeded up}
    IF SELF.children <> NIL THEN
        IF SELF.children.Size > 0 THEN
            BEGIN
            newExtent := zeroLRect;
            s := SELF.children.Scanner;
            WHILE s.Scan(dialogImage) DO
                IF EmptyLRect(newExtent) THEN
                    newExtent := dialogImage.extentLRect
                ELSE
                    UnionLRect(newExtent, dialogImage.extentLRect, newExtent);
            SELF.Resize(newExtent);
            END;
    IF SELF.parent <> NIL THEN
        SELF.parent.RecalcExtent;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgCold}
PROCEDURE TImageWithID.ReplaceImage(replacee, newValue: TDialogImage);
 {make this such that it puts back at same place; or use Become}
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.DeleteImage(replacee, TRUE);
    SELF.AddImage(newValue);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TImageWithID.StillMyMouse(mouseLPt : LPoint): BOOLEAN;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.Hit(mouseLPt) THEN
        StillMyMouse := TRUE {I've handled it}
    ELSE
        StillMyMouse := FALSE; {give it to someone else}
   {default; this will usually be overridden in subclass}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;


METHODS OF TDialog;


{$S DlgAlloc}
FUNCTION TDialog.CREATE(object: TObject; heap: THeap; itsKey: S4; itsView: TView): TDialog;
    VAR itsStringKey:   TStringKey;
        itsExtent:      LRect;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    WITH stdButtonMetrics DO
        BEGIN
        height := stdBtnHeight;
        curvH := stdCurvH;
        curvV := stdCurvV;
        typeStyle := sysTypeStyle;
        penState := normalPen;
        expandNum := 4;
        expandDen := 3;
        absMinWidth := 80;
        END;
    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TDialog(TImageWithID.CREATE(object, heap, zeroLRect, itsKey, itsView, TRUE));
    XferLeft(Ptr(ORD(@itsKey)+1), @itsStringKey.trueKey, 4);  {get it into LONGINT form}
    itsStringKey.key := itsKey;
    SELF.stringKey := itsStringKey;
   {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TDialog.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('stringKey: RECORD trueKey: LONGINT; key: STRING[4] END');
    Field('');
END;
{$ENDC}


{$S DlgAlloc}
FUNCTION  TDialog.NewButton(itsPhrase: INTEGER; itsMetrics: TButtonMetrics; sameSizedButton: TButton;
                    itsCmdNumber: TCmdNumber): TButton;
    VAR itsID:          S255;
        itsLocation:    LPoint;
        button:         TButton;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    GetTextAndLocation(itsPhrase, itsID, itsLocation);
    button := SELF.AddButton(itsID, itsLocation, itsMetrics, sameSizedButton, itsCmdNumber);
    button.idNumber := itsPhrase;
    NewButton := button;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.NewCluster(itsPhrase: INTEGER): TCluster;
    VAR itsID:          S255;
        itsLocation:    LPoint;
        cluster:        TCluster;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    GetTextAndLocation(itsPhrase, itsID, itsLocation);
    cluster := SELF.AddStdCluster(itsID, itsLocation.h, itsLocation.v);
    cluster.idNumber := itsPhrase;
    NewCluster := cluster;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.NewFreeCheckbox(itsPhrase: INTEGER;  boxWidth: INTEGER;
    boxHeight: INTEGER; wantLabel: BOOLEAN; labelOffset: Point; itsTypeStyle: TTypeStyle): TCheckBox;
    VAR itsID:          S255;
        itsLocation:    LPoint;
        checkbox:       TCheckbox;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    GetTextAndLocation(itsPhrase, itsID, itsLocation);
    checkbox := SELF.AddFreeCheckbox(itsID, itsLocation.h, itsLocation.v, boxWidth, boxHeight,
        wantLabel, labelOffset, itsTypeStyle);
    checkbox.idNumber := itsPhrase;
    NewFreeCheckbox := checkbox;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.NewInputFrame(itsPhrase: INTEGER; promptTypeStyle: TTypeStyle;
        inputOffset: Point; inputTypeStyle: TTypeStyle;
        maxInputChars: INTEGER; itsBorders: Rect; drawInputLRect: BOOLEAN;
        drawHitLRect: BOOLEAN): TInputFrame;
    VAR itsID:          S255;
        itsLocation:    LPoint;
        inputFrame:     TInputFrame;
        inputLocation:  LPoint;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    GetTextAndLocation(itsPhrase, itsID, itsLocation);

    SetQDTypeStyle(promptTypeStyle);
    WITH inputLocation DO
        BEGIN
        h := itsLocation.h + StringWidth(itsID) + inputOffset.h;
        v := itsLocation.v + inputOffset.v;
        END;

    inputFrame := SELF.AddInputFrame(itsID, itsLocation, promptTypeStyle,
        inputLocation, inputTypeStyle, maxInputChars, itsBorders, drawInputLRect,
        drawHitLRect);
    inputFrame.idNumber := itsPhrase;
    NewInputFrame := inputFrame;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.NewLegend(itsPhrase: INTEGER; itsTypeStyle: TTypeStyle): TLegend;
    VAR itsID:          S255;
        itsLocation:    LPoint;
        legend:         TLegend;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    GetTextAndLocation(itsPhrase, itsID, itsLocation);
    legend := SELF.AddStdLegend(itsID, itsLocation.h, itsLocation.v, itsTypeStyle);
    NewLegend := legend;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.NewRowOfBoxes(itsPhrase: INTEGER; numberOfBoxes: INTEGER;
    startingIDNumber: INTEGER; boxWidth: INTEGER; boxHeight: INTEGER; boxSpacing: INTEGER): TCluster;
    VAR itsID:          S255;
        itsLocation:    LPoint;
        cluster:        TCluster;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    GetTextAndLocation(itsPhrase, itsID, itsLocation);
    cluster := SELF.AddRowOfBoxes(itsID, itsLocation.h, itsLocation.v, numberOfBoxes,
        startingIDNumber, boxWidth, boxHeight, boxSpacing);
    cluster.idNumber := itsPhrase;
    NewRowOfBoxes := cluster;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialog.AddOKButton(cmdNumber: TCmdNumber);
    VAR button: TButton;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    button := SELF.NewButton(phOK, stdButtonMetrics,
                TButton(SELF.ObjectWithIDNumber(phCancel)), cmdNumber);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialog.AddCancelButton(cmdNumber: TCmdNumber);
    VAR button: TButton;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    button := SELF.NewButton(phCancel, stdButtonMetrics,
                TButton(SELF.ObjectWithIDNumber(phOK)), cmdNumber);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.AddBigFreeCheckbox(itsId: S255; itsXLoc, itsYLoc: LONGINT): TCheckbox;                                                {---}
    VAR location:       LPoint;
        itsChars:       S255;
        newBox:         TCheckbox;
        labelOffset:    Point;
        typeStyle:      TTypeStyle;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SetLPt(location, itsXLoc, itsYLoc);
        SetPt(labelOffset, 20, -4);
        MakeTypeStyle(famClassic, size18Point, [], typeStyle);
        newBox := TCheckbox.CREATE(NIL, SELF.Heap, itsId, SELF.view, location, 36, 24, TRUE,
            labelOffset, typeStyle);
        SELF.AddImage(newBox);
        AddBigFreeCheckbox := newBox;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
FUNCTION  TDialog.AddButton(itsId: S255; itsLocation: LPoint; itsMetrics: TButtonMetrics;
        sameSizedButton: TButton; itsCmdNumber: TCmdNumber): TButton;
    VAR button: TButton;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    button := TButton.CREATE(NIL, SELF.Heap, itsId, SELF.view, itsLocation, itsMetrics,
        sameSizedButton, itsCmdNumber);
    SELF.AddImage(button);
    AddButton := button;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.AddStdButton(itsId: S255; itsXLoc, itsYLoc: LONGINT;  sameSizedButton: TButton;
                itsCmdNumber: TCmdNumber): TButton;
VAR location:   LPoint;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SetLPt(location, itsXLoc, itsYLoc);
    AddStdButton := SELF.AddButton(itsID, location, stdButtonMetrics, sameSizedButton, itsCmdNumber);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION TDialog.AddStdFreeCheckbox(itsId: S255; itsXLoc, itsYLoc: LONGINT): TCheckBox;
VAR legend:     TLegend;
    location:   LPoint;
    checkbox:   TCheckbox;
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
   SetLPt (location, itsXLoc, itsYLoc);
   checkbox := TCheckbox.CREATE(NIL, SELF.Heap, itsId, SELF.view, location, stdBoxWidth,
        stdBoxHeight, TRUE, stdLabelOffset, sysTypeStyle);
   SELF.AddImage(checkbox);
   AddStdFreeCheckbox := checkbox;
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION TDialog.AddStdCluster(itsId: S255; itsXLoc, itsYLoc: LONGINT): TCluster;
    VAR location:   LPoint;
        cluster:    TCluster;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SetLPt(location, itsXLoc, itsYLoc);
        cluster :=TCluster.CREATE(NIL, SELF.Heap, itsId, SELF.view, location);
        SELF.AddImage(cluster);
        AddStdCluster := cluster;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
FUNCTION  TDialog.AddFreeCheckbox(itsID: S255; itsXLoc, itsYLoc: LONGINT; boxWidth: INTEGER;
        boxHeight: INTEGER; wantLabel: BOOLEAN; labelOffset: Point; itsTypeStyle: TTypeStyle): TCheckbox;
    VAR location:   LPoint;
        checkbox:   TCheckbox;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SetLPt(location, itsXLoc, itsYLoc);
        checkbox := TCheckbox.CREATE(NIL, SELF.Heap, itsID, SELF.view, location, boxWidth, boxHeight,
                        wantLabel, labelOffset, itsTypeStyle);
        SELF.AddImage(checkbox);
        AddFreeCheckbox := checkbox;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
FUNCTION  TDialog.AddInputFrame(itsId: S255;
        promptLocation: LPoint; promptTypeStyle: TTypeStyle;
        inputLocation:  LPoint; inputTypeStyle: TTypeStyle;
        maxInputChars: INTEGER; itsBorders: Rect; drawInputLRect: BOOLEAN;
        drawHitLRect: BOOLEAN): TInputFrame;
    VAR inputFrame: TInputFrame;
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
   inputFrame := TInputFrame.CREATE(NIL, SELF.Heap, itsID, SELF.view, promptLocation, promptTypeStyle,
        inputLocation, inputTypeStyle, maxInputChars, itsBorders,
        drawInputLRect, drawHitLRect);
   SELF.AddImage(inputFrame);
   AddInputFrame := inputFrame;
   {$IFC fTrace}EP;{$ENDC}
 END;


{$S DlgAlloc}
FUNCTION TDialog.AddRowOfBoxes(itsID: S255; itsXLoc, itsYLoc: LONGINT; numberOfBoxes: INTEGER;
    startingIDNumber: INTEGER; boxWidth: INTEGER; boxHeight: INTEGER; boxSpacing: INTEGER): TCluster;
    VAR currentIDNumber: INTEGER;
        checkbox:       TCheckbox;
        newLocation:    LPoint;
        newID:          S255;
        cluster:        TCluster;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    cluster := SELF.AddStdCluster(itsID, itsXLoc, itsYLoc);
    FOR currentIDNumber := startingIDNumber TO (startingIDNumber + numberOfBoxes -  1) DO
        BEGIN
        IF cluster.lastBox = NIL THEN {this is the first to be inserted}
            newLocation := cluster.location
        ELSE { There is already at least one box in the cluster -- align to right of it}
            WITH newLocation DO
                BEGIN
                h := cluster.lastBox.rectImage.extentLRect.right + boxSpacing;  {??}
                v := cluster.lastBox.rectImage.extentLRect.top;
                END;
        IntToString(currentIDNumber, @newID);
        checkbox := cluster.AddCheckbox(newID, newLocation, boxWidth, boxHeight, FALSE, zeroPt,
            sysTypeStyle, FALSE);
        checkBox.IDNumber := currentIDNumber;
        END;
    AddRowOfBoxes := cluster;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.AddStdInputFrame(itsId: S255; itsXLoc: LONGINT;
        itsYLoc: LONGINT; maxInputChars : INTEGER): TInputFrame;
    VAR promptLocation: LPoint;
        inputLocation:  LPoint;
        inputFrame:     TInputFrame;
BEGIN
   {$IFC fTrace}BP(11);{$ENDC}
    SetLPt(promptLocation, itsXLoc, itsYLoc);

    SetQDTypeStyle(sysTypeStyle);

    WITH inputLocation DO
        BEGIN
        h := itsXLoc + StringWidth(itsID) + 20;
        v := itsYLoc;
        END;

    inputFrame := TInputFrame.CREATE(NIL, SELF.Heap, itsId, SELF.view, promptLocation, sysTypeStyle,
        inputLocation, stdInputTypeStyle, maxInputChars,
        stdFrameBorders, TRUE {draw input LRect}, TRUE {draw HitLRect});
    SELF.AddImage(inputFrame);
    AddStdInputFrame := inputFrame;
    {$IFC fTrace}EP;{$ENDC}
 END;


{$S DlgAlloc}
FUNCTION  TDialog.AddStdLegend(itsId: S255; itsXLoc, itsYLoc: LONGINT;
        itsTypeStyle: TTypeStyle): TLegend;
    VAR newString:  TLegend;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    newString := NewStdLegend(SELF.Heap, itsID, itsXLoc, itsYLoc, SELF.view, itsTypeStyle);
    SELF.AddImage(newString);
    AddStdLegend := newString;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION  TDialog.AddSysLegend(itsId: S255; itsXLoc, itsYLoc: LONGINT): TLegend;
    VAR newString:  TLegend;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    newString := NewSysLegend(SELF.Heap, itsID, itsXLoc, itsYLoc, SELF.view);
    SELF.AddImage(newString);
    AddSysLegend := newString;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialog.ButtonPushed(button: TButton);  {usually'll be called through SUPERSELF}
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.parent <> NIL THEN
        TDialog(SELF.parent).ButtonPushed(button)
    ELSE
        TDialogView(SELF.view).ButtonPushed(button);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialog.CheckboxHit(checkbox: TCheckbox; toggleDirection: BOOLEAN);
    {default--passes up the line; client can reimplement}
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.parent <> NIL THEN
        BEGIN
        IF InClass(SELF.parent, TDialog) THEN
            TDialog(SELF.parent).CheckboxHit(checkbox, toggleDirection)
        ELSE
            SELF.parent.ControlHit(checkbox, toggleDirection);
        END
    ELSE
        TDialogView(SELF.view).CheckboxHit(checkbox, toggleDirection);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialog.ControlHit(control: TDialogImage; toggleDirection: BOOLEAN);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF InClass(control, TButton) THEN
        SELF.ButtonPushed(TButton(control))  {this branch perhaps not achievable in current design}
    ELSE
    IF InClass(control, TCheckbox) THEN
        SELF.CheckboxHit(TCheckbox(control), toggleDirection);   {Client can add own kinds by redefining this}
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION TDialog.DownAt(mouseLPt: LPoint): TDialogImage;
    VAR s:                  TListScanner;
        dialogImage:        TDialogImage;
        currentDialogImage: TDialogImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    currentDialogImage := NIL;
    IF SELF.Hit(mouseLPt) THEN
        BEGIN
        s := SELF.children.Scanner;
        WHILE s.Scan(dialogImage) DO
            IF dialogImage.isActive THEN
                BEGIN
                currentDialogImage := dialogImage.DownAt(mouseLPt);
                IF currentDialogImage <> NIL THEN
                    s.Done;
                END;
        END;
     DownAt := currentDialogImage;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialog.PushButton(button: TButton);          {client or ToolKit may call}
    PROCEDURE TurnOnTheJuice;
        BEGIN
        button.Highlight(hOffToOn);
        END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF NOT button.isHighlighted THEN
        SELF.view.panel.OnAllPadsDo(TurnOnTheJuice);
    TDialogView(SELF.view).hitButton := button;
    SELF.ButtonPushed(button);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgWarm}
PROCEDURE TDialog.RecalcExtent;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SUPERSELF.RecalcExtent;  {build up my size as the sum of the sizes of my children}
    IF SELF.parent = NIL THEN
        SELF.view.RecalcExtent;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TDialog.SetDefaultButton(button: TButton);
    VAR thickPnSize:   point;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.parent <> NIL THEN
        TDialog(SELF.parent).SetDefaultButton(button)
    ELSE
        TDialogView(SELF.view).SetDefaultButton(button);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TDialog.SelectInputFrame(inputFrame: TInputFrame);
    VAR panel:          TPanel;
        newFrameSel:    TFrameSelection;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    panel := SELF.view.panel;
    panel.BeginSelection;
    newFrameSel := TFrameSelection(panel.selection.FreedAndReplacedBy(
                         TFrameSelection.CREATE(NIL, SELF.Heap, inputFrame)));
    newFrameSel.coSelection.Become(
        inputFrame.textDialogImage.textImage.text.SelectAll(
                        inputFrame.textDialogImage.textImage));
    panel.Highlight(panel.selection.coSelection, hOffToOn);
    {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


{-------------------------------------------------------------------------------------------------------}


METHODS OF TButton;


{$S DlgAlloc}
FUNCTION TButton.CREATE(object: TObject; heap: THeap; itsId: S255; itsView: TView;
         itsLocation: LPoint; itsMetrics: TButtonMetrics;
         sameSizedButton: TButton; itsCmdNumber: TCmdNumber):  TButton;

    VAR buttonLRect:    LRect;
        itsLegend:      TLegend;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SetLRect(buttonLRect, -1, 0, 1, 1);
    OffsetLRect(buttonLRect, itsLocation.h, itsLocation.v);
    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TButton(TImageWithID.CREATE(object, heap, buttonLRect, itsId, itsView, TRUE));

    WITH SELF DO
        BEGIN
        cmdNumber := itsCmdNumber;
        buttonMetrics := itsMetrics;
        isHighlighted := FALSE;
       {minWidth will be set by RecalcExtent}
        END;

    IF sameSizedButton <> NIL THEN {weave me into chain of same-sized buttons}
        BEGIN
        SELF.nextSameSizedButton := sameSizedButton.nextSameSizedButton;
        sameSizedButton.nextSameSizedButton := SELF;
        END
    ELSE
        SELF.nextSameSizedButton := SELF;

    itsLegend := NewStdLegend(heap, itsID, itsLocation.h, itsLocation.v, SELF.view,
                itsMetrics.typeStyle);
    SELF.AddImage(itsLegend);
    SELF.Resize(buttonLRect);  {the AddImage will've made things out of balance}
    SELF.legend := itsLegend;
    itsLegend.wouldBeDraggable := FALSE; {as an entity unto itself during layout}

    SELF.RecalcExtent;  {performs lots of magic}

    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TButton.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('cmdNumber: INTEGER');
    Field('minWidth: INTEGER');
    Field('isHighlighted: BOOLEAN');
    Field('nextSameSizedButton: TButton');
    Field('legend: TLegend');
    Field(CONCAT('buttonMetrics: RECORD height: INTEGER; curvH: INTEGER; curvV: INTEGER;',
            'typeStyle: LONGINT; expandNum: INTEGER; expandDen: INTEGER;',
            'absMinWidth: INTEGER; penState: ARRAY[1..18] OF Byte END'));
    Field('');
END;
{$ENDC}


{$S DlgHot}
PROCEDURE TButton.DrawJustMe;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SetPenState(SELF.buttonMetrics.penState);
    FrameLRRect(SELF.extentLRect, SELF.buttonMetrics.curvH, SELF.buttonMetrics.curvV);
    IF SELF.isHighlighted THEN
        InvrtLRRect(SELF.extentLRect, SELF.buttonMetrics.curvH, SELF.buttonMetrics.curvV);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TButton.Highlight(highTransit: THighTransit);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    InvrtLRRect(SELF.extentLRect, SELF.buttonMetrics.curvH, SELF.buttonMetrics.curvV);
    SELF.isHighLighted := (highTransit = hOffToOn);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgLayout}
FUNCTION  TButton.LaunchLayoutBox(view: TView): TImage;
    VAR layoutBox:      TLayoutBox;
        layBoxExtent:   LRect;
        s:              TListScanner;
        childLayoutBox: TLayoutBox;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    LaunchLayoutBox := TButtonLayoutBox.CREATE(NIL, SELF.Heap, SELF, view);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TButton.MousePress(mouseLPt: LPoint);
    PROCEDURE TurnOnButton;
        BEGIN
        SELF.HighLight(hOffToOn);
        END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.view.panel.OnAllPadsDo(TurnOnButton);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TButton.MouseRelease;
  BEGIN
      {$IFC fTrace}BP(11);{$ENDC}
      TDialog(SELF.parent).PushButton(SELF);
      {$IFC fTrace}EP;{$ENDC}
  END;


{$S DlgAlloc}
PROCEDURE TButton.RecalcExtent;
    VAR dialogView:         TDialogView;
        curWidth:           INTEGER;
        timesThrough:       INTEGER;
        nextButton:         TButton;
        legend:             TLegend;
        paraImage:          TParaImage;
        width:              INTEGER;
        styleIndex:         INTEGER;
        oldLegendLoc:       LPoint;
        lRectToInval:       LRect;
        legLength:          INTEGER;
        textDialogImage:    TTextDialogImage;
        editLegendSelection:TEditLegendSelection;
        paraExtent:         LRect;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    lRectToInval := SELF.extentLRect;
    legend := TLegend(SELF.children.First);
    oldLegendLoc := legend.location;

    WITH legend.extentLRect DO
        legLength := right - left;
    WITH SELF, buttonMetrics DO
{$H-}   minWidth := MAX(absMinWidth, (legLength * expandNum) DIV expandDen);  {$H+}

    curWidth := SELF.minWidth;
    FOR timesThrough := 1 TO 2 DO
        BEGIN
        nextButton := SELF.nextSameSizedButton;
        WHILE nextButton <> SELF DO {send this round my circle of same-sized buttons}
            BEGIN
            nextButton.Recompute(curWidth);
            WITH nextButton.extentLRect DO
                curWidth := right - left;
            nextButton := nextButton.nextSameSizedButton;
            END;
        SELF.Recompute(curWidth);
        END;

   UnionLRect(lRectToInval, SELF.extentLRect, lRectToInval);
   IF TDialogView(SELF.view).isShowing THEN
        SELF.view.panel.InvalLRect(lRectToInval);

    IF SELF.parent <> NIL THEN
        SELF.parent.RecalcExtent;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
 PROCEDURE TButton.Recompute(minWidth: INTEGER);
    VAR buttonWidth:    INTEGER;
        labelWidth:     INTEGER;
        legend:         TLegend;
        topLeft:        LPoint;
        shape:          LRect;
        offset:         LPoint;
        width:          INTEGER;
        curLegendWidth: INTEGER;
        textExtent:     LRect;
        topCenter:      LPoint;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    legend := SELF.legend;

    topLeft := SELF.extentLRect.topLeft;
    WITH topCenter, SELF.extentLRect DO
        BEGIN
        v := top;
        h := (left + right) DIV 2;
        END;

    buttonWidth := SELF.minWidth;
    IF buttonWidth < minWidth THEN
        buttonWidth := minWidth;

    SetParaExtent(legend.paragraph, SELF.view, zeroLPt, textExtent);
    curLegendWidth := textExtent.right;

    SetLPt(offset, (topCenter.h  - (curLegendWidth DIV 2)) - legend.location.h,
                   (topCenter.v +    ((SELF.buttonMetrics.height DIV 2) + 3)) - legend.location.v);
    legend.OffsetBy(offset);

    SetLRect(shape, 0, 0, buttonWidth, SELF.buttonMetrics.height);
    OffSetLRect(shape, topCenter.h - (buttonWidth DIV 2), topCenter.v);

    SELF.Resize(shape);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION TButton.StillMyMouse(mouseLPt: LPoint): BOOLEAN;
{Called when the mouse which went down in me has moved; possibly it is no longer in me}
    PROCEDURE TurnOffButton;
        BEGIN
        SELF.Highlight(hOnToOff);
        END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.Hit(mouseLPt) THEN
        StillMyMouse := TRUE {still in same button -- do nothing}
    ELSE { no longer in the button ; need to unhilight and remove claim }
        BEGIN
        SELF.view.panel.OnAllPadsDo(TurnOffButton);
        StillMyMouse := FALSE;  {see if anyone else wants this guy}
        END ;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;


{-------------------------------------------------------------------------------------------------------}


METHODS OF TCheckbox;


{$S DlgAlloc}
FUNCTION TCheckbox.CREATE(object: TObject; heap: THeap; itsId: S255; itsView: TView;
            itsLocation: LPoint; boxWidth: INTEGER; boxHeight: INTEGER; wantLabel: BOOLEAN;
            labelOffset: Point; itsTypeStyle: TTypeStyle): TCheckbox;
    VAR extentLRect:    LRect;
        tempLRect:      LRect;
        rectImage:      TRectImage;
        stringLoc:      LPoint;
        itsString:      TLegend;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SetLRect(extentLRect, 0, 0, boxWidth, boxHeight);
    OffsetLRect(extentLRect, itsLocation.h, itsLocation.v);

    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TCheckbox(TImageWithID.CREATE(object, heap, extentLRect, itsId, itsView, TRUE));

    SELF.isSelected := FALSE;

    rectImage := TRectImage.CREATE(NIL, heap, extentLRect, noID, itsView, normalPen, FALSE);
    SELF.AddImage(rectImage);
    SELF.rectImage := rectImage;

    IF wantLabel THEN
        BEGIN
        itsString := NewStdLegend(SELF.Heap, itsID, extentLRect.right + labelOffset.h,
                    extentLRect.bottom + labelOffset.v, itsView, itsTypeStyle);
        SELF.AddImage(itsString);
        SELF.legend := itsString;
        END
    ELSE
        SELF.legend := NIL;
    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TCheckbox.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('isSelected: BOOLEAN');
    Field('rectImage: TRectImage');
    Field('legend: TLegend');
    Field('');
END;
{$ENDC}


{$S DlgHot}
PROCEDURE TCheckbox.ChangeLabel(newS255: S255);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.legend = NIL THEN
{$IFC fDbgOK}
        ABCBreak('No legend to chg', 0)  {later could perhaps launch a new label}
{$ENDC}
    ELSE
        SELF.legend.ChangeString(newS255);
    SELF.RecalcExtent;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION TCheckbox.CursorAt(mouseLPt: LPoint): TCursorNumber;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.Hit(mouseLPt) THEN
        CursorAt := checkCursor
    ELSE
        CursorAt := noCursor;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TCheckbox.Draw;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    PenNormal;
    IF SELF.IsSelected THEN
        FillLRect(SELF.rectImage.extentLRect, lPatBlack)     {fill with black if selected}
    ELSE
        FillLRect(SELF.rectImage.extentLRect, lPatWhite);
    SELF.rectImage.Draw;                     {draw the outline box in any case}
    IF SELF.legend <> NIL THEN
        SELF.legend.Draw;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgLayout}
FUNCTION  TCheckbox.LaunchLayoutBox(view: TView): TImage;
    VAR layoutBox:      TLayoutBox;
        childLayoutBox: TLayoutBox;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.legend <> NIL THEN {has string; use normal layout box}
        LaunchLayoutBox := SUPERSELF.LaunchLayoutBox(view)
    ELSE
        BEGIN  {a checkbox without an associated string}
        childLayoutBox := TLayoutBox(SELF.rectImage.LaunchLayoutBox(view));
        layoutBox := TLayoutBox.CREATE(NIL, SELF.Heap, childLayoutBox.extentLRect, noID, NIL,
            view, SELF, zeroRect, FALSE, FALSE, TRUE);
        layoutBox.AddImage(childLayoutBox);
        LaunchLayoutBox := layoutBox;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TCheckbox.MousePress(mouseLPt: LPoint);
{This proc is only called for mouspresses within "free check boxes", which is to say Checkboxes
which are componenents of a dialogView -- NOT for Checkboxes which are subdialogImages of another dialogImage}
    VAR carryOutTheToggle:  BOOLEAN;
        dialogView:         TDialogView;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    carryOutTheToggle := TRUE;
    dialogView := TDialogView(SELF.view);
    IF dialogView.paintFreeBoxes THEN {need to worry about only toggling if in current sense}
        BEGIN
        IF dialogView.startedPainting THEN {have already started 'painting' free checkboxes}
            BEGIN
            IF dialogView.paintSense = SELF.isSelected THEN
                carryOutTheToggle := FALSE {already in the sense being painted--do nothing}
            END
        ELSE {just starting painting; establish the painting sense}
            BEGIN
            dialogView.startedPainting := TRUE;
            dialogView.paintSense := NOT SELF.isSelected;
            END;
        END;
    IF carryOutTheToggle THEN
       BEGIN
       SELF.Toggle;
       dialogView.panel.InvalLRect(SELF.rectImage.extentLRect);
       SELF.ControlHit(SELF, SELF.isSelected); {pass it up to cluster and Dialog and even DialogView}
       END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TCheckbox.Toggle;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.isSelected := NOT SELF.isSelected;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;


{-------------------------------------------------------------------------------------------------------}

METHODS OF TCluster;


{$S DlgAlloc}
FUNCTION  TCluster.CREATE(object: TObject; heap: THeap; itsId: S255; itsView: TView;
            itsLocation: LPoint): TCluster;
                VAR extentLRect: LRect;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    WITH itsLocation DO
        SetLRect(extentLRect, h, v, h + 1, v + 1); {include that pt in ultimate extent}
    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TCluster(TImageWithID.CREATE(object, heap, extentLRect, itsId, itsView, TRUE));

    WITH SELF DO
        BEGIN
        location := itsLocation;
        hitBox := NIL;
        hiLitBox := NIL;
        lastBox  := NIL;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TCluster.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('location: LPoint');
    Field('hitBox: TCheckBox');
    Field('hiLitBox: TCheckBox');
    Field('lastBox: TCheckBox');
    Field('');
END;
{$ENDC}


{$S DlgAlloc}
FUNCTION TCluster.AddAlignedCheckbox(itsId: S255; selectThisOne: BOOLEAN): TCheckbox;
    CONST   stdIncrement = 20;
    VAR lastBox:        TCheckbox;
        location:       LPoint;
        itsBoxWidth:    INTEGER;
        itsBoxHeight:   INTEGER;
        checkBox:       TCheckbox;
        wantLabel:      BOOLEAN;
        labelOffset:    Point;
        vhs:            VHSelect;
        itsTypeStyle:   TTypeStyle;
        styleChange:    TStyleChange;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    itsTypeStyle := sysTypeStyle;
    wantLabel := (itsID <> noID);
    labelOffset := stdLabelOffset;
    itsBoxWidth := stdBoxWidth;
    itsBoxHeight := stdBoxHeight;

    lastBox := SELF.lastBox;
    IF lastBox = NIL THEN {this is the first to be inserted}
        location := SELF.location
    ELSE    {there is already at least one box in the cluster -- align to right of it & use its params}
        BEGIN
        WITH location DO
            BEGIN
            h := lastBox.extentLRect.right + stdIncrement;
            v := lastBox.rectImage.extentLRect.top;
            END;
        WITH lastBox.rectImage.extentLRect DO
            BEGIN
            itsBoxWidth := right - left;
            itsBoxHeight := bottom - top;
            END;
        IF wantLabel THEN
            BEGIN
            IF lastBox.legend <> NIL THEN   {use same type style and label Offset as prev guy}
                BEGIN
                lastBox.legend.paragraph.typeStyles.GetAt(1, @styleChange);
                WITH lastBox, legend DO
                    BEGIN
                    itsTypeStyle := styleChange.newStyle;
                    FOR vhs := v TO h DO
                        labelOffset.vh[vhs] := location.vh[vhs] -
                            rectImage.extentLRect.botRight.vh[vhs];
                    END;
                END
            ELSE
                wantLabel := FALSE;  {last box did not have a label, so I won't either}
            END;
        END;

    checkBox := SELF.AddCheckbox(itsID, location, itsBoxWidth, itsBoxHeight,
                wantLabel, labelOffset, itsTypeStyle, selectThisOne);
    IF lastBox <> NIL THEN
        checkbox.idNumber := lastBox.idNumber + 1;
    AddAlignedCheckbox := checkbox;

    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION TCluster.NewAlignedCheckbox(itsPhrase: INTEGER; selectThisOne: BOOLEAN): TCheckbox;
    VAR itsID:          S255;
        itsLocation:    LPoint;
        checkbox:       TCheckbox;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    GetTextAndLocation(itsPhrase, itsID, itsLocation);
    checkbox := SELF.AddAlignedCheckbox(itsID, selectThisOne);
    checkbox.idNumber := itsPhrase;
    NewAlignedCheckbox := checkbox;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION TCluster.AddCheckbox(itsID: S255; itsLocation: LPoint; boxWidth: INTEGER;
                     boxHeight: INTEGER; wantLabel: BOOLEAN; labelOffset: Point;
                     itsTypeStyle: TTypeStyle;  selectThisOne: BOOLEAN): TCheckbox;
    VAR location:   LPoint;
        checkbox:   TCheckbox;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    checkbox := TCheckbox.CREATE(NIL, SELF.Heap, itsID, SELF.view, itsLocation, boxWidth,
                    boxHeight, wantLabel, labelOffset, itsTypeStyle);
    SELF.AddImage(checkbox);
    SELF.lastBox := checkbox;
    IF selectThisOne THEN
        BEGIN
        IF NOT checkbox.isSelected THEN
            checkbox.Toggle;
        SELF.hiLitBox := checkbox;
        END;
    AddCheckbox := checkbox;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
FUNCTION TCluster.NewCheckbox(itsPhrase: INTEGER; boxWidth: INTEGER;
                   boxHeight: INTEGER; wantLabel: BOOLEAN; labelOffset: Point; itsTypeStyle: TTypeStyle;
                   selectThisOne: BOOLEAN): TCheckbox;
    VAR itsID:          S255;
        itsLocation:    LPoint;
        checkbox:       TCheckbox;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    GetTextAndLocation(itsPhrase, itsID, itsLocation);
    checkbox := SELF.AddCheckbox(itsID, itsLocation, boxWidth, boxHeight, wantLabel,  labelOffset,
        itsTypeStyle, selectThisOne);
    checkbox.idNumber := itsPhrase;
    NewCheckbox := checkbox;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgAlloc}
PROCEDURE TCluster.AddRowOfBoxes(numberOfBoxes: INTEGER; startingIDNumber: INTEGER;
                boxWidth: INTEGER; boxHeight: INTEGER; boxSpacing: INTEGER);
    VAR currentIDNumber: INTEGER;
        checkbox:       TCheckbox;
        newLocation:    LPoint;
        newID:          S255;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    FOR currentIDNumber := startingIDNumber TO (startingIDNumber + numberOfBoxes -  1) DO
        BEGIN
        IF SELF.lastBox = NIL THEN {this is the first to be inserted}
            newLocation := SELF.location
        ELSE { There is already at least one box in the cluster -- align to right of it}
            WITH newLocation DO
                BEGIN
                h := SELF.lastBox.rectImage.extentLRect.right + boxSpacing;  {??}
                v := SELF.lastBox.rectImage.extentLRect.top;
                END;
        IntToString(currentIDNumber, @newID);
        checkbox := SELF.AddCheckbox(newID, newLocation, boxWidth, boxHeight, FALSE, zeroPt,
            sysTypeStyle, FALSE);
        checkBox.IDNumber := currentIDNumber;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION TCluster.Hit(mouseLPt: LPoint): BOOLEAN;
    VAR checkbox:   TCheckbox;
        s:          TListScanner;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    Hit := FALSE;
    IF LRectHasLPt(SELF.extentLRect, mouseLPt) THEN  {passes coarsest hit test; look more deeply now}
        BEGIN
        s := SELF.children.Scanner;
        WHILE s.Scan(checkbox) DO
            IF checkbox.Hit(mouseLPt) THEN
                BEGIN
                Hit := TRUE;
                SELF.hitBox := checkbox;
                s.Done;
                END;
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TCluster.MousePress(mouseLPt: LPoint);
    {We are assured that when this is called, it will have been immediately
      preceded by a successful call to TCluster.Hit .  Hence, the field
      TCluster.hitBox will correctly point to which guy was hit.}
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.SelectBox(SELF.hitBox);  {will deselect any other}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TCluster.SelectBox(checkbox: TCheckbox); {select this box, deselecting others}
        PROCEDURE DrawUnHiLitBoxOnThePad;
        BEGIN
            SELF.hiLitBox.Draw; {redraw old box unhilit}
        END;

        PROCEDURE DrawHiLitBoxOnThePad;
        BEGIN
            checkbox.Draw;     {toggle the newly selected one on}
        END;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF (SELF.hiLitBox <> checkbox) AND (checkbox <> NIL) THEN
        BEGIN
        IF SELF.hiLitBox <> NIL THEN
            BEGIN
            SELF.hiLitBox.Toggle;
            SELF.view.panel.OnAllPadsDo(DrawUnHiLitBoxOnThePad);
            SELF.ControlHit(SELF.hiLitBox, FALSE);
            END;
        SELF.hiLitBox := checkbox;   {set new box as the currently hilit one}
        checkbox.Toggle;
        SELF.view.panel.OnAllPadsDo(DrawHiLitBoxOnThePad);
        SELF.ControlHit(checkbox, TRUE);
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TCluster.StillMyMouse(mouseLPt: LPoint): BOOLEAN;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.Hit(mouseLPt) THEN {mouse is in a box of the cluster}
        BEGIN
        SELF.SelectBox(SELF.hitBox);   {will toggle any alternate box off}
        StillMyMouse := TRUE;
        END
    ELSE {mouse not in any of my box's hit areas at the moment}
        StillMyMouse := FALSE;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;


METHODS OF TInputFrame;


{$S DlgAlloc}
FUNCTION TInputFrame.CREATE(object: TObject; heap: THeap; itsId: S255; itsView: TView;
        promptLocation: LPoint; promptTypeStyle: TTypeStyle;
        inputLocation:  LPoint; inputTypeStyle: TTypeStyle;  maxInputChars: INTEGER;
        itsBorders: Rect; drawInputLRect: BOOLEAN; drawHitLRect: BOOLEAN): TInputFrame;
    VAR textExtent:         LRect;
        myOwnExtentLRect:   LRect;
        prompt:             TLegend;
        textDialogImage:    TTextDialogImage;
{$IFC libraryVersion <= 20}   {* * * P E P S I * * *}
        fInfo:              TFInfo;
{$ELSEC}                      {* *  S P R I N G  * *}
        fInfo:              FontInfo;
{$ENDC}
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    prompt := TLegend.CREATE(NIL, heap, itsID, itsView, promptLocation, promptTypeStyle);

    SetQDTypeStyle(inputTypeStyle);
    GetFontInfo(fInfo);
    WITH fInfo DO
        SetLRect(textExtent, 0, -ascent - leading, maxInputChars * widMax,  descent + leading);

    OffsetLRect(textExtent, inputLocation.h, inputLocation.v);
    textDialogImage := TTextDialogImage.CREATE(NIL, heap, textExtent, 'input', itsView,
        inputTypeStyle, '');

    UnionLRect(prompt.extentLRect, textDialogImage.extentLRect, myOwnExtentLRect);
    LRectAddBorders(myOwnExtentLRect, itsBorders, myOwnExtentLRect);

    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TInputFrame(TImageWithID.CREATE(object, heap, myOwnExtentLRect, itsId, itsView, TRUE));

    SELF.prompt := prompt;
    SELF.AddImage(prompt);

    SELF.textDialogImage := textDialogImage;
    SELF.AddImage(textDialogImage);

    SELF.inputTypeStyle := inputTypeStyle;
    SELF.maxInputChars := maxInputChars;
    SELF.drawHitLRect := drawHitLRect;
    SELF.drawInputLRect := drawInputLRect;
    SELF.borders := itsBorders;

    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TInputFrame.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('textDialogImage: TTextDialogImage');
    Field('prompt: TLegend');
    Field('borders: Rect');
    Field('drawInputLRect: BOOLEAN');
    Field('drawHitLRect: BOOLEAN');
    Field('maxInputChars: INTEGER');
    Field('inputTypeStyle: LONGINT');   {make this right someday}
    Field('');
END;
{$ENDC}


{$S DlgText}
FUNCTION TInputFrame.CursorAt(mouseLPt: LPoint): TCursorNumber;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.Hit(mouseLPt) THEN
            CursorAt := textCursor
        ELSE
            CursorAt := noCursor;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgText}
PROCEDURE TInputFrame.Draw;
        VAR tempLRect:  LRect;
            pat:        pattern;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.prompt <> NIL THEN
            SELF.prompt.Draw;
        SELF.textDialogImage.Draw;    {draw the current input characters lying there...}
        IF SELF.drawInputLRect THEN
            BEGIN
            tempLRect := SELF.textDialogImage.textImage.extentLRect;
            InsetLRect(tempLRect, -6, -4);
            PenNormal;
            thePad.LPatToPat(lPatGray, pat);
            PenPat(pat);
            PenSize(1,1);
            FrameLRect(tempLRect);  {mostly for debugging reassurance...}
            END;
        IF SELF.drawHitLRect THEN
            FrameLRect(SELF.extentLRect);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
FUNCTION  TInputFrame.LaunchLayoutBox(view: TView): TImage;
{In the future, if there were one, we would want to allow resizing of the hit area during
  layout, and would here launch a special type of layout box, TInptFrmLayoutBox, to do layout just right}
    VAR layoutBox:      TLayoutBox;
        layBoxExtent:   LRect;
        s:              TListScanner;
        childLayoutBox: TLayoutBox;
        newBorders:     Rect;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    layoutBox := TLayoutBox(SUPERSELF.LaunchLayoutBox(view));  {i.e., TImageWithID's launch}
    WITH layoutBox.borders DO
        BEGIN
        top := SELF.borders.top;
        right := SELF.borders.right - right;
        bottom := SELF.borders.bottom - bottom;
        left := SELF.borders.left - left;
        END;
    layoutBox.RecalcExtent;
    LaunchLayoutBox := layoutBox;

    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgText}
PROCEDURE TInputFrame.MousePress(mouseLPt: LPoint);
    VAR frameSelection: TFrameSelection;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
     LRectHaveLPt(SELF.textDialogImage.textImage.extentLRect, mouseLPt);
     TDialogView(SELF.view).magnetCursor := textCursor;
     frameSelection := TFrameSelection(SELF.view.panel.selection.FreedAndReplacedBy(
                                        TFrameSelection.CREATE(NIL, SELF.Heap, SELF)));
     SELF.textDialogImage.textImage.MousePress(mouseLPt);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgText}
PROCEDURE TInputFrame.GetContents(VAR theStr: S255);
    VAR paraImage:  TParaImage;
        paragraph:  TParagraph;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    paraImage := TParaImage(SELF.textDialogImage.textImage.imageList.First);
    paragraph := paraImage.paragraph;
    paragraph.ToPStr(@theStr);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgLayout}
PROCEDURE TInputFrame.RecalcExtent;
    VAR newExtent:  LRect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.prompt <> NIL THEN
            UnionLRect(SELF.prompt.extentLRect, SELF.textDialogImage.extentLRect, newExtent)
        ELSE
            newExtent := SELF.textDialogImage.extentLRect;
        LRectAddBorders(newExtent, SELF.borders, newExtent);

        SELF.Resize(newExtent);
        IF SELF.parent <> NIL THEN
            SELF.parent.RecalcExtent;

        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgText}
FUNCTION TInputFrame.StillMyMouse(mouseLPt: LPoint): BOOLEAN;
  {in this implementation, once the insertion point has been dropped, we don't give up
    control even if user now strays outside our hit area}
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
         LRectHaveLPt(SELF.textDialogImage.textImage.extentLRect, mouseLPt);
         SELF.view.panel.selection.coSelection.MouseMove(mouseLPt);  {currently, just pass it on to the
                                                                      text selection}
         StillMyMouse := TRUE;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgText}
PROCEDURE TInputFrame.SupplantContents(newStr: S255);
    VAR paragraph:  TParagraph;
        paraImage:  TParaImage;
        textImage:  TTextImage;
        oldCount:   INTEGER;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        textImage := SELF.textDialogImage.textImage;
        paraImage := TParaImage(textImage.imageList.First);
        paragraph := paraImage.paragraph;
        oldCount := paragraph.size;
        paragraph.ReplPString(0, oldCount, @newStr);

        paraImage.changed := TRUE;
        paraImage.InvalLinesWith(0, MAXINT);

        textImage.RecomputeImages(actionNone, TRUE);
        IF TDialogView(SELF.view).isShowing THEN
            SELF.view.panel.InvalLRect(SELF.textDialogImage.extentLRect);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TLegend;

{$S TK2Start}
FUNCTION  TLegend.CREATE(object: TObject; heap: THeap; itsChars: S255; itsView: TView;
            itsLocation: LPoint; itsTypeStyle: TTypeStyle):  TLegend;
    VAR itsExtent:      LRect;
        height:         INTEGER;
        itsParagraph:   TParagraph;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    itsParagraph := TParagraph.CREATE(NIL, heap, LENGTH(itsChars), itsTypeStyle);
    itsParagraph.InsPStrAt(1, @itsChars);
    SetParaExtent(itsParagraph, itsView, itsLocation, itsExtent);

    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TLegend(TDialogImage.CREATE(object, heap, itsExtent, noID, itsView, FALSE));

    WITH SELF DO
        BEGIN
        location := itsLocation;
        paragraph := itsParagraph;
        wouldBeDraggable := TRUE;
        usesSysFont := (itsTypeStyle.font.fontFamily = famSystem);
        END;

    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgCold}
PROCEDURE TLegend.Free;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    Free(SELF.paragraph);
    SUPERSELF.Free;
    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TLegend.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('location: LPoint');
    Field('paragraph: TParagraph');
    Field('wouldBeDraggable: BOOLEAN');
    Field('usesSysFont: BOOLEAN');
    Field('');
END;
{$ENDC}


{$S DlgHot}
PROCEDURE  TLegend.ChangeToPhrase(newPhrase: INTEGER);
    VAR newString:  S255;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    process.GetAlert(newPhrase, newString);
    SELF.ChangeString(newString);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE  TLegend.ChangeString(newString: S255);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.view.panel.InvalLRect(SELF.extentLRect); {invalidate old string's bounding box}
    SELF.paragraph.DelAll;
    SELF.paragraph.InsPStrAt(1, @newString);
    SELF.GetBoxRight;
    SELF.view.panel.InvalLRect(SELF.extentLRect); {invalidate new string's bounding box}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TLegend.Draw;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    MoveToL(SELF.location.h, SELF.location.v);
    SELF.paragraph.Draw(1, SELF.paragraph.size);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S TK2Start}
PROCEDURE TLegend.GetBoxRight;
    VAR newExtent:      LRect;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SetParaExtent(SELF.paragraph, SELF.view, SELF.location, newExtent);
    SELF.Resize(newExtent);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TLegend.GetString(VAR itsString: S255);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.paragraph.ToPStr(@itsString);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S SgLayout}
FUNCTION  TLegend.LaunchLayoutBox(view: TView): TImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.isEditable THEN
        LaunchLayoutBox := TLegendLayoutBox.CREATE(NIL, SELF.Heap, view, SELF)
    ELSE
        LaunchLayoutBox := SUPERSELF.LaunchLayoutBox(view);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TLegend.OffsetBy(deltaLPt: LPoint);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
{$H-} LPtPlusLPt(SELF.location, deltaLPt, SELF.location); {$H+}
    SUPERSELF.OffsetBy(deltaLPt);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TLegend.RecalcExtent;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.GetBoxRight;
    IF SELF.parent <> NIL THEN
        SELF.parent.RecalcExtent;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;
