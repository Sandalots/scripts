{INCLUDE FILE UOBJECT3 -- COLLECTIONS}
{Copyright 1983, 1984, Apple Computer, Inc.}

{Segments: SgCLAini(tialize and Terminate), SgCLAres(ident), SgCLAc(o)ld, SgCLAdbg}

{$S sResDat}
PROCEDURE XferContiguous(whichWay: xReadWrite; collection: TCollection; alsoSkip: INTEGER; s: TStringScanner);
        {Transfer the size (as an INTEGER), class-specific fields (after alsoSkip bytes), and all members.
         Do not recur on the members.
         Do not transfer the class, the dynStart (=SizeOfClass), or the hole info (=zero).
         When reading, append the elements that are read.
         This only works for contiguous objects up to 32K members in size.}
    VAR size:       INTEGER;
        numToXfer:  INTEGER;
BEGIN
    {$IFC fTrace}BP(3);{$ENDC}
    size := collection.size;
    collection.StopEdit;
    CASE whichWay OF
        xRead:
            BEGIN
            numToXfer := s.ReadNumber(2);
            collection.EditAt(size + 1, numToXfer);
            size := collection.size;
            END;
        xWrite:
            BEGIN
            numToXfer := size;
            s.WriteNumber(numToXfer, 2);
            END;
        END;
    s.XferSequential(whichWay,
                     Ptr(ORD(Handle(collection)^) + SIZEOF(TCollection) + alsoSkip),
                     size * collection.MemberBytes);
    {$IFC fTrace}EP;{$ENDC}
END;


{INVARIANT ON TCollections:
    given a collection c,
 the elements of the collection are stored at physical indices:
        [1..c.holeStart] and [c.holeStart+c.holeSize+1..c.Size+c.holeSize]
 the hole occupies physical indices:
        [c.holeStart+1..c.holeStart+c.holeSize]
}

METHODS OF TCollection;


{$S sResDat}
    FUNCTION  TCollection.CREATE(object: TObject; heap: THeap; initialSlack: INTEGER): TCollection;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF object = NIL THEN
            ABCBreak('TCollection.CREATE must be passed an already-allocated object by a subclass CREATE', 0);
        SELF := TCollection(object);
        WITH SELF DO
            BEGIN
            size := 0;
      {$H-} dynStart := SizeOfClass(SELF.Class); {$H+}
            holeStart := 0;
            holeSize := initialSlack;
            holeStd := 0;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TCollection.Clone(heap: THeap): TObject;
        VAR numMembers: INTEGER;
            collection: TCollection;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        numMembers := SELF.size;
        collection := TCollection(NewDynObject(heap, SELF.Class, numMembers * SELF.MemberBytes));
        XferLeft(Ptr(Handle(SELF)^), Ptr(Handle(collection)^), SELF.dynStart);
        collection := TCollection.CREATE(collection, heap, numMembers);
        collection.InsManyAt(1, SELF, 1, numMembers);
        Clone := collection;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TCollection.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('size: LONGINT');
        Field('dynStart: INTEGER');
        Field('holeStart: INTEGER');
        Field('holeSize: INTEGER');
        Field('holeStd: INTEGER');
    END;
    {$S SgCLAres}
    {$ENDC}


    {$IFC fCheckIndices}
    {$S SgCLAdbg}
    PROCEDURE TCollection.CheckIndex(index: LONGINT);
    BEGIN
        {$IFC fMaxTrace}BP(1);{$ENDC}
        {$IFC fMaxTrace}EP;{$ENDC}
        IF (index < 1) OR (index > SELF.size) THEN
            ABCBreak('CheckIndex', index);
    END;
    {$S SgCLAres}
    {$ENDC}


{$S sResDat}
    FUNCTION  TCollection.AddrMember(i: LONGINT): LONGINT;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        {$IFC fDbgObject}
        IF SELF.dynStart = MAXINT THEN
            ABCBreak('No dynamic part', i);
        {$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            IF (i < 1) OR (i > SELF.size+1) THEN
                ABCBreak('CheckIndex', i);
        {$ENDC}

        IF i > SELF.holeStart THEN
            i := i + SELF.holeSize;
        {i is now a physical index}

        AddrMember := TpLONGINT(SELF)^ + SELF.dynStart + (SELF.MemberBytes * (i - 1));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TCollection.CopyMembers(dstAddr, startIndex, howMany: LONGINT);
        VAR memberBytes:    INTEGER;
            beforeHole:     INTEGER;
            srcAddr:        LONGINT;
            j:              INTEGER;
            offset:         INTEGER;
            numBytes:       INTEGER;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        IF startIndex < 1 THEN
            startIndex := 1;
        howMany := Min(howMany, SELF.size + 1 - startIndex);

        IF (howMany > 0) AND (startIndex <= SELF.size) THEN
            BEGIN
            memberBytes := SELF.MemberBytes;

            beforeHole := Min(howMany, SELF.holeStart + 1 - startIndex);
            srcAddr := SELF.AddrMember(startIndex);

            IF beforeHole > 0 THEN
                BEGIN
                numBytes := beforeHole * memberBytes;

                XferLeft(Ptr(srcAddr), Ptr(dstAddr), numBytes);
                dstAddr := dstAddr + numBytes;
                END
            ELSE
                beforeHole := 0;

            IF beforeHole < howMany THEN
                BEGIN
                srcAddr := SELF.AddrMember(startIndex + beforeHole);
                XferLeft(Ptr(srcAddr), Ptr(dstAddr), (howMany - beforeHole) * memberBytes);
                END;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
{AFTER EXECUTING THIS METHOD:
    IF deltaMembers >= 0,
        physical positions [atIndex..atIndex+deltaMembers-1] are available for adding new members.

    IF deltaMembers < 0,
        actual members [atIndex..atIndex-deltaMembers+1] have been removed.

NOTE: This routine does not preserve the TCollection invariant.
}
    PROCEDURE TCollection.EditAt(atIndex: LONGINT; deltaMembers: INTEGER);
        VAR oldHoSize:      INTEGER;
            newHoSize:      INTEGER;
            oldHoStart:     INTEGER;
            newHoStart:     INTEGER;
            maxHoStart:     INTEGER;
            minHoStart:     INTEGER;
            size:           INTEGER;
            b:              0..1;
    BEGIN                                               {Removes any hole it creates unless holdStd <> 0}
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fDbgObject}
        IF SELF.dynStart = MAXINT THEN
            ABCBreak('No dynamic part', atIndex);
        {$ENDC}

        {Force atIndex and deltaMembers into the valid range}
        atIndex := Max(1, Min(atIndex, SELF.size + 1));

        IF deltaMembers < 0 THEN
            deltaMembers := Min(0, Max(deltaMembers, atIndex - SELF.size - 1));

(***** Range checks not necessary with the above code
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            BEGIN
            IF atIndex <> (SELF.size + 1) THEN
                SELF.CheckIndex(atIndex);
            IF deltaMembers < 0 THEN
                SELF.CheckIndex(atIndex - 1 - deltaMembers);
            END;
        {$ENDC}
*****)

        oldHoSize := SELF.holeSize;
        oldHoStart := SELF.holeStart;

        IF (deltaMembers < 0) AND ((oldHoStart + 1) = atIndex) THEN {the hole is right before the deletion}
            SELF.holeStart := oldHoStart - deltaMembers {deltaMembers is going to be added in again later}
        ELSE
            BEGIN
            newHoStart := atIndex - 1 - Min(deltaMembers, 0);
            IF (deltaMembers > oldHoSize) OR (newHoStart <> oldHoStart) THEN
                BEGIN
                maxHoStart := Max(oldHoStart, newHoStart);
                newHoSize := Max(oldHoSize, deltaMembers);

                IF newHoSize > oldHoSize THEN
                    BEGIN
                    {increase the space allocated to the collection, and shift the collection so that the
                     the last real element is at the end of the space allocated to the collection;
                     but only move REAL elements that will end up after the hole}

                    size := SELF.size;
                    newHoSize := Max(newHoSize, SELF.holeStd);
                    SELF.ResizeColl(size + newHoSize);
                    SELF.ShiftColl(maxHoStart + oldHoSize, maxHoStart + newHoSize, size - maxHoStart);

                    {Explanation of the above line:
                        maxHoStart = max # real elements before the hole (in initial and final collections)
                        size = # real elements in the initial collection
                        therefore, size - maxHoStart is min # real elements after the hole, which
                            is the right number of elements to move

                        the allocated size of the collection is size + newHoSize (from SELF.ResizeColl)
                        to get the last real element we are moving to be at the end of the allocated space,
                            we need to move the first element to
                            allocated size of collection - # elements moving
                        =   size + newHoSize - (size - maxHoStart)
                        =   maxHoStart + newHoSize

                        we increased the size of the collection by newHoSize - oldHoSize
                        therefore the first source element must be
                            first destination element - (newHoSize - oldHoSize)
                        =   maxHoStart + newHoSize - (newHoSize - oldHoSize)
                        =   maxHoStart + oldHoSize
                    }
                    END;

                IF newHoStart <> oldHoStart THEN
                    BEGIN
                    b := ORD(newHoStart > oldHoStart);    {1 if hole is moving right and data is moving left,
                                                           0 otherwise}
                    minHoStart := Min(oldHoStart, newHoStart);
                    SELF.ShiftColl(minHoStart + oldHoSize*b, minHoStart + newHoSize*(1-b),
                                    maxHoStart - minHoStart);
                    END;

                SELF.holeStart := newHoStart;
                SELF.holeSize := newHoSize;
                END;
            END;

        WITH SELF DO
            BEGIN
            size := size + deltaMembers;
            holeSize := holeSize - deltaMembers;
            holeStart := holeStart + deltaMembers;
            IF oldHoSize = 0 THEN
                IF holeStd = 0 THEN
                    IF holeSize > 0 THEN
                {$H-}   SELF.StopEdit;  {$H+}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TCollection.Equals(otherCollection: TCollection): BOOLEAN;
        LABEL 1;
        VAR memberBytes: INTEGER;
            size:        INTEGER;
            i:           INTEGER;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        Equals := FALSE;
        memberBytes := SELF.MemberBytes;
        size := SELF.size;
        IF SELF = otherCollection THEN
            Equals := TRUE
        ELSE
        IF size = otherCollection.size THEN
            IF memberBytes = otherCollection.MemberBytes THEN
                BEGIN
                FOR i := 1 TO size DO
                    IF NOT EqualBytes(Ptr(SELF.AddrMember(i)), Ptr(otherCollection.AddrMember(i)), memberBytes) THEN
                        GOTO 1;
                Equals := TRUE;
                END;
        1:
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TCollection.InsManyAt(i: LONGINT; otherCollection: TCollection; index, howMany: LONGINT);
    BEGIN                                                   {Stops edit if it wasn't explicitly started}
        {$IFC fTrace}BP(3);{$ENDC}
        {$IFC fDbgObject}
        IF SELF.dynStart = MAXINT THEN
            ABCBreak('No dynamic part', i);
        {$ENDC}

        {$IFC fCheckIndices}
        IF fCheckIndices AND (howMany > 0) THEN
            BEGIN {i is checked by EditAt}
            IF SELF.memberBytes <> otherCollection.MemberBytes THEN
                BEGIN
                WriteLn;
                WriteLn('*** ERROR: Tried to insert ', otherCollection.MemberBytes:1,
                        '-byte Members into a TCollection with ', SELF.memberBytes, '-byte Members');
                ABCbreak('InsManyAt', howMany);
                END;
(***** Dont need range checks anymore
            otherCollection.CheckIndex(index);
            otherCollection.CheckIndex(index + howMany - 1);
*****)
            END;
        {$ENDC}

        IF howMany > 0 THEN
            BEGIN
            SELF.EditAt(i, howMany);

            otherCollection.CopyMembers(SELF.AddrMember(i), index, howMany);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TCollection.InsNullsAt(i, howMany: LONGINT);
        VAR dstAddr:        LONGINT;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fDbgObject}
        IF SELF.dynStart = MAXINT THEN
            ABCBreak('No dynamic part', i);
        {$ENDC}

        SELF.EditAt(i, howMany);
        IF howMany > 0 THEN
            BEGIN
            dstAddr := SELF.AddrMember(i);
            TPByte(dstAddr)^ := 0;
            XferLeft(Ptr(dstAddr), Ptr(dstAddr + 1), howMany * SELF.MemberBytes-1);
                {WARNING: The success of the preceding line depends on the fact the XferLeft
                        copies data 1 byte at a time; use of a routine that tries to optimize the
                        transfer will negatively impact the correctness of this method.}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
{NOTE: This routine does not preserve the TCollection invariant.}

    PROCEDURE TCollection.ResizeColl(membersPlusHole: INTEGER);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fDbgObject}
        IF SELF.dynStart = MAXINT THEN
            ABCBreak('No dynamic part', membersPlusHole);
        {$ENDC}

        IF membersPlusHole <> (SELF.size + SELF.holeSize) THEN
            ResizeDynObject(SELF, SELF.dynStart + (membersPlusHole * SELF.MemberBytes));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
{NOTE: This routine does not preserve the TCollection invariant.}

    PROCEDURE TCollection.ShiftColl(afterSrcIndex, afterDstIndex, howMany: INTEGER);
        VAR memberBytes:    INTEGER;
            numBytes:       INTEGER;
            startAddr:      LONGINT;
            srcAddr:        LONGINT;
            dstAddr:        LONGINT;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fDbgObject}
        IF SELF.dynStart = MAXINT THEN
            ABCBreak('No dynamic part', howMany);
        {$ENDC}

        IF (howMany > 0) AND (afterSrcIndex <> afterDstIndex) THEN
            BEGIN
            memberBytes := SELF.MemberBytes;
            numBytes := howMany * memberBytes;

            startAddr := TpLONGINT(SELF)^ + SELF.dynStart;
            srcAddr := startAddr + afterSrcIndex * memberBytes;
            dstAddr := startAddr + afterDstIndex * memberBytes;

            IF afterSrcIndex < afterDstIndex THEN
                XferRight(Ptr(srcAddr), Ptr(dstAddr), numBytes)
            ELSE
                XferLeft(Ptr(srcAddr), Ptr(dstAddr), numBytes);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TCollection.StartEdit(withSlack: INTEGER);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fDbgObject}
        IF SELF.dynStart = MAXINT THEN
            ABCBreak('No dynamic part', withSlack);
        {$ENDC}

        SELF.holeStd := withSlack;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TCollection.StopEdit;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fDbgObject}
        IF SELF.dynStart = MAXINT THEN
            ABCBreak('No dynamic part', 0);
        {$ENDC}

        IF SELF.holeStart < SELF.size THEN
            SELF.EditAt(SELF.size + 1, 0);
        SELF.ResizeColl(SELF.size);
        SELF.holeStd := 0;
        SELF.holeSize := 0;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
BEGIN

    {$IFC fCheckIndices}
    fCheckIndices := FALSE;
    {$ENDC}

END;
{$S SgCLAres}


METHODS OF TList;


{$S sResDat}
    FUNCTION  TList.CREATE(object: TObject; heap: THeap; initialSlack: INTEGER): TList;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF object = NIL THEN
            object := NewDynObject(heap, THISCLASS, initialSlack * SIZEOF(Handle));
        SELF := TList(TCollection.CREATE(object, heap, initialSlack));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TList.Free;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        SELF.Each(Free);
        SUPERSELF.Free;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TList.Clone(heap: THeap): TObject;
        VAR l:  TList;
            j:  INTEGER;
            x:  TObject;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        l := TList(SUPERSELF.Clone(heap));
        FOR j := 1 TO l.size DO
            BEGIN
            x := SELF.At(j);
            IF x <> NIL THEN
                l.PutAt(j, x.Clone(heap), FALSE);
            END;
        Clone := l;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TList.Debug(numLevels: INTEGER; memberTypeStr: S255);
    VAR s:          TListScanner;
        obj:        TObject;
        str:        S8;
        first:      BOOLEAN;
        {$IFC fTrace}
        oldFlag:    BOOLEAN;
        {$ENDC}
    BEGIN
        {$IFC fTrace}
        oldFlag := fDebugRecursion;
        fDebugRecursion := TRUE;
        {$ENDC}

        SUPERSELF.Debug(numLevels, '');         { this prints other fields of the list }
        IF numLevels > 0 THEN
            BEGIN
            WrStr('(');
            IF numLevels = 1 THEN           { compressed list of classes }
                SELF.DebugMembers
            ELSE                            { list of classes and their handles }
                BEGIN
                s := SELF.Scanner;
                IF s.position = SELF.holeStart THEN
                    Write('<=HOLE=>');
                first := TRUE;
                WHILE s.Scan(obj) DO
                    BEGIN
                    IF NOT first THEN
                        WrStr(', ');
                    first := FALSE;
                    IF obj = NIL THEN
                        WrStr('NIL')
                    ELSE IF ValidObject(Handle(obj)) THEN
                        obj.Debug(numLevels-2, '')
                    ELSE
                        WrStr('<Invalid Object>');
                    IF numLevels = 2 THEN
                        BEGIN
                        LIntToHex(ORD4(obj), @str);
                        WrStr(CONCAT(': $', str));
                        END;
                    IF s.position = SELF.holeStart THEN
                        Write('<=HOLE=>');
                    END;
                END;
            WrStr(')');
            END;

        {$IFC fTrace}
        fDebugRecursion := oldFlag;
        {$ENDC}
    END;
    {$S SgCLAres}


    {$S SgCLAdbg}
    PROCEDURE TList.DebugMembers;
        VAR y:              TObject;
            s:              TListScanner;
            str:            S8;
            initial:        BOOLEAN;
            class:          TClass;
            thisClass:      TClassName;
            prevClass:      TClassName;
            sameClass:      INTEGER;
            charCount:      INTEGER;

        PROCEDURE WriteMembers;
            VAR charsNeeded:    INTEGER;
        BEGIN
            IF sameClass = 0 THEN EXIT(WriteMembers);
            IF sameClass = 1 THEN
                charsNeeded := 10
            ELSE
                charsNeeded := 13;
            IF initial THEN
                initial := FALSE
            ELSE IF (charCount + charsNeeded) > 70 THEN
                BEGIN
                WrStr(',');
                WrLn;
                WrStr('          ');
                charCount := 10;
                END
            ELSE
                WrStr(', ');

            str := prevClass;
            WrStr(str);

            IF sameClass > 1 THEN
                BEGIN
                IntToStr(sameClass, @str);
                WrStr(CONCAT('*', str));
                END;

            charCount := charCount + charsNeeded;
        END;

    BEGIN
        IF SELF.size > 0 THEN {prevent initialization anomaly in BP(i)/EP}
            BEGIN
            charCount := cMin(indentTrace, 20) + 30;
            initial := TRUE;
            sameClass := 0;
            prevClass := '';
            s := SELF.Scanner;
            WHILE s.Scan(y) DO
                BEGIN
                IF y = NIL THEN
                    thisClass := 'NIL'
                ELSE IF ValidObject(Handle(y)) THEN
                    BEGIN
                    class := y.Class;
                    CpToCn(TPSliceTable(class), TS8(thisClass));
                    END
                ELSE
                    thisClass := '????????';

                IF thisClass <> prevClass THEN
                    BEGIN
                    WriteMembers;
                    sameClass := 1;
                    END
                ELSE
                    sameClass := sameClass + 1;

                prevClass := thisClass;
                END;
            WriteMembers;
            END;
    END;
    {$S SgCLAres}
    {$ENDC}


{$S sResDat}
    FUNCTION  TList.At(i: LONGINT): TObject;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            SELF.CheckIndex(i);
        {$ENDC}

       {At := TPObject(SELF.AddrMember(i))^;  but for speed...}

        IF i > SELF.holeStart THEN
            i := i + SELF.holeSize;
        At := TPObject(TpLONGINT(SELF)^ + SELF.dynStart + (4 * (i - 1)))^;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TList.DelAll(freeOld: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        IF freeOld THEN
            SELF.Each(Free);
        SELF.EditAt(1, -SELF.size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TList.DelAt(i: LONGINT; freeOld: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            SELF.CheckIndex(i);
        {$ENDC}

        IF freeOld THEN
            Free(SELF.At(i));
        SELF.EditAt(i, -1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TList.DelFirst(freeOld: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.DelAt(1, freeOld);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TList.DelLast(freeOld: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.DelAt(SELF.size, freeOld);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TList.DelManyAt(i, howMany: LONGINT; freeOld: BOOLEAN);
        VAR j: INTEGER;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        IF howMany > 0 THEN
            BEGIN
            {$IFC fCheckIndices}
            IF fCheckIndices THEN
                BEGIN
                SELF.CheckIndex(i);
                SELF.CheckIndex(i+howMany-1);
                END;
            {$ENDC}
            IF freeOld THEN
                FOR j := 0 TO howMany - 1 DO
                    Free(SELF.At(i + j));
            SELF.EditAt(i, -howMany);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TList.DelObject(object: TObject; freeOld: BOOLEAN);
        VAR y:  TObject;
            s:  TListScanner;
    BEGIN   {If there is more than one occurrence, and editing is off, this calls StopEdit more than once}
        {$IFC fTrace}BP(4);{$ENDC}
        s := SELF.Scanner;
        WHILE s.Scan(y) DO
            IF y = object THEN
                s.Delete(FALSE);
        IF freeOld THEN
            Free(object);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TList.Each(PROCEDURE DoToObject(object: TObject));
        VAR holeStart:  INTEGER;
            offset:     INTEGER;
            j:          INTEGER;
            pObject:    TPObject;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        holeStart := SELF.holeStart;
        offset := SELF.dynStart;
        FOR j := 0 TO SELF.size - 1 DO
            BEGIN
            IF j = holeStart THEN
                offset := offset + 4 * SELF.holeSize;
            pObject := TPObject(TpLONGINT(SELF)^ + offset);
            DoToObject(pObject^);
            offset := offset + 4;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TList.First: TObject;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        First := SELF.At(1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TList.InsAt(i: LONGINT; object: TObject);
        VAR pObject:    TPObject;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        SELF.EditAt(i, 1);
        pObject := TPObject(SELF.AddrMember(i));
        pObject^ := object;

        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TList.InsFirst(object: TObject);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.InsAt(1, object);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TList.InsLast(object: TObject);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.InsAt(SELF.size + 1, object);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TList.Last: TObject;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        Last := SELF.At(SELF.size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TList.ManyAt(i, howMany: LONGINT): TList;
        VAR list: TList;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        list := TList.CREATE(NIL, SELF.Heap, howMany);
        list.InsManyAt(1, SELF, i, howMany);
        ManyAt := list;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TList.MemberBytes: INTEGER;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        MemberBytes := 4;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TList.PopLast: TObject;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        PopLast := SELF.Last;
        SELF.DelLast(FALSE);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TList.Pos(after: LONGINT; object: TObject): LONGINT;
        VAR y:  TObject;
            s:  TListScanner;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        Pos := after;
        s := SELF.ScannerFrom(after, scanForward);
        WHILE s.Scan(y) DO
            IF object = y THEN
                BEGIN
                Pos := s.position;
                s.Done;
                END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TList.PutAt(i: LONGINT; object: TObject; freeOld: BOOLEAN);
        VAR pObject:    TPObject;
            oldObject:  TObject;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            SELF.CheckIndex(i);
        {$ENDC}

       {pObject := TPObject(SELF.AddrMember(i));   but for speed...}

        IF i > SELF.holeStart THEN
            i := i + SELF.holeSize;
        pObject := TPObject(TpLONGINT(SELF)^ + SELF.dynStart + (4 * (i - 1)));

        oldObject := pObject^;
        pObject^ := object;

        IF freeOld THEN
            IF object <> oldObject THEN
                Free(oldObject);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TList.Scanner: TListScanner;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        Scanner := TListScanner.CREATE(NIL, SELF, 0, scanForward);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TList.ScannerFrom(firstToScan: LONGINT; scanDirection: TScanDirection): TListScanner;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        ScannerFrom := TListScanner.CREATE(NIL, SELF, firstToScan, scanDirection);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
{$IFC compatibleLists} {For TIndexList.Class}
BEGIN
    cList := THISCLASS;
{$ENDC}
END;
{$S SgCLAres}


METHODS OF TArray;


{$S sResDat}
    FUNCTION  TArray.CREATE(object: TObject; heap: THeap; initialSlack, bytesPerRecord: INTEGER): TArray;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF ODD(bytesPerRecord) THEN
            bytesPerRecord := bytesPerRecord + 1;
        IF object = NIL THEN
            object := NewDynObject(heap, THISCLASS, initialSlack * bytesPerRecord);
        SELF := TArray(TCollection.CREATE(object, heap, initialSlack));
        SELF.recordBytes := bytesPerRecord;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TArray.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('recordBytes: INTEGER');
    END;
    {$S SgCLAres}
    {$ENDC}


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TArray.Debug(numLevels: INTEGER; memberTypeStr: S255);
        VAR s:          TArrayScanner;
            pRecord:    Ptr;
            i:          INTEGER;
            j:          INTEGER;
            str:        S255;
            hexOrd:     S8;

        PROCEDURE SupplyMember(PROCEDURE Field(nameAndType: S255));
        BEGIN
            Field(Concat(str, ': ', memberTypeStr));
        END;

    BEGIN
        SUPERSELF.Debug(numLevels, '');         { this prints other fields of the array }
        IF (numLevels > 1) OR ((numLevels = 1) AND (memberTypeStr <> '')) THEN
            BEGIN
            WrStr('{ ');
            i := 0;
            s := SELF.Scanner;
            IF s.position = SELF.holeStart THEN
                WrStr(' <=HOLE=> ');
            WHILE s.Scan(pRecord) DO
                BEGIN
                IF i > 0 THEN
                    WrStr(', ');
                i := i + 1;
                IntToStr(i, @str);
                IF memberTypeStr = '' THEN
                    BEGIN
                    str := CONCAT(str, ': ');
                    FOR j := 0 TO SELF.recordBytes-1 DO
                        BEGIN
                        LIntToHex(TPByte(ORD(pRecord)+j)^, @hexOrd);
                        str := CONCAT(str, Copy(hexOrd, 7, 2));
                        END;
                    WrStr(str);
                    END
                ELSE
                    WriteDRecord(numLevels - 1, @pRecord, 0, SupplyMember);
                IF s.position = SELF.holeStart THEN
                    WrStr(', <=HOLE=> ');
                END;
            WrStr(' }');
            END;
    END;
    {$S SgCLAres}
    {$ENDC}


{$S sResDat}
    FUNCTION  TArray.At(i: LONGINT): Ptr;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            SELF.CheckIndex(i);
        {$ENDC}

       { At := Ptr(SELF.AddrMember(i));   but for speed...}

        IF i > SELF.holeStart THEN
            i := i + SELF.holeSize;

        At := Ptr(TpLONGINT(SELF)^ + SELF.dynStart + (SELF.recordBytes * (i - 1)));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArray.DelAll;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        SELF.EditAt(1, -SELF.size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArray.DelAt(i: LONGINT);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        SELF.EditAt(i, -1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArray.DelFirst;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.DelAt(1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArray.DelLast;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.DelAt(SELF.size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArray.DelManyAt(i, howMany: LONGINT);
        VAR j: INTEGER;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        IF howMany > 0 THEN
            SELF.EditAt(i, -howMany);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArray.Each(PROCEDURE DoToRecord(pRecord: Ptr));
        VAR holeStart:      INTEGER;
            offset:         INTEGER;
            recordBytes:    INTEGER;
            j:              INTEGER;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        holeStart := SELF.holeStart;
        offset := SELF.dynStart;
        recordBytes := SELF.recordBytes;
        FOR j := 0 TO SELF.size - 1 DO
            BEGIN
            IF j = holeStart THEN
                offset := offset + recordBytes * SELF.holeSize;
            DoToRecord(Ptr(TpLONGINT(SELF)^ + offset));
            offset := offset + recordBytes;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TArray.First: Ptr;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        First := SELF.At(1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TArray.GetAt(i: LONGINT; pRecord: Ptr);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            SELF.CheckIndex(i);
        {$ENDC}

        XferLeft(Ptr(SELF.AddrMember(i)), pRecord, SELF.recordBytes);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TArray.InsAt(i: LONGINT; pRecord: Ptr);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        SELF.EditAt(i, 1);
        SELF.PutAt(i, pRecord);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TArray.InsFirst(pRecord: Ptr);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.InsAt(1, pRecord);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TArray.InsLast(pRecord: Ptr);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.InsAt(SELF.size + 1, pRecord);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TArray.Last: Ptr;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        Last := SELF.At(SELF.size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TArray.ManyAt(i, howMany: LONGINT): TArray;
        VAR arr: TArray;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        arr := TArray.CREATE(NIL, SELF.Heap, howMany, SELF.recordBytes);
        arr.InsManyAt(1, SELF, i, howMany);
        ManyAt := arr;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TArray.MemberBytes: INTEGER;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        MemberBytes := SELF.recordBytes;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TArray.Pos(after: LONGINT; pRecord: Ptr): LONGINT;
        VAR y:  Ptr;
            s:  TArrayScanner;

        FUNCTION EqualRecords(p, q: Ptr; n: INTEGER): BOOLEAN; {n is even}
            VAR i:  INTEGER;
        BEGIN
            EqualRecords := FALSE;
            i := 0;
            WHILE i < n DO
                BEGIN
                IF TpINTEGER(ORD(p) + i)^ <> TpINTEGER(ORD(q) + i)^ THEN
                    EXIT(EqualRecords);
                i := i + 2;
                END;
            EqualRecords := TRUE;
        END;

    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        Pos := after;
        s := SELF.ScannerFrom(after, scanForward);
        WHILE s.Scan(y) DO
            IF EqualRecords(pRecord, y, SELF.recordBytes) THEN
                BEGIN
                Pos := s.position;
                s.Done;
                END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TArray.PutAt(i: LONGINT; pRecord: Ptr);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            SELF.CheckIndex(i);
        {$ENDC}

        XferLeft(pRecord, Ptr(SELF.AddrMember(i)), SELF.recordBytes);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TArray.Scanner: TArrayScanner;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        Scanner := TArrayScanner.CREATE(NIL, SELF, 0, scanForward);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TArray.ScannerFrom(firstToScan: LONGINT; scanDirection: TScanDirection): TArrayScanner;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        ScannerFrom := TArrayScanner.CREATE(NIL, SELF, firstToScan, scanDirection);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
{$IFC compatibleLists} {For TDynamicArray.Class}
BEGIN
    cArray := THISCLASS;
{$ENDC}
END;


METHODS OF TString;


{$S sResDat}
    FUNCTION  TString.CREATE(object: TObject; heap: THeap; initialSlack: INTEGER): TString;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF ODD(initialSlack) THEN
            initialSlack := initialSlack + 1;
        IF object = NIL THEN
            object := NewDynObject(heap, THISCLASS, initialSlack);
        SELF := TString(TCollection.CREATE(object, heap, initialSlack));
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TString.Debug(numLevels: INTEGER; memberTypeStr: S255);
    VAR s:          TStringScanner;
        ch:         CHAR;
        str:        S8;
    BEGIN
        SUPERSELF.Debug(numLevels, '');         { this prints other fields of the list }
        IF numLevels > 0 THEN
            BEGIN
            WrStr('''');
            s := SELF.Scanner;
            IF s.position = SELF.holeStart THEN
                WrStr('<=HOLE=>');
            str := 'x';
            WHILE s.Scan(ch) DO
                BEGIN
                str[1] := ch;
                WrStr(str);
                IF s.position = SELF.holeStart THEN
                    WrStr('<=HOLE=>');
                END;
            WrStr('''');
            END;
    END;
    {$S SgCLAres}
    {$ENDC}


{$S SgCLAres}
    FUNCTION  TString.At(i: LONGINT): CHAR;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            SELF.CheckIndex(i);
        {$ENDC}

        IF i > SELF.holeStart THEN
            i := i + SELF.holeSize;
        At := TpPAOC(TpLONGINT(SELF)^ + SELF.dynStart)^[i];
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.DelAll;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        SELF.EditAt(1, -SELF.size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.DelAt(i: LONGINT);
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        SELF.EditAt(i, -1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.DelFirst;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.DelAt(1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.DelLast;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.DelAt(SELF.size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.DelManyAt(i, howMany: LONGINT);
        VAR j: INTEGER;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        IF howMany > 0 THEN
            SELF.EditAt(i, -howMany);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.Draw(i: LONGINT; howMany: INTEGER);
        VAR beforeHole: INTEGER;
            pWord1:     TpINTEGER;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        beforeHole := Min(SELF.holeStart - (i - 1), howMany);
        pWord1 := TpINTEGER(TpLONGINT(SELF)^ + SELF.dynStart);
        IF beforeHole > 0 THEN
            DrawLText(pWord1, i - 1, beforeHole);
        IF beforeHole < howMany THEN
            DrawLText(pWord1, SELF.holeStart + SELF.holeSize - Min(beforeHole, 0),
                              howMany - Max(beforeHole, 0));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TString.Width(i: LONGINT; howMany: INTEGER): INTEGER;
        VAR beforeHole: INTEGER;
            pWord1:     TpINTEGER;
            totalWidth: INTEGER;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        beforeHole := Min(SELF.holeStart - (i - 1), howMany);
        pWord1 := TpINTEGER(TpLONGINT(SELF)^ + SELF.dynStart);
        totalWidth := 0;
        IF beforeHole > 0 THEN
            totalWidth := TextWidth(pWord1, i - 1, beforeHole);
        IF beforeHole < howMany THEN
            totalWidth := totalWidth + TextWidth(pWord1, SELF.holeStart + SELF.holeSize - Min(beforeHole, 0),
                                                  howMany - Max(beforeHole, 0));
        Width := totalWidth;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.Each(PROCEDURE DoToCharacter(character: CHAR));
        VAR holeStart:      INTEGER;
            offset:         INTEGER;
            j:              INTEGER;
            pChars:         TpPAOC;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        holeStart := SELF.holeStart;
        pChars := TpPAOC(TpLONGINT(SELF)^ + SELF.dynStart);
        offset := 1;
        FOR j := 0 TO SELF.size - 1 DO
            BEGIN
            IF j = holeStart THEN
                offset := offset + SELF.holeSize;
            DoToCharacter(pChars^[offset]);
            offset := offset + 1;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    FUNCTION  TString.First: CHAR;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        First := SELF.At(1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.InsAt(i: LONGINT; character: CHAR);
        VAR pPAOC:      TpPAOC;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        SELF.EditAt(i, 1);

        pPAOC := TpPAOC(TpLONGINT(SELF)^ + SELF.dynStart);
        pPAOC^[i] := character;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.InsFirst(character: CHAR);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.InsAt(1, character);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.InsLast(character: CHAR);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.InsAt(SELF.size + 1, character);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TString.InsPStrAt(i: LONGINT; pStr: TPString);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.EditAt(i, Length(pStr^));
        XferLeft(Ptr(ORD(pStr)+1), Ptr(SELF.AddrMember(i)), Length(pStr^));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    FUNCTION  TString.Last: CHAR;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        Last := SELF.At(SELF.size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    FUNCTION  TString.ManyAt(i, howMany: LONGINT): TString;
        VAR str: TString;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        str := TString.CREATE(NIL, SELF.Heap, howMany);
        str.InsManyAt(1, SELF, i, howMany);
        ManyAt := str;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TString.MemberBytes: INTEGER;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        MemberBytes := 1;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    FUNCTION  TString.Pos(after: LONGINT; character: CHAR): LONGINT;
        VAR y:  CHAR;
            s:  TStringScanner;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        Pos := after;
        s := SELF.ScannerFrom(after, scanForward);
        WHILE s.Scan(y) DO
            IF y = character THEN
                BEGIN
                Pos := s.position;
                s.Done;
                END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.PutAt(i: LONGINT; character: CHAR);
        VAR pPAOC:  TpPAOC;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        {$IFC fCheckIndices}
        IF fCheckIndices THEN
            SELF.CheckIndex(i);
        {$ENDC}

        IF i > SELF.holeStart THEN
            i := i + SELF.holeSize;

        pPAOC := TpPAOC(TpLONGINT(SELF)^ + SELF.dynStart);
        pPAOC^[i] := character;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    FUNCTION  TString.Scanner: TStringScanner;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        Scanner := TStringScanner.CREATE(NIL, SELF, 0, scanForward);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    FUNCTION  TString.ScannerFrom(firstToScan: LONGINT; scanDirection: TScanDirection): TStringScanner;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        ScannerFrom := TStringScanner.CREATE(NIL, SELF, firstToScan, scanDirection);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.ToPStr(pStr: TPString);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.ToPStrAt(1, SELF.size, pStr);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgCLAres}
    PROCEDURE TString.ToPStrAt(i, howMany: LONGINT; pStr: TPString);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        {$IFC fCheckIndices}
        IF howMany > 255 THEN
            ABCBreak('ToPStrAt: Too many characters', howMany);
        {$ENDC}
        SELF.EditAt(i + howMany, 0);
        XferLeft(Ptr(SELF.AddrMember(i)), Ptr(ORD(pStr)+1), howMany);
  {$R-} pStr^[0] := CHAR(howMany); {$IFC fRngObject}{$R+}{$ENDC}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
END;
{$S SgCLAres}


METHODS OF TFile;


{$S sResDat}
    FUNCTION  TFile.CREATE(object: TObject; heap: THeap; itsPath: TFilePath;
                            itsPassword: TPassword): TFile;
        VAR pPath:          TPPathname;
            error:          INTEGER;
        {$IFC LibraryVersion <= 20}
            fsInfo:         FS_Info;
        {$ELSEC}
            fsInfo:         Q_Info;
        {$ENDC}
            itsScanners:    TList;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TFile(TCollection.CREATE(object, heap, 0)); {Just to initialize those ignored fields}
        pPath := @itsPath;
      {$IFC LibraryVersion <= 20}
        Lookup(error, pPath^, fsInfo);
      {$ELSEC}
        Quick_Lookup(error, pPath^, fsInfo);
      {$ENDC}

        itsScanners := TList.CREATE(NIL, heap, 0);
        WITH SELF DO
            BEGIN
            dynStart := MAXINT;
            IF error > 0 THEN
                size := 0
            ELSE
                size := fsInfo.size;
            path := itsPath;
            password := itsPassword;
            scanners := itsScanners;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TFile.Free;                               {Free frees the scanners as well}
    BEGIN
        {$IFC fTrace}BP(5);{$ENDC}
        SELF.scanners.Free;
        SUPERSELF.Free;
        {$IFC fTrace}EP;{$ENDC}
    END;
    {$S SgCLAres}


    {$IFC fDbgObject}
    {$S SgCLAdbg}
    FUNCTION  TFile.Clone(heap: THeap): TObject;
    BEGIN
        ABCBreak('A TFile cannot Clone', 0);
    END;
    {$S SgCLAres}
    {$ENDC}


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TFile.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('path: STRING[255]');
        Field('password: STRING[32]');
        Field('scanners: TList');
    END;
    {$S SgCLAres}
    {$ENDC}


    {$S SgCLAcld}
    PROCEDURE TFile.ChangePassword(VAR error: INTEGER; newPassword: TPassword);
        VAR pPath:      TPPathname;
            pPass:      TPEName;
            pNPass:     TPEName;
    BEGIN
        {$IFC fMaxTrace}BP(1);{$ENDC}
        {$IFC fMaxTrace}EP;{$ENDC}
        {$IFC LibraryVersion <= 20}
        error := -1293; {warning: file is not password protected}
        {$ELSEC}
        pPath := @SELF.path;
        pPass := @SELF.password;
        pNPass := @newPassword;
        Change_Password(error, pPath^, pPass^, pNPass^);
        {$ENDC}
        IF error <= 0 THEN
            SELF.password := newPassword;
    END;
    {$S SgCLAres}


    {$S SgCLAcld}
    PROCEDURE TFile.Delete(VAR error: INTEGER);
        VAR pPath:      TPPathname;
            {$IFC LibraryVersion > 20}
            pPass:      TPEName;
            {$ENDC}
    BEGIN
        {$IFC fMaxTrace}BP(1);{$ENDC}
        {$IFC fMaxTrace}EP;{$ENDC}
        pPath := @SELF.path;
        {$IFC LibraryVersion <= 20}
        Kill_Object(error, pPath^);
        {$ELSEC}
        pPass := @SELF.password;
        Kill_Secure(error, pPath^, pPass^);
        {$ENDC}
    END;
    {$S SgCLAres}


    {$S sResDat}
    FUNCTION TFile.Exists(VAR error: INTEGER): BOOLEAN;
      {$IFC LibraryVersion <= 20}
        VAR refInfo:    FS_Info;
      {$ELSEC}
        VAR refInfo:    Q_Info;
      {$ENDC}
            pPath:      TPPathname;
    BEGIN
        {$IFC fMaxTrace}BP(1);{$ENDC}
        {$IFC fMaxTrace}EP;{$ENDC}
        pPath := @SELF.path;
      {$IFC LibraryVersion <= 20}
        Lookup(error, pPath^, refInfo);
      {$ELSEC}
        Quick_Lookup(error, pPath^, refInfo);
      {$ENDC}
        Exists := error <= 0;
    END;
    {$S SgCLAres}


{$S SgABCdat}
    FUNCTION  TFile.MemberBytes: INTEGER;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        MemberBytes := 1;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$S SgCLAcld}
    PROCEDURE TFile.Rename(VAR error: INTEGER; newFileName: TFilePath);
            {the volume of newFileName is ignored}
        VAR pPath:          TPPathname;
            vol:            TFilePath;
            name:           TFilePath;
            pEName:         TPEname;
            {$IFC LibraryVersion > 20}
            pPass:          TPEName;
            {$ENDC}
    BEGIN
        {$IFC fMaxTrace}BP(1);{$ENDC}
        {$IFC fMaxTrace}EP;{$ENDC}
        pPath := @SELF.path;
        SplitFilePath(newFileName, vol, name);
        pEName := @name;
        {$IFC LibraryVersion <= 20}
        Rename_Entry(error, pPath^, pEName^);
        {$ELSEC}
        pPass := @SELF.password;
        Rename_Secure(error, pPath^, pEName^, pPass^);
        {$ENDC}
    END;
    {$S SgCLAres}


    {$S SgCLAcld}
    FUNCTION  TFile.Scanner: TFileScanner;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        Scanner := SELF.ScannerFrom(0, [fRead, fWrite]);
        {$IFC fTrace}EP;{$ENDC}
    END;
    {$S SgCLAres}


{$S sResDat}
    FUNCTION  TFile.ScannerFrom(firstToScan: LONGINT; manip: TAccesses): TFileScanner;
        VAR s: TFileScanner;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        s := TFileScanner.CREATE(NIL, SELF, manip);
        s.Seek(firstToScan);
        ScannerFrom := s;
        {$IFC fTrace}EP;{$ENDC}
    END;
    {$S SgCLAres}


    {$S SgCLAcld}
    FUNCTION  TFile.VerifyPassword(VAR error: INTEGER; password: TPassword): BOOLEAN;
        VAR pPath:  TPPathname;
            pPass:  TPEName;
    BEGIN
        {$IFC fMaxTrace}BP(1);{$ENDC}
        {$IFC fMaxTrace}EP;{$ENDC}
        {$IFC LibraryVersion <= 20}
        error := -1293; {warning file is not password protected}
        VerifyPassword := TRUE;
        {$ELSEC}
        pPath := @SELF.path;
        pPass := @password;
        Verify_Password(error, pPath^, pPass^);
        VerifyPassword := error <= 0;
        {$ENDC}
    END;
    {$S SgCLAres}


    {$S SgCLAcld}
    FUNCTION TFile.WhenModified(VAR error: INTEGER): LONGINT;
      {$IFC LibraryVersion <= 20}
        VAR refInfo:    FS_Info;
      {$ELSEC}
        VAR refInfo:    Q_Info;
      {$ENDC}
            pPath:      TPPathname;
    BEGIN
        {$IFC fMaxTrace}BP(1);{$ENDC}
        {$IFC fMaxTrace}EP;{$ENDC}
        pPath := @SELF.path;
      {$IFC LibraryVersion <= 20}
        Lookup(error, pPath^, refInfo);
      {$ELSEC}
        Quick_Lookup(error, pPath^, refInfo);
      {$ENDC}
        IF error <= 0 THEN
            WhenModified := refInfo.DTM
        ELSE
            WhenModified := -1;
    END;
    {$S SgCLAres}


{$S sInit1}
END;
{$S SgCLAres}


METHODS OF TScanner;


{$S sResDat}
    FUNCTION  TScanner.CREATE(object: TObject; itsCollection: TCollection;
                              itsInitialPosition: LONGINT; scanDirection: TScanDirection): TScanner;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF object = NIL THEN
            ABCBreak('TScanner.CREATE must be passed an already-allocated object by a subclass CREATE', 0);
        SELF := TScanner(object);
        WITH SELF DO
            BEGIN
            collection := itsCollection;
      {$H-} position := Max(0, Min(collection.size+1, itsInitialPosition)); {$H+}
            scanDone := FALSE;

            IF scanDirection = scanForward THEN
                BEGIN
                increment := 1;
                atEnd := position >= collection.size;
                END
            ELSE
                BEGIN
                increment := -1;
                atEnd := position <= 1;
                END;
            END;
        SELF.Seek(itsInitialPosition);
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TScanner.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('collection: TCollection');
        Field('position: LONGINT');
        Field('increment: INTEGER');
        Field('scanDone: BOOLEAN');
        Field('atEnd: BOOLEAN');
    END;
    {$S SgCLAres}
    {$ENDC}


{$S SgABCdat}
    FUNCTION  TScanner.Advance(PROCEDURE DoToCurrent(anotherMember: BOOLEAN)): BOOLEAN;
        VAR moreToScan: BOOLEAN;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        WITH SELF DO
            IF scanDone THEN
                moreToScan := FALSE     {don't reassign nextObject}
            ELSE
                BEGIN
                IF atEnd THEN
                    moreToScan := FALSE
                ELSE
                    BEGIN
                    moreToScan := TRUE;
                    position := position + increment;
                    IF increment > 0 THEN
                        atEnd := position >= collection.size
                    ELSE
                        atEnd := position <= 1;
                    END;

          {$H-} DoToCurrent(moreToScan); {$H+}
                END;

        IF NOT moreToScan THEN
            SELF.Free;

        Advance := moreToScan;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TScanner.Allocate(slack: LONGINT);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.collection.StartEdit(slack);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TScanner.Close;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TScanner.Compact;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.collection.StopEdit;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TScanner.Done;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.scanDone := TRUE;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TScanner.Open;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TScanner.Reverse;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.increment := - SELF.increment;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TScanner.Seek(newPosition: LONGINT);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        WITH SELF DO
            BEGIN
      {$H-} position := Max(0, Min(collection.size+1, newPosition)); {$H+}
            atEnd := ((position >= collection.size) AND (increment > 0)) OR
                     ((position <= 1) AND (increment < 0));
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TScanner.Skip(deltaPos: LONGINT);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.Seek(SELF.position + deltaPos);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
END;
{$S SgCLAres}


METHODS OF TListScanner;


{$S sResDat}
    FUNCTION  TListScanner.CREATE(object: TObject; itsList: TList;
                                  itsInitialPosition: LONGINT; itsScanDirection: TScanDirection): TListScanner;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF object = NIL THEN
            object := NewOrRecycledObject(mainHeap, THISCLASS, availListScanner);
        SELF := TListScanner(TScanner.CREATE(object, itsList, itsInitialPosition, itsScanDirection));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TListScanner.Free;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        RecycleObject(SELF, availListScanner);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TListScanner.Append(object: TObject);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TList(SELF.collection).InsAt(SELF.position + 1, object);
        SELF.position := SELF.position + 1;

        (***** removed the following line: .InsAt should have set the collection size
  {$H-} SELF.collection.size := Max(SELF.collection.size, SELF.position); {$H+}
        *****)
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TListScanner.Delete(freeOld: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TList(SELF.collection).DelAt(SELF.position, freeOld);
        WITH SELF DO
            IF increment > 0 THEN
                position := position - 1;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TListScanner.DeleteRest(freeOld: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        WITH SELF DO
            IF increment > 0 THEN
       {$H-}    TList(collection).DelManyAt(position + 1, collection.size - position, freeOld)
            ELSE
                TList(collection).DelManyAt(1, position - 1, freeOld);  {$H+}
        WITH SELF DO
            BEGIN
            collection.size := position;
            atEnd := TRUE;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TListScanner.Obtain: TObject;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        Obtain := TList(SELF.collection).At(SELF.position);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TListScanner.Replace(object: TObject; freeOld: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TList(SELF.collection).PutAt(SELF.position, object, freeOld);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TListScanner.Scan(VAR nextObject: TObject): BOOLEAN;
        VAR actIndex:   LONGINT;   {an actual index into the list, INCLUDING the hole as part of the list}
(*
        PROCEDURE AssignListScanVariable(anotherObject: BOOLEAN);
        BEGIN
            IF anotherObject THEN
                nextObject := TList(SELF.collection).At(SELF.position)
            ELSE
                nextObject := NIL;
        END;

    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        Scan := SELF.Advance(AssignListScanVariable);
        {$IFC fTrace}EP;{$ENDC}
    END;
*)
        VAR moreToScan: BOOLEAN;
    BEGIN {speedier version}
        {$IFC fTrace}BP(1);{$ENDC}
        WITH SELF DO
            IF scanDone THEN
                moreToScan := FALSE     {don't reassign nextObject}
            ELSE
                BEGIN
                IF atEnd THEN
                    moreToScan := FALSE
                ELSE
                    BEGIN
                    moreToScan := TRUE;
                    position := position + increment;
                    IF increment > 0 THEN
                        atEnd := position >= collection.size
                    ELSE
                        atEnd := position <= 1;
                    END;

                IF moreToScan THEN
                    BEGIN
                    IF position > collection.holeStart THEN
                        actIndex := position + collection.holeSize
                    ELSE
                        actIndex := position;
                    nextObject := TPObject(TpLONGINT(collection)^ + collection.dynStart + (4 * (actIndex - 1)))^;
                    END
                ELSE
                    nextObject := NIL;
                END;

        IF NOT moreToScan THEN
            SELF.Free;

        Scan := moreToScan;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
BEGIN

    availListScanner := NIL;

END;
{$S SgCLAres}


METHODS OF TArrayScanner;


{$S SgABCdat}
    FUNCTION  TArrayScanner.CREATE(object: TObject; itsArray: TArray;
                                   itsInitialPosition: LONGINT; itsScanDirection: TScanDirection): TArrayScanner;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF object = NIL THEN
            object := NewOrRecycledObject(mainHeap, THISCLASS, availArrayScanner);
        SELF := TArrayScanner(TScanner.CREATE(object, itsArray, itsInitialPosition, itsScanDirection));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArrayScanner.Free;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        RecycleObject(SELF, availArrayScanner);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArrayScanner.Append(pRecord: Ptr);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TArray(SELF.collection).InsAt(SELF.position + 1, pRecord);
        SELF.position := SELF.position + 1;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArrayScanner.Delete;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TArray(SELF.collection).DelAt(SELF.position);
        WITH SELF DO
            IF increment > 0 THEN
                position := position - 1;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArrayScanner.DeleteRest;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        WITH SELF DO
            IF increment > 0 THEN
       {$H-}    TArray(collection).DelManyAt(position + 1, collection.size - position)
            ELSE
                TArray(collection).DelManyAt(1, position - 1);  {$H+}

        WITH SELF DO
            BEGIN
            collection.size := position;
            atEnd := TRUE;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TArrayScanner.Obtain: Ptr;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        Obtain := TArray(SELF.collection).At(SELF.position);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TArrayScanner.Replace(pRecord: Ptr);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TArray(SELF.collection).PutAt(SELF.position, pRecord);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TArrayScanner.Scan(VAR pNextRecord: Ptr): BOOLEAN;

        PROCEDURE AssignArrayScanVariable(anotherRecord: BOOLEAN);
        BEGIN
            IF anotherRecord THEN
                pNextRecord := TArray(SELF.collection).At(SELF.position)
            ELSE
                pNextRecord := NIL;
        END;

    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        Scan := SELF.Advance(AssignArrayScanVariable);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
BEGIN

    availArrayScanner := NIL;

END;
{$S SgCLAres}


METHODS OF TStringScanner;


{$S SgABCdat}
    FUNCTION  TStringScanner.CREATE(object: TObject; itsString: TString;
                                   itsInitialPosition: LONGINT; itsScanDirection: TScanDirection): TStringScanner;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF object = NIL THEN
            object := NewOrRecycledObject(mainHeap, THISCLASS, availStringScanner);
        SELF := TStringScanner(TScanner.CREATE(object, itsString, itsInitialPosition, itsScanDirection));
        SELF.actual := 0;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.Free;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        RecycleObject(SELF, availStringScanner);
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TStringScanner.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('actual: LONGINT');
    END;
    {$S SgCLAres}
    {$ENDC}


{$S SgABCdat}
    PROCEDURE TStringScanner.Append(character: CHAR);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TString(SELF.collection).InsAt(SELF.position + 1, character);
        SELF.position := SELF.position + 1;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.Delete;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TString(SELF.collection).DelAt(SELF.position);
        WITH SELF DO
            IF increment > 0 THEN
                position := position - 1;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.DeleteRest;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        WITH SELF DO
            IF increment > 0 THEN
       {$H-}    TString(collection).DelManyAt(position + 1, collection.size - position)
            ELSE
                TString(collection).DelManyAt(1, position - 1);  {$H+}

        WITH SELF DO
            BEGIN
            collection.size := position;
            atEnd := TRUE;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TStringScanner.Obtain: CHAR;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        Obtain := TString(SELF.collection).At(SELF.position);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.Replace(character: CHAR);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        TString(SELF.collection).PutAt(SELF.position, character);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TStringScanner.Scan(VAR nextChar: CHAR): BOOLEAN;

        PROCEDURE AssignStringScanVariable(anotherChar: BOOLEAN);
        BEGIN
            IF anotherChar THEN
                nextChar := TString(SELF.collection).At(SELF.position)
            ELSE
                nextChar := CHAR(0);
        END;

    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        Scan := SELF.Advance(AssignStringScanVariable);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TStringScanner.ReadArray(heap: THeap; bytesPerRecord: INTEGER): TArray;
        VAR a:  TArray;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        a := TArray.CREATE(NIL, heap, 0, bytesPerRecord);
        XferContiguous(xRead, a, 2, SELF);
        ReadArray := a;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    FUNCTION  TStringScanner.ReadNumber(numBytes: SizeOfNumber): LONGINT;
        VAR v:
            RECORD
            CASE INTEGER OF
                1: (signExtension, short: INTEGER);
                2: (long: LONGINT);
                END;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        v.long := 0;
        SELF.XferSequential(xRead, Ptr(ORD(@v)+4-numBytes), numBytes);
        IF numBytes=2 THEN
            IF v.short < 0 THEN
                v.signExtension := -1;
        ReadNumber := v.long;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TStringScanner.ReadObject(heap: THeap): TObject;
        VAR class:  TClass;
            object: TObject;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        class := TClass(SELF.ReadNumber(4));
        object := NewObject(heap, class);
        object.Read(SELF);
        ReadObject := object;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.WriteArray(a: TArray);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        XferContiguous(xWrite, a, 2, SELF);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.WriteNumber(value: LONGINT; numBytes: SizeOfNumber);
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.XferSequential(xWrite, Ptr(ORD(@value)+4-numBytes), numBytes);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.WriteObject(object: TObject);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.WriteNumber(ORD(object.Class), 4);
        object.Write(SELF);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.XferContiguous(whichWay: xReadWrite; collection: TCollection);
        VAR numToXfer:  INTEGER;
    BEGIN   {Transfer the size (as an INTEGER), class-specific fields, and members.
             Do not recur on the members.
             Do not transfer the class, the dynStart (=SizeOfClass), or the hole info (=zero).
             When reading, append the elements that are read.
             This only works for contiguous objects up to 32K members in size.}
        {$IFC fTrace}BP(3);{$ENDC}
        XferContiguous(whichWay, collection, 0, SELF);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.XferFields(whichWay: xReadWrite; object: TObject);
    BEGIN   {Transfers the bits of a TObject, excluding the class pointer and any dynamic part}
        {$IFC fTrace}BP(3);{$ENDC}
        SELF.XferSequential(whichWay,
                            Ptr(ORD(TH(object)^) + SIZEOF(TObject)),
                            SizeOfClass(object.Class) - SIZEOF(TObject));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.XferPString(whichWay: xReadWrite; pStr: TPString);
        VAR size: Byte;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        IF whichWay = xWrite THEN
            size := Length(pStr^);
        SELF.XferSequential(whichWay, @size, 1);
        SELF.XferSequential(whichWay, Ptr(ORD(pStr)+1), size);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.XferRandom(whichWay: xReadWrite; pFirst: Ptr; numBytes: LONGINT;
                                        mode: TIOMode; offset: LONGINT);
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        CASE mode OF
            fAbsolute: SELF.Seek(offset);
            fRelative: SELF.Skip(offset);
            END;
        SELF.XferSequential(whichWay, pFirst, numBytes);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TStringScanner.XferSequential(whichWay: xReadWrite; pFirst: Ptr; numBytes: LONGINT);
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        WITH SELF, collection DO
            BEGIN
      {$H-} actual := Min(size - position, numBytes); {$H+}
      {$H-} collection.EditAt(size + 1, 0); {$H+}  {Maybe we should xfer in two steps instead}
            END;
        WITH SELF DO
            BEGIN
      {$H-} XferLeft(pFirst, Ptr(collection.AddrMember(position + 1)), actual); {$H+}
            position := position + actual;
            atEnd := position = collection.size;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
BEGIN

    availStringScanner := NIL;

END;
{$S SgCLAres}


METHODS OF TFileScanner;


{$S sResDat}
    FUNCTION  TFileScanner.CREATE(object: TObject; itsFile: TFile; manip: TAccesses): TFileScanner;
    BEGIN
        {$IFC fTrace}BP(5);{$ENDC}
        IF object = NIL THEN
            object := NewObject(itsFile.Heap, THISCLASS);
        SELF := TFileScanner(TScanner.CREATE(object, itsFile, 0, scanForward));
        SELF.actual := 0;
        SELF.accesses := manip;
        SELF.Open;
        TFile(SELF.collection).scanners.InsLast(SELF);
        {$IFC fTrace}EP;{$ENDC}
    END;
    {$S SgCLAres}


    {$IFC fDebugMethods}
    {$S SgCLAdbg}
    PROCEDURE TFileScanner.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('accesses: Byte');
        Field('refnum: INTEGER');
        Field('error: INTEGER');
    END;
    {$S SgCLAres}
    {$ENDC}


{$S SgABCdat}
    PROCEDURE TFileScanner.FreeObject; {use FreeObject, rather than Free, so that we close the
                                            file if the user says fs.FreeObject (as in
                                            TDocManager.OpenSaved), as well as fs.Free}
    BEGIN
        {$IFC fTrace}BP(5);{$ENDC}
        SELF.Close;
        TFile(SELF.collection).scanners.DelObject(SELF, FALSE);
        SUPERSELF.FreeObject;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TFileScanner.Free;        {Free frees the TFile as well, if no other scanners still exist}
        VAR itsFile: TFile;
    BEGIN
        {$IFC fTrace}BP(5);{$ENDC}
        itsFile := TFile(SELF.collection);
        SELF.FreeObject;
        IF itsFile.scanners.size = 0 THEN
            itsFile.Free;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TFileScanner.Allocate(slack: LONGINT);
        VAR fsInfo:     FS_Info;
            pages:      LONGINT;
            actual:     LONGINT;
            newErr:     INTEGER;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        Info(newErr, SELF.refnum, fsInfo);
        WITH fsInfo DO
            pages := ((size + slack + lpSize - 1) DIV lpSize) - ((pSize + lpSize - 1) DIV lpSize);
        IF pages > 0 THEN
            Allocate(newErr, SELF.refnum, TRUE, pages, actual);
        IF (newErr <= 0) AND (actual < pages) THEN
            Allocate(newErr, SELF.refnum, FALSE, pages - actual, actual);
  {$H-} LatestError(newErr, SELF.error); {$H+}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TFileScanner.Close;
        VAR newErr: INTEGER;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        Close_Object(newErr, SELF.refnum);
  {$H-} LatestError(newErr, SELF.error); {$H+}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TFileScanner.Compact;
        VAR newErr:     INTEGER;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        Compact(newErr, SELF.refnum);
  {$H-} LatestError(newErr, SELF.error); {$H+}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TFileScanner.Delete;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.Skip(-1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TFileScanner.DeleteRest;
        VAR newErr:     INTEGER;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        Truncate(newErr, SELF.refnum);
  {$H-} LatestError(newErr, SELF.error); {$H+}
        WITH SELF DO
            BEGIN
            collection.size := position;
            atEnd := TRUE;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TFileScanner.Append(character: CHAR);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.XferSequential(xWrite, Ptr(ORD(@character)+1), 1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TFileScanner.Obtain: CHAR;
        VAR character: CHAR;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        SELF.XferRandom(xRead, Ptr(ORD(@character) + 1), 1, fRelative, -1);
        Obtain := character;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
{$IFC LibraryVersion <= 20}
    PROCEDURE TFileScanner.Open;
        VAR pPath:      TPPathName;
            itsFile:    TFile;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        itsFile := TFile(SELF.collection);
        pPath := @itsFile.path;
  {$H-} Open(SELF.error, pPath^, SELF.refnum, MSet(SELF.accesses)); {$H+}
        IF (SELF.error = 948) and (fWrite in SELF.accesses) then
            BEGIN
  {$H-}     Make_File(SELF.error, pPath^, 0);
            IF SELF.error <= 0 then
                Open(SELF.error, pPath^, SELF.refnum, MSet(SELF.accesses)); {$H+}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$ELSEC}
    PROCEDURE TFileScanner.Open;
        VAR pPath:      TPPathName;
            itsFile:    TFile;
            pPass:      TPEName;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        itsFile := TFile(SELF.collection);
        pPath := @itsFile.path;
        pPass := @itsFile.password;
  {$H-} Open_Secure(SELF.error, pPath^, SELF.refnum, MSet(SELF.accesses), pPass^); {$H+}
        IF (SELF.error = 948) and (fWrite in SELF.accesses) then
            BEGIN
  {$H-}     Make_Secure(SELF.error, pPath^, pPass^);
            IF SELF.error <= 0 then
                Open_Secure(SELF.error, pPath^, SELF.refnum, MSet(SELF.accesses), pPass^); {$H+}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;
{$ENDC}


{$S SgABCdat}
    PROCEDURE TFileScanner.Replace(character: CHAR);
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.XferRandom(xWrite, Ptr(ORD(@character) + 1), 1, fRelative, -1);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    FUNCTION  TFileScanner.Scan(VAR nextChar: CHAR): BOOLEAN;

        PROCEDURE AssignFileScanVariable(anotherChar: BOOLEAN);
        BEGIN
            IF anotherChar THEN
                SELF.XferSequential(xRead, Ptr(ORD(@nextChar) + 1), 1)
            ELSE
                nextChar := CHAR(0);
        END;

    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        Scan := SELF.Advance(AssignFileScanVariable);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TFileScanner.Seek(newPosition: LONGINT);
        VAR dummy: INTEGER;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.XferRandom(xRead, @dummy, 0, fAbsolute, newPosition);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgABCdat}
    PROCEDURE TFileScanner.Skip(deltaPos: LONGINT);
        VAR dummy: INTEGER;
    BEGIN
        {$IFC fTrace}BP(2);{$ENDC}
        SELF.XferRandom(xRead, @dummy, 0, fRelative, deltaPos);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TFileScanner.XferRandom(whichWay: xReadWrite; pFirst: Ptr; numBytes: LONGINT;
                                        mode: TIOMode; offset: LONGINT);
        VAR newErr:     INTEGER;
            osMode:     IOMode;
            fsInfo:     FS_Info;
            sched_err:  INTEGER;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        osMode := IOMode(mode);
        WITH SELF DO {$H-}
            IF error <= 0 THEN
                BEGIN
                CASE whichWay OF
                    xRead:  BEGIN
                            Sched_Class(sched_err, FALSE);
                            Read_Data(newErr, refnum, ord(pFirst), numBytes, actual, osMode, offset);
                            Sched_Class(sched_err, TRUE);
                            END;
                    xWrite: BEGIN
                            Sched_Class(sched_err, FALSE);
                            Write_Data(newErr, refnum, ord(pFirst), numBytes, actual, osMode, offset);
                            Sched_Class(sched_err, TRUE);
                            collection.size := Max(position + actual, collection.size);
                            END;
                    END;

                IF (newErr = 956) OR (newErr = 963) OR (newErr = 883) OR (newErr = 882) OR
                   (newErr = 848) THEN {EOF}
                    newErr := 0;

                IF mode = fSequential THEN  {do it fast}
                    position := position + actual
                ELSE                        {play it safe}
                    BEGIN
                    Info(newErr, refnum, fsInfo);
                    position := fsInfo.fMark;
                    collection.size := fsInfo.size;
                    END;

                atEnd := position = collection.size;
                LatestError(newErr, error); {$H+}
                END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sResDat}
    PROCEDURE TFileScanner.XferSequential(whichWay: xReadWrite; pFirst: Ptr; numBytes: LONGINT);
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        SELF.XferRandom(whichWay, pFirst, numBytes, fSequential, 0);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
END;
{$S SgCLAres}


{$IFC compatibleLists} {Backward Compatibility}
METHODS OF TDynamicArray;


    FUNCTION  TDynamicArray.CREATE(object: TObject; heap: THeap; bytesPerRecord: INTEGER;
                                   initialSize: INTEGER): TDynamicArray;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF ODD(bytesPerRecord) THEN
            bytesPerRecord := bytesPerRecord + 1;
        SELF := POINTER(ORD(TArray.CREATE(object, heap, initialSize, bytesPerRecord))); {NB reversed args}
        Handle(SELF)^^ := ORD(THISCLASS);
        SELF.EditAt(1, initialSize);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TDynamicArray.BeSize(newSize: INTEGER);
    BEGIN
        SELF.EditAt(SELF.size + 1, newSize - SELF.size);
    END;


    FUNCTION  TDynamicArray.Class: TClass; {So New- & Resize- DynObject will use correct object size}
    BEGIN
        Class := cArray;
    END;


    FUNCTION  TDynamicArray.numRecords: INTEGER;
    BEGIN
        numRecords := SELF.size;
    END;


{$S sInit1}
END;
{$S SgCLAres}


METHODS OF TIndexList;


    FUNCTION  TIndexList.CREATE(object: TObject; heap: THeap; initialSize: INTEGER): TIndexList;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        SELF := POINTER(ORD(TList.CREATE(object, heap, initialSize)));
        Handle(SELF)^^ := ORD(THISCLASS);
        SELF.EditAt(1, initialSize);
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  TIndexList.Class: TClass; {So New- & Resize- DynObject will use correct object size}
    BEGIN
        Class := cList;
    END;


    FUNCTION  TIndexList.numElements: INTEGER;
    BEGIN
        numElements := SELF.size;
    END;


{$S sInit1}
END;
{$S SgCLAres}


METHODS OF TLinkList;


    FUNCTION  TLinkList.CREATE(object: TObject; heap: THeap): TLinkList;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        SELF := POINTER(ORD(TList.CREATE(object, heap, 0)));
        Handle(SELF)^^ := ORD(THISCLASS);
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  TLinkList.numElements: INTEGER;
    BEGIN
        numElements := SELF.size;
    END;


{$S sInit1}
END;
{$S SgCLAres}


METHODS OF TBlockList;


    FUNCTION  TBlockList.CREATE(object: TObject; heap: THeap; itsMinBlockSize: INTEGER): TBlockList;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        SELF := POINTER(ORD(TList.CREATE(object, heap, 0)));
        Handle(SELF)^^ := ORD(THISCLASS);
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  TBlockList.numElements: INTEGER;
    BEGIN
        numElements := SELF.size;
    END;


{$S sInit1}
END;
{$S SgCLAres}


METHODS OF TFileStream;


    FUNCTION  TFileStream.CREATE(object: TObject; heap: THeap; path: S255; manip: TAccesses): TFileStream;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TFileStream(TFileScanner.CREATE(object, TFile.CREATE(NIL, heap, path, ''), manip));
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  TFileStream.Size: LONGINT;
    BEGIN
        {$IFC fTrace}BP(1);{$ENDC}
        Size := SELF.collection.size;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S sInit1}
END;
{$S SgCLAres}


{$S SgCLAcld}
PROCEDURE FileDelete(path: S255);
    VAR osPath:     Pathname;
        error:      INTEGER;
BEGIN
    osPath := path;         { THIS IS THE SECOND TIME WE COPY THE STRING !!!! }
    Kill_Object(error, osPath);
END;
{$S SgCLAres}


{$S SgCLAcld}
PROCEDURE FileLookup(VAR error: INTEGER; path: S255);
    VAR refInfo:    FS_Info;
        osPath:     Pathname;
BEGIN
    osPath := path;         { THIS IS THE SECOND TIME WE COPY THE STRING !!!! }
    Lookup(error, osPath, refInfo);
END;
{$S SgCLAres}


{$S SgCLAcld}
PROCEDURE FileRename(oldPath, newPath: S255);
    VAR osPath:         Pathname;
        osEname:        E_Name;
        error:          INTEGER;
        centerHyphen:   INTEGER;
BEGIN
    osPath := oldPath;
    centerHyphen := pos('-{', newPath);
    osEname := copy(newPath, centerHyphen+1, length(newPath)-centerHyphen);
    Rename_Entry(error, osPath, osEname);
END;
{$S SgCLAres}


{$S SgCLAcld}
FUNCTION FileModified(path: S255): LONGINT;
    VAR refInfo:    FS_Info;
        osPath:     Pathname;
        error:      INTEGER;
BEGIN
    osPath := path;         { THIS IS THE SECOND TIME WE COPY THE STRING !!!! }
    Lookup(error, osPath, refInfo);
    IF error <= 0 THEN
        FileModified := refInfo.DTM
    ELSE
        FileModified := -1;
END;
{$S SgCLAres}


{$ENDC} {Backward Compatibility}




