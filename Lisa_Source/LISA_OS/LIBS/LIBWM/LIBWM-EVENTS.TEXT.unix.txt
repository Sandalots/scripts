
UNIT Events;

{ CopyRight 1983, Apple Computer, Inc. }
{ Written by Bill Atkinson             }

INTRINSIC SHARED;

INTERFACE

USES {$U libos/SysCall   }  SysCall,
     {$U libos/PSysCall  }  PSysCall,
     {$U libhw/HWInt     }  HWInt,
     {$U libsm/UnitStd   }  UnitStd,
     {$U libsm/UnitHz    }  UnitHz,
     {$U libqd/Storage   }  Storage,
     {$U libpm/PmDecl    }  PmDecl,
     {$U libpm/PmM       }  PmM,
     {$U libqd/QuickDraw }  QuickDraw,
     {$U libfm/FontMgr   }  FontMgr;

{$SetC wmOS      := TRUE   }
{$SetC wmDebug   := FALSE }
{$SetC wmSymbols := fSymOk }
{$SetC wmJournal := TRUE  }
{$SetC wmMonkey  := FALSE  }                                                                    { MONKEY }
{$SetC wmScrn2File := TRUE }                                                       { SCREEN DUMP TO FILE }

{$SETC doTraceWM := TRUE}
{$SetC fTraceWM := doTraceWM AND fTRACE}


CONST nilEvent          =  0;     { the event kinds }
      buttonDown        =  1;
      buttonUp          =  2;
      keyDown           =  3;
      folderActivate    =  4;
      folderDeactivate  =  5;
      folderUpdate      =  6;
      folderMoved       =  7;
      filerEvent        =  8;
      abortEvent        =  9;
      diedEvent         = 10;
      private1          = 11;
      private2          = 12;
      private3          = 13;
      diskEvent         = 14;
      catalogEvent      = 15;
      { when adding new event, adjust evntKind for debugging use. }


      disk1InCode       =   1;     { special keyCode values }
      disk1OutCode      =   2;
      disk2InCode       =   3;
      disk2OutCode      =   4;
      paraCode          =   5;
      buttonCode        =   6;
      mouseCode         =   7;
      powerCode         =   8;
      microInCode       =  11;     { Built-in Sony drives }
      micro1InCode      =  12;
      micro2InCode      =  13;
      micro3InCode      =  14;
      microOutCode      =  15;
      micro1Outcode     =  16;
      micro2OutCode     =  17;
      micro3OutCode     =  18;
      optionCode        = 104;
      shiftCode         = 126;
      commandCode       = 127;



      nilUserData       =   0;
      nilProcess        =   0;

      whyNot            =   0;
      whyClick          = 300;
      whyClose          = 301;
      whyDisk           = 302;
      whyDied           = 303;
      whyFind           = 304;


TYPE KeyCode     = 0..127;
     KeySet      = SET OF KeyCode;
     ProcessId   = LongInt;
     WindowPtr   = GrafPtr;
     EventHandle = ^EventPtr;
     EventKind   = INTEGER;
     EventPtr    = ^EventRecord;
     EventRecord = RECORD
                     who:         WindowPtr;  { which window is this for  }
                     what:        EventKind;  { what happened             }
                     where:       Point;      { where was the mouse       }
                     when:        LongInt;    { when did it happen        }
                     why:         INTEGER;    { why did it happen         }
                     shiftKey:    BOOLEAN;    { was the shift key down    }
                     alphaKey:    BOOLEAN;    { was the alpha key down    }
                     codeKey:     BOOLEAN;    { was the option key down   }
                     appleKey:    BOOLEAN;    { was the command key down  }
                     mouseKey:    BOOLEAN;    { was the mouse button down }
                     repeatKey:   BOOLEAN;    { was this key repeated     }
                     keyCap:      KeyCode;    { raw keyCap number         }
                     ascii:       CHAR;       { decoded ascii character   }
                     toProcess:   ProcessId;  { which process is it for   }
                     fromProcess: ProcessId;  { which process is it from  }
                     fromFolder:  WindowPtr;  { which folder is it from   }
                     userData:    LongInt;    { for filer messages etc.   }
                   END;


VAR wmHeap:         Thz;
    deskPort:       GrafPtr;

    menuFolder:     WindowPtr;    { the system windows }
    alertFolder:    WindowPtr;
    dialogFolder:   WindowPtr;
    filerFolder:    WindowPtr;
    scrapFolder:    WindowPtr;
    activeFolder:   WindowPtr;
    keyWindow:      WindowPtr;

    filerProcess:   ProcessId;    { their associated processes }
    scrapProcess:   ProcessId;
    activeProcess:  ProcessId;
    keyProcess:     ProcessId;

    clickDelay:     LongInt;      { standard double click time }
    caretOnTime:    LongInt;      { standard caret blink time  }
    caretOffTime:   LongInt;

    eventDebug:     BOOLEAN;

    trapKeys:       KeySet;       { special for interactive manuals }
    keyTrapProc:    ProcPtr;
    trapPrcs:       ProcessId;
    _CA_StartFlag:  BOOLEAN;      { special for coverage analyzer }
    queueLocked:    BOOLEAN;
    recordFlag:     BOOLEAN;      { for NPR only }
    playFlag:       BOOLEAN;

    monkeyFlag:     BOOLEAN;      { Monkey On/Off switch }                                      { MONKEY }
    monkeyWorld:    BOOLEAN;      { 1=full desk, 0=current window }                             { MONKEY }

 { spares for future reusable changes }

    wmspare1:       LONGINT;
    wmspare2:       LONGINT;
    wmspare3:       LONGINT;
    wmspare4:       LONGINT;
    wmspare5:       LONGINT;


FUNCTION  Abort:        BOOLEAN;
FUNCTION  Button:       BOOLEAN;                                         {  Semi-private procedure }
PROCEDURE CheckEvents   (updateOK: BOOLEAN);                             {  Semi-private procedure }
PROCEDURE DeleteEvent   (evHandle: EventHandle);                         {  Semi-private procedure }
FUNCTION  ElapsTime:    LongInt;
FUNCTION  EventAvail:   BOOLEAN;
FUNCTION  FirstEvent:   EventHandle;                                     {  Semi-private procedure }
PROCEDURE GetEvent      (VAR event: EventRecord);
PROCEDURE GetEvFrom     (fromProcess: ProcessID; VAR event: EventRecord);{  Semi-private procedure }
PROCEDURE GetKeys       (VAR keys: KeySet);
PROCEDURE GetMouse      (VAR pt: Point);
FUNCTION  ImActive:     BOOLEAN;
PROCEDURE InitEvents;                                                    {  Semi-private procedure }
PROCEDURE LetOthersRun;
FUNCTION  NextEvent     (evHandle: EventHandle): EventHandle;            {  Semi-private procedure }
FUNCTION  PeekEvent     (VAR event: EventRecord): BOOLEAN;
PROCEDURE PrintScreen;                                                   {  Semi-private procedure }
PROCEDURE PushEvent     (VAR event: EventRecord);                        {  Semi-private procedure }
PROCEDURE SendEvent     (VAR event: EventRecord; toPrcs: ProcessId);
FUNCTION  StillDown:    BOOLEAN;
FUNCTION  Time:         LongInt;
PROCEDURE WakeUpHead;                                                    {  Semi-private procedure }

{$IFC wmJournal }
PROCEDURE StartPlayback (fileName: PathName; journalMode: INTEGER);      {  Journal procedures     }
PROCEDURE StartRecording(fileName: PathName; journalMode: INTEGER);
PROCEDURE StopPlayback;
PROCEDURE StopRecording;
{$ENDC }


IMPLEMENTATION

{$IFC wmDebug}
{$R+}
{$ELSEC}
{$R-}
{$ENDC}

{$IFC wmSymbols}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}

CONST  badKind    =    0;
       keyKind    =    1;       { the journal record kinds }
       mouseKind  =    2;
       timeKind   =    3;
       buttonKind =    4;
       endKind    =    5;
       beginKind  =    6;
       runKind    =    7;
       keyMapKind =    8;
       firstKind  =    badKind;
       lastKind   =    keyMapKind;
       lastOp     =   13;       { size of compression table }
       cursorDelay = 3000;      { 3 seconds before busy cursor shows }



TYPE EvNodeHandle = ^EvNodePtr;
     EvNodePtr    = ^EventNode;
     EventNode    = RECORD
                      event:      EventRecord;
                      nextEvNode: EvNodeHandle;
                      prevEvNode: EvNodeHandle;
                    END;

    JournalKind = INTEGER;


VAR eventHead:          EvNodeHandle;
    eventTail:          EvNodeHandle;
    hourGlass:          Cursor;
    keyState:           KeyEvent;
    keyStatus:          INTEGER;

{$IFC wmDebug }
    evntKinds:          ARRAY[nilEvent..catalogEvent] OF String[10];
{$ENDC}


{$IFC wmJournal }
    recordFile:         INTEGER;
    recordCount:        LongInt;
    playFile:           INTEGER;
    playCount:          LongInt;
    endCount:           LongInt;
    stopKind:           JournalKind;
    printNumbers:       BOOLEAN;
    jrnlMode:           INTEGER;
    waitForKind:        JournalKind;
    waitCount:          INTEGER;

    timeState:          LongInt;   { the current state for record or playBack }
    mouseState:         Point;
    buttonState:        BOOLEAN;
    keyMapState:        KeySet;

    oldTime:            LongInt;
    oldMouse:           Point;
    oldButton:          BOOLEAN;
    oldMapState:        KeySet;

    deltaTime:          LongInt;

    jrnlKinds:          ARRAY[firstKind..lastKind] OF String[8];

    opA,opB,opAB:       ARRAY[0..lastOp] OF INTEGER;   { group compression stuff }
    expandSet:          SET OF 0..255;
    opBuf:              ARRAY[0..7] OF INTEGER;
    opBufIndex:         INTEGER;
    oldOp:              INTEGER;

    recRunCount:        LongInt;        { run compression stuff }
    playRunCount:       LongInt;
    recRunData:         INTEGER;
    playRunData:        INTEGER;
{$ENDC}

{$IFC wmMonkey}                                                                                 { MONKEY }
    buttonFocus:        INTEGER;                { prcnt of button vs key events }               { MONKEY }
    buttonsUp:          BOOLEAN;                { TRUE=buttons up, finish drag }                { MONKEY }
    didDrag:            BOOLEAN;                { TRUE=drag occured, finish up }                { MONKEY }
    logCount:           LONGINT;                { meter for logging total events }              { MONKEY }
    menuFocus:          INTEGER;                { frequency of menu drags }                     { MONKEY }
    mnkyBreak:          BOOLEAN;                { TRUE=begin single step at stepCount }         { MONKEY }
    mnkyClicks:         INTEGER;                { multiple mouse click count }                  { MONKEY }
    mnkyDown:           BOOLEAN;                { tracks button status for keystate.state}      { MONKEY }
    mnkyDrag:           BOOLEAN;                { TRUE=click-down,drag,click-up }               { MONKEY }
    mnkyMenu:           BOOLEAN;                { TRUE=menu bar hit, do a menu drag }           { MONKEY }
    mnkyCount:          LONGINT;                { total number of monkey events }               { MONKEY }
    mnkyStep:           BOOLEAN;                { TRUE=single stepping enabled }                { MONKEY }
    mnkyStress:         INTEGER;                { frequency of random events }                  { MONKEY }
    oldXMouse:          Pixels;                 { last known mouse coordinates - X }            { MONKEY }
    oldYMouse:          Pixels;                 { last known mouse coordinates - Y }            { MONKEY }
    snglStep:           BOOLEAN;                { TRUE=single step one event }                  { MONKEY }
    stepPoint:          LONGINT;                { begin single-stepping here }                  { MONKEY }
{$ENDC}                                                                                         { MONKEY }

{$IFC wmScrn2File}                                                                 { SCREEN DUMP TO FILE }
    screenFileNum :     integer;                { suffix for screen dump file names  SCREEN DUMP TO FILE }
{$ENDC}                                                                            { SCREEN DUMP TO FILE }


PROCEDURE DelEvNode(thisEv: EvNodeHandle);                                          FORWARD;
FUNCTION  Now: LongInt;                                                             FORWARD;

{$IFC wmJournal }   { all journal stuff is optional }
PROCEDURE ReadJournal(kind: JournalKind);                                           FORWARD;
PROCEDURE WriteJournal(kind: JournalKind);                                          FORWARD;
{$ENDC }

{ assembly language routines, all in graflib }
FUNCTION  BitAnd(long1,long2: LongInt): LongInt;                                    EXTERNAL;
PROCEDURE BitClr(addr: Ptr; bitNumber: LongInt);                                    EXTERNAL;
PROCEDURE BitSet(addr: Ptr; bitNumber: LongInt);                                    EXTERNAL;   { MONKEY }
FUNCTION  BitTst(addr: Ptr; bitNumber: LongInt): BOOLEAN;                           EXTERNAL;
PROCEDURE CallKeyTrap(key: KeyCode; keyTrapProc: ProcPtr);                          EXTERNAL;

{ the two UpStream calls to Unit Windows }
PROCEDURE CheckWindow(VAR event: EventRecord);                                      EXTERNAL;
PROCEDURE SendUpdate;                                                               EXTERNAL;

{ upstream call to Unit Folders }
PROCEDURE GetFldrTitle(folder: WindowPtr; VAR title: Str255);                       EXTERNAL;
PROCEDURE HeDied(deadProcess: ProcessID);                                           EXTERNAL;

{$IFC wmMonkey}                                                                                 { MONKEY }
{ Monkey  Functions and Procedures  }                                                           { MONKEY }
FUNCTION  MonkeyBool(freq: INTEGER): BOOLEAN;                                       FORWARD;    { MONKEY }
FUNCTION  MonkeyButton: BOOLEAN;                                                    FORWARD;    { MONKEY }
FUNCTION  MonkeyDo(repOK: BOOLEAN; VAR mnkyVent: KeyEvent): BOOLEAN;                FORWARD;    { MONKEY }
PROCEDURE MonkeyInit;                                                               FORWARD;    { MONKEY }
PROCEDURE MonkeyListen;                                                             FORWARD;    { MONKEY }
PROCEDURE MonkeyMake(repOK: BOOLEAN; VAR mnkyVent: KeyEvent);                       FORWARD;    { MONKEY }
PROCEDURE MonkeyMouse(VAR mouseX: Pixels;  VAR mouseY: Pixels);                     FORWARD;    { MONKEY }
PROCEDURE MonkeyRepeat(VAR mnkyVent: KeyEvent);                                     FORWARD;    { MONKEY }
FUNCTION  MonkeyStillDown: BOOLEAN;                                                 FORWARD;    { MONKEY }
{$ENDC }                                                                                        { MONKEY }

{$IFC wmScrn2File}                                                                 { SCREEN DUMP TO FILE }
PROCEDURE FileScreen;                                                               FORWARD;
{$ENDC}                                                                            { SCREEN DUMP TO FILE }


{$S WMothrwk }
{-----------------------------------------------------------------------}
FUNCTION Abort{ : BOOLEAN};
{-----------------------------------------------------------------------}
VAR thisEv: EvNodeHandle;
    me: ProcessID;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  CheckEvents(FALSE);  { empty the interrupt buffer, no updates }
  me := My_ID;
  Abort := FALSE;

  thisEv := eventHead^^.nextEvNode;
  WHILE thisEv <> eventTail DO WITH thisEv^^ DO
    BEGIN
      IF  (event.toProcess=me) AND (event.what = abortEvent)
      THEN
        BEGIN
          Abort := TRUE;
          EXIT(Abort);
        END;
      thisEv := nextEvNode;
    END;
END;


{$S WMwork }
{-----------------------------------------------------------------------}
FUNCTION Button{ : BOOLEAN};
{-----------------------------------------------------------------------}
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF ImActive THEN BusyDelay(cursorDelay);
{$IFC wmJournal }                                                                               { MONKEY }
  {$IFC wmMonkey }                                                                              { MONKEY }
    oldButton := buttonState;                                                                   { MONKEY }
    IF        playFlag THEN ReadJournal(buttonKind)                                             { MONKEY }
    ELSE IF monkeyFlag THEN buttonState := MonkeyButton                                         { MONKEY }
                       ELSE buttonState := KeyIsDown(buttonCode);                               { MONKEY }
    IF recordFlag THEN WriteJournal(buttonKind);                                                { MONKEY }
    Button := buttonState;                                                                      { MONKEY }
  {$ELSEC }                                                                                     { MONKEY }
    oldButton := buttonState;                                                                   { MONKEY }
    IF playFlag THEN ReadJournal(buttonKind)                                                    { MONKEY }
                ELSE buttonState := KeyIsDown(buttonCode);                                      { MONKEY }
    IF recordFlag THEN WriteJournal(buttonKind);                                                { MONKEY }
    Button := buttonState;                                                                      { MONKEY }
  {$ENDC }                                                                                      { MONKEY }
{$ELSEC }                                                                                       { MONKEY }
  {$IFC wmMonkey }                                                                              { MONKEY }
    IF monkeyFlag THEN Button := MonkeyButton                                                   { MONKEY }
                  ELSE Button := KeyIsDown(buttonCode);                                         { MONKEY }
  {$ELSEC }                                                                                     { MONKEY }
    Button := KeyIsDown(buttonCode);                                                            { MONKEY }
  {$ENDC }                                                                                      { MONKEY }
{$ENDC }                                                                                        { MONKEY }
END;


{$S WMwork }
{-----------------------------------------------------------------------}
PROCEDURE CheckEvents{updateOK: BOOLEAN};
{-----------------------------------------------------------------------}

{ Pull all events from the interrupt buffer, calling CheckWindow }
{ to classify each. If no events in interrupt buffer and none in }
{ the big queue, then send an update. }

LABEL 1, 33;
VAR event:      EventRecord;
    shifts:     INTEGER;
    flagPtr:    Ptr;
    pt:         Point;
    repeatOK:   BOOLEAN;
    saveContrast: INTEGER;

{$IFC wmDebug AND wmOS }
    errNum:     INTEGER;
    prcsInfo:   ProcInfoRec;
{$ENDC }


{$S WMwork }
    PROCEDURE GetNextKey;
    BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmJournal }                                                                               { MONKEY }
  {$IFC wmMonkey }                                                                              { MONKEY }
      IF        playFlag THEN ReadJournal(keyKind)                                              { MONKEY }
      ELSE IF monkeyFlag THEN keyStatus := ORD(MonkeyDo(repeatOk,keyState))                     { MONKEY }
                         ELSE keyStatus := ORD(KeybdEvent(repeatOk,FALSE,keyState));            { MONKEY }
      IF recordFlag THEN WriteJournal(keyKind);                                                 { MONKEY }
  {$ELSEC }                                                                                     { MONKEY }
      IF playFlag THEN ReadJournal(keyKind)                                                     { MONKEY }
                  ELSE keyStatus := ORD(KeybdEvent(repeatOk,FALSE,keyState));                   { MONKEY }
      IF recordFlag THEN WriteJournal(keyKind);                                                 { MONKEY }
  {$ENDC }                                                                                      { MONKEY }
{$ELSEC }                                                                                       { MONKEY }
  {$IFC wmMonkey }                                                                              { MONKEY }
      IF monkeyFlag THEN keyStatus := ORD(MonkeyDo(repeatOk,keyState))                          { MONKEY }
                    ELSE keyStatus := ORD(KeybdEvent(repeatOk,FALSE,keyState));                 { MONKEY }
  {$ELSEC }                                                                                     { MONKEY }
      keyStatus := ORD(KeybdEvent(repeatOk,FALSE,keyState));                                    { MONKEY }
  {$ENDC }                                                                                      { MONKEY }
{$ENDC }                                                                                        { MONKEY }

      { handle wierd stuff for interactive manuals }
      IF (keyStatus <> 0) AND (keyState.key IN trapKeys)
      THEN
        BEGIN
          IF My_ID = trapPrcs THEN CallKeyTrap(keyState.key,keyTrapProc)
          ELSE
            BEGIN
              WITH event DO
                BEGIN
                  who         := Nil;
                  what        := private1;
                  keyCap      := keyState.key;
                END;
              SendEvent(event,trapPrcs);
            END;
        END;
    END;


{$S WMwork }
BEGIN
{$IFC wmDebug AND wmOS }
{ temporary check to be sure that activeProcess is running at priority 130 }
   IF activeProcess <> nilProcess THEN
     BEGIN
       Info_Process(errNum,activeProcess,prcsInfo);
       (*
       IF prcsInfo.priority <> 130 THEN WRITELN(
       'CheckEvents says activeProcess at priority ',prcsInfo.priority);
       *)
     END;

{$ENDC }

{$IFC wmMonkey}                                                                                 { MONKEY }
    IF NOT(monkeyFlag) THEN GetMouse(pt);   { tickle the cursor in case journal }               { MONKEY }
{$ELSEC}                                                                                        { MONKEY }
    GetMouse(pt);   {tickle the cursor in case journal}                                         { MONKEY }
{$ENDC}                                                                                         { MONKEY }

  repeatOK := (eventHead^^.nextEvNode = eventTail);
  GetNextKey;
  repeatOK := FALSE;

  IF keyStatus = 0 THEN  { no key in interrupt buffer }
    BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
      { possibly send one update, only if no events for anybody }
      IF updateOK AND (eventHead^^.nextEvNode = eventTail) THEN SendUpdate;
      EXIT(CheckEvents);
    END;

  REPEAT

{$IFC wmMonkey}                                                                                 { MONKEY }
    IF NOT(monkeyFlag) THEN GetMouse(pt);   { tickle the cursor in case journal }               { MONKEY }
{$ELSEC}                                                                                        { MONKEY }
    GetMouse(pt);   {tickle the cursor in case journal}                                         { MONKEY }
{$ENDC}                                                                                         { MONKEY }
33:
    shifts := keyState.state;
    flagPtr := @shifts;
    WITH event DO
      BEGIN
        who         := Nil;
        what        := nilEvent;
        where.h     := keyState.mouseX;
        where.v     := keyState.mouseY;
        when        := keyState.time DIV 10;  { scale to 100ths }
        why         := whyNot;
        shiftKey    := BitTst(flagPtr,14);    { left or right shift key }
        alphaKey    := BitTst(flagPtr,15);    { alpha lock key }
        codeKey     := BitTst(flagPtr,13);    { option key(s)  }
        appleKey    := BitTst(flagPtr,12);    { command key }
        mouseKey    := BitTst(flagPtr,11);    { mouse button }
        repeatKey   := BitTst(flagPtr,10);    { was key repeated }
        keyCap      := keyState.key;
        ascii       := KeyState.ascii;
        toProcess   := NilProcess;
        fromProcess := NilProcess;
        fromFolder  := Nil;
        userData    := keyStatus;
      END;

    { don't repeat command characters -- unless wmSpare1 <> 0 }
    IF event.repeatKey AND event.appleKey AND (wmSpare1 = 0) THEN GOTO 1;

    { check for a few special shift option characters }
    IF event.codeKey
    AND event.shiftKey
    AND NOT event.repeatKey THEN
    CASE event.KeyCap OF

      73: BEGIN  { shift option 0  --> hide screen }
            saveContrast := Contrast;
            RampContrast(255);
            REPEAT GetNextKey UNTIL keyStatus <> 0;
            RampContrast(saveContrast);
            IF keystate.key IN [microInCode,powerCode,116{microOutCode}]
            THEN GOTO 33;     { don't throw away disk/power events }
            GOTO 1;
          END;

      40: BEGIN  { shift option 4  --> print screen }
            PrintScreen;
            GOTO 1;
          END;

      33: BEGIN  { shift option -  --> enable NMI from '-' key }
            SetNMIKey(33);
          END;

      {$IFC wmScrn2File}                                                                { SCREEN DUMP TO FILE }
      36: BEGIN  { shift option 7  --> dump screen to file}
            FileScreen;                                                                 { SCREEN DUMP TO FILE }
            GOTO 1;                                                                     { SCREEN DUMP TO FILE }
          END;                                                                          { SCREEN DUMP TO FILE }
      {$ENDC}                                                                           { SCREEN DUMP TO FILE }

      {$IFC ftrace}
       68: BEGIN {shift option p trace procs}
           ResetTrace(TRUE);
           writeln( 'Hash Table reset -- Trace Procedures Enabled');
           GOTO 1;
           END;
      118: BEGIN {shift option s trace segs}
           ResetTrace(FALSE);
           writeln( 'Hash Table reset -- Trace Segments Enabled');
           GOTO 1;
           END;
      106: BEGIN {shift option g start trace}
           StartCallLog;
           writeln( 'Starting to log calls');
           GOTO 1;
           END;
      107: BEGIN {shift option h stop trace}
           StopCallLog;
           writeln( 'Logging of calls Stopped');
           GOTO 1;
           END;
       89: BEGIN {shift option l list trace}
           ListCalls;
           GOTO 1;
           END;
      102: BEGIN {shift option t enable tracing}
           SetCallTrace(TRUE);
           writeln( 'Tracing Enabled');
           GOTO 1;
           END;
      111: BEGIN {shift option n disable tracing}
           SetCallTrace(FALSE);
           writeln( 'Tracing Disabled');
           GOTO 1;
           END;
      {$ENDC}
    END;  { case }

{$IFC wmMonkey}                                                                                 { MONKEY }
    IF event.codeKey                                                                            { MONKEY }
    AND event.appleKey                                                                          { MONKEY }
    AND NOT event.repeatKey                                                                     { MONKEY }
    AND NOT monkeyFlag THEN             {Don't let the Monkey start itself}                     { MONKEY }
    CASE event.KeyCap OF                                                                        { MONKEY }
                                                                                                { MONKEY }
      88: BEGIN  { apple option M  --> invoke Monkey }                                          { MONKEY }
            MonkeyInit;                                                                         { MONKEY }
            GOTO 1;                                                                             { MONKEY }
          END;                                                                                  { MONKEY }
                                                                                                { MONKEY }
    END;  { case }                                                                              { MONKEY }
{$ENDC}                                                                                         { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}

    CheckWindow(event);

1:  keyStatus := 0; { reset keyStatus here, allows for inexact journal mode }
    GetNextKey;

  UNTIL keyStatus = 0;
END;


{$S WMothrwk }
{-----------------------------------------------------------------------}
PROCEDURE DeleteEvent{evHandle: EventHandle};
{-----------------------------------------------------------------------}
{ public procedure used by Alert manager }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  DelEvNode(Pointer(ORD(evHandle)));
  queueLocked := FALSE;
END;


{$S WMwork }
{-----------------------------------------------------------------------}
PROCEDURE DelEvNode{thisEv: EvNodeHandle};
{-----------------------------------------------------------------------}
{  Delete an event node from the event list.  }
VAR prevEv,nextEv: EvNodeHandle;
{$IFC wmDebug }
    title: Str255;
{$ENDC }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF (thisEv = eventHead)
  OR (thisEv = eventTail)
  OR (thisEv = Nil)
  THEN EXIT(DelEvNode);

{$IFC wmDebug }
  IF eventDebug THEN WITH thisEv^^ DO
    BEGIN
      WRITE ('Delete wm event: ');
      IF event.what > private3
      THEN WRITE('Event number ',event.what:1)
      ELSE WRITE(evntKinds[event.what]);
      GetFldrTitle(event.who,title);
      WRITE(' to ',title);
      IF event.who = activeFolder THEN WRITE(' (active)');
      WRITELN(', proc ',event.toProcess:1,' from ',event.fromProcess:1,' by ',My_ID:1);
    END;
{$ENDC }

  prevEv := thisEv^^.prevEvNode;
  nextEv := thisEv^^.nextEvNode;
  prevEv^^.nextEvNode := nextEv;
  nextEv^^.prevEvNode := prevEv;
  DisposeHandle(Pointer(ORD(thisEv)));
END;


{$S WMcold }
{-----------------------------------------------------------------------}
FUNCTION  ElapsTime{ : LONGINT};
{-----------------------------------------------------------------------}
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  ElapsTime := Timer*1000;  { convert milliseconds to microseconds }
END;


{$S WMwork }
{-----------------------------------------------------------------------}
FUNCTION EventAvail{ : BOOLEAN};
{-----------------------------------------------------------------------}

{ Empty the interrupt buffer, classifying each low-level event. }
{ Then return TRUE if the next event is for my process.         }
{ IF the next event isnt for me, wake up the guy who it's for.  }

LABEL 1,2;

VAR minTime:     LongInt;
    headEvNode:  EvNodeHandle;
    eventWhat: EventKind;

BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
   IF ImActive THEN BusyDelay(cursorDelay);
   CheckEvents(TRUE);        { empty the interrupt buffer, update ok }
   EventAvail := FALSE;

1: headEvNode := eventHead^^.nextEvNode;
   IF queueLocked OR (headEvNode = eventTail) THEN GOTO 2;

   IF headEvNode^^.event.toProcess = My_ID THEN
     BEGIN
       eventWhat := headEvNode^^.event.what;
       IF (eventWhat = buttonDown)
       OR (eventWhat = buttonUp)
       OR (eventWhat = keyDown) THEN
         BEGIN
           IF NOT ImActive THEN
             BEGIN
               DelEvNode(headEvNode);
               GOTO 1;
             END;
         END;

       EventAvail := TRUE;
       EXIT(EventAvail);
     END;

   WakeUpHead;

2:
{$IFC wmJournal }
   IF recordFlag AND ODD(jrnlMode) THEN
     BEGIN
       { delay 1/20th second to cut down on journal size }
       minTime := Now + 5;
       REPEAT Until Now >= minTime;
     END;
{$ENDC }

END;


{$S WMwork }
{-----------------------------------------------------------------------}
FUNCTION FirstEvent{ : EventHandle};
{-----------------------------------------------------------------------}
{ return an EventHandle to the oldest event in the queue }
{ if queue empty, return Nil. }
VAR thisEv: EvNodeHandle;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  CheckEvents(FALSE);  { empty interrupt buffer, no updates }
  thisEv := eventHead^^.nextEvNode;
  IF thisEv=eventTail
  THEN FirstEvent := Nil
  ELSE FirstEvent := Pointer(ORD(thisEv));
END;


{$S WMwork }
{-----------------------------------------------------------------------}
PROCEDURE GetEvent{VAR event: EventRecord};
{-----------------------------------------------------------------------}

{ Get the oldest event for the current process. }
{ If there are none, then suspend the process. }

VAR title:   Str255;
    errNum:  INTEGER;

BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmDebug }
  IF eventDebug THEN WRITE('GetEvent: proc ',My_ID:1,' - ');
{$ENDC }

  WHILE NOT PeekEvent(event) DO
    { don't suspend me if Im active or nobody is active }
    IF ImActive
    THEN LetOthersRun
    ELSE
      BEGIN
{$IFC wmDebug }
        IF eventDebug THEN WRITELN('suspending');
{$ENDC }
        Suspend_Process(errnum,My_ID,FALSE);
{$IFC wmDebug }
        IF eventDebug THEN WRITE('Proc ',My_ID:1,' activated - ');
{$ENDC }
      END;

  DelEvNode(eventHead^^.nextEvNode);

  IF event.what = folderDeactivate THEN queueLocked := TRUE;

END;


{$S WMwarm }
{-----------------------------------------------------------------------}
PROCEDURE GetEvFrom{fromProcess: ProcessID; VAR event: EventRecord};
{-----------------------------------------------------------------------}
{ get the first event for me, from the specified process }
VAR which: EventHandle;
  toProcess: ProcessId;
  found:  BOOLEAN;
  errNum: INTEGER;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  toProcess :=  My_ID;
  which  :=  FirstEvent;
  found  :=  FALSE;
  REPEAT
    IF which = Nil THEN
      BEGIN
        WakeUpHead;
        Suspend_Process(errNum,My_ID,FALSE);
        which := FirstEvent;
      END
    ELSE
      BEGIN
        IF  (which^^.fromProcess = fromProcess)
        AND (which^^.toProcess = toProcess)
        AND (which^^.what <> folderDeactivate)
        THEN found := TRUE
        ELSE which := NextEvent(which);
      END;
  UNTIL found;
  event := which^^;
  DeleteEvent(which);
END;


{$S WMothrwk }
{-----------------------------------------------------------------------}
PROCEDURE GetKeys{VAR keys: KeySet};
{-----------------------------------------------------------------------}
{ inquire the current state of all keys on the keyboard }
VAR typeConvert: ^KeyCapSet;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmJournal }
  oldMapState := keyMapState;
  IF playFlag
  THEN ReadJournal(keyMapKind)
  ELSE
    BEGIN
      typeConvert := @keyMapState;
      KeyMap(typeConvert^);
    END;
  IF recordFlag THEN WriteJournal(keyMapKind);
  keys := keyMapState;
{$ELSEC }
  typeConvert := @keys;
  KeyMap(typeConvert^);
{$ENDC }
END;


{$S WMwork }
{-----------------------------------------------------------------------}
PROCEDURE GetMouse{VAR pt: Point};
{-----------------------------------------------------------------------}
{ inquire the current mouse location in local coordinates }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmJournal }                                                                               { MONKEY }
  {$IFC wmMonkey }                                                                              { MONKEY }
    oldMouse := mouseState;                                                                     { MONKEY }
    IF        playFlag THEN ReadJournal(mouseKind)                                              { MONKEY }
    ELSE IF monkeyFlag THEN MonkeyMouse(mouseState.h,mouseState.v)                              { MONKEY }
                       ELSE MouseLocation(mouseState.h,mouseState.v);                           { MONKEY }
    IF recordFlag THEN WriteJournal(mouseKind);                                                 { MONKEY }
    pt := mouseState;                                                                           { MONKEY }
  {$ELSEC }                                                                                     { MONKEY }
    oldMouse := mouseState;                                                                     { MONKEY }
    IF playFlag THEN ReadJournal(mouseKind)                                                     { MONKEY }
                ELSE MouseLocation(mouseState.h,mouseState.v);                                  { MONKEY }
    IF recordFlag THEN WriteJournal(mouseKind);                                                 { MONKEY }
    pt := mouseState;                                                                           { MONKEY }
  {$ENDC }                                                                                      { MONKEY }
{$ELSEC }                                                                                       { MONKEY }
  {$IFC wmMonkey }                                                                              { MONKEY }
    IF monkeyFlag THEN MonkeyMouse(pt.h,pt.v)                                                   { MONKEY }
                  ELSE MouseLocation(pt.h,pt.v);                                                { MONKEY }
  {$ELSEC }                                                                                     { MONKEY }
    MouseLocation(pt.h,pt.v);                                                                   { MONKEY }
  {$ENDC }                                                                                      { MONKEY }
{$ENDC }                                                                                        { MONKEY }
  IF thePort <> Nil THEN GlobalToLocal(pt);
END;


{$S WMwork }
{-----------------------------------------------------------------------}
FUNCTION ImActive{ : BOOLEAN};
{-----------------------------------------------------------------------}
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  ImActive := (My_ID = activeProcess);
END;


{$S WMinit }
{-----------------------------------------------------------------------}
PROCEDURE InitEvents;
{-----------------------------------------------------------------------}
{ one-time initialize for Unit Events, called from Unit Objects }
VAR i: INTEGER;
    saveHeap: THz;

BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  GetHeap(saveHeap);
  SetHeap(wmHeap);

  eventDebug := FALSE;
  queueLocked  :=  FALSE;
  trapKeys := [];
  keyTrapProc := Pointer(-1);
  trapPrcs := -1;

  { initialize event queue }
  eventHead := Pointer(ORD(NewHandle(SizeOf(EventNode))));
  eventTail := Pointer(ORD(NewHandle(SizeOf(EventNode))));

  WITH eventHead^^ DO
    BEGIN
      nextEvNode := eventTail;
      prevEvNode := Nil;
      event.what := nilEvent;
      event.toProcess := nilProcess;
    END;

  WITH eventTail^^ DO
    BEGIN
      nextEvNode := Nil;
      prevEvNode := eventHead;
      event.what := nilEvent;
      event.toProcess := nilProcess;
    END;

  WITH hourGlass DO
    BEGIN
      StuffHex(@data[0],'7FFF7FFF2002380E2E3A27F223E221C2');
      StuffHex(@data[8],'214221422222249229CA33E67FFF7FFF');
      StuffHex(@mask[0],'7FFF7FFF3FFE3FFE3FFE3FFE3FFE3FFE');
      StuffHex(@mask[8],'3FFE3FFE3FFE3FFE3FFE3FFE7FFF7FFF');
      SetPt(hotSpot,8,8);
    END;

  MouseScaling(TRUE);
  MouseThresh(8);
  BusyImage(8, 8, 16, @hourGlass.data, @hourGlass.mask);
  SetHeap(saveHeap);
  recordFlag := FALSE;
  playFlag := FALSE;


{$IFC wmDebug }
  evntKinds[nilEvent]            := 'NilEvent';
  evntKinds[buttonDown]          := 'ButtonDown';
  evntKinds[buttonUp]            := 'ButtonUp';
  evntKinds[keyDown]             := 'KeyDown';
  evntKinds[folderActivate]      := 'Activate';
  evntKinds[folderDeactivate]    := 'Deactivate';
  evntKinds[folderUpdate]        := 'Update';
  evntKinds[folderMoved]         := 'FldrMoved';
  evntKinds[filerEvent]          := 'FilerEvent';
  evntKinds[abortEvent]          := 'AbortEvent';
  evntKinds[diedEvent]           := 'DiedEvent';
  evntKinds[private1]            := 'Private1';
  evntKinds[private2]            := 'Private2';
  evntKinds[private3]            := 'Private3';
  evntKinds[diskEvent]           := 'DiskEvent';
  evntKinds[catalogEvent]        := 'CatalogEv';
{$ENDC }


{$IFC wmJournal }
  jrnlMode := 0;
  keyStatus := 0;
  waitForKind := badKind;
  waitCount := 0;

  jrnlKinds[badKind]     := ' bad    ';
  jrnlKinds[keyKind]     := ' key    ';
  jrnlKinds[mouseKind]   := ' mouse  ';
  jrnlKinds[timeKind]    := ' time   ';
  jrnlKinds[buttonKind]  := ' button ';
  jrnlKinds[endKind]     := ' end    ';
  jrnlKinds[beginKind]   := ' begin  ';
  jrnlKinds[keyMapKind]  := ' keyMap ';

  { initialize journal opcode compression table }

  opA[0] :=  6;   opB[0] :=  2;   opAB[0] := 20;
  opA[1] := 20;   opB[1] :=  6;   opAB[1] := 21;
  opA[2] := 20;   opB[2] := 64;   opAB[2] := 32;
  opA[3] := 20;   opB[3] := 65;   opAB[3] := 33;
  opA[4] := 21;   opB[4] :=  2;   opAB[4] := 22;
  opA[5] := 21;   opB[5] :=  4;   opAB[5] := 23;
  opA[6] := 21;   opB[6] := 64;   opAB[6] := 24;
  opA[7] := 21;   opB[7] := 65;   opAB[7] := 25;
  opA[8] := 21;   opB[8] := 69;   opAB[8] := 26;
  opA[9] := 21;   opB[9] := 70;   opAB[9] := 27;
  opA[10] := 20;  opB[10] := 70;  opAB[10] := 28;
  opA[11] := 28;  opB[11] :=  6;  opAB[11] := 29;
  opA[12] :=  2;  opB[12] :=  6;  opAB[12] := 30;
  opA[13] := 30;  opB[13] :=  4;  opAB[13] := 31;

  expandSet := [];
  FOR i := 0 TO lastOp DO expandSet := expandSet+[ opAB[i] ];
{$ENDC }

{$IFC wmMonkey}                                                                                 { MONKEY }
  monkeyFlag  := FALSE;                                                                         { MONKEY }
  monkeyWorld := FALSE;                                                                         { MONKEY }
{$ENDC}                                                                                         { MONKEY }

{$IFC wmScrn2File}                                                                 { SCREEN DUMP TO FILE }
  screenFileNum := 0;              { suffix for screen dump file names               SCREEN DUMP TO FILE }
{$ENDC}                                                                            { SCREEN DUMP TO FILE }

END;
{ end of code segment WMInit }


{$S WMwork }
{-----------------------------------------------------------------------}
PROCEDURE LetOthersRun;
{-----------------------------------------------------------------------}
VAR errNum: INTEGER;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  { If there is someone else ready to run, then let him take a turn }
  IF NOT ImActive THEN SetPriority_Process(errNum, My_ID, 120);
  Yield_CPU(errNum,TRUE);
END;


{$S WMothrwk }
{-----------------------------------------------------------------------}
FUNCTION NextEvent{evHandle: EventHandle};
{-----------------------------------------------------------------------}
{ given an EventHandle, return an EventHandle to the next event }
{ Return Nil if none found. }
VAR thisEv: EvNodeHandle;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  thisEv := Pointer(ORD(evHandle));
  thisEv := Pointer(ORD(thisEv^^.nextEvNode));
  IF thisEv = eventTail THEN thisEv := Nil;
  NextEvent := Pointer(ORD(thisEv));
END;


{$S WMwork }
{-----------------------------------------------------------------------}
FUNCTION Now{: LongInt};
{-----------------------------------------------------------------------}
{ current time in 100ths }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  Now := Timer DIV 10;
END;


{$S WMwork }
{-----------------------------------------------------------------------}
FUNCTION  PeekEvent{VAR event: EventRecord): BOOLEAN};
{-----------------------------------------------------------------------}
{ say whether the next event is for me. If so, peek it }
VAR evAvail: Boolean;
    thisEv:  EvNodeHandle;
    savePort: GrafPtr;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  evAvail := EventAvail;
  PeekEvent := evAvail;
  IF evAvail THEN
    BEGIN
      { Copy event from head of the event queue.  }
      thisEv := eventHead^^.nextEvNode;
      event := thisEv^^.event;

      { convert global coordinates to local coordinates }
      IF (event.who <> Nil) AND (event.what <> folderDeactivate) THEN
        BEGIN
          GetPort(savePort);
          SetPort(event.who);
          GlobalToLocal(event.where);
          SetPort(savePort);
        END;
    END;
END;


{$S WMinit }
{-----------------------------------------------------------------------}
PROCEDURE PrintScreen;
{-----------------------------------------------------------------------}
{ dump LISA screen to a dot matrix printer }
LABEL 1;
TYPE Bite      = -128..127;

     { definition of ConfigDev.extWords[1] }
     TPrntrID  = 0..16383;
     TPrExWord = PACKED RECORD
                 printer: BOOLEAN;
                 default: BOOLEAN;
                 printerID: TPrntrID;
                 END;

VAR i,band:     INTEGER;
    srcPtr,dstPtr: ^Bite;
    buffer: PACKED ARRAY[0..363] OF Bite;
    path:   PathName;
    actual: LongInt;
    volumeName, passName: E_Name;
    errNum,refNum: INTEGER;
    devCtrl: DcType;
    nextConfig: LONGINT;
    config: ConfigDev;
    pmRec: PMemRec;
    pExtWord: ^TprExWord;
    mountErr: INTEGER;

{-----------------------------------------------------------------------}
{$S WMinit }
    PROCEDURE PrintChar(ch: CHAR);
    VAR chArray: PACKED ARRAY[0..0] OF CHAR;
    BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
      chArray[0] := ch;
{$IFC wmOS }
      Write_Data(errNum,refNum,ORD(@chArray),1,actual,sequential,0);
{$ELSEC }
      UnitWrite(6,chArray,1,0,12);
{$ENDC }
    END;

{-----------------------------------------------------------------------}
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmOS }
  passName := '';
  Read_PMem (errNum, pmRec);
  IF errNum > 0 THEN EXIT (PrintScreen);
  nextConfig := 0;
  pExtWord := @config.extWords[1];
  REPEAT
    GetNxtConfig (errNum, nextConfig, pmRec, config);
    IF errNum > 0 THEN EXIT (PrintScreen);          { couldn't mount a dot matrix printer }
    IF ((config.nExtWords > 0) AND (pExtWord^.printer) AND (pExtWord^.printerID = 32))
    THEN Mount(mountErr, volumeName, passName, config.devName )
    ELSE mountErr := 1;
    UNTIL mountErr <= 0;

  path := CONCAT('-',config.devName,'-X');
  OPEN(errNum,path,refNum,[dwrite,dread,private]);
  IF errNum > 0 THEN
    BEGIN
      Unmount(mountErr,config.devName);
      EXIT(PrintScreen);
    END;

  WITH devCtrl DO
    BEGIN
      dcVersion := 2;
      dcCode := dvAutoLF;
      dcData[0] := 0;           { disable auto line-feed }
      Device_Control(errNum, path, devCtrl);
      IF config.driverID = 32 THEN         { a serial driver }
        BEGIN
          dcCode := dvBaud;
          dcData[0] := 9600;
          Device_Control(errNum, path, devCtrl);

          dcCode := dvOUtDTR;
          Device_Control(errNum, path, devCtrl);

          dcCode := dvParity;
          dcData[0] := 0;       { 8 bit, no parity }
          Device_Control(errNum, path, devCtrl);

          dcCode := 12;         { Time out }
          dcData[0] := 60;
          Device_Control(errNum, path, devCtrl);

          dcCode := dvDiscon;
          dcData[0] := 0;
          dcData[1] := -128;
          Device_Control(errNum, path, devCtrl);
        END;
    END;
{$ENDC }

  PrintChar(CHR(27));           { 16/144 inch per linefeed }
  PrintChar('T');
  PrintChar('1');
  PrintChar('6');

  FOR band := 89 DOWNTO 0 DO
    BEGIN
      BusyDelay(10000);     { keep the normal cursor }

      PrintChar(CHR(27));   { elite = 96 dots per inch }
      PrintChar('E');

      PrintChar(CHR(27));   { unidirectional for less stitching }
      PrintChar('>');

      PrintChar(CHR(14));   { double all the bits }

      PrintChar(CHR(27));   { graphics mode, 364 bytes }
      PrintChar('G');
      PrintChar('0');
      PrintChar('3');
      PrintChar('6');
      PrintChar('4');

      srcPtr := POINTER(ScreenAddr+band);
      dstPtr := @buffer;
      FOR i := 1 TO 364 DO     { peek 364 bytes from the screen }
        BEGIN
          dstPtr^ := srcPtr^;
          srcPtr := Pointer(ORD(srcPtr)+90);
          dstPtr := Pointer(ORD(dstPtr)+1);
        END;

{$IFC wmOS }
      Write_Data(errNum,refNum,ORD(@buffer),364,actual,sequential,0);
{$ELSEC }
      UnitWrite(6,buffer,364,0,12);
{$ENDC }

      PrintChar(CHR(10));       { linefeed }
      IF Abort THEN GOTO 1;
    END;

1: PrintChar(CHR(15));           { clear elongated }
   PrintChar(CHR(27));           { return to 1/6 inch linefeeds }
   PrintChar('A');
   PrintChar(CHR(12));           { formfeed }

{$IFC wmOS }
  Close_Object(errNum,refNum);
  Unmount(mountErr,config.devName);
{$ENDC }
END;


{$S WMact }
{-----------------------------------------------------------------------}
PROCEDURE PushEvent{VAR event: EventRecord};
{-----------------------------------------------------------------------}

VAR thisEv,nextEv: EvNodeHandle;
    title: Str255;
    saveHeap: THz;

BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  GetHeap(saveHeap);
  SetHeap(wmHeap);

{$IFC wmDebug }
  IF eventDebug THEN
    BEGIN
      WRITE ('Push wm event: ');
      IF event.what > private3
      THEN WRITE('Event number ',event.what:1)
      ELSE WRITE(evntKinds[event.what]);
      GetFldrTitle(event.who,title);
      WRITE(' to ',title);
      IF event.who = activeFolder THEN WRITE(' (active)');
      WRITELN(', proc ',event.toProcess:1,' from ',event.fromProcess:1);
    END;
{$ENDC }

  {  Insert event at the head of the event queue.   }
  thisEv := Pointer(ORD(NewHandle(SizeOf(eventNode))));
  nextEv := eventHead^^.nextEvNode;

  thisEv^^.event := event;
  thisEv^^.prevEvNode := eventHead;
  eventHead^^.nextEvNode := thisEv;
  thisEv^^.nextEvNode := nextEv;
  nextEv^^.prevEvNode := thisEv;

  SetHeap(saveHeap);
  WakeUpHead;
END;


{$S WMwork }
{-----------------------------------------------------------------------}
PROCEDURE SendEvent{VAR event: EventRecord; toPrcs: ProcessId};
{-----------------------------------------------------------------------}

{ put one EventRecord into the event queue }
{ event.where should be in global coords }

VAR thisEv,prevEv: EvNodeHandle;
    title: Str255;
    saveHeap: THz;

BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  GetHeap(saveHeap);
  SetHeap(wmHeap);

{$IFC wmDebug }
  IF eventDebug THEN
    BEGIN
      WRITE ('Send wm event: ');
      IF event.what > private3
      THEN WRITE('Event number ',event.what:1)
      ELSE WRITE(evntKind[event.what]);
      GetFldrTitle(event.who,title);
      WRITE(' to ',title);
      IF event.who = activeFolder THEN WRITE(' (active)');
      WRITELN(', proc ',toPrcs:1,' from ',event.fromProcess:1);
    END;
{$ENDC }

  {  Add event to the tail of the event queue.   }
  thisEv := Pointer(ORD(NewHandle(SizeOf(eventNode))));
  prevEv := eventTail^^.prevEvNode;

  thisEv^^.event := event;
  thisEv^^.event.toProcess := toPrcs;
  thisEv^^.nextEvNode := eventTail;

  eventTail^^.prevEvNode := thisEv;
  thisEv^^.prevEvNode := prevEv;
  prevEv^^.nextEvNode := thisEv;

  SetHeap(saveHeap);
END;


{$S WMwork }
{-----------------------------------------------------------------------}
FUNCTION StillDown{: BOOLEAN};
{-----------------------------------------------------------------------}
{ TRUE only if button currently down and no button events in queue. }
VAR thisEv: EvNodeHandle;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF ImActive THEN BusyDelay(cursorDelay);
  StillDown := FALSE;
{$IFC wmMonkey }                                                                                { MONKEY }
  IF MonkeyFlag THEN                                                                            { MONKEY }
        BEGIN                                                                                   { MONKEY }
        IF MonkeyStillDown THEN BEGIN                                                           { MONKEY }
           CheckEvents(FALSE);  { empty interrupt buffer, no updates }                          { MONKEY }
           { scan thru event queue for any button transitions }                                 { MONKEY }
           thisEv := eventHead^^.nextEvNode;                                                    { MONKEY }
           WHILE thisEv <> eventTail DO WITH thisEv^^ DO                                        { MONKEY }
                BEGIN                                                                           { MONKEY }
                IF event.keyCap = buttonCode THEN EXIT(StillDown) { false };                    { MONKEY }
                thisEv := nextEvNode;                                                           { MONKEY }
                END;                                                                            { MONKEY }
           StillDown := TRUE;                                                                   { MONKEY }
           END;                                                                                 { MONKEY }
        END                                                                                     { MONKEY }
  ELSE                                                                                          { MONKEY }
{$ENDC }                                                                                        { MONKEY }
  IF Button THEN
    BEGIN
      CheckEvents(FALSE);  { empty interrupt buffer, no updates }
      { scan thru event queue for any button transitions }
      thisEv := eventHead^^.nextEvNode;
      WHILE thisEv <> eventTail DO WITH thisEv^^ DO
        BEGIN
          IF event.keyCap = buttonCode THEN EXIT(StillDown) { false };
          thisEv := nextEvNode;
        END;
      StillDown := TRUE;
    END;
END;


{$S WMwork }
{-----------------------------------------------------------------------}
FUNCTION Time{: LongInt};
{-----------------------------------------------------------------------}
{ inquire time in 1/100 ths of a second since boot }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmJournal }
  oldTime := timeState;
  IF playFlag THEN ReadJournal(timeKind) ELSE timeState := Now;
  IF recordFlag THEN WriteJournal(timeKind);
  Time := timeState;
{$ELSEC }
  Time := Now;
{$ENDC }
END;


{$S WMact }
{-----------------------------------------------------------------------}
PROCEDURE WakeUpHead;
{-----------------------------------------------------------------------}
{ make sure the owner of the queue head is alive }
{$IFC wmOS }
LABEL 1;
{$ENDC }
VAR errNum:     INTEGER;
    me,process: ProcessID;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  {$IFC wmOS }
  me := My_ID;  { do it now in case it triggers a process switch }

1: IF eventHead^^.nextEvNode = eventTail THEN EXIT(WakeUpHead);
  process := eventHead^^.nextEvNode^^.event.toProcess;
  IF process <> me THEN
    BEGIN
      IF process = nilProcess THEN
        BEGIN
          DelEvNode(eventHead^^.nextEvNode);
          GOTO 1;
        END;

      Activate_Process(errNum,process,FALSE);
      IF errNum > 0 THEN
        BEGIN
          {$IFC wmDebug }
          WRITELN('WakeUpHead called Activate_Process, err= ',errNum);
          {$ENDC }
          DelEvNode(eventHead^^.nextEvNode);
          IF process <> filerProcess THEN HeDied(process);
          GOTO 1;
        END;
    END;
 {$ENDC }
END;


{======================== for dumping Lisa screens to file on -LOWER device ===================================}

{$IFC wmScrn2File }                                                                     { SCREEN DUMP TO FILE }

{$S WMinit }
{--------------------------------------------------------------------------------------   SCREEN DUMP TO FILE }
PROCEDURE FileScreen;
{--------------------------------------------------------------------------------------   SCREEN DUMP TO FILE }
CONST   screenSize = 64;        { 64 blocks holds one screenful }
TYPE    TByte   = -128..127;                                                            { SCREEN DUMP TO FILE }
        TByteArray = Array[0..16380] of TByte;
        Tstring2 = string[2];                                                           { SCREEN DUMP TO FILE }
VAR     path           :      PathName;
        actual         :      longint;                                                  { SCREEN DUMP TO FILE }
        errNum, refNum :      integer;
        suffixBuffer   :      ARRAY[0..2] of TByte;                                     { SCREEN DUMP TO FILE }
        suffixPtr      :      ^Tstring2;
        screenPtr      :      ^TByte;                                                   { SCREEN DUMP TO FILE }
        buffer         :      TByteArray;
        bufPtr         :      ^TByteArray;                                              { SCREEN DUMP TO FILE }
        try            :      integer;
        fileInfo       :      Fs_Info;                                                  { SCREEN DUMP TO FILE }

        PROCEDURE ErrorBeep;                                                            { SCREEN DUMP TO FILE }
        BEGIN
        Beep(4000, 1500);                                                               { SCREEN DUMP TO FILE }
        EXIT(FileScreen);
        END;                                                                            { SCREEN DUMP TO FILE }

BEGIN                                                                                   { SCREEN DUMP TO FILE }
screenFileNum := screenFileNum + 1;
suffixBuffer[0] := 2;                                                                   { SCREEN DUMP TO FILE }
suffixBuffer[1] := (screenFileNum DIV 10)+$30;
suffixBuffer[2] := (screenFileNum MOD 10)+$30;                                          { SCREEN DUMP TO FILE }
suffixPtr := @suffixBuffer;
path := CONCAT('-LOWER-ScreenDump',suffixPtr^);                                         { SCREEN DUMP TO FILE }
Make_File(errNum, path, 0);
if (errNum > 0) and (errNum <> 890) then ErrorBeep;                                     { SCREEN DUMP TO FILE }
Open(errNum, path, refNum, [Dwrite]);
if errNum > 0 then ErrorBeep;                                                           { SCREEN DUMP TO FILE }

Info(errNum, refNum, fileInfo);                                                         { SCREEN DUMP TO FILE }
if errNum > 0 then ErrorBeep;
if screenSize > fileInfo.pSize then                                                     { SCREEN DUMP TO FILE }
     begin
     Allocate(errNum, refNum, FALSE, screenSize - fileInfo.pSize, actual);              { SCREEN DUMP TO FILE }
     if errNum > 0 then begin
                        Kill_Object(errNum, path);                                      { SCREEN DUMP TO FILE }
                        ErrorBeep;
                        end;                                                            { SCREEN DUMP TO FILE }
     end;

for try := 0 to 1 do                                                                    { SCREEN DUMP TO FILE }
     begin
     BusyDelay(10000);                  { keep normal cursor }
     screenPtr := POINTER(ScreenAddr+try*16380);                                        { SCREEN DUMP TO FILE }
     bufPtr := @buffer;
     MoveLeft(ScreenPtr^, buffer, 16380);                                               { SCREEN DUMP TO FILE }

     Write_Data(errNum, refNum, ORD(@buffer), 16380, actual, sequential, 0);            { SCREEN DUMP TO FILE }
     if errNum > 0 then ErrorBeep;
     end;                                                                               { SCREEN DUMP TO FILE }

Close_Object(errNum, refNum);
END;                                                                                    { SCREEN DUMP TO FILE }

{$ENDC }                                                                                { SCREEN DUMP TO FILE }

{==============================================================================================================}


{----------  THE REST OF THIS UNIT IS JOURNAL STUFF ------------}

{$IFC wmJournal }   { all journal stuff is optional }


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE ReadByte(VAR word: INTEGER);
{-----------------------------------------------------------------------}
{ returns unsigned 0..255 }
VAR errNum: INTEGER;
    actual: LongInt;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  word := 0;
  Read_Data(errNum,playFile,ORD(@word)+1,1,actual,Sequential,0);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE ReadWord(VAR word: INTEGER);
{-----------------------------------------------------------------------}
VAR errNum: INTEGER;
    actual: LongInt;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  Read_Data(errNum,playFile,ORD(@word),2,actual,Sequential,0);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE ReadLong(VAR long: LongInt);
{-----------------------------------------------------------------------}
VAR errNum: INTEGER;
    actual: LongInt;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  Read_Data(errNum,playFile,ORD(@long),4,actual,Sequential,0);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE ReadKey(VAR key: KeyEvent);
{-----------------------------------------------------------------------}
VAR errNum: INTEGER;
    actual: LongInt;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  Read_Data(errNum,playFile,ORD(@key),SizeOf(key),actual,Sequential,0);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE ReadMap(VAR map: KeySet);
{-----------------------------------------------------------------------}
VAR errNum: INTEGER;
    actual: LongInt;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  Read_Data(errNum,playFile,ORD(@map),SizeOf(map),actual,Sequential,0);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE WriteData(dataPtr: Ptr; byteCount: LongInt);
{-----------------------------------------------------------------------}
VAR errNum: INTEGER;
    actual: LongInt;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  Write_Data(errNum,recordFile,ORD(dataPtr),byteCount,actual,sequential,0);
  IF errNum <> 0 THEN
    BEGIN
      WRITELN('Journal file full after ',recordCount:1,' journal records.');
      recordFlag := FALSE;
      Close_Object(errNum,recordFile);
    END;
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE WriteByte(word: INTEGER);
{-----------------------------------------------------------------------}
{ writes unsigned 0..255 }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  WriteData(Pointer(ORD(@word)+1),1);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE WriteWord(word: INTEGER);
{-----------------------------------------------------------------------}
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  WriteData(@word,2);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE WriteLong(long: LongInt);
{-----------------------------------------------------------------------}
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  WriteData(@long,4);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
FUNCTION WhatKind(opCode: INTEGER): JournalKind;
{-----------------------------------------------------------------------}
{ given an 8 bit journal opcode, return what kind of entry it is }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
(***
 op code is packed in 8 bits as follows:

 deci  name        binary

    2  keyNone:    00000010
    3  keyAvail:   00000011 + keyState + keyStatus
    4  btnSame:    00000100
    5  btnChange:  00000101
    6  mouseSame:  00000110
  192+ mouseSmall: 11vvvhhh                   { 3 bit dh and dv -4..+3 }
  128+ mouseMed:   10vvvvvv + dhByte          { 6 bit dv -32..31, dh -128..127 }
    7  mouseBig:   00000111 + vWord + hWord   { note: v,h not dv,dh }
   64+ timeSmall:  010xxxxx                   { 5 bit dt 0..31 }
    8  timeByte:   00001000 + dtByte          { dt 32..255 }
    9  timeWord:   00001001 + dtWord          { dt 256..32767 }
   10  timeLong:   00001010 + tLong           { note: time, not dt }
   11  startJrnl   00001011
   12  stopJrnl    00001100
   96+ runSmall:   011xxxxx                   { 5 bit run length 2..31 }
   13  runByte:    00001101 + lenByte + dataByte  { 8 bit run length 0..255 }
   14  runLong:    00001110 + lenLong + dataByte  { 32 bit run length }
   15  keyMapChng: 00010001 + keyMap
   16  keyMapSame: 00010010

***)

  CASE opCode OF
    2,3:    WhatKind := keyKind;
    4,5:    WhatKind := buttonKind;
    6,7:    WhatKind := mouseKind;
    8,9,10: WhatKind := timeKind;
    11:     WhatKind := beginKind;
    12:     WhatKind := endKind;
    13,14:  WhatKind := runKind;
    15,16:  WhatKind := keyMapKind;
    OTHERWISE
       BEGIN
         IF opCode >= 128 THEN WhatKind := mouseKind
         ELSE IF opCode >= 96 THEN WhatKind := runKind
         ELSE IF opCode >= 64 THEN WhatKind := timeKind
         ELSE WhatKind := badKind;
       END;
  END; { case opCode }

END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE CheckPlay(thisKind,opCode: INTEGER);
{-----------------------------------------------------------------------}
{ check for user input to control playback }
(***

  COMMANDS ARE:

  <space>      = stop,single step
  10<space>    = take 10 steps
  <return>     = go
  1000<return> = go till playCount=1000
  B = go till button changes
  K = go till next key typed
  M = go till mouse moves
  T = go till time changes
  D = toggle eventDebug
  N = toggle numbers
  R = stop recording
  P = stop playback

***)
VAR number:  LongInt;
    ascii:   CHAR;


    FUNCTION GetChar(VAR ch: CHAR): BOOLEAN;
    VAR state:   KeyEvent;
        status:  INTEGER;
    BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
      status := 0;
      IF KeybdEvent(FALSE,FALSE,state) THEN status := 1;
      IF status = 1 THEN
        BEGIN
          ch := state.ascii;
          WRITE(ch);
        END;
      GetChar := (status <> 0);
    END;


BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF ODD(jrnlMode DIV 4) THEN EXIT(CheckPlay);

  IF (playCount >= endCount)
  OR ( (thisKind=stopKind) AND NOT (opCode IN [2,4,6,64]) ) THEN
    BEGIN
      WRITE('Break at playCount =',playCount,' ');
      REPEAT UNTIL GetChar(ascii);
    END
  ELSE IF NOT GetChar(ascii) THEN EXIT(CheckPlay);

  number := 0;
  WHILE ascii in ['0'..'9'] DO
    BEGIN
      number := number*10 + ORD(ascii) - ORD('0');
      REPEAT UNTIL GetChar(ascii);
    END;
  IF number <> 0 THEN stopKind := badKind;  { stop on count instead of kind }

  CASE ascii OF

    'B','b': stopKind := buttonKind;
    'K','k': stopKind := keyKind;
    'M','m': stopKind := mouseKind;
    'T','t': stopKind := timeKind;
    'D','d': eventDebug := NOT eventDebug;
    'N','n': printNumbers := NOT printNumbers;
    'R','r': StopRecording;
    'P','p': StopPlayback;

    ' ': BEGIN
           IF number=0
           THEN endCount := playCount+1         { single step }
           ELSE endCount := playCount+number;   { play n records }
         END;

    OTHERWISE IF ascii = CHR(13) THEN
        BEGIN
          IF number<>0
          THEN endCount := number      { play till record # n }
          ELSE  { play till break point or space }
            IF endCount <= playCount THEN endCount := 1000000;
        END;

  END;  { case }

  WRITELN;
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
FUNCTION GetOp: INTEGER;
{-----------------------------------------------------------------------}
{ get the next journal opcode, expanding runs and groups }
VAR op,a,b,i,word: INTEGER;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF opBufIndex >= 0 THEN   { just get the op from the expansion buffer }
    BEGIN
      GetOp := opBuf[opBufIndex];
      opBufIndex := opBufIndex-1;
      EXIT(getOp);
    END;

  IF playRunCount = 0 THEN  { time to read next byte from disk }
    BEGIN
      ReadByte(op);
      IF WhatKind(op)=runKind THEN
        BEGIN
          CASE op OF
            13: BEGIN ReadByte(word);  playRunCount := word;  END;
            14: ReadLong(playRunCount);
            OTHERWISE playRunCount := op-96;
          END;  { case }
          ReadByte(playRunData);
        END;
    END;

  IF playRunCount > 0 THEN
    BEGIN
      op := playRunData;
      playRunCount := playRunCount-1;
    END;

  WHILE op IN expandSet DO
    BEGIN
      opBufIndex := opBufIndex+1;
      i := 0;
      WHILE op <> opAB[i] DO i := i+1;
      opBuf[opBufIndex] := opB[i];
      op := opA[i];
    END;

  GetOp := op;
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE WaitTill(when: LongInt);
{-----------------------------------------------------------------------}
{ Delay for real-time journal playback. }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  WHILE Now < when + deltaTime DO BusyDelay(cursorDelay);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE ReadJournal(* kind: JournalKind *);
{-----------------------------------------------------------------------}
VAR dh,dv,word,opCode: INTEGER;
    thisKind:   JournalKind;
    saveDebug:  BOOLEAN;

BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF NOT playFlag THEN EXIT(ReadJournal);
  IF waitForKind <> badKind THEN
    BEGIN
      { the journal playback file is locked in inexact play }
      waitCount := waitCount+1;
      IF (kind = waitForKind) OR (waitCount > 500)
        THEN BEGIN
          waitForKind := badKind;   { we got caught up or gave up }
          waitCount := 0;
         END;
      EXIT(ReadJournal);
    END;

  playCount := playCount+1;
  IF eventDebug THEN WRITE(playCount,':',jrnlKinds[kind])
  ELSE IF printNumbers THEN WRITELN(playCount);

  opCode := GetOp;
  IF eventDebug THEN WRITE('(',opCode:3,') ' );
  thisKind := WhatKind(opCode);

  IF kind <> thisKind THEN
    BEGIN
      IF ODD(jrnlMode DIV 2) THEN   { approximate play }
        BEGIN
          waitCount := 0;
          IF opCode = 3 {keyAvail}  THEN waitForKind := keyKind;
          IF opCode = 5 {btnChange} THEN waitForKind := buttonKind;
        END

      ELSE   { exact play, we're out of sync }
        BEGIN
          WRITELN;
          WRITELN('---> ReadJournal expected',jrnlKinds[kind],
                  'but found',jrnlKinds[thisKind]);
          saveDebug := eventDebug;
          eventDebug := TRUE;  { make sure StopPlayback prints message }
          StopPlayback;
          eventDebug := saveDebug;
          EXIT(ReadJournal);
        END;
    END;


  CASE thisKind OF

    beginKind:
      BEGIN
        ReadLong(timeState);
        ReadWord(mouseState.v);
        ReadWord(mouseState.h);
        CursorLocation(mouseState.h,mouseState.v);
        ReadWord(word);
        buttonState := ODD(word);
        ReadMap(keyMapState);
        IF eventDebug THEN
          BEGIN
            WRITELN;
            WRITELN('Start Time: ',timeState);
            WRITELN('Start Mouse: ',mouseState.h,mouseState.v);
            WRITELN('Start Button: ',buttonState);
          END;
      END;

    endKind:
      BEGIN
        StopPlayback;
        EXIT(ReadJournal);
      END;

    keyKind:
      BEGIN
        IF ODD(opCode) THEN
          BEGIN
            ReadKey(keyState);
            ReadWord(keyStatus);
            IF ODD(jrnlMode DIV 4) THEN WaitTill(keyState.time DIV 10);
          END
        ELSE keyStatus := 0;

        IF eventDebug THEN
          BEGIN
            IF keyStatus <> 0 THEN WRITE('key=',keyState.key:3);
            WRITELN;
          END;
      END;

    mouseKind:
      BEGIN
        IF opCode = 6 THEN                 { mouse same }
          BEGIN
          END

        ELSE IF opCode >= 192 THEN         { 3 bit dv,dh }
          BEGIN
            dh := BitAnd(opCode,7)-4;
            dv := ((opCode-192) DIV 8)-4;
            mouseState.h := mouseState.h+dh;
            mouseState.v := mouseState.v+dv;
          END

        ELSE IF opCode >= 128 THEN         { 6 bit dv, 8 bit dh }
          BEGIN
            ReadByte(word);
            dh := word-128;
            dv := opCode-128-32;
            mouseState.h := mouseState.h+dh;
            mouseState.v := mouseState.v+dv;
          END

        ELSE                               { 16 bit v,h }
          BEGIN
            ReadWord(mouseState.v);
            ReadWord(mouseState.h);
          END;

        CursorLocation(mouseState.h,mouseState.v);
        IF eventDebug THEN WRITELN(' ',mouseState.h,',',mouseState.v);
      END;

    timeKind:
      BEGIN
        CASE opCode OF
          8: BEGIN
               ReadByte(word);                          { 8 bit dt 0..255 }
               timeState := timeState+word;
             END;
          9: BEGIN
               ReadWord(word);
               timeState := timeState+word;             { 16 bit dt }
             END;
          10: ReadLong(timeState);                      { 32 bit time }
          OTHERWISE timeState := timeState+opCode-64;   { 5 bit dt 0..31 }
        END; { case }

        IF ODD(jrnlMode DIV 4) THEN WaitTill(timeState);
        IF eventDebug THEN WRITELN(timeState);
      END;

    buttonKind:
      BEGIN
        IF ODD(opCode) THEN buttonState := NOT buttonState;
        IF eventDebug THEN WRITELN(buttonState);
      END;

    keyMapKind:
      BEGIN
        IF ODD(opCode) THEN ReadMap(keyMapState);
        IF eventDebug THEN
          IF ODD(opCode) THEN WRITELN('changed')
                         ELSE WRITELN('same');
      END;

  END;   { case thisKind }

  { check for user input to control playback }
  CheckPlay(thisKind,opCode);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE FlushRunData;
{-----------------------------------------------------------------------}
{ flush the run-length recording buffer }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF recRunCount=0 THEN EXIT(FlushRunData);  { nothing to flush }

  IF recRunCount > 255 THEN
    BEGIN
      WriteByte(14);                { long run > 255 }
      WriteLong(recRunCount);
    END
  ELSE IF recRunCount > 31 THEN
    BEGIN
      WriteByte(13);                { byte run 32..255 }
      WriteByte(recRunCount);
    END
  ELSE IF recRunCount > 1 THEN
    WriteByte(96 + recRunCount);    { short Run 2..31 }

  WriteByte(recRunData);
  recRunCount := 0;
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE PutRunData(data: INTEGER);
{-----------------------------------------------------------------------}
{ put a byte to the disk, buffered by run-coding }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF data = recRunData
  THEN recRunCount := recRunCount+1    { just bump run length counter }
  ELSE
    BEGIN
      FlushRunData;
      recRunData := data;
      recRunCount := 1;
    END;
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE FlushOp(newOp: INTEGER);
{-----------------------------------------------------------------------}
{ called if new op not compressible }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF oldOp <> 0 THEN PutRunData(oldOp);
  FlushRunData;
  oldOp := 0;
  WriteByte(newOp);
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE PutOp(newOp: INTEGER);
{-----------------------------------------------------------------------}
VAR i: INTEGER;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF oldOp=0 THEN oldOp := newOp
  ELSE
    BEGIN
      FOR i := 0 to lastOp DO     { scan compression table }
        IF oldOp=opA[i] THEN
          IF newOp=opB[i] THEN
            BEGIN
              oldOp := opAB[i];   { just compress oldOp,newOp into oldOp2 }
              EXIT(PutOp);
            END;
        PutRunData(oldOp);
        oldOp := newOp;
    END;
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE WriteJournal(* kind: JournalKind *);
{-----------------------------------------------------------------------}
VAR dh,dv: INTEGER;
    dt: LongInt;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
  IF eventDebug THEN WRITELN('WriteJournal: ',jrnlKinds[kind]);
  recordCount := recordCount+1;

  CASE kind OF

    beginKind:
      BEGIN
        FlushOp(11);
        WriteLong(timeState);
        WriteWord(mouseState.v);
        WriteWord(mouseState.h);
        WriteWord(ORD(buttonState));
        WriteData(@keyMapState,SizeOf(keyMapState));
      END;

    endKind:
      BEGIN
        FlushOp(12);
      END;

    keyKind:
      BEGIN
        IF keyStatus = 0 THEN PutOp(2)
        ELSE
          BEGIN
            FlushOp(3);
            WriteData(@keyState,SizeOf(keyState));
            WriteWord(keyStatus);
          END;
      END;

    mouseKind:
      BEGIN
        dh := mouseState.h-oldMouse.h;
        dv := mouseState.v-oldMouse.v;

        IF (dh=0) AND (dv=0) THEN PutOp(6)  { mouse same }

        ELSE IF (dh>=-4) AND (dh<=3) AND (dv>=-4) AND (dv<=3) THEN
          FlushOp(192 + (dv+4)*8 + dh+4)    { 3 bit dv,dh }

        ELSE IF (dh>=-128) AND (dh<=127) AND (dv>=-32) AND (dv<=31) THEN
          BEGIN
            FlushOp(128+dv+32);      { 6 bit dv, 8 bit dh }
            WriteByte(dh+128);
          END

        ELSE
          BEGIN
            FlushOp(7);               { 16 bit h,v }
            WriteWord(mouseState.v);
            WriteWord(mouseState.h);
          END;
      END;

    timeKind:
      BEGIN
        dt := timeState-oldTime;

        IF dt < 0 THEN
          BEGIN
            FlushOp(10);                    { 32 bit time }
            WriteLong(timeState);
          END

        ELSE IF dt <= 31 THEN PutOp(64+dt)  { 6 bit dt }

        ELSE IF dt <= 255 THEN
          BEGIN
            FlushOp(8);                     { 8 bit dt }
            WriteByte(dt);
          END

        ELSE IF dt <= 32767 THEN
          BEGIN
            FlushOp(9);
            WriteWord(dt);                  { 16 bit dt }
          END

        ELSE
          BEGIN
            FlushOp(10);                    { 32 bit time }
            WriteLong(timeState);
          END;
      END;

    buttonKind:
      BEGIN
        IF buttonState <> oldButton
        THEN FlushOp(5)
        ELSE PutOp(4);
      END;

    keyMapKind:
      BEGIN
        IF keyMapState = oldMapState THEN PutOp(16)
        ELSE
          BEGIN
            FlushOp(15);
            WriteData(@keyMapState,SizeOf(keyMapState));
          END;
      END;

  END;   { case kind }
END;

{$ENDC }    { end if wmJournal }


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE StartRecording(* fileName: PathName; journalMode: INTEGER *);
{-----------------------------------------------------------------------}
CONST fileExists = 890;
VAR errNum:  INTEGER;
    sync:    LongInt;
    typeConvert: ^KeyCapSet;
    thisEv,nextEv: EventHandle;
    timeZero: LongInt;

BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmJournal }
  timeZero := Now;

  IF eventDebug THEN WRITELN('Start Recording');
  Make_File(errNum,fileName,0);
  IF (errNum > 0) AND (errNum <> fileExists) THEN
    BEGIN
      WRITELN('Error making journal file =',errNum);
      EXIT(StartRecording);
    END;

{$IFC wmOS }
  Open(errNum,fileName,recordFile,[DWrite,private,global_refNum]);
{$ELSEC }
  Open(errNum,fileName,recordFile,[DWrite,private]);
{$ENDC }
  IF errNum > 0 THEN
    BEGIN
      WRITELN('Error opening journal file =',errNum);
      EXIT(StartRecording);
    END;

  IF NOT playFlag THEN
    BEGIN
      MouseLocation(mouseState.h,mouseState.v);
      timeState := timeZero;
      buttonState := KeyIsDown(buttonCode);
      typeConvert := @keyMapState;
      KeyMap(typeConvert^);

      { drain the interrupt buffer and big buffer }
      WHILE KeybdEvent(FALSE,FALSE,keyState) DO;
      thisEv := FirstEvent;
      WHILE thisEv <> Nil DO
        BEGIN
          nextEv := NextEvent(thisEv);
          DeleteEvent(thisEv);
          thisEv := nextEv;
        END;

      sync := Now;
      REPEAT UNTIL Now <> sync;
      jrnlMode := journalMode;
    END;

  recordFlag := TRUE;
  recordCount := 0;
  recRunCount := 0;
  recRunData := 0;
  oldOp := 0;
  WriteJournal(beginKind);
{$ENDC }    { end if wmJournal }
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE StopRecording;
{-----------------------------------------------------------------------}
VAR i,errNum: INTEGER;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmJournal }
  IF NOT recordFlag THEN EXIT(StopRecording);
  IF eventDebug THEN
    BEGIN
      WRITELN;
      WRITELN('Stop Recording after ',recordCount,' journal records.');
    END;
  WriteJournal(endKind);
  recordFlag := FALSE;
  Close_Object(errNum,recordFile);
  IF errNum <> 0 THEN
    BEGIN
      WRITELN('Error closing record file =',errnum);
    END;
{$ENDC }    { end if wmJournal }
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE StartPlayback(* fileName: PathName; journalMode: INTEGER *);
{-----------------------------------------------------------------------}
CONST alreadyOpen = 873;
VAR errNum: INTEGER;
    newData: BOOLEAN;
    sync:    LongInt;
    thisEv,nextEv: EventHandle;
    timeZero: LongInt;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmJournal }
  timeZero := Now;

  IF eventDebug THEN WRITELN('Start Playback');
{$IFC wmOS }
  Open(errNum,fileName,playFile,[DRead,private,global_refNum]);
{$ELSEC }
  Open(errNum,fileName,playFile,[DRead,private]);
{$ENDC }
  IF (errNum > 0) AND (errNum <> alreadyOpen) THEN
    BEGIN
      WRITELN('Error opening play file =',errNum);
      EXIT(StartPlayBack);
    END;

  { drain the interrupt buffer and big buffer }
  WHILE KeybdEvent(FALSE,FALSE,keyState) DO;
  thisEv := FirstEvent;
  WHILE thisEv <> Nil DO
    BEGIN
      nextEv := NextEvent(thisEv);
      DeleteEvent(thisEv);
      thisEv := nextEv;
    END;

  sync := Now;
  REPEAT UNTIL Now <> sync;
  CursorTracking(FALSE);
  playFlag := TRUE;
  opBufIndex := -1;
  jrnlMode := journalMode;
  playCount := 0;
  playRunCount := 0;
  playRunData := 0;
  printNumbers := FALSE;
  endCount := 1000000;
  stopKind := badKind;
  waitForKind := badKind;
  waitCount := 0;
  ReadJournal(beginKind);
  deltaTime := timeZero - timeState;
{$ENDC }    { end if wmJournal }
END;


{$S WMJrnl }
{-----------------------------------------------------------------------}
PROCEDURE StopPlayback;
{-----------------------------------------------------------------------}
VAR errNum: INTEGER;
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
{$IFC wmJournal }
  IF NOT playFlag THEN EXIT(StopPlayback);
  CursorTracking(TRUE);
  IF eventDebug THEN
    BEGIN
      WRITELN;
      WRITELN('Stop Playback after ',playCount,' journal records.');
    END;
  playFlag := FALSE;
  Close_Object(errNum,playFile);
  IF errNum <> 0 THEN
    BEGIN
      WRITELN('Error closing play file =',errnum);
    END;
{$ENDC }    { end if wmJournal }
END;

{ end of code segment WMJrnl }


{****************************  Monkey Routines  ******************************}                 { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
{$IFC wmMonkey }                                                                                { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
FUNCTION MonkeyBool;  {(freq: INTEGER):BOOLEAN}                                                 { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
{ MonkeyBool returns TRUE freq percent. }                                                       { MONKEY }
BEGIN                                                                                           { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
MonkeyBool := ((ABS(Random) MOD 100) < freq);                                                   { MONKEY }
END;                                                                                            { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
FUNCTION MonkeyButton;  {:BOOLEAN}                                                              { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
{ MonkeyButton returns TRUE during drag events. Called from Button.     }                       { MONKEY }
{ This satisfies calls made to Button from WM Unit Folders.             }                       { MONKEY }
BEGIN                                                                                           { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
IF mnkyDrag THEN IF MonkeyBool(50) THEN MonkeyButton := TRUE                                    { MONKEY }
                                   ELSE BEGIN                                                   { MONKEY }
                                        MonkeyButton := FALSE;                                  { MONKEY }
                                        buttonsUp := TRUE;                                      { MONKEY }
                                        END                                                     { MONKEY }
            ELSE MonkeyButton := FALSE;                                                         { MONKEY }
END;                                                                                            { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
FUNCTION MonkeyDo;    {(repOK: BOOLEAN; VAR mnkyVent: KeyEvent): BOOLEAN}                       { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
  { similar to HWInt function KeyBdEvent, MonkeyDo returns a random     }                       { MONKEY }
  { keyboard event. Called from CheckEvents.                            }                       { MONKEY }
                                                                                                { MONKEY }                                                                                                { MONKEY }
BEGIN                                                                                           { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
IF buttonsUp THEN {Unit Folders just polled the button, and Monkey said it was up}              { MONKEY }
                  {This is a special case for drags from DragRect, HitFolder, et al}            { MONKEY }
                   BEGIN                                                                        { MONKEY }
                   MonkeyDo   := TRUE;                                                          { MONKEY }
                   buttonsUp  := FALSE;                                                         { MONKEY }
                   mnkyDrag   := FALSE;                                                         { MONKEY }
                   didDrag    := FALSE;                                                         { MONKEY }
                   mnkyClicks := 0;                                                             { MONKEY }
                   mnkyCount  := mnkyCount + 1;                                                 { MONKEY }
                   MonkeyRepeat(mnkyVent);                                                      { MONKEY }
                   EXIT(MonkeyDo);                                                              { MONKEY }
                   END;                                                                         { MONKEY }
                                                                                                { MONKEY }
IF mnkyDrag THEN {we are in the midst of a down-drag-up}                                        { MONKEY }
                 {this is the normal case and handles menu drags, etc}                          { MONKEY }
        BEGIN                                                                                   { MONKEY }
        IF MonkeyBool(4) THEN {the button just went up}                                         { MONKEY }
                               BEGIN                                                            { MONKEY }
                               MonkeyDo := TRUE;                                                { MONKEY }
                               mnkyDrag := FALSE;                                               { MONKEY }
                               didDrag  := FALSE;                                               { MONKEY }
                               mnkyClicks := 0;                                                 { MONKEY }
                               mnkyCount  := mnkyCount + 1;                                     { MONKEY }
                               MonkeyRepeat(mnkyVent);                                          { MONKEY }
                               END                                                              { MONKEY }
                         ELSE {the button is still down}                                        { MONKEY }
                               MonkeyDo := FALSE;                                               { MONKEY }
        EXIT(MonkeyDo);                                                                         { MONKEY }
        END;                                                                                    { MONKEY }
                                                                                                { MONKEY }
IF (mnkyClicks > 0) THEN {generate button ups and multiple button events}                       { MONKEY }
        BEGIN                                                                                   { MONKEY }
        IF MonkeyBool(mnkyStress) THEN {do the next button transition}                          { MONKEY }
                                        BEGIN                                                   { MONKEY }
                                        MonkeyDo   := TRUE;                                     { MONKEY }
                                        mnkyClicks := mnkyClicks - 1;                           { MONKEY }
                                        mnkyCount  := mnkyCount + 1;                            { MONKEY }
                                        MonkeyRepeat(mnkyVent);                                 { MONKEY }
                                        END                                                     { MONKEY }
                                  ELSE {stall for a bit}                                        { MONKEY }
                                        MonkeyDo := FALSE;                                      { MONKEY }
        EXIT(MonkeyDo);                                                                         { MONKEY }
        END;                                                                                    { MONKEY }
                                                                                                { MONKEY }
IF mnkyStep THEN  {wait here till a user message comes through}                                 { MONKEY }
                  REPEAT MonkeyListen UNTIL snglStep OR NOT(mnkyStep)                           { MONKEY }
            ELSE  {check quick for any user messages}                                           { MONKEY }
                  MonkeyListen;                                                                 { MONKEY }
                                                                                                { MONKEY }
IF NOT(monkeyFlag) THEN BEGIN {user said quit}                                                  { MONKEY }
                        MonkeyDo := FALSE;                                                      { MONKEY }
                        EXIT(MonkeyDo);                                                         { MONKEY }
                        END;                                                                    { MONKEY }
                                                                                                { MONKEY }
IF monkeyBool(mnkyStress) {generate a new event sequence}                                       { MONKEY }
     THEN BEGIN                                                                                 { MONKEY }
          MonkeyDo  := TRUE;                                                                    { MONKEY }
          snglStep  := FALSE;                                                                   { MONKEY }
          mnkyCount := mnkyCount + 1;                                                           { MONKEY }
          MonkeyMake(repOK,mnkyVent);                                                           { MONKEY }
          END                                                                                   { MONKEY }
     ELSE BEGIN                                                                                 { MONKEY }
          MonkeyDo := FALSE;                                                                    { MONKEY }
          END;                                                                                  { MONKEY }
                                                                                                { MONKEY }
END; {MonkeyDo}                                                                                 { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
PROCEDURE MonkeyInit;                                                                           { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
{ Called from CheckEvents when apple-option-m is entered. }                                     { MONKEY }
                                                                                                { MONKEY }
VAR     thisEv:         EventHandle;                                                            { MONKEY }
        nextEv:         EventHandle;                                                            { MONKEY }
        mnkyworld:      INTEGER;                                                                { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
        PROCEDURE MonkeyProof(VAR value: INTEGER; lo,hi: INTEGER);                              { MONKEY }
        { Keeps user from making a monkey out of himself!   }                                   { MONKEY }
        BEGIN                                                                                   { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
        WHILE (value < lo) OR (value > hi) DO                                                   { MONKEY }
                BEGIN                                                                           { MONKEY }
                Beep(5000,250);                                                                 { MONKEY }
                WRITE('Please enter a number within the given range: ');                        { MONKEY }
                READLN(value);                                                                  { MONKEY }
                END; {While}                                                                    { MONKEY }
        END; {MonkeyProof}                                                                      { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
BEGIN                                                                                           { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
SetScreenKeybd(AltScrn);                                                                        { MONKEY }
                                                                                                { MONKEY }
WRITELN('     *** THE LISA MONKEY *** v3.0 ***');                                               { MONKEY }
WRITELN;                                                                                        { MONKEY }
WRITE('Feeding time!  How many bananas do you have?  ');                                        { MONKEY }
READLN(randSeed);                                                                               { MONKEY }
                                                                                                { MONKEY }
WRITE('Frequency of random events?           (0-100) ');                                        { MONKEY }
READLN(mnkyStress);                                                                             { MONKEY }
MonkeyProof(mnkyStress,0,100);                                                                  { MONKEY }
                                                                                                { MONKEY }
WRITE('Frequency of menu drags?              (0-100) ');                                        { MONKEY }
READLN(menuFocus);                                                                              { MONKEY }
MonkeyProof(menuFocus,0,100);                                                                   { MONKEY }
                                                                                                { MONKEY }
WRITE('Frequency of mouse button?            (0-100) ');                                        { MONKEY }
READLN(buttonFocus);                                                                            { MONKEY }
MonkeyProof(buttonFocus,0,100);                                                                 { MONKEY }
                                                                                                { MONKEY }
WRITE('Monkey World? (0=full desk, 1=current window) ');                                        { MONKEY }
READLN(mnkyWorld);                                                                              { MONKEY }
MonkeyProof(mnkyWorld,0,1);                                                                     { MONKEY }
monkeyWorld := (mnkyWorld = 1);                                                                 { MONKEY }
                                                                                                { MONKEY }
WRITE('Single-Step after how many monkey events?     ');                                        { MONKEY }
READLN(stepPoint);                                                                              { MONKEY }
                                                                                                { MONKEY }
buttonsUp  := FALSE;                                                                            { MONKEY }
didDrag    := FALSE;                                                                            { MONKEY }
logCount   := 150;                                                                              { MONKEY }
mnkyBreak  := (stepPoint <> 0);                                                                 { MONKEY }
mnkyClicks := 0;                                                                                { MONKEY }
mnkyCount  := 0;                                                                                { MONKEY }
mnkyDrag   := FALSE;                                                                            { MONKEY }
mnkyMenu   := FALSE;                                                                            { MONKEY }
mnkyStep   := FALSE;                                                                            { MONKEY }
monkeyFlag := TRUE;                                                                             { MONKEY }
snglStep   := FALSE;                                                                            { MONKEY }
SetScreenKeybd(PriScrn);                                                                        { MONKEY }
                                                                                                { MONKEY }
{ drain the interrupt buffer and big buffer }                                                   { MONKEY }
WHILE KeybdEvent(FALSE,FALSE,keyState) DO;                                                      { MONKEY }
thisEv := FirstEvent;                                                                           { MONKEY }
WHILE thisEv <> Nil DO BEGIN                                                                    { MONKEY }
                       nextEv := NextEvent(thisEv);                                             { MONKEY }
                       DeleteEvent(thisEv);                                                     { MONKEY }
                       thisEv := nextEv;                                                        { MONKEY }
                       END;                                                                     { MONKEY }
                                                                                                { MONKEY }
CursorTracking(FALSE);                                                                          { MONKEY }
END;                                                                                            { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
PROCEDURE MonkeyListen;                                                                         { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
{ Polls HWInt for user messages, checks for breakpoints, etc. }                                 { MONKEY }
                                                                                                { MONKEY }
VAR     shifts:         INTEGER;                                                                { MONKEY }
        flagPtr:        Ptr;                                                                    { MONKEY }
                                                                                                { MONKEY }
BEGIN                                                                                           { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
IF (mnkyCount >= logCount) THEN {write the current elapsed event total on the alt screen}       { MONKEY }
                                BEGIN                                                           { MONKEY }
                                WRITELN('Monkey Elapsed Events: ',mnkyCount);                   { MONKEY }
                                logCount := logCount + 150;                                     { MONKEY }
                                END;                                                            { MONKEY }
                                                                                                { MONKEY }
IF mnkyBreak AND (mnkyCount >= stepPoint) AND NOT(mnkyStep) THEN {breakpoint reached: trace on} { MONKEY }
        BEGIN                                                                                   { MONKEY }
        mnkyStep   := TRUE;                                                                     { MONKEY }
        eventDebug := TRUE;                                                                     { MONKEY }
        mnkyBreak  := FALSE;                                                                    { MONKEY }
        Beep(2000,500);                                                                         { MONKEY }
        SetScreenKeybd(AltScrn);                                                                { MONKEY }
        WRITELN('Monkey Elapsed Events: ',mnkyCount);                                           { MONKEY }
        WRITELN('Monkey is Ready to Single Step!');                                             { MONKEY }
        WRITELN('Hit return to begin            ');                                             { MONKEY }
        READLN;                                                                                 { MONKEY }
        SetScreenKeybd(PriScrn);                                                                { MONKEY }
        END;                                                                                    { MONKEY }
                                                                                                { MONKEY }
keyStatus := ORD(KeybdEvent(FALSE,FALSE,keyState));                                             { MONKEY }
IF keyStatus <> 0 THEN {user sent a message}                                                    { MONKEY }
        BEGIN                                                                                   { MONKEY }
        shifts := keyState.state;                                                               { MONKEY }
        flagPtr := @shifts;                                                                     { MONKEY }
        IF  BitTst(flagPtr,13)                   { option key(s) }                              { MONKEY }
        AND BitTst(flagPtr,12) THEN              { command key }                                { MONKEY }
        CASE keyState.key OF                                                                    { MONKEY }
                                                                                                { MONKEY }
          92: IF mnkyStep THEN snglStep := TRUE;           { apple option space  --> Step once }{ MONKEY }
                                                                                                { MONKEY }
         101: mnkyStep   := FALSE;                              { apple option R  --> Run Mode }{ MONKEY }
                                                                                                { MONKEY }
         102: BEGIN;                                          { apple option T  --> Trace Mode }{ MONKEY }
              mnkyStep   := TRUE;                                                               { MONKEY }
              eventDebug := TRUE;                                                               { MONKEY }
              END;                                                                              { MONKEY }
                                                                                                { MONKEY }
         109: WRITELN('Monkey Elapsed Events: ',mnkyCount);    { apple option C  --> Count Log }{ MONKEY }
                                                                                                { MONKEY }
         118: BEGIN                                          { apple option S  --> stop Monkey }{ MONKEY }
              monkeyFlag := FALSE;                                                              { MONKEY }
              mnkyStep   := FALSE;                                                              { MONKEY }
              WHILE KeybdEvent(FALSE,FALSE,keyState) DO;                                        { MONKEY }
              CursorTracking(TRUE);                                                             { MONKEY }
              END;                                                                              { MONKEY }
                                                                                                { MONKEY }
         123: eventDebug := NOT(eventDebug);                { apple option D  --> toggle debug }{ MONKEY }
                                                                                                { MONKEY }
        END;  { case }                                                                          { MONKEY }
        END;  { if }                                                                            { MONKEY }
END;                                                                                            { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
PROCEDURE MonkeyMake; {(repOK: BOOLEAN; VAR mnkyVent: KeyEvent)}                                { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
  { similar to HWInt function KeyBdEvent, MonkeyDo returns a random   }                         { MONKEY }
  { keyboard event.                                                   }                         { MONKEY }
                                                                                                { MONKEY }
VAR     x:              Pixels;                                                                 { MONKEY }
        y:              Pixels;                                                                 { MONKEY }
        shifts:         INTEGER;                                                                { MONKEY }
        flagPtr:        Ptr;                                                                    { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
        PROCEDURE RandClicks;                                                                   { MONKEY }
        { gets random number of mouse clicks for event. }                                       { MONKEY }
        VAR howMany:            INTEGER;                                                        { MONKEY }
        BEGIN                                                                                   { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
        IF mnkyMenu THEN mnkyClicks := 1                                                        { MONKEY }
                    ELSE BEGIN                                                                  { MONKEY }
                         howMany := ABS(Random) MOD 10 + 1;                                     { MONKEY }
                         CASE howMany OF                                                        { MONKEY }
                              1,2,3  :mnkyClicks := 1;    {single click}                        { MONKEY }
                              4,5,6  :mnkyClicks := 3;    {double click}                        { MONKEY }
                              7,8,9  :mnkyClicks := 5;    {triple click}                        { MONKEY }
                              10     :mnkyClicks := 7;    {quad   click}                        { MONKEY }
                         END {Case};                                                            { MONKEY }
                         END {Else};                                                            { MONKEY }
        IF (mnkyClicks = 1) THEN mnkyDrag := (mnkyMenu OR MonkeyBool(50));                      { MONKEY }
        END; {RandClicks}                                                                       { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
      WITH mnkyVent DO BEGIN                                                                    { MONKEY }
                                                                                                { MONKEY }
        {***  get event key  ***}                                                               { MONKEY }
        mnkyMenu := MonkeyBool(menuFocus);                                           {menu drag}{ MONKEY }
        IF MonkeyBool(buttonFocus) OR mnkyMenu                                                  { MONKEY }
        THEN key := 6                                                             {mouse button}{ MONKEY }
        ELSE key := (ABS(Random) MOD 96) + 32;                                      {key stroke}{ MONKEY }
                                                                                                { MONKEY }
        {***  get state  ***}                                                                   { MONKEY }
        shifts  := 0;                                                                           { MONKEY }
        flagPtr := @shifts;                                                                     { MONKEY }
        IF key = 6                                                                              { MONKEY }
        THEN {event is a mouse button}                                                          { MONKEY }
             BEGIN                                                                              { MONKEY }
             ascii := CHR(0);                                                                   { MONKEY }
             mnkyDown := TRUE;                                                                  { MONKEY }
             BitSet(flagPtr,11);                                                  {mouse button}{ MONKEY }
             IF MonkeyBool(7) THEN BitSet(flagPtr,14);                              {shift keys}{ MONKEY }
             state := shifts;                                                                   { MONKEY }
             END                                                                                { MONKEY }
        ELSE {event is a key stroke}                                                            { MONKEY }
             BEGIN                                                                              { MONKEY }
             IF repOK AND MonkeyBool(1) THEN BitSet(flagPtr,10);                  {repeated key}{ MONKEY }
             IF MonkeyBool(3) THEN BitSet(flagPtr,12);                               {apple key}{ MONKEY }
             IF MonkeyBool(2) THEN BitSet(flagPtr,13);                             {option keys}{ MONKEY }
             IF MonkeyBool(7) THEN BitSet(flagPtr,14);                              {shift keys}{ MONKEY }
             IF MonkeyBool(1) THEN BitSet(flagPtr,15);                           {caps lock key}{ MONKEY }
             state := shifts;                                                                   { MONKEY }
             ascii := KeyToAscii(key,state);                                                    { MONKEY }
             END;                                                                               { MONKEY }
                                                                                                { MONKEY }
        {***  get mouse coordinates  ***}                                                       { MONKEY }
        IF mnkyMenu THEN {give menu bar coordinates}                                            { MONKEY }
           BEGIN                                                                                { MONKEY }
           mouseX := ABS(Random) MOD 720 + 1;                                                   { MONKEY }
           oldXMouse := mouseX;                                                                 { MONKEY }
           mouseY := 8;                                                                         { MONKEY }
           oldYMouse := mouseY;                                                                 { MONKEY }
           CursorLocation(mouseX,mouseY);                                                       { MONKEY }
           END                                                                                  { MONKEY }
        ELSE IF (key = 6) THEN {give regular mouse coordinates}                                 { MONKEY }
           BEGIN                                                                                { MONKEY }
           mouseX := ABS(Random) MOD 720 + 1;                                                   { MONKEY }
           oldXMouse := mouseX;                                                                 { MONKEY }
           IF monkeyWorld THEN mouseY := ABS(Random) MOD 317 + 32                               { MONKEY }
                          ELSE mouseY := ABS(Random) MOD 349 + 16;                              { MONKEY }
           oldYMouse := mouseY;                                                                 { MONKEY }
           CursorLocation(mouseX,mouseY);                                                       { MONKEY }
           END                                                                                  { MONKEY }
        ELSE {mouse hasn't moved since last time}                                               { MONKEY }
           BEGIN                                                                                { MONKEY }
           mouseX := oldXMouse;                                                                 { MONKEY }
           mouseY := oldYMouse;                                                                 { MONKEY }
           END;                                                                                 { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
        {***  get time of event  ***}                                                           { MONKEY }
        time := Timer;                                                                          { MONKEY }
                                                                                                { MONKEY }
        {***  get total number of clicks for this sequence  ***}                                { MONKEY }
        IF (key = 6) THEN RandClicks                                                            { MONKEY }
                     ELSE mnkyClicks := 0;                                                      { MONKEY }
                                                                                                { MONKEY }
   END; { with }                                                                                { MONKEY }
END;                                                                                            { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
PROCEDURE MonkeyMouse; {VAR mouseX: Pixels;  VAR mouseY: Pixels}                                { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
  { similar to HWInt procedure MouseLocation, MonkeyMouse returns   }                           { MONKEY }
  { random mouse coordinates.  Calls HWInt procedure CursorLocation }                           { MONKEY }
  { to simulate mouse movement on the display.                      }                           { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
BEGIN                                                                                           { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
IF didDrag THEN {sit tight til button-up}                                                       { MONKEY }
                BEGIN                                                                           { MONKEY }
                mouseX := oldXMouse;                                                            { MONKEY }
                mouseY := oldYMouse;                                                            { MONKEY }
                Exit(MonkeyMouse);                                                              { MONKEY }
                END;                                                                            { MONKEY }
                                                                                                { MONKEY }
IF mnkyDrag THEN {do a mouse drag}                                                              { MONKEY }
    IF mnkyMenu                                                                                 { MONKEY }
    THEN {drag in the menu box}                                                                 { MONKEY }
         BEGIN                                                                                  { MONKEY }
         mouseX := oldXMouse;                                                                   { MONKEY }
         IF monkeyBool(70) THEN mouseY := ABS(Random) MOD 150 + 16                              { MONKEY }
                           ELSE mouseY := ABS(Random) MOD 300 + 16;                             { MONKEY }
         oldYMouse := ABS(Random) MOD 317 + 32;                                                 { MONKEY }
         CursorLocation(mouseX,mouseY);                                                         { MONKEY }
         mnkyMenu := FALSE;                                                                     { MONKEY }
         didDrag := TRUE;                                                                       { MONKEY }
         END                                                                                    { MONKEY }
    ELSE {regular drag}                                                                         { MONKEY }
         BEGIN                                                                                  { MONKEY }
         mouseX := ABS(Random) MOD 720 + 1;                                                     { MONKEY }
         oldXMouse := mouseX;                                                                   { MONKEY }
         IF monkeyWorld THEN mouseY := ABS(Random) MOD 317 + 32                                 { MONKEY }
                        ELSE mouseY := ABS(Random) MOD 349 + 16;                                { MONKEY }
         oldYMouse := mouseY;                                                                   { MONKEY }
         CursorLocation(mouseX,mouseY);                                                         { MONKEY }
         didDrag := TRUE;                                                                       { MONKEY }
         END                                                                                    { MONKEY }
ELSE {mouse hasn't moved since last time}                                                       { MONKEY }
         BEGIN                                                                                  { MONKEY }
         mouseX := oldXMouse;                                                                   { MONKEY }
         mouseY := oldYMouse;                                                                   { MONKEY }
         END;                                                                                   { MONKEY }
END; {MonkeyMouse}                                                                              { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
PROCEDURE MonkeyRepeat; {VAR mnkyVent: KeyEvent}                                                { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
  { do repeated button transitions. }                                                           { MONKEY }
                                                                                                { MONKEY }                                                                                                { MONKEY }
VAR     shifts:         INTEGER;                                                                { MONKEY }
        flagPtr:        Ptr;                                                                    { MONKEY }
                                                                                                { MONKEY }
BEGIN
{$IFC fTraceWM}    LogCall;     {$ENDC}
      WITH mnkyVent DO BEGIN                                                                    { MONKEY }
                                                                                                { MONKEY }
        {***  button event  ***}                                                                { MONKEY }
        key := 6;                                                                               { MONKEY }
                                                                                                { MONKEY }
        {***  set state and ascii  ***}                                                         { MONKEY }
        flagPtr := @shifts;                                                                     { MONKEY }
        mnkyDown := NOT(mnkyDown);                                                              { MONKEY }
        IF mnkyDown THEN {button down transition}                                               { MONKEY }
                         BEGIN                                                                  { MONKEY }
                         BitSet(flagPtr,11);                                                    { MONKEY }
                         ascii := CHR(0);                                                       { MONKEY }
                         END                                                                    { MONKEY }
                    ELSE {button up transition}                                                 { MONKEY }
                         BEGIN                                                                  { MONKEY }
                         BitClr(flagPtr,11);                                                    { MONKEY }
                         ascii := CHR(1);                                                       { MONKEY }
                         END;                                                                   { MONKEY }
        state := shifts;                                                                        { MONKEY }
                                                                                                { MONKEY }
        {***  same mouse coordinates  ***}                                                      { MONKEY }
        mouseX := oldXMouse;                                                                    { MONKEY }
        mouseY := oldYMouse;                                                                    { MONKEY }
                                                                                                { MONKEY }
        {***  get time of event  ***}                                                           { MONKEY }
        time := Timer;                                                                          { MONKEY }
                                                                                                { MONKEY }
      END; {With}                                                                               { MONKEY }
END; {MonkeyRep}                                                                                { MONKEY }
                                                                                                { MONKEY }
{$S WMJrnl }                                                                                    { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
FUNCTION MonkeyStillDown;  {:BOOLEAN}                                                           { MONKEY }
{-----------------------------------------------------------------------}                       { MONKEY }
{ MonkeyStillDown returns TRUE for drag events. Called from StillDown.  }                       { MONKEY }
{ WM Unit Folder calls to Button are handled by MonkeyButton.           }                       { MONKEY }
BEGIN                                                                                           { MONKEY }
{$IFC fTraceWM}    LogCall;     {$ENDC}
MonkeyStillDown := mnkyDrag;                                                                    { MONKEY }
END;                                                                                            { MONKEY }
                                                                                                { MONKEY }
                                                                                                { MONKEY }
{$ENDC }                                                                                        { MONKEY }
                                                                                                { MONKEY }
END.  { of unit }

