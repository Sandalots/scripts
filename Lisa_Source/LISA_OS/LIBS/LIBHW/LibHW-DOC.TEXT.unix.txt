^pl 72
^rm 88
^m1 3
^m2 2
^m3 2
^m4 3
Subject:   Lisa Hardware Interface Software
Date:      16 December 1982  (Release 8.0)
From:      Rick Meyers

__________________________________________________________________________________
^he 'Lisa Hardware Interface''(c) 1983, Apple Computer Inc.'
^fo ''- % -''


^ce 1
Contents


     Lisa Hardware Interface Software .  .  .  .  .  .  .  .  .  .  .  .  .  2

     1.0  Initialization and Synchronization   .  .  .  .  .  .  .  .  .  .  3
           1.1  Driver Initialization .  .  .  .  .  .  .  .  .  .  .  .  .  3
           1.2  Disk and Twiggy Drivers  .  .  .  .  .  .  .  .  .  .  .  .  3
           1.3  Synchronization of the Parallel Port .  .  .  .  .  .  .  .  4
           1.4  NMI (Non-Maskable Interrupt) Synchronization  .  .  .  .  .  4
           1.5  COPS Synchronization  .  .  .  .  .  .  .  .  .  .  .  .  .  4
           1.6  Polling for COPS, Retrace and Timer Interrupts   .  .  .  .  5

     2.0  The Mouse .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  5
           2.1  Mouse Location  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  5
           2.2  Mouse Update Frequency   .  .  .  .  .  .  .  .  .  .  .  .  6
           2.3  Mouse Scaling   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  6
           2.4  Mouse Odometer  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  7

     3.0  The Cursor   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  7
           3.1  Cursor/Mouse Tracking .  .  .  .  .  .  .  .  .  .  .  .  .  8
           3.2  Cursor Hide, Shield, Display, Obscure and Init   .  .  .  .  8
           3.3  The Busy Cursor .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 10

     4.0  The Display Screens   .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 11
           4.1  Screen Contrast .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 12

     5.0  Power Control   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 13

     6.0  The Speaker  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 15

     7.0  The Keyboard .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 16
           7.1  Keyboard Identification  .  .  .  .  .  .  .  .  .  .  .  . 17
           7.2  Keyboard State  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 18
           7.3  Keyboard Events .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 19
           7.4  Dead Key Diacriticals .  .  .  .  .  .  .  .  .  .  .  .  . 22
           7.5  Repeats   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 23
           7.6  Pseudo-Keys  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 24
           7.7  NMI Key   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 24
           7.7  Toggle Key   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 24

     8.0  The Microsecond Timer .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 25

     9.0  The Millisecond Timer and Alarms  .  .  .  .  .  .  .  .  .  .  . 25

    10.0  Date and Time   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 27

    11.0  Time Stamp   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 28

    12.0  Clock and Calendar .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 29


    Appendix A.  Pascal Unit HWINT (Hardware Interface) .  .  .  .  .  .  . 30

    Appendix B.  Summary of Hardware Interface Routines .  .  .  .  .  .  . 33
^bp
Lisa Hardware Interface Software
________________________________________________________________________________


The software below provides an interface for accessing and controlling several parts
of the Lisa hardware.  This interface is intended for use by several operating systems,
including the Lisa OS, the Monitor OS and Smalltalk.  The following hardware/software
capabilities are currently addressed:  the mouse, the cursor, primary and alternate
displays, the contrast control, inactive fading and power-off, the speaker, both
undecoded and decoded keyboard access, the NMI key, the millisecond timer and alarms,
the microsecond timer and the hardware clock/calendar.

Both Pascal and assembly language interfaces are supported.  Three distinct ways of
accessing the hardware interface routines exist.

     1)  From Pascal, compile using unit HWINT, link with HWINTL.OBJ.  Pascal
         register and calling conventions are observed.
     2)  From assembly language, JSR to the Pascal routines defined in HWINT.
         Link with HWINTL.OBJ.  Pascal register and calling conventions apply.
     3)  From assembly language, trap to the routines with parameters and
         results passed in registers.  All (non-parameter) registers are preserved.

All of the capabilities defined below are available in the assembly language
interface.  Most of the capabilities are also available from Pascal.  In the Lisa
Office System, most of the the routines will be called from the OS, LisaGraf and the
Event Manager, not directly from applications.  I repeat, most of the the routines
are only to be called from the OS, LisaGraf and the Event Manager, and not directly
from applications!

Several of the assembly language routines will execute successfully only in supervisor
mode.  These routine are marked with an asterisk (*).

The documentation below contains interleaved text descriptions, Pascal function and
procedure declarations and assembly language interface definitions.  Pascal type
declarations and a summary of the function and procedure declarations can be found
in Appendix A.  A brief summary of all capabilities is found in Appendix B.


^bp
1.0  Initialization and Synchronization

1.1  Driver Initialization

The hardware interface routines must be initialized as part of the booting process.
This may be done either by calling the first instruction of the object files
DRIVERS.OBJ or SYSTEM.LLD, or by calling routine DriverInit.

   _________________________________________________________________________

   Procedure DriverInit;
   _________________________________________________________________________

   Routine:    DriverInit
   Arguments:    none
   Function:   Initialize data areas, VIAs and the interrupt vectors for
               level 1 and level 2 interrupts.  Determine which versions
               of the I/O board is installed.
   _________________________________________________________________________


1.2  Disk and Twiggy Drivers

The hardware interface package owns the level 1 and 2 interrupts.  However,
parallel port and twiggy interrupts come in at level 1.  The routines
below must be called, after calling DriverInit, to install the parallel
port (disk) and Twiggy drivers.   Disk and Twiggy drivers execute with
Level 1 interrupts disabled, and must preserve all registers.

Beware if the disk or Twiggy drivers are written in Pascal.  You must guarantee
that they will be memory resident.  The drivers run on the system stack, and must
establish their own global environment (A5).

   _________________________________________________________________________

   Procedure DiskDriver (routine: LogicalAddress);
   _________________________________________________________________________

   Procedure TwiggyDriver (routine: LogicalAddress);
   _________________________________________________________________________

   Routine:    TwiggyDriver
   Arguments:    A0 (input)   --  address of Twiggy driver (long)
   Function:   Install the Twiggy driver routine.
   _________________________________________________________________________

   Routine:    DiskDriver
   Arguments:    A0 (input)   --  address of disk driver (long)
   Function:   Install the parallel port (disk) driver routine.
   _________________________________________________________________________



^ne 10
1.3  Synchronization of the Parallel Port

The Parallel Port (Hard Disk VIA) is shared by the disk and/or printer driver
and the contrast control routines.  In order to properly synchronize access to
the parallel port, all disk and printer drivers using this port must bracket use
of the port with calls to routine DiskSync, first with a parameter "busy", then
with "free".  The port is initially free.

When the port is not in use, the contrast control routines will be free to execute
the following sequence at priority level 2.

   program data direction register for DEN/ as output
   set DEN/ to 1 (disable the disk)
   program data direction register for Port A as output
   transfer data on Port A
   program data direction register for Port A as input
   set DEN/ to 0 (enable the disk)

   _________________________________________________________________________

   Procedure DiskSync (busy: Boolean);
   _________________________________________________________________________

   Routine:    DiskSync
   Argument:     D0 (input)   --  0=free, else=busy (byte)
   Function:   Synchronize access to the parallel port.  All drivers using
               the parallel port must call DiskSync before and after each
               use of the port.
   _________________________________________________________________________




^ne 10
1.4  NMI (Non-Maskable Interrupt) Synchronization

Non-maskable interrupts can occur, oddly enough, even though interrupts are
disabled.  Output to the COPS which has been interrupted by NMI is sent to
the COPS again after the NMI handler has completed.

   _________________________________________________________________________

   Procedure NMISync;
   _________________________________________________________________________

   Routine:    NMISync
   Argument:     none
   Function:   Inform the hardware interface that an NMI has occurred.
               NMISync attempts to straighten out COPS input and output
               that was interrupted by the NMI.
   _________________________________________________________________________


1.5  COPS Synchronization

Input from the COPS (through the keyboard 6522) comes in multiple byte packets.
These include two byte reset packets, three byte mouse locations and seven byte
clock/calendar packets.  Normally the hardware interface drivers receive all
input from the COPS, and rely on knowledge of previous inputs to interpret
data received from the COPS.  Routines which borrow the COPS (e.g. customer
diagnostics) must take two precautions to insure that the hardware interface
routines don't misinterpret COPS input.  First, after modifying the Level 2
interrupt vector, the borrower must call routine COPSSync.  Second, before
restoring the interrupt vector, the borrower must insure that all bytes of
the current packet have been read.  That is, the COPS input stream must be
between packets when it is returned to the hardware interface.

COPSSync abandons any packet in progress and adjusts the keyboard map to
indicate that all keys are up, with the exceptions of the caps-lock key,
parallel port and mouse plug.

   _________________________________________________________________________

   Procedure COPSSync;
   _________________________________________________________________________

   Routine:    COPSSync
   Argument:     none
   Function:   Inform the hardware interface that the COPS input stream has
               been borrowed.
   _________________________________________________________________________



^ne 10
1.6  Polling for COPS, Retrace and Timer Interrupts

The millisecond and microsecond timers and vertical retrace counter stop running
if level 1 interrupts are off for more than about 10 milliseconds.  Similiarly,
keyboard and mouse input are disabled if level 2 interrupts are disabled.
Software which runs for extended periods of time with interrupts disabled
(e.g. LisaBug) should call Procedure Poll every few milliseconds to keep the
clocks running.  Poll should also be called prior to requests for keyboard or
mouse input if interrupts are disabled.
   _________________________________________________________________________

   Procedure Poll;
   _________________________________________________________________________

   Routine:    Poll
   Arguments:    none
   Function:   Poll for COPS, vertical retrace and Timer interrupts.
   _________________________________________________________________________



2.0  The Mouse

2.1  Mouse Location

The mouse is a pointing device used to indicate screen locations.  The X-coordinate
can range from 0 to 719, and the Y-coordinate from 0 to 363.  The initial mouse
location is 0,0.

   _________________________________________________________________________

   Procedure MouseLocation (var x: Pixels; var y: Pixels);
   _________________________________________________________________________

   Routine:    MouseLocation
   Arguments:    D0 (output)  --  X-coordinate (integer)
                 D1 (output)  --  Y-coordinate (integer)
   Function:   Return the current mouse location.
   _________________________________________________________________________



2.2  Mouse Update Frequency

Software knowledge of the mouse location is updated periodically, rather than
continuously.  The frequency of these updates can be programmatically controlled.
The time between updates can range from 0 milliseconds (continuous updating) to 28
milliseconds, in intervals of 4 milliseconds.  The initial setting is 16
milliseconds.

   _________________________________________________________________________

   Procedure MouseUpdates (delay: MilliSeconds);
   _________________________________________________________________________

   Routine:    MouseUpdates *
   Arguments:    D0 (input)   --  milliseconds between updates (integer)
   Function:   Set the approximate number of milliseconds between mouse
               location updates.
   _________________________________________________________________________




^ne 10
2.3  Mouse Scaling

The relationship between physical mouse movements and logical mouse movements is not
necessary a fixed linear mapping.  Three alternatives are available:  1) unscaled,
2) scaled for fine movement and 3) scaled for coarse movement.  Initially mouse
movements are unscaled.

When mouse movement is unscaled, a horizontal mouse movement of x units yields a
change in the mouse X-coordinate of x pixels.  Similiarly, a vertical movement of y
units yields a change is the mouse Y-coordinate of y pixels.  These rules apply
independent of the speed of the mouse movement.

When mouse movement is scaled, horizontal movements are magnified by 3/2 relative to
vertical movements.  This is intended to compensate for the 2/3 aspect ratio of
pixels on the screen.  When scaling is in effect, a distinction is made between fine
(small) movements and coarse (large) movements.  Fine movements are slightly
reduced, while coarse movements are magnified.  For scaled fine movements, a
horizontal mouse movement of x units yields a change in the X-coordinate of x
pixels, but a vertical movement of y units yields a change of (2/3)*y pixels.  For
scaled coarse movements, a horizontal movement a x units yields a change of (3/2)*x
pixels, while a vertical movements of y units yields a change of y pixels.

The distinction between fine movements and coarse movements is determined by the sum
of the x and y movements each time the mouse location is updated.  If this sum is at
or below the 'threshold', the movement is considered to be a fine movement.  Values
of the threshold range from 0 (which yields all coarse movements) to 256 (which
yields all fine movements).  Given the default mouse updating frequency, a threshold
of about 8 (threshold's initial setting) gives a comfortable transition between fine
and coarse movements.


   _________________________________________________________________________

   Procedure MouseScaling (scale: Boolean);
   _________________________________________________________________________

   Procedure MouseThresh (threshold: Pixels);
   _________________________________________________________________________

   Routine:    MouseScaling
   Argument:     D0 (input)   --  0=no scaling, else=scaling (byte)
   Function:   Enable or disable the scaling of mouse movements.
   _________________________________________________________________________

   Routine:    MouseThresh
   Argument:     D0 (input)   --  mouse movement threshold (integer)
   Function:   Set the threshold between fine and coarse movements.
   _________________________________________________________________________



2.4  Mouse Odometer

In order to properly specify, design and test mice, it's important to estimate how
far a mouse moves during it's lifetime.  Routine MouseOdometer returns the sum of
the X and Y movements of the mouse since boot time.  The value returned is in
(unscaled) pixels.  There are 180 pixels per inch of mouse movement.

   _________________________________________________________________________

   Function  MouseOdometer: ManyPixels;
   _________________________________________________________________________

   Routine:    MouseOdomener
   Argument:     D0 (output)  --  mouse odometer in pixels (long)
   Function:   Return the sum of the X and Y mouse movements since boot time.
   _________________________________________________________________________



^ne 10
3.0  The Cursor

The cursor is a small image that is displayed on the screen.  It's shape is
specified by two bitmaps, called 'data' and 'mask'.  These bitmaps are 16 bits
wide and from 0 to 32 bits high.  The rule used to combine the bits already on
the screen with the data and mask is

    screen <- (screen and (not mask)) xor data.

The effect is that white areas of the screen are replaced with the cursor data.
Black areas of the screen are replaced with (not mask) xor data.  If the data and
mask bitmaps are identical, the effect is to 'or' the data onto the screen.

The cursor has both a location and a hotspot.  The location is a position on the
screen, with X-coordinates of 0 to 719 and Y-coordinates of 0 to 363 .  The hotspot
is a position within the cursor bitmaps, with X- and Y-coordinates ranging from 0
to 16.  The cursor is displayed on the screen with it's hotspot at location.  If the
cursor's location is near an edge of the screen, the cursor image may be partially
or completely off the screen.

Initially the cursor data and mask bitmaps contain all zeroes, which yields a blank
(invisible) cursor.  The initial hotspot is 0,0.

   _________________________________________________________________________

   Procedure CursorImage (hotX: Pixels; hotY: Pixels;
      height: CursorHeight; data: CursorPtr; mask: CursorPtr);
   _________________________________________________________________________

   Procedure CursorLocation (x: Pixels; y: Pixels);
   _________________________________________________________________________

   Routine:    CursorImage
   Arguments:    D0 (input)   --  hotspot X-coordinate (integer)
                 D1 (input)   --  hotspot Y-coordinate (integer)
                 D2 (input)   --  cursor height, 0-32 (integer)
                 A0 (input)   --  address of data bitmap (address)
                 A1 (input)   --  address of mask bitmap (address)
   Function:   Set the cursor hotspot and data and mask bitmaps.
   _________________________________________________________________________

   Routine:    CursorLocation
   Arguments:    D0 (input)   --  X-coordinate (integer)
                 D1 (input)   --  Y-coordinate (integer)
   Function:   Set the cursor location.  Note that if tracking is enabled
               this will have no effect.
   _________________________________________________________________________



^ne 5
3.1  Cursor/Mouse Tracking

When 'tracking' is disabled the mouse location and cursor location are independent.
Setting the cursor location will move the cursor, moving the mouse will not.

When tracking is enabled the cursor location is changed to the mouse location each
time the mouse moves.  Setting the cursor location will have no effect, the cursor
sticks with the mouse.

When tracking is first enabled (i.e.  on each transition from disabled to enabled)
the mouse location is modified to equal the cursor location.  Therefore, enabling
tracking does not move the cursor; it does modify the mouse location.  Initially
tracking is enabled.

   _________________________________________________________________________

   Procedure CursorTracking (track: Boolean);
   _________________________________________________________________________

   Routine:    CursorTracking
   Arguments:    D0 (input)   --  0=disable; else=enable
   Function:   Enable and disable cursor tracking of the mouse.  Note that
               enabling tracking will modify the mouse location.
   _________________________________________________________________________




3.2  Cursor Hide, Shield, Display, Obscure and Init

Care must be taken when updating the screen image which is 'under' the cursor.  The
simplest approach is to remove the cursor from the screen (hide), do the screen
modification, then redisplay the cursor (display).

This simple solution may yield excessive cursor blinking.  A subtler approach is to
remove the cursor only when it is in the same area of the screen that is being
updated.  A conditional hide, called 'shield', removes the cursor from the screen if
the data 'under' the cursor intersects a given rectangular area.

Each hide or shield operation should be followed by a corresponding display operation.
The operations are paired and can be nested.  The first of a series of hides removes
the cursor from the screen; it's corresponding display redisplays the cursor.
Intervening operations have no apparent effect.
^ne 5
It is also possible to remove the cursor from the screen and have it reappear
automatically the next time the cursor moves.  This operation is called 'obscure'.
The cursor movement may be caused by either mouse movement (if tracking is enabled)
or by a call to CursorLocation (if tracking is disabled).

Occasionally is is necessary to definately display the cursor, independent of
previous calls to CursorHide, CursorShield, CursorObscure, and BusyDelay.  Procedure
CursorInit performs this function.  Procedure CursorReInit forgets previous hides,
shields and obscures, while retaining the status of the busy cursor.

   _________________________________________________________________________

   Procedure CursorHide;
   _________________________________________________________________________

   Procedure CursorShield (left: Pixels; top: Pixels; right: Pixels;
      bottom: Pixels);
   _________________________________________________________________________

   Procedure CursorDisplay;
   _________________________________________________________________________

   Procedure CursorObscure;
   _________________________________________________________________________

   Procedure CursorInit;
   _________________________________________________________________________

   Procedure CursorReInit;
   _________________________________________________________________________

   Routine:    CursorHide
   Arguments:    none
   Function:   Remove the cursor from the screen.  Note that every call
               to CursorHide must be followed by exactly one call to
               CursorDisplay.
   _________________________________________________________________________

   Routine:    CursorShield
   Arguments:    D0 (input)   --  top left X-coordinate (integer)
                 D1 (input)   --  top left Y-coordinate (integer)
                 D2 (input)   --  bottom right X-coordinate (integer)
                 D3 (input)   --  bottom right Y-coordinate (integer)
   Function:   Remove the cursor from the screen if the data 'under'
               the cursor intersects the specified rectangle.  Note
               that every call to CursorShield must be followed by
               exactly one call to CursorDisplay.
   _________________________________________________________________________

   Routine:    CursorDisplay
   Arguments:    none
   Function:   Redisplay the cursor.  Note that every call to
               CursorDisplay must be preceeded by exactly one call
               to CursorHide or CursorShield.
   _________________________________________________________________________

   Routine:    CursorObscure
   Arguments:    none
   Function:   Remove the cursor from the screen.  Redisplay the cursor
               automatically the next time the cursor moves, either in
               response to mouse movement or in response to a call to
               CursorLocation.
   _________________________________________________________________________

   Routine:    CursorInit
   Arguments:    none
   Function:   Definately redisplay the normal cursor, independent of previous
               calls to CursorHide, CursorShield, CursorObscure and BusyDelay.
   _________________________________________________________________________

   Routine:    CursorReInit
   Arguments:    none
   Function:   Definately redisplay the normal or busy cursor, independent of
               previous calls to CursorHide, CursorShield and CursorObscure.
               Retain the status of the busy cursor.
   _________________________________________________________________________



3.3  The Busy Cursor

Applications may desire to display a busy cursor (e.g. an hourglass) when an
operation in progress requires more than a few seconds to complete. Routine
BusyImage is used to specify the data bitamp, mask bitmap, height and hotspot
of the busy cursor.

A call to BusyDelay specifies that the normal cursor should currently be displayed,
and that display of the busy cursor should be delayed for a specified number of
milliseconds.  Subsequent calls to BusyDelay override previous calls, postponing
display of the busy cursor.  If no calls to BusyDelay occur for the specified
number of milliseconds, the busy cursor will be displayed until the next call to
BusyCursor.

Initially the busy cursor data and mask bitmaps contain all zeroes, which yields a
blank (invisible) cursor.  The initial hotspot is 0,0.  The initial busy delay is
infinite, that is, the busy cursor will not be displayed until BusyDelay is called.


   _________________________________________________________________________

   Procedure BusyImage (hotX: Pixels; hotY: Pixels;
      height: CursorHeight; data: CursorPtr; mask: CursorPtr);
   _________________________________________________________________________

   Procedure BusyDelay (delay: Milliseconds);
   _________________________________________________________________________

   Routine:    BusyImage
   Arguments:    D0 (input)   --  hotspot X-coordinate (integer)
                 D1 (input)   --  hotspot Y-coordinate (integer)
                 D2 (input)   --  cursor height, 0-32 (integer)
                 A0 (input)   --  address of data bitmap (address)
                 A1 (input)   --  address of mask bitmap (address)
   Function:   Set the busy cursor hotspot and data and mask bitmaps.
   _________________________________________________________________________

   Routine:    BusyDelay
   Arguments:    D0 (input)   --  milliseconds before busy cursor (long)
   Funciton:   Set the approximate period of time, in milliseconds,
               before the busy cursor will be displayed.
   _________________________________________________________________________



^ne 10
4.0  The Display Screen

The display screen is a bit mappped display; that is, each pixel on the screen is
controlled by a bit in main memory.  The display has 720 pixels horizontally and 364
lines vertically, and therefore requires 32,760 bytes of main memory.  The screen
size may be determined programmatically by calling routine ScreenSize.

The hardware interface supports two separate displays.  The primary screen is
intended for normal users interaction, especially graphics.  The cursor always
appears on the primary screen.  The alternate screen is intended for debugging
output.  Initially the primary display is visible.  The user can toggle between
the two displays by typing <Option-Toggle> (hold down Option while typing the
Toggle key defined by calling routine SetToggleKey).  Programs can toggle between
the two displays using routine ScreenKeybd and SetScreenKeybd.  Routines ScreenAddr
and AltScreenAddr return the addresses of the displays.  These addresses are logical,
rather than physical, addresses.

There are two keyboard input queues, one corresponding to each display.  When the
primary display is visible, input goes into the primary input queue.  Similiarly,
when the alternate display is visible, input goes into the alternate input queue.

The screen is redisplayed about 60 times per second.  A frame counter is incremented
between screen updates, at the vertical retrace interrupt.  The frame counter is an
unsigned 32-bit integer which is reset to 0 each time the machine is booted.  An
application can synchronize with the vertical retaces by watching for changes in the
value of this counter.  The frame counter should NOT be used as a timer, use the
millisecond and mircosecond timers instead.
   _________________________________________________________________________

   Function  FrameCounter: Frames;
   _________________________________________________________________________

   Procedure ScreenSize  (var x: Pixels; var y: Pixels);
   _________________________________________________________________________

   Function  ScreenAddr: LogicalAddress;
   _________________________________________________________________________

   Function  AltScreenAddr: LogicalAddress;
   _________________________________________________________________________

   Function  ScreenKeybd: VisibleScreen;
   _________________________________________________________________________

   Procedure SetScreenKeybd (screen: VisibleScreen);
   _________________________________________________________________________

   Routine:    FrameCounter
   Arguments:    D0 (output)  --  vertical retrace counter (long)
   Function:   Return the current value of the vertical retrace counter.
   _________________________________________________________________________

   Routine:    ScreenSize
   Arguments:    D0 (output)  --  horizontal dimension (integer)
                 D1 (output)  --  vertical dimension (integer)
   Function:   Return the dimensions of the screen.
   _________________________________________________________________________

   Routine:    ScreenAddr
   Arguments:    A0 (output)  --  primary screen address (address)
   Function:   Return the logical address of the primary screen.
   _________________________________________________________________________

   Routine:    AltScreenAddr
   Arguments:    A0 (output)  --  alternate screen address (address)
   Function:   Return the logical address of the alternate screen.
   _________________________________________________________________________

   Routine:    ScreenKeybd
   Arguments:    D0 (output)  --  0=primary, 1=alternate (byte)
   Function:   Return the currently visible/active screen/keyboard.
   _________________________________________________________________________

   Routine:    SetScreenKeybd
   Arguments:    D0 (input)   --  0=primary, 1=alternate (byte)
   Function:   Set the currently visible/active screen/keyboard.
   _________________________________________________________________________



^ne 10
4.1  Screen Contrast

The display's contrast level is under program control.  Contrast values range from 0
to 255 ($FF), with 0 as maximum contrast and 255 as minimum.  The low order two bits
of the contrast value are ignored.  The initial contrast value in 128 ($80).  A
sudden change in the contrast level can be jarring to the user.  A routine is
provided which gradually changes the contrast to the new setting over a period of
approximately a second.  This routine returns immediately, then ramps the contrast
using interrupt driven processing.

The display automatically dims when no user activity has been noted over a specified
period of time.  (See the "Power Control" section below for details.)  The contrast
value to which the screen is dimmed is under program control.  Routines are provided
to both read and write the dim contrast setting.  The initial dim contrast value is
176 ($B0).

   _________________________________________________________________________

   Function  Contrast: ScreenContrast;
   _________________________________________________________________________

   Procedure SetContrast (contrast: ScreenContrast);
   _________________________________________________________________________

   Procedure RampContrast (contrast: ScreenContrast);
   _________________________________________________________________________

   Function  DimContrast: ScreenContrast;
   _________________________________________________________________________

   Procedure SetDimContrast (contrast: ScreenContrast);
   _________________________________________________________________________

   Routine:    Contrast
   Arguments:    D0 (output)  --  contrast level (integer)
   Function:   Return the display contrast level.
   _________________________________________________________________________

   Routine:    SetContrast
   Arguments:    D0 (input)   --  contrast level (integer)
   Function:   Set the display contrast level.  The value specified
               should be in the range 0 to 255.
   _________________________________________________________________________

   Routine:    RampContrast
   Arguments:    D0 (input)  --  contrast level (integer)
   Function:   Gradually change the display contrast level.  The value
               specified should be in the range 0 to 255.
   _________________________________________________________________________

   Routine:    DimContrast
   Arguments:    D0 (output)  --  dim contrast level (integer)
   Function:   Return the dim contrast level.
   _________________________________________________________________________

   Routine:    SetDimContrast
   Arguments:    D0 (input)   --  dim contrast level (integer)
   Function:   Set the dim contrast level.  The value specified
               should be in the range 0 to 255.
   _________________________________________________________________________



^ne 10
5.0  Power Control

Four distinct levels of operation are provided by a combination of hardware and
software.

    1)  Fully Operational.
    2)  Operational with display dimmed.
    3)  Powered off.
    4)  Unplugged.

Fully Operational -- When the machine is fully operational, user interaction with
the system is monitored in an attempt to determine if the machine is in use.  If no
user activity is noted over a specified period (usually several minutes) the screen
contrast level is automatically dimmed in order to preserve the screen phosphor.
The delay between the last user activity and dimming of the screen is under software
control.  The actual delay will range from the specified delay to twice the
specified delay.  The initial delay period is five minutes.

Operational with display dimmed -- When the machine is operational but the screen is
dimmed, user interaction will cause the screen contrast to return to its normal
bright level.  Moving the mouse or pressing a key on the keyboard (e.g. SHIFT) is
enough to trigger the screen brightening.  Calling routines CursorLocation or
SetFadeDelay also indicates user activity.

Powered Off  --  Software can instruct the hardware to power off.  Routine PowerDown
provides this function.  In additon, the hardware can be instructed to reboot after
a specified period of time.  The delay before rebooting may range from 0 to
1,048,575 seconds (about 12 days).  Routine PowerCycle provides this function.
Note that PowerCycle is unable to turn the machine back on if the clock/calendar
hasn't been set since the loss of battery power.  In the powered off state, most
of the machine is off, but the clock/calendar circuitry continues to function.

Unplugged -- If the machine is unplugged the clock/calendar circuitry will continue
to operate for a few hours on battery backup.

   _________________________________________________________________________

   Function  FadeDelay: MilliSeconds;
   _________________________________________________________________________

   Procedure SetFadeDelay (delay: MilliSeconds);
   _________________________________________________________________________

   Procedure PowerDown;
   _________________________________________________________________________

   Procedure PowerCycle (delay: Seconds);
   _________________________________________________________________________

   Routine:    FadeDelay
   Arguments:    D0 (output)  --  milliseconds before dimming (long)
   Function:   Return the approximate period of time, in milliseconds,
               between the last user activity and the automatic dimming
               of the screen.
   _________________________________________________________________________

   Routine:    SetFadeDelay
   Arguments:    D0 (input)   --  milliseconds before dimming (long)
   Funciton:   Set the approximate period of time, in milliseconds,
               between the last user activity and the automatic dimming
               of the screen.
   _________________________________________________________________________

   Routine:    PowerDown *
   Arguments:    none
   Function:   Power off the machine.
   _________________________________________________________________________

   Routine:    PowerCycle *
   Arguments:    D0 (input)   --  seconds until reboot (long)
   Function:   Power off the machine.  Reboot after the specified number
               of seconds.
   _________________________________________________________________________



^bp
6.0  The Speaker

The routines below provide square wave output from the Lisa speaker.  The speaker
volume can be set to values in the range 0 (soft) to 7 (loud).  The initial volume
setting is 4.  The approximate wavelength of the tone produced can also be set.  The
minimum wavelength is about 8 microseconds, which corresponds to a frequecncy of
125,000 cycles per seconds, well above the audible range.  The maximum wavelength is
8,191 microseconds, which corresponds to about 122 cycles per second.

The Noise and Silence routines are called in pairs to start and stop square wave
output.  In contrast, the Beep routine starts square wave output which will
automatically stop after a specified period of time.  The effects of Noise, Silence
and Beep are overridden by subsequent calls.

   _________________________________________________________________________

   Function  Volume: SpeakerVolume;
   _________________________________________________________________________

   Procedure SetVolume (volume: SpeakerVolume);
   _________________________________________________________________________

   Procedure Noise (waveLength: MicroSeconds);
   _________________________________________________________________________

   Procedure Silence;
   _________________________________________________________________________

   Procedure Beep (waveLength: MicroSeconds; duration: MilliSeconds);
   _________________________________________________________________________

   Routine:    Volume
   Arguments:    D0 (output)  --  The speaker volume (0 to 7) (word)
   Function:   Return the speaker volume.
   _________________________________________________________________________

   Routine:    SetVolume
   Arguments:    D0 (input)   --  speaker volume (0 to 7) (word)
   Function:   Set the speaker volume.
   _________________________________________________________________________

   Routine:    Noise
   Arguments:    D0 (input)   --  wavelength in mircoseconds (0-8191)
   Function:   Produce a continuous square wave tone from the speaker.
   _________________________________________________________________________

   Routine:    Silence
   Arguments:    none
   Function:   Silence the speaker.
   _________________________________________________________________________

   Routine:    Beep
   Arguments:    D0 (input)   --  wavelength in mircoseconds (0-8191)
                 D1 (input)   --  duration in milliseconds (long)
   Function:   Produce a square wave tone from the speaker for a
               specified number of milliseconds.
   _________________________________________________________________________


^bp
7.0  The Keyboard

The routines below provide an interface to the keyboard, the keypad, the mouse
button and plug, the disk inserted switches, the diskette buttons and insertion
switches, and the power switch.  Two interfaces are provided, a pollable keyboard
state and a queue of keyboard events.

Three physical keyboard layouts are defined, the "Old US Layout" (with 73 keys
on the main keyboard and numeric keypad),  the "Final US Layout" (76 keys) and
the "European Layout" (77 keys).  Each key has been assigned a keycode, which
uniquely identifies the key.  Keycode values range from 0 to 127.  The matrix
below defines the keycodes for the "Final US Layout", using the legends from
the US Keyboard.  The "Old US Layout" has three less keys. |\, Alpha-Enter,
and Right-Option are not on the old keyboard. The "European Layout" has one
additional key, ><, with a keycode of $43.

Two keys on the "Old US Layout" generate keycodes different from the corresponding
keys on the "Final US Layout".  To aid in campatibility, software changes the
keycode for ~` from $7C to $68, and the keycode for R-Option from $68 to $4E.


        high   000     001     010     011     100     101     110     111
                0       1       2       3       4       5       6       7
   low

   0000  0                    Clear            _ -     ( 9      E       A

   0001  1    Disk 1            -              + =     ) 0     ^ 6     @ 2
              Inserted
   0010  2    Disk 1         + Left            | \      U      & 7     # 3
              Button
   0011  3    Disk 2         * Right                    I      * 8     $ 4
              Inserted
   0100  4    Disk 2            7               P       J      % 5     ! 1
              Button
   0101  5    Parallel          8             Backsp    K       R       Q
              Port
   0110  6    Mouse             9             Alpha    { [      T       S
              Button                          Enter
   0111  7    Mouse           / Up                     } ]      Y       W
              Plug
   1000  8    Power             4             Return    M      ~ `     Tab
              Button
   1001  9                      5               0       L       F       Z

   1010  A                      6                      : ;      G       X

   1011  B                   , Down                    " '      H       D

   1100  C                      .              ? /     SPACE    V     Left
                                                                      Option
   1101  D                      2               1      < ,      C     Caps
                                                                      Lock
   1110  E                      3             Right    > .      B     Shift
                                              Option
   1111  F                    Enter                     O       N     Command




^ne 10
7.1  Keyboard Identification

Lisa support a host of different keyboards.  Each keyboard has three major
attributes: 1) manufacturer, 2) physical layout, and 3) keycap legends.
The chart below describes how these three attributes are combined to form
a keyboard identification number.  The keyboards self identify when the
machine is turned on and when a new keyboard is attached.  Routine Keyboard
returns the identification number of the keyboard currently attached.  Routines
Legends and SetLegends provide a means of pretending to have different legends,
without physically replacing the keyboard.


Keyboard identification numbers:

          7       6       5       4       3       2      1       0
       ---------------------------------------------------------------
      | manufacturer  |    Layout     |         Keycap Legends        |
       ---------------------------------------------------------------

   Manufacturer:

       00  --  APD (i.e. TKC)
       01  --
       10  --  Keytronics

   Layout:

       00  --  Old US (73 keys)
       01  --
       10  --  European (77 keys)
       11  --  Final US (76 keys)

   Layout/Legends:

       0F  --  Old US

       26  --  Swiss-German  (proposed)
       27  --  Swiss-French  (proposed)
       28  --  Portugese     (proposed)
       29  --  Spanish       (proposed)
       2A  --  Danish        (proposed)
       2B  --  Swedish
       2C  --  Italian
       2D  --  French
       2E  --  German
       2F  --  UK

       3C  --  APL           (proposed)
       3D  --  Canadian      (proposed)
       3E  --  US-Dvorak
       3F  --  Final US



   _________________________________________________________________________

   Function  Keyboard: KeybdId;
   _________________________________________________________________________

   Function  Legends: KeybdId;
   _________________________________________________________________________

   Procedure SetLegends (id: KeybdId);
   _________________________________________________________________________

   Routine:    Keyboard
   Arguments:    D0 (output)  --  keyboard identification (integer)
   Function:   Return the keyboard identification number of the actual
               keyboard.
   _________________________________________________________________________

   Routine:    Legends
   Arguments:    D0 (output)  --  keyboard layout/legends (integer)
   Function:   Return the keyboard layout/legends code.  The layout/legends
               are determined by plugging in a keyboard or calling SetLegends,
               whichever is most recent.
   _________________________________________________________________________

   Routine:    SetLegends
   Arguments:    D0 (input)   --  keyboard layout/legends (integer)
   Functions:  Modify the keyboard mapping to match the specified set of
               keyboard legends.  The new mapping will be overridden by
               a subsequent call to SetLegends, or by plugging in an actual
               keyboard.
   _________________________________________________________________________



^ne 5
7.2  Keyboard State

Low level access to the keyboard is provided through a pollable keyboard state.
This state information is based on physical keycodes defined above.  Routine
KeyIsDown returns the position of a single specified key.  Routine KeyMap returns an
128-bit map, one bit for each key.  A zero indicates the key is up, a one indicates
down.  For the mouse plug, a zero indicates unplugged, a one indicates plugged in.
Certain keys are not pollable; the corresponding bits will always be zero.  These
keys are disk 1 inserted, disk 1 button, disk 2 inserted, disk 2 button, parallel
port, and power switch.  The parallel port and mouse plug keys are unreliable
across reboots and older hardware.

   _________________________________________________________________________

   Function  KeyIsDown (key: KeyCap): Boolean;
   _________________________________________________________________________

   Procedure KeyMap (var keys: KeyCapSet);
   _________________________________________________________________________

   Routine:    KeyIsDown
   Arguments:    D0 (input)   --  keycode (integer)
                 D1 (output)  --  key position, 0=up, 1=down (integer)
   Function:   Return the position of the key specified by keycode.
   _________________________________________________________________________

   Routine:    KeyMap
   Arguments:    D0 (output)  --  state bits 0 (low-order) to 31
                 D1 (output)  --  state bits 32 (low-order) to 63
                 D2 (output)  --  state bits 64 (low-order) to 95
                 D3 (output)  --  state bits 96 (low-order) to 127
   Function:   Return the current keyboard state as an 128-bit map,
               one bit for each key.  A 0 indicates the key is up, a
               1 indicates down.  Note carefully the order of the bits,
               it's not obvious.
   _________________________________________________________________________

^ne 10
7.3  Keyboard Events

The hardware interface provides two keyboard input queues, one corresponding to
each of the two displays.  When the primary (graphics) display is visible, input
goes into the primary input queue.  Similiarly, when the alternate (debugging)
display is visible, input goes into the  alternate input queue.  Initially input
is directed into the primary queue.  The user can toggle between the two queues
(and displays) by typing <Option-Toggle> (hold down Option while typing the
Toggle key defined by routine SetToggleKey).  The <Option-Toggle> combination
does not generate an event.  Programs can toggle between the two displays using
routine ScreenKeybd and SetScreenKeybd.

The events in the input queues are generally key down transitions.  Each event
contains the following information:

   keycode  --  physical key
   ascii    --  ascii interpretation of this key
   state    --  caps-lock, shift, option, command, mouse button and repeat
   mouseX   --  X-coordinate of the mouse when the key was pressed
   mouseY   --  Y-coordinate of the mouse when the key was pressed
   time     --  value of the millisecond timer when the key was pressed


Keycode -- Keycodes are defined above for the Existing Keyboard Layout.

Ascii -- The ascii interpretation of keys depends on the state of the caps-lock,
shift and option keys.  Six interpretations are associated with each different
keyboard layout:

   normal
   caps-lock
   shift or (shift and caps-lock)

   alternate
   alternate with caps-lock
   alternate with shift or (shift and caps-lock)

In most cases the ascii value returned is obvious.  The table below lists the cases
that aren't so obvious.

   $00  (NUL)   Disk 1 Inserted
   $00  (NUL)   Disk 1 Button
   $00  (NUL)   Disk 2 Inserted
   $00  (NUL)   Disk 1 Button
   $00  (NUL)   Power Button
   $00  (NUL)   Mouse Button (down)
   $00  (NUL)   Mouse Plug (in)
   $01  (SOH)   Mouse Button (up)
   $01  (SOH)   Mouse Plug (out)
   $03  (ETX)   Enter
   $08  (BS)    BackSpace
   $09  (HT)    Tab
   $0D  (CR)    Return
   $1B  (ESC)   Clear
   $1C  (FS)    Left
   $1D  (GS)    Right
   $1E  (RS)    Up
   $1F  (US)    Down
   $20  (SP)    Space

State -- A 16-bit word is used to return the state of several keys with each event.
Each bit represents one or more keys, a zero indicates that all of the keys are up,
a one indicates that at least one of the keys is down.  An additional bit indicates,
if it is a one, that the event was generated by repeating the previous event.  The
following bits of state are currently assigned:

   bit 0:  caps-lock
   bit 1:  left or right shift
   bit 2:  left or right option
   bit 3:  command
   bit 4:  mouse button
   bit 5:  this event is a repeat


Certain keys never generate events.  These keys are caps-lock, both shift keys,
option keys, and the command keys.  The <Option-Toggle> combination, used to
toggle between the two input queues (and displays) does not generate an event.  The
mouse button generates events on both the down and up transitions.  Down transitions
have as ascii value of 0, up transitions 1.  The mouse plug also generates two
different events.  When the mouse is plugged in an event with an ascii value of 0
is returned, when it is unplugged a value of 1 is returned.

Functions KeybdPeek and AltKeyPeek are used to examine events in the keyboard queues,
without removing them from the queue.  The first input parameter indicates whether
repeats are desired.  The second parameter is the queue index.  The first output
parameter indicates whether the specified queue entry  contains an event. To examine
an entire queue, first call KeybdPeek (or AltKeyPeek) with a queue index of 1.  If
an event is returned, call it again with a queue index of 2, etc.

Functions KeybdEvent and AltKeyEvent are used both to determine if a keyboard event
is available, and to return the event if one is available.  The event is removed
from the queue. The functions return a boolean result which is true if an event is
returned.  A parameter to KeybdEvent (and AltKeyEvent) is used to indicate if the
caller will accept repeated events on this call.  A second parameter indicates if
the functions should wait for an event if one is not immediately available.

   _________________________________________________________________________

   Function  KeybdPeek (repeats: Boolean; index: KeybdQIndex;
      var event: KeyEvent): Boolean;
   _________________________________________________________________________

   Function  AltKeyPeek (repeats: Boolean; index: KeybdQIndex;
      var event: KeyEvent): Boolean;
   _________________________________________________________________________

   Function  KeybdEvent (repeats: Boolean; wait: Boolean;
      var event: KeyEvent): Boolean;
   _________________________________________________________________________

   Function  AltKeyEvent (repeats: Boolean; wait: Boolean;
      var event: KeyEvent): Boolean;
   _________________________________________________________________________

   Routine:    KeybdPeek
   Arguments:    D0 (input)   --  0=no repeats, else=repeats ok (byte)
                 D1 (input)   --  keyboard queue index: 1,2,3... (integer)
                 D0 (output)  --  0=no event, 1=event returned (integer)
                 D1 (output)  --  keycode (byte)
                 D2 (output)  --  ascii value (byte)
                 D3 (output)  --  shift key state (word)
                 D4 (output)  --  mouseX (word)
                 D5 (output)  --  mouseY (word)
                 D6 (output)  --  millisecond timer value (long)
   Function:   Return an event from the primary keyboard event queue, without
               removing it from the queue. Repeats will be generated if the
               repeat parameter is non-zero.  An event is returned if the
               specified queue entry contains an event. The first output
               parameter is 0 if no event is being returned, and 1 if an
               event is returned.
   _________________________________________________________________________

   Routine:    AltKeyPeek
   Arguments:    D0 (input)   --  0=no repeats, else=repeats ok (byte)
                 D1 (input)   --  keyboard queue index: 1,2,3... (integer)
                 D0 (output)  --  0=no event, 1=event returned (integer)
                 D1 (output)  --  keycode (byte)
                 D2 (output)  --  ascii value (byte)
                 D3 (output)  --  shift key state (word)
                 D4 (output)  --  mouseX (word)
                 D5 (output)  --  mouseY (word)
                 D6 (output)  --  millisecond timer value (long)
   Function:   Return an event from the alternate keyboard event queue, without
               removing it from the queue. Repeats will be generated if the
               repeat parameter is non-zero.  An event is returned if the
               specified queue entry contains an event. The first output
               parameter is 0 if no event is being returned, and 1 if an
               event is returned.
   _________________________________________________________________________

   Routine:    KeybdEvent
   Arguments:    D0 (input)   --  0=no repeats, else=repeats ok (byte)
                 D1 (input)   --  0=don't wait, else=wait for event (byte)
                 D0 (output)  --  0=no event, 1=event returned (integer)
                 D1 (output)  --  keycode (byte)
                 D2 (output)  --  ascii value (byte)
                 D3 (output)  --  shift key state (word)
                 D4 (output)  --  mouseX (word)
                 D5 (output)  --  mouseY (word)
                 D6 (output)  --  millisecond timer value (long)
   Function:   Return the next event from the primary keyboard event queue.
               Repeats will be generated iff the repeat parameter is non-zero.
               The first output parameter is 0 if no event is being returned,
               and 1 if an event is returned.
   _________________________________________________________________________

   Routine:    AltKeyEvent
   Arguments:    D0 (input)   --  0=no repeats, else=repeats ok (byte)
                 D1 (input)   --  0=don't wait, else=wait for event (byte)
                 D0 (output)  --  0=no event, 1=event returned (integer)
                 D1 (output)  --  keycode (byte)
                 D2 (output)  --  ascii value (byte)
                 D3 (output)  --  shift key state (word)
                 D4 (output)  --  mouseX (word)
                 D5 (output)  --  mouseY (word)
                 D6 (output)  --  millisecond timer value (long)
   Function:   Return the next event from the alternate keyboard event queue.
               Repeats will be generated iff the repeat parameter is non-zero.
               The first output parameter is 0 if no event is being returned,
               and 1 if an event is returned.
   _________________________________________________________________________



7.4  Dead Key Diacriticals

Many languages employ diacritical marks on certain letters.  Several of the required
diacritical mark, letter combinations appear on European keyboards, but others do not.
The combinations shown in the table below may be typed as a two key sequence, by first
typing the dead key diacritical (which has no immediate effect), and then typing the
letter.  Dead key diacriticals appear on keyboard legends as the diacritical mark over
a dotted square.

       circumflex    ^   --                  
       grave accent  `   --                  
       tilde         ~   --               
       acute accent     --                 
       umlaut           --                

A dead key diacritical followed by a letter which appears in the table above yields
the corresponding character.  The event that is generated contains the keycode,
state, mouse location and time that correspond to the letter, but the ascii value
of the letter-diacritical combination.  A dead key diacritical followed by a space
yields just the diacritical mark.  The event contains the keycode, state, mouse
location and time corresponding to the space, but the ascii value of the diacritical
mark.  Finally, a dead key diacritical followed by any other character (i.e. not a
defined letter or space) yields both the diacritical mark and the following character.

       diacritical, defined letter   -->  foreign character
       diacritical, space            -->  diacritical
       diacritical, other character  -->  diacritical, other character



^ne 5
7.5  Repeats

Certain keys, if held down for an extended period of time, may generate multiple
events (repeats).  Several conditions must all be satisfied before a repeat is
generated.  These conditions are as follows:

    1)  KeybdPeek, AltKeyPeek, KeybdEvent or AltKeyEvent is called with
        repeatsDesired true.
    2)  The specified keyboard event queue is empty.
    3)  The key returned in the last event is still down.
    4)  No down transitions have occurred since the last event.
    5)  The key is repeatable.
    6)  Enough time has elapsed.

All keys are repeatable, with the exception of caps-lock, shifts, options, command,
disk 1 inserted, disk 1 button, disk 2 inserted, disk 2 button, parallel port, mouse
button, mouse plug, and the power button.

Repeats generate events with the following attributes:

   keycode  --  original keycode
   ascii    --  original ascii interpretation
   state    --  original position of the caps-lock, shift, etc.
   mousePt  --  revised mouse location
   time     --  revised value of the millisecond timer

^ne 5
The repeat rates can be read and set by calls to RepeatRate and SetRepeatRate.
The rates include an initial delay, which occurs prior to the first repetition,
and a subsequent delay, prior to additional repetitions.  They are both in units
of milliseconds.  The default repeat rates are 400 milliseconds initially and 100
milliseconds subsequently.

   _________________________________________________________________________

   Procedure RepeatRate (var initial: MilliSeconds;
      var subsequent: MilliSeconds);
   _________________________________________________________________________

   Procedure SetRepeatRate (initial: MilliSeconds;
      subsequent: MilliSeconds);
   _________________________________________________________________________

   Routine:    RepeatRate
   Arguments:    D0 (output)  --  initial delay in milliseconds (long)
                 D1 (output)  --  subsequent delay in milliseconds (long)
   Function:   Return the initial and subsequent repeat delays.
   _________________________________________________________________________

   Routine:    SetRepeatRate
   Arguments:    D0 (input)   --  initial delay in milliseconds (long)
                 D1 (input)   --  subsequent delay in milliseconds (long)
   Function:   Set the initial and subsequent repeat delays.
   _________________________________________________________________________



^ne 5
7.6  Pseudo-Keys

The disk insertion switches, the disk buttons and the power button are detected in
drivers other than the normal keyboard driver.  The drivers which detect these
switches and buttons must call routine KeyPushed each time a pseudo-key is pressed.
KeyPushed is passed a keycode, defined as follows:

    01  --  Disk 1 Inserted
    02  --  Disk 1 Button
    03  --  Disk 2 Inserted
    04  --  Disk 2 Button

   _________________________________________________________________________

   Procedure KeyPushed (key: KeyCap);
   _________________________________________________________________________

   Routine:    KeyPushed
   Arguments:    D0 (input)   --  keycode (integer)
   Function:   Indicate that the psuedo-key identified by keycode has
               been pressed.
   _________________________________________________________________________



^ne 15
7.7  NMI Key

It is possible to program a specific keyboard key to generate NMI (non-
maskable interrupt) rather than the character it normally generates.  The
key is specified by it's keycode, defined above.  If no NMI key is desired,
specify a keycode of zero.  The routines below return the keycode of the
current NMI key, and program a new NMI key.  Initially no NMI key has been
programmed.

   _________________________________________________________________________

   Function  NMIKey: KeyCap;
   _________________________________________________________________________

   Procedure SetNMIKey (key: KeyCap);
   _________________________________________________________________________

   Routine:    NMIKey
   Arguments:    D0 (output)  --  keycode (integer)
   Function:   Return the keycode of the current NMI key.
   _________________________________________________________________________

   Routine:    SetNMIKey *
   Arguments:    D0 (input)   --  keycode (integer)
   Function:   Program the specified key to generate NMI.
   _________________________________________________________________________



7.8  Toggle Key

The user can toggle between the primary and alternate screen/keyboard by
typing <Option-Toggle>.  The Toggle key is defined programmatically by
specifying it's keycode, defined above.  If no Toggle key is desired,
specify a keycode of zero.  The routines below return the keycode of the
current Toggle key, and program a new Toggle key.  Initially no Toggle key
is defined.

   _________________________________________________________________________

   Function  ToggleKey: KeyCap;
   _________________________________________________________________________

   Procedure SetToggleKey (key: KeyCap);
   _________________________________________________________________________

   Routine:    ToggleKey
   Arguments:    D0 (output)  --  keycode (integer)
   Function:   Return the keycode of the current Toggle key.
   _________________________________________________________________________

   Routine:    SetToggleKey
   Arguments:    D0 (input)   --  keycode (integer)
   Function:   Set the alternate screen/keyboard Toggle key.
   _________________________________________________________________________



^ne 25
8.0  The Microsecond Timer

The microsecond timer simulates a continuously running 32-bit counter which is
incremented every microsecond.  The timer is reset to 0 each time the machine
is booted.  The timer changes sign about once every 35 minutes, and rolls over
every 70 minutes.

The microsecond timer is designed for performance measurements.   It has a
resolution of 2 microseconds.  Calling MicroTimer from Pascal takes takes about
135 microseconds.  Note that interrupt processing will have a major effect on
microsecond timings.

   _________________________________________________________________________

   Function  MicroTimer: Milliseconds;
   _________________________________________________________________________

   Routine:    MicroTimer *
   Arguments:    D0 (output)  --  microsecond timer value (long)
   Function:   Return the current value of the microsecond timer.
   _________________________________________________________________________



^ne 10
9.0  The Millisecond Timer and Alarms

The millisecond timer simulates a continuously running 32-bit counter which is
incremented every millisecond.  The timer is reset to 0 each time the machine is
booted.  The timer changes sign about once every 25 days, and rolls over every 7
weeks.

The millisecond timer is designed for timing user interactions such as mouse clicks
and repeat keys.  It can also be used for performance measurements, assuming that
millisecond resolution is sufficient.

Twenty independent alarms are associated with the millisecond timer.  These alarms
are dynamically assigned to users, associating each alarm with a user ALARM routine.
Alarms should be returned when no longer needed.  The alarms have a 10 millisecond
resolution.

Once assigned, an alarm can be set to a specific value of the millisecond timer
(absolute setting), or to a specified number of milliseconds in the future (relative
setting).  When the timer reaches the alarm's setting, the user supplied ALARM
routine associated with the alarm is called.  If, when an alarm is set, the alarm
setting is 'in the past', the alarm goes off within 10 milliseconds.  (In this
context, 'in the past' means any time in the last 25 days).  Each of the alarms
remembers only one setting.  Resetting an alarm causes it to disregard any previous
setting.

The user supplied ALARM routines run as interrupt handlers.  Interrupts at priority
levels 1-6 are disabled during their execution.  To guarentee proper response to
interrupts, they should complete their processing within 1-2 milliseconds.  The
alarm routines may lower the interrupt priority level, and need not preserve the
registers.

Beware if your ALARM routine is written in Pascal.  You must guarantee that the
routine will be memory resident when the alarm goes off.  The alarm routine will
run on the system stack, and must establish its own global environment (A5).

   _________________________________________________________________________

   Function  Timer: Milliseconds;
   _________________________________________________________________________

   Procedure AlarmAssign (var alarm: AlarmNumber; routine: LogicalAddress);
   _________________________________________________________________________

   Procedure AlarmReturn (alarm: AlarmNumber);
   _________________________________________________________________________

   Procedure AlarmAbsolute (alarm: AlarmNumber; time: Milliseconds);
   _________________________________________________________________________

   Procedure AlarmRelative (alarm: AlarmNumber; delay: Milliseconds);
   _________________________________________________________________________

   Procedure AlarmOff (alarm: AlarmNumber);
   _________________________________________________________________________

   Routine:    Timer *
   Arguments:    D0 (output)  --  millisecond timer value (long)
   Function:   Return the current value of the millisecond timer.
   _________________________________________________________________________

   Routine:    ALARM  (user routine)
   Arguments:    none
   Function:   User supplied routine which is called when one of the
               millisecond timer's alarms goes off.
   _________________________________________________________________________

   Routine:    AlarmAssign
   Arguments:    D0 (output)  --  alarm number (integer)
                 A0 (input)   --  address of ALARM (address)
   Function:   Assign an alarm number to the caller.  Associate the
               user ALARM routine with this alarm.  An alarm number of
               0 indicated that all alarms are currently allocated.
   _________________________________________________________________________

   Routine:    AlarmReturn
   Arguments:    D0 (input)   --  alarm number (integer)
   Function:   Return an alarm.  This alarm may then be assigned to
               another user.
   _________________________________________________________________________

   Routine:    AlarmAbsolute
   Arguments:    D0 (input)   --  alarm number (integer)
                 D1 (input)   --  milliseconds (long)
   Function:   Set an alarm.  When the millisecond timer reaches the
               alarm setting, the user routine ALARM associated with
               this alarm will be called.
   _________________________________________________________________________

   Routine:    AlarmRelative
   Arguments:    D0 (input)   --  alarm number (integer)
                 D1 (input)   --  milliseconds (long)
   Function:   Set an alarm to the curret time plus a specified number
               of milliseconds.  When the millisecond timer reaches
               the alarm setting, the user routine ALARM associated
               with this alarm will be called.
   _________________________________________________________________________

   Routine:    AlarmOff
   Arguments:    D0 (input)   --  alarm number (integer)
   Function:   Disable an alarm.
   _________________________________________________________________________




^bp
10.0  Date and Time

The current date and time is available as a set of 16-bit integers which represent
the year, day, hour, minute and second.  The date and time are based on the hardware
clock/calendar.  This restricts dates to the years 1980-1995.  The clock/calendar
continues to operate during soft power off, and for brief periods on battery backup
if the machine is unplugged.  If the clock/calendar hasn't been set since the last
loss of battery power, the date and time will be midnight prior to January 1, 1980.
Setting the date and time also sets the clock/calendar and time stamp described below.
Conversions from the date and time format to the time stamp and clock/calendar formats
are provided.

   _________________________________________________________________________

   Procedure DateTime (var date: DateArray);
   _________________________________________________________________________

   Procedure SetDateTime (date: DateArray);
   _________________________________________________________________________

   Procedure DateToTime (date: DateArray; var time: Seconds);
   _________________________________________________________________________

   Routine:    DateTime *
   Arguments:    D0 (output)  --  year    1980..1995 (integer)
                 D1 (output)  --  day         1..366 (integer)
                 D2 (output)  --  hour         0..23 (integer)
                 D3 (output)  --  minute       0..59 (integer)
                 D4 (output)  --  second       0..59 (integer)
   Function:   Return the current data and time.
   _________________________________________________________________________

   Routine:    SetDateTime *
   Arguments:    D0 (input)   --  year    1980..1995  (integer)
                 D1 (input)   --  day         1..366 (integer)
                 D2 (input)   --  hour         0..23 (integer)
                 D3 (input)   --  minute       0..59 (integer)
                 D4 (input)   --  second       0..59 (integer)
   Function:   Set the current data and time.
   _________________________________________________________________________

   Routine:    DateToTime
   Arguments:    D0 (input)   --  year    1901..2030 (integer)
                 D1 (input)   --  day         1..366 (integer)
                 D2 (input)   --  hour         0..23 (integer)
                 D3 (input)   --  minute       0..59 (integer)
                 D4 (input)   --  second       0..59 (integer)
                 D0 (output)  --  number of seconds since midnight prior to
                                    1 January 1901 (unsigned long)
   Function:   Convert from date and time format to time stamp format.
   _________________________________________________________________________

   Routine:    DateToClock
   Arguments:    D0 (input)   --  year    1980..1995  (integer)
                 D1 (input)   --  day         1..366 (integer)
                 D2 (input)   --  hour         0..23 (integer)
                 D3 (input)   --  minute       0..59 (integer)
                 D4 (input)   --  second       0..59 (integer)
                 D0 (output)  --  high order word of clock (integer)
                 D1 (output)  --  low order two words of clock (long)
   Function:   Convert from date and time format to clock/calendar format.
   _________________________________________________________________________




^ne 10
11.0  Time Stamp

The current date and time is also available as a 32-bit unsigned integer which
represents the number of seconds since the midnight prior to 1 January 1901.  This
time stamp will roll over once every 135 years.  Beware - for dates beyond the mid
1960's the sign bit is set.  The time stamp is based on the hardware clock/calendar.
This clock continues to operate during soft power off, and for brief periods on
battery backup if the machine is unplugged.  If the clock/calendar hasn't been set
since the last loss of battery power, the date and time will be midnight prior to
January 1, 1980. Setting the time stamp also sets the date and time and the
clock/calendar described below.  Since the clock/calendar is restricted to 1980-1995,
the time stamp is also restricted to this range.  Conversions from the time stamp
format to the date and time and clock/calendar formats are provided.

   _________________________________________________________________________

   Function  TimeStamp: Seconds;
   _________________________________________________________________________

   Procedure SetTimeStamp (time: Seconds);
   _________________________________________________________________________

   Procedure TimeToDate (time: Seconds; var date: DateArray);
   _________________________________________________________________________

   Routine:    TimeStamp *
   Arguments:    D0 (output)  --  number of seconds since midnight prior
                                    to 1 January 1901 (unsigned long)
   Function:   Return the current time stamp.
   _________________________________________________________________________

   Routine:    SetTimeStamp *
   Arguments:    D0 (input)   --  number of seconds since midnight prior
                                    to 1 January 1901 (unsigned long)
   Function:   Set the current time stamp.
   _________________________________________________________________________

   Routine:    TimeToDate
   Arguments:    D0 (input)   --  number of seconds since midnight prior
                                    to 1 January 1901 (unsigned long)
                 D0 (output)  --  year    1901..2030 (integer)
                 D1 (output)  --  day         1..366 (integer)
                 D2 (output)  --  hour         0..23 (integer)
                 D3 (output)  --  minute       0..59 (integer)
                 D4 (output)  --  second       0..59 (integer)
   Function:   Convert from time stamp format to date and time format.
   _________________________________________________________________________

   Routine:    TimeToClock
   Arguments:    D0 (input)   --  number of seconds since midnight prior
                                    to 1 January 1901 (unsigned long)
                 D0 (output)  --  high order word of clock (integer)
                 D1 (output)  --  low order two words of clock (long)
   Function:   Convert from time stamp format to clock/calendar format.
   _________________________________________________________________________



^ne 10
12.0  Clock and Calendar

The hardware maintains a clock/calendar.  The clock has a resolution of a tenth of a
second, and rolls over every 16 years.  The clock continues to operate during soft
power off, and can operate for brief periods on battery backup if the machine is
unplugged.

The clock/calendar is packed into six bytes as follows:

    0000yyyy dddddddd  ddddhhhh hhhhmmmm  mmmmssss sssstttt

where y*4 represents the year (1980=0), d*12 the day, h*8 the hour, m*8 minutes, s*8
seconds, and t*4 tenths of seconds.  The year is in binary format; all other fields
are stored in binary coded decimal.

If the clock/calendar hasn't been set since the last loss of battery power, the
bit pattern 0FFF FFFF FFFF will be returned.

   _________________________________________________________________________

   Routine:    Clock *
   Arguments:    D0 (output)  --  high order word of clock (integer)
                 D1 (output)  --  low order two words of clock (long)
   Function:   Return the current date and time in clock/calendar format.
   _________________________________________________________________________

   Routine:    SetClock *
   Arguments:    D0 (input)   --  high order word of clock (integer)
                 D1 (input)   --  low order two words of clock (long)
   Function:   Set the hardware clock/calendar.
   _________________________________________________________________________

   Routine:    ClockToDate
   Arguments:    D0 (input)   --  high order word of clock (integer)
                 D1 (input)   --  low order two words of clock (long)
                 D0 (output)  --  year    1980..1995 (integer)
                 D1 (output)  --  day         1..366 (integer)
                 D2 (output)  --  hour         0..23 (integer)
                 D3 (output)  --  minute       0..59 (integer)
                 D4 (output)  --  second       0..59 (integer)
   Function:   Convert from clock/calendar format to date and time format.
   _________________________________________________________________________

   Routine:    ClockToTime
   Arguments:    D0 (input)   --  high order word of clock (integer)
                 D1 (input)   --  low order two words of clock (long)
                 D0 (output)  --  number of seconds since midnight prior
                                    to 1 January 1901 (unsigned long)
   Function:   Convert from clock/calendar format to time stamp format.
   _________________________________________________________________________



