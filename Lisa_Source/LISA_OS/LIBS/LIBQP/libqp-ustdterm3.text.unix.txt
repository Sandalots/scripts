{File USTDTERM3.TEXT}          {part of standard terminal unit, standard terminal functions}


{Note :
 All terminal lines have initial size of 3+maxtextline, this does not include space for charattr. When
 ChangeAttributes is called, it will resize the termline object to include space for new char attr. Note
 that charattr field must start from even byte, so if line length (tmline.ch[0]) is even, should bypass one
 byte when the tmline is moved to buffer and the slack is removed.

 If there is no charattr, tmline.size is either 3+maxtextline if there is slack, or 3+tmline.ch[0] (line
 length) if there is no slack (in buffer).  If there is charattr, tmline.size is < 0, it is either
 -(3+maxtextline) if there is slack, or -(3+tmline.ch[0] (linelength)) if there is no slack. The actual # of
 bytes for lines space with slack are 3+maxtextline if no charattr, and 3+maxtextline+2 (the attrsize field)
 + attrsize * SIZEOF (TRAttributes) if there is charattr. (We could use a bit in the size field to indicate
 whether there is charattr or not, but then DrawTmLine would be slower in getting the real size.
}



{$S sQPortRes}                               {resident code segment - writeln and readln}

{----------------------------------------------- TTermLine -------------------------------------------------}

METHODS OF TTermLine {SUBCLASS OF TObject };

    FUNCTION  {TTermLine.}CREATE {: TTermLine};
    BEGIN                                    {no subclass, always creates object, so no need to pass object}
        {$IFC fTrace}BP(20);{$ENDC}
        SELF := NewDynObject (Consterm.heap, THISCLASS, 0);      {THISCLASS has the size already}
        WITH SELF DO
          BEGIN
            size := 3 + maxtextline;
            ch [0] := CHR (0);
          END;
        {$IFC fTrace}EP;{$ENDC}
    END;  {TStdTerm.CREATE}

{$S sQPortInit}                              {initialization code segment}
END;  {METHODS OF TTermLine}

{$S sQPortRes}                               {resident code segment - writeln and readln}



{----------------------------------------------- BindDocheap -----------------------------------------------}

PROCEDURE BindDocheap;
                {bind document first before accessing window, or anything on doc heap}
                {All TStdTerm's interface methods must call this first}
VAR docManager : TTermDocManager;
BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    docManager := TTermDocManager (docList.First);
    docManager.Bind;
                               {could use window := DocManager.windowWithId(ORD(who))
                                to get window, then no need to have window field in TStdTerm}
    {$IFC fTrace}EP;{$ENDC}
END;  {BindDocheap}



PROCEDURE CkPutAway;               {to be called after process.ObeyEvents call to check put away}
BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    IF docList.Size = 0 THEN                  {got put away}
      BEGIN
        amDying := TRUE;                      {so that we dont go to the ToolKit debugger}
        process.complete (TRUE);              {will not return}
      END;
    {$IFC fTrace}EP;{$ENDC}
END;  {CkPutAway}



FUNCTION NotToWait {: BOOLEAN};           {for ObeyEvents until idle, used in VWrite, Vread}
BEGIN
    NotToWait := TRUE;
END;




{Internal routines}


{$S sQPortInit}                         {initialization code segment}

{----------------------------------------------- InitScreen ------------------------------------------------}

PROCEDURE InitScreen;         {Called by DocManager.Open after all terminal subclass has being created}
VAR i    : INTEGER;
    tmline : TTermLine;
    anarray : TArray;
    Finfo : FontInfo;
BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    anarray := TArray.CREATE (NIL, Consterm.heap, initbuflines, 4);
    Consterm.buffer := anarray;
    FOR i := 0 TO Consterm.maxLines-1 DO               {screen always has maxLines lines}
      BEGIN
        tmline := TTermLine.CREATE;
        Consterm.screen [i] := tmline;
      END;
(* If terminal emulator changed the defltAttr but not dfontInfo, we should not do this again, would mess up
   the viewsize.
    WITH Consterm DO
      BEGIN
 {$H-}  TextFont (defltAttr.charFont);
        GetFontInfo (Finfo); {$H+}
        WITH dfontInfo DO
          BEGIN
            leading := Finfo.leading;
            ascent := Finfo.ascent;
            descent := Finfo.descent;
            widmax := Finfo.widmax;
            WITH Finfo DO lineheight :=  leading + ascent + descent;
          END;
      END;
*)
    {$IFC fTrace}EP;{$ENDC}
END;  {InitScreen}


{$S sQPortRes}                               {resident code segment - writeln and readln}



{Internal routines, they must not call BindDocHeap and HandleEvent again.}

{----------------------------------------------- DrawTmLine --------------------------------------------------}

PROCEDURE DrawTmLine {(tmline : TTermLine)};    {Caller should do MoveTo, focus before call}
LABEL 9;
VAR pt : Point;
    tmlineptr  : QDPtr;
    precolumn, i, len : INTEGER;
    preFont   : INTEGER;
    preStyle  : Style;
    s  : PTAttributes;
    attrP : PTCharAttrs;
BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    len := ORD (tmline.ch [0]);
    IF len = 0 THEN GOTO 9;
    preFont := pdefltAttr.charFont;
    preStyle := pdefltAttr.charStyle;
    IF thePort^.txFont <> preFont THEN TextFont (preFont);
    IF thePort^.txFace <> preStyle THEN TextFace (preStyle);
    precolumn := 0;
    tmlineptr := POINTER (ORD (@tmline.ch) + 1);                 {points to the first byte of termstr - odd}

    IF tmline.size < 0 THEN                                      {has some charAttr}
      BEGIN
        IF (-tmline.size - 3) < maxtextline THEN                 {no slack in tmline}
          IF ODD (len) THEN
            attrP := POINTER (ORD (tmlineptr) + len)             {points to charAttr field - has to be even}
          ELSE
            attrP := POINTER (ORD (tmlineptr) + len + 1)         {charAttr field}
        ELSE
          attrP := POINTER (ORD (tmlineptr) + maxtextline);
        len := Min (len, pmaxColumns);
        i := 1;
        WHILE i <= attrP^.attrsize DO
          BEGIN
            s := @attrP^.charAttr [i];
            drawtext (tmlineptr, precolumn, Min (s^.beginX, len) - precolumn);
            IF preFont <> s^.chAttr.charFont THEN
              BEGIN
                preFont := s^.chAttr.charFont;
                TextFont (preFont);
              END;
            IF preStyle <> s^.chAttr.charStyle THEN
              BEGIN
                preStyle := s^.chAttr.charStyle;
                TextFace (preStyle);
              END;
            precolumn := s^.beginX;
            i := i + 1;
          END;
      END
    ELSE
        len := Min (len, pmaxColumns);

    drawtext (tmlineptr, precolumn, len - precolumn);
9:
    {$IFC fTrace}EP;{$ENDC}
END;  {DrawTmLine}



{----------------------------------------------- HiLiteCursor ----------------------------------------------}

PROCEDURE HiLiteCursor {(highTransit: THighTransit; cursorpoint : Point)};
                                   {highlight cursor position, to be called from inside the pad proc}
VAR r : Rect;
BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    IF NOT Consterm.window.IsActive THEN
      BEGIN
        IF highTransit = hOnToOff THEN highTransit := hDimToOff;
        IF highTransit = hOffToOn THEN highTransit := hOffToDim;
      END;
    SetPenState(highPen[highTransit]);

    WITH Consterm, dfontInfo DO
      BEGIN
  {$H-} IF cursorshape = blockshape THEN
          BEGIN
            WITH r DO
              BEGIN
                left := cursorpoint.h;
                top  := cursorpoint.v - ascent;
                right := cursorpoint.h + widmax;
                bottom := cursorpoint.v + descent;
              END;
            PaintRect (r);
          END
        ELSE IF cursorshape = underscoreshape THEN
          BEGIN
            MoveTo (cursorpoint.h, cursorpoint.v + descent - 1);      {so that it wont run into next line}
            PenSize (1, 1);                                           {use smallest pen size}
            Line (widmax, 0); {$H-}
          END;
      END;
    {$IFC fTrace}EP;{$ENDC}
END;  {HiLiteCursor}



{----------------------------------------------- HandleEvent ----------------------------------------------}

PROCEDURE HandleEvent;          {handle any event pending and deal with ToolKit update stuff}
                         {This is to be called by every interface method including graphPanel except Vread}
    FUNCTION WaitIfOutPutStopped : BOOLEAN;
    BEGIN
      IF docList.Size <> 0 THEN WaitIfOutPutStopped := NOT outputStopped
      ELSE WaitIfOutPutStopped := TRUE;

      (*
      IF docList.Size <> 0 THEN WaitIfOutPutStopped := NOT SELF.outputStopped
      ELSE WaitIfOutPutStopped := TRUE;
      *)
                                         {return true only if output not stopped or put away}
    END;

BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    (* didupdate := true;   *)       {so that toolkit won't update it again}
    Consterm.window.selectPanel.selection.MarkChanged;      {markchange does not care about which selection}

    Process.ObeyEvents (WaitIfOutPutStopped);
    CkPutAway;                                {no return if document got put away}

    IF qdpUsed THEN
        SetPort (qdpGPtr);          {restore graphPanel's grafport}
    {$IFC fTrace}EP;{$ENDC}
END;  {HandleEvent}




{----------------------------------------------- EmptyTmLine -------------------------------------------}

PROCEDURE EmptyTmLine (tmline : TTermLine);
BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    ResizeDynObject (tmline, SIZEOF (TTermLine));       {get rid of the attr space}
    tmline.size := 3 + maxtextline;
    {$IFC fTrace}EP;{$ENDC}
END;  {EmptyTmLine}




{----------------------------------------------- MoveScrnHandles -------------------------------------------}

PROCEDURE MoveScrnHandles (insertORdelete : TinsertORdelete; newORfreeobj : BOOLEAN;
                                                   startindex, howmany : INTEGER);
                         {Insert (expand for inserted ones) or delete (compact) handles in screen array
                          starting from startindex for howmany handles. If to insert, also delete the objeccts
                          that got moved out of the array bottom. If to delete, also create new objects to
                          fill up the screen array. Most of calls are to delete.}
VAR fromptr, toptr : pTpaoc;
    outarray : ARRAY [0..maxPosLines] OF TTermLine;
    i, j, endindex, delstart, delend : INTEGER;
    tmline : TTermLine;
BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    WITH Consterm DO
      BEGIN  {$H-}
        endindex := startindex + howmany;
        IF endindex > maxLines THEN endindex := maxLines;
        delstart := maxLines - howmany;
        IF delstart < startindex THEN
          BEGIN
            howmany := maxLines;
            delstart := 0;
          END;
        delend := maxLines - 1;
        IF insertORdelete = shDelete THEN
          BEGIN
            j := 1;
            FOR i := startindex TO endindex - 1 DO
              BEGIN
                outarray [j] := screen [i];            {collect to be deleted handles}
                J := j + 1;
              END;
            fromptr := @screen [endindex];
            toptr := @screen [startindex];
            MoveLeft (fromptr^, toptr^, (maxLines - startindex - 1)*4);            {4 bytes each per handle}
          END
        ELSE             {to insert handles}
          BEGIN
            j := 1;
            FOR i := delstart TO delend DO
              BEGIN
                outarray [j] := screen [i];            {collect to be deleted handles}
                J := j + 1;
              END;
            fromptr := @screen [startindex];
            toptr := @screen [endindex];
            MoveRight (fromptr^, toptr^, (maxLines - startindex - 1)*4);           {4 bytes each per handle}
            delstart := startindex;
            delend := endindex - 1;
          END;
      END;  {$H+}

    IF newORfreeobj THEN                                {to delete objects of the deleted handles if shDelete
                                                         or to create new objects for new handles if shInsert}
      BEGIN                                             {then reuse them to fill up the screen bottom}
        J := 1;
        FOR i := delstart TO delend DO
          BEGIN
            IF outarray [j].size < 0 THEN EmptyTmLine (outarray [j]);              {has char attr before}
            outarray [j].ch [0] := CHR (0);             {linelength}
            Consterm.screen [i] := outarray [j];
            j := j + 1;
          END;
      END
    ELSE
      IF insertORdelete = shDelete THEN
               {do not delete objects if shDelete, then create new objects to fill up the screen array bottom}
        FOR i := delstart TO delend DO
          BEGIN
            tmline := TTermLine.CREATE;
            Consterm.screen [i] := tmline;
          END
      ELSE         {do not create new objects if shInsert, then free the objects of the deleted handles}
        FOR j := 1 TO howmany DO outarray [j].Free;
    {$IFC fTrace}EP;{$ENDC}
END;  {MoveScrnHandles}



{----------------------------------------------- GetPoint --------------------------------------------------}

PROCEDURE GetPoint {(x, y : INTEGER; VAR basept : Point)}; {y is home relative}
VAR frombottom : INTEGER;
BEGIN                                    {calculate char base point from the bottom of viewRect}
    {$IFC fTrace}BP(15);{$ENDC}
    with Consterm, dfontInfo do
      BEGIN
        frombottom := maxLines - y - 1;
        basept.v := window.termPanel.view.extentLRect.bottom     {can not use vscreenRect, it is not always inited}
                                   - (lineheight * frombottom + descent + vindent);

        basept.h := hindent + x * widmax;
      END;
    {$IFC fTrace}EP;{$ENDC}
END;   {GetPoint}




{----------------------------------------------- MoveWindow ------------------------------------------------}

PROCEDURE MoveWindow;           {move window if needed to contain cursorassuming called from outside the pad}
                                {for performance, called by Vread, QPMoveCursor and DoKey only}
VAR panel : TPanel;
    minh, minv : INTEGER;
    r : LRect;

BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    WITH Consterm, dfontInfo DO
      BEGIN
        panel := window.termPanel;
        minh := 10 * widmax;                  {show at least 10 char 6 before and 3 after cursor}
        minv := 2 * lineheight;               {show at least one line above cursor}
  {$H-} SetLRect (r, 0, 0, minh, minv);
        OffsetLRect (r, Max (cursorPt.h - minh + 4*widmax, 0), cursorPt.v - (ascent + leading) - lineheight);
        panel.RevealLRect (r, minh, minv);  {$H+}
      END;
    {$IFC fTrace}EP;{$ENDC}
ENd;  {MoveWindow}



{----------------------------------------------- ChangeAttributes ------------------------------------------}

PROCEDURE ChangeAttributes (newattr : TRAttributes);        {Attributes change, to screen lines only}
LABEL 1;
TYPE PObject = ^LONGINT;
     PHandle = ^PObject;
VAR s  : PTAttributes;
    tmline : TTermLine;
    attrP : PTCharAttr;
    fromptr, toptr : pTpaoc;
    i, csize, x, nsize : INTEGER;

    PROCEDURE CopyNewAttr (index : INTEGER);
      BEGIN
        attrP^.attrsize := csize + 1;                       {inc total charAttr entries}
        s:= @attrP^.charAttr [index];                       {copy new entry to the index}
        s^.beginX := x;
        s^.chAttr := newattr;
      END;

BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    Consterm.currAttr := newattr;
    pcurrAttr := newattr;

    TextFace (newattr.charStyle);
    TextFont (newattr.charFont);
                                                   {create an entry of TAttributes with cursorx}
    tmline := Consterm.screen [Consterm.cursorXY.y];
    csize := tmline.size;
    IF csize > 0 THEN                                                 {no charattr yet}
      nsize := SIZEOF (TTermLine) + 2 + SIZEOF (TAttributes)          {2 bytes for attrsize field}
    ELSE                                                              {exist a charattr already}
      BEGIN
        attrP := POINTER (ORD (@tmline.ch) + maxtextline + 1);        {charAttr field}
        nsize := SIZEOF (TTermLine) + 2 + attrP^.attrsize * SIZEOF (TAttributes)  {current size}
                 + SIZEOF (TAttributes);                              {new charattr size}
      END;
    ResizeDynObject (tmline, nsize);                                  {get space for new entry}
    attrP := POINTER (ORD (@tmline.ch) + maxtextline + 1);            {charAttr field, for screen lines}
    IF csize > 0 THEN                                                 {no charAttr yet}
      BEGIN
        attrP^.attrsize := 0;
        tmline.size := -csize;                                        {to indicate there is a charattr}
      END;

    x := Consterm.cursorXY.x;
    csize := attrP^.attrsize;
    i := 1;
      {insert the new entry into charAttributes in the order of increasing beginX, check for duplicates}
    WHILE i <= csize DO
      BEGIN
        s := @attrP^.charAttr [i];
        IF x < s^.beginX THEN
          BEGIN                {insert new entry before i, movedown the existing ones first}
            fromptr := POINTER (ORD (s));
            toptr := POINTER (ORD (s) + SIZEOF (TAttributes));
            MoveRight (fromptr^, toptr^, (csize - i + 1) * SIZEOF (TAttributes));
            CopyNewAttr (i);
            GOTO 1;
          END
        ELSE IF x = s^.beginX THEN        {replace existing one}
               BEGIN
                 s^.chAttr := newattr;
                 GOTO 1;
               END;
        i := i + 1;
      END;
    CopyNewAttr (csize + 1);                  {insert new entry in the last one}
1:
    needChangeAttr := FALSE;
    {$IFC fTrace}EP;{$ENDC}
END;  {ChangeAttributes}




{----------------------------------------------- QPMoveCursor ----------------------------------------------}

PROCEDURE QPMoveCursor (scroll : BOOLEAN; xdistance, ydistance : INTEGER);
                                        {internal movecursor, no BindDocHeap and HandleEvent.}
VAR newx, newy, mlines, bsize, extralines, i : INTEGER;
    tvertviewsize : LONGINT;
    panel : TPanel;
    bcursorpoint : Point;
    termView  : TTermView;
    pt        : Point;
    tmline    : TTermLine;
    termSelection : TTermSelection;
    startisanchor : BOOLEAN;

    PROCEDURE MoveOnThePad {(pane: TPane)};   {will forcus in pad}
    TYPE EPattern = ARRAY [0..1] OF LONGINT;           {equ to pattern - 8 bytes}
    VAR r, grafRect : Rect;
        pnstate : PenState;
        p : ^EPattern;
        mouseLPt: LPoint;
        charXY : TCoordinate;
    BEGIN
      (*
      termSelection.QPHighlight (hOnToOff, bcursorpoint);        {dehighlight current cursor}
      *)
      HiLiteCursor (hOnToOff, bcursorpoint);           {dehighlight current cursor}
      WITH Consterm DO
       BEGIN
 {$H-}  IF scroll THEN
          IF mlines > 0 THEN                                     {move cursor down and scroll up}
            BEGIN
              IF saveBuffer THEN
                BEGIN
                                                  {erase the original gray line}
                  WITH pnstate DO
                    BEGIN
                      pnLoc.h := 0;
                      pnLoc.v := vscreenRect.top;
                      pnSize.h := 1;                   {use smallest pen size}
                      pnSize.v := 1;
                      pnMode := patXor;                {to erase}
                      pnPat  := gray;
                    END;
                  SetPenState (pnstate);
                  MoveTo (0, vscreenRect.top);
                  Line (vscreenRect.right, 0);

                  thePad.LRectToRect (panel.View.extentLRect, grafRect);
                END
              ELSE
                grafRect := vscreenRect;
              p := @thePort^.bkPat;
              IF (p^[0] + p^[1]) <> 0 THEN BackPat (white);
              ScrollRect (grafRect, 0, -dfontInfo.lineheight * mlines, workRgn);
                                                       {scroll the whole view up first}
              WITH workRgn^^, rgnBBox DO
                IF (thePad.visLRect.bottom < (vscreenRect.bottom - vindent))   {updatergn is not last line}
                   OR ((bottom - top) > dfontInfo.lineheight) THEN
                  BEGIN
                  (*
                  thePad.InvalRect (rgnBBox);          {need not update if update region is the last line}
                  *)    {try updating myself instead of calling ToolKit so that we need not swap in toolkit code}
                    mouseLPt.v := top;
                    mouseLPt.h := hindent;
                    CharPosWithPt (mouseLPt, charXY);            {find the corresponding line position}
                    GetPoint (0, charXY.y, pt);
                    WHILE pt.v - dfontInfo.ascent < bottom DO
                      BEGIN
                        i := charXY.y{ + mlines};                  {since lines are scrolled up but not
                                                                  reflected in the Consterm yet.}
                        IF (pt.v + dfontInfo.descent > top) AND (i < maxLines) THEN
                          BEGIN                                  {if whole line is in updatergn}
                            IF i < 0 THEN
                              tmline := TTermLine (Consterm.buffer.At (Consterm.buffer.size + i + 1)^)
                            ELSE tmline := Consterm.screen [i];
                            Moveto (hindent, pt.v);
                            DrawTmLine (tmline);
                          END;
                        pt.v := pt.v + dfontInfo.lineheight;
                        charXY.y := charXY.y + 1;
                      END;
                  END;
              IF saveBuffer THEN
                BEGIN
                  (*
                                                  {erase the original gray line, now in between row -1 and -2}
                  WITH pnstate DO
                    BEGIN
                      pnLoc.h := 0;
                      pnLoc.v := vscreenRect.top - dfontInfo.lineheight;
                      pnSize.h := 1;                   {use smallest pen size}
                      pnSize.v := 1;
                      pnMode := patCopy;
                      pnPat  := white;                 {to erase}
                    END;
                  SetPenState (pnstate);
                  MoveTo (0, vscreenRect.top - dfontInfo.lineheight);
                  Line (vscreenRect.right, 0);
                  *)

                  MoveTo (0, vscreenRect.top);
                  PenPat (gray);
                  Line (vscreenRect.right, 0);          {draw a gray line between screen and buffer areas}
                END;
            END;     {move cursor down and scroll up}
          GetPoint (cursorXY.x, cursorXY.y, cursorPt);
          (*
          termSelection.QPHighlight (hOffToOn, cursorPt);       {highlight current cursor}
          *)
          HiLiteCursor (hOffToOn, cursorPt);
       END;  {WITH Consterm DO}   {$H+}
    END;

BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    panel := Consterm.window.termPanel;
    termSelection := TTermSelection (panel.selection);
    WITH Consterm DO
      BEGIN
        bcursorpoint := cursorPt;
        newx := cursorXY.x + xdistance;
        newy := cursorXY.y + ydistance;
        cursorXY.x := newx;
        cursorXY.y := newy;
        IF newx < 0 THEN cursorXY.x := 0 ELSE IF newx > (maxColumns - 1) THEN cursorXY.x := maxColumns - 1;
        mlines := newy - (maxLines - 1);
        IF newy < 0 THEN cursorXY.y := 0 ELSE IF mlines > 0 THEN cursorXY.y := maxLines - 1;
                                          {if move cursor up, we dont want to scroll screen down}
      END;

    WITH Consterm DO
     BEGIN
{$H-}  IF scroll THEN
        IF mlines > 0 THEN                      {move cursor down and scroll up}
          BEGIN
            IF saveBuffer THEN
              BEGIN
                bsize := buffer.size;
                IF bsize > 0 THEN
                  BEGIN
                    extralines := bsize + newy + 1 - (viewSize - 1);
                    IF extralines > 0 THEN           {grow beyond the current view size, expand the view}
                      BEGIN
                        i := viewSize + (extralines div maxLines + 2) * maxLines;       {min 2 pages}
                        tvertviewsize := ORD4(i) * dfontInfo.lineheight + vindent;
                        IF tvertviewsize < maxint THEN      {stay in small view size}
                          BEGIN
                            viewSize := i;
                            termView := TTermView (panel.view);
                            PushFocus;                         {has to do this before Focus, and pop later}
                            Consterm.window.Focus;             {needed for ReactToPrinterChange to do thumb
                                                                position correct.}
                            SetLRect (termView.minViewLRect, 0, 0, 720, tvertviewsize);
                            termView.ReactToPrinterChange;     {toolkit will call view.SetMinViewSize}
                                                               {is this OK if we have paginated view later ?}
                            Consterm.window.Update (TRUE);     {to get the thumb position updated}
                            PopFocus;
                            GetPoint (0, 0, pt);               {locate home point}
                            SetRect (vscreenRect, pt.h, pt.v - dfontInfo.ascent - dfontInfo.leading,
                                               termView.extentLRect.right,
                                               termView.extentLRect.bottom);
                            GetPoint (cursorXY.x, cursorXY.y, cursorPt);
                            MoveWindow;                        {so that bottom view will stay shown}
                          END
                        ELSE
                          BEGIN
                            IF Consterm.bufhasroom THEN     {first time}
                              BEGIN
                                process.Stop (phBufTooBig);
                                panel.Invalidate;
                                Consterm.bufhasroom := FALSE;
                              END;
                            FOR i := 1 TO extralines DO
                              BEGIN
                                tmline := TTermLine (Consterm.buffer.First^);
                                tmline.Free;                         {have to free the buffer.First myself}
                                Consterm.buffer.DelFirst;
                              END;
                          END;
                      END;
                  END;
                FOR i := 1 TO mlines DO
                  BEGIN
                    tmline := Consterm.screen [0];
                    IF tmline.size > 0 THEN
                      BEGIN        {need not resize if there's charattr fields, otherwise has to move charattr up}
                        bsize := SIZEOF (TTermLine) - (maxtextline - ORD (tmline.ch [0])) + 1;
                                                                 {actual length + CR for lines in clipboard}
                        tmline.size := ORD (tmline.ch [0]) + 4;  {reserve one extra byte for CR in the clipline}
                        ResizeDynObject (tmline, bsize);
                      END;
                    Consterm.buffer.InsLast (@tmline);           {move lines from screen to buffer}
                    MoveScrnHandles (shDelete, FALSE, 0, 1);
                                                {delete the handles off screen top, but not the objects}
                                                {uptimize later to call this once to delete all handles}
                  END;
              END
            ELSE        { not to save lines in  buffer}
              MoveScrnHandles (shDelete, TRUE, 0, mlines);    {delete the lines off screen top}

                                                  {see if need to adjust the selection's selrange}
            IF panel.selection.kind = termselKind THEN
              BEGIN
                termSelection := TTermSelection (panel.selection);
                WITH termSelection, selRange DO
                  BEGIN
                    startisanchor := startXY.xyCoord = anchorXY.xyCoord;
                    startXY.y :=  startXY.y - mlines;
                    endXY.y := endXY.y - mlines;
                    anchorXY.y := anchorXY.y - mlines;
                    IF NOT saveBuffer THEN
                      IF (startXY.y < 0) AND (endXY.y < 0) THEN
                        termSelection := TTermSelection (termSelection.FreedAndReplacedBy (
                             TTermSelection.CREATE (NIL, Consterm.heap, panel.view, noselKind, startXY, zeroLPt)))
                      ELSE
                        BEGIN
                          IF startXY.y < 0 THEN startXY.xyCoord := 0;         {make x 0 too}
                          IF endXY.y < 0 THEN endXY.y := 0;
                          IF startisanchor THEN anchorXY := startXY ELSE anchorXY := endXY;
                        END;
                  END;
              END;
          END; {$H+}     {move cursor down and scroll up}
     END;  {WITH Consterm DO}

    panel.OnAllPadsDo (MoveOnThePad);     {will forcus in pad, takes care of multiple panes too if any}

    WITH Consterm DO
      IF (currAttr.charStyle <> defltAttr.charStyle) OR
         (currAttr.charFont <> defltAttr.charFont) THEN
        needChangeAttr := TRUE;                             {if different, need to create one}
    {$IFC fTrace}EP;{$ENDC}
END;   {QPMoveCursor}





{----------------------------------------------- CharPosWithPt ---------------------------------------------}

PROCEDURE CharPosWithPt {(mouseLPt : LPoint; VAR charXY : TCoordinate)};
                                         {find the corresponding character position}
VAR frombottom, bsize : INTEGER;
    tmline : TTermLine;
BEGIN
    {$IFC fTrace}BP(15);{$ENDC}
    WITH Consterm, dfontInfo DO
      BEGIN
        charXY.x := (mouseLPt.h - hindent) div widmax;
        frombottom := (vscreenRect.bottom - vindent - mouseLPt.v) div lineheight;
        charXY.y := maxLines - 1 - frombottom;
        IF charXY.y >= maxLines THEN charXY.y := maxLines - 1;
      END;
    IF charXY.y < 0 THEN
      BEGIN
        bsize := Consterm.buffer.size;
        IF bsize + charXY.y < 0 THEN              {above the existing lines}
          charXY.y := - bsize;                    {use the first line}
      END;
    IF charXY.y < 0 THEN
      tmline := TTermLine (Consterm.buffer.At (bsize + charXY.y + 1)^)
    ELSE tmline := Consterm.screen [charXY.y];
    IF charXY.x > ORD (tmline.ch [0]) THEN        { > linelength ?, then set to the next position}
      charXY.x := ORD (tmline.ch [0])
    ELSE IF charXY.x < 0 THEN charXY.x := 0;
    {$IFC fTrace}EP;{$ENDC}
END;  {CharPosWithPt}




{----------------------------------------------- TStdTerm --------------------------------------------------}

{TStdTerm methods, only terminal subclass can call these, so they need not call BindDocHeap and HandleEvent.}

METHODS OF TStdTerm {SUBCLASS of TObject };     {All ToolKit classes should have been initiaialized by now}
      {It can not be subclass of TTermView since the CREATE would need parameters like panel that are not
       meanful in terminal emulator which is subclass of this. Also BlankStationary would have to be
       overridden to create the correct view.
       It can not be subclass of TPasTerm either since the CREATE function needs to use newObject or subObject
       and they return TObject type, but TPasTerm is not a  subclass of TObject.}


{$S sQPortInit}                         {initialization code segment}

    FUNCTION {TStdTerm.} CREATE {(object : TObject; heap : Theap) : TStdTerm};
    VAR finfo : FontInfo;
    BEGIN
        {$IFC fTrace}BP(20);{$ENDC}
        IF object = NIL THEN
            object := NewObject (heap, THISCLASS);
        SELF := TStdTerm (object);
        WITH SELF do
         BEGIN
          window := NIL;                {during initialization}
          maxLines   := cStdMaxLines;
          maxColumns := cStdMaxColumns;
          viewSize := maxLines;       {default # lines in total view, initially 4 pages of 24 lines by 80 or 132}
                         {Terminal subclass should init maxLines and viewSize like this if they are differnet}
                                      {initial cursorPt will be at the home point, done in docManager.Open,
                                       after the subclass of TStdTerm has init the maxLines, so is linelist}
          cursorXY.xyCoord := 0;      {relative to home position}
          cursorshape := blockshape;
          saveBuffer := FALSE;
          handleApplePeriod := TRUE;     {QP will handle apple .}
          haveInputPanel    := FALSE;    {no show of input panel}
          haveTwoPanels     := FALSE;    {one panel}
          alreadyConfigured := FALSE;
          bufhasroom        := TRUE;
          wrapAround        := TRUE;
          stopOutputKey     := CHR (keyCtrS);
          startOutputKey    := CHR (keyCtrQ);
          with tabPosition do
            BEGIN
              tabSet := FALSE;
              all [1] := 0;             {0 is false}
              all [2] := 0;
              all [3] := 0;
              all [4] := 0;
              all [5] := 0;
            END;
                     {Terminal subclass should init defltAttr and dfontInfo like this if they are differnet}
          WITH defltAttr DO
            BEGIN
              charStyle := [];
              charFont := fIDLT12Text;                 {fIDLT20Text for > 80, up to 132 columns}
       {$H-}  TextFont (charFont);
              GetFontInfo (finfo); {$H+}
              maxcoltofit := (720 - hindent) div (finfo.widmax);   {max number of columns will fit in our view}
            END;
          WITH dfontInfo DO
            BEGIN
              leading := finfo.leading;
              ascent := finfo.ascent;
              descent := finfo.descent;
              widmax := finfo.widmax;
              WITH finfo DO lineheight :=  leading + ascent + descent;
            END;
          currAttr := defltAttr;
         END;

          {subclass would do
               IF object = NIL THEN
                   object := NewObject (heap, THISCLASS);
               SELF := TVT100 (TStdTerm.CREATE (object, heap));
                  and then init subclass' additional fields.      }
        {$IFC fTrace}EP;{$ENDC}
    END;  {TStdTerm.CREATE}


{$S sQPortRes}                               {resident code segment - writeln and readln}

{----------------------------------------------- TStdTerm.VWrite -------------------------------------------}

    PROCEDURE {TStdTerm.}VWrite {(VAR str : Tstr255)};     {Paslib will call this, can be overridden}
    BEGIN
        {$IFC fTrace}BP(20);{$ENDC}
        IF str [1] < ' ' THEN           {control key only allowed in the first char}
          BEGIN
            IF str [1] = CHR (keyCR) THEN QPMoveCursor (TRUE, -200, 1)       {move to next line column 1}
            ELSE SELF.CtrKeyWrite (str [1]);
          END
        ELSE
            VStrWrite (str);
        {$IFC fTrace}EP;{$ENDC}
    END;  {TStdTerm.VWrite}



{----------------------------------------------- TStdTerm.CtrKeyWrite --------------------------------------}

    PROCEDURE {TStdTerm.}CtrKeyWrite {(ctrch : CHAR)};    {Note that CR or LF is not stored in the termlines}
    LABEL 9;
    VAR panel : TPanel;
        i     : INTEGER;
        r     : Rect;
        termstrP     : PTTermStr;
        bcursorpoint, pt, endpt : Point;
        termSelection : TTermSelection;

        PROCEDURE EraseOnThePad;
        BEGIN
          termSelection.QPHighlight (hOnToOff, bcursorpoint);       {dehighlight current cursor}
          EraseRect (r);
          WITH SELF DO
           BEGIN
      {$H-} GetPoint (cursorXY.x, cursorXY.y, cursorPt);
            termSelection.QPHighlight (hOffToOn, cursorPt);         {highlight current cursor}  {$H+}
           END;  {WITH SELF}
        END;  {EraseOnThePad}

        PROCEDURE HiCursorOnThePad;
        BEGIN
          termSelection.QPHighlight (hOnToOff, bcursorpoint);       {dehighlight current cursor}
          WITH SELF DO
           BEGIN
      {$H-} GetPoint (cursorXY.x, cursorXY.y, cursorPt);
            termSelection.QPHighlight (hOffToOn, cursorPt);         {highlight current cursor} {$H+}
           END;  {WITH SELF}
        END;  {HiCursorOnThePad}

    BEGIN      {TStdTerm.CtrKeyWrite}
        {$IFC fTrace}BP(20);{$ENDC}
        BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}
        panel := SELF.window.termPanel;
        termSelection := TTermSelection (panel.selection);
        CASE ORD (ctrch) OF
          keyBELL :  Beep (2000, 200);       {Beep tone of (1/2000)*10^6 == 500 cycles/sec for 200 milliseconds }

          keyCR : VGotoxy (0, SELF.cursorXY.y);   {move cursor to first column, do not copy CR to termline}

          keyBS :                            {move cursor back one column}
            WITH SELF DO
              BEGIN
                bcursorpoint := cursorPt;
          {$H-} termstrP := @screen [cursorXY.y].ch;
                IF cursorXY.x > 0 THEN
                  BEGIN
                    IF length (termstrP^) >= cursorXY.x THEN
                      BEGIN
                        (* try replace by space instead of delete
                        delete (termstrP^, cursorXY.x+1, 1);
                        *)
                        termstrP^[cursorXY.x+1] := ' ';
                        cursorXY.x := cursorXY.x - 1;
                              {can not do ClearScreen (CclearEline) after focus on Pad}
                        GetPoint (cursorXY.x, cursorXY.y, pt);
                        GetPoint (cursorXY.x+1, cursorXY.y, endpt);
                        SetRect (r, pt.h, pt.v - dfontInfo.ascent, endpt.h, endpt.v + dfontInfo.descent);
                        panel.OnAllPadsDo(EraseOnThePad);     {will forcus in pad, takes care of multiple panes too if any}
                        (*
                        IF length (termstrP^) > cursorXY.x THEN
                          BEGIN
                            GetPoint (0, cursorXY.y, pt);
                            MoveTo (pt.h, pt.v);
                            DrawTmLine (screen [cursorXY.y]);
                          END;
                        *)
                      END
                    ELSE
                      BEGIN
                        cursorXY.x := cursorXY.x - 1;
                        panel.OnAllPadsDo(HiCursorOnThePad);     {will forcus in pad, takes care of multiple panes too if any}
                      END;
                    IF (currAttr.charStyle <> defltAttr.charStyle) OR
                       (currAttr.charFont <> defltAttr.charFont) THEN
                      needChangeAttr := TRUE;                   {if different, need to create one}
                  END;
                {$H+}
            END;  {WITH SELF}

        keyLF : QPMoveCursor (TRUE, 0, 1);      {cannot do this after focus in Pane,
                                                               because OnAllPadsDo call can not be nested}
        keyHT :
          WITH SELF DO
            BEGIN                               {move to next tab position}
              IF tabPosition.tabSet THEN
                BEGIN
                  FOR i := cursorXY.x TO maxColumns - 1 DO
                    IF tabPosition.tabStop [i] THEN
                      BEGIN
                 {$H-}  VGotoxy (i, cursorXY.y);  {$H+}
                        GOTO 9;
                      END;
                END
              ELSE {$H-} VGotoxy (maxColumns - 1, cursorXY.y);  {$H+}
                                               {go to margin if no tab, according to most terminals}
9:
            END;
        END;  {CASE}

        HandleEvent;          {handle any event pending and deal with ToolKit update stuff}
        {$IFC fTrace}EP;{$ENDC}
    END;  {TStdTerm.CtrKeyWrite}



{----------------------------------------------- TStdTerm.Vread --------------------------------------------}

    PROCEDURE {TStdTerm.}Vread {(VAR ach: char; VAR keycap : Byte; VAR applekey, shiftkey, optionKey : BOOLEAN)};
    VAR vanWindow : TVanWindow;
        panel  : TPanel;
        inputbuffer : TInputBuffer;
        pcombkey    : TPCombKeys;

        FUNCTION WaitForInput : BOOLEAN;
        BEGIN
          IF currentDocument <> NIL THEN
            IF currentDocument <> clipboard THEN WaitForInput := vanWindow.inputcount > 0
            ELSE WaitForInput := FALSE
          ELSE WaitForInput := docList.Size = 0;              {return true only if has input or put away}
        END;

    BEGIN           {have to bind documnet first before accessing window, or anything on doc heap}
        {$IFC fTrace}BP(20);{$ENDC}
        BindDocheap;
        MoveWindow;                               {move window if needed to contain cursor point}
        vanWindow := SELF.window;

        IF vanWindow.inputcount <= 0 THEN
          BEGIN
            inBackGround := FALSE;                {so that ToolKit will treat me as normal apps, and suspend
                                                   me when I am deactivated}
            IF NOT currentWindow.IsActive THEN    {in background}
              BEGIN
                currentWindow := NIL;             {so that I'll get suspended in getevent}
                currentDocument.Deactivate;       {donot tie up data segments when suspended}
              END;
            Process.ObeyEvents (WaitForInput);
            inBackGround := TRUE;
          END
        ELSE Process.ObeyEvents (NotToWait);
        CkPutAway;                                {no return if document got put away}

        keycap := 0;
        applekey := FALSE;
        shiftkey := FALSE;
        optionkey := FALSE;
        inputbuffer := TInputBuffer (vanWindow.typeAhead.First^);
        IF inputbuffer.inputRun.Size = 0 THEN     {go to the next one}
          BEGIN
            inputbuffer := TInputBuffer (vanWindow.typeAhead.First^);
            inputbuffer.Free;
            vanWindow.typeAhead.DelFirst;
            IF vanWindow.typeAhead.size = 0 THEN
              BEGIN
                ABCBreak ('In TStdTerm.VRead, typeAhead.size = 0 after DelFirst ', 99);
                Halt;
              END;
            inputbuffer := TInputBuffer (vanWindow.typeAhead.First^);
          END;
        WITH vanWindow, inputbuffer DO
          BEGIN  {$H-}
            ach := inputRun.First;
            inputRun.DelFirst;
            IF combKeys <> NIL THEN
              BEGIN
                pcombkey := TPCombKeys (combKeys.First);
                WITH pcombkey^ DO
                  BEGIN
                    keycap := keycapvalue;
                    applekey := appledown;
                    shiftkey := shiftdown;
                    optionkey := optiondown;
                  END;
                combKeys.DelFirst;    {$H+}
              END;
            inputcount := inputcount - 1;
          END;
        IF vanWindow.inputPanel <> NIL THEN
          IF ach = CHR (keyCR) THEN
            vanWindow.inputPanel.Invalidate;                 {redisplay the input panel}
                                                             {later - blank out the non-CR character read}
        vanWindow.selectPanel.selection.MarkChanged;
        IF qdpUsed THEN
            SetPort (qdpGPtr);          {restore qdp's grafport}
        {$IFC fTrace}EP;{$ENDC}
    END;  {TStdTerm.Vread}


{$S sQPortInit}                         {initialization code segment}

BEGIN        {TStdTerm class init routine. This is called in the begining of program after %_init}

    Pterminating   := FALSE;            {init all run time vars to default}
    qdpUsed        := FALSE;            {this has to be inited in this class}
    qdpPicOpen     := FALSE;
    gotapplePeriod := FALSE;
    restarted      := FALSE;
    outputStopped  := FALSE;
    inputStopped   := FALSE;
    tabRulerShown  := FALSE;
    needChangeAttr := FALSE;

    WITH qdpViewRect DO
      BEGIN
        left := 0;
        top := 0;
        right := 720;
        bottom := 364;
      END;

          {The process.ObeyEvents call has to follow the calls to all the TStdTerm's subclass's creation blocks, because
           the first filer event will do docManager.open which relys on the Consterm being setup by terminal
           subclass.}

    Consterm := TStdTerm.CREATE (NIL, mainHeap);       {Terminal subclass has to assign its own CREATE to
                                                        Consterm in its class init routine like this.}
END;  {Methods of TStdTerm}

{$S sQPortRes}                     {resident code segment - writeln, readln and routines called from program}




{Procedures to be called by programs, or terminal emulators. They must do BindDocHeap and HandleEvent,
 Pasterm.InWidnow to true and false, and Sched_class to true and false.}

{----------------------------------------------- Vread -----------------------------------------------------}

PROCEDURE VRead (VAR ch: char; VAR keycap : Byte; VAR applekey, shiftkey, optionkey : BOOLEAN);
                                                  {program can call this to get control keys, instead of READ,
                                                   But this call will not echo the character read, nor do mapping.}
VAR errnum : INTEGER;
BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}
    Consterm.VRead (ch, keycap, applekey, shiftkey, optionkey);
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;   {VRead}



{----------------------------------------------- ClearScreen -----------------------------------------------}

PROCEDURE ClearScreen {(clearkind : INTEGER)};
LABEL 9;
VAR r           : Rect;
    pt, beginpt : Point;
    cursorline, errnum, i : INTEGER;
    termstrP    : PTTermStr;
    s           : TListScanner;
    panel       : TPanel;

    PROCEDURE ClearLines (beginY, endY : INTEGER);
    VAR j : INTEGER;
    BEGIN
      FOR j := beginY TO endY DO
        BEGIN
          IF Consterm.screen [j].size < 0 THEN EmptyTmLine (Consterm.screen [j]);     {has char attr before}
          Consterm.screen [j].ch [0] := CHR (0);               {linelength}
        END;
    END;

    PROCEDURE ClearOnThePad {(pane: TPane)};      {will forcus in pad}
    VAR pnstate : PenState;
    BEGIN
      panel.selection.HighLight (hOnToOff);       {dehighlight current cursor}
      EraseRect (r);
      WITH pnstate DO
        BEGIN
          pnLoc.h := 0;
          pnLoc.v := vscreenRect.top;
          pnSize.h := 1;                   {use smallest pen size}
          pnSize.v := 1;
          pnMode := patCopy;
          pnPat  := gray;
        END;
      SetPenState (pnstate);
      MoveTo (0, vscreenRect.top);
      Line (vscreenRect.right, 0);                {redraw a gray line between screen and buffer areas}
      panel.selection.HighLight (hOffToOn);
    END;

BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}
    panel := Consterm.window.termPanel;
    WITH Consterm DO
{$H-} CASE clearkind OF
        sclearScreen :
          BEGIN
            ClearLines (0, maxLines - 1);
            r := vscreenRect;
          END;

        sclearEScreen :
          BEGIN
            cursorline := cursorXY.y + 1;
            ClearScreen (sclearELine);
            ClearLines (cursorline, maxLines - 1);

            WITH Consterm DO
              IF cursorline < maxLines THEN
                BEGIN
                  GetPoint (0, cursorline, pt);
                  SetRect (r, pt.h, pt.v - dfontInfo.ascent, vscreenRect.right, vscreenRect.bottom);
                END
              ELSE goto 9;
          END;

        sclearBScreen :
          BEGIN
            ClearLines (0, cursorXY.y - 1);

            ClearScreen (sclearBLine);
            WITH Consterm DO
              IF cursorXY.y > 0 THEN
                BEGIN
                  GetPoint (0, cursorXY.y - 1, pt);
                  SetRect (r, vscreenRect.left, vscreenRect.top + dfontInfo.leading,       {not touch gray line}
                                                vscreenRect.right, pt.v + dfontInfo.descent);
                END
              ELSE goto 9;
          END;
        sclearLine :
          BEGIN
            IF screen [cursorXY.y].size < 0 THEN EmptyTmLine (screen [cursorXY.y]);   {has char attr before}
            WITH Consterm DO
              BEGIN
                screen [cursorXY.y].ch [0] := CHR (0);               {linelength}
                GetPoint (0, cursorXY.y, pt);
                SetRect (r, pt.h, pt.v - dfontInfo.ascent, vscreenRect.right,
                                                          pt.v + dfontInfo.descent);
              END;
          END;
        sclearELine :               {including the character at the cursor position}
          BEGIN
            screen [cursorXY.y].ch [0] := CHR (cursorXY.x);      {linelength}
            GetPoint (cursorXY.x, cursorXY.y, pt);
            SetRect (r, pt.h, pt.v - dfontInfo.ascent, vscreenRect.right,
                                                      pt.v + dfontInfo.descent);
          END;
        sclearBLine :               {including the character at the cursor position}
          BEGIN
            termstrP := @screen [cursorXY.y].ch;
            FOR i := 1 TO cursorXY.x+1 DO termstrP^[i] := ' ';
            GetPoint (0, cursorXY.y, beginpt);
            GetPoint (cursorXY.x+1, cursorXY.y, pt);
            SetRect (r, beginpt.h, beginpt.v - dfontInfo.ascent, pt.h, pt.v + dfontInfo.descent);
          END;
      END;   {$H+}

    panel.OnAllPadsDo (ClearOnThePad);
9:
    HandleEvent;          {handle any event pending and deal with ToolKit update stuff}
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;   {ClearScreen}



{----------------------------------------------- VGotoxy ---------------------------------------------------}

PROCEDURE VGotoxy {(x, y : INTEGER)};
VAR panel  : TPanel;
    errnum : INTEGER;
    bcursorpoint : Point;

    PROCEDURE GotoOnThePad {(pane: TPane)};   {will forcus in pad}
    BEGIN
      HiLiteCursor (hOnToOff, bcursorpoint);           {dehighlight current cursor}
      WITH Consterm DO
        BEGIN
    {$H-} GetPoint (cursorXY.x, cursorXY.y, cursorPt);
          HiLiteCursor (hOffToOn, cursorPt);  {$H+}
        END;
    END;

BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}
    WITH Consterm DO
      BEGIN
        panel := window.termPanel;
        bcursorpoint := cursorPt;
        cursorXY.x := x;
        cursorXY.y := y;
        IF x < 0 THEN cursorXY.x := 0 ELSE IF x > (maxColumns - 1) THEN cursorXY.x := maxColumns - 1;
        IF y < 0 THEN cursorXY.y := 0 ELSE IF y > (maxLines - 1) THEN cursorXY.y := maxLines - 1;
      END;
    panel.OnAllPadsDo (GotoOnThePad);     {will forcus in pad, takes care of multiple panes too if any}

    WITH Consterm DO
      IF (currAttr.charStyle <> defltAttr.charStyle) OR
         (currAttr.charFont <> defltAttr.charFont) THEN
        needChangeAttr := TRUE;                   {if different, need to create one}
    HandleEvent;          {handle any event pending and deal with ToolKit update stuff}
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;   {VGotoxy}




{----------------------------------------------- MoveCursor ------------------------------------------------}

PROCEDURE MoveCursor {(scroll : BOOLEAN; xdistance, ydistance : INTEGER)};      {external call from program}
                               {scroll is only meanful in vertical direction.}
                               {xdistance, ydistance: positive means to the right or down.}
VAR errnum : INTEGER;
BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;         {have to bind documnet first before accessing window, or anything on doc heap}
    QPMoveCursor (scroll, xdistance, ydistance);
    HandleEvent;         {handle any event pending and deal with ToolKit update stuff}
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;   {MoveCursor}




{----------------------------------------------- ChangeCharStyle -------------------------------------------}

PROCEDURE ChangeCharStyle {(newstyle : Style)};
VAR newattr : TRAttributes;
    errnum : INTEGER;
BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;              {have to bind documnet first before accessing window, or anything on doc heap}
    IF Consterm.currAttr.charStyle <> newstyle THEN
      BEGIN
        newattr.charStyle := newstyle;
        newattr.charFont  := Consterm.currAttr.charFont;
        ChangeAttributes (newattr);
      END;
    HandleEvent;              {handle any event pending and deal with ToolKit update stuff}
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;  {ChangeCharStyle}





{$S sQPortCold}                         {cold segment - user interface code - and infrequent code segment}

{----------------------------------------------- StopInput -------------------------------------------------}

PROCEDURE StopInput;      {lock keyboard from program or terminal emulator}
BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    inputStopped := TRUE;
    {$IFC fTrace}EP;{$ENDC}
END;  {StopInput}



PROCEDURE StartInput;     {unlock keyboard}
BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    inputStopped := FALSE;
    {$IFC fTrace}EP;{$ENDC}
END;  {StartInput}



{----------------------------------------------- SetTab ----------------------------------------------------}

PROCEDURE SetTab {(column : INTEGER)};      {use cursor if column < 0}
LABEL 9;
VAR errnum : INTEGER;
BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}
    IF column < 0 THEN column := Consterm.cursorXY.x;
    IF column > Consterm.maxColumns THEN GOTO 9;
    WITH Consterm.tabPosition DO
      BEGIN
        tabSet := TRUE;
        tabStop [column] := TRUE;
      END;
9:
    HandleEvent;          {handle any event pending and deal with ToolKit update stuff}
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;   {SetTab}



PROCEDURE ClearTab {(clearAll : BOOLEAN; column : INTEGER)};    {use cursor if column < 0}
LABEL 9;
VAR errnum : INTEGER;
BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}
    WITH Consterm.tabPosition DO
      IF clearAll THEN
        BEGIN
          tabSet := FALSE;
          All [1] := 0;
          All [2] := 0;
          All [3] := 0;
          All [4] := 0;
          All [5] := 0;
        END
      ELSE
        BEGIN
          IF column < 0 THEN column := Consterm.cursorXY.x;
          IF column > Consterm.maxColumns THEN GOTO 9;
          tabStop [column] := FALSE;
          IF (All [1] = 0) AND (All [2] = 0) AND (All [3] = 0) AND (All [4] = 0) AND (All [5] = 0)
          THEN tabSet := FALSE;
        END;
9:
    HandleEvent;          {handle any event pending and deal with ToolKit update stuff}
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;   {ClearTab}




{----------------------------------------------- QPConfig --------------------------------------------------}

PROCEDURE QPConfig {(config : TQPConfigRec)};     {main program should call this before any screen i/o}
LABEL 1, 2;
VAR panelsize, tvertviewsize, errnum : INTEGER;
    panel, tpanel : TPanel;
    viewLRect : LRect;
    inputView : TInputView;
    termView:  TTermView;
    termSelection : TTermSelection;
    itsCharPos : TCoordinate;
    pt : Point;

BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

    WITH Consterm, config DO
      BEGIN
        IF alreadyConfigured THEN GOTO 2;         {we don't want to keep creating new panels}
        saveBuffer := tosaveBuffer;
        handleApplePeriod := NOT passApplePeriod;
        haveInputPanel := showInputPanel;
        haveTwoPanels := twoPanels;
        alreadyConfigured := TRUE;           {so that 2nd call of QPConfig would not create panels again}
      END;

    tpanel := Consterm.window.termPanel;
    PushFocus;                               {has to do this before Focus, and pop before ObeyEvents.}
    Consterm.window.Focus;                   {just want to switch to toolkit's grafport before panel divide}
    IF config.showInputPanel THEN
      BEGIN                                  {create input panel}
        panelsize := Consterm.dfontInfo.lineheight * 2 + Consterm.dfontInfo.leading;
                                             {2+ lines of input panel initially, make the scroll bar visible}
        panel := tpanel.Divide (v, panelsize, pixelsFromEdge, [userCanResizeIt, windowCanResizeIt],
                                     0, [aBar, aScroll], []);      {input panel has no h scroll}
        SetLRect (viewLRect, 0, 0, 720, 364);                {size of input panel view}
        inputView := TInputView.CREATE (NIL, Consterm.heap, panel, viewLRect);
        Consterm.window.inputPanel := panel;
      END;

    WITH config DO
     IF twoPanels THEN
      BEGIN
        IF (NOT qdpUsed) OR ((vhs <> v) AND (vhs <> h)) THEN
          BEGIN
            Consterm.haveTwoPanels := FALSE;
            GOTO 1;                {text output only program can not have two panels}
          END;
                                   {create text panel, since graph panel already created in BlankStationary}
        panelsize := tpanel.innerRect.botRight.vh [vhs] - tpanel.innerRect.topLeft.vh [vhs];
                                                          {is this the only way to get size of rect edge ?}
        IF grPanelSize > 0 THEN
          BEGIN
            panelsize := panelsize - grPanelSize;
            IF panelsize < 0 THEN panelsize := 0;           {to make sure > 0}
          END
        ELSE
          BEGIN
            panelsize := - (panelsize + grPanelSize);
            IF panelsize > 0 THEN panelsize := 0;           {to make sure < 0}
          END;
        panel := tpanel.Divide (vhs, panelsize, pixelsFromEdge, [userCanResizeIt, windowCanResizeIt],
                                                  0, [aBar, aScroll, aSplit], [aBar, aScroll, aSplit]);
        WITH Consterm DO                                    {Consterm has been inited by subclass by now}
            tvertviewsize := viewSize * dfontInfo.lineheight + vindent;
        SetLRect (viewLRect, 0, 0, 720, tvertviewsize);     {size of terminal output for initial text view}
        termView := TTermView.CREATE (NIL, Consterm.heap, panel, viewLRect, NIL);

        Consterm.window.termPanel := panel;
        itsCharPos.xyCoord := 0;
        termSelection := TTermSelection (panel.selection.freedAndReplacedBy(
                    TtermSelection.CREATE (NIL, Consterm.heap, termView, noselKind, itsCharPos, zeroLPt)));
        WITH Consterm DO
          BEGIN  {$H-}
            GetPoint (0, 0, cursorPt);                      {locate home point}
            SetRect (vscreenRect, cursorPt.h, cursorPt.v - dfontInfo.ascent - dfontInfo.leading,
                                             viewLRect.right, viewLRect.bottom);
          END;  {$H+}
        menubar.Delete (midGrOnlyEdit);
        menuBar.Insert (midTermSpec, midExecution);    {since term spec menu got unloaded initially in graph
                                                        panel only condition}
        menuBar.Insert (midTxGrEdit, midTermSpec);
        menuBar.Draw;
      END;
1:
    WITH Consterm DO
      BEGIN
        txpanelonly := (NOT haveTwoPanels) AND (NOT qdpUsed);
        grpanelonly := (NOT haveTwoPanels) AND qdpUsed;
        IF grpanelonly THEN saveBuffer := FALSE;
      END;

    IF config.showInputPanel THEN
     WITH Consterm DO
      BEGIN                                  {switch in menus with 'Flush Input' menu item.}
 {$H-} IF txpanelonly THEN
          BEGIN
            menubar.Delete (midTxOnlyEdit);
            menuBar.Insert (midInTxOnlyEdit, midTermSpec);
          END
        ELSE IF grpanelonly THEN
          BEGIN
            menubar.Delete (midGrOnlyEdit);
            menuBar.Insert (midInGrOnlyEdit, midExecution);
          END
        ELSE IF haveTwoPanels THEN
          BEGIN
            menubar.Delete (midTxGrEdit);
            menuBar.Insert (midInTxGrEdit, midTermSpec);
          END;
        menuBar.Draw;  {$H+}
      END;

    PopFocus;                                     {has to do this before ObeyEvents.}
2:
    HandleEvent;                                  {handle any event pending and deal with ToolKit update stuff}
    IF qdpUsed THEN
        SetPort (qdpGPtr);                        {restore qdp's grafport}
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;  {QPConfig}




{----------------------------------------------- SetupTermPara ---------------------------------------------}

PROCEDURE SetupTermPara {(termpara : TTermPara)};      {set up terminal parameters from program or terminal emulator}
VAR tmline : TTermLine;
    i, errnum, tvertviewsize : INTEGER;
    termView  : TTermView;
    pt        : Point;
BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}
    WITH Consterm, termpara DO
      IF (rowsize <= maxPosLines) OR (columnsize <= maxPosColumns) THEN
        BEGIN  {$H-}
          IF maxLines < rowsize THEN
            FOR i := maxLines TO rowsize-1 DO              {screen always has maxLines lines}
              BEGIN
                tmline := TTermLine.CREATE;
                Consterm.screen [i] := tmline;
              END;
          maxLines := rowsize;
          IF viewSize < rowsize THEN
            BEGIN
              viewSize := rowsize;
              termView := TTermView (window.termPanel.view);
              tvertviewsize := rowsize * dfontInfo.lineheight + vindent;
              SetLRect (termView.minViewLRect, 0, 0, 720, tvertviewsize);
              termView.ReactToPrinterChange;     {toolkit will call view.SetMinViewSize}
              GetPoint (0, 0, pt);               {locate home point}
              SetRect (vscreenRect, pt.h, pt.v - dfontInfo.ascent - dfontInfo.leading,
                                 termView.extentLRect.right,
                                 termView.extentLRect.bottom);
              GetPoint (cursorXY.x, cursorXY.y, cursorPt);
            END;
          IF maxColumns <> columnsize THEN ChangeMaxColumns (columnsize);  {$H+}
          WITH Consterm DO                                  {in case Consterm is moved}
            BEGIN
              wrapAround     := towraparound;
              stopOutputKey  := keytoStopOutput;
              startOutputKey := keytoStartOutput;
              cursorshape    := tmcursorShape;
            END;
        END;
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;  {SetupTermPara}


{----------------------------------------------- QPYield_CPU -----------------------------------------------}

PROCEDURE QPYield_CPU;                          {Programs should include this call in the long compute-bound
                                                 loop. This call will handle user's menu and mouse actions
                                                 as well. If programs do not want to give up being the active
                                                 window, they may call Yield_CPU.}
VAR errnum : INTEGER;
BEGIN
    {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
    {$IFC fTrace}BP(20);{$ENDC}
    Sched_Class (errnum, TRUE);                   {switch to non-preemptive class}
    BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

    Process.ObeyEvents (NotToWait);
    CkPutAway;                                    {no return if document got put away}

    IF qdpUsed THEN
        SetPort (qdpGPtr);                        {restore graphPanel's grafport}
    Sched_Class (errnum, FALSE);                  {switch back to preemptive class}
    {$IFC fTrace}EP;{$ENDC}
    {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
END;  {QPYield_CPU}





{Procedures to be called by terminal emulators only. They need not do BindDocHeap and HandleEvent, since they
can only get control from TPasTerm methods and they are doing these already.}

{$S sQPortRes}                     {resident code segment - writeln, readln and routines called from program}

{----------------------------------------------- VStrWrite -------------------------------------------------}

PROCEDURE VStrWrite {(VAR str : Tstr255)};        {write the str from cursor position, not the entire line, to be
                                                   called by terminal emulators after interpreting esc sequences.}
                                                  {No control characters allowed in str, handles wraparound}
VAR panel  : TPanel;
    termstrP : PTTermStr;
    fromptr, toptr : pTpaoc;
    towrap, toerase : BOOLEAN;
    i : INTEGER;
    str2   : Tstr255;
    bcursorpoint : Point;

    PROCEDURE WriteOnThePad;   {will forcus in pad}
    VAR r : Rect;
        termSelection : TTermSelection;
    BEGIN
      IF panel.selection.kind = noselKind THEN
        HiLiteCursor (hOnToOff, bcursorpoint)
      ELSE
        BEGIN
          termSelection := TTermSelection (panel.selection);
          termSelection.QPHighlight (hOnToOff, bcursorpoint);       {dehighlight current cursor}
        END;
      WITH Consterm DO
        BEGIN
    {$H-} IF thePort^.txFont <> currAttr.charFont THEN TextFont (currAttr.charFont);
          IF thePort^.txFace <> currAttr.charStyle THEN TextFace (currAttr.charStyle);
          IF thePort^.txMode <> srcOr THEN TextMode (srcOr);
                (* TextMode (srcCopy);                 {use copy mode to write over characters on screen}
                   This caused 5 characters to be erased when drawstring is called. Actually srcCopy is
                   not supported in text drawing.*)
          IF toerase THEN
            BEGIN
              SetRect (r, bcursorpoint.h, bcursorpoint.v - dfontInfo.ascent,
                       bcursorpoint.h + length (str)*dfontInfo.widmax, bcursorpoint.v + dfontInfo.descent);
              EraseRect (r);
            END;
          MoveTo (bcursorpoint.h, bcursorpoint.v);
          DrawString (str);                            {output it rightaway}
          IF panel.selection.kind = noselKind THEN
            HiLiteCursor (hOffToOn, cursorPt)
          ELSE
            termSelection.QPHighlight (hOffToOn, cursorPt);       {highlight current cursor}  {$H+}
        END;  {WITH Consterm}
    END;

BEGIN    {VStrWrite}
    {$IFC fTrace}BP(20);{$ENDC}
    panel := Consterm.window.termPanel;
                          {have to test grpanelonly and not save str, do this later}
                          {or maybe we still save in screen only, no buffer since saveBuffer is false.}
    toerase := TRUE;
    WITH Consterm DO
      IF needChangeAttr AND
         ((currAttr.charStyle <> defltAttr.charStyle) OR (currAttr.charFont <> defltAttr.charFont)) THEN
    {$H-} ChangeAttributes (currAttr);     {$H+}                 {if different, need to create one}

    WITH Consterm DO
      BEGIN
  {$H-} termstrP := @screen [cursorXY.y].ch;
        IF length (termstrP^) < cursorXY.x THEN         {extend the line first}
          BEGIN
            FOR i := length (termstrP^) + 1 TO cursorXY.x DO
              termstrP^[i] := ' ';
            termstrP^[0] :=  CHR (cursorXY.x);          {linelength}
          END;
        towrap := FALSE;
        IF cursorXY.x + length (str) >= maxColumns THEN
          BEGIN
            IF wraparound THEN
              BEGIN
                towrap := TRUE;
                str2 := copy (str, maxColumns - cursorXY.x + 1, length (str) - (maxColumns - cursorXY.x));
              END;
            str := copy (str, 1, maxColumns - cursorXY.x);
          END;
        fromptr := POINTER (ORD (@str) + 1);
        toptr := POINTER (ORD (termstrP) + cursorXY.x + 1);
        MoveLeft (fromptr^, toptr^, length (str));
        IF termstrP^[0] <= CHR (cursorXY.x) THEN toerase := FALSE;     {new output, no need to erase}
        IF cursorXY.x + length (str) > length (termstrP^) THEN
            termstrP^[0] :=  CHR (cursorXY.x + length (str));

        IF thePort^.txFont <> currAttr.charFont THEN TextFont (currAttr.charFont);
        bcursorpoint := cursorPt;
        cursorXY.x := cursorXY.x + length (str);
        cursorPt.h := cursorPt.h + StringWidth (str);
                                      {Outline and shadow got drawn with one extra pixel wide.
                                       This would allow continue WRITEs to come out ok, but cursor move
                                       will still mess up, users should be aware.}
     (* GetPoint (cursorXY.x, cursorXY.y, cursorPt);  *)
        IF cursorXY.x >= maxColumns THEN
          BEGIN
            cursorXY.x := maxColumns - 1;            {stay with the last char}
            cursorPt.h := cursorXY.x * dfontInfo.widmax + hindent;
          END;
        {$H+}
      END;
    panel.OnAllPadsDo(WriteOnThePad);     {will forcus in pad, takes care of multiple panes too if any}
    IF towrap THEN
      BEGIN
        QPMoveCursor (TRUE, -200, 1);     {move to next line column 1}
        VStrWrite (str2);
      END;
    {$IFC fTrace}EP;{$ENDC}
END;  {VStrWrite}



{----------------------------------------------- VGetLine --------------------------------------------------}

PROCEDURE VGetLine {(lineNo : INTEGER; VAR line : Tstr255; delete : BOOLEAN)};
                               {lineNo is limited to -1 to maxLines-1}
                               {if lineNo < 0 and to delete, have to scroll down the buffer}
                     {Note that all these procedures do not affect the screen, except for the buffer area,
                      caller should call ReDrawLine or RedrawSreen or VScrollLines}
LABEL 9;
VAR tmline : TTermLine;
    bsize, lineinbuffer : INTEGER;
    fromptr, toptr : pTpaoc;
BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    line := '';
    IF (lineNo >= Consterm.maxLines) THEN GOTO 9;
    bsize := Consterm.buffer.size;
    IF lineNo < 0 THEN
      BEGIN
        IF bsize <= 0 THEN GOTO 9;
        (* lineNo is limited to -1
        lineinbuffer := bsize + lineNo + 1;
        termline := Consterm.buffer.At (lineinbuffer);
        *)
        tmline := TTermLine (Consterm.buffer.Last^);
      END
    ELSE tmline := Consterm.screen [lineNo];

    toptr := @line;
    fromptr := @tmline.ch;
    MoveLeft (fromptr^, toptr^, ORD (tmline.ch [0]) + 1);              {copy linelength and textline}
    IF delete THEN
      BEGIN
        IF lineNo < 0 THEN                                       {buffer scrolls down one line}
          BEGIN
            (* lineNo is limited to -1
            Consterm.buffer.DelAt (lineinbuffer, TRUE);
            *)
            tmline := TTermLine (Consterm.buffer.Last^);
            tmline.Free;                                         {have to free the buffer.First myself}
            Consterm.buffer.DelLast;
            VScrollLines (-bsize, lineNo, 1);
          END
        ELSE         {keep screen maxLines of lines}
          BEGIN
            MoveScrnHandles (shDelete, TRUE, lineNo, 1);         {delete the line off screen}
            VScrollLines (lineNo, Consterm.maxLines - 1, -1);    {screen scroll up one line}
          END;
      END;
9:
    {$IFC fTrace}EP;{$ENDC}
END;   {VGetLine}



{----------------------------------------------- VPutLine --------------------------------------------------}

PROCEDURE VPutLine {(lineNo : INTEGER; VAR line : Tstr255; insert : BOOLEAN)};  {insert as lineNo}
                                    {lineNo is limited to -1 to maxLines-1}
                                    {if not insert then it is to replace the lineNo with line}
                                    {Possible to have active view size > maxlines after insertion, caller
                                     should make sure this does not happen.}
                     {Note that all these procedures do not affect the screen, except for the buffer area,
                      caller should call ReDrawLine or RedrawSreen or VScrollLines}
LABEL 9;
VAR tmline : TTermLine;
    fromptr, toptr : pTpaoc;
    bsize    : INTEGER;
BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    IF lineNo >= Consterm.maxLines THEN GOTO 9;
    bsize := Consterm.buffer.size;
    IF insert THEN
      BEGIN
        tmline := TTermLine.CREATE;
        fromptr := @line;
        toptr := @tmline.ch;
        MoveLeft (fromptr^, toptr^, length (line) + 1);       {copy linelength and textline}

        IF lineNo < 0 THEN                   {buffer scrolls up one line}
          BEGIN
            (* lineNo is limited to -1
            IF (bsize > 0) AND (lineNo <> -1) THEN
                Consterm.buffer.InsAt (bsize + lineNo + 1 + 1, termline)   {this inserts before index passed}
            ELSE
            *)
            IF Consterm.saveBuffer THEN
              BEGIN
                                   {remove slack and move charattr up if any.}
                Consterm.buffer.InsLast (@tmline);
                VScrollLines (-bsize - 1, lineNo, -1);
              END
            ELSE GOTO 9;
          END
        ELSE                   {keep screen maxLines of lines}
          BEGIN
            MoveScrnHandles (shInsert, FALSE, lineNo, 1);         {insert a handle}
            Consterm.screen [lineNo] := tmline;
            VScrollLines (lineNo, Consterm.maxLines - 1, 1);       {screen scroll down one line}
          END;
        RedrawLine (lineNo);             {draw the inserted line}
      END
    ELSE        {replace line}
      BEGIN
        IF lineNo < 0 THEN
          BEGIN
            IF bsize > 0 THEN
              tmline := TTermLine (Consterm.buffer.At (bsize + lineNo + 1)^);
          END
        ELSE
          tmline := Consterm.screen [lineNo];
        fromptr := @line;
        toptr := @tmline.ch;
        MoveLeft (fromptr^, toptr^, length (line) + 1);       {copy linelength and textline}
      END;
9:
    {$IFC fTrace}EP;{$ENDC}
END;   {VPutLine}



{----------------------------------------------- VScrollLines ----------------------------------------------}

PROCEDURE VScrollLines {(topRegion, bottomRegion : INTEGER; scrollhowmanylines : INTEGER)};
                                    {scrollhowmanylines : positive means to scroll down}
                                    {just scroll output on screen, does not change data structure}
                                    {It is caller's job to delete the lines that scrolled off the view}
                                    {topRegion and bottomRegion must have same sign, 0 is positive}
VAR panel      : TPanel;

    PROCEDURE VScrollOnThePad {(pane: TPane)};   {will forcus in pane or pad}
    VAR r : Rect;
        topPt, bottomPt : Point;
        frompt, topt : Point;
    BEGIN
      panel.selection.HighLight (hOnToOff);       {dehighlight current cursor}
      GetPoint (0, topRegion, frompt);
      GetPoint (0, bottomRegion, topt);
      WITH Consterm DO
        BEGIN
    {$H-} SetRect (r, frompt.h, frompt.v - dfontInfo.ascent,
                                        vscreenRect.right, topt.v + dfontInfo.descent);
          ScrollRect (r, 0, Consterm.dfontInfo.lineheight * scrollhowmanylines, workRgn);

          WITH workRgn^^, rgnBBox DO
            IF (thePad.visLRect.bottom < vscreenRect.bottom) OR
               ((bottom - top) > dfontInfo.lineheight) THEN
              thePad.InvalRect (rgnBBox);     {$H+}   {need not update if workRgn is the last line}
        END;
      panel.selection.HighLight (hOffToOn);
    END;

BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    panel := Consterm.window.termPanel;
    panel.OnAllPadsDo(VScrollOnThePad);     {will forcus in pane or pad, takes care of multiple panes too if any}
    {$IFC fTrace}EP;{$ENDC}
END;   {VScrollLines}




{----------------------------------------------- ChangeFont -----------------------------------------------}

     {for VT100 terminal emulator only, to switch to graphic character font and back}
PROCEDURE ChangeFont {(newfont : INTEGER)};       {same character width, fixed pitch font only}
VAR newattr : TRAttributes;
BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    IF Consterm.currAttr.charFont <> newfont THEN
      BEGIN
        newattr.charFont  := newfont;
        newattr.charStyle := Consterm.currAttr.charStyle;
        ChangeAttributes (newattr);
      END;
    {$IFC fTrace}EP;{$ENDC}
END;  {ChangeFont}




{$S sQPortCold}                         {cold segment - user interface code - and infrequent code segment}

{----------------------------------------------- RedrawScreen ----------------------------------------------}

PROCEDURE RedrawScreen;     {repaint entire screen after lines or screen size changes}
VAR panel      : TPanel;

    PROCEDURE RedrawSOnThePad {(pane: TPane)};   {will forcus in pane, or pad}
    VAR pt : Point;
        i  : INTEGER;
    BEGIN
      panel.selection.HighLight (hOnToOff);      {dehighlight current cursor}
      pt.v := vscreenRect.top + Consterm.dfontInfo.leading + Consterm.dfontInfo.ascent;
      MoveTo (hindent, pt.v);
      FOR i := 0 TO Consterm.maxLines - 1 DO
        BEGIN
          DrawTmLine (Consterm.screen [i]);
          pt.v := pt.v + Consterm.dfontInfo.lineheight;
          moveto (hindent, pt.v);               {moveto next line}
        END;
      panel.selection.HighLight (hOffToOn);
    END;

BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    panel := Consterm.window.termPanel;
    panel.OnAllPadsDo (RedrawSOnThePad);     {will forcus in pane or pad, takes care of multiple panes too if any}
    {$IFC fTrace}EP;{$ENDC}
END;   {RedrawScreen}



{----------------------------------------------- RedrawLine ------------------------------------------------}

PROCEDURE RedrawLine {(lineNo : INTEGER)};       {repaint the current line after attributes changes}
VAR panel      : TPanel;

    PROCEDURE RedrawLOnThePad {(pane: TPane)};   {will forcus in pane or pad}
    VAR tmline : TTermLine;
        pt   : Point;
    BEGIN
      panel.selection.HighLight (hOnToOff);      {dehighlight current cursor}
      IF lineNo < 0 THEN tmline := TTermLine (Consterm.buffer.At (Consterm.buffer.size + lineNo + 1)^)
      ELSE tmline := Consterm.screen [lineNo];
      GetPoint (0, lineNo, pt);
      MoveTo (pt.h, pt.v);
      DrawTmLine (tmline);
      panel.selection.HighLight (hOffToOn);
    END;

BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    panel := Consterm.window.termPanel;
    panel.OnAllPadsDo (RedrawLOnThePad);     {will forcus in pane or pad, takes care of multiple panes too if any}
    {$IFC fTrace}EP;{$ENDC}
END;   {RedrawLine}




{----------------------------------------------- ChangeMaxColumns ------------------------------------------}

PROCEDURE ChangeMaxColumns {(newColumns : INTEGER)};
                          {Note that this call always go to non-graphic font. So in grphic font when this
                           is called, the new font is non-graphic font.}
LABEL 9;
VAR finfo : FontInfo;
    newfontfamily : INTEGER;
    panel      : TPanel;

BEGIN
    {$IFC fTrace}BP(20);{$ENDC}
    panel := Consterm.window.termPanel;
    WITH Consterm DO
      BEGIN
        IF maxColumns = newColumns THEN GOTO 9;
        maxColumns := newColumns;
        pmaxColumns := newColumns;
        IF newColumns <= maxcoltofit THEN newfontfamily := fIDLT12Text
        ELSE newfontfamily := fIDLT20Text;                   {132 column font}

        defltAttr.charFont := newfontfamily;
        pdefltAttr.charFont := newfontfamily;
                                        {so that TTermView.Draw for clipboard can access to this field.}
        pcurrAttr.charFont := newfontfamily;
                                        {load new font if necessary}
        currAttr.charFont := newfontfamily;
 {$H-}  TextFont (newfontfamily);
        GetFontInfo (Finfo); {$H+}
        WITH dfontInfo DO
          BEGIN
            leading := Finfo.leading;
            ascent := Finfo.ascent;
            descent := Finfo.descent;
            widmax := Finfo.widmax;
            WITH Finfo DO lineheight :=  leading + ascent + descent;
          END;
        pdfontInfo := dfontInfo;
 {$H-}  VGotoxy (0, 0);
        SetRect (vscreenRect, cursorPt.h, cursorPt.v - dfontInfo.ascent - dfontInfo.leading,
                             panel.view.extentLRect.right,
                             panel.view.extentLRect.bottom);   {$H+}
      END;

    ClearScreen (sclearScreen);              {clear the screen lines too.}
    panel.Invalidate;                        {the whole panel, force redraw at next update}
9:
    {$IFC fTrace}EP;{$ENDC}
END;  {ChangeMaxColumns}




Procedure QPFinished (error : INTEGER);  FORWARD;       {called by toolkit after all class init}


{$S sQPortInit}                         {initialization code segment}

{----------------------------------------------- TPasTerm --------------------------------------------------}

METHODS OF TPasTerm;
          {Note SELF.heap can not be used in this class since this is not subclass of ToolKit's TOBJECT}

    FUNCTION {TPasTerm.}CREATE {: TPasTerm};
    BEGIN
        {$IFC fTrace}BP(30);{$ENDC}
        TermMptr := @Termdata;                              {cannot use heap in paslib}
        Termdata.classptr := ORD (THISCLASS);               {to set up the class pointer}
        SELF := TPasTerm (@TermMptr);
        {$IFC fTrace}EP;{$ENDC}
    END;  {CREATE}



{$S sQPortRes}                               {resident code segment - writeln and readln}

    PROCEDURE EnterQPCall;
    VAR errnum : INTEGER;
    BEGIN
        (*
                                   {this should not happen, since we does not turn InWindow to true in the
                                    end of CleanUp.}
        IF docList = NIL THEN EXIT (QPProcCall);       {can only happen when abnormal termination and called from
                                                        terminate exception handler calling halt}
        *)
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}
    END;  {EnterQPCall}




    PROCEDURE {TPasTerm.}VWrite {(VAR str : Tstr255)};
    VAR errnum : INTEGER;
        currtime : milliseconds;
    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        BindDocheap;          {have to bind documnet first before accessing window, or anything on doc heap}

        Consterm.VWrite (str);

        (* caused no repainting while scrolling and the response to user moving scroll bar is slow.
        currtime := Timer;              {if this overhead takes more than HandleEvent call, then this is worse}
        IF (currtime - preWriteTime) > maxeventinterval THEN
        *)
          HandleEvent;                  {handle any event pending and deal with ToolKit update stuff}

        (*
        preWriteTime := currtime;
        *)

        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.VWrite}



    FUNCTION {TPasTerm.}VRead {: char};
    VAR ach : CHAR;
        keycap : Byte;
        applekey, shiftkey, optionkey : BOOLEAN;
        errnum : INTEGER;
    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

        Consterm.VRead (ach, keycap, applekey, shiftkey, optionkey);
        IF appleKey AND (ach >= ' ') THEN ach := CHR (ORD (ach) MOD ORD (' '));    {DoKey only maps beyond '?'}
        VRead := ach;
        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.VRead}



    PROCEDURE {TPasTerm.}VGotoxy {(x, y : INTEGER)};
    VAR errnum : INTEGER;
    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}

        VGotoxy (x, y);
        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.VGotoxy}



    FUNCTION  {TPasTerm.}VKeyPress {: BOOLEAN};
    VAR errnum : INTEGER;
    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

        Process.ObeyEvents (NotToWait);
        CkPutAway;                                     {no return if document got put away}
        VKeyPress := Consterm.window.inputcount > 0;
        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.VKeyPress}



    FUNCTION  {TPasTerm.}VAbortKey {: BOOLEAN};
    VAR errnum : INTEGER;
    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

        Process.ObeyEvents (NotToWait);
        CkPutAway;                                     {no return if document got put away}
        IF NOT Consterm.handleApplePeriod THEN
          BEGIN
            VAbortKey := gotapplePeriod;
            gotapplePeriod := FALSE;
          END;
        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.VAbortKey}



    PROCEDURE {TPasTerm.}VScreenCtr {(contrfun : INTEGER)};
    CONST                                              {from paslibcall, but name conflict if we USE it}
      CclearScreen = 1;            {clear the whole screen}
      CclearEScreen = 2;           {clear to the end of the screen}
      CclearELine = 3;             {clear to end of line}

      CgoHome = 11;                {move cursor to home position}
      CleftArrow = 12;             {move cursor left one character position}
      CrightArrow = 13;            {move cursor right one character position}
      CupArrow = 14;               {move cursor up one line position}
      CdownArrow = 15;             {move cursor down one line position}
    VAR errnum : INTEGER;
    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}

        CASE contrfun OF
          CclearScreen  : BEGIN
                            ClearScreen (sclearScreen);
                            VGotoxy (0, 0);            {to be compatible with the Workshop behavior}
                          END;
          CclearEScreen : ClearScreen (sclearEScreen);
          CclearELine   : ClearScreen (sclearELine);
          CgoHome       : VGotoxy (0, 0);
          CleftArrow    : MoveCursor (FALSE, -1, 0);
          CrightArrow   : MoveCursor (FALSE, 1, 0);
          CupArrow      : MoveCursor (FALSE, 0, -1);
          CdownArrow    : MoveCursor (FALSE, 0, 1);
        END;
        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.VScreenCtr}



{$S sQPortCold}                         {cold segment - user interface code - and infrequent code segment}


    FUNCTION {TPasTerm.}OpenPrinter { : INTEGER};
    VAR errnum : INTEGER;

    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

        IF vwp_Reset THEN OpenPrinter := 0 ELSE OpenPrinter := er_openprinter;
        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.OpenPrinter}


    FUNCTION {TPasTerm.}PrWrite {(VAR str : Tstr255) : INTEGER};
    VAR errnum : INTEGER;

    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

        IF vwp_W_Str (@str) THEN PrWrite := 0 ELSE PrWrite := er_prwrite;
        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.PrWrite}


    FUNCTION {TPasTerm.}ClosePrinter {: INTEGER};
    VAR errnum : INTEGER;

    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

        IF vwp_Close THEN ClosePrinter := 0 ELSE ClosePrinter := er_closeprinter;
        Sched_Class (errnum, FALSE);                   {switch back to preemptive class}
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}
    END;  {TPasTerm.ClosePrinter}


    PROCEDURE {TPasTerm.}CleanUp;
    VAR errnum : INTEGER;

        FUNCTION WaitForDocClose : BOOLEAN;
        BEGIN
          WaitForDocClose := (docList.Size = 0);
        END;

    BEGIN
        {$IFC fTrace}PasTerm.InWindow (TRUE);{$ENDC}
        {$IFC fTrace}BP(30);{$ENDC}
        Sched_Class (errnum, TRUE);                    {switch to non-preemptive class}
        IF docList <> NIL THEN
         IF docList.size <> 0 THEN
          BEGIN
            BindDocheap;        {have to bind documnet first before accessing window, or anything on doc heap}

            Pterminating := true;
            WrTermMsg;                                     {write terminal message to text panel if any}
            inBackGround := FALSE;                         {so that ToolKit will treat me as normal apps, and
                                                            suspend me when I am deactivated}
            IF NOT currentWindow.IsActive THEN             {in background}
              BEGIN
                currentWindow := NIL;                      {so that I'll get suspended in getevent}
                currentDocument.Deactivate;                {donot tie up data segments when suspended}
              END;
            Process.ObeyEvents (WaitForDocClose);          {go to wait for set aside or put away}
            amDying := TRUE;                               {so that we dont go to the ToolKit debugger}
            process.complete (true);
          END;
        {$IFC fTrace}EP;{$ENDC}
        {$IFC fTrace}PasTerm.InWindow (FALSE);{$ENDC}      {so that user's term excep handler can call writeln}
    END;  {TPasTerm.CleanUp}



{$S sQPortInit}                              {initialization code segment}

begin                                        {TPasTerm class init routine}
    InitClascal (QPFinished);                {install my Finished proc}
END;  {Methods of TPasTerm}





FUNCTION WaitForRestart : BOOLEAN;
BEGIN
  WaitForRestart := restarted;
END;



{----------------------------------------------- QPFinished ------------------------------------------------}

Procedure QPFinished (error : INTEGER);      {to be called by toolkit after all class init}
VAR copyright : string [80];
BEGIN
    copyright := 'Copyright 1983, 1984, Apple Computer Inc.';

    ClascalError (error);                    {do the standard one - version conversion stuff}

    WITH Consterm DO
      BEGIN
        txpanelonly := (NOT haveTwoPanels) AND (NOT qdpUsed);         {qdpUsed is inited in UQPGraph}
        grpanelonly := (NOT haveTwoPanels) AND qdpUsed;
      END;
    workRgn := newRgn;
    WITH Consterm DO                         {save some Consterm info on process stack}
      BEGIN
        pmaxColumns := maxColumns;
        pdfontInfo  := dfontInfo;
        pdefltAttr  := defltAttr;
        pcurrAttr   := currAttr;
      END;

    PasTerm := TPasTerm.CREATE;              {set up the linkage to paslib}

          {The following has to follow the calls to all the TStdTerm's subclass's creation blocks, because the first
          filer event will do docManager.open which relys on the Consterm being setup by terminal subclass.}
    qMouseEvents := NIL;

    process := TTermProcess.CREATE;
    process.Commence (phraseVersion);        {set up linkage to Toolkit}
    inBackGround := TRUE;                    {so that we can run in the background without ToolKit unbinding
                                              the doc heap}
    Process.ObeyEvents (NotToWait);          {this will process events to open document, set up window, etc}

    IF blankdocument THEN
      restarted := TRUE                      {so that the Restart command will be gray}
    ELSE                                     {reopen a put away document, wait for restart command}
      Process.ObeyEvents (WaitForRestart);   {This is the only place that checks for this flag, so restart
                                              command is nop after program executes.}
    CkPutAway;                               {no return if document got put away}

    menuBar.Check (ccDontSaveBuffer, TRUE);

    {process.complete is called when CleanUp is called or amDying is true.}

    IF qdpUsed THEN
      BEGIN
        qMouseEvents := TArray.CREATE (NIL, mainHeap, 20, SIZEOF (TMouseEvent));
        SetPort (qdpGPtr);                   {restore qdp's grafport just before going to main program}
        BindDocheap;
      END;

    PasTerm.SetupIOFile;                     {tell paslib to direct writeln to here}
    (*
    vwp_Init;                                {initialize printer}
    *)
    vwptoinit := TRUE;                       {to initialize -printer}
    preWriteTime := 0;
    InitClascal (ClascalError);              {install the original back, so it can handle error conditions}
END;  {QPFinished}


