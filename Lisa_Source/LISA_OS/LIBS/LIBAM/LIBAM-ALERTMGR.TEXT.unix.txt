
Unit AlertMgr; {Copyright 1983, Apple Computer Inc.}
{in segments SgAl, SgAlInit, SgAlHot, and SgAlIcy} {A4}

{Sizes:
    SgAl        8460 (was 7774)
    SgAlInit    1672+?
    SgAlIcy      312
}
   {6/14/84: Frank Ludolph
        * Added InitCursor to Ask/Note/Stop/CautionAlert to force visible
          cursor for background printing alerts }
   {4/23/84: Steve Rhodes
        * Fixed hang of background alert where it was throwing away
          folderDeactivate events for other folders }
   {3/9/84: Steve Rhodes
        * Fixed background alert processing so that it will not do a yield
          of the CPU.}
   {12/14/83: May Hu & Frank Ludolph
        * adding EndWaitAlert   }
   {12/2/83: Steve Rhodes
        * Added a BackgroundAlert mechanism that will be used initially
          by printing.}
   {10/31/83: Rod Perkins
        * Added the InitMP code to read in alert files generated by the tkAlert
          program.  New error number 3083 added}
   {7/4/83:
        * ShowSign draws text black ionstead of white if sign suppressed due to lack of heap space}
   {7/1/83:
        * Get rid of dfltKind array and use conditional instead in IndexOfAlert}
   { 6/29/83:
        * Make DTAlert get alerts 901-909 out of a phrase file (new argument) instead of always English
        * Get rid of 5/2 kludge: replace traceWouldAlert usage by preventReentry}
   { 5/2/83:
        * Trap reentry attempts.
          NOTE!!!! For now, we are multiplexing the variable traceWouldAlert to keep this library reusable!!!}
   { 4/11/83
        * Push private3 event on front of event queue to
            keep Filer from seeing DiskEvent if RefuseDeactivate or insist}
   { 3/27/83
        * Fix bug wherein SetPort was too late in AlertBox procedure}
   { 3/8/83
        * Recover gracefully from heap expansion failure
        * New error 3082 from InitAlerts, ReadAlerts, and ArgAlert -- very rare occurrences
        * ShowSign suppresses graphics when no heap space left}
   {1/10/83:
        * Use width of a 9 instead of fwidmax
        * FlushInput now brings activeFolder to the top, so I don't call MakeFldrActive any more
          and don't have to check for no-op deactivates
        * When beep only, call FlushInput directly instead of FlushTypeahead to avoid wasted effort'
    Next time a reusable change can be made (if ever):
        @ Delete the declaration of fWidMax (never used any more) -- NOT CRUCIAL
    1/3/83:
        * SetStdCursor(icrsInactive) instead of SetCursor(arrow)
    12/26/82
        * Added copyright comments and variables
        * Fixed bug in ShowText -- didn't check for citeArgs[]=NIL
        * AFTER every FlushInput, need MakeFldrActive; ignore no-op deactivates to avoid infinite loop
          (Old order [MakeFldrActive then FlushInput] failed because FlushInput itself called BringToFront!)
          NOTE: This changed again 1/10/83: see above!
        * ^C will lower case all letters of the command name between A and Z (not Diacritical Caps!!!)
        * ^K variant of ^C to keep case
     }

Intrinsic;

{errors from ReadAlert:
  -3076   Warning: Phrase file has wrong version number
   3077   Fatal: You must increase cacheBytes
   3078   Fatal: You must increase cacheBytes or shorten long alert messages
 errors when alerts are locked:
   3079   Fatal: You must increase cacheBytes or shorten long alert messages
   3080   Fatal: You must increase cacheSize
 errors from OpenPhraseFile:
   3081   Fatal: Checksum error in Phrase File
 errors from InitAlerts, ReadAlerts, ArgAlert, ParamAlert:
   3082   Fatal: Heap filled up (init failed, or argument not set)
 errors from InitMP:
   3083   Fatal: menu mapping information found in alert file
 errors from BackgroundAlert:
   3084   Fatal: Illegal type of alert requested (not ask, caution, note, or stop)
}


{***********************************************************************}

INTERFACE

uses

    {$U libhw/HWINT}           HwInt,
    {$U libsm/UNITSTD}         UnitStd,
    {$U libsm/UNITHZ}          UnitHz,
    {$U libqd/STORAGE}         Storage,
    {$U libqd/QUICKDRAW}       QuickDraw,
    {$U libfm/FONTMGR}         FontMgr,
    {$U libfm/FMGRUTIL}        FMgrUtil,
    {$U libos/SYSCALL}         SysCall,
    {$U libos/PSYSCALL}        PSysCall,
    {$U libpm/PMDECL}          PMDecl,
    {$U libpm/PMM}             PMM,
    {$U libwm/EVENTS}          Events,
    {$U libwm/FOLDERS}         Folders,
    {$U libwm/MENUS}           Menus,
    {$U libwm/WINDOWS}         Windows,
    {$U libsb/WMLSTD}          WmlStd,
    {$U libsb/WMLCRS}          WmlCrs,
    {$U libdb/DBENV}           dbenv;

{$setc alSymbols := FSymOK}
{$setc alDebug := FDbgOK}

{$setc dbgAlWould := alDebug}

{$setc dbgAlrt := false}
{$setc dbgAlEvt := false}
{$setc dbgAlRdErr := false}
{$setc dbgAlOpErr := false}

const maxButn = 10; {0..1 system-defined, 2..6 in file header, 7..10 AskAlert}
      noButn = 11;

type

     TButn = 0..maxButn;

     TAlertFile = ^PAlertRec;
     PAlertRec = ^TAlertRec;
     TAlertRec =
         record
            falerts:         longint; {ord(HAlertVec)}
            fnumAlerts:      integer;
            frefNum:         integer;
            fPos:            integer;
         end;

     TParamAlert = String[40];
     TArgAlert = 0..5; {must agree with minCitation, maxCitation below}
     TCountAlert = 7..9; {must agree with minCounter, maxCounter below}

     TPstr255 = ^Str255;

{begin type shared with AlertGen: keep consistent!}

     TAlertKind = (getProc,          {this order is relied upon !!!}
                   drawProc,
                   askProc, waitProc, stopProc, noteProc, cautionProc,
                   cautionOKproc, cautionCancelProc,
                   cautionStopProc, cautionNoteProc,
                   cautionInsistProc);

{end type shared with AlertGen: keep consistent!}

var

        alertError: integer;

        refuseDeactivate: boolean;

           {the next VAR is always declared & can be set by the
            application, but it is ineffective IFC NOT dbgAlWould.
            Note that it takes no code space because all references
            in this unit are conditionally compiled.}

        traceWouldAlert:  boolean;
        preventReentry:   boolean;
        BackGrInProgress: boolean;

        {$ifc dbgAlRdErr}
        fakeAlError: integer; {used to simulate an error to debug this unit}
        {$endc}


function  AskAlert(alertFile: TAlertFile; alertNumber: integer): integer;

procedure ArgAlert(n: TArgAlert; s: Str255);

function BackgroundAlert(alertFile: TAlertFile; alertNumber: integer; alertType: TAlertKind): integer;

procedure BeepAlert(volume: integer); {0..3}

function  ButnPushed(first, last: TButn; VAR pushed: TButn; pt: Point): boolean;

function  CautionAlert(alertFile: TAlertFile; alertNumber: integer): boolean;

function  CalcButWidth(topButn, botButn: TButn; VAR height: integer): integer;

procedure CountAlert(whichCounter: TCountAlert; countValue: integer);

procedure DrawAlert(alertFile: TAlertFile; alertNumber: integer; marginRect: Rect);

procedure DTAlert(alertFile: TAlertFile; osDT: longint; VAR userString: TParamAlert);

procedure EndWaitAlert;

procedure GetAlert(alertFile: TAlertFile; alertNumber: integer;
                   pStr: TPstr255);

procedure GetButn(d: TButn; pStr: TPstr255);

procedure HideButn(d: TButn);

procedure InitAlerts(cacheSize, cacheBytes: integer; hz: THz;
                     idleProcPtr, errProcPtr: procPtr);

procedure initMP
   (myHeap         : Thz;
    toolPreFix     : TParamAlert;
    ptrToAlertProc : procPtr;
    phraseversion  : integer;
    myMenus        : rMenuPtr;
    var alertFile  : TAlertFile;
    var error      : integer
   );

procedure LdSgAl;

procedure LocateAlert(top: integer);

procedure LockAlert(alertFile: TAlertFile; alertNumber: integer);

procedure NoteAlert(alertFile: TAlertFile; alertNumber: integer);

function  NthAlert(ordinal: INTEGER; alertFile: TAlertFile;
                   VAR alertNumber, numStages: integer; VAR alertKind: TAlertKind): BOOLEAN;

procedure OpenPhraseFile(VAR refNum: integer; path: pathName);

procedure ParamAlert(cite1, cite2, cite3: Str255);

procedure PushButn(d: TButn; f: boolean);

function  ReadAlerts(refNum, version: integer): TAlertFile;

procedure ReshowButn(d: TButn);

procedure SetButWidths(width: integer);

procedure ShowButn(d: TButn; h, v: integer; fDefault: boolean);

procedure StopAlert(alertFile: TAlertFile; alertNumber: integer);

procedure UnlockAlerts;

procedure WaitAlert(alertFile: TAlertFile; alertNumber: integer);

procedure WouldAlert(VAR menu: menuInfo; itemIndex: integer);

{*************************************************************************}

IMPLEMENTATION

{*************************************************************************}
{$SETC doTraceAM := TRUE}
{$SetC fTraceAM := doTraceAM AND fTRACE}

{$S alert}

{$R-}

{$ifc alSymbols}
{$D+}
{$elsec}
{$D-}
{$endc}

const

{begin consts shared with AlertGen: keep consistent!}

        signStrLength = 15;   {must be odd}

        cancelButn = 0;
        okButn = 1;

        ciL=-1;  {^L forced new line}
        ciQM=-2; {^? non-default ask button}
        ciEM=-3; {^! default ask button}
        ciN=-4;  {^N cite alert number}
        ciC=-5;  {^C cite last command -- change case to lower}
        ciK=-12;  {^K cite last command -- keep case as is}

        ci0=-6;  {^0 cite parameter 0}
        ci1=-7;  {^1 cite parameter 1}
        ci2=-8;  {^2 cite parameter 2}
        ci3=-9;  {^3 cite parameter 3}
        ci4=-10; {^4 cite parameter 4}
        ci5=-11; {^5 cite parameter 5}
        {note: code 12 is ciK above}

        ciS1=-15; {^7 1-digit count} {must be 0 modulo 5!!!}
        ciS2=-16; {^77 2-digit count}
        ciS3=-17; {^777 3-digit count}
        ciS4=-18; {^7777 4-digit count}
        ciS5=-19; {^77777 5-digit count}

        ciE1=-20; {^8 1-digit count} {must be 0 modulo 5!!!}
        ciE2=-21; {^88 2-digit count}
        ciE3=-22; {^888 3-digit count}
        ciE4=-23; {^8888 4-digit count}
        ciE5=-24; {^88888 5-digit count}

        ciN1=-25; {^9 1-digit count} {must be 0 modulo 5!!!}
        ciN2=-26; {^99 2-digit count}
        ciN3=-27; {^999 3-digit count}
        ciN4=-28; {^9999 4-digit count}
        ciN5=-29; {^99999 5-digit count}

{end consts shared with AlertGen: keep consistent!}

        alFldrLeft = 50;
        alFldrTop = 50;
        alFldrWidth = 620;
        alFldrHeightMin = 88;

        askButnOffset = 6;

        butRight = 600;

        heapMinFree = 12; {cbMinFree in UnitHz}
        heapOverhead = 8; {cbOvhStd+sizeof(POINTER)}

        maxWoulds = 2; {no. of calls of WouldAlert between Alert calls
                        without restarting at the first stage response}

        maxOSerror = 2000;

        minCitation = 0;
        maxCitation = 5;
        {6 still unassigned}
        minCounter = 7;
        maxCounter = 9;

        wait_Time = 1000;   {minimum uptime - millisecs - for any wait alert}

        {enterKey = 3;}

type

{begin types shared with AlertGen: keep consistent!}

        TAlertProc = getProc..cautionProc;

        TAlertSign = askProc..cautionProc;

        TAlertInfo =
            packed record               {6 bytes per alert}
                alertNumber:    integer;                  {16 bits}
                alertKind:      TAlertKind;               {4 bits}
                fBox0, fBox1, fBox2, fBox3: boolean;      {4 bits}
                volume0, volume1, volume2, volume3: 0..3; {8 bits}
                textLength:     integer;                  {16 bits}
            end;

        HBytes = ^TRgCh;

{end types shared with AlertGen: keep consistent!}

        TButnInfo =
            record
                fShown:         boolean;
                fPushed:        boolean;
                fDflt:          boolean;
                hitBox:         Rect;
            end;

        TAlertVec = array [0..0] of TAlertInfo;   {dynamic size}
        PAlertVec = ^TAlertVec;
        HAlertVec = ^PAlertVec;

        TCachedAlert = record
                           calertFile:   TAlertFile;
                           calertNumber: integer;  {0=empty slot in cache}
                           calertText:   HBytes;
                           ctextLength:  integer;
                           clruAge:      TB;       {0=young, -1=empty slot}
                           locked:       boolean;  {locked in memory?}
                       end;

        TAlertCache = array [0..0] of TCachedAlert;
        PAlertCache = ^TAlertCache;
        HAlertCache = ^PAlertCache;

{*************************************************************************}

var

        alBoxTop:       integer;
        alertHeap:      THz;

        butns:          array [cancelButn..maxButn] of TButnInfo;
        butnString:     array [0..maxButn] of string [signStrLength];

        butWidth:       integer;
        butHeight:      integer;
        butOvalWidth:   integer;
        butOvalHeight:  integer;

        cache:          HAlertCache;
        cacheAscii:     integer; {no. bytes req'd by largest alert text}
        cacheBinary:    integer; {no. bytes req'd by all alert file binaries}
        cacheCapacity:  integer; {number of bytes usable in heap}
        cacheLength:    integer; {number of alerts alowed in cache}
        cacheLoad:      integer; {number of bytes used in heap so far}
        cacheSlotsAvail:integer; {number of empty slots in the cache}

        citeArgs:       array [TArgAlert] of HBytes;
        citeCommand:    TParamAlert;
        citeNumber:     integer;
        citeCounts:     array [TCountAlert] of integer;

        cntRects:       array [TCountAlert] of Rect; {where to show counters}

        fAscent:        integer;
        fDescent:       integer;
        fOffset:        integer;
        fWidMax:        integer; { not used any more, but left in to make this reusable }

        fileCount:      integer;

        junk:           longint; { throw away VAR parameter }

        lastFile:       TAlertFile;
        lastAlert:      integer;
        lastResponse:   integer;

        lastButn:       TButn;

        lineSpc:        integer;  { line spacing }

        msgRect:        Rect;

        origAbortCount: integer;

        pushedButn:     TButn;

        countPort:      WindowPtr; {the port that cntRects are in}

        signPoints:     array [TAlertSign] of Integer;
        signPt:         array [TAlertSign, 0..8] of Point;
        signString:     array [TAlertSign] of string [signStrLength];

        theErrProcPtr:  procPtr;
        theIdleProcPtr: procPtr;

        upTime:         Milliseconds;

        woulds:         integer;


    {$ifc dbgAlEvt}
        lastB:          boolean;
        lastFldr:       WindowPtr;
        lastAct:        Integer;
    {$endc}


{*************************************************************************}

function  Alert(alertFile: TAlertFile; alertNumber: integer;
                whichProc: TAlertProc): integer; forward;

function  AlertBox(alertFile: TAlertFile; index: integer;
              dfltDis: TButn; fOneB: boolean;
              whichProc: TAlertProc): TButn; forward;

function  AlertEvent(VAR event: EventRecord; insist: boolean): boolean; forward;

procedure AssureSpace(numBytes: integer); forward;

function  CacheAlert(alertFile: TAlertFile; index, firstSlot: integer): integer;
   forward;

function  CachedAlert(alertFile: TAlertFile; index: integer): integer;
   forward;

procedure CallProc(proc: procPtr); external; {calls a procedure of no args}

function  FindSpace(firstSlot: integer): integer; forward;

procedure FlushTypeahead; forward;

function  FPosOfAlert(alertFile: TalertFile; index: integer): longint; forward;

procedure GetText(alertFile: TAlertFile; index: integer; lockIt: boolean;
                  VAR txt: HBytes; VAR len: integer); forward;

function  IndexOfAlert(alertFile: TAlertFile;
                       num: integer;
                       whichProc: TAlertProc;
                       any: boolean): integer; forward;

procedure HDispose(h: TH); forward;

function  HNew(numBytes: integer): TH; forward;

function  ReadNext(refNum: integer;
                   pFirstByte: TRgch; nBytes: integer): boolean; forward;

procedure reduceHeapUsage; forward;

procedure ShowSign(draw: boolean; whichProc: TAlertProc;
                   VAR signRight: integer); forward;

procedure ShowText(draw, measure, middle: boolean; textBuf: HBytes; chars: integer;
                   VAR lines: integer; VAR botButn, dfltDis: TButn); forward;

procedure Str(num: integer; VAR s: TParamAlert); forward;

function  UserDismissal(topButn, botButn, dfltDis: TButn;
                        savePort: grafPtr): TButn;
   forward;

{*************************************************************************}

{$S alert}
function  Alert{alertFile: TAlertFile; alertNumber: integer;
                whichProc: TAlertProc): integer};
var
  d:           TButn;
  i:           integer;
  toneVolume:  integer;
  fAlertBox:   boolean;
  index:       integer;
  alerts:      HAlertVec;
  alInfo:      TAlertInfo;
  k:           TAlertKind;
  fOneButn:    boolean;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin Alert(..., ', alertNumber:1, ', ', ord(whichProc):1, ')');
{$endc}
    if not preventReentry then
        begin
        citeNumber := alertNumber;
        if (lastFile=alertFile) and (lastAlert=alertNumber) and
           (woulds<=maxWoulds) then
          lastResponse := lastResponse+1
        else
          begin
          lastFile := alertFile;
          lastAlert := alertNumber;
          lastResponse := 0;
          end;
        woulds := 0;
        end;
    index := IndexOfAlert(alertFile, alertNumber, whichProc, false);
    alerts := pointer(alertFile^^.falerts);
    alInfo := alerts^^[index];
    with alInfo do
        begin
        k := alertKind;
        if k in [cautionInsistProc, askProc] then d := noButn
        else if k in [noteProc, cautionOKProc, cautionNoteProc] then d := okButn
        else d := cancelButn;
        fOneButn := k in [stopProc, noteProc, cautionStopProc, cautionNoteProc];
        if k=cautionStopProc then whichProc := stopProc;
        if k=cautionNoteProc then whichProc := noteProc;
        case lastResponse of
            0: begin toneVolume := volume0; fAlertBox := fbox0; end;
            1: begin toneVolume := volume1; fAlertBox := fbox1; end;
            2: begin toneVolume := volume2; fAlertBox := fbox2; end;
            otherwise begin toneVolume := volume3; fAlertBox := fbox3; end;
            end;
        if not preventReentry then
            begin
            preventReentry := true;
            alertError := 0;
            BeepAlert(toneVolume);
            if fAlertBox then
                d := AlertBox(alertFile, index, d, fOneButn, whichProc)
            else if toneVolume > 0 then
                FlushInput(nil);
            preventReentry := false;
            end;
        end;
    if not preventReentry then
        begin
        alBoxTop := alFldrTop;
        reduceHeapUsage;
        end;
{$ifc dbgAlrt}
writeln('end   Alert:=', d);
{$endc}
    Alert := d;
end;


{$S alert}
function  AlertBox{(alertFile: TAlertFile; index: integer;
              dfltDis: TButn; fOneB: boolean;
              whichProc: TAlertProc): TButn};
var
  d, ud: TButn;
  v, len, textHeight, ht, signRight: integer;
  txt: HBytes;
  savePort: grafPtr;
  topButn, botButn: TButn;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin AlertBox(..., ', index:1, ', ', ord(dfltDis):1, ', ',
                        fOneB, ', ', ord(whichProc):1, ')');
{$endc}
    GetPort(savePort);
    GetText(alertFile, index, false, txt, len);
    if alertError > 0 then begin AlertBox := dfltDis; exit(AlertBox); end;
    {determine which buttons will be shown}
    if whichProc = askProc then
        begin {phrase file text specifies buttons}
        topButn := askButnOffset+1;
        botButn := askButnOffset; {interim value}
        end
    else if whichProc = waitProc then {no buttons}
        begin {no buttons}
        topButn := okButn;
        botButn := cancelButn;
        end
    else
        begin {standard buttons}
        topButn := cancelButn;
        botButn := okButn;
        end;
    {Set port before setting font}
    SetPort(alertFolder);
    {Set font so text can be measured}
    TextFont(sysText); TextFace([]); TextMode(srcOr);
    {Get button text out of Phrase File}
    if whichProc=askProc then
       ShowText(false, false, true, txt, len, textHeight, botButn, dfltDis);
    {Measure buttons}
    butWidth := CalcButWidth(topButn, botButn, butHeight);
    {Measure sign}
    ShowSign(false, whichProc, signRight);
    {Specify text bounding box left and right}
    SetRect(msgRect, signRight+15, 0, butRight-butWidth-15, 360);
    {Measure number of lines of text}
    ShowText(false, true, true, txt, len, textHeight, botButn, dfltDis);
    {Calculate height of Alert Box}
    ht := CMax(alFldrHeightMin, (textHeight+3)*lineSpc);
    {Locate and Show Alert Box on screen}
    v := screenBits.bounds.bottom-16;
    alBoxTop := CMax(CMin(alBoxTop, v-ht), alFldrTop);
    HideFolder(alertFolder);
    MoveFolder(alertFolder, alFldrLeft, alBoxTop);
    FolderSize(alertFolder, alFldrWidth, ht, false);
    ShowFolder(alertFolder);
    {Set cursor}
    SetStdCursor(icrsInactive);
    {Show text and sign}
    msgRect.top := (ht div 2)+fOffset;
    ShowText(true, true, true, txt, len, textHeight, botButn, dfltDis);
    ShowSign(true, whichProc, signRight);
    if whichProc <> waitProc then
      begin
      {Show buttons}
      for d := topButn to botButn do
        with butns[d] do
          begin
          fPushed := false;
          if (not fOneB) or (dfltDis=d) then
             begin
             if d=topButn then v := 10
             else v := 10+(ht-20-butHeight)*(d-topButn) div (botButn-topButn);
             ShowButn(d, butRight-butWidth, v, dfltDis=d);
             end
          else
             fShown := false;
          end;
      FlushTypeahead;
      {Track button pushes}
      ud := UserDismissal(topButn, botButn, dfltDis, savePort);
      {Clean up}
      HideFolder(alertFolder);
      FlushWindow(alertFolder); {delete all events to the Alert Box}
      for d := topButn to botButn do butns[d].fShown := false;
      end;
    {Restore original states}
    butWidth := CalcButWidth(0, lastButn, butHeight);
    SetPort(savePort);
{$ifc dbgAlrt}
writeln('end   AlertBox:=', ord(ud):1);
{$endc}
    AlertBox := ud;
end;


{$S alert}
function  AlertEvent{(VAR event: EventRecord; insist: boolean): boolean};
var b: boolean;
    hEvent: EventHandle;
    fldr: WindowPtr;
    act, abortCount: Integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    b := EventAvail; {just to get rid of the hourglass}
    abortCount := 0;
    b := false;
    hEvent := FirstEvent;
    while hEvent<>nil do
        begin
        fldr := hEvent^^.who;
        act := hEvent^^.what;
        {$ifc dbgAlEvt}
        writeln('Event: who = ', ord(fldr), ' what = ', ord(act));
        {$endc}
        if act=abortEvent then
            abortCount := abortCount + 1;
        if (fldr=alertFolder) and (act<>private3) then
            begin
            event := hEvent^^;
            GlobalToLocal(event.where);
            DeleteEvent(hEvent);
            b := true;
            hEvent := nil;
            {$ifc dbgAlEvt}
            writeln('Found an event for the AlertFolder');
            {$endc}
            end
        else if (((fldr=activeFolder) or (fldr=dialogFolder) or (fldr=menuFolder))
                   and  (act<=keyDown))
             or ((fldr=activeFolder) and (act=folderDeactivate)
                  and (not BackGrInProgress))  {Added by spr 4/23/84}
             or ((act=abortEvent) and (abortCount > origAbortCount))
          then
            begin
            event := hEvent^^;
            if (act=buttonUp) or ((act<>folderDeactivate) and insist) then
                DeleteEvent(hEvent);
            b := true;
            hEvent := nil;
            {$ifc dbgAlEvt}
            writeln('Found a new abort or found an event for another folder');
            {$endc}
            end
        else
            hEvent := NextEvent(hEvent);
        end;
{$ifc dbgAlEvt}
if (b<>lastB) or (fldr<>lastFldr) or (act<>lastAct) then
   writeln('AlertEvent: ', b, ' who = ', ord(fldr), ' what = ', act)
else write('"');
lastB := b; lastFldr := fldr; lastAct := act;
{$endc}
AlertEvent := b;
end;


{$S alert}
procedure ArgAlert{(n: TArgAlert; s: Str255)};
var i: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    if (n < minCitation) or (n > maxCitation) then
        exit(ArgAlert);
    if preventReentry then
        exit(ArgAlert);
    preventReentry := true;
    HDispose(pointer(ord(citeArgs[n])));
    citeArgs[n] := pointer(ord(HNew(length(s)+1)));
    if pointer(ord(citeArgs[n])) = hNil then    (* added this line 3/8/83 *)
        begin                                   (* added this line 3/8/83 *)
        alertError := 3082;                     (* added this line 3/8/83 *)
        citeArgs[n] := nil                      (* added this line 3/8/83 *)
        end                                     (* added this line 3/8/83 *)
    else                                        (* added this line 3/8/83 *)
        for i := 0 to length(s) do
            citeArgs[n]^^[i] := ord(s[i]);
    preventReentry := false;
end;


{$S alert}
function  AskAlert{(alertFile: TAlertFile; alertNumber: integer): integer};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    InitCursor;
    AskAlert := Alert(alertFile, alertNumber, askProc) - askButnOffset;
end;


{$S alert}
procedure AssureSpace{numBytes: integer};
var ci, i, oldAge: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    {$ifc dbgAlrt}
    writeln('begin AssureSpace(', numBytes:1, ')');
    writeln('  cacheCapacity = ', cacheCapacity:1);
    {$endc}
    while (cacheSlotsAvail = 0) or
          ((cacheLoad + numBytes+heapMinFree+heapOverhead) > cacheCapacity) do
        begin
        {$ifc dbgAlrt}
        writeln('    cacheSlotsAvail, cacheLoad = ', cacheSlotsAvail:3, cacheLoad:6);
        {$endc}
        ci := 0;
        oldAge := -1;
        for i := 1 to cacheLength do
            with cache^^[i] do
                if (clruAge>oldAge) and not locked then
                    begin
                    oldAge := clruAge;
                    ci := i;
                    end;
        if ci = 0 then {should only be possible when alerts are locked}
            begin
            alertError := 3079;
            {$ifc dbgAlrt}
            writeln('alertError := 3079');
            {$endc}
            exit(AssureSpace);
            end;
        with cache^^[ci] do
            begin
            HDispose(pointer(ord(cAlertText))); {reduces cacheLoad}
            cAlertText := nil;
            calertNumber := 0;
            clruAge := -1;
            cacheSlotsAvail := cacheSlotsAvail + 1;
            end;
        end;
    {$ifc dbgAlrt}
    writeln('end AssureSpace');
    writeln('  cacheSlotsAvail, cacheLoad  =  ', cacheSlotsAvail:3, cacheLoad:6);
    {$endc}
end;


{$S alert}
function BackgroundAlert{(alertFile: TAlertFile; alertNumber: integer; alertType: TAlertKind): integer};
var
    ErrNum: integer;
    Alerts: WindowPeek;
    Interval: Timestmp_Interval;
    ClkTime: Time_Rec;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    Interval.Sec  := 5;             { Set timer delay interval to 5 seconds }
    Interval.Msec := 0;

    Sched_Class(alertError, true);   { Turn on semaphore }
    if alertError <> 0 then begin
            {$ifc dbgAlrt}
            writeln('AlertMgr:  Setting Sched_Class true. Got Error #', alertError);
            {$endc}
            BackgroundAlert := alertError;
            exit(BackgroundAlert);
    end;


    Alerts := pointer(ord(alertfolder));
    while Alerts^.Visible do         { While an alert is still up, sleep and loop }
        begin
            Delay_Time(alertError, Interval, ClkTime);
            if alertError <> 0 then begin
                    {$ifc dbgAlrt}
                    writeln('AlertMgr:  Delay_Time Error #', alertError);
                    {$endc}
                    BackgroundAlert := alertError;
            end;
        end;

    BackGrInProgress := TRUE; {Don't yield CPU while background alert in progress}

    case AlertType of

        AskProc:        BackgroundAlert := AskAlert(alertFile, alertNumber);

        CautionProc:    BackgroundAlert := ord(CautionAlert(alertFile, alertNumber));

        NoteProc:       begin
                            BackgroundAlert := 1;
                            NoteAlert(alertFile, alertNumber);
                        end;

        StopProc:       begin
                            BackgroundAlert := 1;
                            StopAlert(alertFile, alertNumber);
                        end;

        otherwise       begin
                            alertError := 3084;
                            {$ifc dbgAlrt}
                            writeln('AlertMgr:  Bad Alert Type Parameter to BackgoundAlert  ', ord(AlertType));
                            {$endc}
                            BackgroundAlert := alertError;
                        end

    end;

    BackGrInProgress := FALSE;{Can yield CPU since no BackGroundAlert in progress}

    Sched_Class(alertError, false);      { Turn off semaphore }
    if alertError <> 0 then begin
            {$ifc dbgAlrt}
            writeln('AlertMgr:  Setting Sched_Class false. Got Error #', alertError);
            {$endc}
            BackgroundAlert := alertError;
            exit(BackgroundAlert);
    end;

end;


{$S alert}
procedure BeepAlert{volume: integer};
var
  i:        integer;
  t:        longint;
  savePort: grafPtr;
  r:        rect;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    volume := CMax(0, CMin(3, volume));
    if volume=0 then {no signal at all}
        begin
        end
    else if PMBeep_Flash > 0 then
        begin {beep to signal}
        SetVolume(PMBeep_Flash+volume-1); {(1..5)+(1..3)-(1) = (1..7)}
        Beep(1136, 100*volume); {An 880 Hz A lasting .1, .2, .3 sec.}
        end
    else
        begin {flash menu bar to signal}
        GetPort(savePort);
        SetPort(menuFolder);
        for i := 1 to 2*(1+volume) do {2, 3, 4 blinks = soft, med, loud}
            begin
            SetRect(r, 0,0,720,15);
            InvertRect(r);
            t := Time;
            repeat until Time > (t+10); {1/10 sec on, 1/10 sec off}
            end;
        SetPort(savePort);
        end;
 end;


{$S alert}
function  ButnPushed{(first, last: TButn; VAR pushed: TButn; pt: Point): boolean};
var
  d: TButn;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlEvt}
writeln('begin ButnPushed(', ord(first):1, ', ', ord(last):1, ')');
{$endc}
    repeat
       pushedButn := noButn;
       for d := first to last do
          with butns[d] do
             if fShown then
                PushButn(d, PtInRect(pt, hitBox));
       GetMouse(pt);
    until not StillDown;
    pushed := pushedButn;
{$ifc dbgAlEvt}
writeln('end   ButnPushed: ', pushedButn <> noButn, ' pushed=', pushed:1);
{$endc}
    ButnPushed := pushedButn <> noButn;
end;


{$S alert}
function CacheAlert{(alertFile: TAlertFile; index, firstSlot: integer): integer};
        {call if not already in cache}
        {firstSlot=1, except when forcing alert 2 into slot 0, it is 0}
var
    ci, numBytes, eqIndex: integer;
    alerts: HAlertVec;
    txt: HBytes;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin CacheAlert(..., ', index:1, ',', firstSlot:1, ')');
{$endc}
    {$ifc dbgAlrt}
    if firstSlot=0 then
        writeln('Starting to cache alert #2');
    {$endc}
    alerts := pointer(alertFile^^.falerts);
    numBytes := -index;
    repeat
       eqIndex := -numBytes;
       numBytes := alerts^^[eqIndex].textLength
    until numBytes>=0;

    AssureSpace(numBytes);
    ci := FindSpace(firstSlot);
    if alertError > 0 then {can only happen if alerts are locked}
        exit(CacheAlert);

    txt := pointer(ord(HNew(numBytes)));
    if pointer(ord(txt)) = hNil then                (* added this line 3/8/83 *)
        begin                                       (* added this line 3/8/83 *)
        if index <> 2 then CallProc(theErrProcPtr)  (* added this line 3/8/83 *)
        {$ifc dbgAlrt}                              (* added this line 3/8/83 *)
        else writeln('Error reading alert #2!')     (* added this line 3/8/83 *)
        {$endc};                                    (* added this line 3/8/83 *)
        exit(CacheAlert);                           (* added this line 3/8/83 *)
        end                                         (* added this line 3/8/83 *)
    else                                            (* added this line 3/8/83 *)
        Read_Data(alertError, alertFile^^.frefNum, ord(txt^), numBytes,
              junk, absolute, FPosOfAlert(alertFile, eqIndex));

    {$ifc dbgAlRdErr}
    if alertError=0 then
        begin alertError := fakeAlError; fakeAlError := 0 end;
    {$endc}

    if alertError>0 then
        begin
        HDispose(pointer(ord(txt)));
        if index <> 2 then CallProc(theErrProcPtr) {prevent recursion}
        {$ifc dbgAlrt}
        else writeln('Error reading alert #2!')
        {$endc};
        exit(CacheAlert);
        end;

    {$ifc dbgAlrt}
    writeln('index = ', index:1,
            ' eqIndex = ', eqIndex:1,
            ' textLength = ', numBytes:1,
            ' pos = ', FPosOfAlert(alertFile, eqIndex):1);
    {$endc}

    with cache^^[ci] do
       begin
       calertFile := alertFile;
       calertNumber := alerts^^[index].alertNumber;
       clruAge := firstSlot; {if 1, will be reset to 0 in a moment}
       cacheSlotsAvail := cacheSlotsAvail - 1;
       calertText := txt;
       ctextLength := numBytes;
       end;

{$ifc dbgAlrt}
writeln('end   CacheAlert:=', ci:1);
{$endc}

    CacheAlert := ci;
end;


{$S alert}
function  CachedAlert{(alertFile: TAlertFile; index: integer): integer};
        {returns -1 if not in cache}
label 100;
var
    ci, i: integer;
    alerts: HAlertVec;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin CachedAlert(', index:1, ')');
{$endc}
    alerts := pointer(alertFile^^.falerts);
    ci := -1;
    for i := 0 to cacheLength do
      if (alertFile=cache^^[i].calertFile) or (index=2) then
        if alerts^^[index].alertNumber=cache^^[i].calertNumber then
            begin
            ci := i;
            goto 100;
            end;
  100:
{$ifc dbgAlrt}
writeln('end   CachedAlert:=', ci:1);
{$endc}
    CachedAlert := ci;
end;


{$S alert}
function  CalcButWidth{(topButn, botButn: TButn; VAR height: integer): integer};
var d: TButn;
    w: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    w := 0;
    if topButn <= botButn then
        begin
        TextFont(sysText);
        for d := topButn to botButn do
           w := CMax(w, StringWidth(butnString[d]));
        w := w + (2*butOvalWidth);
        end;
    height := butHeight;
    CalcButWidth := w;
end;


{$S alert}
function  CautionAlert{(alertFile: TAlertFile; alertNumber: integer): boolean};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    InitCursor;
    CautionAlert := Alert(alertFile, alertNumber, cautionProc)>0;
end;


{$S alert}
procedure CountAlert{(whichCounter: TCountAlert; countValue: integer)};
var
  savePort: grafPtr;
  s: TParamAlert;
  countRect: Rect;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    if (whichCounter < minCounter) or (whichCounter > maxCounter) then
        exit(CountAlert);
    countValue := CMax(countValue, 0);
    if citeCounts[whichCounter]=countValue then
        exit(CountAlert);
    if preventReentry then
        exit(CountAlert);
    preventReentry := true;
    citeCounts[whichCounter] := countValue;
    countRect := cntRects[whichCounter];
    GetPort(savePort);
    SetPort(countPort);
    EraseRect(countRect);
    Str(countValue, s);
    MoveTo(countRect.right-StringWidth(s), countRect.top+fascent);
    DrawString(s);
    SetPort(savePort);
    preventReentry := false;
end;


{$S alert}
procedure DfltIdleProc;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlevt}
write('.');
{$endc}
    LetOthersRun;
end;


{$S alert}
procedure DfltErrProc;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln;
writeln('*** Alert manager error*** number ', alertError:1);
{$endc}
end;


{$S alert}
procedure DrawAlert{(alertFile: TAlertFile; alertNumber: integer; marginRect: Rect)};
var
  textHeight, len, b, i: integer;
  txt: HBytes;
  irrelevant, ignore: TButn;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    if preventReentry then
        exit(DrawAlert);
    preventReentry := true;
    alertError := 0;
    citeNumber := alertNumber;
    GetText(alertFile, IndexOfAlert(alertFile, alertNumber, drawProc, false),
            false, txt, len);
    if alertError > 0 then exit(DrawAlert);
    msgRect := marginRect;
    for b := 0 to 1 do
        ShowText(b=1, true, false, txt, len, textHeight, ignore, irrelevant);
    reduceHeapUsage;
    preventReentry := false;
end;


{$S alert}
procedure DTAlert{alertFile: TAlertFile; osDT: longint; VAR userString: TParamAlert};
label 9;
var deltaDT: Seconds;
    osError: integer;
    gmt_time: time_rec;

  procedure SingularPlural(VAR str: TParamAlert);
    var slash: integer;
  begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
      slash := pos('/', str);
      if slash > 0 then
        if deltaDT = 1 THEN
            delete(str, slash, length(str)+1-slash)
        else
            delete(str, 1, slash);
  end;

{$S alert}
  procedure Ago(howManyPerLargerUnit: integer; alertNumber: INTEGER);
    var leadingText, numeral, timeUnitName, trailingText: TParamAlert;
  begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
      if deltaDT <= howManyPerLargerUnit then
          begin
          Str(deltaDT, numeral);
          GetAlert(alertFile, 901, @leadingText);
          SingularPlural(leadingText);
          if length(leadingText) > 0 then leadingText := concat(leadingText, ' ');
          GetAlert(alertFile, alertNumber, @timeUnitName);
          SingularPlural(timeUnitName);
          GetAlert(alertFile, 908, @trailingText);
          SingularPlural(trailingText);
          if length(trailingText) > 0 then trailingText := concat(' ', trailingText);
          userString := concat(leadingText, numeral, ' ', timeUnitName, trailingText);
          exit(DTAlert);
          end;
      deltaDT := deltaDT div howManyPerLargerUnit;
  end;

{$S alert}
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
Get_Time(osError, gmt_time); {just to check for errors}
if osError > 0 then goto 9;
deltaDT := TimeStamp - osDT; {TimeStamp doesn't check for enough errors}
if deltaDT < 0 then goto 9;
Ago(60, 902);
Ago(60, 903);
Ago(24, 904);
Ago(7, 905);
Ago(52, 906);
Ago(200, 907);
9:
GetAlert(alertFile, 909, @userString);
end;


{$S alert}
procedure EndWaitAlert;
VAR peek: WindowPeek;

begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
peek := POINTER(ORD(alertFolder));
IF peek^.visible
THEN BEGIN
   while  ABS(Timer - upTime) < wait_Time do {nothing} ;
   HideFolder(alertFolder);
   END;
end;



{$S alert}
function  FindSpace{(firstSlot: integer): integer};
var i: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    for i := firstSlot to cacheLength do
       if cache^^[i].calertNumber=0 then
            begin
            FindSpace := i;
            exit(FindSpace);
            end;
    alertError := 3080;
end;


{$S alert}
procedure FlushTypeahead;
var hEvent: EventHandle;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    FlushInput(nil); {flush pairs of act/deact events and bring activeFolder to front}
    origAbortCount := 0;
    hEvent := FirstEvent;
    while hEvent<>nil do
        begin
        if hEvent^^.what=abortEvent then
            origAbortCount := origAbortCount + 1;
        hEvent := NextEvent(hEvent);
        end;
end;


{$S alert}
function  FPosOfAlert{(alertFile: TalertFile; index: integer): longint};
var fp: longint;
    i: integer;
    alerts: HAlertVec;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
   with alertFile^^ do
      begin
      fp := fPos;
      alerts := pointer(fAlerts);
      end;
   for i := 1 to index-1 do
      with alerts^^[i] do
         if textLength>0 then
            fp := fp + textLength;
FPosOfAlert := fP;
end;


{$S alert}
procedure GetAlert{alertFile: TAlertFile; alertNumber: integer;
                   pStr: TPstr255};
var ps: TPStr255;
    txt: HBytes;
    index, ignored, i: integer;
    s: TParamAlert;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin   GetAlert');
{$endc}
    if preventReentry then
        begin
        s := '';
        ps := @s;
        end
    else
        begin
        preventReentry := true;
        alertError := 0;
        index := IndexOfAlert(alertFile, alertNumber, getProc, false);
        if index=1 then
            begin
            Str(alertNumber, s);
            ps := @s;
            end
        else
            begin
            GetText(alertFile, index, false, txt, ignored);
            if alertError>0 then begin s := ''; ps := @s end
            else ps := pointer(ord(txt^));
            end;
        preventReentry := false;
        end;
    for i := 0 to length(ps^) do pStr^[i] := ps^[i];
{$ifc dbgAlrt}
writeln('end   GetAlert');
{$endc}
end;


{$S alert}
procedure GetButn{d: TButn; pStr: TPstr255};
var
  i: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
     for i := 0 to length(butnString[d]) do
         pStr^[i] := butnString[d][i];
end;


{$S alert}
procedure GetText{(alertFile: TAlertFile; index: integer; lockIt: boolean;
                  VAR txt: HBytes; VAR len: integer)};
var ci, i: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin   GetText');
{$endc}
    ci := CachedAlert(alertFile, index);
    if ci < 0 then ci := CacheAlert(alertFile, index, 1);
    if alertError>0 then exit(GetText);
    if cache^^[ci].clruAge>0 then {age the others}
        begin {this will never occur for slot ci=0}
        for i := 1 to cacheLength do
            with cache^^[i] do
                if calertNumber>0 then
                    clruAge := clruAge+1;
        cache^^[ci].clruAge := 0;
        end;
    with cache^^[ci] do
       begin
       txt := cAlertText;
       len := cTextLength;
       if lockIt then locked := true;
       end;
{$ifc dbgAlrt}
writeln('end   GetText');
{$endc}
end;


{$S alert}
procedure HDispose{h: TH};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    if h <> nil then
        begin
        cacheLoad := cacheLoad - CbDataOfH(alertHeap, h) - heapOverhead;
        FreeH(alertHeap, h);
        end;
end;


{$S alert}
procedure HideButn{d: TButn};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin HideButn(', ord(d):1, ')');
{$endc}
    with butns[d] do
       begin
       EraseRect(hitBox);
       fShown := false;
       fPushed := false;
       fDflt := false;
       end;
{$ifc dbgAlrt}
writeln('end   HideButn');
{$endc}
end;


{$S alert}
function  HNew{(numBytes: integer): TH};
var h: TH;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    h := HAllocate(alertHeap, numBytes);
    if h <> hNil then                               (* added this line 3/8/83 *)
        cacheLoad := cacheLoad + CbDataOfH(alertHeap, h) + heapOverhead;
    HNew := h;
end;


{$S alert}
function  IndexOfAlert{(alertFile: TAlertFile;
                       num: integer;
                       whichProc: TAlertProc;
                       any: boolean): integer};
label 111;
var i, index, numAlerts: integer;
    alerts: HAlertVec;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin   IndexOfAlert');
{$endc}
    with alertFile^^ do
        begin
        alerts := pointer(falerts);
        numAlerts := fnumAlerts;
        end;
    for i := 1 to numAlerts do
      with alerts^^[i] do
       if alertNumber=num then
         if any or (CMin(ord(alertKind),ord(cautionProc)) = ord(whichProc)) then
            begin
            index := i;
            goto 111;
            end;
{$ifc dbgAlrt}
writeln('Didn''t find alert #', num:5, ' proc = ', ord(whichProc):1);
{$endc}
    index := 1;
    with alerts^^[index] do
        if whichProc = cautionProc then
            alertKind := cautionInsistProc
        else
            alertKind := whichProc;
   111:
{$ifc dbgAlrt}
writeln('end   IndexOfAlert = ', index:1);
{$endc}
    IndexOfAlert := index;
end;


{$S AMopen1}
procedure InitAlerts{cacheSize, cacheBytes: integer; hz: THz;
                     idleProcPtr, errProcPtr: procPtr};
var
  i:        integer;
  lFntid:   TLfntid;
  fInfo:    FontInfo;
  d:        TButn;
  copyright: TParamAlert;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin InitAlerts(', cacheSize:1, ' ', cacheBytes: 1, ', ...)');
{$endc}
    {$ifc dbgAlRdErr}
    fakeAlError := 0;
    {$endc}

    copyright := 'Copyright 1983, Apple Computer Inc.';

    BackGrInProgress := FALSE;{Can yield CPU while no backgroundalert in progress}

    fileCount := 0;
    upTime := Timer;

    with lFntid do
      begin
      fam := systext;
      seteface := [];
      dev := devScreen;
      end;
    if FMFontMetrics(lFntid, fInfo, alertError) then begin end;
    if alertError>0 then exit(InitAlerts);

    with fInfo do
        begin
        fAscent := ascent;
        fDescent := descent;
        linespc := ascent+descent+leading;
        end;
    fOffset := (fAscent-fDescent) div 2;

    butHeight := fascent+fdescent+7;
    butOvalHeight := butHeight div 2;
    butOvalWidth := butHeight;
    {butWidth set later using CalcButWidth}
    lastButn := -1;
    for d := 0 to maxButn do
       with butns[d] do
           begin
           fShown := false;
           fPushed := false;
           fDflt := false;
           SetRect(hitBox, -100, -100, 0, 0);
           end;

    if idleProcPtr=nil then theIdleProcPtr := @dfltIdleProc
    else theIdleProcPtr := idleProcPtr;

    if errProcPtr=nil then theErrProcPtr := @dfltErrProc
    else theErrProcPtr := ErrProcPtr;

    refuseDeactivate := false;

    preventReentry := false;
    traceWouldAlert := false;

    lastFile := nil;
    lastAlert := 0;
    woulds := 0;
    citeCommand := 'do that';
    for i := minCitation to maxCitation do citeArgs[i] := nil;
    for i := minCounter to maxCounter do SetRect(cntRects[i], 0, 0, 0, 0);
    alBoxTop := alFldrTop;

    countPort := dialogFolder;

    cacheLength := cacheSize;
    cacheCapacity := cacheBytes;
    cacheLoad := 0;
    cacheAscii := 0;
    cacheBinary := (cacheLength+1)*sizeof(TCachedAlert);

    alertHeap := hz;
    cache := pointer(ord(HNew(cacheBinary)));

    if pointer(ord(cache)) = hNil then          (* added this line 3/8/83 *)
        begin                                   (* added this line 3/8/83 *)
        alertError := 3082;                     (* added this line 3/8/83 *)
        exit(InitAlerts);                       (* added this line 3/8/83 *)
        end;                                    (* added this line 3/8/83 *)

    cacheBinary := cacheBinary + heapOverhead;

    for i := 0 to cacheLength do
      with cache^^[i] do
        begin
        calertNumber := 0;
        clruAge := -1;
        locked := false;
        end;
    cacheSlotsAvail := cacheLength + 1;
{$ifc dbgAlrt}
writeln('end   InitAlerts');
{$endc}
end;


{$S AMopen1}
procedure initMP
   {myHeap         : Thz;
    toolPreFix     : TParamAlert;
    ptrToAlertProc : procPtr;
    phraseversion  : integer;
    myMenus        : rMenuPtr;
    var alertFile  : TAlertFile;
    var error      : integer
   };
var FileRefnum : integer;
    numMenus   : integer;
    numBytes   : integer;
    cacheSize  : integer;
    cacheBytes : integer;
    x          : integer;
    mapping    : integer;
    fileName   : pathname;
    menu       : MenuInfo;


    {$S AMopen1}
    function ReadBytes(dataPtr : PtrData; numBytes : longint) : boolean;
    begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
       Read_Data(error, FileRefnum, ord(dataPtr), numbytes, numbytes, sequential, 0);
       ReadBytes := (error <> 0)
    end;

{$S AMopen1}
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin InitMP');
{$endc}

   {Open Phrase File}
   upTime := Timer;
   fileName := concat(toolPrefix, 'PHRASE');
   open(error, fileName, FileRefnum, [DRead]);
   case error of
      0,
      -1173,                   {warning errors from OS}
      -1174,
      -1175   : ;
      otherwise exit(initMP)
   end;

   {read in the menu information}
   if ReadBytes(@numMenus, sizeOf(numMenus)) then exit(initMP);
   for x := 0 to numMenus - 1 do begin
      with myMenus^[x] do begin
         drawProc   := @drawTxtMenu;
         chooseProc := @chooseTxtItem
      end;
      if ReadBytes(@myMenus^[x].menuID, sizeOf(myMenus^[x].menuID)) then exit(initMP);
      if ReadBytes(@myMenus^[x].enableFlags, sizeOf(myMenus^[x].enableFlags)) then exit(initMP);
      if ReadBytes(@numBytes, sizeOf(numBytes)) then exit(initMP);
      myMenus^[x].menuData := pointer(ord(hallocate(pointer(ord(myHeap)), numbytes)));
      if ReadBytes(@myMenus^[x].menuData^^, numBytes) then exit(initMP);
      CalcMenuSize(myMenus^[x])
   end;
   if ReadBytes(@mapping, sizeOf(mapping)) then exit(initMP);
   if mapping <> 0 then begin
      error := 3083;
      exit(initMP)
   end;

   {read in alert information}
   if ReadBytes(@cacheSize, sizeOf(cacheSize)) then exit(initMP);
   if ReadBytes(@cacheBytes, sizeOf(cacheBytes)) then exit(initMP);
   InitAlerts(cacheSize, cacheBytes, myHeap, nil, ptrToAlertProc);
   if alertError = 0 then alertFile := ReadAlerts(FileRefNum, phraseVersion);
   error := alertError;
{$ifc dbgAlrt}
writeln('end   InitMP');
{$endc}
end;





{$S alert}
procedure LdSgAl;
begin {force Alert Manager to swap in}
{$IFC fTraceAM}    LogCall;     {$ENDC}
end;


{$S alert}
procedure LocateAlert{top: integer};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
   alBoxTop := top;
end;


{$S alert}
procedure LockAlert{alertFile: TAlertFile; alertNumber: integer};
var txt: HBytes;
    len: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    alertError := 0;
    GetText(alertFile, IndexOfAlert(alertFile, alertNumber, getProc, true),
            true, txt, len);
end;


{$S alert}
procedure NoteAlert{alertFile: TAlertFile; alertNumber: integer};
var
  dummy: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    InitCursor;
    dummy := Alert(alertFile, alertNumber, noteProc);
end;


{$S AMcold}
function  NthAlert{(ordinal: INTEGER; alertFile: TAlertFile;
                   VAR alertNumber, numStages: integer; VAR alertKind: TAlertKind): BOOLEAN};
var numAlerts, num: integer;
    alerts: HAlertVec;
    kind: TAlertKind;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    with alertFile^^ do
        begin
        alerts := pointer(falerts);
        numAlerts := fnumAlerts;
        end;
    if (ordinal < 1) OR (ordinal > numAlerts) then
        NthAlert := false
    else
        begin
        with alerts^^[ordinal] DO
            begin
            num := alertNumber;
            kind := alertKind;
            if (fBox3 <> fBox2) or (volume3 <> volume2) then numStages := 4
            else if (fBox2 <> fBox1) or (volume2 <> volume1) then numStages := 3
            else if (fBox1 <> fBox0) or (volume1 <> volume0) then numStages := 2
            else numStages := 1;
            NthAlert := true;
            END;
        alertNumber := num;
        alertKind := kind;
        end;
end;


{$S AMopen1}
procedure OpenPhraseFile{VAR refNum: integer; path: pathName};
var
    refInfo:    fs_info;
    resetStatus: boolean;
    i:          integer;
    checksum:   -128..127;
    block:      array [0..511] of -128..127;
    actual:     longint;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin OpenPhraseFile(..., ', path, ')');
{$endc}
    path := concat(path, 'PHRASE');
    Open(alertError, path, refNum, [DRead]);
{$ifc dbgAlOpErr}
    writeln('To simulate an error opening the phrase file, enter:');
    write('   -1173 or -1174 for bad close, -1175 for scavenge, 0 for OK: ');
    readln(alertError);
{$endc}
    resetStatus := (alertError = -1173) or (alertError = -1174); {abnormal close}
    if alertError = -1175 then {scavenged}
        begin
        checksum := 0;
        repeat
           Read_Data(alertError, refNum, ord(@block[0]), 512, actual,
                     sequential, 0);
           for i := 0 to actual-1 do checksum := checksum + block[i];
        until (actual < 512) or (alertError > 0);
        if (alertError = 848) or (alertError = 956) or (alertError = 0) then
            Read_Data(alertError, refNum, ord(@junk), 0, junk, absolute, 0);
        if alertError <> 0 then begin end
        else if checksum = 50 then resetStatus := true
        else
            begin
{$ifc dbgAlOpErr}
            writeln('50 <> Checksum = ', checksum:1);
{$endc}
            alertError := 3081;
            end;
        end;
    if resetStatus then
        begin
        Info(alertError, refNum, refInfo);
        if alertError <= 0 then
            begin
            with refInfo do
                begin
                file_scavenged := false;
                file_closed_by_os := false;
                file_left_open := false;
                end;
            Set_File_Info(alertError, refNum, refInfo);
            alertError := 0;
            end;
        end;
{$ifc dbgAlrt}
writeln('end   OpenPhraseFile');
{$endc}
end;


{$S alert}
procedure ParamAlert{cite1, cite2, cite3: Str255};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('ParamAlert(', cite1, ', ', cite2, ', ', cite3, ')');
{$endc}
    ArgAlert(1, cite1);
    ArgAlert(2, cite2);
    ArgAlert(3, cite3);
end;


{$S alert}
procedure PushButn{d: TButn; f: boolean};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    with butns[d] do
      begin
      if fShown and (fPushed<>f) then
        InvertRoundRect(hitBox, butOvalWidth, butOvalHeight);
      fPushed := f;
      end;
    if f then pushedButn := d;
end;


{$S AMopen1}
function  ReadAlerts{(refNum, version: integer): TAlertFile};
var
  i: integer;
  p: TAlertProc;
  d: TButn;
  alertFile: TAlertFile;
  numAlerts: integer;
  alerts: HAlertVec;
  refinfo: fs_info;
  itsVersion: integer; {version<0 means don't check}
  warning: integer;
  numBytes, mayRef: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin ReadAlerts(..., ', refNum:1, ')');
{$endc}
    ReadAlerts := nil;
    warning := 0;

    if not ReadNext(refNum, @itsVersion, 2) then
        exit(ReadAlerts);
    if (version>=0) and (itsVersion<>version) then
        warning := -3076;

    fileCount := fileCount + 1;
    if fileCount = 1 then
        mayRef := refNum
    else
        mayRef := -refnum;
    for p := askProc to cautionProc do
        begin
        if not ReadNext(mayRef, @signString[p], 1+signStrLength) then
            exit(ReadAlerts);
        if not ReadNext(refNum, @i, sizeof(signPoints[p])) then
            exit(ReadAlerts);
        if fileCount = 1 then
            signPoints[p] := i;
        if not ReadNext(mayRef, @signPt[p,0], (i+1)*sizeof(signPt[p,0])) then
            exit(ReadAlerts);
        end;
    if not ReadNext(refNum, @i, 2) then {i used below}
        exit(ReadAlerts);
    if fileCount = 1 then
        lastButn := i; {can't readNext directly because it's a byte var not a word}
    for d := cancelButn to i do
        if not ReadNext(mayRef, @butnString[d], 1+signStrLength) then
            exit(ReadAlerts);
    if fileCount = 1 then
        butWidth := CalcButWidth(0, lastButn, butHeight);

    if not ReadNext(refNum, @numAlerts, 2) then
        exit(ReadAlerts);
    numBytes := (1+numAlerts)*sizeof(TAlertInfo);

    cacheBinary := cacheBinary + numBytes + sizeof(TAlertRec) + 2*heapOverhead;
    if cacheBinary > cacheCapacity then
        begin {alert array and file descriptor won't fit}
        alertError := 3077;
        exit(ReadAlerts);
        end;

    {$ifc dbgAlrt}
    writeln('ask=',signString[askProc]);
    writeln('ok=',butnString[okButn]);
    writeln('numAlerts=', numAlerts);
    {$endc}

    alerts := pointer(ord(HNew(numBytes)));

    if pointer(ord(alerts)) = hNil then         (* added this line 3/8/83 *)
        begin                                   (* added this line 3/8/83 *)
        alertError := 3082;                     (* added this line 3/8/83 *)
        exit(ReadAlerts);                       (* added this line 3/8/83 *)
        end;                                    (* added this line 3/8/83 *)

    if not ReadNext(refNum, @alerts^^[1], numAlerts*sizeof(TAlertInfo)) then
        exit(ReadAlerts);

    {$ifc dbgAlrt}
    writeln('Finished reading phrase file header');
    for i := 1 to numAlerts do
       with alerts^^[i] do
          writeln('Alert #', alerts^^[i].alertNumber:5, '  ... ',
                  '  kind=', ord(alertKind):1,
                  ', size=', textLength);
    {$endc}

    Info(alertError, refNum, refInfo);
    if alertError>0 then
        exit(ReadAlerts);
    alertFile := pointer(ord(HNew(sizeof(TAlertRec))));

    if pointer(ord(alertFile)) = hNil then      (* added this line 3/8/83 *)
        begin                                   (* added this line 3/8/83 *)
        alertError := 3082;                     (* added this line 3/8/83 *)
        exit(ReadAlerts);                       (* added this line 3/8/83 *)
        end;                                    (* added this line 3/8/83 *)

    with alertFile^^ do
       begin
       frefNum := refNum;
       fnumAlerts := numAlerts;
       falerts := ord(alerts);
       fPos := refInfo.fMark;
       end;
    {$ifc dbgAlrt}
    writeln('fPos = ', alertFile^^.fPos);
    {$endc}

    if fileCount = 1 then {permanently cache alert #2 in slot 0}
        i := CacheAlert(alertFile, 2, 0);

    for i := 1 to numAlerts do
        if i <> 2 then
            with alerts^^[i] do
                cacheAscii := CMax(cacheAscii, textLength);

    if (cacheAscii + cache^^[0].cTextLength + 2*heapOverhead + cacheBinary) > cacheCapacity then
        begin {biggest alert text plus alert#2 won't fit}
        alertError := 3078;
        exit(ReadAlerts);
        end;

    if alertError=0 then alertError := warning;
    ReadAlerts := alertFile;
{$ifc dbgAlrt}
writeln('end   ReadAlerts');
{$endc}
end;


{$S AMopen1}
function ReadNext{(refNum: integer; pFirstByte: TRgch; nBytes: integer): boolean};
   begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
      if refNum > 0 then
          Read_Data(alertError, refNum, ord(pFirstByte), nBytes, junk, sequential, 0)
      else
          Read_Data(alertError, -refnum, ord(@junk), 0, junk, relative, nBytes);
      ReadNext := alertError <= 0;
   end;


{$S alert}
procedure reduceHeapUsage;
var i: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    for i := minCitation to maxCitation do
        begin
        HDispose(pointer(ord(citeArgs[i])));
        citeArgs[i] := nil;
        end;
end;


{$S alert}
procedure ReshowButn{d: TButn};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin ReshowButn(', ord(d):1, ')');
{$endc}
   with butns[d] do
      if fShown then
         ShowButn(d, hitBox.topLeft.h, hitBox.topLeft.v, fDflt);
{$ifc dbgAlrt}
writeln('end   ReshowButn');
{$endc}
end;


{$S alert}
procedure SetButWidths{(width: integer)};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    butWidth := width;
end;


{$S alert}
procedure ShowButn{d: TButn; h, v: integer; fDefault: boolean};
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin ShowButn(', ord(d):1, ', ', h:1, ', ', v:1, ')');
{$endc}
   with butns[d] do
      begin
      TextFont(sysText); TextFace([]); TextMode(srcOr);
      SetRect(hitBox, h, v, h+butWidth, v+butHeight);
      EraseRect(hitBox);
      PenNormal;
      fDflt := fDefault;
      if fDefault then PenSize(3, 2);
      FrameRoundRect(hitBox, butOvalWidth, butOvalHeight);
      PenNormal;
      MoveTo(h + (butWidth-StringWidth(butnString[d])) div 2, v + fAscent + 3);
      DrawString(butnString[d]);
      fShown := true;
      if fPushed then begin fPushed := false; PushButn(d, true) end;
      end;
{$ifc dbgAlrt}
writeln('end   ShowButn');
{$endc}
end;


{$S alert}
procedure ShowSign{draw: boolean; whichProc: TAlertProc;
                   VAR signRight: integer};
var rgn: RgnHandle;
    i, dv, dh, sh, sv: integer;
    r: Rect;
    s: string [signStrLength];
    pat: Pattern;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin ShowSign(', ord(whichProc):1, ')');
{$endc}
   rgn := NewRgn;
   if pointer(ord(rgn)) <> hNil then                (* added this line 3/8/83 *)
      begin                                         (* added this line 3/8/83 *)
      PenMode(-1);
      OpenRgn;
      with SignPt[whichProc, 1] do MoveTo(h, v);
      signRight := 10;
      for i := signPoints[whichProc] downto 1 do
         with SignPt[whichProc,i] do
            begin
            LineTo(h, v);
            signRight := CMax(h, signRight);
            end;
      CloseRgn(rgn);
      PenNormal;
      if draw then FillRgn(rgn, black);
      DisposeRgn(rgn);
      end;                                          (* added this line 3/8/83 *)
   s := signString[whichProc];
   dh := StringWidth(s) div 2 + 2;
   with SignPt[whichProc, 0] do
      begin sh := h; sv := v; end;
   MoveTo(sh-dh+2, sv+fOffset);
   if pointer(ord(rgn)) <> hNil then                (* added this line 7/4/83 *)
      TextMode(srcBic);
   if draw then DrawString(s);
   TextMode(srcOr);
{$ifc dbgAlrt}
writeln('end   ShowSign');
{$endc}
end;


{$S alert}
procedure ShowText{draw, measure, middle: boolean; textBuf: HBytes; chars: integer;
                   VAR lines: integer; VAR botButn, dfltDis: TButn};
        {textBuf^^[0..chars-1] is of the form:
            repeat
                    wordCode: byte
                    word: array [1..wordCode] of byte;
            where each word includes its spaces (if any)
            and where wordCode < 0 means:
                ciL  represents a ^L (forced new line)
                ciQM represents a ^? (non-default ask button)
                ciEM represents a ^! (default ask button)
                ciN  represents a ^N (cite alert number)
                ciC  represents a ^C (cite last command--change case to lower)
                ciK  represents a ^K (cite last command--keep case as is)
                ci0  represents a ^0 (cite parameter 0)
                     ...
                ci5  represents a ^5 (cite parameter 5)
                ciS1 represents a ^7 (1-digit count)
                     ...
                ciS5 represents a ^77777 (5-digit count)
                ciE1 represents a ^8 (1-digit count)
                     ...
                ciE5 represents a ^88888 (5-digit count)
                ciN1 represents a ^9 (1-digit count)
                     ...
                ciN5 represents a ^99999 (5-digit count)
                }
  var hPos, vPos, lMarg, rMarg: integer;
      wordCode, wordLength, i, j, x: integer;
      s, thisWord: TParamAlert;
      endOfWord: boolean;
      s1: string[1];
      hb: hBytes;
      c: char;
{$S alert}
  procedure Fit(ch: char);
  var wordWidth: integer;
  begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
      if (endOfWord and (ch<>' ')) or (ord(ch)=0) or (wordLength=40) then
          begin
          wordWidth := StringWidth(thisWord);
          if (hPos+wordWidth > rMarg) and (hPos > lMarg) then
              begin
              hPos := lMarg;
              vPos := vPos+lineSpc;
              if draw then MoveTo(hPos, vPos);
              lines := lines + 1;
              end;
          hPos := hPos + wordWidth;
          if draw then DrawString(thisWord);
          wordLength := 0;
          thisWord := '';
          end;
      if ord(ch) <> 0 then
          begin
          wordLength := wordLength + 1;
          s1[1] := ch;
          Insert(s1, thisWord, wordLength);
          end;
      endOfWord := ch=' ';
  end;
{$S alert}
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin ShowText(..., ', chars:1, ', ', lines:1, ')');
{$endc}
    endOfWord := false;
    wordLength := 0;
    thisWord := '';
    s1 := ' ';
    lMarg := msgRect.topLeft.h;
    rMarg := msgRect.botRight.h;
    hPos := lMarg;
    if draw then
        begin
        vPos := msgRect.topLeft.v;
        if middle then vPos := vPos - (((lines-1)*lineSpc) div 2)
        else vPos := vPos + fAscent;
        end
    else
        begin lines := 0; vPos := 0; end;
    MoveTo(hPos, vPos);
    i := 0;
    while i < chars do
        begin
        wordCode := textBuf^^[i];
        i := i + 1;
        if wordCode>0 then
             begin
             if draw or measure then
                 for j := i to i+wordCode-1 do
                     Fit(chr(textBuf^^[j]));
             i := i + wordCode;
             end
        else if draw or measure then
            case wordCode of
                ciL:
                    begin
                    Fit(chr(0));
                    hPos := rMarg+1;
                    end;
                ciN, ciC, ciK:
                    begin
                    if wordCode=ciN then Str(citeNumber, s)
                    else s := citeCommand;
                    for j := 1 to length(s) do
                        begin
                        c := s[j];
                        if (wordCode=ciC) and ('A'<=c) and (c<='Z') then
                            c := chr(ord(c)+ord('a')-ord('A'));
                        Fit(c);
                        end;
                    end;
                ci0, ci1, ci2, ci3, ci4, ci5:
                    begin
                    hb := citeArgs[ci0-wordCode];
                    if hb <> NIL then
                        for j := 1 to hb^^[0] do
                            Fit(chr(hb^^[j]));
                    end;
                ciS1, ciS2, ciS3, ciS4, ciS5,
                ciE1, ciE2, ciE3, ciE4, ciE5,
                ciN1, ciN2, ciN3, ciN4, ciN5:
                    begin
                    getPort(countPort);
                    Fit(chr(0));
                    x := hPos;
                    hPos := x + ((abs(wordCode) mod 5) + 1)*StringWidth('9');
                    SetRect(cntRects[((ciS1-wordCode) div 5) + minCounter],
                            x, vPos-fascent, hPos, vPos+fdescent);
                    MoveTo(hPos, vPos);
                    end;
                ciQM, ciEM:
                    i := i + textBuf^^[i] + 1;
                end
        else
            case wordCode of
                ciQM, ciEM:
                    begin
                    botButn := botButn + 1;
                    if wordCode=ciEM then dfltDis := botButn;
                    for j := 0 to textBuf^^[i] do
                        begin
                        butnString[botButn][j] := chr(textBuf^^[i]);
                        i := i + 1;
                        end;
                    end;
            end;
        end;
    Fit(chr(0));
{$ifc dbgAlrt}
writeln('end   ShowText');
{$endc}
end;


{$S alert}
procedure StopAlert{alertFile: TAlertFile; alertNumber: integer};
var
  dummy: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    InitCursor;
    dummy := Alert(alertFile, alertNumber, stopProc);
end;


{$S alert}
procedure Str{num: integer; VAR s: TParamAlert};
var neg: boolean;
    s1:  string[1];
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
   neg:= num<0;
   num := abs(num);
   if num=0 then s := '0'
   else s := '';
   s1 := ' ';
   while num>0 do
      begin
      s1[1] := chr((num mod 10)+48);
      Insert(s1, s, 1);
      num := num div 10;
      end;
   if neg then Insert('-', s, 1);
end;


{$S alert}
procedure UnlockAlerts;
var i: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    for i := 1 to cacheLength do
        cache^^[i].locked := false;
end;


{$S alert}
function  UserDismissal{(topButn, botButn, dfltDis: TButn;
                         savePort: grafPtr): TButn};
label 999;
var
    event: eventRecord;
    t: integer;
    pushed: TButn;
    insist: boolean;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlEvt}
writeln('begin UserDismissal(', ord(topButn):1, ',', ord(botButn):1, ',',
                             ord(dfltDis):1, ')');
lastB:=false;
lastFldr:=nil;
lastAct:=-1;
{$endc}

    insist := (dfltDis = noButn);

    if refuseDeactivate or insist then
        begin {Push a dummy private3 event to keep other processes from seeing queued events}
        with event do
            begin
            what := private3;
            fromFolder := alertFolder;
            fromProcess := my_id;
            who := alertFolder;
            toProcess := fromProcess;
            end;
        PushEvent(event);
        end;

    while true do
       if not AlertEvent(event, insist) then
          begin
          SetPort(savePort);
          IF BackGrInProgress THEN {if no background alert up don't let others run}
             BusyDelay(3000) {Keep hour glass from appearing}
          ELSE {Let others have a shot at some CPU cycles}
             CallProc(theIdleProcPtr);
          SetPort(alertFolder);
          end
       else
          with event do
             if what=buttonUp then begin end
             else if (what=folderDeactivate) and (refuseDeactivate or insist) then
                 begin {refuse}
                 BeepAlert(1); {soft beep}
                 FlushInput(nil); {flush two pairs of act/deact events and bring activeFolder to front}
                 SetPort(alertFolder);
                 end
             else if (who<>alertFolder) or (what=abortEvent) then
                 begin
                 if insist then BeepAlert(1)
                 else
                    begin
                    PushButn(dfltDis, true);
                    pushed := dfltDis;
                    goto 999;
                    end
                 end
             else if what=buttonDown then
                 begin
                 if ButnPushed(topButn, botButn, pushed, where) then
                    goto 999;
                 end
             else if what=folderUpdate then
                 begin
                 BeginUpdate(alertFolder);
                 EndUpdate(alertFolder);
                 end;
999:
{$ifc dbgAlEvt}
writeln('end   UserDismissal:=', ord(pushed):1);
{$endc}

    t := Time + 25; repeat until Time > t; { display state at least 1/4 second }
    UserDismissal := pushed;
end;


{$S alert}
procedure WaitAlert{alertFile: TAlertFile; alertNumber: integer};
var
  i: integer;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
    if not preventReentry then
        for i := minCount to maxCount do
            citeCounts[i] := -1;
    upTime := Timer;
    BusyDelay(0);
    i := Alert(alertFile, alertNumber, waitProc);
end;


{$S AMothrwk}
procedure WouldAlert{VAR menu: menuInfo; itemIndex: integer};
var cite: Str255;
begin
{$IFC fTraceAM}    LogCall;     {$ENDC}
{$ifc dbgAlrt}
writeln('begin WouldAlert(..., ', itemIndex:1, ')');
{$endc}
    GetItem(menu, itemIndex, @cite);
    if length(cite) > 40 then
        cite := Concat(Copy(cite, 1, 37), '...');
    citeCommand := cite;
    woulds := woulds + 1;
{$ifc dbgAlWould}
    if traceWouldAlert then
        writeln('WouldAlert #', woulds:1, '(', cite, ')');
{$endc}
{$ifc dbgAlrt}
writeln('end   WouldAlert ', citeCommand);
{$endc}
end;


end.
