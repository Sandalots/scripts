program AlertGen; {Copyright 1983, Apple Computer Inc.}

{12/26/82 -- A4}
   {added copyright notices to unit source and object}
   {added ^K like ^C}
   {file format changes (backward compatible)}
        {added ^K code}
        {added copyright notice to binary phrase file (just before checksum)}

{$R-}


{***********************************************************************}


uses

    {$U libsm/UNITSTD}         UnitStd,
    {$U libsm/UNITHZ}          UnitHz,
    {$U libos/SYSCALL}         SysCall;


label 777, 999;

const
        alertLimit = 2000;
        textLimit  = 2000;

        charCr =  13;
        charSp =  32;
        charUA =  65;
        charUC =  67;
        charUK =  75;
        charUL =  76;
        charUN =  78;
        charUZ =  90;
        charLa =  97;
        charLc =  99;
        charLk = 107;
        charLl = 108;
        charLn = 110;
        charLz = 122;
        charPl =  43;
        charSe =  59;
        charDl =  36;
        charUp =  94;
        charEq =  61;
        charQM =  63;
        charEM =  33;
        char0  =  48;
        char1  =  49;
        char2  =  50;
        char3  =  51;
        char4  =  52;
        char5  =  53;
        char6  =  54;
        char7  =  55;
        char8  =  56;
        char9  =  57;

        nestLimit = 2;

        maxButn = 6;

        kindWord = 256;

{begin consts shared with AlertMgr IMPLEMENTATION: keep consistent!}

        signStrLength = 15;   {must be odd}

        cancelButn = 0;
        okButn = 1;

        ciL=-1;  {^L forced new line}
        ciQM=-2; {^? non-default ask button}
        ciEM=-3; {^! default ask button}
        ciN=-4;  {^N cite alert number}
        ciC=-5;  {^C cite last command--change case to lower}
        ciK=-12;  {^K cite last command -- keep case as is}

        ci0=-6;  {^0 cite parameter 0}
        ci1=-7;  {^1 cite parameter 1}
        ci2=-8;  {^2 cite parameter 2}
        ci3=-9;  {^3 cite parameter 3}
        ci4=-10; {^4 cite parameter 4}
        ci5=-11; {^5 cite parameter 5}
        {note: code 12 is ciK above}

        ciS1=-15; {^7 1-digit count} {must be 0 modulo 5!!!}
        ciS2=-16; {^77 2-digit count}
        ciS3=-17; {^777 3-digit count}
        ciS4=-18; {^7777 4-digit count}
        ciS5=-19; {^77777 5-digit count}

        ciE1=-20; {^8 1-digit count} {must be 0 modulo 5!!!}
        ciE2=-21; {^88 2-digit count}
        ciE3=-22; {^888 3-digit count}
        ciE4=-23; {^8888 4-digit count}
        ciE5=-24; {^88888 5-digit count}

        ciN1=-25; {^9 1-digit count} {must be 0 modulo 5!!!}
        ciN2=-26; {^99 2-digit count}
        ciN3=-27; {^999 3-digit count}
        ciN4=-28; {^9999 4-digit count}
        ciN5=-29; {^99999 5-digit count}

{end consts shared with AlertMgr IMPLEMENTATION: keep consistent!}


type

{begin types shared with AlertMgr IMPLEMENTATION: keep consistent!}

        TAlertKind = (getProc,          {this order is relied upon!!}
                      drawProc,
                      askProc, waitProc, stopProc, noteProc, cautionProc,
                      cautionOKproc, cautionCancelProc,
                      cautionStopProc, cautionNoteProc,
                      cautionInsistProc); {up to 16 possible}

        TAlertProc = getProc..cautionProc;

        TAlertSign = askProc..cautionProc;

        TAlertInfo =
            packed record               {6 bytes per alert}
                alertNumber:    integer;                  {16 bits}
                alertKind:      TAlertKind;               {4 bits}
                fBox0, fBox1, fBox2, fBox3: boolean;      {4 bits}
                volume0, volume1, volume2, volume3: 0..3; {8 bits}
                textLength:     integer;                  {16 bits}
            end;

        HBytes = ^TRgCh;

{end types shared with AlertMgr IMPLEMENTATION: keep consistent}

        TButn  = 0..maxButn;

        Point  = record v, h: integer end;
        TBytes = array [0..textLimit] of TB;
        byte   = TB;
        str255 = String[255];
        TKeyword = (wdBad, wdStop, wdCaution, wdNote, wdWait, wdAsk, wdDraw,
                    wdOk, wdCancel, wdInsist,
                    wdEqual, wdSilent, wdSoft, wdMedium, wdLoud, wdAlert,
                    wdPlus, wdSemi, wdCr);
                 {required order: wdBad first, wdCr last}

var

        copyright:      string[40];

        listAlerts:     boolean;
        explained:      boolean;

        alerts:         array [1..alertLimit] of TAlertInfo;
        texts:          array [1..alertLimit] of HBytes;
        alertNumber:    integer; {current alert number}
        index:          integer; {current alert index}
        numAlerts:      integer; {last index used in arrays alerts and texts}

        errNum:         integer;
        junk:           longint; {throw away VAR parameter}

        ucsdFiles:      array[0..nestLimit] of TEXT;
        ucsdNames:      array[0..nestLimit] of Str255;
        nestLevel:      integer;

        phraseFile:     integer; {refNum}
        rootName:       pathname;
        inputName:      string[40];
        outputName:     pathname;
        volLength:      integer;

        buttString:     array [cancelButn..maxButn] of
                                              string [signStrLength];
        buttName:       array [cancelButn..okButn] of string [10];
        lastButn:       TButn;

        signString:     array [TAlertSign] of string [signStrLength];
        signName:       array [TAlertSign] of string [10];
        signPoints:     array [TAlertSign] of Integer;
        signPt:         array [TAlertSign, 0..8] of Point;

        source:         str255;  {parse source}
        poss:           integer; {scan position in parse source}
        this:           integer;    {character at source[poss]}
        singleChar:     string[1];
        singleWord:     str255;
        keywords:       array [TKeyword] of String[10];

        hz:             THz;
        pLim:           TP;
        pFst:           TP;

        heapStart:      longint;
        heapSize:       longint;
        ldsn:           integer;
        dsrefnum:       integer;
        dspathname:     PathName;

        itsVersion:     integer;




FUNCTION HeapError(hz: Thz; bytesNeeded: INTEGER): INTEGER;
BEGIN
  WRITELN; WRITELN('The heap is full.  User Croak !! ');
  write('type SPACE to exit'); readln;
  goto 999;
END;


procedure Mistake(s: Str255);
begin
   writeln;
   writeln('Fatal error in Phrase File, Alert Section.', chr(7));
   if alertNumber<0 then writeln('At the beginning of the file')
   else writeln('At alert number ', alertNumber:1, '.');
   writeln;
   writeln('Error is... ', s, '.');
   writeln;
   writeln('Type CR to return to the shell.');
   readln;
   goto 999;
end;


function Stageless(alertInfo: TAlertInfo): boolean;
var s: boolean;
begin
   Stageless := alertInfo.alertKind=getProc;
end;


procedure Str(num: integer; VAR s: Str255);
var neg: boolean;
    s1:  string[1];
begin
   neg:= num<0;
   num := abs(num);
   if num=0 then s := '0'
   else s := '';
   s1 := ' ';
   while num>0 do
      begin
      s1[1] := chr((num mod 10)+48);
      Insert(s1, s, 1);
      num := num div 10;
      end;
   if neg then Insert('-', s, 1);
end;



procedure IOerror(errNum: integer; s: Str255);
var r: Str255;
begin
   writeln;
   writeln('Input file is: ', ucsdNames[nestLevel]);
   writeln('Output file is: ', outputName);
   Str(errNum, r);
   Mistake(concat(r, s));
end;


procedure WriteNext(pFirstByte: TRgch; nBytes: integer);
begin
   if nBytes>0 then
        Write_Data(errNum, phraseFile, ord(pFirstByte), nBytes,
             junk, sequential, 0);
   if errNum>0 then
      IOerror(errNum, ' Writing the output file!');
end;


function  Suffix(fileName, ext: Str255): boolean;
var good: boolean;
    i, fc, ec: integer;
   begin
   good := true;
   if length(fileName)<length(ext) then
      good := false
   else
      for i := 1 to length(ext) do
         begin
         fc := ord(fileName[length(fileName)-length(ext)+i]);
         ec := ord(ext[i]);
         if ((charLa<=fc) and (fc<=charLz)) then fc := fc+charUA-charLa;
         if ((charLa<=ec) and (ec<=charLz)) then ec := ec+charUA-charLa;
         if ec<>fc then good := false;
         end;
   Suffix := good;
end;


procedure ReadNext(var s: Str255);
var fini: boolean;
begin
   repeat
      fini := true;
      if nestLevel<0 then
         Mistake('A line with just a zero should precede EOF');
      readln(ucsdFiles[nestLevel], s);
      if eof(ucsdFiles[nestLevel]) then
         begin
         if listAlerts and (nestLevel>0) then
            writeln('(End Include File ', s, ')');
         nestLevel := nestLevel-1;
         fini := false;
         end
      else if length(s)>0 then
         begin
         if ord(s[1])=charDl then
            begin
            s := copy(s, 2, length(s)-1);
            if not Suffix(s, '.text') then
               s := concat(s, '.text');
            if listAlerts then writeln('(Begin Include File ', s, ')');
            nestLevel := nestLevel+1;
            if nestLevel > nestLimit then
               Mistake('Include files nested too deep');
            ucsdNames[nestLevel] := s;
            reset(ucsdFiles[nestLevel], s);
            errNum := ioResult;
            if errNum>0 then
               IOerror(errNum, concat(' opening include file ', s));
            fini := false;
            end
         else if ord(s[1])=charSe then fini := false;
         end
   until fini;
end;

function BlankLine(VAR s: Str255): boolean;
label 888;
var b: boolean;
    i: integer;
begin
   b := false;
   for i := 1 to length(s) do if ord(s[i])<>charSp then goto 888;
   b := true;
 888:
   BlankLine := b;
end;


procedure Advance;
   begin
   poss := poss + 1;
   if poss>length(source) then this := charCr
   else this := ord(source[poss]);
   end;


procedure StartParse(VAR s: str255);
begin
   source := s;
   poss := 0;
   Advance;
end;


procedure Include;
   begin
   singleChar[1] := chr(this);
   Insert(singleChar, singleWord, length(singleWord)+1);
   Advance;
   end;


function ParseKeyword: TKeyword;
var ans, kwd: TKeyword;
begin
   singleWord := '';
   while this=charSp do Advance;
   if (this=charPl) or (this=charSe) or (this=charEq) then Include
   else
      while ((charLa<=this) and (this<=charLz)) or
            ((charUA<=this) and (this<=charUZ)) do
         begin
         if this<=charUZ then this := this+charLa-charUA;
         Include;
         end;
   if length(singleWord)=0 then
      begin
      if poss <= length(source) then
         Mistake(concat('Extra characters: ',
                        copy(source, poss+1, length(source)-poss)));
      ans := wdCr;
      end
   else
      begin
      if listAlerts then write(singleWord, ' ');
      ans := wdBad;
      for kwd := succ(wdBad) to pred(wdCr) do
         if Keywords[kwd]=singleWord then ans := kwd;
      if ans=wdBad then Mistake(concat('Unknown keyword: ', singleWord));
      end;
   ParseKeyword := ans;
end;


function ParseNumber: integer;
var i: integer;
    d: integer;
begin
   d := 0;
   i := 0;
   while this=charSp do Advance;
   while (this<>charSp) and (this<>charCr) do
      if (char0<=this) and (this<=char9) then
         begin
         i := 10*i + this - char0;
         d := d + 1;
         Advance;
         end
      else Mistake('Nondigit in alert number or version number');
   if d=0 then Mistake('Alert number expected');
   if listAlerts then write(i:1, ' ');
   ParseNumber := i;
end;


procedure ParseHeader(VAR alertHeader: str255;
                      VAR alertInfo:   TAlertInfo);

      procedure Equation;
      label 111;
      var i, k: integer;
         begin
            k := ParseNumber;
            if k<1 then
               Mistake('Can''t equate to 0');
            if k>alertNumber then
               Mistake('Can''t equate to a later alert');
            for i := 1 to index do
               if alerts[i].alertNumber=k then
                  begin
                  k := i;
                  goto 111;
                  end;
            Mistake('Can''t equate to an undefined alert');
           111:
            alertInfo.textLength := -k;
         end;

      procedure ParseQualifier;
      var k: integer;
         begin
            with alertInfo do case ParseKeyword of
               wdStop:
                  alertKind := cautionStopProc;
               wdNote:
                  alertKind := cautionNoteProc;
               wdCancel:
                  alertKind := cautionCancelProc;
               wdOk:
                  alertKind := cautionOKProc;
               wdInsist:
                  alertKind := cautionInsistProc;
               otherwise
                  Mistake('Caution not followed by qualifier');
               end;
         end;

      procedure ParseSeverity;
         begin
            with alertInfo do case ParseKeyword of
               wdStop:
                  alertKind := stopProc;
               wdNote:
                  alertKind := noteProc;
               wdCaution:
                  ParseQualifier;
               wdWait:
                  alertKind := waitProc;
               wdAsk:
                  alertKind := askProc;
               wdDraw:
                  alertKind := drawProc;
               wdCr:
                  alertKind := getProc;
               otherwise
                  Mistake('Alert number not followed by severity');
               end;
         end;

      procedure ParseStages;
      var rpt, sound, sight, more: boolean;
          i, k: integer;
          responses: array [0..3] of
                        record
                           toneVolume: 0..3;
                           fAlertBox: boolean;
                           end;
         begin
            rpt := false;
            for i := 0 to 3 do
               begin
               if rpt then responses[i] := responses[i-1] else
               with responses[i] do
                  begin
                  toneVolume := 0;
                  fAlertBox := false;
                  sound := false;
                  sight := false;
                  more := true;
                  while more do case ParseKeyword of
                     wdSilent:  begin sound := true; toneVolume := 0; end;
                     wdSoft:    begin sound := true; toneVolume := 1; end;
                     wdMedium:  begin sound := true; toneVolume := 2; end;
                     wdLoud:    begin sound := true; toneVolume := 3; end;
                     wdAlert:   begin sight := true; fAlertBox  := true end;
                     wdPlus:    if sound=sight then Mistake('Bad use of +');
                     wdSemi:    if sound or sight then more := false
                                else Mistake('extra ;');
                     wdCr:      begin more := false; rpt := true end;
                     wdEqual:   begin
                                more := false; rpt := true;
                                Equation;
                                end;
                     otherwise
                        Mistake('bad word in stage');
                     end;
                  if rpt and not (sound or sight) then Mistake('missing stage');
                  end;
                  with responses[i] do with alertInfo do case i of
                     0: begin volume0 := toneVolume; fbox0 := fAlertBox; end;
                     1: begin volume1 := toneVolume; fbox1 := fAlertBox; end;
                     2: begin volume2 := toneVolume; fbox2 := fAlertBox; end;
                     3: begin volume3 := toneVolume; fbox3 := fAlertBox; end;
                     end;
               end;
         end;

begin
   StartParse(alertHeader);
   alertNumber := ParseNumber;
   if alertNumber>0 then
      begin
      alertInfo.alertNumber := alertNumber;
      with alertInfo do
         begin
         textLength := 0;
         fBox0 := false;
         fBox1 := false;
         fBox2 := false;
         fBox3 := false;
         end;
      ParseSeverity;
      if not Stageless(alertInfo) then
         begin
         if alertInfo.textLength=0 then {"continue=n" if nonzero}
            ParseStages;
         if ParseKeyword<>wdCr then
            Mistake('too many stages');
         end;
      end;
   if listAlerts then writeln;
end;


function ParseWord(VAR kind: Integer): boolean;
var
  explanation: str255;
  eol: boolean;
  cn, digits: integer;
begin
   singleWord := '';
   if this=charUp then
      begin
      Advance;
      case this of
         charUp: Include;
         charUL, charLl: begin kind := ciL+256; Advance; end;
         charUC, charLc: begin kind := ciC+256; Advance; end;
         charUK, charLk: begin kind := ciK+256; Advance; end;
         char0, char1, char2, char3, char4, char5:
                begin kind := ci0+256-(this-char0); Advance; end;
         charUN, charLn: begin kind := ciN+256; Advance; end;
         charQM, charEM:
            begin
            if this=charQM then kind := ciQM+256 else kind := ciEM+256;
            Advance;
            while (this<>charCr) and (this<>charUp) do Include;
            end;
         char7, char8, char9:
            begin
            cn := this;
            digits := 1;
            Advance;
            while this=cn do
               begin
               if digits < 5 then digits := digits + 1;
               Advance;
               end;
            kind := (ciS1+1-digits-5*(cn-char7))+256;
            end;
         otherwise begin singleWord := '^'; Include; end;
         end
      end
   else
      begin
      kind := kindWord;
      while (this<>charSp) and (this<>charCr) and (this<>charUp) do
          Include;
      while this=charSp do Include;
      if (this=charCr) and (length(singleWord) > 0) then
         Insert(' ', singleWord, length(singleWord)+1);
      end;
   eol := (length(singleWord) = 0) and (kind = kindWord);
   if listAlerts then
      begin
      case kind-256 of
         ciL: explanation:= '<new line>';
         ciN: explanation := '<cite number>';
         ciC: explanation := '<cite command--lower case>';
         ciK: explanation := '<cite command--keep case>';
         ci0: explanation := '<cite param 0>';
         ci1: explanation := '<cite param 1>';
         ci2: explanation := '<cite param 2>';
         ci3: explanation := '<cite param 3>';
         ci4: explanation := '<cite param 4>';
         ci5: explanation := '<cite param 5>';
         ciS1: explanation:= '<1-digit counter#7>';
         ciS2: explanation:= '<2-digit counter#7>';
         ciS3: explanation:= '<3-digit counter#7>';
         ciS4: explanation:= '<4-digit counter#7>';
         ciS5: explanation:= '<5-digit counter#7>';
         ciE1: explanation:= '<1-digit counter#8>';
         ciE2: explanation:= '<2-digit counter#8>';
         ciE3: explanation:= '<3-digit counter#8>';
         ciE4: explanation:= '<4-digit counter#8>';
         ciE5: explanation:= '<5-digit counter#8>';
         ciN1: explanation:= '<1-digit counter#9>';
         ciN2: explanation:= '<2-digit counter#9>';
         ciN3: explanation:= '<3-digit counter#9>';
         ciN4: explanation:= '<4-digit counter#9>';
         ciN5: explanation:= '<5-digit counter#9>';
         ciQM: explanation := '<ask button>';
         ciEM: explanation := '<ask default>';
         otherwise explanation := '';
         end;
      write(explanation);
      write(singleWord);
      if eol then writeln;
      end;
   ParseWord := not eol;
end;


procedure ParseText(VAR textLine:      str255;
                    VAR alertText:     TBytes;
                    VAR chars:         integer);
var str: str255;
    kind: Integer;

      procedure Append(wdLen: integer; s: str255);
      var i: integer;
      begin
         if chars+1+length(s) > textLimit then Mistake('Text too long');
         alertText[chars] := wdLen;
         for i := 1 to length(s) do alertText[chars+i] := ord(s[i]);
         chars := chars + length(s) + 1;
      end;

begin
        {alertText^[0..chars-1] is of the form:
            repeat
                    wordLength: byte
                    word: array [1..wordLength] of byte;
            where each word includes its spaces (if any)
            and where wordLength=256+ciL represents a ^L (forced new line)
                                =256+ciN represents a ^N (cite alert number)
                                =256+ciC represents a ^C (cite last command--change case to lower)
                                =256+ciK represents a ^K (cite last command--keep case)
                                =256+ci0 represents a ^0 (cite parameter 0)
                                         ...
                                =256+ci5 represents a ^5 (cite parameter 5)
                                =256+ciQM represents a ^? (ask button)
                                =256+ciEM represents a ^! (ask default button)
                                =256+ciS1 represents a ^7 (1-digit counter#7)
                                          ...
                                =256+ciS5 represents a ^77777 (5-digit counter#7)
                                =256+ciE1 represents a ^8 (1-digit counter#8)
                                          ...
                                =256+ciE5 represents a ^88888 (5-digit counter#8)
                                =256+ciN1 represents a ^9 (1-digit counter#9)
                                          ...
                                =256+ciN5 represents a ^99999 (5-digit counter#9)
                                }
   StartParse(textLine);
   while ParseWord(kind) do
      begin
      if kind <> kindWord then Append(kind, '');
      if (kind=kindWord) or (kind=(ciQM+256)) or (kind=(ciEM+256)) then
         Append(length(singleWord), singleWord);
      end;
end;


procedure RdAlerts;
var
   p:           TAlertProc;
   d:           TButn;
   moreAlerts:  boolean;
   alertHeader: str255;
   alertInfo:   TAlertInfo;
   moreText:    boolean;
   textLine:    str255;
   alertText:   TBytes;
   hAlertText:  HBytes;
   numBytes:    integer;
   i:           integer;
   equated:     boolean;
   needsText:   boolean;
   textProvided, eqIndex: integer;
begin
   ReadNext(textLine);
   StartParse(textLine);
   itsVersion := ParseNumber;
   if listAlerts then writeln('Version number = ', itsVersion:1);

   for p := askProc to cautionProc do
       begin
       ReadNext(textLine);
       if listAlerts then writeln(signName[p], ' = ', textLine);
       if length(textLine) > signStrLength then
          Mistake('Sign name too long');
       for i := length(textLine)+1 to signStrLength do
          textLine[i] := ' ';
       signString[p] := textLine;
       end;

   d := cancelButn;
   repeat
       ReadNext(textLine);
       if not BlankLine(textLine) then
          begin
          if d>maxButn then
             Mistake('Too many Butns defined');
          if listAlerts then
             if d<=okButn then
                writeln(buttName[d], ' = ', textLine)
             else writeln('   ',  textLine);
          if length(textLine) > signStrLength then
             Mistake('Butn name too long');
          for i := length(textLine)+1 to signStrLength do
             textLine[i] := ' ';
          buttString[d] := textLine;
          d := d+1;
          end
   until BlankLine(textLine);
   lastButn := d-1;

   errNum := ioresult;
   if errNum>0 then
        IOerror(errNum, ' reading the input file!');

   if lastButn<okButn then
      Mistake('Require nonblank text for cancel and ok');

   moreAlerts := true;
   while moreAlerts do
      begin
      repeat
         ReadNext(alertHeader);
         errNum := ioresult;
         if errNum>0 then
           IOerror(errNum, ' reading the input file!');
      until not BlankLine(alertHeader);
      ParseHeader(alertHeader, alertInfo); {alertNumber set as side effect}
      if alertNumber=0 then moreAlerts := false
      else
         begin
         if index>0 then
            if alertNumber<=alerts[index].alertNumber then
               Mistake('Alert numbers must appear in ascending order');
         index := index + 1;
         if index>alertLimit then Mistake('More than 2000 alerts!');
         alerts[index] := alertInfo;
         equated := alertInfo.textLength<0;
         numAlerts := index;
         numBytes := 0;
         moreText := true;
         while moreText do
            begin
            ReadNext(textLine);
            errNum := ioResult;
            if errNum>0 then
               IOerror(errNum, ' reading the input file!');
            if BlankLine(textLine) then
               moreText := false
            else if Stageless(alertInfo) then
               begin
               if listAlerts then writeln(textLine);
               if numBytes>0 then
                  Mistake('Only one line of text allowed when no severity');
               numBytes := length(textLine)+1;
               for i := 0 to length(textLine) do
                  alertText[i] := ord(textLine[i]);
               end
            else
               ParseText(textLine, alertText, numBytes);
            end;
         if listAlerts then writeln;
         with alertInfo do
            needsText := fBox0 or fBox1 or fBox2 or fBox3 or
                                        Stageless(alertInfo);
         if equated then
            begin
            if numBytes>0 then
               Mistake('there should not be text after an equated alert');
            textProvided := -index;
            repeat
               eqIndex := -textProvided;
               textProvided := alerts[eqIndex].textLength
            until textProvided>=0;
            if (textProvided=0) and needsText then
               Mistake('the equated alert doesn''t have any text');
            end
         else
           begin
           if (numBytes=0) and needsText then
               Mistake('no text for alert');
           alerts[index].textLength := numBytes;
           end;
         hAlertText := pointer(ord(HAllocate(hz, numBytes)));
         for i := 0 to numBytes-1 do hAlertText^^[i] := alertText[i];
         texts[index] := hAlertText;
         end;
      end;
   writeln;
   writeln('All ', numAlerts:1, ' alerts read.');
end;


procedure WrAlerts;
var
  p:        TAlertProc;
  d:        TButn;
  i:        integer;
  checksum: -128..127;
  block:    array [0..511] of -128..127;
  actual:   longint;
begin
   Make_File(errNum, outputName, 0);
   Open(errNum, outputName, phraseFile, [DRead, DWrite]);
   if errNum>0 then
      IOerror(errNum, ' opening the output file!');

   WriteNext(@itsVersion, 2);

   for p := askProc to cautionProc do
      begin
      WriteNext(@signString[p], 1+signStrLength);
      WriteNext(@signPoints[p], sizeof(signPoints[p]));
      WriteNext(@signPt[p,0], (signPoints[p]+1)*sizeof(signPt[p,0]));
      end;

   i := lastButn;
   WriteNext(@i, 2); {can't WriteNext lastButn directly; it's a byte not a word}
   for d := cancelButn to lastButn do
      WriteNext(@buttString[d], 1+signStrLength);

   WriteNext(@numAlerts, 2);
   WriteNext(@alerts[1], numAlerts*sizeof(TAlertInfo));
   for i := 1 to numAlerts do
      WriteNext(texts[i]^, alerts[i].textLength);

   WriteNext(@copyright, length(copyright)+1);

   Truncate(errNum, phraseFile);
   if errNum>0 then
      IOerror(errNum, ' truncating the output file!');

   checksum := 0;
   Read_Data(errNum, phraseFile, ord(@junk), 0, junk, absolute, 0);
   if errNum>0 then
      IOerror(errNum, ' preparing to checksum the output file!');
   repeat
      Read_Data(errNum, phraseFile, ord(@block[0]), 512, actual, sequential, 0);
      for i := 0 to actual-1 do checksum := checksum + block[i];
   until (actual < 512) or (errNum <> 0);
   if (errNum <> 848) and (errNum <> 956) then
      IOerror(errNum, ' checksumming the output file!');
   checksum := 50-checksum;
   writeln;
   writeln('Checksum = ', checksum:1);
   WriteNext(@checksum, 1);

   Compact(errNum, phraseFile);
   if errNum>0 then
      IOerror(errNum, ' compacting the output file!');

   Close_Object(errNum, phraseFile);
   if errNum>0 then
      IOerror(errNum, ' closing the output file!');
end;


procedure WrMeasure;
const sizeofTAlertRec = 10;
      hzBlkOvhd = 20; {4 byte blk ovhd, 4 byte master ptr, 12 byte minFree}
      sizeofTCachedAlert = 14;
var tot: longint;
    i, len, big, ovhd, insz, avga, lrga, sugg: integer;
begin
      writeln;
      writeln('heap required = overhead + ',
              'cacheFactor*cacheSize + indexSize + largestAlert');
      writeln;
      tot := 0;
      big := 0;
      for i := 1 to numAlerts do if i<>2 then
         begin
         len := alerts[i].textLength;
         tot := tot + len;
         big := cmax(big, len);
         end;
      avga := (tot div numAlerts) + hzBlkOvhd + 1;
      lrga := big + hzBlkOvhd + 1;
      ovhd := sizeofTAlertRec+sizeofTCachedAlert+alerts[2].textLength+3*hzBlkOvhd;
      insz := (1+numAlerts)*sizeof(TAlertInfo)+hzBlkOvhd;
      writeln('overhead = ', ovhd:1);
      writeln('cacheFactor = ', sizeofTCachedAlert:1);
      writeln('indexSize = ', insz:1);
      writeln('Average alert = ', avga:1);
      writeln('Largest alert = ', lrga:1);
      writeln;

      writeln('For example, if you are using the A3 Print Manager, and if you never pass');
      writeln('more than 3 arguments of 80 characters or less to any alert, then I suggest:');
      writeln;
      sugg := ovhd + sizeofTCachedAlert*3 + (insz+120) + CMax(lrga, 500) + avga*3 + 300;
      writeln('InitAlerts(3, ', (sugg - (sugg mod 100))+100:1, ', theHeap, @myIdleProc, @myErrProc);');
end;


procedure Main;
begin
   RdAlerts;
   alertNumber := -1;
   if numAlerts>0 then
      begin
      alertNumber := alerts[numAlerts].alertNumber;
      if (alerts[1].alertNumber<>1) or (alerts[1].alertKind=getProc) then
         Mistake('You forgot to define alert #1 as the default non-GetAlert.');
      if (numAlerts < 2) or (alerts[2].alertNumber <> 2) then
         Mistake('You forgot to define alert #2 as the Swan Song alert.')
      else if alerts[2].textLength < 1 then
         Mistake('Alert #2 must contain text.');
      WrAlerts;
      WrMeasure;
      end
   else
      Mistake('There are no alerts in the file.');
end;


begin

copyright := 'Copyright 1983, Apple Computer Inc.';

alertNumber := -1;

index := 0;

numAlerts := 0;

singleChar := 'X';

buttName[cancelButn] := 'cancel';
buttName[okButn] := 'ok';

signName[askProc] := '?';
signName[waitProc] := 'wait';
signName[stopProc] := 'stop';
signName[noteProc] := 'note';
signName[cautionProc] := 'caution';

Keywords[wdStop]     := 'stop';
Keywords[wdCaution]  := 'caution';
Keywords[wdNote]     := 'note';
Keywords[wdWait]     := 'wait';
Keywords[wdAsk]      := 'ask';
Keywords[wdDraw]     := 'draw';
Keywords[wdOk]       := 'ok';
Keywords[wdCancel]   := 'cancel';
Keywords[wdInsist]   := 'insist';
Keywords[wdEqual]    := '=';
Keywords[wdSilent]   := 'silent';
Keywords[wdSoft]     := 'soft';
Keywords[wdMedium]   := 'medium';
Keywords[wdLoud]     := 'loud';
Keywords[wdAlert]    := 'alert';
Keywords[wdPlus]     := '+';
Keywords[wdSemi]     := ';';

SignPoints[askProc] := 4; {diamond}
with SignPt[askProc, 0] do begin h:= 66; v:= 44; end; {text center}

with SignPt[askProc, 1] do begin h:= 66; v:= 10; end;
with SignPt[askProc, 2] do begin h:= 117; v:= 44; end;
with SignPt[askProc, 3] do begin h:= 66; v:= 78; end;
with SignPt[askProc, 4] do begin h:= 15; v:= 44; end;

SignPoints[waitProc] := 8; {bottom-vertex triangle}
with SignPt[waitProc, 0] do begin h:= 66; v:= 25; end; {text center}

with SignPt[waitProc, 1] do begin h:= 65; v:= 78; end;
with SignPt[waitProc, 2] do begin h:= 67; v:= 78; end;
with SignPt[waitProc, 3] do begin h:= 116; v:= 12; end;
with SignPt[waitProc, 4] do begin h:= 116; v:= 11; end;
with SignPt[waitProc, 5] do begin h:= 115; v:= 10; end;
with SignPt[waitProc, 6] do begin h:= 17; v:= 10; end;
with SignPt[waitProc, 7] do begin h:= 16; v:= 11; end;
with SignPt[waitProc, 8] do begin h:= 16; v:= 12; end;

SignPoints[stopProc] := 8; {octagon}
with SignPt[stopProc, 0] do begin h:= 66; v:= 44; end; {text center}

with SignPt[stopProc, 1] do begin h:= 87; v:= 10; end;
with SignPt[stopProc, 2] do begin h:= 117; v:= 30; end;
with SignPt[stopProc, 3] do begin h:= 117; v:= 58; end;
with SignPt[stopProc, 4] do begin h:= 87; v:= 78; end;
with SignPt[stopProc, 5] do begin h:= 45; v:= 78; end;
with SignPt[stopProc, 6] do begin h:= 15; v:= 58; end;
with SignPt[stopProc, 7] do begin h:= 15; v:= 30; end;
with SignPt[stopProc, 8] do begin h:= 45; v:= 10; end;

SignPoints[noteProc] := 4; {square}
with SignPt[noteProc, 0] do begin h:= 66; v:= 44; end; {text center}

with SignPt[noteProc, 1] do begin h:= 30; v:= 20; end;
with SignPt[noteProc, 2] do begin h:= 102; v:= 20; end;
with SignPt[noteProc, 3] do begin h:= 102; v:= 68; end;
with SignPt[noteProc, 4] do begin h:= 30; v:= 68; end;

SignPoints[cautionProc] := 8; {top-vertex triangle}
with SignPt[cautionProc, 0] do begin h:= 66; v:= 68; end; {text center}

with SignPt[cautionProc, 1] do begin h:= 65; v:= 7; end;
with SignPt[cautionProc, 2] do begin h:= 67; v:= 7; end;
with SignPt[cautionProc, 3] do begin h:= 121; v:= 79; end;
with SignPt[cautionProc, 4] do begin h:= 121; v:= 80; end;
with SignPt[cautionProc, 5] do begin h:= 120; v:= 81; end;
with SignPt[cautionProc, 6] do begin h:= 12; v:= 81; end;
with SignPt[cautionProc, 7] do begin h:= 11; v:= 80; end;
with SignPt[cautionProc, 8] do begin h:= 11; v:= 79; end;


rootName := '';
inputName := 'UNKNOWN';
outputName := 'UNKNOWN';
explained := false;
listAlerts := false;

repeat
   if not explained then
      begin
      writeln('/L lists tokenized input to console');
      explained := true;
      end;
   writeln;
   write('Input File Name [.text]? ');
   readln(rootName);
   if length(rootName)=0 then
      goto 999
   else if rootName[1]='/' then
      begin
      if (rootName[2]='L') or (rootname[2]='l') then
         listAlerts := true
      else writeln('Undefined switch');
      rootName := '';
      end
   else if rootName[1]='?' then
      begin
      explained := false;
      rootName := '';
      end
 until length(rootName) > 0;

if not Suffix(rootName, '.text') then
   inputName := concat(rootName, '.text')
else
   begin
   inputName := rootName;
   rootName := copy(rootName, 1, length(rootName)-5);
   end;

if length(rootName)=0 then goto 999;

volLength := pos(':', rootName);
rootName := copy(rootName, volLength+1, length(rootName)-volLength);
if length(rootName)=0 then goto 999;

nestLevel := 0;
ucsdNames[nestLevel] := inputName;
reset(ucsdFiles[nestLevel], inputName);
errNum := ioResult;
if errNum>0 then
   IOerror(errNum, ' opening the input file!');

write('Output File Name [', rootName, '] [PHRASE]? ');
readln(outputName);
if length(outputName)=0 then
   outputName := concat(rootName, 'PHRASE')
else if not Suffix(outputName, 'phrase') then
   outputName := concat(outputName, 'PHRASE');

{$IFC FDbgOK}
fTstHz := false;
{$ENDC}

dspathname := 'AlertGenDS';
heapSize := 65000;
ldsn := 4;
errnum := 1;
while errnum>0 do
   begin
   Make_Dataseg(errnum, dspathname, heapSize, heapSize,
                dsrefnum, heapStart, ldsn, ds_private);
   if errnum>0 then
      begin
      writeln('Make_Dataseg error #', errnum:1,
              ' path name = ', dspathname,
              ' heap size = ', heapSize:1,
              ' ldsn = ', ldsn:1);
      write('type SPACE to exit'); readln;
      goto 777;
      end;
   end;
hz :=  HzInit(pointer(heapStart), pointer(heapStart+heapSize), nil,
              alertLimit, 0, @heapError,
              POINTER(procNil), POINTER(procNil), POINTER(procNil));

Main;

writeln;
writeln('File ', outputName, ' generated successfully');

999:

Close_Dataseg(errNum, dsrefnum);
if length(dspathname) > 0 then Kill_Dataseg(errnum, dspathname);

777:

end.




ÿ