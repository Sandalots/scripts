{$S FontMgr}   {Copyright 1983, Apple Computer Inc.}
UNIT FontMgr; { December 1983 }
INTRINSIC SHARED;

{*******************************************************************************}
                                    INTERFACE
{*******************************************************************************}

USES
   {$U libqd/QuickDraw}    QuickDraw,
   {$U libsm/UnitStd}      UnitStd,
   {$U libsm/UnitHz }      UnitHz,
   {$U libos/SysCall}      SysCall,
   {$U libos/PSysCall}     PSysCall;

{$SETC fmdebug := FALSE}
{$SETC fmSymbols := fsymok}
{$setC fTraceFM := fTrace}

CONST
   ccMax = 255;

   {Non-printing ASCII}
   ccBS = 8;
   ccHT = 9;
   ccLF = 10;
   ccVT = 11;
   ccFF = 12;
   ccCR = 13;
   ccESC = 27;

   {Current standard character codes > ASCII}
   ccPara      = 166;  {paragraph symbol}
   ccSec       = 164;  {section symbol}
   ccCopy      = 169;  {copyright}
   ccReg       = 168;  {registrata}
   ccTM        = 170;  {trademark}
   ccDeg       = 161;  {degree e.g. Celsius}
   ccDag       = 160;  {dagger}
   ccBul       = 165;  {bullet}
   ccPound     = 163;  {pound (currency)}
   ccElip      = 201;  {ellipsis}
   ccSysApple  = 202;  {apple for Logo}
   ccLisaLogo  = 0;    {apple Logo}

   {Current standard Icons in wmfont}
   ccCheck      = 142;
   ccApple      = 143;

   {Current standared Patterns in sysPat}
   ccLreg       = 0;
   ccLalt       = 1;
   ccLdash      = 2;
   ccRreg       = 3;
   ccRalt       = 4;
   ccRdash      = 5;
   ccHreg       = 6;
   ccHalt       = 7;
   ccHdash      = 8;
   ccVreg       = 9;
   ccValt       = 10;
   ccVdash      = 11;
   ccG90f       = 12;
   ccG90c       = 13;
   ccG45f       = 14;
   ccG45c       = 15;
   ccWhite      = 16;
   ccXLtGray    = 17;
   ccLtGray     = 18;
   ccMedGray    = 19;
   ccGray       = 20;
   ccDkGray     = 21;
   ccBlack      = 22;
   ccNil = 255; {A non-existant pattern -> generates the missing char pattern}

   ccWhiteMask = 255; {Special code for the white mask of a cursor}

   {System text families}
   sysText     = 0;     {System text font - TEXT ONLY!}
   wmfont      = 1;     {System icon font -- primarily WM}
   sysPat      = 2;     {system pattern font}
   sysCursor   = 3;     {System cursor font - not character compatible}
   tile12      = 4;     {proportional}
   tile18      = 5;     {proportional}
   tile24      = 6;     {proportional}
   p15Tile     = 7;     {monospaced - 8 lines/inch & 15 characters/inch}
   p12Tile     = 8;     {monospaced - 6 lines/inch & 12 characters/inch}
   p10Tile     = 9;     {monospaced - 6 lines/inch & 10 characters/inch}
   cent12      = 10;    {proportional}
   cent18      = 11;    {proportional}
   cent24      = 12;    {proportional}
   p12cent     = 13;    {monospaced - 6 lines/inch & 12 characters/inch}
   p10cent     = 14;    {monospaced - 6 lines/inch & 10 characters/inch}
   elite       = 15;    {monospaced - 6 lines/inch & 12 characters/inch}
   courier     = 16;    {monospaced - 6 lines/inch & 10 characters/inch}
   boldface    = 17;    {proportional}
   calcFont    = 18;    {calculator font}
   p20Tile     = 19;    {monospaced}
   marker      = 20;    {BG icon font -- for scatter plots}
   tile7       = 21;    {Filer proportional font}
   fIconFont   = 22;    {Filer icon font}
   sysLogo     = 23;    {system logo font}

   devScreen    = 0;
   famLst       = 23;
   substitution = -3024; {Font Manager warning that a substitution has occurred}

   BigCache   = 98000;   { Cache size for 1 meg machine }
   HighCache  = 45000;   { A Guess at the maximum size cache when printing }
   LowCache   = 30000;   { Resets to this after printing in 512K machine }

{$IFC NOT fmdebug}
   fdebug   = FALSE;
   fdebug1  = FALSE;
   fdebug2  = FALSE;
   fdebug3  = FALSE;
   fdebug4  = FALSE;
   fdebug5  = FALSE;
   fdebug6  = FALSE;
   fdebug7  = FALSE;
   fdebug8  = FALSE;
   fdebug9  = FALSE;
   fdebug10 = FALSE;
   fdebug11 = FALSE;
   fdebug12 = FALSE;
   fdebug13 = FALSE;
   fdebug14 = FALSE;
   fdebug15 = FALSE;
   fdebug16 = FALSE;
   fdebug17 = FALSE;
   fdebug18 = FALSE;
   fdebug19 = FALSE;
   fdebug20 = FALSE;
   fdebug21 = FALSE;
   fdebug22 = FALSE;
   fdebug23 = FALSE;
   fdebug24 = FALSE;
   fdebug25 = FALSE;
   fdebug26 = FALSE;
   fdebug27 = FALSE;
   fdebug28 = FALSE;
   fdebug29 = FALSE;
   fdebug30 = FALSE;
   fdebug31 = FALSE;
   fdebug32 = FALSE;
   fdebug33 = FALSE;
   fdebug34 = FALSE;
   fdebug35 = FALSE;
   fdebug36 = FALSE;
   fdebug37 = FALSE;
   fdebug38 = FALSE;
   fdebug39 = FALSE;
   fdebug40 = FALSE;
{$ENDC}

TYPE
   TCc = 0..255;

   TStr30 = STRING [30];

   TFam = TC;


      (***Removed the following on 10/13/83 to support new QuickDraw from Mac(spr):
         TEface =    (efaceBold,
                     efaceItalic,
                     efaceUnderLined,
                     efaceOutlined,
                     efaceShadow);

         TSeteface = SET OF TEface;
          TFinfo = RECORD
                     ascent,         {Distance from baseline to top of font bounding box}
                     descent,        {Distance from baseline to bottom of font bounding box}
                     widMax,         {Width of widest character in font}
                     leading: TC;    {White space between two adjacent lines of text}
                   END;
       ***)


   TDev = -128..127;

   TEdev = (edevScreen,
            edevDotMx,
            edevHDotMx,
            edevTyper,
            edevLaser,
            edev1,
            edev2);

   TEwhcl = (ewhcl20,
             ewhcl15,
             ewhcl12,
             ewhcl10,
             ewhclPS,
             ewhclMF,
             ewhclMP,
             ewhclLCS);

   TEskcl = (eskclMPPS,
             eskclMPFP,
             eskclMFR,
             eskclMFI,
             eskclApple,
{jwp 3/16/83}eskclFQume,
{jwp 3/16/83}eskclPQume);

   TAdev = PACKED RECORD  {Type declaration for "Print Style"}
      CASE BOOLEAN OF
         TRUE: (dev: TDev);

         FALSE: (fOffline: TF;

                 CASE edev: TEdev OF
                    edevScreen,
                    edevLaser: ();
                    edevDotMx,
                    edevHDotMx: (fHiRes: TF;
                                fPortrait: TF);
                    edevTyper: (fSpoke: TF;
                                ewhcl: TEwhcl);
                    edev1,{Added 2 general devices for additional printers }
                    edev2:  ()

                );
   END; {TAdev}

   TFntid = PACKED RECORD
      fam: TFam;
      seteface: Style;
   END;

   TLfntid = PACKED RECORD
      fam: TFam;
      seteface: Style;
      CASE BOOLEAN OF
         TRUE: (dev: TDev);

         FALSE: (fOffline: TF;

                 CASE edev: TEdev OF
                    edevScreen,
                    edevLaser: ();
                    edevDotMx,
                    edevHDotMx: (fHiRes: TF;
                                fPortrait: TF);
                    edevTyper: (fSpoke: TF;
                                ewhcl: TEwhcl);
                    edev1,      {Added 2 general devices for additional printers }
                    edev2:  ()
                );
   END; {TLfntid}



   TWid = 0..255;
   TMpccwid = PACKED ARRAY [TCc] OF TWid;
   TPmpccwid = ^TMpccwid;
   THmpccwid = ^TPmpccwid;

   TPcharStyle = ^TCharStyle;
   TCharstyle = PACKED RECORD
      hks: TH;
      hmpccwid: THmpccwid;
      bBold: TB;
      bItalic: TB;
      bUnderline: TB;
      bShadow: TB;
      cExtra: TC;
   END;

   TMpefaceb = ARRAY [StyleItem] OF TB;

   TModifier = RECORD
      seteface: Style;
      mpefaceb: TMpefaceb;
    END;

VAR
{$IFC fmdebug}
   fdebug:   TF;
   fdebug1:  TF;
   fdebug2:  TF;
   fdebug3:  TF;
   fdebug4:  TF;
   fdebug5:  TF;
   fdebug6:  TF;
   fdebug7:  TF;
   fdebug8:  TF;
   fdebug9:  TF;
   fdebug10: TF;
   fdebug11: TF;
   fdebug12: TF;
   fdebug13: TF;
   fdebug14: TF;
   fdebug15: TF;
   fdebug16: TF;
   fdebug17: TF;
   fdebug18: TF;
   fdebug19: TF;
   fdebug20: TF;
   fdebug21: TF;
   fdebug22: TF;
   fdebug23: TF;
   fdebug24: TF;
   fdebug25: TF;
   fdebug26: TF;
   fdebug27: TF;
   fdebug28: TF;
   fdebug29: TF;
   fdebug30: TF;
   fdebug31: TF;
   fdebug32: TF;
   fdebug33: TF;
   fdebug34: TF;
   fdebug35: TF;
   fdebug36: TF;
   fdebug37: TF;
   fdebug38: TF;
   fdebug39: TF;
   fdebug40: TF;
{$ENDC}
   InitialCacheSize: TL;         {(Initial) Size of the cache}
   MinCache: TL;                 {Low Cache Size when not printing}
   cRefnumLib: TC;               {refnum for system font library}

{*******************************************************************************}

{Procedures inside Segment "FMInit"}
PROCEDURE FMinit
   (VAR cError: TC);


PROCEDURE FMOpen
   (VAR cError: TC);


PROCEDURE FMCloseLib
   (VAR cError: TC);


PROCEDURE FMCacheSize
   (    lCacheSize: TL;
    VAR cError: TC);


FUNCTION FMAddFont
   (    str30: TStr30;
        modifier: TModifier;
        dev: TDev;
     VAR cError: TC)
   : TFam;


PROCEDURE FMDelfont
   (    lfntid: TLfntid);


{Procedures inside Segment "FontMgr"}
FUNCTION FMSwapFont
   (VAR lfntid: TLfntid;
    VAR cError: TC)
   : TPcharstyle;


PROCEDURE FMLockFont
   (VAR lfntid: TLfntid;
        flock: TF;
    VAR cError: TC);


FUNCTION FMFontMetrics
   (VAR lfntid: TLfntid;
    VAR finfo: FontInfo;
    VAR cError: TC)
   : TF;


FUNCTION FMFontWidths
   (VAR lfntid: TLfntid;
    VAR hmpccwid: THmpccwid;
    VAR dExtra: TB;
    VAR cError: TC)
   : TF;


PROCEDURE FMMapFont
   (VAR lfntid: TLfntid;
    VAR cError: TC);


{$IFC fmdebug}
PROCEDURE FMDebug
   (    fdbg: TF);


PROCEDURE FMDumpHeurTable;
{$ENDC}

{*******************************************************************************}
                              IMPLEMENTATION
{*******************************************************************************}

{$IFC fmSymbols}
   {$D+}
{$ELSEC}
   {$D-}
{$ENDC}
{$IFC fmDebug}
   {$R+}
{$ELSEC}
   {$R-}
{$ENDC}


CONST
   pPoolSize = 170;     {number of Handles to allocate for the heapzone}
   hashSize = 6;        {Log (number of hash enteries to allocate for hz)}
   heurTableSize = 50;  {Number of family entries in the heuristic table}
   fmErrorBase = 3000;  {Base error number for font manager error codes}
   tableSize = 128;     {size of the library hash table}
   AlreadyExists = 308; {Data segment already exists error number}

   oldKS          = 0;  {Special font format identifiers}
   newKS          = 1;
   cursorFont     = 2;
   iconFont       = 3;
   patternFont    = 4;
   spokeFont      = 5;
   typerFont      = 6;

TYPE
   THistory = 0..255;
   TVariety = 0..127;

   TFormat = PACKED RECORD
      CASE BOOLEAN OF
         TRUE: (c: INTEGER);
         FALSE: (history: THistory;
                 fCompressed: BOOLEAN;
                 variety: TVariety);
   END;

   TKshdr = RECORD
      format: TFormat; {format of KS font i.e. fixed, variable, or special     }
      chFst: TC;       {char code of first char in KS font                     }
      chLst: TC;       {char code of last char in KS font                      }
      widMax: TC;      {maximum width (dist.) between origins of adjacent char }
      fBBox: TC;       {negative offset from font bounding box in x direc.     }
      fBBoy: TC;       {negative offsets from font bounding box in y direc.    }
      fBBdx: TC;       {extent of the font bounding box in the x direc.        }
      fBBdy: TC;       {extent of the font bounding box in the y direc.        }
      length: TC;      {number of integer words in the strike body             }
      ascent: TC;      {acent of char's in font                                }
      descent: TC;     {descent of char's in font                              }
      leading: TC;     {the amount of white space between lines of text.       }
      raster: TC;      {number of integer words / scanline in the ks bitmap    }
   END; {record TKshdr}
   TPkshdr = ^TKshdr;
   THkshdr = ^TPKshdr;

   TPSRec = ^TSRec;
   TSRec = RECORD
      hks: TH;              { Handle to font bit map }
      hmpccwid: THmpccwid;  { Handle to width table }
   END;

   TSetedev = SET OF TEdev;

   TPfaceRec = ^TFaceRec;
   THfaceRec = ^TPfaceRec;
   TFaceRec = RECORD
      seteface: Style;
      mpefaceb: TMpefaceb;
      cxtra: TC;
      setedev: TSetedev;
      str30Root: TStr30;
      hfcRecNxt: THfaceRec;
   END;

   TMpewhclfam = ARRAY [TEwhcl] OF TFam;
   TMpeskclstr30 = ARRAY [TEskcl] OF TStr30;
   TPmpeskclstr30 = ^TMpeskclstr30;
   THmpeskclstr30 = ^TPmpeskclstr30;

   THeurRec = RECORD
      mpewhclfam: TMpewhclfam;
      hfaceRec: THfaceRec;
      fuser: TF;
   END;
   TRgheurRec = ARRAY [0..heurTableSize] OF THeurRec;
   TPrgheurrec = ^TRgheurrec;
   THrgheurrec = ^TPrgheurrec;

   TTable = ARRAY [1..tableSize] OF
      Record
         key: TC;
         lFst,
         lLim,
         MetWid_Fst,
         MetWid_Lim: TL;
   END;
   TPtable = ^TTable;
   THtable = ^TPtable;

   TLfCheat = RECORD
      CASE BOOLEAN OF
         TRUE: (n: TN);
         FALSE: (lfntid: TLfntid);
   END; {TLfCheat}

   TSetCheat = RECORD
      CASE BOOLEAN OF
         TRUE: (seteface: Style);
         FALSE: (bex: TB);
   END; {TSetCheat}


VAR
   {the following are "read/write" global variables}
   nMap: TN;                     {"Name" of NOB - result of NToName}
   nPrv: TN;                     {Optimization for last font request}
   chsPrv: TCharstyle;           {Optimization for last font request}
   cErrorG: TC;                  {Global Error reporting parameter}
   NeedTheBits: Boolean;         {Flag(hack!) to indicate font bit map is needed}
   ChangeInterval,               {# FMFontMetrics calls between cache size changes}
   SwapINCount,                  {Count of calls to FMSwapNIn}
   SwapOutCount,                 {Count of calls to FMSwapOutN}
   SwapFontCount,                {Count of calls to FMSwapFont}
   MetricsCount: LongInt;        {Count of calls to FMFontMetrics}

   {the following are "read only" global variables -- set once at init time.}
   sysLfntid: TLfntid;           {lfntid associated with systext}
   hrgheurrec: THrgheurRec;      {Table of heuristics indexed by font family}
   hmpeskclstr30: THmpeskclstr30;{Table of spoke table names by spoke class}
   htable: THtable;              {hash table for library entries}
   hzFM: THz;                    {Handle to the FM's heap zone}
   lmemSize: TL;                 {Size of current heap}
   cRefnumHeap: TC;              {refnum for font manager heap data segment}
   odirec: TC;                   {offset to start of first font in library}


PROCEDURE GetWidths
   (    hks: TH;
        hmpccwid: THmpccwid);
EXTERNAL;

PROCEDURE UnCompress
   (    cbMax,
        cbCur: TL;
        pData: TP);
EXTERNAL;

PROCEDURE UnVXORFont
   (    pFont: TP);
EXTERNAL;

FUNCTION HashOfId
   (    id: TC;
        htable: THtable;
    VAR firstIndex: TC)
: INTEGER;
EXTERNAL;

FUNCTION FMROR
   (    w: TW)
: INTEGER;
EXTERNAL;

FUNCTION IpnMapN
   (    hz: THz;
        n: TN)
:TC;
EXTERNAL;


{$S FMlwwrk}
{$IFC fmdebug}

{===============================================================================

#######> FMDebug

        COMMENT:

===============================================================================}

PROCEDURE FMDebug
   {    fdbg: TF};

BEGIN {FMDebug}
{$IFC fTraceFM} LogCall; {$ENDC}
   fdebug   := TRUE;    {Beats me what it is for}
   fdebug1  := TRUE;    {Debug flag for Want to change first cache size}
   fdebug2  := TRUE;    {Debug flag for module change cache size dynamically}
   fdebug3  := TRUE;    {Debug flag for module FMLockFont}
   fdebug4  := TRUE;    {Debug flag for module FMCbOfN}
   fdebug5  := TRUE;    {Debug flag for test driver for FMSwapFont}
   fdebug6  := TRUE;    {Debug flag for module FMSwapNIn}
   fdebug7  := TRUE;    {Debug flag for module AssignDevice}
   fdebug8  := TRUE;    {Debug flag for module SpokeName}
   fdebug9  := TRUE;    {Debug flag for module NToFileName}
   fdebug10 := TRUE;    {Debug flag for module ReadFont}
   fdebug11 := TRUE;    {Debug flag for changing to High Res}
   fdebug12 := TRUE;    {Debug flag for module LocateFont}
   fdebug13 := TRUE;    {Debug flag for module ZZOpenfont}
   fdebug14 := TRUE;    {Debug flag for module ReadMetricsWidths}
   fdebug15 := TRUE;    {Debug flag for module FMSwapOutN}
   fdebug16 := TRUE;    {Debug flag for module FMMapFont}
   fdebug17 := TRUE;    {Debug flag for module FMSwapFont}
   fdebug18 := TRUE;    {Debug flag for module NToName}
   fdebug19 := TRUE;    {Debug flag for module EvalEntry}
   fdebug20 := TRUE;    {Debug flag for module CheckChs}
   fdebug21 := TRUE;    {Debug flag for module EvalSpoke}
   fdebug22 := TRUE;    {Debug flag for module LastDitchOk}
   fdebug23 := TRUE;    {Debug flag for module FMFontMetrics}
   fdebug24 := TRUE;    {Debug flag for module FMFontWidths}
   fdebug25 := TRUE;    {Debug flag for module FMCacheSize}
   fdebug26 := TRUE;    {Debug flag for module FMAddFont}
   fdebug27 := TRUE;    {Debug flag for module FMDelFont}
   fdebug28 := TRUE;    {Debug flag for module FMCloseFont}
   fdebug29 := TRUE;    {Debug flag for module FMOpen}
   fdebug30 := TRUE;    {Debug flag for module FMInit}
   fdebug31 := TRUE;    {Debug flag for changing to typer font}
   fdebug32 := TRUE;    {Debug flag for module HashEntry}
   fdebug33 := TRUE;    {Debug flag for module OpenLib}
   fdebug34 := TRUE;    {Debug flag for dump heuristics table}
   fdebug35 := TRUE;    {Debug flag for module FillLibTable}
   fdebug36 := TRUE;    {Debug flag for module ReadHeuristics}
   fdebug37 := TRUE;    {Debug flag for module GetFile}
   fdebug38 := TRUE;    {Debug flag for hash table in module FillLibTable}
   fdebug39 := TRUE;    {Debug flag for table in module ReadHeuristics}
   fdebug40 := TRUE;    {Debug flag for error situations}
END; {FMDebug}


{===============================================================================

#######> FMDumpHeurTable

        COMMENT: To print out the contents of the heuristic table that was read
                 into memory by ReadHeuristics.

===============================================================================}

PROCEDURE FMDumpHeurTable;
VAR
   ihrrecT: TC;
   hfcRecT: THfaceRec;
   ewhcl: TEwhcl;
   eskcl: TEskcl;
   cError: TC;

BEGIN {FMDumpHeurTable}
{$IFC fTraceFM} LogCall; {$ENDC}
   FOR ihrrecT := 0 TO heurTableSize DO BEGIN
      WITH hrgheurrec^^ [ihrrecT] DO BEGIN
         IF hfacerec <> NIL THEN BEGIN
            WRITELN;
            WRITELN ('<<<<<<<<<<<<<<<< Heuristic Record >>>>>>>>>>>>>>>');
            WRITELN ('fam: ', ihrrecT:1);
            FOR ewhcl := ewhcl20 TO ewhclLCS DO BEGIN
               WRITE (mpewhclfam [ewhcl]:1, ' | ');
            END; {for}
            WRITELN;
            WRITELN ('fuser: ', fuser);
            hfcRecT := hfaceRec;
            WHILE hfcRecT <> NIL DO BEGIN
               WRITELN ('<<<<<<<<<<<<<<<< Face Record >>>>>>>>>>>>>>>');
               WITH hfcRecT^^ DO BEGIN
                  IF Bold in seteface THEN BEGIN
                     WRITE ('Bold | ');
                  END; {if}
                  IF Italic in seteface THEN BEGIN
                     WRITE ('Italic | ');
                  END; {if}
                  IF UnderLine in seteface THEN BEGIN
                     WRITE ('UnderLine | ');
                  END; {if}
                  IF Outline in seteface THEN BEGIN
                     WRITE ('Outline | ');
                  END; {if}
                  IF Shadow in seteface THEN BEGIN
                     WRITE ('Shadow | ');
                  END; {if}
                  IF condense in seteface THEN BEGIN
                     WRITE ('condense | ');
                  END; {if}
                  IF extend in seteface THEN BEGIN
                     WRITE ('extend | ');
                  END; {if}
                  IF OnlyMetricsWidths in seteface THEN BEGIN
                     WRITE ('OnlyMetricsWidths | ');
                  END; {if}
                  WRITELN;

                  WRITELN ('Bold:         ', mpefaceb [Bold]);
                  WRITELN ('Italic:       ', mpefaceb [Italic]);
                  WRITELN ('UnderLine:   ', mpefaceb [UnderLine]);
                  WRITELN ('Outline:     ', mpefaceb [Outline]);
                  WRITELN ('Shadow:       ', mpefaceb [Shadow]);
                  WRITELN ('Extra:        ', cXtra);

                  IF edevScreen IN setedev THEN BEGIN
                     WRITE ('Screen | ');
                  END; {if}
                  IF edevDotMx IN setedev THEN BEGIN
                     WRITE ('Dot Matrix | ');
                  END; {if}
                  IF edevHDotMx IN setedev THEN BEGIN
                     WRITE ('Hi-Res Dot Matrix | ');
                  END; {if}
                  IF edevTyper IN setedev THEN BEGIN
                     WRITE ('Typewriter | ');
                  END; {if}
                  IF edevLaser IN setedev THEN BEGIN
                     WRITE ('Laser | ');
                  END; {if}
                  IF edev1 IN setedev THEN BEGIN
                     WRITE ('edev1 | ');
                  END; {if}
                  IF edev2 IN setedev THEN BEGIN
                     WRITE ('edev2 | ');
                  END; {if}
                  WRITELN;

                  WRITELN ('Root Name:  "', str30Root, '"');
               END; {with hfcRecT^^}
               hfcRecT := hfcRecT^^.hfcRecNxt;
            END; {while}
         END; {if there is a valid entry here}
      END; {with hrgheurrec^^ [ihrrecT]}
   END; {for}

   WRITELN ('<<<<<<<<<<<<<<<< Spoke Table >>>>>>>>>>>>>>>');
   FOR eskcl := eskclMPPS TO eskclPQume DO BEGIN               {jwp 3/16/83}
      WRITELN ('hmpeskclstr30^^ [', ORD (eskcl):1, ']: "',
                hmpeskclstr30^^ [eskcl], '"');
   END; {for each spoke table name}

END; {FMDumpHeurTable}
{$ENDC}{end of fmdebug section}

{$S FMwarm}
{===============================================================================

#######> FMLockFont

        COMMENT: This procedure will cause the font associated with the specifed
                 lfntid to locked, or not locked in memory depending on the state
                 of flock (TRUE, or FALSE).

                 For the time being, HLockN will always return NIL.

        GLOBALS: nMap: the "name" of the NOB which is to be locked. nMap is
                       generated from NToName inside of FMSwapFont.

===============================================================================}

PROCEDURE FMLockFont
   {VAR lfntid: TLfntid;
        flock: TF;
    VAR cError: TC};
VAR
   hT: TH;
   pcharstyle: TPcharstyle;
   lfCheat: TLfCheat;

BEGIN {FMLockFont}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug3 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('FMLockFont:    fam = ', lfntid.fam, '  lfntid = ',
               lfCheat.n, '   flock = ', flock);
   END; {if}
   {make sure the font is swapped in first}
   pcharstyle := FMSwapFont (lfntid, cError);
   IF cError <= 0 THEN BEGIN
      IF flock THEN BEGIN
         hT := HLockN (hzFM, nMap, FALSE);
      END
      ELSE BEGIN
         UnlockN (hzFM, nMap);
      END; {else}
   END; {if}
END; {FMLockFont}


{$S FMwork}
{===============================================================================

#######> FMCbOfN

        COMMENT: Given a named object, return the count of bytes in the object.
                 Note: in our case, the named object is always the same size -
                       it is the size of a TSRec.

===============================================================================}

FUNCTION FMCbOfN
   (    n: TN)
   : TC;

BEGIN {FMCbOfN}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug4 THEN BEGIN
      WRITELN ('FMCbOfN');
   END; {if}
   FMCbOfN := SIZEOF (TSRec);
END; {FMCbOfN}


{$S FMwarm}
{===============================================================================

#######> CheckSumOk

     COMMENT:  cw = the number of words in the font excluding the checksum
                  word itself.

===============================================================================}

FUNCTION CheckSumOk
    (    pFont: TP;
         cw: LONGINT)
: TF;
VAR
    i: LONGINT;
    sum: INTEGER;
    pw: ^INTEGER;

BEGIN {CheckSumOk}
{$IFC fTraceFM} LogCall; {$ENDC}
    sum := 0;
    FOR i := 1 TO cw * 2 DO BEGIN
        sum := (sum + pFont^) MOD MAXINT;
        pFont := POINTER (ORD (pFont) + 1);
    END; {for i}
    pw := POINTER (ORD (pFont));
    CheckSumOk := (sum = pw^);
END; {CheckSumOk}


{===============================================================================

#######> FMSwapNIn

        COMMENT: Given a real file identifier, find the associated swap record
                 (create if necessary) and return a handle to it.
                 Note: When a swap record is first created (allocated) it is
                 initialized with all handles = NIL. This is necessary since
                 in the process of allocating those handles, the swap record
                 may itself be removed by FMSwapOutN.

===============================================================================}

FUNCTION FMSwapNIn
   (    hz: THz;
        nMap: TN)
   : TF;
CONST
   formatSize = 2;
   chkSumSize = 2;
   paramSize = 8;

VAR
   hkT,
   hmT: TH;
   pnobT: TPnob;
   psrecT: TPSRec;
   pformat: ^TFormat;
   filename: TStr30;
   cError: TC;
   found: TF;
   lfntidT: TLfntid;
   lFst,
   lLim,
   MetWid_Fst,
   MetWid_Lim: TL;
   lfCheat: TLfCheat;


{$S FMwork}
{===============================================================================

#######> AssignDevice

        COMMENT:  Given the root file name of a font, and a device spec.,
                  return the full file name including device specifier.

===============================================================================}

PROCEDURE AssignDevice
   (    lfntid: TLfntid;
    VAR str30: TStr30;
    VAR cError: TC);

VAR
   lfCheat: TLfCheat;

BEGIN {AssignDevice}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug7 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('AssignDevice:    lfntid = ', lfCheat.n);
   END; {if}
   WITH lfntid DO BEGIN
      CASE edev OF
         edevScreen: BEGIN
            str30 := CONCAT (str30, 'S.F');
         END; {edevScreen}
         edevDotMx,
         edevHDotMx: BEGIN
            IF fHiRes OR (edev = edevHDotMx) THEN BEGIN  {jwp 4/22/83}
               str30 := CONCAT (str30, 'H.F');
            END
            ELSE BEGIN
               str30 := CONCAT (str30, 'S.F');
            END; {else}
         END; {edevDotMx}
         edevTyper: BEGIN
            str30 := CONCAT (str30, 'T.F');
         END; {edevTyper}
         edevLaser: BEGIN
            str30 := CONCAT (str30, 'L.F');
         END; {edevLaser}
         edev1:  BEGIN
            str30 := CONCAT (str30, 'C.F');
         END; {edev1}
         edev2:  BEGIN
            str30 := CONCAT (str30, 'X.F');
         END; {edev2}
         OTHERWISE BEGIN
            IF fdebug40 THEN BEGIN
               WRITELN ('   An unknown device was specified. Dev #', ORD (edev):1);
            END; {if}
            cError := fmErrorBase + 2;
         END; {otherwise}
      END; {case}
   END; {with}
END; {AssignDevice}


{$S FMwarm}
{===============================================================================

#######> SpokeName

        COMMENT:

===============================================================================}

PROCEDURE SpokeName
   (    lfntid: TLfntid;
    VAR str30: TStr30);

TYPE
   TSetCheat = RECORD
      CASE BOOLEAN OF
         TRUE: (seteface: Style);
         FALSE: (bex: TB);
   END;

VAR
   setCheat: TSetCheat;

BEGIN {SpokeName}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug8 THEN BEGIN
      WRITELN ('SpokeName    whcl: ', ORD (lfntid.ewhcl));
   END; {if}
   WITH lfntid DO BEGIN
      setCheat.seteface := seteface;
      CASE ewhcl OF
         ewhclMP: BEGIN
            CASE fam OF
{jwp 3/16/83}     tile12: BEGIN
                  str30 := hmpeskclstr30^^ [eskclMPPS];
               END;
               OTHERWISE BEGIN
                  str30 := hmpeskclstr30^^ [eskclMPFP];
               END;
            END; {case fam}
         END; {ewhclMP}

         ewhclMF: BEGIN
            IF setCheat.bex = 1 THEN BEGIN  {we want the italic spoke table}
               str30 := hmpeskclstr30^^ [eskclMFI];
            END
            ELSE BEGIN
               str30 := hmpeskclstr30^^ [eskclMFR];
            END;
         END; {ewhclMF}

         ewhcl20,                                     {jwp 3/16/83}
         ewhcl15,                                     {jwp 3/16/83}
         ewhcl12,                                     {jwp 3/16/83}
         ewhcl10: BEGIN                               {jwp 3/16/83}
            str30 := hmpeskclstr30^^ [eskclFQume];    {jwp 3/16/83}
         END;                                         {jwp 3/16/83}
                                                      {jwp 3/16/83}
         ewhclPS: BEGIN                               {jwp 3/16/83}
            str30 := hmpeskclstr30^^ [eskclPQume];    {jwp 3/16/83}
         END;                                         {jwp 3/16/83}

         OTHERWISE BEGIN  {universal wheel class ewhclLCS?}
            str30 := hmpeskclstr30^^ [eskclApple];
         END;
      END; {case ewhcl}
   END; {with lfntid}
END; {SpokeName}



{$S FMwork}
{===============================================================================

#######> NToFileName

        COMMENT: Return the file name (string) associated with the given
                 name (nMap).

===============================================================================}

PROCEDURE NToFileName
   (    nMap: TN;
    VAR str30: TStr30;
    VAR cError: TC);

VAR
   i: TC;
   lfCheat: TLfCheat;
   setCheat: TSetCheat;
   hfaceNxt: THfaceRec;

BEGIN {NToFileName}
{$IFC fTraceFM} LogCall; {$ENDC}
   cError := 0;   {assume the best}
   lfCheat.n:= nMap;    {type cheat to get some sort of a lfntid}
   setCheat.seteface := lfCheat.lfntid.seteface;
   IF fdebug9 THEN BEGIN
      WRITELN ('NToFileName    nMap = ', nMap, '    fam = ', lfCheat.lfntid.fam,
               '    bex = ', setCheat.bex);
   END;
   WITH lfCheat, lfntid DO BEGIN
      IF (edev = edevTyper)
         AND
         fspoke THEN BEGIN
         SpokeName (lfntid, str30);
      END
      ELSE BEGIN
         WITH hrgheurrec^^[fam], setCheat DO BEGIN
            hfaceNxt := hfaceRec;
            FOR i := 1 TO bex DO BEGIN
               hfaceNxt := hfaceNxt^^.hfcRecNxt;
            END; {for i}
            str30 := hfaceNxt^^.str30Root;
         END; {with hrgheurrec^^[fam]}
         IF fdebug9 THEN BEGIN
            WRITELN ('    fileName: "', str30, '"');
         END;
         IF NOT hrgheurrec^^ [fam].fuser THEN BEGIN
            AssignDevice (lfntid, str30, cError);
         END; {if}
      END;
      IF fdebug9 THEN BEGIN
         WRITELN ('    final fileName: "', str30, '"');
      END;
   END; {with lfCheat}
END; {NToFileName}



{$S FMwork}
{===============================================================================

#######> LocateFont

     COMMENT:

===============================================================================}

PROCEDURE LocateFont
   (    name: PathName;
    VAR lFst,
        lLim,
        MetWid_Fst,
        MetWid_Lim: TL;
    VAR found: TF);
VAR
   i,
   id,
   ifst,
   ihash: TC;

BEGIN {LocateFont}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug12 THEN BEGIN
      WRITELN ('LocateFont:   Pathname = ', name);
   END;
   id := 0;
   FOR i := 1 TO LENGTH (name) DO BEGIN
       id := FMROR (id + ORD (name [i]));
   END; {for i}
   ifst := 0;
   ihash := HashOfId (id, htable, ifst);
   IF fdebug12 THEN BEGIN
      WRITELN ('    key = ', htable^^ [ihash].key, '  id = ', id,
               '  ihash = ', ihash, '  ifst = ', ifst);
   END;
   IF htable^^ [ihash].key = id THEN BEGIN
      lFst := htable^^ [ihash].lFst;  {we need to return byte lengths}
      lLim := htable^^ [ihash].lLim;
      MetWid_Fst := htable^^ [ihash].MetWid_Fst;
      MetWid_Lim := htable^^ [ihash].MetWid_Lim;
      found := TRUE;
      IF fdebug12 THEN BEGIN
         WRITELN ('    Key found. from ', lFst:1, ' to ', lLim:1,
                  '   and Metrics_Widths from ', MetWid_Fst:1,
                  ' to ', MetWid_Lim:1);
      END;
   END
   ELSE BEGIN
      found := FALSE;
      IF fdebug40 THEN BEGIN
         WRITELN ('Error in LocateFont:    Key not found!',
                  '    key = ', htable^^ [ihash].key);
      END;
   END;
END; {LocateFont}



{$S FMwork}
{===============================================================================

#######> ReadFont

        COMMENT: Read a font from the disk, allocate space for it in hzFM,
                 and return a handle to it.  Returns handle Nil if can't find it.

===============================================================================}

FUNCTION ReadFont
   (    fileName: PathName;
        lFst,
        lLim: TL;
        found: TF;
    VAR cError: TC)
:TH;
VAR
   h: TH;
   readError,
   cjunk,
   cRefNum: TC;
   lactual: LONGINT;
   cbMax,             {# of bytes in uncompressed font -- data only}
   cbCur: TL;         {# of bytes in compressed font -- data only}
   format: TFormat;
   pformat: ^TFormat;
   fSeparate: TF;


{$S FMwork}
{===============================================================================

#######> DecodeFont

     COMMENT:

===============================================================================}

PROCEDURE DecodeFont
   (VAR hfont: TH;
        cbMax,
        cbData: TL);

BEGIN {DecodeFont}
{$IFC fTraceFM} LogCall; {$ENDC}
   {don't forget to skip over the format word!}
   UnCompress (cbMax, cbData, POINTER (ORD (hfont^) + 2));
   IF NOT ((format.variety = typerFont)
          OR
          (format.variety = spokeFont)) THEN BEGIN
       UnVXORFont (hfont^);
   END; {if}
END; {DecodeFont}



{$S FMwarm}
{===============================================================================

#######> ZZOpenFontFile

     COMMENT:  The ZZ prefix is a kludge to make this Unit reusable.

===============================================================================}

PROCEDURE ZZOpenFontFile
   (    fileName: PathName;
    VAR fontRefNum: TC;
    VAR lFst,
          lLim: TL;
    VAR cError: TC);

VAR
   fprot: BOOLEAN;
   fileInfo: fs_info;

BEGIN {ZZOpenFontFile}
{$IFC fTraceFM} LogCall; {$ENDC}
      IF fdebug13 THEN BEGIN
         WRITELN ('ZZOpenFontFile:   Pathname = ', filename);
      END;
      POPEN (cError, fileName, fontRefNum, [dread, global_refnum], fprot);
      IF cError <= 0 THEN BEGIN
         INFO (cError, fontRefNum, fileInfo);
         IF cError <= 0 THEN BEGIN
            lfst := 0;
            llim := fileInfo.size;  {size of font file according to the OS}
         END;
      END;
END; {ZZOpenFontFile}


{$S FMwork}
{*******************************************************************************}

BEGIN {ReadFont}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug10 THEN BEGIN
      WRITELN ('ReadFont:   Pathname = ', filename,'  lFst = ', lFst,
               '  lLim = ', lLim, '  found = ', found);
   END;
   ReadFont := NIL;  {just in case....}
   fSeparate := FALSE;  {99% of the time....}
   readError := 0;
   IF found THEN BEGIN   { This font is in the font library as normal }
      {position ourselves at the proper place in the font library}
      READ_DATA
         (readError, cRefnumLib, ORD (@cjunk), 0, lactual, absolute, odirec + lFst);
      IF fdebug10 THEN BEGIN
         WRITELN ('    file positioned @', (odirec + lFst), '.');
      END;
      cRefNum := cRefnumLib;
   END
   ELSE BEGIN    { This font name is either bad or it is in a separate font file }
      ZZOpenFontFile (fileName, cRefNum, lFst, lLim, readError);
      IF readError > 0 THEN BEGIN
         cError := fmErrorBase + 7;
         EXIT (ReadFont);
      END
      ELSE BEGIN
         fSeparate := TRUE;
      END;
   END;
   READ_DATA
      (readError, cRefNum, ORD (@format), 2, lactual, sequential, 0);
   IF readError <> 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('Error in ReadFont in READ_DATA for header format. Error #:',
                  cError);
      END; {if}
      cError := readError;
      IF fSeparate THEN BEGIN
         CLOSE_OBJECT (cError, cRefNum);
      END;
      EXIT (ReadFont);
   END; {if}
   IF fdebug10 THEN BEGIN
      WITH format DO BEGIN
         WRITELN ('    format/ history: ', history:1, ', variety: ', variety:1,
                  ', compressed: ', format.fcompressed);
      END; {with format}
   END;
   IF format.fcompressed THEN BEGIN
       READ_DATA
         (readError, cRefNum, ORD (@cbCur), 4, lactual, sequential, 0);
       READ_DATA
         (readError, cRefNum, ORD (@cbMax), 4, lactual, sequential, 0);
       {adjust the remaining file size}
   END
   ELSE BEGIN
      cbMax := lLim - lFst - 4; {don't include the format or checksum}
      cbCur := cbMax;
   END; {else}

   h := POINTER (ORD (HAllocate (hzFM, cbMax + formatSize + chkSumSize)));
   IF h <> NIL THEN BEGIN
       pformat := POINTER (ORD (h^)); {add the format word back into the font}
       pformat^.c := format.c;
       READ_DATA
         (readError, cRefNum, ORD (h^) + 2, cbCur + chkSumSize, lactual,
          sequential, 0);
       IF fSeparate THEN BEGIN
          CLOSE_OBJECT (cError, cRefNum);
       END;
       IF readError <> 0 THEN BEGIN
          IF fdebug40 THEN BEGIN
             WRITELN ('Error in ReadFont. READ_DATA Error #:', readError,
                      'cbCur + chkSumSize: ', (cbCur + chkSumSize):5,
                      'lactual: ', lactual:5);
          END; {if}
          FreeH (hzFM, h);
          cError := readError;
          EXIT (ReadFont);
       END; {if}
   END {if}
   ELSE BEGIN
      cError := fmErrorBase + 5;
   END; {else}

   IF format.fcompressed THEN BEGIN
      DecodeFont (h, cbMax, cbCur);
   END;
   cError := readError;
   ReadFont := h;
   IF fdebug10 THEN BEGIN
       WRITELN ('Exiting ReadFont:  h = ', ORD (h),
                '    cbCur = ', cbCur:5, '    cbMax = ', cbMax:5);
   END; {if}
END; {ReadFont}



{$S FMwork}
{===============================================================================

#######> ReadMetricsWidths

        COMMENT: Read the metrics and the widths from the separate uncompresssed
                 record that follows the bit map's compressed record. Note that
                 the metrics and the widths also appear in the compressed record,
                 but duplicating them allows us to get at the just the widths
                 metrics without uncompressing and without pulling in all of the
                 large bit map. The format of the record read is a valid font
                 but the length has been set by the program LibMaster to indicate
                 a null bit map.

===============================================================================}

FUNCTION ReadMetricsWidths
   (    MetWid_Fst,
        MetWid_Lim: TL;
    VAR cError: TC):TH;

VAR
   lactual,
   record_size: LONGINT;
   handle: TH;


BEGIN {ReadMetricsWidths}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug14 THEN BEGIN
      WRITELN ('ReadMetricsWidths:    From ', MetWid_Fst, ' to ', MetWid_Lim);
   END;

   record_size := MetWid_Lim - MetWid_Fst;
   handle := POINTER (ORD (HAllocate (hzFM, record_size)));

   IF handle <> NIL THEN BEGIN
      READ_DATA (cError, cRefNumLib, ORD(handle^), record_size,
                 lactual, absolute, odirec + MetWid_Fst); { Get Metrics & Widths }

      IF (cError <> 0) OR (lactual <> record_size) THEN BEGIN
         IF fdebug40 THEN BEGIN
            WRITELN ('Error in ReadMetricsWidths.   READ_DATA Error #: ', cError,
                     '   record_size: ', record_size,
                     '   odirec: ', odirec,
                     '   MetWid_Fst: ', MetWid_Fst,
                     '   MetWid_Lim: ', MetWid_Lim,
                     '   lactual: ', lactual);
         END; {if}
         FreeH (hzFM, POINTER(ORD(handle)));
         EXIT (ReadMetricsWidths);
      END; {if error}
   END {if}
   ELSE BEGIN
      cError := fmErrorBase + 13;
   END; {else}
   ReadMetricsWidths := handle;

END; {ReadMetricsWidths}



{$S FMwork}
{*******************************************************************************}

BEGIN {FMSwapNIn}
{$IFC fTraceFM} LogCall; {$ENDC}
   SwapInCount := SwapInCount + 1;
   IF fdebug6 THEN BEGIN
      lfCheat.n := nMap;  {type cheat to be able to print a fam}
      WRITELN ('>>>>>FMSwapNIn:  fam =', lfCheat.lfntid.fam:1,
               '  NeedBits =', NeedTheBits:1,
               '  cbFree =', hzFM^.cbFree:1,'  nMap =', nMap:1,
               '  CbOfHz =', CbOfHz(hzFM):1);
   END; {if}

   {Get the font and width table first so we have their sizes on hand. Use the}
   {temporary var's hkT, and hmT in case a handle is invalidated in the middle}
   {of a function call}
   NToFileName (nMap, filename, cError);
   IF cError <> 0 THEN BEGIN  {this error will never be neg.}
      FMSwapNIn := FALSE;
      cErrorG := cError;
      IF fdebug40 THEN BEGIN
         WRITELN ('Exiting FMSwapNIn(After NToFileName):  cError = ', cError:1,
                  '  NeedTheBits = ', NeedTheBits:1);
      END; {if}
      EXIT (FMSwapNIn);
   END;

   LocateFont (filename, lFst, lLim, MetWid_Fst, MetWid_Lim, found);

   IF NeedTheBits OR (NOT found) THEN BEGIN  { if need bits or if separate font }
      hkT := ReadFont (filename, lFst, lLim, found, cError);
      IF cError <> 0 THEN BEGIN
         cErrorG := cError;
         FMSwapNIn := FALSE;
         IF fdebug40 THEN BEGIN
            WRITELN ('Exiting FMSwapNIn(After ReadFont):  cError = ', cError);
         END; {if}
         EXIT(FMSwapNIn);
      END; {if}
   END {if}
   ELSE BEGIN
      hkT := ReadMetricsWidths (MetWid_Fst, MetWid_Lim, cError);
      IF cError <> 0 THEN BEGIN
         FreeH(hzFM, hkT);
         cErrorG := cError;
         FMSwapNIn := FALSE;
            IF fdebug40 THEN BEGIN
               WRITELN ('Exiting FMSwapNIn(After ReadMetricsWidths):  cError = ',
                        cError);
            END; {if}
         EXIT(FMSwapNIn);
      END; {if}
   END; {else}

   FMSwapNIn := TRUE;
   hmT      := POINTER (ORD (HAllocate (hzFM, SIZEOF (TMpccwid))));

   {Now map in the swap record and fill it out.}
   pnobT := PnobFromN(hz, nMap);
   psrecT := @pnobT^.data;

   WITH psrecT^ DO BEGIN
      hks      := hkT;                    {Init the swap record}
      hmpccwid := POINTER (ORD (hmT));

      pformat := POINTER (ORD (hks^));    {Unles spokefont, decode the widths}
      IF (pformat^.variety <> spokeFont) THEN BEGIN
         GetWidths (hks, hmpccwid);      {Get widths from decompressed record}
      END; {if}

      SetFDirty (hzFM, nMap, TRUE); {Make sure we're notified if swapped out}
      IF fdebug6 THEN BEGIN
         pnobT := PnobFromN(hz, nMap);
         psrecT := @pnobT^.data;
         WRITELN ('Exiting FMSwapNIn:   cbFree: ', hzFM^.cbFree:1,
                  '  hks: ', ORD (psrecT^.hks):1,
                  '  hmp: ', ORD (psrecT^.hmpccwid):1,
                  '  CbOfHz = ', CbOfHz(hzFM):1);
     END; {if}
   END; {with}
END; {FMSwapNIn}



{$S FMwork}
{===============================================================================

#######> FMSwapOutN

        COMMENT:

===============================================================================}

PROCEDURE FMSwapOutN
   (    hz: THz;
        nMap: TN);
VAR
   pnobT: TPnob;
   psrecT: TPsrec;
   hkT,
   hmT: TH;
   lfCheat: TLfCheat;

BEGIN {FMSwapOutN}
{$IFC fTraceFM} LogCall; {$ENDC}
   SwapOutCount := SwapOutCount + 1;
   IF fdebug15 THEN BEGIN
      lfCheat.n := nMap;  {type cheat to be able to print a fam}
      WRITELN ('<<<<<FMSwapOutN:  fam =', lfCheat.lfntid.fam:1,
               '  OnlyMetWid =', (OnlyMetricsWidths IN lfCheat.lfntid.seteface):1,
               '  cbFree =', hzFM^.cbFree:1, '  nMap =', nMap:1,
               '  CbOfHz =', CbOfHz(hzFM):1);
   END; {if}
   pnobT := PnobFromN(hz, nMap);
   psrecT := @pnobT^.data;
   IF psrecT <> NIL THEN BEGIN
      hkT      := psrecT^.hks;
      hmT      := POINTER (ORD (psrecT^.hmpccwid));

      FreeH (hzFM, hkT );      {Get rid of the bit map}
      FreeH (hzFM, hmT );      {Get rid of the widths}
      IF fdebug15 THEN BEGIN
         WRITELN ('Exiting FMSwapOutN:   cbFree = ', hzFM^.cbFree:1,
                  '  handles = ', ORD (hkT):1, ', ', ORD(hmT):1,
                  '  CbOfHz = ', CbOfHz(hzFM):1);
      END; {if}
   END {if}
   ELSE BEGIN
      IF fdebug40 THEN
         WRITELN ('Error in FMSwapOutN:    psrecT was NIL!');
   END; {else}
END; {FMSwapOutN}



{$S FMwork}
{===============================================================================

#######> FMMapFont

        COMMENT: FMMapFont will map the given lfntid into a lfntid that is self-
                 consistent ie. a lfntid whose fam field is compatible with its
                 dev field. If a mapping other than the identity mapping occurs,
                 the error code returned will indicate that a substitution has
                 occured.

===============================================================================}

PROCEDURE FMMapFont
   {VAR lfntid: TLfntid;
    VAR cError: TC};

VAR
   lfCheat: TLfCheat;

BEGIN {FMMapFont}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug16 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('FMMapFont:    lfntid = ', lfCheat.n);
   END;
   cError := 0;
   WITH lfntid DO BEGIN
      IF NOT fOffline THEN BEGIN
         IF edev = edevTyper THEN BEGIN
            WITH hrgheurrec^^ [fam] DO BEGIN
               IF hfaceRec <> NIL THEN BEGIN
                  IF fam <> mpewhclfam [ewhcl] THEN BEGIN
                     fam := mpewhclfam [ewhcl];
                     cError := -1 * (fmErrorBase + 24);
                     IF fdebug16 THEN BEGIN
                        WRITELN ('   ewhcl         : ', ORD (ewhcl),
                                 '   New fam       : ', fam);
                     END; {if}
                  END; {if}
{jwp 3/9/83}      IF ewhcl = ewhclMF THEN BEGIN
{jwp 3/9/83}         seteface :=
{jwp 3/9/83}            seteface * [Italic, Bold, UnderLine, OnlyMetricsWidths];
{jwp 3/9/83}      END
{jwp 3/9/83}      ELSE BEGIN
{jwp 3/9/83}         seteface := seteface * [Bold, UnderLine, OnlyMetricsWidths];
{jwp 3/9/83}      END;
               END
               ELSE BEGIN
                  cError := fmErrorBase;
               END; {else there was an unknown fam requested}
            END; {with hrgheurrec^^ [fam]}
         END; {if}
      END; {if not offline}
   END; {with lfntid}
END; {FMMapFont}



{$S FMwork}
{===============================================================================

#######> FMSwapFont

        COMMENT: Given a lfntid, return a valid charstyle including a non-NIL
                 handle to the font bits.

        GLOBALS:
                 nMap   is Set by NToName to be used by FMLockFont, and
                        FMSwapFont. nMap is the "name" used to reference the
                        swapping NOB.

===============================================================================}

FUNCTION FMSwapFont
   {(VAR lfntid: TLfntid;
     VAR cError: TC)
   : TPcharstyle};

VAR
   nMapT: TN;
   pnT: TN;
   pnTP: ^TN;
   chsT: TCharstyle;
   psrecT: TPSRec;
   famNxt: TFam;
   hardError: TC;
   pkshdr: TPkshdr;
   lfCheat: TLfCheat;
   sError: TC;


{$S FMwork}
{===============================================================================

#######> NToName

        COMMENT: Given a long font id, search the heuristics table(s)
                    to find the associated charstyle, and real file name.
                    NOTE: It is important for a call to PMapN to immediately
                           follow NToName.

===============================================================================}

FUNCTION NToName
   (    lfntid: TLfntid;
    VAR charstyle: TCharstyle;
    VAR nMap: TN;
    VAR cError: TC)
   : TF;

VAR
   ffound: TF;
   efaceT: StyleItem;
   pseteface: ^Style;
   bExep: TB;
   pnT: ^TN;
   lfCheat: TLfCheat;


{$S FMwork}
{===============================================================================

#######> EvalEntry

        COMMENT: Given a handle to the correct entry in the heuristic table,
                 and a lfntid, fill in a charstyle and a filename.

===============================================================================}

PROCEDURE EvalEntry
   (    lfntid: TLfntid;
    VAR charstyle: TCharstyle;
    VAR bExep: TB);
{8}
VAR
   efaceT: StyleItem;
   fmatch: TF;
   hfcrecT: THfaceRec;
   lfCheat: TLfCheat;


{$S FMwork}
{===============================================================================

#######> CheckChs

        COMMENT: Given a handle to a face record in the heuristics list, check
                 and see if its entries match those of the requested charstyle.
                 If a match does occur, CheakChs will return the appropriate
                 charstyle.

===============================================================================}

PROCEDURE CheckChs
   (    lfntid: TLfntid;
        hfaceRec: THfaceRec;
    VAR charstyle: TCharstyle;
    VAR fmatch: TF);

VAR
   lfCheat: TLfCheat;

BEGIN {CheckChs}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug20 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('CheckChs:    lfntid = ', lfCheat.n);
   END; {if}
   WITH charstyle, lfntid DO BEGIN
      {First check to see if the device spec will match}
      IF edev IN hfaceRec^^.setedev THEN BEGIN
         fMatch := TRUE; {OK so far}
         {Is the requested set included in the provided set?}
         IF seteface <= hfaceRec^^.seteface THEN BEGIN
            bBold := 0;
            bItalic := 0;
            bUnderline := 0;
            bShadow := 0;
            IF Bold IN seteface  THEN BEGIN
               bBold := hfaceRec^^.mpefaceb [Bold];
            END; {if}
            IF Italic IN seteface  THEN BEGIN
               bItalic := hfaceRec^^.mpefaceb [Italic];
            END; {if}
            IF UnderLine IN seteface  THEN BEGIN
               bUnderline := hfaceRec^^.mpefaceb [UnderLine];
            END; {if}
            IF Outline IN seteface  THEN BEGIN
               bShadow := hfaceRec^^.mpefaceb [Outline];
            END; {if}
            IF Shadow IN seteface  THEN BEGIN
               bShadow := hfaceRec^^.mpefaceb [Shadow];
            END; {if}
         END {if the requested set <= provided set}
         ELSE BEGIN
            IF fdebug40 THEN BEGIN
               WRITELN ('In CheckChs:   Requested set not in given set')
            END; {if}
            fmatch := FALSE;
         END; {else}
      END {if device matched}
      ELSE BEGIN
         IF fdebug40 THEN BEGIN
            WRITELN ('In CheckChs:   Device Mis-Match')
         END; {if}
         fmatch := FALSE;
      END; {else}
   END; {with charstyle, lfntid}

   IF fdebug20 THEN BEGIN
      WITH charstyle DO BEGIN
         WRITELN ('Exiting CheckChs:    Bold = ', bBold:1,
                  '  Italic = ', bItalic:1,
                  '  Underline = ', bUnderline:1,
                  '  Shadow = ', bShadow:1);
      END; {with}
   END; {if}
END; {CheckChs}


{$S FMwork}
{*******************************************************************************}

BEGIN {EvalEntry}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug19 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('EvalEntry:    lfntid = ', lfCheat.n);
   END; {if}
   WITH lfntid DO BEGIN
      fMatch := FALSE;
      hfcrecT := hrgheurrec^^ [fam].hfaceRec;

      {the following is a patch for printing which only sets fHiRes}
      IF fHiRes THEN BEGIN       {jwp 4/22/83}
         edev := edevHDotMx;     {jwp 4/22/83}
      END;                       {jwp 4/22/83}

      {Check each faceRec in the list until we find one which matches the}
      {requested charstyle.}
      bExep := 0; {No exceptions so far...}
      WHILE (hfcrecT <> NIL)
            AND
            (NOT fmatch) DO BEGIN
         CheckChs (lfntid, hfcrecT, charstyle, fmatch);
         IF NOT fmatch THEN BEGIN
            hfcrecT := hfcrecT^^.hfcRecNxt;
            bExep := bExep + 1;
         END; {if}
      END; {while}

      IF fmatch THEN BEGIN
         charstyle.cExtra := hfcrecT^^.cXtra;
         IF (fHiRes OR (edev = edevHDotMx))    {jwp 4/22/83}
             AND
             (NOT fportrait) THEN BEGIN
              charstyle.cExtra := charstyle.cExtra - 1;
          END;
      END  {if}
      ELSE BEGIN {This should never happen...}
         bExep := 0; {....so go back to the vanilla font}
         WITH charstyle DO BEGIN
            bBold := 0;
            bItalic := 0;
            bUnderline := 0;
            bShadow := 0;
            cExtra := 0;
         END; {with charstyle}
      END; {else}
   END; {with lfntid}
END; {EvalEntry}


{$S FMwarm}
{===============================================================================

#######> EvalSpoke

        COMMENT:  Given the wheel class of a spoke tabe, and a face spec.,
                  return the full spoke table file name.

===============================================================================}

PROCEDURE EvalSpoke
   (    lfntid: TLfntid;
    VAR charstyle: TCharstyle;
    VAR bExep: TB);

BEGIN {EvalSpoke}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug21 THEN BEGIN
      WRITELN ('EvalSpoke    whcl: ', ORD (lfntid.ewhcl));
   END; {if}

   WITH lfntid DO BEGIN
      IF (ewhcl = ewhclMF)
         AND
         (Italic IN seteface) THEN BEGIN
         bExep := 1;
      END
      ELSE BEGIN
         bExep := 0; {the general case}
      END;
   END; {with lfntid}

   WITH charstyle DO BEGIN
      bBold := 0;
      bItalic := 0;
      bUnderline := 0;
      bShadow := 0;
      cExtra := 0;
   END; {with charstyle}
END; {EvalSpoke}


{$S FMwork}
{*******************************************************************************}

BEGIN {NToName}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug18 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('NToName:    lfntid = ', lfCheat.n);
    END; {if}
   {If we don't find a matching entry somebody must be trying to use an unknown}
   {font.}
   NToName := TRUE;
   WITH lfntid DO BEGIN
      IF (edev = edevTyper)
         AND
         fspoke THEN BEGIN
         EvalSpoke (lfntid, charstyle, bExep);
      END
      ELSE BEGIN
         IF fam <= heurTableSize THEN BEGIN
            IF hrgheurrec^^ [fam].hfacerec = NIL THEN BEGIN
               IF fdebug40 THEN BEGIN
                  WRITELN ('In NToName  Fatal Error. ',
                           'An Unknown Font was Requested.   fam: ', fam);
               END; {if}
               cError := fmErrorBase;
               NToName := FALSE;
               EXIT (NToName);
            END  {if}
            ELSE BEGIN  {We must have found the entry in the heur table.}
               EvalEntry (lfntid, charstyle, bExep);
            END; {else}
         END {if}
         ELSE BEGIN
            IF fdebug40 THEN BEGIN
               WRITELN ('In NToName  Fatal Error. ',
                        'An Unknown(Our of range) Font was Requested.   fam: ',
                        fam);
            END; {if}
            cError := fmErrorBase + 1;
            NToName := FALSE;
            EXIT (NToName);
         END; {else}
      END; {else not spoke request}
   END; {with lfntid}

   {Finally decide what "name" we are going to use for the swap record.}
   {To do this, replace the requested set of faces with the number of}
   {the exception record which matched the request.}
   pseteface := @bExep;
   lfntid.seteface :=  pseteface^;
   {Now coerce the type into something the hz manager will use}
   pnT := @lfntid;
   nMap := pnT^;
   IF fdebug18 THEN BEGIN
      WRITELN('Exiting NToName   nMap: ', nMap);
   END; {if}
END; {NToName}



{$S FMwarm}
{===============================================================================

#######> LastDitchOk

        COMMENT:

===============================================================================}

FUNCTION LastDitchOk
   (    firstError: INTEGER)
: BOOLEAN;
VAR
   nMapT: TN;
   chsT: TCharstyle;

BEGIN {LastDitchOk}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug22 THEN BEGIN
      WRITELN ('LastDitchOk:  Hence -> Hard error occurred in swapping mechanism');
   END; {if}
   {try a last ditch effort to get SOME font ie. the system font}
   LastDitchOk := FALSE;
   IF NToName (sysLfntid, chsT, nMapT, cError) THEN BEGIN
      psrecT := POINTER (ORD (PMapN (hzFM, nMapT)));
      IF psrecT <> NIL THEN BEGIN {whew!}
         LastDitchOk := TRUE;
         WITH chsT DO BEGIN
            hks := psrecT^.hks;
            hmpccwid := psrecT^.hmpccwid;
            IF fdebug22 THEN BEGIN
               WRITELN ('In LastDitchOk   handles = ',  ORD (hks), ', ',
                        ORD(hmpccwid));
            END; {if}
         END; {with chsPrv}
         chsPrv := chsT;
         nMap := nMapT;
      END;
   END;
   {Insure that we will get to NToName from FMSwapFont next time}
   nPrv := -1;
   cError := firstError;   {make sure the initial error gets through}
END; {LastDitchOk}


{$S FMwork}
{*******************************************************************************}

BEGIN  {FMSwapFont}
{$IFC fTraceFM} LogCall; {$ENDC}
   SwapFontCount := SwapFontCount + 1;
   IF fdebug17 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('FMSwapFont',
               '  fam = ', lfntid.fam:1,
               '  OnlyMetWid = ', (OnlyMetricsWidths IN lfntid.seteface):1,
               '  lfntid = ', lfCheat.n:1,
               '  nPrv = ', nPrv:1,
               '  edev = ', ORD(lfntid.edev):1);
   END; {if}
   IF fdebug11 THEN BEGIN
      IF lfntid.edev = edevDotMx THEN BEGIN {Switch from LowRes to HiRes}
         lfntid.edev := edevHDotMx;
         lfntid.fHiRes := TRUE;
         lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
         WRITELN ('FMSwapFont',
                  '  fam = ', lfntid.fam:1,
                  '  OnlyMetWid = ', (OnlyMetricsWidths IN lfntid.seteface):1,
                  '  lfntid = ', lfCheat.n:1,
                  '  nPrv = ', nPrv:1,
                  '  edev = ', ORD(lfntid.edev):1);
      END;
   END;
   IF fdebug31 THEN BEGIN
      IF (lfntid.edev = edevDotMx) AND (lfntid.fam = p10Tile) THEN BEGIN
         lfntid.edev := edevTyper;  {Switch from LowRes to Typer}
         lfntid.fSpoke := FALSE;
         lfntid.ewhcl := ewhcl10;
         lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
         WRITELN ('FMSwapFont',
                  '  fam = ', lfntid.fam:1,
                  '  OnlyMetWid = ', (OnlyMetricsWidths IN lfntid.seteface):1,
                  '  lfntid = ', lfCheat.n:1,
                  '  nPrv = ', nPrv:1,
                  '  edev = ', ORD(lfntid.edev):1);
      END;
   END;

   NeedTheBits := NOT (OnlyMetricsWidths IN lfntid.seteface); {global <- hack bit}
   cError := 0;
   {First see if we need to do Print Wheel substitution.}
   FMMapFont (lfntid, cError);
   FMSwapFont := @chsPrv;

   {See if the requested font is the same as the last requested font.       }
   {If so, go ahead and return since everything should still be valid.      }
   {Otherwise transform the "name" into a charstyle and file identifier and }
   {make sure the appropriate font is swapped in and ready.}

   pnTP := @lfntid; {Coerce the type into a "name" for unithz}
   pnT := pnTP^;
   IF pnT <> nPrv THEN BEGIN  {if different than last font(with bits <> w/o bits)}
      lfntid.seteface := lfntid.seteface - [OnlyMetricsWidths]; {Turn off hack bit}

      IF NToName (lfntid, chsT, nMapT, cError) THEN BEGIN
         psrecT := POINTER (ORD (PMapN (hzFM, nMapT)));
         IF psrecT = NIL THEN BEGIN
            IF NOT LastDitchOk (cErrorG) THEN BEGIN
               FMSwapFont := NIL;
               EXIT (FMSwapFont);
            END;
         END {if}
         ELSE BEGIN
            pkshdr := POINTER(ORD(psrecT^.hks^));
            IF (pkshdr^.raster = 0) THEN { if bit map not loaded }
               IF (pkshdr^.format.variety <> typerFont) AND
                  (pkshdr^.format.variety <> spokeFont) THEN {if bit map possible}
                  IF NeedTheBits THEN BEGIN { if we need the bit map }
                     FreeN(hzFM, nMapT); {start fresh and retrieve everything }
                     psrecT := POINTER (ORD (PMapN (hzFM, nMapT)));{get it again }
                  END;
            chsT.hks := psrecT^.hks;
            chsT.hmpccwid := psrecT^.hmpccwid;
            chsPrv := chsT; {Save for later}
            nPrv := pnT; {Save for later}
            nMap := nMapT; {Save for later}
         END; {else}
      END {if NToName}
      ELSE BEGIN
         IF NOT LastDitchOk (cError) THEN BEGIN
            FMSwapFont := NIL;
         END;
      END; {else}
   END; {if}

   NeedTheBits := TRUE;  {Probably unnecessary to reset it}

   IF fdebug17 THEN BEGIN
      WITH chsPrv DO BEGIN
         WRITELN ('Exiting FMSwapFont  E<', cErrorG:1, ',', cError:1, '>',
                  '  nMap = ', ORD (nMap):1,
                  '  hks = ', ORD (chsPrv.hks):1,
                  '  hmp = ', ORD (chsPrv.hmpccwid):1);
      END; {with}
   END; {if}
END; {FMSwapFont}



{$S FMwork}
{===============================================================================

#######> FMFontMetrics

        COMMENT:

===============================================================================}

FUNCTION FMFontMetrics
   {(VAR lfntid: TLfntid;
     VAR finfo: FontInfo;
     VAR cError: TC)
    : TF};

VAR
   pchsT: TPcharstyle;
   pkshdr: TPkshdr;
   previous_seteface: Style;  { For saving state of previous long font id }
   lfCheat: TLfCheat;
   TChangeInterval: LongInt;

BEGIN {FMFontMetrics}
{$IFC fTraceFM} LogCall; {$ENDC}
   MetricsCount := MetricsCount + 1;
   IF fdebug2 THEN BEGIN
      IF (MetricsCount MOD ChangeInterval) = 0 THEN BEGIN
         WRITELN;
         WRITE('Cache Size Desired ? ');
         READLN(InitialCacheSize);
         IF InitialCacheSize > 0 THEN
            FMCacheSize(InitialCacheSize, cError);
         WRITE('New Interval ? ');
         READLN(TChangeInterval);
         IF TChangeInterval < 0 THEN BEGIN
            ChangeInterval := - TChangeInterval;
            WRITELN('Counts:  FMSwapFont = ', SwapFontCount:1, '  FMSwapNIn = ',
                    SwapInCount:1, '  FMSwapOutN = ', SwapOutCount:1,
                    '  FMFontMetrics = ', MetricsCount:1);
         END {if}
         ELSE IF TChangeInterval > 0 THEN
            ChangeInterval := TChangeInterval;
      END; {if}
   END; {if}
   IF fdebug23 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('FMFontMetrics:',
               '  fam = ', lfntid.fam:1,
               '  lfntid = ', lfCheat.n:1,
               '  edev = ', ORD(lfntid.edev):1);
   END; {if}
   IF fdebug11 THEN BEGIN
      IF lfntid.edev = edevDotMx THEN BEGIN {Switch from LowRes to HiRes}
         lfntid.edev := edevHDotMx;
         lfntid.fHiRes := TRUE;
         lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
         WRITELN ('FMFontMetrics(to HiRes)',
                  '  fam = ', lfntid.fam:1,
                  '  lfntid = ', lfCheat.n:1,
                  '  edev = ', ORD(lfntid.edev):1);
      END;
   END;
   IF fdebug31 THEN BEGIN
      IF (lfntid.edev = edevDotMx) AND (lfntid.fam = p10Tile) THEN BEGIN
         lfntid.edev := edevTyper;  {Switch from LowRes to Typer}
         lfntid.fSpoke := FALSE;
         lfntid.ewhcl := ewhcl10;
         lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
         WRITELN ('FMFontMetrics(to Typer)',
                  '  fam = ', lfntid.fam:1,
                  '  lfntid = ', lfCheat.n:1,
                  '  edev = ', ORD(lfntid.edev):1);
      END;
   END;

   previous_seteface := lfntid.seteface;  {save may be unnecessary}
   lfntid.seteface := lfntid.seteface + [OnlyMetricsWidsths]; {Don't get bit map}
   pchsT := FMSwapFont (lfntid, cError);
   lfntid.seteface := previous_seteface;

   IF pchsT = NIL THEN BEGIN
      FMFontMetrics := FALSE;
   END
   ELSE BEGIN
      FMFontMetrics := TRUE;
      pkshdr := POINTER(ORD(pchsT^.hks^));
      WITH pkshdr^ DO BEGIN
         finfo.ascent := ascent;
         finfo.descent := descent;
         finfo.widMax := widMax + pchsT^.cExtra;
         IF Shadow IN lfntid.seteface THEN BEGIN   {jwp 3/29/83}
            finfo.ascent := finfo.ascent + 1;
            finfo.descent := finfo.descent + 2;
            finfo.widMax := finfo.widMax + 2;
         END {else if}
         ELSE IF Outline IN lfntid.seteface THEN BEGIN  {jwp 3/29/83}
            finfo.ascent := finfo.ascent + 1;
            finfo.descent := finfo.descent + 1;
            finfo.widMax := finfo.widMax + 1;
         END; {if}
         finfo.leading := leading;
      END; {with}
      WITH lfntid DO BEGIN
         IF (edev = edevScreen) THEN BEGIN
            {convert to 96x66 space -- sort of. (Fonts < 18pts. will work out}
            {exactly)}
            WITH finfo DO BEGIN
               leading := 0;
            END; {with}
         END; {if}
      END; {with}
      IF fdebug23 THEN WITH finfo DO BEGIN
         WRITELN ('Exiting FMFontMetrics: ascent =', ascent:1, ' descent =',
                  descent:1,  ' widmax =', widmax:1, ' leading =',
                  leading:1, ' extra =', pchsT^.cExtra:1);
      END; {if}
   END; {else}
END; {FMFontMetrics}



{$S FMlwwrk}
{===============================================================================

#######> FMFontWidths

        COMMENT:

===============================================================================}

FUNCTION FMFontWidths
   {(VAR lfntid: TLfntid;
     VAR hmpccwid: THmpccwid;
     VAR dExtra: TB;
     VAR cError: TC)
    : TF};
{11}
VAR
   pchsT: TPcharstyle;
   nMapT: TN;
   psrecT: TPsrec;
   previous_seteface: Style;  { For saving state of previous long font id }
   lfCheat: TLfCheat;

BEGIN {FMFontWidths}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug24 THEN BEGIN
      lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
      WRITELN ('FMFontWidths:',
               '  fam = ', lfntid.fam:1,
               '  lfntid = ', lfCheat.n:1,
               '  edev = ', ORD(lfntid.edev):1);
   END; {if}
   IF fdebug11 THEN BEGIN
      IF lfntid.edev = edevDotMx THEN BEGIN {Switch from LowRes to HiRes}
         lfntid.edev := edevHDotMx;
         lfntid.fHiRes := TRUE;
         lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
         WRITELN ('FMFontWidths(to HiRes)',
                  '  fam = ', lfntid.fam:1,
                  '  lfntid = ', lfCheat.n:1,
                  '  edev = ', ORD(lfntid.edev):1);
      END;
   END;
   IF fdebug31 THEN BEGIN
      IF (lfntid.edev = edevDotMx) AND (lfntid.fam = p10Tile) THEN BEGIN
         lfntid.edev := edevTyper;  {Switch from LowRes to Typer}
         lfntid.fSpoke := FALSE;
         lfntid.ewhcl := ewhcl10;
         lfCheat.lfntid := lfntid;  {type cheat to be able to print a lfntid}
         WRITELN ('FMFontWidths(to Typer)',
                  '  fam = ', lfntid.fam:1,
                  '  lfntid = ', lfCheat.n:1,
                  '  edev = ', ORD(lfntid.edev):1);
      END;
   END;

   FMFontWidths := TRUE;

   previous_seteface := lfntid.seteface;  {save may be unnecessary}
   lfntid.seteface := lfntid.seteface + [OnlyMetricsWidsths]; {Don't get bit map}
   pchsT := FMSwapFont (lfntid, cError);
   lfntid.seteface := previous_seteface;

   IF pchsT = NIL THEN BEGIN
      FMFontWidths := FALSE;
   END
   ELSE BEGIN
      hmpccwid := pchsT^.hmpccwid;
      IF fdebug24 THEN BEGIN
         WRITELN ('Exiting FMFontWidths:  pchsT = ',  ORD (pchsT),
                  '   hmpccwid = ', ORD(hmpccwid));
      END; {if}
      dExtra := pchsT^.cExtra;
      IF Shadow IN lfntid.seteface THEN BEGIN
         dExtra := dExtra + 2;
      END {if}
      ELSE IF Outline IN lfntid.seteface THEN BEGIN
         dExtra := dExtra + 1;
      END; {else if}
      FMFontWidths := TRUE;
   END; {else}
END; {FMFontWidths}


{$S FMinit  }
{===============================================================================

#######> FMCacheSize

        COMMENT: FMCacheSize will decrease or increase the size of the Font
                 Manager heap to the size specified if possible.

                 The Cache Is Reduced:
                 First space is freed up in the heap by calling SetCbFree to allow
                 room to shrink the heap. The heap is then shrunk and the data
                 segment is reduced in proportion to the new heap.

                 The Cache Is Increased:
                 First we increase the size of the data segment. The heap is then
                 enlarged in proportion to the new data segment.

===============================================================================}

PROCEDURE FMCacheSize
   {    lCacheSize: TL;
    VAR cError: TC};

CONST
   RoundUp = 100;   {Extra room for data segment over heap size}
   MinDiff = 1000;  {Minimum difference considered worth changing for}
VAR
   lFree,
   lDisk,
   lActual: TL;
   dsinfo: dsinfoRec;
   CurrentHzSize: TL;

BEGIN {FMCacheSize}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug25 THEN BEGIN
      WRITELN ('FMCacheSize:  lCacheSize = ', lCacheSize);
   END;

   INFO_DATASEG (cError, cRefnumHeap, dsinfo);
   IF cError = 0 THEN BEGIN
      IF ABS(lCacheSize - dsinfo.mem_size) > MinDiff THEN BEGIN  {worth changing}
         IF dsinfo.mem_size > lCacheSize THEN BEGIN {we want a smaller cache}
            lFree := CbOfHz(hzFM) - lCacheSize;
            lActual := CbShrinkHz (hzFM, lFree);
            IF fdebug25 THEN BEGIN
               WRITELN ('  Heap reduced: ', lActual:1,
                        '  wanted: ', lFree:1, ' Old Seg Size =',
                        dsinfo.mem_size:1, ' lCache =', lCacheSize:1,
                        '  CbOfHz =', CbOfHz(hzFM):1);
            END;

            lFree := dsinfo.mem_size - CbOfHz(hzFM);
            SIZE_DATASEG (cError, cRefnumHeap, -lFree + RoundUp, lActual, 0,
                          lDisk);
            IF fdebug25 THEN BEGIN
               WRITELN ('  New segment size: ', lActual:1,
                        '  Asked for change of: ',  (-lFree + RoundUp):1,
                        '  CbOfHz: ', CbOfHz(hzFM):1);
            END;
         END
         ELSE BEGIN
            IF dsinfo.mem_size < lCacheSize THEN BEGIN {we want a bigger cache}
               lFree := lCacheSize - dsinfo.mem_size;
               IF ODD (lFree) THEN BEGIN
                  lFree := lFree - 1;
               END;
               SIZE_DATASEG (cError, cRefnumHeap, lFree + RoundUp, lActual,
                             0, lDisk);
               IF fdebug25 THEN BEGIN
               WRITELN ('  New segment size: ', lActual:1,
                        '  Asked for change of: ',  (lFree + RoundUp):1,
                        '  CbOfHz =', CbOfHz(hzFM):1,
                        '  lCacheSize =', lCacheSize:1);
               END;
               CurrentHzSize := CbOfHz(hzFM);
               IF cERROR = 0 THEN BEGIN
                  EnlargeHz (hzFM, lActual - RoundUp - CurrentHzSize);
                  IF fdebug25 THEN BEGIN
                     WRITELN ('    EnlargeHz added: ',
                              (lActual - RoundUp - CurrentHzSize):1,
                              '  CbOfHz =', CbOfHz(hzFM):1);
                  END;
               END;
            END; {if}
         END; {else}
      END; {if}
   END {if}
   ELSE
      IF fdebug40 THEN
         WRITELN ('FMCacheSize:  Error from INFO_DATASEG   cError = ', cError);

   IF fdebug25 THEN
      WRITELN ('Exiting FMCacheSize:     hzFM^.cbfree = ', hzFM^.cbfree);

END; {FMCacheSize}



{$S FMinit  }
{===============================================================================

#######> FMAddFont

        COMMENT:

===============================================================================}

FUNCTION FMAddFont
   {(    str30: TStr30;
         modifier: TModifier;
         dev: TDev;
     VAR cError: TC)
   : TFam};

VAR
   ifam: TFam;
   found: TF;
   ewhcl: TEwhcl;
   lfntid: TLfntid;
   hfcrecT: THfacerec;

BEGIN {FMAddFont}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug26 THEN BEGIN
      WRITELN ('FMAddFont');
   END; {if}
   ifam := 0;
   found := FALSE;
   cError := 0;
   {Search the heuristic table until an unused entry is found. If one is found,}
   {create a new faceRec and add it to the table. If one is not found, return  }
   {an appropriate error code.}
   WHILE (ifam <= heurTableSize)
         AND
         NOT found DO BEGIN
      IF hrgheurrec^^ [ifam].hfaceRec = NIL THEN BEGIN
         {Add new face record to list and make sure it is the only one}
         hfcrecT := POINTER (ORD (HAllocate (hzFM, SIZEOF (TFaceRec))));
         WITH hrgheurRec^^ [ifam] DO BEGIN
            hfacerec := hfcrecT;
            WITH hfaceRec^^ DO BEGIN
               hfcRecNxt := NIL;
               seteface := modifier.seteface;
               mpefaceb := modifier.mpefaceb;
               cXtra := 0;
               lfntid.dev := dev;         {type cheat to get set element}
               setedev := [lfntid.edev];
               str30Root := str30;
            END; {with hfaceRec^^}
            FOR ewhcl := ewhcl20 TO ewhclLCS DO BEGIN
               mpewhclfam [ewhcl] := ifam;
            END; {for}
            fuser := TRUE;
         END; {with hrgheurRec^^ [ifam]}
         found := TRUE;
         FMAddFont := ifam;
         IF fdebug26 THEN BEGIN
            WRITELN ('FMAddFont = ', ifam:2);
         END; {if}
      END
      ELSE BEGIN
         ifam := ifam + 1;
      END; {else}
   END; {while}

   IF NOT found THEN BEGIN
      FMAddFont := 0;
      cError := fmErrorBase + 4;
   END;
END; {FMAddFont}



{$S FMinit  }
{===============================================================================

#######> FMDelFont

        COMMENT:

===============================================================================}

PROCEDURE FMDelFont
   {    lfntid: TLfntid};

VAR
    pn: ^TN;

BEGIN {FMDelFont}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug27 THEN BEGIN
      WRITELN ('FMDelFont');
      WITH lfntid DO BEGIN
          WRITELN ('    lfntid.fam: ', fam:2);
          WRITELN ('    lfntid.edev: ', ORD (edev):2);
      END; {with}
   END; {if}
   WITH lfntid DO BEGIN
       IF (hrgheurRec^^ [fam].hfaceRec <> NIL)
          AND
          hrgheurRec^^ [fam].fuser THEN BEGIN
            {prune the entry in the heuristic table}
            FreeH (hzFM, POINTER (ORD (hrgheurRec^^ [fam].hfaceRec)));
            WITH hrgheurRec^^ [fam] DO BEGIN
                hfaceRec := NIL;
                fuser := FALSE;
            END; {with hrgheurRec^^ [fam]}
            {elliminate NOB from hash table}
            seteface := []; {the execption will always be 0}
            pn := @lfntid;
            IF fdebug27 THEN BEGIN
                WRITELN ('    n: ', pn^);
            END; {if}
            FreeN (hzFM, pn^);
            {insure that we can reuse the same lfntid again by forcing a remapping}
            nPrv := -1;
       END;
   END; {with lfntid}
END;{FMDelFont}



{$S FMinit  }
{===============================================================================

#######> FMCloseLib

        COMMENT:

===============================================================================}

PROCEDURE FMCloseLib
   {VAR cError: TC};

BEGIN {FMCloseLib}
{$IFC fTraceFM} LogCall; {$ENDC}
   CLOSE_OBJECT (cError, cRefNumLib);
   IF cError <> 0 THEN BEGIN
      IF fdebug28 THEN BEGIN
         WRITELN ('Error in FMCloseLib. CLOSE_OBJECT Error #:', cError);
      END; {if}
   END; {if}
END; {FMCloseLib}



{$S FMopen  }
{===============================================================================

#######> FMOpen

        COMMENT: To initialize the segment table of the currently active process
                 to include the Font Managers Heap.

===============================================================================}

PROCEDURE FMOpen
   {VAR cError: TC};

CONST
   fmldsn = 16;

VAR
   fmDataName: PathName;
   lFst: LONGINT;

BEGIN {FMOpen}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug29 THEN BEGIN
      WRITELN ('FMOpen');
   END; {if}

   fmDataName := 'FMDATA';
   OPEN_DATASEG (cError, fmDataName, cRefNumHeap, lFst, fmldsn);
   IF cError <> 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('FMOpen failed on OPEN_DATASEG Error #', cError:3);
      END; {if}
      EXIT (FMOpen);
   END
   ELSE BEGIN
      SETACCESS_DATASEG (cError, cRefNumHeap, FALSE);
      IF cError <> 0 THEN BEGIN
         IF fdebug40 THEN BEGIN
            WRITELN ('FMOpen failed on SETACCESS_DATASEG Error #', cError:3);
         END; {if}
         EXIT (FMOpen);
      END;
   END; {else}
END; {FMOpen}


{$S FMinit  }
{===============================================================================

#######> FMinit

        COMMENT:

===============================================================================}

PROCEDURE FMinit
   {VAR cError: TC};
CONST
   fmldsn = 16;
   MedCache = 60000;

VAR
   fmDataName: PathName;
   lFst,
   lLst: LONGINT;
   infoRec: dsinforec;
   swapMemNxt,
   diskMemNxt: TL;
   pFst,
   pLim: TP;
   ihrrec: TC;
   Leave_On,
   answer: Char;
   lfntid: TLfntid;
   dError: TC;
   FMResult: TPCharStyle;
   SetCheat: TSetCheat;
   lfCheat: TLfCheat;
   SaveDebug: TF;
   FontFamily: TC;
   The_Info: MInfo;

{===============================================================================

#######> InitLibrary

        COMMENT:

===============================================================================}

PROCEDURE InitLibrary
   (VAR cError: TC);
VAR
   i: TC;


{===============================================================================

#######> HashEntry

        COMMENT:

===============================================================================}

PROCEDURE HashEntry
     (    cError: TC;
          name: PathName;
          lStart,
          lNxt,
          MetWid_Start,
          MetWid_Nxt: TL);
VAR
    i,
    id,
    ifst,
    ihash: INTEGER;

BEGIN {HashEntry}
{$IFC fTraceFM} LogCall; {$ENDC}
    id := 0;
    FOR i := 1 TO LENGTH (name) DO BEGIN
        id := FMROR (id + ORD (name [i]));
    END; {for i}
    ifst := 0;
    cError := 0; {assume the best; should always work unless the font names change}
    ihash := HashOfId (id, htable, ifst);
    WITH htable^^ [ihash] DO BEGIN
        IF key <> 0 THEN BEGIN
           cError := fmErrorBase + 12;
           IF fdebug40 THEN BEGIN
              WRITELN ('Error in HashEntry in FontMgr.  ',
                       'Better get another key selecting procedure',
                       ' or change the font names!!   ',
                       'Error #: ', cError);
           END; {if}
           EXIT (HashEntry);
        END; {if}
        key := id;
        lFst := lStart;
        lLim := lNxt;
        MetWid_Fst := MetWid_Start;
        MetWid_Lim := MetWid_Nxt;
    END; {with htable^^ [ihash]}
    IF fdebug32 THEN BEGIN
       WRITELN ('HashEntry:   Pathname = ', name, '  ifst = ', ifst:1,
                '  ihash = ', ihash:1, '  id = ', id:1);
    END;
END; {HashEntry}



{===============================================================================

#######> OpenLib

        COMMENT:

===============================================================================}

PROCEDURE OpenLib
   (    fileName: PathName;
    VAR cError: TC);

VAR
   lactual: LONGINT;
   pFont: TP;
   fileInfo: fs_info;
   fprot: TF;

BEGIN {OpenLib}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug33 THEN BEGIN
      WRITELN ('OpenLib:   Pathname = ', filename);
   END;
   POPEN (cError, fileName, cRefnumLib, [dread, global_refnum], fprot);
   IF cError > 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('Error in OPEN(in OpenLib) of "', fileName, '"  Error #:', cError);
      END; {if}
      EXIT (OpenLib);
   END; {if}
   IF cError < 0 THEN BEGIN  {if we got a warning from the OPEN}
         INFO (cError, cRefnumLib, fileInfo);
         IF cError <> 0 THEN BEGIN
            IF fdebug40 THEN BEGIN
               WRITELN ('Error in INFO(in OpenLib).  Error #:', cError);
            END; {if}
            EXIT (OpenLib);
         END; {if}
      fileInfo.file_closed_by_OS := FALSE;
      fileInfo.file_left_open := FALSE;
      fileInfo.file_scavenged := FALSE;
      SET_FILE_INFO (cError, cRefnumLib, fileInfo);
   END;
END; {OpenLib}



{===============================================================================

#######> ReadName

        COMMENT:

===============================================================================}

PROCEDURE ReadName
    (VAR id: PathName);
VAR
   c,
   cError: INTEGER;
   lactual: TL;

BEGIN {ReadName}
{$IFC fTraceFM} LogCall; {$ENDC}
   READ_DATA   {read the length of the string}
      (cError, cRefNumLib, ORD (@id), 1, lactual, sequential, 0);
   c := ORD (id [0]);
   IF NOT ODD (c) THEN BEGIN  {make sure we read an integral # of words}
      c := c + 1;
   END;
   READ_DATA
      (cError, cRefNumLib, ORD (@id) + 1, c, lactual, sequential, 0);
END; {ReadName}



{===============================================================================

#######> FillLibTable

        COMMENT:

===============================================================================}

PROCEDURE FillLibTable
   (    cError: TC);
VAR
   i,
   cdirecEntrys,
   cdirecSize: TC;
   name: PathName;
   lFst,
   lLim,
   MetWid_Fst,
   MetWid_Lim,
   lactual: TL;

BEGIN {FillLibTable}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug35 THEN BEGIN
      WRITELN ('FillLibTable');
   END;
   READ_DATA
      (cError, cRefNumLib, ORD (@cdirecSize), 2, lactual, sequential, 0);
   odirec := (cdirecSize + 2) * 2; {position of start of first font -- in bytes}
   IF cError <> 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('Error in FillLibTable. READ_DATA Error #:', cError);
      END; {if}
      EXIT (FillLibTable);
   END; {if}
   READ_DATA
      (cError, cRefNumLib, ORD (@cdirecEntrys), 2, lactual, sequential, 0);
   IF fdebug35 THEN BEGIN
      WRITELN ('    requested direc size = ', cdirecSize:1,
               '    #entries: ', cdirecEntrys:1);
   END;
   FOR i := 1 TO cdirecEntrys DO BEGIN
      ReadName (name);
      READ_DATA
         (cError, cRefNumLib, ORD (@lFst), 4, lactual, sequential, 0);
      READ_DATA
         (cError, cRefNumLib, ORD (@lLim), 4, lactual, sequential, 0);
      READ_DATA
         (cError, cRefNumLib, ORD (@MetWid_Fst), 4, lactual, sequential, 0);
      READ_DATA
         (cError, cRefNumLib, ORD (@MetWid_Lim), 4, lactual, sequential, 0);
      IF fdebug38 THEN BEGIN
         WRITELN ('    HashName (', name, ', ', lFst:1, ', ', lLim:1, ', ',
                  MetWid_Fst:1, ', ', MetWid_Lim:1,  ')');
      END;

      {convert position parameters to byte quantities before entering in the table}
      HashEntry (cError, name, lFst * 2, lLim * 2, MetWid_Fst * 2, MetWid_Lim * 2);
      IF cError <> 0 THEN BEGIN
         IF fdebug40 THEN BEGIN
            WRITELN ('Error in FillLibTable. HashEntry Error #: ', cError);
         END; {if}
         EXIT (FillLibTable);
      END; {if}

   END; {for}
END; {FillLibTable}


{*******************************************************************************}

BEGIN {InitLibrary}
{$IFC fTraceFM} LogCall; {$ENDC}
   {Initialize the library hash table}
   htable := POINTER (ORD (HAllocate (hzFM, SIZEOF (TTable))));
   FOR i := 1 TO tableSize DO BEGIN
      htable^^ [i].key := 0;
   END; {for i}
   OpenLib ('-#boot-FONT.LIB', cError);
   IF cError <= 0 THEN BEGIN
      FillLibTable (cError);
   END;
END; {InitLibrary}



{===============================================================================

#######> ReadHeuristics

        COMMENT: To initialize the FM internal heuristics with the values
                 stored in a file.

===============================================================================}

PROCEDURE ReadHeuristics;

CONST
   bufMax = 1536;

VAR
   str30T: TStr30;
   fileb: FILE;
   i,
   b,
   bch,
   bFaceRecs,
   bheurrec,
   bheurMax,
   ihrrec: TB;
   ibuf:TC;
   ewhcl: TEwhcl;
   eskcl: TEskcl;
   eface: StyleItem;
   hfcRecT: THfaceRec;
   pseteface: ^Style;
   psetedev: ^TSetedev;
   rgbbuf: ARRAY [0..bufMax] OF TB;



{===============================================================================

#######> GetFile

        COMMENT:

===============================================================================}

PROCEDURE GetFile
   (    fileName: PathName;
    VAR cError: TC);

VAR
   cRefNum,
   cErrT: TC;
   lactual: LONGINT;
   fileInfo: fs_info;
   pFont: TP;
   fprot: TF;

BEGIN {GetFile}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug37 THEN BEGIN
      WRITELN ('GetFile:   Pathname = ', filename);
   END;
   POPEN (cError, fileName, cRefNum, [dread], fprot);
   IF cError > 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('Error in OPEN(in GetFile) of "', fileName, '"  Error #:',
                  cError);
      END; {if}
      EXIT (GetFile);
   END; {if}
   INFO (cErrT, cRefNum, fileInfo);
   IF cErrT <> 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('Error in INFO(in GetFile).  Error #:', cErrT);
      END; {if}
      cError := cErrT;
      EXIT (GetFile);
   END; {if}
   IF cError < 0 THEN BEGIN  {if we got a warning from the OPEN}
      fileInfo.file_closed_by_OS := FALSE;
      fileInfo.file_left_open := FALSE;
      fileInfo.file_scavenged := FALSE;
      SET_FILE_INFO (cError, cRefNum, fileInfo);
   END;

   READ_DATA (cError, cRefNum, ORD (@rgbbuf), fileInfo.size, lactual,
             sequential, 0);
   IF cError <> 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('Error in Read_Data(in GetFile). Error #:', cError);
      END; {if}
      EXIT (GetFile);
   END; {if}
   CLOSE_OBJECT (cError, cRefNum);
   IF cError <> 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('Error in CLOSE_OBJECT(in GetFile). Error #:', cError);
      END; {if}
   END; {if}
   IF fdebug37 THEN BEGIN
      WRITELN  ('Exiting GetFile    lactual: ', lactual);
   END; {if}
END; {GetFile}



{*******************************************************************************}

BEGIN {ReadHeuristics}
{$IFC fTraceFM} LogCall; {$ENDC}
   IF fdebug36 THEN BEGIN
      WRITELN ('ReadHeuristics');
   END; {if}
   GetFile ('FONT.HEUR', cError);
   IF cError <> 0 THEN BEGIN
      EXIT (ReadHeuristics);
   END; {if}
   ibuf := 0;
   bheurMax := rgbbuf [ibuf];   {get the # of entries in the heur table}
   ibuf := ibuf + 1;
   IF fdebug36 THEN BEGIN
      WRITELN ('   bheurMax(in ReadHeuristics): ', bheurMax);
   END; {if}
   FOR bheurrec := 1 TO bheurMax DO BEGIN
      ihrrec := rgbbuf [ibuf];  {Read in which family}
      ibuf := ibuf + 1;
      IF fdebug39 THEN BEGIN
         WRITELN ('   ihrrec(in ReadHeuristics): ', ihrrec);
      END; {if}

      FOR ewhcl := ewhcl20 TO ewhclLCS DO BEGIN
         WITH hrgheurrec^^ [ihrrec] DO BEGIN
            mpewhclfam [ewhcl] := rgbbuf [ibuf];
            ibuf := ibuf + 1;
         END; {with hrgheurrec^^ [ihrrec]}
      END; {for}
      IF fdebug39 THEN BEGIN
         WITH hrgheurrec^^ [ihrrec] DO BEGIN
            FOR ewhcl := ewhcl20 TO ewhclLCS DO BEGIN
               WRITELN ('mpewhclfam [', ORD (ewhcl):1, ']: ', mpewhclfam [ewhcl]);
            END; {for}
         END; {with hrgheurrec^^ [ihrrec]}
      END; {if}

      bFaceRecs := rgbbuf [ibuf];  {Read in # face recs}
      ibuf := ibuf + 1;
      IF fdebug39 THEN BEGIN
         WRITELN ('bFaceRecs: ', bFaceRecs);
      END; {if}
      FOR b := 1 TO bFaceRecs DO BEGIN
         hfcRecT := POINTER (ORD (HAllocate (hzFM, SIZEOF (TFaceRec))));
         WITH hfcRecT^^ DO BEGIN {The above might invalidate our handle}
            WITH hrgheurrec^^ [ihrrec] DO BEGIN
               hfcRecNxt := hfaceRec; {Add new face record to list}
               hfaceRec := hfcRecT;
            END; {with hrgheurrec^^ [ihrrec]}

            i := rgbbuf [ibuf];{Get the set of allowable faces}
            ibuf := ibuf + 1;
            pseteface := @i;
            seteface := pseteface^;

            mpefaceb [Bold] := rgbbuf [ibuf];
            ibuf := ibuf + 1;
            mpefaceb [Italic] := rgbbuf [ibuf];
            ibuf := ibuf + 1;
            mpefaceb [UnderLine] := rgbbuf [ibuf];
            ibuf := ibuf + 1;
            mpefaceb [Outline] := rgbbuf [ibuf];
            ibuf := ibuf + 1;
            mpefaceb [Shadow] := rgbbuf [ibuf];
            ibuf := ibuf + 1;
            IF fdebug39 THEN BEGIN
                WRITELN ('In ReadHeuristics:   Bold: ', mpefaceb [Bold],
                         'Italic: ', mpefaceb [Italic],
                         'UnderLine: ', mpefaceb [UnderLine],
                         'Outline: ', mpefaceb [Outline],
                         'Shadow: ', mpefaceb [Shadow]);
            END; {if}

            i := rgbbuf [ibuf];  {Get the extra width}
            ibuf := ibuf + 1;
            cXtra := i;
            IF fdebug39 THEN BEGIN
                WRITELN ('In ReadHeuristics:   cXtra: ', cXtra);
            END; {if}

            i := rgbbuf [ibuf];  {Get the device set}
            ibuf := ibuf + 1;
            psetedev := @i;
            setedev := psetedev^;
            IF fdebug39 THEN BEGIN
                WRITELN ('In ReadHeuristics:   setedev: ', i);
            END; {if}

            bch := rgbbuf [ibuf];  {Get the root name}
            ibuf := ibuf + 1;
            str30Root [0] := CHR (bch);
            FOR i := 1 TO bch DO BEGIN
               str30Root [i] := CHR (rgbbuf [ibuf]);
               ibuf := ibuf + 1;
            END; {for}
            IF fdebug39 THEN BEGIN
               WRITELN ('In ReadHeuristics:   str30Root: "', str30Root, '"');
            END; {if}
         END; {with hfcRecT}
      END; {for # faceRecs}
   END; {for # heuristic entries}

   FOR eskcl := eskclMPPS TO eskclPQume DO BEGIN               {jwp 3/16/83}
      bch := rgbbuf [ibuf];  {Get the spoke table root name}
      ibuf := ibuf + 1;
      hmpeskclstr30^^ [eskcl][0] := CHR (bch);
      FOR i := 1 TO bch DO BEGIN
         hmpeskclstr30^^ [eskcl][i] := CHR (rgbbuf [ibuf]);
         ibuf := ibuf + 1;
      END; {for}
      IF fdebug39 THEN BEGIN
         WRITELN ('In ReadHeuristics:   hmpeskclstr30^^ [', ORD (eskcl):1, ']: "',
                   hmpeskclstr30^^ [eskcl], '"');
      END; {if}
   END; {for each spoke table name}
END; {ReadHeuristics}



{*******************************************************************************}

BEGIN  {FMinit}
{$IFC fTraceFM} LogCall; {$ENDC}
{$IFC fmdebug}
   fdebug   := TRUE;   {Who knows what it is for}
   fdebug1  := FALSE;   {Debug flag for module Setting new cache size}
   fdebug2  := TRUE;    {Debug flag for module change cache size dynamically}
   fdebug3  := TRUE;    {Debug flag for module FMLockFont}
   fdebug4  := TRUE;    {Debug flag for module FMCbOfN}
   fdebug5  := TRUE;    {Debug flag for test driver for FMSwapFont}
   fdebug6  := TRUE;    {Debug flag for module FMSwapNIn}
   fdebug7  := TRUE;    {Debug flag for module AssignDevice}
   fdebug8  := TRUE;    {Debug flag for module SpokeName}
   fdebug9  := TRUE;    {Debug flag for module NToFileName}
   fdebug10 := TRUE;    {Debug flag for module ReadFont}
   fdebug11 := TRUE;    {Debug flag for module changing to High Res}
   fdebug12 := TRUE;    {Debug flag for module LocateFont}
   fdebug13 := TRUE;    {Debug flag for module ZZOpenfont}
   fdebug14 := TRUE;    {Debug flag for module ReadMetricsWidths}
   fdebug15 := TRUE;    {Debug flag for module FMSwapOutN}
   fdebug16 := TRUE;    {Debug flag for module FMMapFont}
   fdebug17 := TRUE;    {Debug flag for module FMSwapFont}
   fdebug18 := TRUE;    {Debug flag for module NToName}
   fdebug19 := TRUE;    {Debug flag for module EvalEntry}
   fdebug20 := TRUE;    {Debug flag for module CheckChs}
   fdebug21 := TRUE;    {Debug flag for module EvalSpoke}
   fdebug22 := TRUE;    {Debug flag for module LastDitchOk}
   fdebug23 := TRUE;    {Debug flag for module FMFontMetrics}
   fdebug24 := TRUE;    {Debug flag for module FMFontWidths}
   fdebug25 := TRUE;    {Debug flag for module FMCacheSize}
   fdebug26 := TRUE;    {Debug flag for module FMAddFont}
   fdebug27 := TRUE;    {Debug flag for module FMDelFont}
   fdebug28 := TRUE;    {Debug flag for module FMCloseFont}
   fdebug29 := TRUE;    {Debug flag for module FMOpen}
   fdebug30 := TRUE;    {Debug flag for module FMInit}
   fdebug31 := TRUE;    {Debug flag for changing to typer font}
   fdebug32 := TRUE;    {Debug flag for module HashEntry}
   fdebug33 := TRUE;    {Debug flag for module OpenLib}
   fdebug34 := TRUE;    {Debug flag for dump heuristics table}
   fdebug35 := TRUE;    {Debug flag for module FillLibTable}
   fdebug36 := TRUE;    {Debug flag for module ReadHeuristics}
   fdebug37 := TRUE;    {Debug flag for module GetFile}
   fdebug38 := FALSE;   {Debug flag for hash table in module FillLibTable}
   fdebug39 := FALSE;   {Debug flag for table in module ReadHeuristics}
   fdebug40 := TRUE;    {Debug flag for errors}
{$ENDC}

{$IFC fmdebug}
   IF fdebug THEN BEGIN
      WRITE('Leave Font Manager debugging printout on(Yes, No, Selective)? ');
      READLN(Leave_On);
      IF (Leave_On = 'n') OR (Leave_On = 'N') THEN BEGIN
         fdebug   := FALSE;    {Global(basically error) debug flag}
         fdebug1  := FALSE;    {Debug flag for Want to change cache size}
         fdebug2  := FALSE;    {Debug flag for module change cache size dynamically}
         fdebug3  := FALSE;    {Debug flag for module FMLockFont}
         fdebug4  := FALSE;    {Debug flag for module FMCbOfN}
         fdebug5  := FALSE;    {Debug flag for test driver for FMSwapFont}
         fdebug6  := FALSE;    {Debug flag for module FMSwapNIn}
         fdebug7  := FALSE;    {Debug flag for module AssignDevice}
         fdebug8  := FALSE;    {Debug flag for module SpokeName}
         fdebug9  := FALSE;    {Debug flag for module NToFileName}
         fdebug10 := FALSE;    {Debug flag for module ReadFont}
         fdebug11 := FALSE;    {Debug flag for module changing to High Res}
         fdebug12 := FALSE;    {Debug flag for module LocateFont}
         fdebug13 := FALSE;    {Debug flag for module ZZOpenfont}
         fdebug14 := FALSE;    {Debug flag for module ReadMetricsWidths}
         fdebug15 := FALSE;    {Debug flag for module FMSwapOutN}
         fdebug16 := FALSE;    {Debug flag for module FMMapFont}
         fdebug17 := FALSE;    {Debug flag for module FMSwapFont}
         fdebug18 := FALSE;    {Debug flag for module NToName}
         fdebug19 := FALSE;    {Debug flag for module EvalEntry}
         fdebug20 := FALSE;    {Debug flag for module CheckChs}
         fdebug21 := FALSE;    {Debug flag for module EvalSpoke}
         fdebug22 := FALSE;    {Debug flag for module LastDitchOk}
         fdebug23 := FALSE;    {Debug flag for module FMFontMetrics}
         fdebug24 := FALSE;    {Debug flag for module FMFontWidths}
         fdebug25 := FALSE;    {Debug flag for module FMCacheSize}
         fdebug26 := FALSE;    {Debug flag for module FMAddFont}
         fdebug27 := FALSE;    {Debug flag for module FMDelFont}
         fdebug28 := FALSE;    {Debug flag for module FMCloseFont}
         fdebug29 := FALSE;    {Debug flag for module FMOpen}
         fdebug30 := FALSE;    {Debug flag for module FMInit}
         fdebug31 := FALSE;    {Debug flag for module changing to typer font}
         fdebug32 := FALSE;    {Debug flag for module HashEntry}
         fdebug33 := FALSE;    {Debug flag for module OpenLib}
         fdebug34 := FALSE;    {Debug flag for dump heuristics table}
         fdebug35 := FALSE;    {Debug flag for module FillLibTable}
         fdebug36 := FALSE;    {Debug flag for module ReadHeuristics}
         fdebug37 := FALSE;    {Debug flag for module GetFile}
         fdebug38 := FALSE;    {Debug flag for hash table in module FillLibTable}
         fdebug39 := FALSE;    {Debug flag for table in module ReadHeuristics}
         fdebug40 := FALSE;    {Debug flag for errors}
      END {if}
      ELSE BEGIN
             IF (Leave_On = 's') OR (Leave_On = 'S') THEN BEGIN
                WRITE('Change 1st Cache Size: ');
                READLN(answer);
                fdebug1   := (answer = 'y') OR (answer = 'Y');
                WRITE('Change Cache Size Dynamically: ');
                READLN(answer);
                fdebug2  := (answer = 'y') OR (answer = 'Y');
                IF fdebug2 THEN BEGIN
                  WRITE('   Interval: ');
                  READLN(ChangeInterval);
                END; {if}
                WRITE('FMCacheSize: ');
                READLN(answer);
                fdebug25 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMSwapNIn: ');
                READLN(answer);
                fdebug6  := (answer = 'y') OR (answer = 'Y');
                WRITE('FMSwapOutN: ');
                READLN(answer);
                fdebug15 := (answer = 'y') OR (answer = 'Y');
                WRITE('Change to Hi Res: ');
                READLN(answer);
                fdebug11 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMFontMetrics: ');
                READLN(answer);
                fdebug23 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMFontWidths: ');
                READLN(answer);
                fdebug24 := (answer = 'y') OR (answer = 'Y');
                WRITE('Changing to typer font: ');
                READLN(answer);
                fdebug31 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMSwapFont: ');
                READLN(answer);
                fdebug5  := (answer = 'y') OR (answer = 'Y');
                WRITE('Test drive FMSwapFont: ');
                READLN(answer);
                fdebug17 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMLockFont: ');
                READLN(answer);
                fdebug3  := (answer = 'y') OR (answer = 'Y');
                WRITE('fdebug: ');
                READLN(answer);
                fdebug   := (answer = 'y') OR (answer = 'Y');
                WRITE('FMCbOfN: ');
                READLN(answer);
                fdebug4  := (answer = 'y') OR (answer = 'Y');
                WRITE('AssignDevice: ');
                READLN(answer);
                fdebug7  := (answer = 'y') OR (answer = 'Y');
                WRITE('SpokeName: ');
                READLN(answer);
                fdebug8  := (answer = 'y') OR (answer = 'Y');
                WRITE('NToFileName: ');
                READLN(answer);
                fdebug9  := (answer = 'y') OR (answer = 'Y');
                WRITE('ReadFont: ');
                READLN(answer);
                fdebug10 := (answer = 'y') OR (answer = 'Y');
                WRITE('LocateFont: ');
                READLN(answer);
                fdebug12 := (answer = 'y') OR (answer = 'Y');
                WRITE('ZZOpenFont: ');
                READLN(answer);
                fdebug13 := (answer = 'y') OR (answer = 'Y');
                WRITE('ReadMetricsWidths: ');
                READLN(answer);
                fdebug14 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMMapFont: ');
                READLN(answer);
                fdebug16 := (answer = 'y') OR (answer = 'Y');
                WRITE('NToName: ');
                READLN(answer);
                fdebug18 := (answer = 'y') OR (answer = 'Y');
                WRITE('EvalEntry: ');
                READLN(answer);
                fdebug19 := (answer = 'y') OR (answer = 'Y');
                WRITE('CheckChs: ');
                READLN(answer);
                fdebug20 := (answer = 'y') OR (answer = 'Y');
                WRITE('EvalSpoke: ');
                READLN(answer);
                fdebug21 := (answer = 'y') OR (answer = 'Y');
                WRITE('LastDitchOk: ');
                READLN(answer);
                fdebug22 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMAddFont: ');
                READLN(answer);
                fdebug16 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMDelFont: ');
                READLN(answer);
                fdebug27 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMCloseFont: ');
                READLN(answer);
                fdebug28 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMOpenFont: ');
                READLN(answer);
                fdebug29 := (answer = 'y') OR (answer = 'Y');
                WRITE('FMInit: ');
                READLN(answer);
                fdebug30 := (answer = 'y') OR (answer = 'Y');
                WRITE('HashEntry: ');
                READLN(answer);
                fdebug32 := (answer = 'y') OR (answer = 'Y');
                WRITE('OpenLib: ');
                READLN(answer);
                fdebug33 := (answer = 'y') OR (answer = 'Y');
                WRITE('Dump Heuristics Table: ');
                READLN(answer);
                fdebug34 := (answer = 'y') OR (answer = 'Y');
                WRITE('FillLibTable: ');
                READLN(answer);
                fdebug35 := (answer = 'y') OR (answer = 'Y');
                WRITE('ReadHeuristics: ');
                READLN(answer);
                fdebug36 := (answer = 'y') OR (answer = 'Y');
                WRITE('GetFile: ');
                READLN(answer);
                fdebug37 := (answer = 'y') OR (answer = 'Y');
                WRITE('Hash Table: ');
                READLN(answer);
                fdebug38 := (answer = 'y') OR (answer = 'Y');
                WRITE('Heuristics Table: ');
                READLN(answer);
                fdebug39 := (answer = 'y') OR (answer = 'Y');
             END; {if}
      END; {else}
   END; {if}

   IF fdebug30 THEN BEGIN
      WRITELN ('FMInit:   Here we go - Cross your fingers!',
               '  SIZEOF(TLfntid): ', SIZEOF(TLfntid));
   END; {if}
{$ENDC}

   Mach_Info(cError, The_Info);
   IF The_Info.memsize > 950000 THEN BEGIN {Full Meg so choose big buffers}
      InitialCacheSize := BigCache;
      MinCacheSize := BigCache;
   END
   ELSE IF The_Info.memsize > 750000 THEN BEGIN
           InitialCacheSize := MedCache; {3/4 Meg so use medium sized buffers}
           MinCacheSize := MedCache;
        END
        ELSE BEGIN {A little bitty 512K machine so use tiny buffers}
           InitialCacheSize := LowCache;
           MinCacheSize := LowCache;
        END;

   NeedTheBits := TRUE;  {Initialization probably unnecessary}
   SwapINCount := 0;
   SwapOutCount := 0;
   SwapFontCount := 0;
   MetricsCount := 0;
   nPrv := -1;          {Arbitrary initial value for nPrv}
   cErrorG := 0;
   WITH sysLfntid DO BEGIN
      fam := systext;
      seteface := [];
      dev := devScreen;
   END; {with sysLfntid}

   fmDataName := 'FMDATA';
   MAKE_DATASEG (cError, fmDataName, InitialCacheSize, 0,
                 cRefNumHeap, lFst, fmldsn, ds_shared);
   IF cError = AlreadyExists THEN BEGIN
      KILL_DATASEG (cError, fmDataName);
      IF cError <> 0 THEN BEGIN
         IF fdebug40 THEN BEGIN
            WRITELN ('****Error in Kill_DataSeg in FMInit.   Error # ', cError);
         END; {if}
         EXIT (FMInit);
      END; {if}
      MAKE_DATASEG (cError, fmDataName, InitialCacheSize, 0,
                    cRefNumHeap, lFst, fmldsn, ds_shared);
      IF cError <> 0 THEN BEGIN
         IF fdebug40 THEN BEGIN
            WRITELN ('****Error in Make_DataSeg(after Kill) in FMInit.   Error # ',
                     cError);
         END; {if}
         EXIT (FMInit);
      END; {if}
   END {if}
   ELSE BEGIN
      IF cError <> 0 THEN BEGIN
         IF fdebug40 THEN BEGIN
            WRITELN ('****Error in Make_DataSeg in FMInit.   Error # ', cError);
         END; {if}
         EXIT (FMInit);
      END; {if}
   END; {if}

   pFst := POINTER (lFst);
   pLim := POINTER (lFst + InitialCacheSize);
   hzFM := HzInit (pFst, pLim, NIL, pPoolSize, hashSize,
                   POINTER(procNil), @FMCbOfN, @FMSwapNIn, @FMSwapOutN);
   lmemSize := InitialCacheSize;
   IF fdebug30 THEN BEGIN
      WRITELN ('In FMInit:   Initial cbFree: ', hzFM^.cbFree);
   END; {if}

   {Initialize the heuristic table}
   hmpeskclstr30 := POINTER (ORD (HAllocate (hzFM, SIZEOF (TMpeskclstr30))));
   hrgheurrec := POINTER (ORD (HAllocate (hzFM, SIZEOF (TRgheurrec))));
   FOR ihrrec := 0 TO heurTableSize DO BEGIN
      WITH hrgheurrec^^ [ihrrec] DO BEGIN
         hfacerec := NIL;
         fuser := FALSE;
      END; {with hrgheurrec^^ [ihrrec]}
   END; {for}
   ReadHeuristics; {Read in the heuristic table for N to Name mapping}

   InitLibrary(cError);
   IF cError <> 0 THEN BEGIN
      IF fdebug40 THEN BEGIN
         WRITELN ('****Error in InitLibrary in FMInit.   Error # ', cError);
      END; {if}
      EXIT (FMInit);
   END; {if}

{$IFC fmdebug}
   IF fdebug1 THEN BEGIN
      WRITELN;
      WRITE('Cache Size Desired ? ');
      READLN(InitialCacheSize);
      FMCacheSize(InitialCacheSize, cError);
   END; {if}

   IF fdebug5 THEN BEGIN
      SaveDebug := fdebug17;
      fdebug17 := TRUE;
      WRITE('lfntid.fam: ');
      READLN(FontFamily);
      lfntid.fam := FontFamily;
      WHILE lfntid.fam >= 0 DO BEGIN
         WRITE('lfntid.seteface: ');
         READLN(setCheat.bex);
         lfntid.seteface := setCheat.seteface;
         WRITE('OnlyMetricsWidths: ');
         READLN(answer);
         IF (answer = 'y') OR (answer = 'Y') THEN
            lfntid.seteface := lfntid.seteface + [OnlyMetricsWidsths];
         lfntid.fOffline := FALSE;
         WRITE('lfntid.edev: ');
         READLN(answer);
         CASE answer OF
            's', 'S':   lfntid.edev := edevScreen;
            'l', 'L':   lfntid.edev := edevLaser;
            'd', 'D':   lfntid.edev := edevDotMx;
            'h', 'H':   lfntid.edev := edevHDotMx;
            't', 'T':   lfntid.edev := edevTyper;
            OTHERWISE   lfntid.edev := edevScreen;
         END; {case}
         lfCheat.lfntid := lfntid;
         WRITELN('lfntid = ', lfCheat.n);
         WRITELN;
         FMResult := FMSwapFont(lfntid, dError);
         WRITE('lfntid.fam: ');
         READLN(FontFamily);
         lfntid.fam := FontFamily;
      END; {while}
      fdebug17 := SaveDebug;
   END; {if}
   IF fdebug34 THEN BEGIN
      FMDumpHeurTable;
   END; {if}

   IF fdebug30 THEN BEGIN
      WRITELN ('In FMInit:   cbFree after tables: ', hzFM^.cbFree);
   END; {if}
{$ENDC}

END;{FMinit}


END.
