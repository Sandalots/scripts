{                Copyright 1984, Apple Computer Inc.                     }
UNIT CNDlg;
     {code to support dialogs in Canon background printer process}

INTERFACE
USES {$U LibOS/SysCall}            SysCall,
     {$U LibPM/PMDecl}             PMDecl,
     {$U LibSM/UnitStd}            UnitStd,
     {$U LibSM/UnitHz}             UnitHz,
     {$U LibQD/QuickDraw}          QuickDraw,
     {$U LibFM/FontMgr}            FontMgr,
     {$U LibQD/Storage}            Storage,
     {$U LibWM/Events}             Events,
     {$U LibHW/Hwint}              Hwint,
     {$U LibWM/Menus}              Menus,
     {$U LibWM/Windows}            Windows,
     {$U LibWM/Folders}            Folders,
     {$U libSB/WmlStd}             WmlStd,
     {$U libSB/WmlCrs}             WmlCrs,
     {$U LibAM/AlertMgr}           AlertMgr,
     {$U LibPr/PrStdInfo}          PrStdInfo,
     {$U LibPr/PrStdProcs}         PrStdProcs,
     {$U LibPr/Queues}             Queues,
     {$U LibPr/PrEvents}           PrEvents,
     {$U LibPr/PrDlgMgr}           PrDlgMgr,
     {$U LibPr/PrMgr}              PrMgr,
     {$U-}
     {$U LibPr/CNGlobals}          CNGlobals,
     {$U LibPr/CNStdQdProcs}       CNStdQdProcs,
     {$U LibPr/CNProcs}            CNProcs;

     {$SETC SpSize = TRUE}

{ ---------------------------------------------------------------------- }

VAR
   DDSRefNum:       TC;            {!BH 5/4/84 change to bind and unbind dialog dataseg}

{ ---------------------------------------------------------------------- }

FUNCTION CNDlgInit: TF;                                {!DC 4/10/84}
FUNCTION FFmtDlg (VAR prRec: TprRec; VAR fNewStl: TF;
                 maxHt, maxWid, minHt, minWid: TC;
                 fSpecSizeSuppress: TF): DlgOption;
FUNCTION FInsDlg (VAR prRec: TprRec; VAR fNewStl: TF; dlgMode: PrMenuSuppress): DlgOption;

{ ---------------------------------------------------------------------- }

IMPLEMENTATION
{$R-}
{$IFC fSymOK} {$D+} {$ELSEC} {$D-} {$ENDC}

CONST
  DSSegname = 'CNBtnData';
  DSLDSN = 9;

  {The menu and button indices.}
  muDoIt     = 0;                      {This mu serves for both dlgs}
    iDoItYes      = 0;  {"OK" btn}
    iDoItNo       = 1;  {"Cancel" btn}
    iNewPr        = 2;  {"New Printer" btn}
    iPortMsg      = 4;  {port information message}

{Menus for the Format... dialog}

  muPSize    = 1;
   {Button indices from PrStdInfo:
    iPg8x11 = 1; iPg8x14   = 2; iPg14x11  = 3;
    iPgA4   = 4; iPg210x12 = 5; iPg310x8  = 6;
    iPgSpec = 7;
    iPgFst = 0; iPgMax = 15;}

    iPgLst = 5;

  muOrient   = 2;
    iPOrLTitle  = 0;    {"Paper/Printing Orientation" title}
    iPOnlyTitle = 5;    {"Printing Orientation" title}
    PapPImNR = 1;       {Portrait paper loading, image Not Rotated (icon btn)}
    PapPImR  = 2;       {Portrait paper loading, image Rotated (icon btn)}
    PapLImNR = 3;       {Landscape paper loading, image Not Rotated (icon btn)}
    PapLImR  = 4;       {Landscape paper loading, image Rotated (icon btn)}

  muFeeder = 3;
    iRoll = 1; iSingleSheet = 2;

{$IFC SpSize}
  muSpecSize = 4;
    iWidInch = 2; iWid16th = 4; iWidmm = 7;
    iHtInch  =10; iHt16th  =12; iHtmm  =15;
    maxWidTitle = 17; maxHtTitle = 18;
    minWidTitle = 19; minHtTitle = 20;
{$ENDC}

{Menus for the Print... dialog}

  muDraft = 1;
    iFinished = 0; iDraft = 1;

  muCopies = 2;
    {in this menu the number of copies selected = the btn number}

  muPgSelect = 3;
    iAllPgs = 1; iSomePgs = 2; iFirstPg = 3; iLastPg = 5;

TYPE
    TBtnSet  = SET OF 0..cBtnMax;
    THtOrWid = (ht, wid);

VAR
   hckfmFmt:        THckfm;   {The FFmtDlg ckfm}
   hckfmIns:        THckfm;   {The FInsDlg ckfm}
   rgPaperWid:      ARRAY[iPgFst..iPgMax] OF TL;  {Paper widths in prPgFract units}
   rgPaperHt:       ARRAY[iPgFst..iPgMax] OF TL;  {Paper heights in prPgFract units}
   platenWidth:     TL;                           {Platen width in prPgFract units}
 {$IFC SpSize}
   maxHt16,
   maxWid16,
   maxHtMm,
   maxWidMm,
   minHt16,
   minWid16,
   minHtMm,
   minWidMm:        TL;                           {Limits for special paper sizes}
 {$ENDC}
   validPSize:      SET OF iPgFst..iPgMax;
   savePort:        GrafPtr;
   dlgPort:         GrafPort;
 {$IFC SpSize}
   verifySpecSize:  TF;            {!DC 3/16/84 special size changed, not yet verified, & is selected}
 {$ENDC}
   oldSize:         TC;            {!DC 3/16/84 previously selected paper size btn}

{ -------------------------DIRECTORY------------------------------------ }

{Miscellaneous}
FUNCTION  Minimum (x, y: TL): TC;                                FORWARD;
FUNCTION  Maximum (x, y: TL): TC;                                FORWARD;

{The Format for Printer... dialog}
     {Dealing with special sizes}
{$IFC SpSize}
PROCEDURE FitSpecSize (VAR fNewWid, fNewHt: TF);                 FORWARD;
FUNCTION  Spec (hw: THtOrWid):  TL;                              FORWARD;
PROCEDURE SpecGet (hw: THtOrWid);                                FORWARD;
PROCEDURE SpecIndices (hw: THtOrWid; VAR iInch, i16th, iMm: TC); FORWARD;
PROCEDURE SpecLimits (maxHt, maxWid, minHt, minWid: TL);         FORWARD;
PROCEDURE SpecRedraw (hw: THtOrWid);                             FORWARD;
PROCEDURE SpecSet (hw: THtOrWid; inch, in16, mm: TSp);           FORWARD;
FUNCTION  SpecUnDef (hw: THtOrWid): TF;                          FORWARD;
PROCEDURE StuffSpecSize;                                         FORWARD;
{$ENDC}
     {Dealing with orientation menu}
FUNCTION  SetIcons (dlgStarting: TF): TF;                        FORWARD;  {!DC 3/16/84}
     {Initializing the dialog instance}
PROCEDURE FmtSetUp (pPrRecIn: TPprRec; fSpecSizeSuppress: TF);   FORWARD;
PROCEDURE FmtCkSet;                                              FORWARD;
     {Fixing up the port message button}
     {Bottleneck Procs for PrDlgMgr}
PROCEDURE FmtCkCmd (iMu, iBtn: TC);                              FORWARD;
PROCEDURE FmtEnd (fDismiss: TF);                                 FORWARD;

{The Print... dialog}
     {Initializing the dialog instance}
PROCEDURE InsSetUp (pPrRecIn: TPprRec; dlgMode: prMenuSuppress); FORWARD;
PROCEDURE InsCkSet;                                              FORWARD;
     {Bottleneck Procs for PrDlgMgr}
PROCEDURE InsCkCmd (iMu, iBtn: TC);                              FORWARD;
PROCEDURE InsEnd (fDismiss: TF);                                 FORWARD;

{ ---------------------------------------------------------------------- }

FUNCTION Minimum {x, y: TL): TC};
VAR c: TL;
BEGIN
  IF x > y THEN c := y ELSE c := x;
  Minimum := c;
END;

{ ---------------------------------------------------------------------- }

FUNCTION Maximum {x, y: TL): TC};
VAR c: TL;
BEGIN
  IF x > y THEN c := x ELSE c := y;
  Maximum := c;
END;

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
PROCEDURE FitSpecSize {VAR fNewWid, fNewHt: TF};
  {Guarantees that the ckfm's special-size width & height don't exceed limits.  For
  each dimension, returns a flag TRUE if it made a change.  Also does mod 16 stuff in the
  inches & 16ths buttons.}
VAR spIn, sp16, spMm:         TSP;
    cIn, c16, cMm:            TC;
    c16Total:                 TL;
    hmu:                      THmu;
    htIsInches, widIsInches:  TF;
    hsp:                      THSp;

  PROCEDURE SpecRead (hw: THtOrWid); {local}
  VAR iInch, i16th, iMm, c: TC;
  BEGIN
    WITH hCkfmFmt^^, rghmu[muSpecSize]^^ DO BEGIN
      SpecIndices(hw, iInch, i16th, iMm);
      hsp := rgbtn[iInch].hsp; spIn := COPY (hsp^^, 1, ORD(hsp^^[0]));
      hsp := rgbtn[i16th].hsp; sp16 := COPY (hsp^^, 1, ORD(hsp^^[0]));
      PrStrToNum(spIn, cIn); PrStrToNum(sp16, c16);
      c16Total := (ORD4(cIn) * 16) + c16;
      hsp := rgbtn[iMm].hsp; spMm := COPY (hsp^^, 1, ORD(hsp^^[0]));
      PrStrToNum(spMm, cMm);
    END;
  END;

  PROCEDURE Mod16 (hw: THtOrWid); {local}
  VAR iInch, i16th, iMm, c: TC;
  BEGIN
    WITH hCkfmFmt^^, rghmu[muSpecSize]^^ DO BEGIN
      SpecRead(hw);
      IF c16 > 15 THEN BEGIN                           {do mod 16 stuff}
        cIn := cIn + c16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := c16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(hw, spIn, sp16, '');
        SpecRedraw(hw);
      END;
    END;
  END;

BEGIN
WITH hCkfmFmt^^, rghmu[muSpecSize]^^ DO IF fMUActv THEN BEGIN
  fNewWid := FALSE; fNewHt := FALSE;
  hmu := rghmu[muSpecSize];
  widIsInches := rgbtn[iWidmm].hsp^^[0] = CHR(0);
  htIsInches  := rgbtn[iHtmm].hsp^^[0] = CHR(0);

  {deal with width}
  SpecRead(wid);

  {make width <= upper limit}
  IF widIsInches THEN BEGIN
    IF c16Total >= maxWid16 THEN BEGIN
      BtnVanish(hmu, minWidTitle); BtnReappear(hmu, maxWidTitle);
      IF c16Total > maxWid16 THEN BEGIN
        cIn := maxWid16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := maxWid16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(wid, spIn, sp16, '');
        fNewWid := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, maxWidTitle);
  END
  ELSE BEGIN
    IF cMm >= maxWidMm THEN BEGIN
      BtnVanish(hmu, minWidTitle); BtnReappear(hmu, maxWidTitle);
      IF cMm > maxWidMm THEN BEGIN
        cMm := maxWidMm;
        PrNumToStr(cMm, spMm);
        SpecSet(wid, '', '', spMm);
        fNewWid := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, maxWidTitle);
  END;

  {make width >= lower limit}
  IF widIsInches THEN BEGIN
    IF c16Total <= minWid16 THEN BEGIN
      BtnVanish(hmu, maxWidTitle); BtnReappear(hmu, minWidTitle);
      IF c16Total < minWid16 THEN BEGIN
        cIn := minWid16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := minWid16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(wid, spIn, sp16, '');
        fNewWid := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, minWidTitle);
  END
  ELSE BEGIN
    IF cMm <= minWidMm THEN BEGIN
      BtnVanish(hmu, maxWidTitle); BtnReappear(hmu, minWidTitle);
      IF cMm < minWidMm THEN BEGIN
        cMm := minWidMm;
        PrNumToStr(cMm, spMm);
        SpecSet(wid, '', '', spMm);
        fNewWid := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, minWidTitle);
  END;

  {deal with height}
  SpecRead(ht);

  {make height <= upper limit}
  IF htIsInches THEN BEGIN
    IF c16Total >= maxHt16 THEN BEGIN
      BtnVanish(hmu, minHtTitle); BtnReappear(hmu, maxHtTitle);
      IF c16Total > maxHt16 THEN BEGIN
        cIn := maxHt16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := maxHt16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(ht, spIn, sp16, '');
        fNewHt := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, maxHtTitle);
  END
  ELSE BEGIN
    IF cMm >= maxHtMm THEN BEGIN
      BtnVanish(hmu, minHtTitle); BtnReappear(hmu, maxHtTitle);
      IF cMm > maxHtMm THEN BEGIN
        cMm := maxHtMm;
        PrNumToStr(cMm, spMm);
        SpecSet(ht, '', '', spMm);
        fNewHt := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, maxHtTitle);
  END;

  {make height >= lower limit}
  IF htIsInches THEN BEGIN
    IF c16Total <= minHt16 THEN BEGIN
      BtnVanish(hmu, maxHtTitle); BtnReappear(hmu, minHtTitle);
      IF c16Total < minHt16 THEN BEGIN
        cIn := minHt16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := minHt16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(ht, spIn, sp16, '');
        fNewHt := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, minHtTitle);
  END
  ELSE BEGIN
    IF cMm <= minHtMm THEN BEGIN
      BtnVanish(hmu, maxHtTitle); BtnReappear(hmu, minHtTitle);
      IF cMm < minHtMm THEN BEGIN
        cMm := minHtMm;
        PrNumToStr(cMm, spMm);
        SpecSet(ht, '', '', spMm);
        fNewHt := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, minHtTitle);
  END;

  IF NOT fNewWid THEN IF widIsInches THEN Mod16(wid);
  IF NOT fNewHt  THEN IF htIsInches  THEN Mod16(ht);
END;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
FUNCTION Spec {hw: THtOrWid):  TL};
  {Current special-size height/width in prPgFract units, from the ckfm's strings}
VAR iInch, i16th, iMm, c:     TC;
    inches, in16ths, mm:      TL;
    sp:                       TSp;
    hsp:                      THSp;
BEGIN
WITH hCkfmFmt^^.rghmu[muSpecSize]^^ DO BEGIN
  SpecIndices(hw, iInch, i16th, iMm);   {select height or width}

  hsp := rgbtn[iInch].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, c);
  inches := ORD4(c) * PrPgFract;

  hsp := rgbtn[i16th].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, c);
  in16ths := (ORD4(c) * PrPgFract) DIV 16;

  hsp := rgbtn[iMm].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, c);
  mm := (ORD4(c) * PrPgFract * 10) DIV 254;

  Spec := (inches + in16ths + mm);
END;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
PROCEDURE SpecGet {hw: THtOrWid};
  {Sets the strings of the special height/width buttons from the print record's dlgPgSz data.}
VAR spIn, sp16, spMm: TSp;
    recInch, rec16, recMm: TC;
BEGIN
WITH hckfmFmt^^.rghmu[muSpecSize]^^, pPrRecUsr^.prInfo.dlgPgSz DO BEGIN
  IF hw = ht
  THEN BEGIN recInch := htInch;  rec16 := ht16th;  recMm := htMM; END
  ELSE BEGIN recInch := widInch; rec16 := wid16th; recMm := widMM; END;
  PrNumToStr (ABS (recInch),  spIn);
  PrNumToStr (ABS (rec16),    sp16);
  PrNumToStr (ABS (recMm),    spMm);
  SpecSet(hw, spIn, sp16, spMm);
END;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
PROCEDURE SpecLimits {maxHt, maxWid, minHt, minWid: TL};
VAR halfFract: TC;
BEGIN
  halfFract := prPgFract DIV 2;
  IF maxHt  > MAXINT      THEN maxHt  := MAXINT;
  IF maxWid > platenWidth THEN maxWid := platenWidth;
  IF minHt  < prPgFract   THEN minHt  := prPgFract;
  IF minWid < prPgFract   THEN minWid := prPgFract;

  maxHt16 := (((maxHt*16)+halfFract) DIV prPgFract)+1;
  WHILE ((maxHt16*prPgFract) DIV 16)>maxHt DO maxHt16 := maxHt16-1;

  maxWid16 := (((maxWid*16)+halfFract) DIV prPgFract)+1;
  WHILE ((maxWid16*prPgFract) DIV 16)>maxWid DO maxWid16 := maxWid16-1;

  maxHtMm := (((((maxHt*254)+halfFract) DIV prPgFract)+5) DIV 10)+1;
  WHILE ((maxHtMm*prPgFract*10) DIV 254)>maxHt DO maxHtMm := maxHtMm-1;

  maxWidMm := (((((maxWid*254)+halfFract) DIV prPgFract)+5) DIV 10)+1;
  WHILE ((maxWidMm*prPgFract*10) DIV 254)>maxWid DO maxWidMm := maxWidMm-1;

  minHt16 := ((minHt*16) DIV prPgFract)-1;
  WHILE ((minHt16*prPgFract) DIV 16)<minHt DO minHt16 := minHt16+1;

  minWid16 := ((minWid*16) DIV prPgFract)-1;
  WHILE ((minWid16*prPgFract) DIV 16)<minWid DO minWid16 := minWid16+1;

  minHtMm := (((minHt*254) DIV prPgFract) DIV 10)-1;
  WHILE ((minHtMm*prPgFract*10) DIV 254)<minHt DO minHtMm := minHtMm+1;

  minWidMm := (((minWid*254) DIV prPgFract) DIV 10)-1;
  WHILE ((minWidMm*prPgFract*10) DIV 254)<minWid DO minWidMm := minWidMm+1;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
PROCEDURE SpecIndices {hw: THtOrWid; VAR iInch, i16th, iMm: TC};
  {Sets three VAR params to be either special-height btn indices or special-width btn indices}
BEGIN
  IF hw = ht
  THEN BEGIN iInch := iHtInch;  i16th := iHt16th;  iMm := iHtmm; END
  ELSE BEGIN iInch := iWidInch; i16th := iWid16th; iMm := iWidmm; END;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
PROCEDURE SpecRedraw {hw: THtOrWid};
  {Makes sure the special-size width buttons show the current numbers from the
   ckfm}
VAR iInch, i16th, iMm, c: TC;
    btn: TBtn;
BEGIN
WITH hCkFmFmt^^.rghmu[muSpecSize]^^ DO IF fMUActv THEN BEGIN
  SpecIndices(hw, iInch, i16th, iMm);                  {select height or width}
  btn := rgBtn[iInch]; BtnErase(btn); BtnDraw(btn);
  btn := rgBtn[i16th]; BtnErase(btn); BtnDraw(btn);
  btn := rgBtn[iMm];   BtnErase(btn); BtnDraw(btn);
END;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
PROCEDURE SpecSet {hw: THtOrWid; inch, in16, mm: TSp};
  {Set special-size height/width btn strings in the ckfm}
VAR iInch, i16th, iMm, c: TC;
BEGIN
WITH hCkfmFmt^^.rghmu[muSpecSize]^^ DO BEGIN
  SpecIndices(hw, iInch, i16th, iMm);   {select height or width}
  BtnSetSp(rgbtn[iInch], inch, FALSE);
  BtnSetSp(rgbtn[i16th], in16, FALSE);
  BtnSetSp(rgbtn[iMm],   mm,   FALSE);
END;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
FUNCTION SpecUnDef {hw: THtOrWid): TF};
  {Checks that the special size button strings define width/height, & that
   inches and mm are not mixed.  Returns TRUE if strings are bad.}
VAR f: TF;
    iInch, i16th, iMm, c: TC;
BEGIN
WITH hCkfmFmt^^.rghmu[muSpecSize]^^ DO BEGIN
  f := Spec(hw)=0;                                {find out if all 3 buttons are blank}
  IF NOT f
  THEN BEGIN                                      {find out if inches and mm are mixed}
  SpecIndices(hw, iInch, i16th, iMm);             {select height or width}
         IF rgbtn[iMm].hsp^^[0] <> CHR(0)
            THEN IF rgbtn[i16th].hsp^^[0] <> CHR(0)
                 THEN f := TRUE
                 ELSE IF rgbtn[iInch].hsp^^[0] <> CHR(0)
                      THEN f := TRUE;
  END;
  SpecUnDef := f;
END;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

{$IFC SpSize}
PROCEDURE StuffSpecSize;
  {Takes special-size strings from the ckfm, converts them to numbers, &
   stuffs the numbers into the print record.  Then converts the numbers to
   prPgFract units & stuffs them into the rgPaperHt & rgPaperWid arrays}
VAR sp:   TSp;
    hsp:  THSp;
BEGIN
WITH hckfmFmt^^.rghmu[muSpecSize]^^, pPrRecUsr^.prInfo.dlgPgSz DO IF fMUActv THEN BEGIN
  hsp := rgBtn[iWidInch].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, widInch);
  hsp := rgBtn[iWid16th].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, wid16th);
  hsp := rgBtn[iWidmm].hsp;   sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, widmm);
  hsp := rgBtn[iHtInch].hsp;  sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, htInch);
  hsp := rgBtn[iHt16th].hsp;  sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, ht16th);
  hsp := rgBtn[iHtmm].hsp;    sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, htmm);

  rgPaperHt [iPgSpec] := (ORD4(htInch)*PrPgFract)
                       + ((ORD4(ht16th)*PrPgFract) DIV 16)
                       + ((ORD4(htmm)*PrPgFract*10) DIV 254);
  rgPaperWid[iPgSpec] := (ORD4(widInch)*PrPgFract)
                       + ((ORD4(wid16th)*PrPgFract) DIV 16)
                       + ((ORD4(widmm)*PrPgFract*10) DIV 254);
END;
END;
{$ENDC}

{ ---------------------------------------------------------------------- }

FUNCTION SetIcons {dlgStarting: TF): TF};    {!DC 3/16/84}
  {Makes the correct set of orientation icons appear, depending on what paper orientations
   are possible with the current paper size.  If this makes the current "on" button disappear,
   the "on" button is defaulted.  Must only be called after special size and standard size
   are validated & special size is stuffed; depends on integrity of the rgPaperWid &
   rgPaperHt arrays.}
VAR visBtns:   TBtnSet;
    i:         TB;
    XW, XH:    TL;
    changed:   TF;                               {!DC 3/16/84 - identifier change, cosmetic}
    hMu:       THMu;
BEGIN
WITH hCkfmFmt^^, rghmu[muOrient]^^ DO BEGIN
  changed := FALSE;
  visBtns := [];
  FOR i := 0 TO cBtn DO IF rgBtn[i].lx.fBtnVis THEN visBtns := visBtns + [i];
  XW := rgPaperWid[rghmu[muPSize]^^.iBtnOn];
  XH := rgPaperHt[rghmu[muPSize]^^.iBtnOn];
  hMu := rghmu[muOrient];

  IF (XW > PlatenWidth) OR (XH > PlatenWidth) OR (XH = XW)  {!DC 3/16/84 - remainder of proc changed}
  THEN BEGIN {portrait paper loading only}
    IF visBtns <> [iPOnlyTitle, PapPImNR, PapPImR] THEN BEGIN
      CASE iBtnOn OF
        PapLImNR: MuPush(hMu, PapPImNR);
        PapLImR:  MuPush(hMu, PapPImR);
        OTHERWISE BEGIN END;
      END;
      BtnVanish (hMu, PapLImR); BtnVanish (hMu, PapLImNR);
      BtnVanish (hMu, iPOrLTitle); BtnReappear(hMu, iPOnlyTitle);
      BtnReappear(hMu, PapPImNR); BtnReappear(hMu, PapPImR);
      changed := TRUE;
    END;
  END
  ELSE BEGIN {either paper loading}
    IF visBtns <> [iPOrLTitle, PapPImNR, PapPImR, PapLImR, PapLImNR] THEN BEGIN
      BtnVanish (hMu, iPOnlyTitle); BtnReappear(hMu, iPOrLTitle);
      BtnReappear(hMu, PapLImR); BtnReappear(hMu, PapLImNR);
      BtnReappear(hMu, PapPImNR); BtnReappear(hMu, PapPImR);
      changed := TRUE;
    END;
    IF NOT dlgStarting
    THEN IF XW <= XH
         THEN CASE iBtnOn OF
                PapLImNR: BEGIN MuPush(hMu, PapPImNR); changed := TRUE; END;
                PapLImR:  BEGIN MuPush(hMu, PapPImR);  changed := TRUE; END;
                OTHERWISE BEGIN END;
              END
         ELSE CASE iBtnOn OF
                PapPImNR: BEGIN MuPush(hMu, PapLImNR); changed := TRUE; END;
                PapPImR:  BEGIN MuPush(hMu, PapLImR);  changed := TRUE; END;
                OTHERWISE BEGIN END;
              END;
  END;
  SetIcons := changed;
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FmtSetUp {pPrRecIn: TPprRec; fSpecSizeSuppress: TF};
  {Sets up everything for the "Format" dialog, just before it runs}
VAR f, fTW, fTH, wrongBtn: TF;
    setIDMu: TSetIdMu;
BEGIN
{$IFC SpSize}
  IF fSpecSizeSuppress THEN setIDMu := [0] ELSE setIDMu := setIdMuAll;
{$ELSEC}
  setIDMu := [0];
{$ENDC}
  pPrRecUsr := pPrRecIn;                                         {set up generic ptr to the print record}
  CkFmSetUp (hckfmFmt, TRUE {fInit}, setIDMu);                   {PrDlgMgr's ckfm initialization}
  FmtCkSet;                                                      {info from print record to checkform}
  hckfmPrCk := hckfmFmt;                                         {set generic handle for the ckfm}
{$IFC SpSize}
  IF SpecUnDef(wid) THEN SpecSet(wid, '8', '8', '');             {make sure special-size stuff & paper size...}
  IF SpecUnDef(ht) THEN SpecSet(ht, '11', '', '');               {..."on" btn are kosher}
  FitSpecSize(fTW, fTH);
  StuffSpecSize;
  verifySpecSize := FALSE;                                       {!DC 3/16/84}
{$ENDC}
  WITH hCkfmFmt^^ DO BEGIN
    WITH rghmu[muPSize]^^ DO BEGIN                     {make sure page size btn is valid}
    {$IFC SpSize}
      IF fSpecSizeSuppress THEN BtnVanish(rghmu[muPSize], iPgSpec);
    {$ELSEC}
      IF cBtn >= iPgSpec THEN BtnVanish(rghmu[muPSize], iPgSpec);
    {$ENDC}
      wrongBtn := NOT (iBtnOn IN validPSize);                         {undefined btn for this printer}
      IF wrongBtn THEN muPush(rghmu[muPSize], iBtnStd);
      oldSize := iBtnOn;                               {!DC 3/16/84}
    END;
    f := SetIcons (TRUE);                              {make icons right}  {!DC 3/16/84}
    PsPortName (pPrRecUsr^.PrInfo.Port,
                rgHMu[muDoIt]^^.rgBtn[iPortMsg].hsp);  {get port descriptor string} {!DC 4/11/84}
  END;
  procCkCmd := @FmtCkCmd;                              {stuff PrDlgMgr procs}
  DlgInstall (TRUE, @PrCkEvent, @PrCkTrkMse, @FmtEnd);
  DlgOpen (hckfmFmt^^.rBB.bottom);                     {open the dlg window & init its grafport}
  CkFmShow (hckfmFmt, TRUE{fInit});                    {display the ckfm}
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FmtCkSet;
  {Turns on buttons and sets up strings for each menu when the dialog
   starts up.}
VAR i: TC;
    pDevRec: TpDevRec;
BEGIN
  pDevRec := POINTER(ORD(@pPrRecUsr^.PrDevInfo));
  WITH hckfmFmt^^, pPrRecUsr^.prInfo DO BEGIN
    FOR i := 0 TO cMu DO BEGIN
      WITH rghmu[i]^^ DO BEGIN
        IF fMuActv AND NOT fMuVis THEN CASE i OF
          muDoIt:      iBtnOn := iBtnNil;         {initially no "on" btn in this menu}
          muPSize:     iBtnOn := dlgPgSz.pgSzBtn; {turn on a page size btn}
        {$IFC SpSize}
          muSpecSize:  BEGIN
                         iBtnOn := iBtnNil;       {no "on" btn in this menu}
                         SpecGet(wid);            {stuff numbers into btn strings}
                         SpecGet(ht);
                       END;
        {$ENDC}
          muOrient:    WITH pgSize DO CASE PrintDirect OF           {turn on an orientation icon}
                         Portrait:  CASE PaperDirect OF
                                      Portrait:  iBtnOn := PapPImNR;
                                      Landscape: iBtnOn := PapLImNR;
                                      OTHERWISE  iBtnOn := PapPImNR;
                                    END;
                         Landscape: CASE PaperDirect OF
                                      Portrait:  iBtnOn := PapPImR;
                                      Landscape: iBtnOn := PapLImR;
                                      OTHERWISE  iBtnOn := PapPImNR;
                                    END;
                         OTHERWISE  iBtnOn := PapPImNR;
                       END;
          muFeeder:    WITH pDevRec^.CNInfo DO CASE feeder OF
                         feedRoll: iBtnOn := iRoll;
                         feedCut:  iBtnOn := iSingleSheet;
                         OTHERWISE iBtnOn := iRoll;
                       END;
        END {case};
      END; {with menu}
    END; {for}
  END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FmtCkCmd {iMu, iBtn: TC};
     {Bottleneck proc for responding to a particular button-push.}
VAR btn: TBtn;
    f, fNewWid, fNewHt, fWidJunk, fHtJunk: TF;
BEGIN
{$IFC SpSize}
  IF iMu <> muSpecSize THEN CkFmKeys(hCkFmFmt, iMuNil, iBtnNil); {if it's a standard size then
                                                                  ignore keystrokes}
{$ELSEC}
  CkFmKeys(hCkFmFmt, iMuNil, iBtnNil);                           {ignore keystrokes}
{$ENDC}

  CASE iMu OF
    muDoIt:       DlgEnd (FALSE); {FFmtDlg calls FCkFmHit to find whether IDoItYes was pushed.}
    muPSize:      BEGIN
                  {$IFC SpSize}
                    IF iBtn = iPgSpec THEN BEGIN                {validate special-size data}
                      fWidJunk := SpecUnDef(wid);                 {if width data is junk...}
                      IF fWidJunk THEN SpecGet(wid);              {...then get previous width}
                      fHtJunk := SpecUnDef(ht);                   {if height data is junk...}
                      IF fHtJunk THEN SpecGet(ht);                {...then get previous height}
                      FitSpecSize(fNewWid, fNewHt);               {force data to be within bounds}
                      StuffSpecSize;                              {update print rec & size arrays}
                      IF fWidJunk OR fNewWid THEN SpecRedraw(wid);{update the screen}
                      IF fHtJunk OR fNewHt THEN SpecRedraw(ht);
                      IF verifySpecSize OR (iBtn <> oldSize)      {!DC 3/16/84}
                      THEN f := SetIcons (FALSE);                 {update orientation menu} {!DC 3/16/84}
                    END
                    ELSE IF iBtn <> oldSize                       {!DC 3/16/84}
                         THEN f := SetIcons (FALSE);              {update orientation menu}
                    verifySpecSize := FALSE;                      {!DC 3/16/84}
                    oldSize := iBtn;                              {!DC 3/16/84}
                  {$ELSEC}
                    f := SetIcons (FALSE);              {update orientation menu}
                    oldSize := iBtn;                              {!DC 3/16/84}
                  {$ENDC}
                  END;
  {$IFC SpSize}
    muSpecSize:   WITH hCkFmFmt^^, rghmu[muSpecSize]^^ DO BEGIN   {!DC 3/16/84}
                    CkFmKeys(hCkFmFmt, iMu, iBtn);  {this btn gets keystrokes}
                    iBtnOn := iBtnNil;              {prevent this btn being pushed when next btn is hit;
                                                     type-in btns should not be left "on"}
                    CASE iBtn OF
                      iWidInch,
                      iWid16th: BtnSetSp (rgbtn[iWidmm], '', TRUE);    {blank the mm btn}
                      iWidmm:   BEGIN                                  {blank the inch/16ths btns}
                                  BtnSetSp (rgbtn[iWidInch], '', TRUE);
                                  BtnSetSp (rgbtn[iWid16th], '', TRUE);
                                END;
                      iHtInch,
                      iHt16th:  BtnSetSp (rgbtn[iHtmm], '', TRUE);    {blank the mm btn}
                      iHtmm:    BEGIN                                 {blank the inch/16ths btns}
                                  BtnSetSp (rgbtn[iHtInch], '', TRUE);
                                  BtnSetSp (rgbtn[iHt16th], '', TRUE);
                                END;
                    END;
                    IF rghmu[muPSize]^^.iBtnOn = iPgSpec THEN verifySpecSize := TRUE;     {!DC 3/16/84}
                  END;
  {$ENDC}
    muOrient:     BEGIN END;
    muFeeder:     BEGIN END;
  END;
END;

{ ---------------------------------------------------------------------- }

FUNCTION FFmtDlg {VAR prRec: TprRec; VAR fNewStl: TF;
                  maxHt, maxWid, minHt, minWid: TC;
                  fSpecSizeSuppress: TF): DlgOption};
  {Runs the "Format" dialog}
VAR prRecIn, prRecTmp:   TprRec;
    fBadRec:             TF;
    usrWid, usrHt:       TC;
    pDevRec:             TpDevRec;
BEGIN
  PsNonPreemptive;       {!DC 4/6/84}
  GetPort(savePort);
  SetPort(@dlgPort);     {!DC 4/19/84}
{$IFC SpSize}
  SpecLimits (maxHt, maxWid, minHt, minWid);
{$ENDC}
  fNewStl := FALSE;
  fBadRec := NOT FPrPrfValid (prRec);
  IF fBadRec THEN PrPrfDefault (prRec);
  prRecIn := prRec;      {prRecIn is left untouched for comparison at end}
  prRecTmp:= prRec;      {prRecTmp is used to record changes caused by the dlg,
                          then used to update prRec if user dismisses by OK button}

  FmtSetup (@prRecTmp, fSpecSizeSuppress);   {get everything ready...}
  DlgMain;                                   {...and run the dialog}

  IF FCkfmHit (hckfmFmt, muDoIt, iDoItYes)   {if dlg was dismissed with "OK"...}
  THEN BEGIN                                 {...put info from ckfm into the PrRec}
    FFmtDlg := eDlgOK;
    prRec := prRecTmp;                         {copy info that has been maintained during the dlg}
    WITH hckfmFmt^^, prRec.prInfo, pgSize DO BEGIN
      WITH rgHMu[muOrient]^^ DO CASE iBtnOn OF
        PapPImNR: BEGIN PaperDirect := Portrait;  PrintDirect := Portrait;  END;
        PapPImR:  BEGIN PaperDirect := Portrait;  PrintDirect := Landscape; END;
        PapLImNR: BEGIN PaperDirect := Landscape; PrintDirect := Portrait;  END;
        PapLImR:  BEGIN PaperDirect := Landscape; PrintDirect := Landscape; END;
      END;
      WITH rghmu[muPSize]^^ DO BEGIN
        dlgPgSz.pgSzBtn := iBtnOn;      {other fields of dlgPgSz have been maintained}
        usrWid := rgPaperWid[iBtnOn];   {temp variables used here to reduce indexing below}
        usrHt  := rgPaperHt[iBtnOn];
        CASE PaperDirect OF
          Portrait:  BEGIN
                       Width  := Minimum (usrWid, usrHt);
                       Height := Maximum (usrWid, usrHt);
                     END;
          Landscape: BEGIN
                       Width  := Maximum (usrWid, usrHt);
                       Height := Minimum (usrWid, usrHt);
                     END;
        END;
      END;
      pDevRec := POINTER(ORD(@prRec.PrDevInfo));
      WITH rghmu[muFeeder]^^, pDevRec^.CNInfo DO CASE iBtnOn OF
        iRoll:         feeder := feedRoll;
        iSingleSheet:  feeder := feedCut;
      END;
    END; {with hckfmFmt^^, prRec.prInfo, pgSize}
    CNMetrics (prRec);                                 {!DC 5/2/84}
  END {if FCkfmHit (hckfmFmt, muDoIt, iDoItYes)}
  ELSE IF FCkfmHit (hckfmFmt, muDoIt, iNewPr)
       THEN  FFmtDlg := eDlgAnother
       ELSE {neither iDoIt nor iNewPr} FFmtDlg := eDlgCancel;

  fNewStl := NOT FPrPrfEq(prRecIn,prRec);
  fNewStl := fNewStl OR fBadRec;
  SetPort(savePort);
  PsPreemptive;               {!DC 4/6/84}
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FmtEnd {fDismiss: TF};
  {Bottleneck proc for ending the "Format" dialog (becomes procEnd in the PrDlgMgr
   code).  Does what's needed between the time you hit a dismiss btn and the time the
   dlg is erased from the screen.}
VAR hMu:    THMu;
{$IFC SpSize}
    fW, fH, fTW, fTH, fI: TF;
  PROCEDURE WaitABit;
  VAR timeStart: TL;
  BEGIN
    BusyDelay(0);
    timeStart := Time;
    REPEAT UNTIL (ABS (Time-timeStart) > 200);
  END;
  PROCEDURE FlashMu (hMu: THMu);
  BEGIN
    MuErase(hMu); MuShow(hMu); MuErase(hMu); MuShow(hMu);
  END;
{$ENDC}
BEGIN
WITH hckfmFmt^^ DO BEGIN
  hMu := rghmu[muDoIt];
  IF fDismiss THEN MuPush (hMu, iBtnStd);    {if dismissed by a click outside the window, push "OK"}
{$IFC SpSize}
  IF hMu^^.iBtnOn = iDoItYes                 {!DC 3/16/84 - remainder of proc changed}
  THEN IF verifySpecSize
       THEN BEGIN
              fW := SpecUnDef(wid);          {make sure the special width stuff is kosher}
              fH := SpecUnDef(ht);
              IF fW THEN SpecGet(wid);
              IF fH THEN SpecGet(ht);
              FitSpecSize(fTW, fTH);
              StuffSpecSize;                 {store special width stuff in print record & size arrays}
              IF fW OR fH OR fTW OR fTH
              THEN FlashMu (rghmu[muSpecSize]);

              fI := SetIcons (FALSE);        {fix orientation mu if special width changed}
              IF fI
              THEN FlashMu (rghmu[muOrient]);

              IF fI OR fW OR fH OR fTW OR fTH
              THEN WaitABit;                 {if anything changed, wait & let user notice it}
            END;
{$ENDC}
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE InsSetUp {pPrRecIn: TPprRec; dlgMode: prMenuSuppress};
  {Sets up everything for the "Print..." dialog, just before it runs}
VAR setIDMu: TSetIdMu;
BEGIN
  pPrRecUsr := pPrRecIn;                                 {set up generic ptr to the print record}
  setIDMu := [0];                                        {show vanilla menus}
  IF dlgMode <> ePgRangeSuppress
  THEN setIDMu := setIDMu + [1];                         {show page range menu}
  CkFmSetUp (hckfmIns, TRUE {fInit}, setIDMu);           {PrDlgMgr's ckfm initialization}
  InsCkSet;                                              {info from print record to checkform}
  hckfmPrCk := hckfmIns;                                 {set generic handle for the ckfm}
  PsPortName (pPrRecUsr^.PrInfo.Port,
        hCkFmIns^^.rgHMu[muDoIt]^^.rgBtn[iPortMsg].hsp); {get port descriptor string} {!DC 4/30/84}
  IF dlgMode <> ePrDialogSuppress THEN BEGIN
    procCkCmd := @InsCkCmd;                              {stuff PrDlgMgr procs}
    DlgInstall (TRUE, @PrCkEvent, @PrCkTrkMse, @InsEnd);
    DlgOpen (hckfmIns^^.rBB.bottom);                     {open the dlg window & init its grafport}
    CkFmShow (hckfmIns, TRUE{fInit});                    {display the ckfm}
  END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE InsCkSet;
  {Turns on buttons when the dialog starts up, for those menus that should be "remembered"
   from the print record.  Will include the hires/lores menu if that is put into this dlg.}
VAR i: TC;
    pDevRec: TpDevRec;
    hMu: THMu;
BEGIN
  pDevRec := POINTER(ORD(@pPrRecUsr^.PrDevInfo));
  WITH hckfmIns^^, pDevRec^ DO BEGIN
    WITH rghmu[muDraft]^^ DO IF CNInfo.fDraft
                             THEN iBtnOn := iDraft
                             ELSE iBtnOn := iFinished;
  END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE InsCkCmd {iMu, iBtn: TC};
     {Bottleneck proc for responding to a particular button-push.}
VAR btn: TBtn;
    f, fNewWid, fNewHt, fWidJunk, fHtJunk: TF;
BEGIN
WITH hCkFmIns^^ DO BEGIN
  IF iMu <> muPgSelect THEN CkFmKeys(hCkFmIns, iMuNil, iBtnNil); {ignore keystrokes}
  CASE iMu OF
    muDoIt:      DlgEnd (FALSE); {FInsDlg calls FCkFmHit to find whether IDoItYes was pushed.}
    muDraft:     BEGIN END;
    muCopies:    BEGIN END;
    muPgSelect:  BEGIN
                   CASE iBtn OF
                     iAllPgs: WITH rgHMu[iMu]^^ DO BEGIN
                                BtnSetSp(rgBtn[iFirstPg], '', TRUE);
                                BtnSetSp(rgBtn[iLastPg], '', TRUE);
                                CkfmKeys (hckfmIns, iMuNil, iBtnNil);
                              END;
                     iSomePgs: BEGIN
                                 btn := rghmu[iMu]^^.rgbtn[iLastPg];
                                 btn.hsp^^[0] := CHR(0);
                                 BtnFill (btn, FALSE);
                                 CkfmKeys (hckfmIns, iMu, iFirstPg);
                               END;
                     iFirstPg, iLastPg: BEGIN
                                          MuPush (rghmu[iMu], iSomePgs);
                                          CkfmKeys (hckfmIns, iMu, iBtn);
                                        END;
                   END;
                 END;
  END;
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE InsEnd {fDismiss: TF};
  {Bottleneck proc for ending the "Print..." dialog (becomes procEnd in the PrDlgMgr
   code).  Does what's needed between the time you dismiss the dlg and the time the
   dlg is erased from the screen.}
BEGIN
WITH hckfmIns^^ DO BEGIN
  IF fDismiss
  THEN MuPush (rghmu[muDoIt], iBtnStd); {if dismissed by a click outside the window, push "Cancel"}
END;
END;

{ ---------------------------------------------------------------------- }

FUNCTION FInsDlg {VAR prRec: TprRec; VAR fNewStl: TF; dlgMode: prMenuSuppress): TF};
  {Runs the "Print..." dialog}
VAR prRecIn, prRecTmp:   TprRec;
    fBadRec:   TF;
    c1, c2:    TC;
    sp:        TSp;
    hsp:       THSp;
    pDevRec:   TpDevRec;
BEGIN
  PsNonPreemptive;                                {!DC 4/6/84}
  GetPort(savePort);
  SetPort(@dlgPort);                              {!DC 4/19/84}
  fNewStl := FALSE;
  fBadRec := NOT FPrPrfValid (prRec);
  IF fBadRec THEN PrPrfDefault (prRec);
  prRecIn := prRec;      {prRecIn is left untouched for comparison at end}
  prRecTmp:= prRec;      {prRecTmp is used to record changes caused by the dlg,
                          then used to update prRec if user dismisses by OK button}

  InsSetup (@prRecTmp, dlgMode);                  {get everything ready...}
  IF dlgMode <> ePrDialogSuppress                 {...and if the dialog isn't suppressed...}
  THEN DlgMain
  ELSE PsYieldCPU;

  IF FCkfmHit (hckfmIns, muDoIt, iDoItYes)   {if dlg was dismissed with "OK"...}
     OR (dlgMode = ePrDialogSuppress)        {...or was suppressed...}
  THEN BEGIN                                 {...put info from ckfm into the PrRec}
    FInsDlg := eDlgOK;
    prRec := prRecTmp;                         {copy info that has been maintained during the dlg}
    pDevRec := POINTER(ORD(@prRec.PrDevInfo));
    WITH hckfmIns^^, prRec.prJobInfo DO BEGIN

      WITH rghmu[muPgSelect]^^ DO IF (dlgMode <> ePrNormal) OR (iBtnOn = iAllPgs) THEN BEGIN
        docPgFst := 1;   {set info in the print record}
        docPgLst := 1999;
      END
      ELSE BEGIN                             {turn page range strings into numbers}
        hsp := rgBtn[iFirstPg].hsp;
        sp := COPY (hsp^^, 1, ORD(hsp^^[0]));
        PrStrToNum(sp, c1);
        IF c1 = 0 THEN c1 := 1;              {!DC 3/19/84}
        hsp := rgBtn[iLastPg].hsp;
        sp := COPY (hsp^^, 1, ORD(hsp^^[0]));
        PrStrToNum(sp, c2);
        IF c2 = 0 THEN c2 := PrPageMax;           {!DC 3/19/84}
        docPgFst := CMIN(c1, c2);            {set info in the print record}
        docPgLst := CMAX(c1, c2);
      END;

      pDevRec^.CNInfo.fDraft := rghmu[muDraft]^^.iBtnOn = iDraft;

      copies := rghmu[muCopies]^^.iBtnOn;
    END;
  END
  ELSE FInsDlg := eDlgCancel;

  fNewStl := NOT FPrPrfEq(prRecIn,prRec);
  fNewStl := fNewStl OR fBadRec;
  SetPort(savePort);
  PsPreemptive;                              {!DC 4/6/84}
END;

{ ---------------------------------------------------------------------- }

FUNCTION CNDlgInit {: TF};                   {!DC 4/10/84}
  {Should be called once by the printer process, when it begins to run.}
TYPE TRgHCkFm = ARRAY[0..1] OF TL;
VAR DSPathname:     Pathname;
    cErr, i:        TC;
    DSAddr:         TL;
    pRgHCkFm:       ^TRgHCkFm;
    failed:         TF;            {!DC 4/10/84}
BEGIN
  GetPort(savePort);                                        {!DC 4/19/84}
  OpenPort(@dlgPort);                                       {!DC 4/19/84}
  SetPort(savePort);                                        {!DC 4/19/84}
  failed := FALSE;                                          {!DC 4/10/84}
  DSPathname := DSSegname;
  OPEN_DATASEG (cErr, DSPathname, DDSRefNum, DSAddr, DSLDSN);
  IF cErr <= 0 THEN BEGIN                                   {!DC 4/10/84}
    SETACCESS_DATASEG (cErr, DDSRefNum, FALSE);              {read/write access}
    IF cErr <= 0 THEN BEGIN                                 {!DC 4/10/84}
      pRgHCkFm := POINTER(ORD(DSAddr));
      hckfmFmt := POINTER(ORD(pRgHCkFm^[0]));
      hckfmIns := POINTER(ORD(pRgHCkFm^[1]));

      {init the size arrays, except for the iPgSpec elements, which may vary during the dlg and
       are maintained via the StuffSpecSize proc}
      FOR i := iPgFst TO iPgLst DO BEGIN
        rgPaperWid[i] := 0;
        rgPaperHt[i]  := 0;
      END;
      rgPaperWid[iPg8x11]   := (ORD4(510) * prPgFract) DIV 60;  {1020/120 = 8.5"}
      rgPaperHt [iPg8x11]   := (ORD4(660) * prPgFract) DIV 60;  {1320/120 = 11"}
      rgPaperWid[iPg8x14]   := rgPaperWid[iPg8x11];             {1020/120 = 8.5"}
      rgPaperHt [iPg8x14]   := (ORD4(840) * prPgFract) DIV 60;  {1680/120 = 14"}
      rgPaperWid[iPgA4]     := (ORD4(496) * prPgFract) DIV 60;  { 992/120 = 210mm}
      rgPaperHt [iPgA4]     := (ORD4(700) * prPgFract) DIV 60;  {1400/120 = 297mm}
      rgPaperWid[iPg210x12] := rgPaperWid[iPgA4];               { 992/120 = 210mm}
      rgPaperHt [iPg210x12] := (ORD4(720) * prPgFract) DIV 60;  {1440/120 = 12"}

      PlatenWidth           := rgPaperWid[iPg8x11];             {8.5"}
    {$IFC SpSize}
      validPSize := [iPg8x11, iPg8x14, iPgA4, iPg210x12, iPgSpec];
    {$ELSEC}
      validPSize := [iPg8x11, iPg8x14, iPgA4, iPg210x12];
    {$ENDC}
    END
    ELSE failed := TRUE;
  END
  ELSE failed := TRUE;
  CNDlgInit := NOT failed;                                       {!DC 4/10/84}
  UNBIND_DATASEG(cErr,DDSRefNum);
END;

{ ---------------------------------------------------------------------- }

END.
{Changes:
           5/04/84 : BH -- change to bind and unbind dialog dataseg
           5/02/84 : DC -- FFmtDlg: call CNMetrics with only 1 param
           4/30/84 : DC -- InsSetup: call PsPortName to set port info string (a new button in the
                           button file, plus a dummy button to make the index come out right).
           4/19/84 : DC -- FInsDlg: SetPort instead of OpenPort.
           4/19/84 : DC -- FFmtDlg: SetPort instead of OpenPort.
           4/19/84 : DC -- CNDlgInit: Open the dlgport.
           4/10/84 : DC -- CNDlgInit: changed to function, returns false if it fails to open the
                           data seg.
           4/09/84 : DC -- FmtSetup: Call PsPortName instead of BtnVanish.
           4/06/84 : DC -- FInsDlg: moved PsNonPreemptive & PsPreemptive to enclose entire proc.
           4/06/84 : DC -- FFmtDlg: moved PsNonPreemptive & PsPreemptive to enclose entire proc.
           3/19/84 : DC -- FInsDlg: force 1st pg num from 0 to 1, last pg num from 0 to 1999.
                           CNDlgInit: removed InitWmlCrs call.  Needs to be put in PrDlgMgr...
           3/16/84 : DC -- SetIcons: new parameter, new functionality to offer "smart" defaults to user
                             on orientation.
                           oldSize, verifySpecSize: new global variables for benefit of SetIcons.
                           FmtSetup: init oldSize & verifySpecSize.
                           FmtCkCmd: new functionality for benefit of SetIcons.
                           FmtDlg: new functionality for benefit of SetIcons.
}

ÿ