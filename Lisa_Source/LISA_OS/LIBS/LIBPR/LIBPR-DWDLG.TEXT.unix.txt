(*
$EXEC
P?
-newdisk-intrinsic.lib
LibPr/DWDlg
{no listing}
LibPr/Temp
GLibPr/Temp
LibPr/DWDlg

$ENDEXEC
*)
{------------------------------------------------------------------------------}
{                Copyright 1983, 1984, Apple Computer Inc.                     }
{------------------------------------------------------------------------------}
{$S DWDlg}
UNIT DWDlg;
     {code to support dialogs in daisy-wheel background printer process - converted from the ImageWriter
      code}

INTERFACE
USES {$U LibOS/SysCall         }   SysCall,
     {$U sys1lib               }   PMDecl,
                                   UnitStd,
                                   UnitHz,
                                   QuickDraw,
                                   FontMgr,
                                   Storage,
                                   Events,
                                   HwInt,
                                   Menus,
                                   Windows,
                                   Folders,
                                   WmlStd,
                                   WmlCrs,
                                   AlertMgr,
                                   PrStdInfo,
     {$U prlib.obj             }   PrStdProcs,
                                   Queues,
                                   PrEvents,
                                   PrDlgMgr,
                                   PrMgr;

{----------------------------  Main Dev and Dlg Types  --------------------------}
{!BH 2/27/84}
TYPE

    TFeeder   = (feedCut,feedFanfold,feedMechCut,feedOther);
    TPrintMode= (HighRes,Draft);
    TTyScan   = (tyScanTB,tyScanLR);

    TDWInfo   = RECORD
      tyScan      : TTyScan;
      cPatScale,
      cULThick,
      cULOffset,
      cULShadow   : TC;

      rRoller     : Rect;
      rBand       : Rect;
      rBounds     : Rect;
      lBandSize   : TL;
      numBands    : TC;
      DeltaHBand  : TC;
      DeltaVBand  : TC;
    END;

    TDWCfg    = RECORD
      feeder  : TFeeder;
      mode    : TPrintMode;
      wheel   : TEwhcl;             (*the print wheel*)
    END;

    TpDWRec   = ^TDWRec;
    TDWRec    = RECORD
      DWInfo  : TDWInfo;
      DWCfg   : TDWCfg;
    END;

{ ---------------------------------------------------------------------- }

VAR
   DDSRefNum:        TC;            {!BH 2/24/84}

{ ---------------------------------------------------------------------- }

PROCEDURE DWDlgInit;
PROCEDURE DWDlgQuit;{!BH 2/24/84}
FUNCTION  FFmtDlg (VAR prRec: TprRec; VAR fNewStl: TF;
                  maxHt, maxWid, minHt, minWid: TC;
                  fSpecSizeSuppress: TF): DlgOption;
FUNCTION  FInsDlg (VAR prRec: TprRec; VAR fNewStl: TF; dlgMode: PrMenuSuppress): DlgOption;

{ ---------------------------------------------------------------------- }
IMPLEMENTATION
{ ---------------------------------------------------------------------- }

{$IFC PrSymbols}
     {$D+}
{$ELSEC}
     {$D-}
{$ENDC}
{$IFC PrDebug}
     {$R+}
{$ELSEC}
     {$R-}
{$ENDC}

{$S Pr }

CONST
  DSSegname = 'dwBtnData';
{  DSLDSN = 9;}

  {The menu and button indices.}
  muDoIt     = 0;                      {This mu serves for both dlgs}
    iDoItYes      = 0;  {"OK" btn}
    iDoItNo       = 1;  {"Cancel" btn}
    iNewPr        = 2;  {"New Printer" btn}
    iPortMsg      = 4;  {port information message}

{Menus for the Format... dialog}

  muPSize    = 1;
   {Button indices from PrStdInfo:
    iPg8x11 = 1; iPg8x14   = 2; iPg14x11  = 3;
    iPgA4   = 4; iPg210x12 = 5; iPg310x8  = 6;
    iPgSpec = 7;
    iPgFst = 0; iPgMax = 15;}

    iPgLst = 7;

  muSpecSize = 2;
    iWidInch = 2; iWid16th = 4; iWidmm = 7;
    iHtInch  =10; iHt16th  =12; iHtmm  =15;
    maxWidTitle = 17; maxHtTitle = 18;
    minWidTitle = 19; minHtTitle = 20;

  muOrient   = 3;
    iOrientTitle  = 0;  {"Paper Orientation" title}
    paperPortrait  = 1;       {Portrait paper loading (icon btn)}     {!DC 3/17/84, new id, cosmetic}
    paperLandscape = 2;       {Landscape paper loading (icon btn)}    {!DC 3/17/84, new id, cosmetic}

{Menus for the Print... dialog}

  muDraft = 1;
    iFinished = 0; iDraft = 1;

  muFeeder = 2;
    iFanFold = 1; iSingleSheet = 2; iMechFeed = 3;

  muWheel = 3;
    iWhcl15 = 1; iWhcl12 = 2; iWhcl10 = 3;
    iWhclPS = 4; iWhclMF = 5; iWhclMP = 7; iWhclLCS= 8;

  muCopies = 4;
    {in this menu the number of copies selected = the btn number}

  muPgSelect = 5;
    iAllPgs = 1; iSomePgs = 2; iFirstPg = 3; iLastPg = 5;

TYPE
    TBtnSet  = SET OF 0..cBtnMax;
    THtOrWid = (ht, wid);
    TRgHCkFm  = ARRAY[0..5] OF TL;
    TPRgHCkFm = ^TRgHCkFm;

VAR
   hckfmFmt:        THckfm;   {The FFmtDlg ckfm}
   hckfmIns:        THckfm;   {The FInsDlg ckfm}
   pRgHCkFm:        TPRgHCkFm;
   rgPaperWid:      ARRAY[iPgFst..iPgMax] OF TL;  {Paper widths in prPgFract units}
   rgPaperHt:       ARRAY[iPgFst..iPgMax] OF TL;  {Paper heights in prPgFract units}
   platenWidth,                                   {Platen width in prPgFract units}
   maxHt16,
   maxWid16,
   maxHtMm,
   maxWidMm,
   minHt16,
   minWid16,
   minHtMm,
   minWidMm:        TL;                           {Limits for special paper sizes}
   validPSize:      SET OF iPgFst..iPgMax;
   savePort:        GrafPtr;
   dlgPort:         GrafPort;
   verifySpecSize:  TF;            {!DC 3/17/84 special size changed, not yet verified, & is selected}
   oldSize:         TC;            {!DC 3/17/84 previously selected paper size btn}

{ -------------------------DIRECTORY------------------------------------ }
{$S DWDlg}
{Miscellaneous}
FUNCTION  Minimum (x, y: TL): TC;                                FORWARD;
FUNCTION  Maximum (x, y: TL): TC;                                FORWARD;

{The Format for Printer... dialog}
     {Dealing with special sizes}
PROCEDURE FitSpecSize (VAR fNewWid, fNewHt: TF);                 FORWARD;
FUNCTION  Spec (hw: THtOrWid):  TL;                              FORWARD;
PROCEDURE SpecGet (hw: THtOrWid);                                FORWARD;
PROCEDURE SpecIndices (hw: THtOrWid; VAR iInch, i16th, iMm: TC); FORWARD;
PROCEDURE SpecLimits (maxHt, maxWid, minHt, minWid: TL);         FORWARD;
PROCEDURE SpecRedraw (hw: THtOrWid);                             FORWARD;
PROCEDURE SpecSet (hw: THtOrWid; inch, in16, mm: TSp);           FORWARD;
FUNCTION  SpecUnDef (hw: THtOrWid): TF;                          FORWARD;
PROCEDURE StuffSpecSize;                                         FORWARD;
     {Dealing with orientation menu}
FUNCTION  SetIcons (dlgStarting: TF): TF;                        FORWARD;  {!DC 3/17/84}
     {Initializing the dialog instance}
PROCEDURE FmtSetUp (pPrRecIn: TPprRec; fSpecSizeSuppress: TF);   FORWARD;
PROCEDURE FmtCkSet;                                              FORWARD;
     {Bottleneck Procs for PrDlgMgr}
PROCEDURE FmtCkCmd (iMu, iBtn: TC);                              FORWARD;
PROCEDURE FmtEnd (fDismiss: TF);                                 FORWARD;

{The Print... dialog}
     {Initializing the dialog instance}
PROCEDURE InsSetUp (pPrRecIn: TPprRec; dlgMode: prMenuSuppress); FORWARD;
PROCEDURE InsCkSet;                                              FORWARD;
     {Bottleneck Procs for PrDlgMgr}
PROCEDURE InsCkCmd (iMu, iBtn: TC);                              FORWARD;
PROCEDURE InsEnd (fDismiss: TF);                                 FORWARD;
PROCEDURE DWDefMetrics(VAR PrRec:TPrRec);                               EXTERNAL;
PROCEDURE RhMetrics(VAR prstl: TPrRec);                                 EXTERNAL;

{ ---------------------------------------------------------------------- }

FUNCTION Minimum {x, y: TL): TC};
VAR c: TL;
BEGIN
  IF x > y THEN c := y ELSE c := x;
  Minimum := c;
END;

{ ---------------------------------------------------------------------- }

FUNCTION Maximum {x, y: TL): TC};
VAR c: TL;
BEGIN
  IF x > y THEN c := x ELSE c := y;
  Maximum := c;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FitSpecSize {VAR fNewWid, fNewHt: TF};
  {Guarantees that the ckfm's special-size width & height don't exceed limits.  For
  each dimension, returns a flag TRUE if it made a change.  Also does mod 16 stuff in the
  inches & 16ths buttons.}
VAR spIn, sp16, spMm:         TSP;
    cIn, c16, cMm:            TC;
    c16Total:                 TL;
    hmu:                      THmu;
    htIsInches, widIsInches:  TF;
    hsp:                      THSp;

  PROCEDURE SpecRead (hw: THtOrWid); {local}
  VAR iInch, i16th, iMm, c: TC;
  BEGIN
    WITH hCkfmFmt^^, rghmu[muSpecSize]^^ DO BEGIN
      SpecIndices(hw, iInch, i16th, iMm);
      hsp := rgbtn[iInch].hsp; spIn := COPY (hsp^^, 1, ORD(hsp^^[0]));
      hsp := rgbtn[i16th].hsp; sp16 := COPY (hsp^^, 1, ORD(hsp^^[0]));
      PrStrToNum(spIn, cIn); PrStrToNum(sp16, c16);
      c16Total := (ORD4(cIn) * 16) + c16;
      hsp := rgbtn[iMm].hsp; spMm := COPY (hsp^^, 1, ORD(hsp^^[0]));
      PrStrToNum(spMm, cMm);
    END;
  END;

  PROCEDURE Mod16 (hw: THtOrWid); {local}
  VAR iInch, i16th, iMm, c: TC;
  BEGIN
    WITH hCkfmFmt^^, rghmu[muSpecSize]^^ DO BEGIN
      SpecRead(hw);
      IF c16 > 15 THEN BEGIN                           {do mod 16 stuff}
        cIn := cIn + c16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := c16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(hw, spIn, sp16, '');
        SpecRedraw(hw);
      END;
    END;
  END;

BEGIN
WITH hCkfmFmt^^, rghmu[muSpecSize]^^ DO IF fMUActv THEN BEGIN
  fNewWid := FALSE; fNewHt := FALSE;
  hmu := rghmu[muSpecSize];
  widIsInches := rgbtn[iWidmm].hsp^^[0] = CHR(0);
  htIsInches  := rgbtn[iHtmm].hsp^^[0] = CHR(0);

  {deal with width}
  SpecRead(wid);

  {make width <= upper limit}
  IF widIsInches THEN BEGIN
    IF c16Total >= maxWid16 THEN BEGIN
      BtnVanish(hmu, minWidTitle); BtnReappear(hmu, maxWidTitle);
      IF c16Total > maxWid16 THEN BEGIN
        cIn := maxWid16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := maxWid16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(wid, spIn, sp16, '');
        fNewWid := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, maxWidTitle);
  END
  ELSE BEGIN
    IF cMm >= maxWidMm THEN BEGIN
      BtnVanish(hmu, minWidTitle); BtnReappear(hmu, maxWidTitle);
      IF cMm > maxWidMm THEN BEGIN
        cMm := maxWidMm;
        PrNumToStr(cMm, spMm);
        SpecSet(wid, '', '', spMm);
        fNewWid := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, maxWidTitle);
  END;

  {make width >= lower limit}
  IF widIsInches THEN BEGIN
    IF c16Total <= minWid16 THEN BEGIN
      BtnVanish(hmu, maxWidTitle); BtnReappear(hmu, minWidTitle);
      IF c16Total < minWid16 THEN BEGIN
        cIn := minWid16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := minWid16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(wid, spIn, sp16, '');
        fNewWid := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, minWidTitle);
  END
  ELSE BEGIN
    IF cMm <= minWidMm THEN BEGIN
      BtnVanish(hmu, maxWidTitle); BtnReappear(hmu, minWidTitle);
      IF cMm < minWidMm THEN BEGIN
        cMm := minWidMm;
        PrNumToStr(cMm, spMm);
        SpecSet(wid, '', '', spMm);
        fNewWid := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, minWidTitle);
  END;

  {deal with height}
  SpecRead(ht);

  {make height <= upper limit}
  IF htIsInches THEN BEGIN
    IF c16Total >= maxHt16 THEN BEGIN
      BtnVanish(hmu, minHtTitle); BtnReappear(hmu, maxHtTitle);
      IF c16Total > maxHt16 THEN BEGIN
        cIn := maxHt16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := maxHt16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(ht, spIn, sp16, '');
        fNewHt := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, maxHtTitle);
  END
  ELSE BEGIN
    IF cMm >= maxHtMm THEN BEGIN
      BtnVanish(hmu, minHtTitle); BtnReappear(hmu, maxHtTitle);
      IF cMm > maxHtMm THEN BEGIN
        cMm := maxHtMm;
        PrNumToStr(cMm, spMm);
        SpecSet(ht, '', '', spMm);
        fNewHt := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, maxHtTitle);
  END;

  {make height >= lower limit}
  IF htIsInches THEN BEGIN
    IF c16Total <= minHt16 THEN BEGIN
      BtnVanish(hmu, maxHtTitle); BtnReappear(hmu, minHtTitle);
      IF c16Total < minHt16 THEN BEGIN
        cIn := minHt16 DIV 16; PrNumToStr(cIn, spIn);
        c16 := minHt16 MOD 16; PrNumToStr(c16, sp16);
        SpecSet(ht, spIn, sp16, '');
        fNewHt := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, minHtTitle);
  END
  ELSE BEGIN
    IF cMm <= minHtMm THEN BEGIN
      BtnVanish(hmu, maxHtTitle); BtnReappear(hmu, minHtTitle);
      IF cMm < minHtMm THEN BEGIN
        cMm := minHtMm;
        PrNumToStr(cMm, spMm);
        SpecSet(ht, '', '', spMm);
        fNewHt := TRUE;
      END;
    END
    ELSE BtnVanish(hmu, minHtTitle);
  END;

  IF NOT fNewWid THEN IF widIsInches THEN Mod16(wid);
  IF NOT fNewHt  THEN IF htIsInches  THEN Mod16(ht);
END;
END;

{ ---------------------------------------------------------------------- }

FUNCTION Spec {hw: THtOrWid):  TL};
  {Current special-size height/width in prPgFract units, from the ckfm's strings}
VAR iInch, i16th, iMm, c:     TC;
    inches, in16ths, mm:      TL;
    sp:                       TSp;
    hsp:                      THSp;
BEGIN
WITH hCkfmFmt^^.rghmu[muSpecSize]^^ DO BEGIN
  SpecIndices(hw, iInch, i16th, iMm);   {select height or width}

  hsp := rgbtn[iInch].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, c);
  inches := ORD4(c) * PrPgFract;

  hsp := rgbtn[i16th].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, c);
  in16ths := (ORD4(c) * PrPgFract) DIV 16;

  hsp := rgbtn[iMm].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, c);
  mm := (ORD4(c) * PrPgFract * 10) DIV 254;

  Spec := (inches + in16ths + mm);
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE SpecGet {hw: THtOrWid};
  {Sets the strings of the special height/width buttons from the print record's dlgPgSz data.}
VAR spIn, sp16, spMm: TSp;
    recInch, rec16, recMm: TC;
BEGIN
WITH hckfmFmt^^.rghmu[muSpecSize]^^, pPrRecUsr^.prInfo.dlgPgSz DO BEGIN
  IF hw = ht
  THEN BEGIN recInch := htInch;  rec16 := ht16th;  recMm := htMM; END
  ELSE BEGIN recInch := widInch; rec16 := wid16th; recMm := widMM; END;
  PrNumToStr (ABS (recInch),  spIn);
  PrNumToStr (ABS (rec16),    sp16);
  PrNumToStr (ABS (recMm),    spMm);
  SpecSet(hw, spIn, sp16, spMm);
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE SpecLimits {maxHt, maxWid, minHt, minWid: TL};
VAR halfFract: TC;
BEGIN
  halfFract := prPgFract DIV 2;
  IF maxHt  > MAXINT      THEN maxHt  := MAXINT;
  IF maxWid > platenWidth THEN maxWid := platenWidth;
  IF minHt  < prPgFract   THEN minHt  := prPgFract;
  IF minWid < prPgFract   THEN minWid := prPgFract;

  maxHt16 := (((maxHt*16)+halfFract) DIV prPgFract)+1;
  WHILE ((maxHt16*prPgFract) DIV 16)>maxHt DO maxHt16 := maxHt16-1;

  maxWid16 := (((maxWid*16)+halfFract) DIV prPgFract)+1;
  WHILE ((maxWid16*prPgFract) DIV 16)>maxWid DO maxWid16 := maxWid16-1;

  maxHtMm := (((((maxHt*254)+halfFract) DIV prPgFract)+5) DIV 10)+1;
  WHILE ((maxHtMm*prPgFract*10) DIV 254)>maxHt DO maxHtMm := maxHtMm-1;

  maxWidMm := (((((maxWid*254)+halfFract) DIV prPgFract)+5) DIV 10)+1;
  WHILE ((maxWidMm*prPgFract*10) DIV 254)>maxWid DO maxWidMm := maxWidMm-1;

  minHt16 := ((minHt*16) DIV prPgFract)-1;
  WHILE ((minHt16*prPgFract) DIV 16)<minHt DO minHt16 := minHt16+1;

  minWid16 := ((minWid*16) DIV prPgFract)-1;
  WHILE ((minWid16*prPgFract) DIV 16)<minWid DO minWid16 := minWid16+1;

  minHtMm := (((minHt*254) DIV prPgFract) DIV 10)-1;
  WHILE ((minHtMm*prPgFract*10) DIV 254)<minHt DO minHtMm := minHtMm+1;

  minWidMm := (((minWid*254) DIV prPgFract) DIV 10)-1;
  WHILE ((minWidMm*prPgFract*10) DIV 254)<minWid DO minWidMm := minWidMm+1;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE SpecIndices {hw: THtOrWid; VAR iInch, i16th, iMm: TC};
  {Sets three VAR params to be either special-height btn indices or special-width btn indices}
BEGIN
  IF hw = ht
  THEN BEGIN iInch := iHtInch;  i16th := iHt16th;  iMm := iHtmm; END
  ELSE BEGIN iInch := iWidInch; i16th := iWid16th; iMm := iWidmm; END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE SpecRedraw {hw: THtOrWid};
  {Makes sure the special-size width buttons show the current numbers from the
   ckfm}
VAR iInch, i16th, iMm, c: TC;
    btn: TBtn;
BEGIN
WITH hCkFmFmt^^.rghmu[muSpecSize]^^ DO IF fMUActv THEN BEGIN
  SpecIndices(hw, iInch, i16th, iMm);                  {select height or width}
  btn := rgBtn[iInch]; BtnErase(btn); BtnDraw(btn);
  btn := rgBtn[i16th]; BtnErase(btn); BtnDraw(btn);
  btn := rgBtn[iMm];   BtnErase(btn); BtnDraw(btn);
END;
END;

{ ---------------------------------------------------------------------- }
PROCEDURE SpecSet {hw: THtOrWid; inch, in16, mm: TSp};
  {Set special-size height/width btn strings in the ckfm}
VAR iInch, i16th, iMm, c: TC;
BEGIN
WITH hCkfmFmt^^.rghmu[muSpecSize]^^ DO BEGIN
  SpecIndices(hw, iInch, i16th, iMm);   {select height or width}
  BtnSetSp(rgbtn[iInch], inch, FALSE);
  BtnSetSp(rgbtn[i16th], in16, FALSE);
  BtnSetSp(rgbtn[iMm],   mm,   FALSE);
END;
END;

{ ---------------------------------------------------------------------- }

FUNCTION SpecUnDef {hw: THtOrWid): TF};
  {Checks that the special size button strings define width/height, & that
   inches and mm are not mixed.  Returns TRUE if width is bad.}
VAR f: TF;
    iInch, i16th, iMm, c: TC;
BEGIN
WITH hCkfmFmt^^.rghmu[muSpecSize]^^ DO BEGIN
  f := Spec(hw)=0;                                {find out if all 3 buttons are blank}
  IF NOT f
  THEN BEGIN                                      {find out if inches and mm are mixed}
  SpecIndices(hw, iInch, i16th, iMm);             {select height or width}
         IF rgbtn[iMm].hsp^^[0] <> CHR(0)
            THEN IF rgbtn[i16th].hsp^^[0] <> CHR(0)
                 THEN f := TRUE
                 ELSE IF rgbtn[iInch].hsp^^[0] <> CHR(0)
                      THEN f := TRUE;
  END;
  SpecUnDef := f;
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE StuffSpecSize;
  {Takes special-size strings from the ckfm, converts them to numbers, &
   stuffs the numbers into the print record.  Then converts the numbers to
   prPgFract units & stuffs them into the rgPaperHt & rgPaperWid arrays}
VAR sp:   TSp;
    hsp:  THSp;
BEGIN
WITH hckfmFmt^^.rghmu[muSpecSize]^^, pPrRecUsr^.prInfo.dlgPgSz DO IF fMUActv THEN BEGIN
  hsp := rgBtn[iWidInch].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, widInch);
  hsp := rgBtn[iWid16th].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, wid16th);
  hsp := rgBtn[iWidmm].hsp;   sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, widmm);
  hsp := rgBtn[iHtInch].hsp;  sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, htInch);
  hsp := rgBtn[iHt16th].hsp;  sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, ht16th);
  hsp := rgBtn[iHtmm].hsp;    sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, htmm);

  rgPaperHt [iPgSpec] := (ORD4(htInch)*PrPgFract)
                       + ((ORD4(ht16th)*PrPgFract) DIV 16)
                       + ((ORD4(htmm)*PrPgFract*10) DIV 254);
  rgPaperWid[iPgSpec] := (ORD4(widInch)*PrPgFract)
                       + ((ORD4(wid16th)*PrPgFract) DIV 16)
                       + ((ORD4(widmm)*PrPgFract*10) DIV 254);
END;
END;

{ ---------------------------------------------------------------------- }

FUNCTION SetIcons {dlgStarting: TF): TF};    {!DC 3/17/84}
  {Makes the correct set of orientation icons appear, depending on what paper orientations
   are possible with the current paper size.  If this makes the current "on" button disappear,
   the "on" button is defaulted.  Must only be called after special size and standard size
   are validated & special size is stuffed; depends on integrity of the rgPaperWid &
   rgPaperHt arrays.}
VAR visBtns:   TBtnSet;
    i:         TB;
    XW, XH:    TL;
    changed:   TF;                               {!DC 3/17/84 - identifier change, cosmetic}
    hMu:       THMu;
BEGIN
WITH hCkfmFmt^^, rghmu[muOrient]^^ DO BEGIN
  changed := FALSE;
  visBtns := [];
  FOR i := 1 TO cBtn DO IF rgBtn[i].lx.fBtnVis THEN visBtns := visBtns + [i];
  XW := rgPaperWid[rghmu[muPSize]^^.iBtnOn];
  XH := rgPaperHt[rghmu[muPSize]^^.iBtnOn];
  hMu := rghmu[muOrient];

  IF (XW > PlatenWidth) OR (XH > PlatenWidth) OR (XW = XH)  {!DC 3/17/84 - remainder of proc changed}
  THEN BEGIN {portrait paper loading only}
    IF visBtns <> [paperPortrait] THEN BEGIN
      MuPush(hMu, paperPortrait);
      BtnVanish (hMu, paperLandscape);
      changed := TRUE;
    END;
  END
  ELSE BEGIN {either paper loading}
    IF visBtns <> [paperPortrait, paperLandscape] THEN BtnReappear(hMu, paperLandscape);
    IF NOT dlgStarting
    THEN IF XW <= XH THEN MuPush (hMu, paperPortrait)
                     ELSE MuPush (hMu, paperLandscape);
    changed := TRUE;
  END;
  SetIcons := changed;
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FmtSetUp {pPrRecIn: TPprRec; fSpecSizeSuppress: TF};
  {Sets up everything for the "Format" dialog, just before it runs}
VAR f, fTW, fTH, wrongBtn: TF;
    setIDMu: TSetIdMu;
BEGIN
  IF fSpecSizeSuppress THEN setIDMu := [0] ELSE setIDMu := setIdMuAll;
  pPrRecUsr := pPrRecIn;                                         {set up generic ptr to the print record}
  CkFmSetUp (hckfmFmt, TRUE {fInit}, setIDMu);                   {PrDlgMgr's ckfm initialization}
  FmtCkSet;                                                      {info from print record to checkform}
  hckfmPrCk := hckfmFmt;                                         {set generic handle for the ckfm}
  IF SpecUnDef(wid) THEN SpecSet(wid, '8', '8', '');             {make sure special-size stuff & paper size...}
  IF SpecUnDef(ht) THEN SpecSet(ht, '11', '', '');               {..."on" btn are kosher}
  FitSpecSize(fTW, fTH);
  StuffSpecSize;
  verifySpecSize := FALSE;                                       {!DC 3/17/84}
  WITH hCkfmFmt^^ DO BEGIN
    WITH rghmu[muPSize]^^ DO BEGIN                     {make sure page size btn is valid}
      IF fSpecSizeSuppress THEN BtnVanish(rghmu[muPSize], iPgSpec);
      wrongBtn := NOT (iBtnOn IN validPSize);                         {undefined btn for this printer}
      IF wrongBtn THEN muPush(rghmu[muPSize], iBtnStd);
      oldSize := iBtnOn;                               {!DC 3/17/84}
    END;
    f := SetIcons (TRUE);                              {make icons right}  {!DC 3/17/84}
    PsPortName(pPrRecUsr^.PrInfo.Port,rghmu[muDoIt]^^.rgBtn[iPortMsg].hsp);
                                                       {get port descriptor string}
  END;
  procCkCmd := @FmtCkCmd;                              {stuff PrDlgMgr procs}
  DlgInstall (TRUE, @PrCkEvent, @PrCkTrkMse, @FmtEnd);
  DlgOpen (hckfmFmt^^.rBB.bottom);                     {open the dlg window & init its grafport}
  CkFmShow (hckfmFmt, TRUE{fInit});                    {display the ckfm}
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FmtCkSet;
  {Turns on buttons and sets up strings for each menu when the dialog
   starts up.}
VAR i: TC;
BEGIN
WITH hckfmFmt^^, pPrRecUsr^.prInfo DO BEGIN
  FOR i := 0 TO cMu DO BEGIN
    WITH rghmu[i]^^ DO BEGIN
      IF fMuActv AND NOT fMuVis THEN CASE i OF
        muDoIt:      iBtnOn := iBtnNil;         {initially no "on" btn in this menu}
        muPSize:     iBtnOn := dlgPgSz.pgSzBtn; {turn on a page size btn}
        muSpecSize:  BEGIN
                       iBtnOn := iBtnNil;       {no "on" btn in this menu}
                       SpecGet(wid);            {stuff numbers into btn strings}
                       SpecGet(ht);
                     END;
        muOrient:    WITH pgSize DO CASE PrintDirect OF           {turn on an orientation icon}
                       Portrait:  CASE PaperDirect OF
                                    Portrait:  iBtnOn := paperPortrait;
                                    Landscape: iBtnOn := paperLandscape;
                                    OTHERWISE  iBtnOn := paperPortrait;
                                  END;
                       OTHERWISE  iBtnOn := paperPortrait;
                     END;
      END {case};
    END; {with menu}
  END; {for}
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FmtCkCmd {iMu, iBtn: TC};
     {Bottleneck proc for responding to a particular button-push.}
VAR btn: TBtn;
    f, fNewWid, fNewHt, fWidJunk, fHtJunk: TF;
BEGIN
  IF iMu <> muSpecSize THEN CkFmKeys(hCkFmFmt, iMuNil, iBtnNil); {if it's a standard size then
                                                                  ignore keystrokes}

  CASE iMu OF
    muDoIt:       DlgEnd (FALSE); {FFmtDlg calls FCkFmHit to find whether IDoItYes was pushed.}
    muPSize:      BEGIN
                    IF iBtn = iPgSpec THEN BEGIN                {validate special-size data}
                      fWidJunk := SpecUnDef(wid);                 {if width data is junk...}
                      IF fWidJunk THEN SpecGet(wid);              {...then get previous width}
                      fHtJunk := SpecUnDef(ht);                   {if height data is junk...}
                      IF fHtJunk THEN SpecGet(ht);                {...then get previous height}
                      FitSpecSize(fNewWid, fNewHt);               {force data to be within bounds}
                      StuffSpecSize;                              {update print rec & size arrays}
                      IF fWidJunk OR fNewWid THEN SpecRedraw(wid);{update the screen}
                      IF fHtJunk OR fNewHt THEN SpecRedraw(ht);
                      IF verifySpecSize OR (iBtn <> oldSize)      {!DC 3/17/84}
                      THEN f := SetIcons (FALSE);                 {update orientation menu} {!DC 3/17/84}
                    END
                    ELSE IF iBtn <> oldSize                       {!DC 3/17/84}
                         THEN f := SetIcons (FALSE);              {update orientation menu}
                    verifySpecSize := FALSE;                      {!DC 3/17/84}
                    oldSize := iBtn;                              {!DC 3/17/84}
                  END;
    muSpecSize:   WITH hCkFmFmt^^, rghmu[muSpecSize]^^ DO BEGIN
                    CkFmKeys(hCkFmFmt, iMu, iBtn);  {this btn gets keystrokes}
                    iBtnOn := iBtnNil;              {prevent this btn being pushed when next btn is hit;
                                                     type-in btns should not be left "on"}
                    CASE iBtn OF
                      iWidInch,
                      iWid16th: BtnSetSp (rgbtn[iWidmm], '', TRUE);    {blank the mm btn}
                      iWidmm:   BEGIN                                  {blank the inch/16ths btns}
                                  BtnSetSp (rgbtn[iWidInch], '', TRUE);
                                  BtnSetSp (rgbtn[iWid16th], '', TRUE);
                                END;
                      iHtInch,
                      iHt16th:  BtnSetSp (rgbtn[iHtmm], '', TRUE);    {blank the mm btn}
                      iHtmm:    BEGIN                                 {blank the inch/16ths btns}
                                  BtnSetSp (rgbtn[iHtInch], '', TRUE);
                                  BtnSetSp (rgbtn[iHt16th], '', TRUE);
                                END;
                    END;
                    IF (rghmu[muPSize]^^.iBtnOn = iPgSpec) THEN verifySpecSize := TRUE;     {!DC 3/17/84}
                 END;
    muOrient:    BEGIN END;
  END;
END;

{ ---------------------------------------------------------------------- }

FUNCTION FFmtDlg {VAR prRec: TprRec; VAR fNewStl: TF;
                  maxHt, maxWid, minHt, minWid: TC;
                  fSpecSizeSuppress: TF): DlgOption};
  {Runs the "Format" dialog}
VAR prRecIn, prRecTmp:   TprRec;
    fBadRec:             TF;
    usrWid, usrHt:       TC;
    pDWRec: TpDWRec;
BEGIN
  PsNonPreemptive;
  GetPort(savePort);
  SetPort(@dlgPort);
  SpecLimits (maxHt, maxWid, minHt, minWid);
  fNewStl := FALSE;
  fBadRec := NOT FPrPrfValid (prRec);
  IF fBadRec THEN DWDefMetrics (prRec);
  prRecIn := prRec;      {prRecIn is left untouched for comparison at end}
  prRecTmp:= prRec;      {prRecTmp is used to record changes caused by the dlg,
                          then used to update prRec if user dismisses by OK button}

  FmtSetup (@prRecTmp, fSpecSizeSuppress);   {get everything ready...}
  DlgMain;                                   {...and run the dialog}

  IF FCkfmHit (hckfmFmt, muDoIt, iDoItYes)   {if dlg was dismissed with "OK"...}
  THEN BEGIN                                 {...put info from ckfm into the PrRec}
    FFmtDlg := eDlgOK;
    prRec := prRecTmp;                         {copy info that has been maintained during the dlg}
    WITH hckfmFmt^^, prRec.prInfo, pgSize DO BEGIN
      WITH rgHMu[muOrient]^^ DO CASE iBtnOn OF
        paperPortrait: BEGIN PaperDirect := Portrait;  PrintDirect := Portrait;  END;
        paperLandscape: BEGIN PaperDirect := Landscape; PrintDirect := Portrait;  END;
      END;
      WITH rghmu[muPSize]^^ DO BEGIN
        dlgPgSz.pgSzBtn := iBtnOn;      {other fields of dlgPgSz have been maintained}
        usrWid := rgPaperWid[iBtnOn];   {temp variables used here to reduce indexing below}
        usrHt  := rgPaperHt[iBtnOn];
        CASE PaperDirect OF
          Portrait:  BEGIN
                       Width  := Minimum (usrWid, usrHt);
                       Height := Maximum (usrWid, usrHt);
                     END;
          Landscape: BEGIN
                       Width  := Maximum (usrWid, usrHt);
                       Height := Minimum (usrWid, usrHt);
                     END;
        END;
      END;
      pDWRec := POINTER(@prRec.PrDevInfo);
    END; {with hckfmFmt^^, prRec.prInfo, pgSize}
    RhMetrics (prRec);
  END {if FCkfmHit (hckfmFmt, muDoIt, iDoItYes)}
  ELSE IF FCkfmHit (hckfmFmt, muDoIt, iNewPr)
       THEN  FFmtDlg := eDlgAnother
       ELSE {neither iDoIt nor iNewPr} FFmtDlg := eDlgCancel;

  fNewStl := NOT FPrPrfEq(prRecIn,prRec);
  fNewStl := fNewStl OR fBadRec;
  SetPort(savePort);
  PsPreemptive;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE FmtEnd {fDismiss: TF};
  {Bottleneck proc for ending the "Format" dialog (becomes procEnd in the PrDlgMgr
   code).  Does what's needed between the time you hit a dismiss btn and the time the
   dlg is erased from the screen.}
VAR fW, fH, fTW, fTH, fI: TF;
    hMu:    THMu;
  PROCEDURE WaitABit;
  VAR timeStart: TL;
  BEGIN
    BusyDelay(0);
    timeStart := Time;
    REPEAT UNTIL (ABS (Time-timeStart) > 200);
  END;
  PROCEDURE FlashMu (hMu: THMu);
  BEGIN
    MuErase(hMu); MuShow(hMu); MuErase(hMu); MuShow(hMu);
  END;
BEGIN
WITH hckfmFmt^^ DO BEGIN
  hMu := rghmu[muDoIt];
  IF fDismiss THEN MuPush (hMu, iBtnStd);    {if dismissed by a click outside the window, push "OK"}
  IF hMu^^.iBtnOn = iDoItYes                 {!DC 3/17/84 - remainder of proc changed}
  THEN IF verifySpecSize
       THEN BEGIN
              fW := SpecUnDef(wid);          {make sure the special width stuff is kosher}
              fH := SpecUnDef(ht);
              IF fW THEN SpecGet(wid);
              IF fH THEN SpecGet(ht);
              FitSpecSize(fTW, fTH);
              StuffSpecSize;                 {store special width stuff in print record & size arrays}
              IF fW OR fH OR fTW OR fTH
              THEN FlashMu (rghmu[muSpecSize]);

              fI := SetIcons (FALSE);        {fix orientation mu if special width changed}
              IF fI
              THEN FlashMu (rghmu[muOrient]);

              IF fI OR fW OR fH OR fTW OR fTH
              THEN WaitABit;                 {if anything changed, wait & let user notice it}
            END;
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE InsSetUp {pPrRecIn: TPprRec; dlgMode: prMenuSuppress};
  {Sets up everything for the "Print..." dialog, just before it runs}
VAR setIDMu: TSetIdMu;
BEGIN
  pPrRecUsr := pPrRecIn;                                 {set up generic ptr to the print record}
  setIDMu := [0];                                        {show vanilla menus}
  IF dlgMode <> ePgRangeSuppress
  THEN setIDMu := setIDMu + [1];                         {show page range menu}
  IF pPrRecUsr^.prInfo.pgSize.printDirect = portrait
  THEN setIDMu := setIDMu + [2];                         {show draft menu}
  CkFmSetUp (hckfmIns, TRUE {fInit}, setIDMu);           {PrDlgMgr's ckfm initialization}
  InsCkSet;                                              {info from print record to checkform}
  hckfmPrCk := hckfmIns;                                 {set generic handle for the ckfm}
  PsPortName (pPrRecUsr^.PrInfo.Port,
        hCkFmIns^^.rgHMu[muDoIt]^^.rgBtn[iPortMsg].hsp); {get port descriptor string} {!DC 4/30/84}
  IF dlgMode <> ePrDialogSuppress THEN BEGIN
    procCkCmd := @InsCkCmd;                              {stuff PrDlgMgr procs}
    DlgInstall (TRUE, @PrCkEvent, @PrCkTrkMse, @InsEnd);
    DlgOpen (hckfmIns^^.rBB.bottom);                     {open the dlg window & init its grafport}
    CkFmShow (hckfmIns, TRUE{fInit});                    {display the ckfm}
  END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE InsCkSet;
  {Turns on buttons when the dialog starts up, for those menus that should be "remembered"
   from the print record.  Will include the hires/lores menu if that is put into this dlg.}
VAR i: TC;
    pDWRec: TpDWRec;
    hMu: THMu;
BEGIN
  pDWRec := POINTER(ORD(@pPrRecUsr^.PrDevInfo));
  WITH hckfmIns^^, pDWRec^.DWCfg DO BEGIN
    WITH rghmu[muFeeder]^^ DO CASE feeder OF
      feedFanFold: iBtnOn := iFanFold;
      feedCut:     iBtnOn := iSingleSheet;
      feedMechCut: iBtnOn := iMechFeed;
      OTHERWISE    iBtnOn := iFanFold;
    END;
    WITH rghmu[muWheel]^^ DO CASE wheel OF
      eWhcl20:  iBtnOn := iWhcl15;
      eWhcl15:  iBtnOn := iWhcl15;
      eWhcl12:  iBtnOn := iWhcl12;
      eWhcl10:  iBtnOn := iWhcl10;
      eWhclPS:  iBtnOn := iWhclPS;
      eWhclMF:  iBtnOn := iWhclMF;
      eWhclMP:  iBtnOn := iWhclMP;
      eWhclLCS: iBtnOn := iWhclLCS;
      OTHERWISE iBtnOn := iWhcl12;
    END;
    WITH rghmu[muDRAFT]^^ DO CASE mode OF
      HighRes: iBtnOn := iFinished;
      Draft:   iBtnOn := iDraft;
    END;
  END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE InsCkCmd {iMu, iBtn: TC};
     {Bottleneck proc for responding to a particular button-push.}
VAR btn: TBtn;
    f, fNewWid, fNewHt, fWidJunk, fHtJunk: TF;
BEGIN
WITH hCkFmIns^^ DO BEGIN
  IF iMu <> muPgSelect THEN CkFmKeys(hCkFmIns, iMuNil, iBtnNil); {ignore keystrokes}
  CASE iMu OF
    muDoIt:      DlgEnd (FALSE); {FInsDlg calls FCkFmHit to find whether IDoItYes was pushed.}
    muFeeder:    BEGIN END;
    muWheel:     BEGIN END;
    muCopies:    BEGIN END;
    muPgSelect:  BEGIN
                   CASE iBtn OF
                     iAllPgs: WITH rgHMu[iMu]^^ DO BEGIN
                                BtnSetSp(rgBtn[iFirstPg], '', TRUE);
                                BtnSetSp(rgBtn[iLastPg], '', TRUE);
                                CkfmKeys (hckfmIns, iMuNil, iBtnNil);
                              END;
                     iSomePgs: BEGIN
                                 btn := rghmu[iMu]^^.rgbtn[iLastPg];
                                 btn.hsp^^[0] := CHR(0);
                                 BtnFill (btn, FALSE);
                                 CkfmKeys (hckfmIns, iMu, iFirstPg);
                               END;
                     iFirstPg, iLastPg: BEGIN
                                          MuPush (rghmu[iMu], iSomePgs);
                                          CkfmKeys (hckfmIns, iMu, iBtn);
                                        END;
                   END;
                 END;
  END;
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE InsEnd {fDismiss: TF};
  {Bottleneck proc for ending the "Print..." dialog (becomes procEnd in the PrDlgMgr
   code).  Does what's needed between the time you dismiss the dlg and the time the
   dlg is erased from the screen.}
BEGIN
WITH hckfmIns^^ DO BEGIN
  IF fDismiss
  THEN MuPush (rghmu[muDoIt], iBtnStd); {if dismissed by a click outside the window, push "Cancel"}
END;
END;

{ ---------------------------------------------------------------------- }

FUNCTION FInsDlg {VAR prRec: TprRec; VAR fNewStl: TF; dlgMode: prMenuSuppress): TF};
  {Runs the "Print..." dialog}
VAR prRecIn, prRecTmp:   TprRec;
    fBadRec:   TF;
    c1, c2:    TC;
    sp:        TSp;
    hsp:       THSp;
    pDWRec:    TpDWRec;
BEGIN
  PsNonPreemptive;
  GetPort(savePort);
  SetPort(@dlgPort);
  fNewStl := FALSE;
  fBadRec := NOT FPrPrfValid (prRec);
  IF fBadRec THEN PrPrfDefault (prRec);
  prRecIn := prRec;      {prRecIn is left untouched for comparison at end}
  prRecTmp:= prRec;      {prRecTmp is used to record changes caused by the dlg,
                          then used to update prRec if user dismisses by OK button}

  InsSetup (@prRecTmp, dlgMode);                  {get everything ready...}
  IF dlgMode <> ePrDialogSuppress                 {...and if the dialog isn't suppressed...}
  THEN BEGIN                                      {...then run it}
         DlgMain;
       END
  ELSE PsYieldCPU;

  IF FCkfmHit (hckfmIns, muDoIt, iDoItYes)   {if dlg was dismissed with "OK"...}
     OR (dlgMode = ePrDialogSuppress)        {...or was suppressed...}
  THEN BEGIN                                 {...put info from ckfm into the PrRec}
    FInsDlg := eDlgOK;
    prRec := prRecTmp;                         {copy info that has been maintained during the dlg}
    pDWRec := POINTER(ORD(@prRec.PrDevInfo));
    WITH hckfmIns^^, prRec.prJobInfo DO BEGIN

      WITH rghmu[muPgSelect]^^ DO IF (dlgMode <> ePrNormal) OR (iBtnOn = iAllPgs) THEN BEGIN
        docPgFst := 1;   {set info in the print record}
        docPgLst := PrPageMax;
      END
      ELSE BEGIN                             {turn page range strings into numbers}
        hsp := rgBtn[iFirstPg].hsp; sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, c1);
        hsp := rgBtn[iLastPg].hsp;  sp := COPY (hsp^^, 1, ORD(hsp^^[0])); PrStrToNum(sp, c2);
        IF c1 = 0 THEN c1:=1;
        IF c2 = 0 THEN c2:=PrPageMax;
        docPgFst := CMIN(c1, c2);            {set info in the print record}
        docPgLst := CMAX(c1, c2);
      END;

      WITH pDWRec^.DWCfg DO BEGIN
        CASE rghmu[muFeeder]^^.iBtnOn OF
          iFanFold:      feeder := feedFanFold;
          iSingleSheet:  feeder := feedCut;
          iMechFeed:     feeder := feedMechCut;
        END;
        CASE rghmu[muWheel]^^.iBtnOn OF
          iWhcl15:  wheel := eWhcl15;
          iWhcl12:  wheel := eWhcl12;
          iWhcl10:  wheel := eWhcl10;
          iWhclPS:  wheel := eWhclPS;
          iWhclMF:  wheel := eWhclMF;
          iWhclMP:  wheel := eWhclMP;
          iWhclLCS: wheel := eWhclLCS;
        END;
        CASE rghmu[muDraft]^^.iBtnOn OF
          iFinished: mode := HighRes;
          iDraft:    mode := Draft;
        END;
      END;

      copies := rghmu[muCopies]^^.iBtnOn;
    END;
  END
  ELSE FInsDlg := eDlgCancel;

  fNewStl := NOT FPrPrfEq(prRecIn,prRec);
  fNewStl := fNewStl OR fBadRec;
  SetPort(savePort);
  PsPreemptive;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE DWDlgInit;
  {Should be called once by the printer process, when it begins to run.}
VAR DSPathname:     Pathname;
    cErr, i:        TC;
    DSAddr:         TL;
BEGIN
  PsNonPreemptive;
  GetPort(savePort);
  OpenPort(@dlgPort);
  DSPathname := DSSegname;
  OPEN_DATASEG (cErr, DSPathname, DDSRefNum, DSAddr, ldsndialog);
  SETACCESS_DATASEG (cErr, DDSRefNum, FALSE);                {read/write access}
  IF (cErr <= 0) THEN BEGIN
    pRgHCkFm := POINTER(ORD(DSAddr));
    hckfmFmt := POINTER(ORD(pRgHCkFm^[0]));
    hckfmIns := POINTER(ORD(pRgHCkFm^[1]));

    {init the size arrays, except for the iPgSpec elements, which may vary during the dlg and
     are maintained via the StuffSpecSize proc}
    FOR i := iPgFst TO iPgLst DO BEGIN
      rgPaperWid[i] := 0;
      rgPaperHt[i]  := 0;
    END;
    rgPaperWid[iPg8x11]   := (ORD4(510) * prPgFract) DIV 60;  {8.5"}
    rgPaperHt [iPg8x11]   := (ORD4(660) * prPgFract) DIV 60;  {11"}
    rgPaperWid[iPg8x14]   := rgPaperWid[iPg8x11];             {8.5"}
    rgPaperHt [iPg8x14]   := (ORD4(840) * prPgFract) DIV 60;  {14"}
    rgPaperWid[iPg14x11]  := rgPaperHt[iPg8x14];              {14"}
    rgPaperHt [iPg14x11]  := rgPaperHt[iPg8x11];              {11"}
    rgPaperWid[iPgA4]     := (ORD4(496) * prPgFract) DIV 60;  {210mm}
    rgPaperHt [iPgA4]     := (ORD4(700) * prPgFract) DIV 60;  {297mm}
    rgPaperWid[iPg210x12] := rgPaperWid[iPgA4];               {210mm}
    rgPaperHt [iPg210x12] := (ORD4(720) * prPgFract) DIV 60;  {12"}
    rgPaperWid[iPg310x8]  := (ORD4(732) * prPgFract) DIV 60;  {310mm}
    rgPaperHt [iPg310x8]  := (ORD4(480) * prPgFract) DIV 60;  {8"}

    PlatenWidth           := (ORD4(840) * prPgFract) DIV 60;  {14"}
    validPSize := [iPg8x11, iPg8x14, iPg14x11, iPgA4, iPg210x12, iPg310x8, iPgSpec];
  END
  ELSE BEGIN
     DDSRefNum:=PrNilRefNum;
  END;
  SetPort(savePort);
  PsPreemptive;
  UNBIND_DATASEG(cErr,DDSRefNum);
END;

{ ---------------------------------------------------------------------- }
{!BH 2/24/84}
PROCEDURE DWDlgQuit;
VAR
   cErr:            TC;
BEGIN
  CLOSE_DATASEG(cErr,DDSRefNum);
END;

{ ---------------------------------------------------------------------- }

END.
{Changes:
           5/04/84 : BH -- Change to allow dialog dataseg to bound and unbound
           4/30/84 : DC -- InsSetup: call PsPortName to set port info string (a new button in the
                           button file, plus a dummy button to make the index come out right).
           3/17/84 : DC -- SetIcons: new parameter, new functionality to offer "smart" defaults to user
                             on orientation.
                           oldSize, verifySpecSize: new global variables for benefit of SetIcons.
                           FmtSetup: init oldSize & verifySpecSize.
                           FmtCkCmd: new functionality for benefit of SetIcons.
                           FmtDlg: new functionality for benefit of SetIcons.
}

ÿ