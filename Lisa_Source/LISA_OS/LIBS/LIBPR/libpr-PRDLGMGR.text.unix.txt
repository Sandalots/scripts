(*
$Exec
P?
-newdisk-intrinsic.lib
RUnits/DlgMgr
{no listing}
RUnits/Temp
GRUnits/Temp
RUnits/DlgMgr
$EndExec
*)
{                          NOTE: The above compiles this program.                          }
{------------------------------------------------------------------------------------------}
{                      Copyright 1983, 1984, Apple Computer Inc.                           }
{------------------------------------------------------------------------------------------}
UNIT PrDlgMgr;
INTRINSIC;

{$SETC fBtnRead  = FALSE}

{------------------------------------------------------------------------------------------}
                                        INTERFACE
{------------------------------------------------------------------------------------------}

USES
     {$U LibOS/SysCall    }  SysCall,
     {$U LibSM/UnitStd    }  UnitStd,
     {$U LibSM/UnitHz     }  UnitHz,
     {$U LibHW/HWInt      }  HWInt,

     {$U LibQD/QuickDraw  }  QuickDraw,
     {$U LibFM/FontMgr    }  FontMgr,
     {$U LibQD/Storage    }  Storage,

     {$U LibWM/Events     }  Events,
     {$U LibWM/Folders    }  Folders,
     {$U LibSB/WmlStd     }  WmlStd,
     {$U LibSB/WmlCrs     }  WmlCrs,
     {$U LibPM/PMDecl     }  PMDecl,
     {$U libPr/PrStdInfo  }  PrStdInfo;

{------------------------------------------------------------------------------------------}

CONST
   cInfinite = $7FFFFFFF; {Infinite (or nearly) cursor hour glass delay}
   cZero     = 0;         {Zero delay}
   cCursorDelay = 3500;   {3 and one half seconds to delay before the hour glass appears}
   cBtnMax   =31;         {The max number of menus in a check form}
   cMuMax    =31;         {The max number of buttons in a menu}
   idMuMax   =15;         {The max number of menu "Levels" in a menu}
                          {Note: these chosen so that can be used in SETs}
   iBtnNil = -1;          {NIL values for button & menu indices}
   iMuNil  = -1;
   iBtnStd = -2;          {The default button.}

   dhCkfmMarg  = 6;       {Ckfm margin}
   dvCkfmMarg  = 4;

{Btn Metrics:}
   dhSpToCk= 4;           {external dh from string to ckbox}
   dhSpToR = 3;           {internal dh from string to ckbox}
   dvSpToR = 1;           {internal dv from string to ckbox}
   cChNrMax= 4;           {Number of chars in a numeric parameter button}
   cChSpMax=15;           {Number of chars in a string parameter button}

   dtDlgEnd  =  25;       {Dlg End pause time}
   dtDlgMin  =  25;       {Minimum Dlg elapsed time; avoids double dismissal.}

   ckfmMax   = 5;         {ckfmMax+1 = Maximum number of checkforms in a data segment}{!BH}

TYPE

   TDBox = RECORD                {The dialog stream.}
      fKeyDlg:      TF;          {is this a keystroke dialog?}
      timeStrt:     TL;          {DlgMain: To avoid double dismissals.}
      procEvent:    TProc;       {procedure to process events}
      procIdle:     TProc;       {procedure to track cursor etc}
      procEnd:      TProc;       {procedure to end dialog}
   END;

   TEbtn  = (ebtnSq, ebtnRR, ebtnOv);
   TEqd   = (eqdLI, eqdCI, eqdRI, eqdRO); {Text Quad: rt, center, lt/In, Out}
   TEact  = (eactIn, eactCk, eactNr, eactSp, eactIc);
   TEnib  = (enibSm, enibLg );
   TRgnib = ARRAY [TEnib] OF Point;
   TLx = PACKED RECORD
      fam:     0..31;  {5}
      fB:      TF;     {1}
      fI:      TF;     {1}
      eact:    TEact;  {2}
      eqd:     TEqd;   {2}
      ebtn:    TEbtn;  {2}
      enib:    TEnib;  {1}
      fBtnVis: TF;     {1}  {!DC 1/13/84}
      mask:    CHAR;   {8}  {!DC 1/12/84}
      smax:    0..255; {8} {1 byte; gives the maximum length of hsp in a TBtn}
   END;                    {!BH: 1/18/84 uses smax instead of CbDataOfH}
                           {smax is here so that packing is most efficient in TBtn}
   TBtn  = RECORD
      r:       Rect;  {8 bytes; Could use "grain" of 3x2 bits &/or h,v,dh,dv=>2 bytes}
      lx:      TLx;   {4 bytes}
      hsp:     THsp;  {4 bytes; Could use isp in a rghsp: 1 byte}
   END;
   TRgbtn   = ARRAY [0..cBtnMax] OF TBtn;

   TIdMu    = 0..idMuMax;
   TSetIdMu = SET OF TIdMu;
   THmu     = ^TPmu;
   TPmu     = ^TMu;
   TMu      = RECORD
      rBB:        Rect;       {The menu's bounding box}
      idMu:       TIdMu;      {Menu "Level".  Used for clustering menus.}
      iBtnOn:     TB;         {The currently "ON" button.}
      iBtnUsr:    TB;         {The user's default button. Prog might change it.}
      cBtn:       TB;         {The total number of buttons.}
      fMuVis:     TF;         {Is the menu displayed?} {!DC 1/13/84, changed identifier throughout}
      fMUActv:    TF;         {Is it active?}          {!DC 1/13/84, changed identifier throughout}
      rgbtn:      TRgbtn;     {The menu's buttons.}
   END;
   TRghmu   = ARRAY [0..cMuMax] OF THmu;
      {fMUActv/fMuVis: The intent of fMuVis is "Can I See It?" & fMUActv is "Should I Show It".
       fMUActv allows redisplay of a modified ckfm with no flicker.
       While a ckfm is up & in use, these should be the same; either both T or F.
       They differ only during setup & display time.}

   THckfm   = ^TPckfm;
   TPckfm   = ^TCkfm;
   TCkfm    = RECORD
      rBB:     Rect;          {The check form's bounding box}
      iMuKey:  TB;            {The menu currently accepting key events.}
      iBtnKey: TB;            {..^'s button.}
      cMu:     TB;            {The total number of menus in the check form}
      rghmu:   TRghmu;        {The check form's menus.}
   END;

   TCkfmseg = RECORD          {!BH}
      ckfm     : ARRAY [0..ckfmMax] OF THckfm;  {The check forms in the data segment}
   END;                                   {NIL implies no more check forms}

VAR
   dbox:       TDBox;      {The current dialog}
   setIdMuAll: TSetIdMu;   {The "complete" set for IdMu's}
   hspNil:     THsp;       {An empty heap string.}
   finfoLx:    FontInfo;   {The font info for the current button.}
   rgnib:      TRgnib;     {The frame pen sizes.}
   pPrRecUsr:  TPprRec;    {Generic ptr to the print record}
   hckfmPrCk:  THckfm;     {Generic handle on checkform}
   procCkCmd:  TProc;      {Current proc for responding to button pushes}

{------------------------------------------------------------------------------------------}

{Unit initialization}
PROCEDURE DlgMgrInit;

{Miscellaneous}
PROCEDURE PauseEvt (dt: TC);
FUNCTION  FMseInFldr (pwnd: WindowPtr; VAR pt: Point): TF;
PROCEDURE PrStrToNum (spNum: TSp; VAR c: TC);
PROCEDURE PrNumToStr (c: TC; VAR spNum: TSp);
PROCEDURE PrCkEvent (event: EventRecord);
PROCEDURE PrCkTrkMse;

{Caret}
PROCEDURE CaretMove ( pwnd: WindowPtr; h, v: TC );
PROCEDURE CaretSynch;
PROCEDURE CaretKill;
PROCEDURE CaretFlip;
PROCEDURE CaretBlink;

{Dialog mechanism}
PROCEDURE DlgInstall  (fKey: TF; pEvent, pIdle, pEnd: TProc);
PROCEDURE DlgEvent (event: EventRecord);
PROCEDURE DlgIdle;
PROCEDURE DlgEnd   (fDismiss: TF);
PROCEDURE DlgOpen  (dv: TC);
FUNCTION  FDlgEvent(VAR event: EventRecord): TF;
PROCEDURE DlgMain;
FUNCTION  FDlgDone: TF;

{CheckForms}
FUNCTION  FCkfmSelect(hckfm: THckfm; ptMse: Point; VAR iMu,iBtn: TB): TF;
PROCEDURE CkFmSetUp  (hckfm: THckfm; fInit: TF; setIdMuActv: TSetIdMu);
PROCEDURE CkfmShow   (hckfm: THckfm; fInit: TF);
PROCEDURE CkfmTrkMse (hckfm: THckfm; pWnd: WindowPtr);
PROCEDURE CkfmKeys   (hckfm: THckfm; iMu, iBtn: TB);
PROCEDURE CkfmAddCh  (hckfm: THckfm; ch: CHAR);
FUNCTION  FCkfmNxtKey(hckfm: THckfm; VAR iMuNxt, iBtnNxt: TB): TF;
PROCEDURE CkfmSp     (hckfm: THckfm; iMu, iBtn: TB; VAR sp: TSp; fNew: TF);
FUNCTION  FCkfmHit   (hckfm: THckfm; iMu, iBtn: TB): TF;

{$IFC fBtnRead}
FUNCTION  HspAlloc (sp: TSp; cChMax: TC): THsp;
PROCEDURE HspFree  (VAR hsp: THsp);
FUNCTION  HCkfmRead  (VAR ckFile: Text): THckfm;
{$ENDC}

{Menus}
PROCEDURE MuShow    (hmu: THmu);
PROCEDURE MuErase   (hmu: THmu);
PROCEDURE MuPush    (hmu: THmu; iBtn: TB);
FUNCTION  FMuHit    (hmu: THmu; ptMse: Point; VAR iBtn: TB): TF;

{Buttons}
PROCEDURE BtnDraw       (btn: TBtn);
PROCEDURE BtnErase      (btn: TBtn);
PROCEDURE BtnFill       (btn: TBtn; fFlip: TF);
PROCEDURE BtnPtSp       (btn: TBtn; VAR ptSp: Point; VAR dhSp: TC);
PROCEDURE BtnWrite      (btn: TBtn; sp: TSp);
PROCEDURE BtnAddCh      (btn: TBtn; ch: CHAR);
PROCEDURE BtnBkSp       (btn: TBtn);
PROCEDURE BtnBind       (VAR lx: TLx);
PROCEDURE BtnSetSp      (btn: TBtn; sp: TSp; showIt: TF);
PROCEDURE BtnReappear   (hmu: THmu; iBtn: TB); {!DC 1/13/84}
PROCEDURE BtnVanish     (hmu: THmu; iBtn: TB); {!DC 1/13/84}

{------------------------------------------------------------------------------------------}
                                        IMPLEMENTATION
{------------------------------------------------------------------------------------------}
{$S PrBtn }

{$IFC PrSymbols}
{$D+}
{$ELSEC}
{$D-}
{$ENDC}
{$IFC PrDebug}
{$R+}
{$ELSEC}
{$R-}
{$ENDC}

CONST
   icrsBtnOn = icrsCheck; {The checkform "hit" cursor}
{$IFC fBtnRead}
   dataSize  = 10000;
{$ENDC}

VAR
   caret: RECORD
      pwnd:      WindowPtr;     {Current port}
      pt:        Point;         {Current pt}
      timeDelta: TC;            {Times for blink interval}
      timeStrt:  LongInt;
      fEven:     TF;            {used for fOnOff}
   END;

   spNil:  STRING[1];            {The hspNil objects}
   pspNil: TPsp;

   SavePort:  GrafPtr;
   MyPort:    GrafPort;

{$IFC fBtnRead}
   rBtnLst:    Rect;             {BtnRead's last bounding box.}
   ckFmData:   ARRAY[1..dataSize] OF -128..127;
   dlgHz:      THz;
{$ENDC}

{------------------------------------------------------------------------------------------}
{                                   PROCEDURE DIRECTORY                                    }
{------------------------------------------------------------------------------------------}

{$IFC fBtnRead}
FUNCTION  HMuRead  (VAR ckFile: Text): THmu;                                        FORWARD;
PROCEDURE BtnRead  (VAR ckFile: Text; VAR btn: TBtn);                               FORWARD;
{$ENDC}

PROCEDURE BtnScroll(ptSp: Point; dhSp, dhScroll: TC);                               FORWARD;
PROCEDURE BtnFlipIcon (btn: TBtn);  {!DC 1/12/84}                                   FORWARD;

{ calling procs }
PROCEDURE XDlgEvent   (event: EventRec; procEvent: TProc);                          EXTERNAL;
PROCEDURE XDlgIdle    (procIdle: TProc);                                            EXTERNAL;
PROCEDURE XDlgEnd     (fDismiss: TF; procEnd: TProc);                               EXTERNAL;
PROCEDURE XCkCmd (iMu, iBtn: TC; procCkCmd: TProc);                                 EXTERNAL;

{------------------------------------------------------------------------------------------}
{                                       Btn PROCS                                          }
{------------------------------------------------------------------------------------------}

PROCEDURE BtnAddCh {btn: TBtn; ch: CHAR};
VAR rSp:    Rect;
    ptSpOld, ptSpNew:  Point;
    dhSpOld, dhSpNew, cCh: TC;
  PROCEDURE BtnErr;
  VAR i: TC;
  BEGIN
    {$IFC fTracePR}    LogCall;     {$ENDC}
    FOR i := 1 TO 10 DO BEGIN
      BtnFill (btn, TRUE);
      PauseEvt (10);
    END;
    EXIT (BtnAddCh);
  END;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF btn.lx.fBtnVis THEN BEGIN  {!DC 1/13/84}
    BtnBind  (btn.lx);
    cCh  := LENGTH(btn.hsp^^);
    CASE btn.lx.eact OF
      eactNr: IF (cCh >= cChNrMax) OR (ch<'0') OR (ch>'9') OR ( (cCh=0) AND (ch='0') ) THEN BtnErr;
      eactSp: IF (cCh >= cChSpMax) THEN BtnErr;
      OTHERWISE BtnErr;
    END;
    BtnPtSp (btn, ptSpOld, dhSpOld);
    btn.hsp^^[cCh+1] := ch;
    btn.hsp^^[0]     := CHR(cCh+1);
    BtnPtSp (btn, ptSpNew, dhSpNew);
    IF cCh<>0 THEN BtnScroll (ptSpOld, dhSpOld, ptSpNew.h-ptSpOld.h);
    MoveTo (ptSpNew.h+dhSpNew-CharWidth(ch), ptSpNew.v);
    DrawChar (ch);
    CaretMove (thePort, ptSpNew.h + dhSpNew, ptSpNew.v);
  END;  {!DC 1/13/84}
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnBind {VAR lx: TLx};
{Add 2 params: fBindText, fBindPen?}
VAR fOk:      TF;
    cErr:     TC;
    lfntid:   TLfntid;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  lfntid.fam      := lx.fam;
  lfntid.seteface := [];
  lfntid.dev      := devScreen;
  IF lx.fB THEN lfntid.seteface := lfntid.seteface+[Bold];
  IF lx.fI THEN lfntid.seteface := lfntid.seteface+[Italic];

  fOk := FMFontMetrics (lfntid, finfoLx, cErr);
  IF NOT( fOk AND (cErr=0) ) THEN BEGIN
    lx.fam      := sysText;
    lfntid.fam  := sysText;
    fOk := FMFontMetrics (lfntid, finfoLx, cErr);
  END;
  IF NOT( fOk AND (cErr=0) ) THEN HALT; {***TEMP***}

  IF lx.eact <> eactIn THEN IF lx.eact <> eactIc THEN BEGIN
    PenSize (rgnib[lx.enib].h,rgnib[lx.enib].v);
    PenMode (8);
    IF lx.eact IN [eactNr,eactSp]
    THEN PenPat(gray)
    ELSE PenPat(black);
  END
  ELSE PenNormal; {*??*}

  TextFont (lx.fam);
  TextFace (lfntid.seteface);
  TextMode ( srcOr );
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnBkSp {btn: TBtn};
VAR ch:     CHAR;
    rCh:    Rect;
    ptSpOld, ptSpNew:  Point;
    dhSpOld, dhSpNew, dhCh, cCh: TC;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF btn.lx.fBtnVis THEN BEGIN  {!DC 1/13/84}
    cCh  := LENGTH(btn.hsp^^);
    IF cCh<>0 THEN BEGIN
      BtnBind  (btn.lx);
      ch   := btn.hsp^^[cCh];
      dhCh := CharWidth (ch);
      BtnPtSp (btn, ptSpOld, dhSpOld);
      SetRect (rCh, ptSpOld.h+dhSpOld-dhCh, ptSpOld.v-finfoLx.ascent,
                    ptSpOld.h+dhSpOld,      ptSpOld.v+finfoLx.descent);
      EraseRect (rCh);
      btn.hsp^^[0] := CHR(cCh-1);
      BtnPtSp (btn, ptSpNew, dhSpNew);
      IF cCh<>1 THEN BtnScroll (ptSpOld, dhSpNew {=dhSpOld-dhCh}, ptSpNew.h-ptSpOld.h);
      CaretMove (thePort, ptSpNew.h + dhSpNew, ptSpNew.v);
    END;
  END;  {!DC 1/13/84}
END;

{ ---------------------------------------------------------------------- }

PROCEDURE BtnFlipIcon {btn: TBtn};  {!DC 1/12/84}
{btn better be an icon button,}
VAR r: Rect;
    ptSp: Point;
    dhSp, dhOv, dvOv: TC;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF btn.lx.fBtnVis THEN BEGIN  {!DC 1/13/84}
    BtnBind (btn.lx);
    BtnPtSp(btn, ptSp, dhSp);
    MoveTo (ptSp.h, ptSp.v);
    TextMode(srcXor);
    DrawChar(btn.lx.mask);
    TextMode(srcOr);
  END;  {!DC 1/13/84}
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnDraw {btn: TBtn};
VAR r: Rect;
    ptSp: Point;
    dhSp, dhOv, dvOv: TC;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF btn.lx.fBtnVis THEN BEGIN   {!DC 1/13/84}
    BtnBind (btn.lx);
    BtnPtSp(btn, ptSp, dhSp);

    WITH btn.lx DO IF eact<>eactIn THEN IF eact<>eactIc THEN BEGIN {!DC 1/12/84}
      r := btn.r;
      IF btn.lx.eqd=eqdRO THEN r.right := r.right - dhSp - dhSpToCk;
      CASE btn.lx.ebtn OF
        ebtnSq: FrameRect (r);
        ebtnOv: FrameOval (r);
        ebtnRR: BEGIN
          dvOv := (2*(r.bottom-r.top)+2) DIV 3;
          dhOv := (1+dvOv*3) DIV 2;
          FrameRoundRect (r, dhOv, dvOv );
        END;
      END;
    END;

    MoveTo (ptSp.h, ptSp.v);
    DrawString (btn.hsp^^);
  END;   {!DC 1/13/84}
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnErase {btn: TBtn};
VAR rErase: Rect;
    ptSp: Point;
    dhSp: TC;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF btn.lx.fBtnVis THEN BEGIN   {!DC 1/13/84}
    BtnBind (btn.lx);
    BtnPtSp (btn, ptSp, dhSp);

    WITH finfoLx, btn.r DO BEGIN
      rErase.top    := CMIN (top,    ptSp.v-ascent);
      rErase.bottom := CMAX (bottom, ptSp.v+descent);

      rErase.left   := CMIN (left,   ptSp.h);
      rErase.right  := CMAX (right,  ptSp.h+dhSp);
    END;

    EraseRect (rErase);
  END;   {!DC 1/13/84}
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnFill {btn: TBtn; fFlip: TF};
VAR r: Rect;
    dhSp, dhOv, dvOv: TC;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF btn.lx.fBtnVis THEN WITH btn.lx DO BEGIN  {!DC 1/13/84}
    BtnBind (btn.lx);
    r := btn.r;

    dhSp := StringWidth (btn.hsp^^);
    IF eqd=eqdRO THEN r.right := r.right - dhSp - dhSpToCk;

    IF eact = eactIc     {!DC 1/12/84}
    THEN BEGIN           {!DC 1/12/84}
           IF fFlip THEN BtnFlipIcon(btn);
         END
    ELSE BEGIN  {!DC 1/12/84}
      IF eact<>eactIn THEN InSetRect(r, rgnib[enib].h, rgnib[enib].v);
      CASE ebtn OF
        ebtnSq: IF fFlip THEN InvertRect (r) ELSE FillRect (r, white);
        ebtnOv: IF fFlip THEN InvertOval (r) ELSE FillOval (r, white);
        ebtnRR: BEGIN
          dvOv := (2*(r.bottom-r.top+2*rgnib[enib].v)+2) DIV 3;
          dhOv := (1+dvOv*3) DIV 2;
          IF fFlip THEN InvertRoundRect (r, dhOv-2*rgnib[enib].h, dvOv-2*rgnib[enib].v)
                   ELSE FillRoundRect   (r, dhOv-2*rgnib[enib].h, dvOv-2*rgnib[enib].v, white);
        END {ebtnRR};
      END {case};
    END {else}
  END {if fBtnVis};
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnPtSp  {btn: TBtn; VAR ptSp: Point; VAR dhSp: TC};
VAR descentEffective: TC;  {!DC 1/12/84}
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH btn DO BEGIN
  dhSp := StringWidth (hsp^^);
  CASE lx.eqd OF
    eqdLI: IF lx.eact<>eactIn THEN ptSp.h := r.left + dhSpToR + rgnib[lx.enib].h
                              ELSE ptSp.h := r.left;
    eqdCI: ptSp.h := (r.right + r.left - dhSp) DIV 2;
    eqdRI: IF lx.eact<>eactIn THEN ptSp.h := r.right - dhSp - dhSpToR - rgnib[lx.enib].h
                              ELSE ptSp.h := r.right - dhSp;
    eqdRO: ptSp.h := r.right - dhSp;
  END;
  WITH finfoLx DO BEGIN
    descentEffective := descent;  {!DC 1/12/84}
    IF lx.eact <> eactIc THEN descentEffective := descentEffective DIV 3;  {!DC 1/12/84}
    {Note descent not fully included in calc, except for icon btn: aesthetics!}
    ptSp.v := (r.bottom + r.top + ascent - descentEffective) DIV 2;  {!DC 1/12/84}
  END;
END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnScroll {ptSp: Point, dhSp, dhScroll: TC};
{Assumes BtnBind called, & assumes the btn is visible.}
VAR hrgnUp: RgnHandle;
    rSp: Rect;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  SetRect (rSp, ptSp.h,      ptSp.v-finfoLx.ascent,
                ptSp.h+dhSp, ptSp.v+finfoLx.descent);
  IF dhScroll<>0 THEN BEGIN
    hrgnUp := NewRgn;
    IF dhScroll < 0 THEN rSp.left  := rSp.left  + dhScroll
                    ELSE rSp.right := rSp.right + dhScroll;
    ScrollRect (rSp, dhScroll, 0, hrgnUp);
    DisposeRgn (hrgnUp);
  END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnSetSp {btn: TBtn; sp: TSp; showIt: TF};
VAR cbSp: TC;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF btn.lx.fBtnVis THEN WITH btn DO BEGIN  {!DC 1/13/84}
    cbSp  := CMIN (LENGTH(sp)+1, lx.smax);   {!BH: 1/18/84 uses smax instead of CbDataOfH}
    sp[0] := CHR (cbSp-1);
    MoveLeft(sp, hsp^^, cbSp);
    IF showIt THEN BEGIN
      BtnErase (btn);
      BtnDraw (btn);
    END;
  END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnWrite {btn: TBtn; sp: TSp};
VAR cbSp: TC;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF btn.lx.fBtnVis THEN WITH btn DO BEGIN  {!DC 1/13/84}
    cbSp  := CMIN (LENGTH(sp)+1, lx.smax);  {!BH: 1/18/84 uses smax instead of CbDataOfH}
    sp[0] := CHR (cbSp-1);
    MoveLeft(sp, hsp^^, cbSp);

    BtnFill (btn, FALSE);
    BtnDraw (btn);
  END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnVanish {hmu: THmu; iBtn: TB}; {!DC 1/13/84}
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hmu^^ DO BEGIN
  IF iBtn = iBtnOn THEN MuPush(hmu, iBtnNil);
  IF fMuVis THEN BtnErase(rgBtn[iBtn]);
  rgBtn[iBtn].lx.fBtnVis := FALSE;
END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE BtnReappear {hmu: THmu; iBtn: TB}; {!DC 1/13/84}
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hmu^^, rgBtn[iBtn].lx DO BEGIN
  IF NOT fBtnVis THEN BEGIN
    fBtnVis := TRUE;
    IF fMuVis THEN BtnDraw(rgBtn[iBtn]);
  END;
END;
END;

{------------------------------------------------------------------------------------------}
{                                        Mu Procs                                          }
{------------------------------------------------------------------------------------------}

PROCEDURE MuErase { hmu: THmu };
VAR i: TC;
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hmu^^ DO BEGIN
  IF fMuVis THEN BEGIN
    FOR i := 0 TO cBtn DO BtnErase (rgbtn[i]);
    fMuVis := FALSE;
  END;
END;
END;

{------------------------------------------------------------------------------------------}

FUNCTION  FMuHit { hmu: THmu; ptMse: Point; VAR iBtn: TB): TF };
VAR i: TC;
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hmu^^ DO BEGIN
  FMuHit := FALSE;
  IF fMuVis AND PtInRect (ptMse, rBB) THEN BEGIN
    FOR i := 0 TO cBtn DO BEGIN
      IF PtInRect (ptMse, rgbtn[i].r) THEN BEGIN
        WITH rgbtn[i].lx DO IF eact<>eactIn THEN BEGIN
          IF fBtnVis THEN BEGIN
            FMuHit := TRUE;
            iBtn := i;
          END;
        END;
        EXIT (FMuHit);
      END;
    END;
  END;
END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE MuPush {hmu: THmu; iBtn: TB};
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hmu^^ DO BEGIN
  IF iBtn=iBtnStd THEN iBtn := iBtnUsr;
  IF fMuVis AND (iBtn<>iBtnOn) THEN BEGIN
    IF iBtnOn<>iBtnNil THEN BtnFill (rgbtn[iBtnOn], TRUE);
    IF iBtn<>iBtnNil   THEN BtnFill (rgbtn[iBtn], TRUE);
  END;
  iBtnOn := iBtn;
END;
END;

{ ---------------------------------------------------------------------- }

PROCEDURE MuShow { hmu: THmu };
VAR i: TC;
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hmu^^ DO BEGIN
  IF fMUActv {AND NOT fMuVis: Updates!} THEN BEGIN
    FOR i := 0 TO cBtn DO BtnDraw (rgbtn[i]);
    IF iBtnOn<>iBtnNil THEN BtnFill (rgbtn[iBtnOn], TRUE);
    fMuVis := TRUE;
  END;
END;
END;

{------------------------------------------------------------------------------------------}
{                                        CkForms                                           }
{------------------------------------------------------------------------------------------}

PROCEDURE CkfmAddCh {hckfm: THckfm; ch: CHAR};
VAR btn: TBtn;
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hckfm^^ DO BEGIN
  IF NOT ((iMuKey=iMuNil) OR (iBtnKey=iBtnNil))
  THEN BEGIN
    btn := rghmu[iMuKey]^^.rgbtn[iBtnKey];
    IF ch=CHR(ccBS)
    THEN BtnBkSp (btn)
    ELSE IF (ch=CHR(ccHT)) OR (ch=CHR(ccCR))
         THEN BEGIN
           IF FCkfmNxtKey (hckfm, iMuKey, iBtnKey)
           THEN XCkCmd (iMuKey, iBtnKey, procCkCmd); {!DC 1/11/84}
         END
         ELSE BtnAddCh (btn, ch);
  END;
END;
END;

{------------------------------------------------------------------------------------------}

FUNCTION  FCkfmHit  {hckfm: THckfm; iMu, iBtn: TB): TF};
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hckfm^^, rghmu[iMu]^^ DO BEGIN
  IF iBtn=iBtnStd THEN iBtn := iBtnUsr;
  FCkfmHit := iBtnOn=iBtn;
END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE CkfmKeys {hckfm: THckfm; iMu, iBtn: TB};
VAR btn:  TBtn;
    ptSp: Point;
    dhSp: TC;
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hckfm^^ DO BEGIN
  iMuKey  := iMu;
  iBtnKey := iBtn;
  IF (iMuKey=iMuNil) OR (iBtnKey=iBtnNil) THEN CaretKill
  ELSE BEGIN
    btn := rghmu[iMu]^^.rgbtn[iBtn];
    btn.hsp^^[0] := CHR(0);    {**Currently blank the field**}
    BtnFill (btn, FALSE);

    BtnBind (btn.lx);          {Install the caret}
    BtnPtSp (btn, ptSp, dhSp);
    CaretMove (thePort, ptSp.h + dhSp, ptSp.v);
  END;
END;
END;

{------------------------------------------------------------------------------------------}

FUNCTION  FCkfmNxtKey {hckfm: THckfm; VAR iMuNxt, iBtnNxt: TB): TF};
VAR iMu, iBtn: TB;
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hckfm^^ DO BEGIN
  FCkfmNxtKey := FALSE;
  FOR iMu := 0 TO cMu DO WITH rghmu[iMu]^^ DO BEGIN
    FOR iBtn := 0 TO cBtn DO WITH rgbtn[iBtn] DO BEGIN

      IF  (lx.eact IN [eactNr, eactSp])
          AND fMuVis
          AND ( ( (iMu=iMuNxt) AND (iBtn>iBtnNxt) )
               OR (iMu>iMuNxt) )
      THEN BEGIN
        iMuNxt := iMu; iBtnNxt := iBtn;
        FCkfmNxtKey := TRUE;
        EXIT (FCkfmNxtKey);
      END;

    END;
  END;
END;
END;

{------------------------------------------------------------------------------------------}

FUNCTION  FCkfmSelect {hckfm: THckfm; ptMse: Point; VAR iMu,iBtn: TB): TF};
VAR iMuLst, iBtnSav, icrs: TC;

  FUNCTION FCkfmHit: TF;
  VAR iMuTst: TB;
  BEGIN
    {$IFC fTracePR}    LogCall;     {$ENDC}
    FCkfmHit := FALSE;
    WITH hckfm^^ DO FOR iMuTst := 0 TO cMu DO BEGIN
      IF FMuHit (rghmu[iMuTst], ptMse, iBtn) THEN BEGIN
        iMu      := iMuTst;
        FCkfmHit := TRUE;
        EXIT (FCkfmHit);
      END;
    END;
  END;

BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  FCkfmSelect := FALSE;
  iMuLst      := 0;
  iBtnSav     := hckfm^^.rghmu[0]^^.iBtnOn;

  REPEAT
    IF FCkfmHit THEN BEGIN
      icrs := icrsBtnOn;
      FCkfmSelect := TRUE;
      IF iMu <> iMuLst THEN BEGIN
        MuPush (hckfm^^.rghmu[iMuLst], iBtnSav);
        iMuLst  := iMu;
        iBtnSav := hckfm^^.rghmu[iMuLst]^^.iBtnOn;
      END;
      MuPush (hckfm^^.rghmu[iMu], iBtn);
    END
    ELSE BEGIN
      icrs := icrsInactive;
      IF NOT PtInRect (ptMse, hckfm^^.rBB) THEN BEGIN
        {Maybe check just muLst instead of whole ckfm?}
        MuPush (hckfm^^.rghmu[iMuLst], iBtnSav);
        FCkfmSelect := FALSE;
      END;
    END;
    SetStdCursor(icrs);
    GetMouse(ptMse);
    LetOthersRun;
  UNTIL NOT StillDown;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE CkFmSetUp {hckfm: THckfm; fInit: TF; setIdMuActv: TSetIdMu};
VAR iMu, iBtn: TB;
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hckfm^^ DO BEGIN
  IF fInit THEN BEGIN
    iMuKey  := iMuNil;
    iBtnKey := iBtnNil;
  END;
  FOR iMu := 0 TO cMu DO WITH rghmu[iMu]^^ DO BEGIN
    fMUActv := idMu IN setIdMuActv;
    IF fInit THEN BEGIN
      fMuVis := FALSE;
      {Convention: first mu uses iBtnUser for dismiss.}
      IF iMu=0 THEN iBtnOn := iBtnNil
               ELSE iBtnOn := iBtnUsr;
      FOR iBtn := 0 TO cBtn DO rgbtn[iBtn].lx.fBtnVis := TRUE;  {!DC 1/13/84}
    END
    ELSE IF NOT fMUActv {AND fMuVis} THEN MuErase (rghmu[iMu]);
    {Set parameter buttons to empty.}
    FOR iBtn := 0 TO cBtn DO WITH rgbtn[iBtn] DO IF lx.eact IN [eactNr, eactSp] THEN hsp^^[0] := CHR(0);
  END;
END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE CkfmShow {hckfm: THckfm; fInit: TF};
{fInit => NOT from an update event.}
VAR iMu: TB;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  WITH hckfm^^ DO
   FOR iMu := 0 TO cMu DO
    WITH rghmu[iMu]^^ DO
     IF NOT (fInit AND fMuVis) THEN MuShow(rghmu[iMu]);
END;

{------------------------------------------------------------------------------------------}

PROCEDURE CkfmSp {hckfm: THckfm; iMu, iBtn: TB; VAR sp: TSp; fNew: TF};
{Does not simply return the btn's hsp due to possibly manipulating the data.}
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hckfm^^.rghmu[iMu]^^ DO BEGIN
  IF iBtn=iBtnStd THEN iBtn := iBtnUsr;
  IF fNew THEN sp[0] := CHR(0);
  sp := CONCAT (sp, rgbtn[iBtn].hsp^^);
  IF sp[LENGTH(sp)] = ' ' THEN BEGIN
    WHILE sp[LENGTH(sp)] = ' ' DO sp[0] := CHR(LENGTH(sp)-1);
    sp := CONCAT (sp, rgbtn[iBtn+1].hsp^^);
  END;
END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE CkfmTrkMse {hckfm: THckfm; pWnd: WindowPtr};
LABEL 1;
VAR icrs: TC;
    iMu, iBtn: TB;
    ptMse: Point;
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH hckfm^^ DO BEGIN
  icrs := icrsInactive;
  IF FMseInFldr ( pWnd, ptMse ) THEN BEGIN
    FOR iMu := 1 {0} TO cMu DO BEGIN   {iMu=0: Use icrsInactive (Dismiss) }
      IF FMuHit (rghmu[iMu], ptMse, iBtn) THEN BEGIN
        icrs := icrsBtnOn;
        GOTO 1;
      END;
    END;
  END;
1: SetStdCursor(icrs);
END;
END;

{------------------------------------------------------------------------------------------}
{                                         CARETS                                           }
{------------------------------------------------------------------------------------------}

PROCEDURE CaretFlip;
VAR r:     Rect;
    finfo: FontInfo;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  SetPort ( caret.pwnd );
  GetFontInfo (finfo);
  SetRect (r, 0, -finfo.ascent, 1, finfo.descent);
  OffsetRect (r, caret.pt.h, caret.pt.v);
  InvertRect (r);
  caret.timeStrt := Time;
  caret.fEven    := NOT caret.fEven;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE CaretBlink;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF caret.pwnd <> NIL THEN IF ABS(Time - caret.timeStrt) > caret.timeDelta THEN CaretFlip;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE CaretMove {pwnd: WindowPtr; h, v: TC};
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF (caret.pwnd<>pwnd) OR (caret.pt.h<>h) OR (caret.pt.v<>v) THEN BEGIN
    CaretSynch;
    caret.pt.h := h;
    caret.pt.v := v;
    caret.pwnd := pwnd;
  END;
  CaretFlip;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE CaretKill;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  CaretSynch;
  caret.pwnd := NIL;
END;
{------------------------------------------------------------------------------------------}

PROCEDURE CaretSynch;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF NOT caret.fEven THEN CaretFlip;
END;

{------------------------------------------------------------------------------------------}
{                                       Dialogs                                            }
{------------------------------------------------------------------------------------------}

FUNCTION  FDlgDone{: TF};
VAR wndInfo: WindowInfo;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  GetWindInfo (dialogFolder, wndInfo);
  FDlgDone := NOT wndInfo.visible
END;

{------------------------------------------------------------------------------------------}

PROCEDURE DlgEnd {fDismiss: TF};
VAR timeStrt:  LongInt;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  timeStrt := Time;
  IF dbox.fKeyDlg THEN CaretKill;
  IF dbox.procEnd <> NIL THEN BEGIN
    SetPort (dialogFolder);
    XDlgEnd (fDismiss, dbox.procEnd);
  END;
  REPEAT LetOthersRun UNTIL (ABS (Time-timeStrt) > dtDlgEnd);
  DialogHeight(0,FALSE);
  DlgInstall(FALSE,NIL,NIL,NIL);
  SetStdCursor(icrsInactive);
  BusyDelay(cCursorDelay);
END;

{------------------------------------------------------------------------------------------}

PROCEDURE DlgEvent {event: EventRecord};
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF dbox.procEvent <> NIL THEN BEGIN
    SetPort (dialogFolder);
    XDlgEvent (event, dbox.procEvent);
  END;
END;

{------------------------------------------------------------------------------------------}

FUNCTION  FDlgEvent {VAR event: EventRecord): TF};
VAR hEvent: EventHandle;
    fEvent: TF;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  {We are the active process for all intents and purposes so...}
  BusyDelay(cInfinite);
  fEvent := FALSE;
  CheckEvents(TRUE);          {--Enable update events}
  hEvent := FirstEvent;
  WHILE hEvent <> NIL DO WITH hEvent^^ DO BEGIN
    IF    (who = dialogFolder)
       OR ((what = keyDown) AND (dbox.fKeyDlg))
       OR (what = folderupdate)                 {!DC 4/26/84}
    THEN BEGIN
      fEvent := TRUE;
      event  := hEvent^^;
      event.who := dialogFolder;
      DeleteEvent (hEvent);
      hEvent := NIL;
    END
    ELSE IF (what = buttonUp) THEN BEGIN
      DeleteEvent (hEvent);
      hEvent := NIL;
    END
    ELSE IF what IN [buttonDown,keyDown,filerEvent,abortEvent,folderDeactivate] THEN BEGIN
      IF (what <= keyDown) AND ( ABS(Time-dbox.timeStrt) < dtDlgMin )
      THEN DeleteEvent (hEvent)
      ELSE DlgEnd (TRUE);
      hEvent := NIL;
    END
    ELSE hEvent := NextEvent(hEvent);
  END {while};
  IF fEvent THEN GlobalToLocal (event.where);
  FDlgEvent := fEvent;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE DlgInstall { fKey: TF; pEvent, pIdle, pEnd: TProc };
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
WITH dbox DO BEGIN
  fKeyDlg     := fKey;
  procEvent   := pEvent;
  procIdle    := pIdle;
  procEnd     := pEnd;
END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE DlgMain;
{Main Loop for dialogs.}
VAR event: EventRecord;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  dbox.timeStrt := Time;
  WHILE NOT FDlgDone DO BEGIN {NOP Loop allowed.}
    IF FDlgEvent (event) THEN BEGIN
      {Turn off the caret during events. Crude but safe!}
      CaretSynch;
      DlgEvent (event);
    END
    ELSE DlgIdle;
    LetOthersRun;
  END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE DlgOpen  {dv: TC};
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  DialogHeight (dv, FALSE);
  SetPort  (dialogFolder);
  SetOrigin (0,0);
  ClipRect (dialogFolder^.portRect);
  FillRect (dialogFolder^.portRect,white);
END;

{------------------------------------------------------------------------------------------}

PROCEDURE DlgIdle;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF dbox.procIdle <> NIL THEN BEGIN
    SetPort(dialogFolder);
    XDlgIdle (dbox.procIdle);
  END;
  IF dbox.fKeyDlg THEN CaretBlink;
END;

{------------------------------------------------------------------------------------------}
{                                         Msc                                              }
{------------------------------------------------------------------------------------------}

FUNCTION FMseInFldr { pWnd: WindowPtr; VAR pt: Point) : TF };
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  SetPort (pWnd);
  GetMouse (pt);
  FMseInFldr := PtInRgn ( pt, pWnd^.visRgn );
END;

{------------------------------------------------------------------------------------------}

PROCEDURE PauseEvt {dt: TC};
VAR timeStrt:  LongInt;
  FUNCTION FKeyOrBtn: TF;
  VAR hEvent: EventHandle;
  BEGIN
    {$IFC fTracePR}    LogCall;     {$ENDC}
    {We are the active process for all intents and purposes so...}
    BusyDelay(cInfinite);
    FKeyOrBtn := FALSE;
    hEvent    := FirstEvent;
    WHILE hEvent <> NIL DO WITH hEvent^^ DO BEGIN
      IF what IN [buttonDown,keyDown] THEN BEGIN
        FKeyOrBtn := TRUE;
        EXIT (FKeyOrBtn);
      END
      ELSE hEvent := NextEvent(hEvent);
    END;
  END;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  timeStrt := Time;
  REPEAT LetOthersRun UNTIL (ABS (Time-timeStrt) > dt) OR (FKeyOrBtn);
END;

{------------------------------------------------------------------------------------------}

PROCEDURE PrStrToNum {spNum: TSp; VAR c: TC};               {!DC 1/11/84}
VAR i, spLength: TC;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  c := 0;
  spLength := LENGTH(spNum);
  FOR i := 1 TO spLength DO c := c * 10 + (ORD(spNum[i]) - 48);
END;

{------------------------------------------------------------------------------------------}

PROCEDURE PrNumToStr { c: TC; VAR spNum: TSp };    {!DC 1/11/84}
VAR spDig: STRING[1];
    fNeg: TF;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  spNum[0] := CHR( 0 );
  IF c <> 0 THEN BEGIN
    spDig[0] := CHR( 1 );
    fNeg := c<0;
    IF fNeg THEN c := -c;
    REPEAT
      spDig[1]:= CHR(c MOD 10+ORD('0'));
      spNum   := CONCAT( spDig, spNum );
      c       := c DIV 10;
    UNTIL c = 0;
    IF fNeg THEN spNum := CONCAT( '-', spNum );
  END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE PrCkEvent {event: EventRecord};
VAR iMu, iBtn: TB;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF event.who = dialogFolder THEN BEGIN {Could remove this test!?}
    SetPort (dialogFolder);
    CASE event.what OF
      buttonDown: IF FCkFmSelect (hckfmPrCk, event.where, iMu, iBtn) THEN XCkCmd (iMu, iBtn, procCkCmd);
      keyDown: CkfmAddCh (hckfmPrCk, event.ascii);
       {This is needed: Alerts can overlay dialogs!
        Oops! The WMgr doesnt seem to generate updates!}
      folderUpdate: BEGIN
        BeginUpdate(dialogFolder);              {!DC 4/9/84}
        CkFmShow   (hckfmPrCk, FALSE{fInit});
        EndUpdate  (dialogFolder);              {!DC 4/9/84}
      END;
    END;
  END;
END;

{------------------------------------------------------------------------------------------}

PROCEDURE PrCkTrkMse;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  CkfmTrkMse (hckfmPrCk, dialogFolder);
END;

{------------------------------------------------------------------------------------------}
{                                       Init Code                                          }
{------------------------------------------------------------------------------------------}
{$S PrBtnInit }

{$IFC fBtnRead}
FUNCTION  HspAlloc {sp: TSp; cChMax: TC): THsp};
VAR hsp: THsp;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  cChMax := CMAX (cChMax, LENGTH(sp));
  IF (cChMax=0) AND (hspNil<>NIL) THEN HspAlloc := hspNil
  ELSE BEGIN
     hsp := POINTER (ORD (HAllocate (dlgHz, cChMax+1)));
     MoveLeft(sp, hsp^^, LENGTH(sp)+1);
     HspAlloc := hsp;
  END;
END;
{$ENDC}

{------------------------------------------------------------------------------------------}

{$IFC fBtnRead}
PROCEDURE HspFree {VAR hsp: THsp};
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  IF hsp<>hspNil THEN FreeH (dlgHz, POINTER (ORD(hsp)));
  hsp := hspNil;
END;
{$ENDC}

{------------------------------------------------------------------------------------------}

{$IFC fBtnRead}
PROCEDURE BtnRead {VAR ckFile: Text; VAR btn: TBtn}; {!DC 1/12/84}
{Format: hhh vvv dhh dvv R fam BIQAT Label}
VAR sp:        TSp;
    hsp:       THsp;
    lx:        TLx;
    r:         Rect;
    h, v, dh, dv, fam, cChSp, iconCode, maskCode: TC;
    chRel, chB, chI, chQd, chAct, chTyp, ch: CHAR;
   PROCEDURE BtnError;
   BEGIN
      {$IFC fTracePR}    LogCall;     {$ENDC}
      HALT;
   END;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  GetPort (SavePort); {save current grafPort}
  OpenPort (@MyPort); {use local grafPort}
  READ (ckFile, h, v, dh, dv, ch, chRel, fam, ch, chB, chI, chQd, chAct, chTyp, ch);
{/ convention: If preceeded by blank, then spacer; else a parameter string to be written to later.}

  lx.fam  := fam;
  lx.fB   := (chB   ='B'); {Use 'b' for not bold, etc.}
  lx.fI   := (chI   ='I');
  CASE chAct OF            {Use upper case only here.}
    'I': lx.eact := eactIn;
    'C': lx.eact := eactCk;
    'N': lx.eact := eactNr;
    'S': lx.eact := eactSp;
    'K': lx.eact := eactIc;
    OTHERWISE BtnError;
  END;

  IF chAct = 'K'
  THEN BEGIN
    READLN(ckFile, iconCode, maskCode);
    sp[0] := CHR(1);
    sp[1] := CHR(iconCode);
    lx.mask := CHR(maskCode);
  END
  ELSE BEGIN
    READLN(ckFile, sp);
    cChSp := LENGTH(sp);
    IF (sp[cChSp] = '/')  AND  (sp[cChSp-1] = ' ') THEN sp[0] := CHR(cChSp-1);
  END;

  CASE chAct OF
    'I', 'C': hsp := HspAlloc (sp, 0{LENGTH(sp)});
    'N': hsp := HspAlloc (sp, cChNrMax);
    'S': hsp := HspAlloc (sp, cChSpMax);
    'K': hsp := HspAlloc (sp, LENGTH(sp));
  END;
   IF (hsp <> hspNil) THEN BEGIN  {!BH: 1/19/84}
      lx.smax:=CbDataOfH(hz,POINTER(hsp));
   END
   ELSE BEGIN
      lx.smax:=2;
   END;

  IF (sp[LENGTH(sp)]='/')
  THEN IF chAct <> 'K'
       THEN hsp^^[0] := CHR(0);

  CASE chQd OF
    'l': lx.eqd := eqdLI;
    'c': lx.eqd := eqdCI;
    'r': lx.eqd := eqdRI;
    'R': lx.eqd := eqdRO; {Note: Should only be a eactCk box.}
    OTHERWISE BtnError;
  END;
  CASE chTyp OF
    's': BEGIN lx.ebtn := ebtnSq; lx.enib := enibSm; END;
    'S': BEGIN lx.ebtn := ebtnSq; lx.enib := enibLg; END;
    'r': BEGIN lx.ebtn := ebtnRR; lx.enib := enibSm; END;
    'R': BEGIN lx.ebtn := ebtnRR; lx.enib := enibLg; END;
    'o': BEGIN lx.ebtn := ebtnOv; lx.enib := enibSm; END;
    'O': BEGIN lx.ebtn := ebtnOv; lx.enib := enibLg; END;
    OTHERWISE BtnError;
  END;

  BtnBind (lx);
{If negative, use 100-ths of an inch.}
  IF h<0  THEN h  := ( -h*9) DIV 10;  {Neg: hundredths}
  IF v<0  THEN v  := ( -v*6) DIV 10;
  IF dh<0 THEN dh := (-dh*9) DIV 10;
  IF dv<0 THEN dv := (-dv*6) DIV 10;

{dh: adjust for "ck boxes" or dh=0 => string width.}
  IF lx.eqd = eqdRO THEN dh := dh + StringWidth (hsp^^) + dhSpToCk;
  IF dh=0 THEN BEGIN {Note: ^=>eqd is "inside"}
    CASE lx.eact OF
      eactCk, eactIn, eactIc: dh := StringWidth (hsp^^);
      eactNr: dh := cChNrMax*finfoLx.widMax;
      eactSp: dh := cChSpMax*finfoLx.widMax;
    END;
    IF NOT(lx.eact IN [eactIn, eactIc]) THEN dh := dh + 2*dhSpToR + 2*rgnib[lx.enib].h;
  END;

{dv: dv=0 => string height.}
  IF dv=0 THEN BEGIN
    dv := finfoLx.ascent + finfoLx.descent;
    IF NOT(lx.eact IN [eactIn, eactIc]) THEN dv := dv + 2*dvSpToR + 2*rgnib[lx.enib].v;
  END;

  h := h + dhCkfmMarg; v := v + dvCkfmMarg;
{"relative mode"=> h/v relative to last rect.}
  CASE chRel OF
    'L': h := rBtnLst.left - dh - h + rgnib[lx.enib].h - dhCkfmMarg;
    'R': h := rBtnLst.right    +  h - rgnib[lx.enib].h - dhCkfmMarg;
    'T': v := rBtnLst.top  - dv - v + rgnib[lx.enib].v - dvCkfmMarg;
    'B': v := rBtnLst.bottom   +  v - rgnib[lx.enib].v - dvCkfmMarg;
     '=': ;
     OTHERWISE BtnError;
  END;

{v/h=0 and "relative mode"=> center on last rect.}
  CASE chRel OF
    'L','R': IF v=dvCkfmMarg THEN v:=(rBtnLst.top+rBtnLst.bottom-dv) DIV 2;
    'T','B': IF h=dhCkfmMarg THEN h:=(rBtnLst.right+rBtnLst.left-dh) DIV 2;
  END;

  btn.hsp   := hsp;
  btn.lx    := lx;
  SetRect (btn.r, h, v, h+dh, v+dv);
  rBtnLst := btn.r;
  IF lx.eqd=eqdRO THEN WHILE (sp[LENGTH (sp)] = ' ') DO BEGIN {**OK for 0 lng?**}
    rBtnLst.right := rBtnLst.right - CharWidth (' ');
    sp[0] := CHR( LENGTH(sp)-1 );
  END;

  SetPort (SavePort); {restore previous grafPort}
END;
{$ENDC}

{------------------------------------------------------------------------------------------}

{$IFC fBtnRead}
FUNCTION HMuRead {VAR ckFile: Text): THmu};
{Format: muID  cBtn dhh dvv}
VAR i, idMu, cBtn, iBtnUsr: TC;
    hmu:   THmu;
    spComment: Str255;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  READLN (ckFile, idMu, cBtn, iBtnUsr, spComment);
  hmu := POINTER (ORD (HAllocate (dlgHz, SizeOf(TMu)-(cBtnMax-cBtn)*SIZEOF(TBtn))));

  hmu^^.idMu    := idMu;
  hmu^^.iBtnOn  := iBtnNil;
  hmu^^.iBtnUsr := iBtnUsr;
  hmu^^.cBtn    := cBtn;
  hmu^^.fMuVis  := FALSE;
  hmu^^.fMUActv := TRUE {idMu=0??};

  FOR i := 0 TO cBtn DO WITH hmu^^, rgbtn[i] DO BEGIN
    BtnRead (ckFile, rgbtn[i]);
    IF i=0 THEN rBB := r ELSE UnionRect(rBB, r, rBB);
  END;
  READLN (ckFile, spComment);

  HMuRead := hmu;
END;
{$ENDC}

{------------------------------------------------------------------------------------------}

{$IFC fBtnRead}
FUNCTION HCkfmRead {VAR ckFile: Text): THckfm};
VAR i, cMu: TC;
    hmu: THmu;
    hckfm: THckfm;
    rBB: Rect;
    spComment: Str255;
BEGIN
  {$IFC fTracePR}    LogCall;     {$ENDC}
  READLN (ckFile, cMu, spComment);
  hckfm := POINTER (ORD (Hallocate (dlgHz, SIZEOF(TCkfm) - (cMuMax-cMu) * SIZEOF(THmu))));

  FOR i := 0 TO cMu DO BEGIN
    hmu := HMuRead(ckFile);
    hckfm^^.rghmu[i] := hmu;
    IF i=0 THEN rBB := hmu^^.rBB ELSE UnionRect(rBB,hmu^^.rBB, rBB);
  END;
  rBB.right   := rBB.right  + dhCkfmMarg;
  rBB.bottom  := rBB.bottom + dvCkfmMarg;

  hckfm^^.cMu       := cMu;
  hckfm^^.rBB       := rBB;
  hckfm^^.iMuKey    := iMuNil;
  hckfm^^.iBtnKey   := iBtnNil;

  HCkfmRead     := hckfm;
END;
{$ENDC}

{------------------------------------------------------------------------------------------}

PROCEDURE DlgMgrInit;
VAR cErr: TC;
    {$IFC fBtnRead} pFst, pLim: TP; {$ENDC}
BEGIN
{$IFC fTracePR}    LogCall;     {$ENDC}
{$IFC fBtnRead}
  pFst := @ckFmData;
  pLim := POINTER(ORD(pFst)+(dataSize));
  dlgHz:= HzInit(pFst, pLim, pFst, 64, 0, NIL, NIL, NIL, NIL);
{$ENDC}
  spNil  := '';
  pspNil := POINTER(ORD(@spNil));
  hspNil := @pspNil;
  rgnib [enibSm].h :=  1;  rgnib [enibSm].v := 1;
  rgnib [enibLg].h :=  3;  rgnib [enibLg].v := 2;

  setIdMuAll  := [0..15];

{$IFC fBtnRead}
  WITH rBtnLst DO BEGIN      {Don't SetRect: SegSwap!!}
    right := 0;
    left  := 0;
    top   := 0;
    bottom:= 0;
  END;
{$ENDC}
  WITH caret DO BEGIN
    timeDelta := 50;
    timeStrt  := 0;         {Don't call Time: SegSwap!!}
    fEven     := TRUE;
    pwnd      := NIL;
    pt.h      := 0;
    pt.v      := 0;
  END;
  WITH dbox DO BEGIN         {Don't call DlgInstall: SegSwap!!}
    fKeyDlg     := FALSE;
    procEvent   := NIL;
    procIdle    := NIL;
    procEnd     := NIL;
  END;
END;

{------------------------------------------------------------------------------------------}

END.

{
UNIT PrDlgMgr CHANGE LOG:
      4/26/84 DC: FDlgEvent - fix the code to handle folderUpdate event
      4/26/84 BH: FDlgEvent - fix the code to generate folderUpdate event with call to CheckEvents(TRUE)
      4/09/84 DC: FDlgEvent - add code to handle folderUpdate event, so it will be passed on to
                  DlgEvent & then to dbox.procEvent bottleneck (normally PrCkEvent).
      4/09/84 DC: PrCkEvent - preempt folderUpdate events intended for other, use them to update
                  the dialog folder.
      2/01/84 BH: Added data segment checkform TYPE and ckfmMax CONST.
      1/18/84 BH: Changed references to cbDataofH to refer to smax, a new field of TLx in TBtn
      1/13/84 DC: Capability to hide individual buttons.
      1/12/84 DC: Iconic buttons.
      1/11/84 DC: PrStrToNum: made c the VAR parameter, instead of spNum.
      1/11/84 DC: PrNumToStr: changed so that 0 produces a null string instead of '0'.
      1/11/84 DC: CkfmAddCh: changed to call prCkCmd instead of CkFmKeys when user
                  types HT or CR.
      1/06/84 DC: Added 2 constants, cLongestDelay & cCursorDelay.
      1/06/84 DC: FDlgEvent & PauseEvent: deleted EventAvail call & added BusyDelay call.
      1/06/84 DC: DlgEnd: added BusyDelay call.
      1/ 5/84 BH: Added my changes for background dialogs. New name (old was DlgMgr).
     12/28/83 DC: Derived this unit from PrMgrUtil.
}


ÿ