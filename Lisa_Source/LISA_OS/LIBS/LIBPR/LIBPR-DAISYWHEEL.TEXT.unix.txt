{ link exec
$EXEC
L?
+W
-NewDisk-intrinsic.lib

LibPr/DaisyWheel
LibPr/DWDlg
LibPr/DW68K
-NewDisk-PrLib
-NewDisk-sys1lib
-NewDisk-iospaslib


LibPr/System.PR_Daisy Wheel
fdSystem.PR_Daisy Wheel
ycLibPr/System.PR_Daisy Wheel.obj,-NewDisk-System.PR_Daisy Wheel Printer
y
q
$ENDEXEC
}

{                    NOTE: The above links this program.                        }
{-------------------------------------------------------------------------------}
{                Copyright 1983, 1984, Apple Computer Inc.                      }
{-------------------------------------------------------------------------------}
{$S DaisyWheel}
PROGRAM DaisyWheel;

{<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>}

USES
    {$U LibSM/UnitStd     } UnitStd,
    {$U LibSM/UnitHz      } UnitHz,
    {$U LibOS/SysCall     } SysCall,
    {$U LibPM/PMDecl      } PMDecl,
    {$U LibPM/PMM         } PMM,
    {$U LibOS/PSysCall    } PSysCall,
    {$U LibPL/PPasLibC    } PPasLibC,
    {$U LibQD/Storage     } Storage,
    {$U LibQD/QuickDraw   } QuickDraw,
    {$U LibQD/GrafUtil    } GrafUtil,
    {$U LibFM/FontMgr     } FontMgr,
    {$U LibFM/FmgrUtil    } FmgrUtil,
    {$U LibWM/Events      } Events,
    {$U LibWM/Menus       } Menus,
    {$U LibWM/Windows     } Windows,
    {$U LibWM/Folders     } Folders,
    {$U libSB/WmlStd      } WmlStd,
    {$U libSB/WmlCrs      } WmlCrs,
    {$U LibAM/AlertMgr    } AlertMgr,
    {$U LibHW/HwInt       } HwInt,
    {$U LibPr/PrStdInfo   } PrStdInfo,
    {$U LibPr/PrStdProcs  } PrStdProcs,
    {$U LibPr/Queues      } Queues,
    {$U LibPr/PrEvents    } PrEvents,
    {$U LibPr/PrDlgMgr    } PrDlgMgr,
    {$U LibPr/PrMgr       } PrMgr,
    {$U LibPr/PrBuf       } PrBuf,
    {$U LibPr/PrFileProcs } PrFileProcs,
{$U-}
    {$U LibPr/DWDlg       } DWDlg;

{$SETC PrDebug = FALSE}

{================================================================================}

{$IFC PrDebug}
  {$R+}
{$ELSEC}
  {$R-}
{$ENDC}

{$IFC PrSymbols}
  {$D+}
{$ELSEC}
  {$D-}
{$ENDC}

{$S DaisyWheel}

{================================================================================}
CONST
{-------------------------------  Main  Constants  ------------------------------}

  fdevdbg     = FALSE;
  fInReverse  = FALSE;

  {--Alert Constants}
  CacheSize     = 5;
  CacheBytes    = 2500;
  sDWAlertFile  = 'System.DW.';
  cAxCutRollerBack  = 5;            {Cut sheet and we are going to roll back the paper}
  cAxFeedSheet      = 6;            {Cut sheet and user must manually feed a new sheet}
  cAxFanRollerBack  = 7;            {Fan feed and paper must be rolled back,(not used)}
  cAxHardChange     = 8;            {The hardware has changed since last printing}
  cAxDifficulties   = 9;            {Hardware io problem}

  {--Heap Stuff for Background Printing}
  sPicDataSeg   = 'DWPicDataSeg';   {Name of our picture data seg}
  cPicDataSize  = $2000;            {Initial data segment size to begin}
  cPicLDSN      = 6;                {LDSN to use for this data seg}

  {--Heap for QuickDraw and Window Manager}
  sQDHeapName   = 'DWQDHeap';
  QDheapSize    = 2560;
  QDheapldsn    = 8;

  sProcessPrefix    = 'System.PR_';

  lDSmemsize  = 2048;                     {Initial DS memory size}
  lDSdsksize  = 2048;                     {Initial DS disk size}

  iJobID    = 1;
  icopies   = 2;
  iPtrID    = 3;
  iPortID   = 4;

{-------------------------------  RhDev Constants  ------------------------------}

  qxFirst   = -8;
  qxLast    = 1560{1680, 1584};
  qyFirst   = -4;
  qyLast    = 1023;
  qdxLast   = 15;
  cRhMaxBuf = 511;             {Maximum size of print buffer - 1}
  RhRollerGap = 54;            {7/8 of an inch gap}

  {--Convenient non-characters}
  FF = 12; SO = 14; SI = 15; SUB = 26; ESC = 27; US = 31; SP = 32;

  {Qume command characters; generally preceded by ESC.}
  cmReset1 = SUB;   cmReset2  = 'I';
  cmCrLfOn = ',';   cmCrLfOff = '.';
  cmPCtlOn = SO;    cmPCtlOff = SI;      cmPCtlSP = US;
  cmRvrsOn = '6';   cmRvrsOff = '5';
  cmFormLng= 'F';   cmHSpacing= 'E';     cmVSpacing = 'L';
  cmDx = 'H';       cmDy = 'V';

  cmLangSel= 'l';   cmLangStd = 'A';     cmLangWP  = 'B';

{------------------------------  RhProcs Constants  -----------------------------}

  hResolution = 0000000120;
  vResolution = 0000000048;

  PrMaxBand  = 16000;

{-------------------------------  Dialog Constants  -----------------------------}

(*  DSSegname = 'dwBtnData';

  {The menu and button indices.}
  muDoIt     = 0;                      {This mu serves for both dlgs}
    iDoItYes      = 0;  {"OK" btn}
    iDoItNo       = 1;  {"Cancel" btn}
    iNewPr        = 2;  {"New Printer" btn}
    iNotConnected = 4;  {"Not Connected at Present!" message}

{Menus for the Format... dialog}

  muPSize    = 1;
   {Button indices from PrStdInfo:
    iPg8x11 = 1; iPg8x14   = 2; iPg14x11  = 3;
    iPgA4   = 4; iPg210x12 = 5; iPg310x8  = 6;
    iPgSpec = 7;
    iPgFst = 0; iPgMax = 15;}

    iPgLst = 7;

  muSpecSize = 2;
    iWidInch = 2; iWid16th = 4; iWidmm = 7;
    iHtInch  =10; iHt16th  =12; iHtmm  =15;
    maxWidTitle = 17; maxHtTitle = 18;
    minWidTitle = 19; minHtTitle = 20;

  muOrient   = 3;
    iOrientTitle  = 0;  {"Paper Orientation" title}
    PapPImNR = 1;       {Portrait paper loading, image Not Rotated (icon btn)}
    PapLImNR = 2;       {Landscape paper loading, image Not Rotated (icon btn)}

{Menus for the Print... dialog}

  muDraft = 1;
    iFinished = 0; iDraft = 1;

  muFeeder = 2;
    iFanFold = 1; iSingleSheet = 2; iMechFeed = 3;

  muWheel = 3;
    iWhcl15 = 1; iWhcl12 = 2; iWhcl10 = 3;
    iWhclPS = 4; iWhclMF = 5; iWhclMP = 7; iWhclLCS= 8;

  muCopies = 4;
    {in this menu the number of copies selected = the btn number}

  muPgSelect = 5;
    iAllPgs = 1; iSomePgs = 2; iFirstPg = 3; iLastPg = 5;
*)
{================================================================================}
TYPE

{----------------------------------  RhDev Types  -------------------------------}

    TSpoke = PACKED ARRAY[0..1] OF CHAR;
    TQx = qxFirst..qxLast;      {The qm carriage range.}
    TQy = qyFirst..qyLast;      {The small neg values adjusts for the center strike model.}
    TQdx = 0..qdxLast;          {Rh delta x motion for PgmCtl.}
    THammer = 0..7;             {Rh hammer intensities.}

    TPRhDev = ^TRhDev;
    THRhDev = ^TPRhDev;
    TRhDev = RECORD
        rollerGap: TC;          {Roller gap to use}
        x: TC;                  {The next location of the Rh print head.}
        y: TC;
        xOld: TC;               {The current location of the Rh print head.}
        yOld: TC;
        rgChBuf: PACKED ARRAY[0..cRhMaxBuf] OF CHAR;
        cCharsBuf: TC;
    END;

{--------------------------------  RhProc Types   ------------------------------}

    TSpkHam = PACKED RECORD
        spoke: TSpoke;
        fMacro: TF;
        fBoldOK: TF;
        ham: THammer;
    END;

    TmpccSpkHam = PACKED ARRAY[0..767] OF CHAR;

    TccMacro = PACKED RECORD
        bOp: TB;
        CASE BOOLEAN OF             {!PR:SpokeTables} {Trick record field added to allow CHAR reference}
            TRUE : (bOperand: TB  );
            FALSE: (bChar: CHAR);
    END;
    TrgMacros= PACKED ARRAY[0..15575] OF TccMacro;  {--Maximum number of TccMacro for record structure}

    TSpokeOffsets = RECORD
        cULoffset: TC;      {Offset from the middle of the underscore image and the
                             baseline position of the spoke }
        cULlocation: TC;    {Desired location of the underscore relative to baseline }
        cHRuleoffset: TC;   {Offset from the left of the underscore image and the center
                             strike position of the spoke }
        cVRuleoffset: TC;   {Offset from the top of the bar's image and the base line
                             strike position of the spoke }
        cVRuleHeight: TC;   {Height of the vertical bar in 48ths}
        cHRuleWidth: TC;    {Width of the horizontal bar in 120ths}
        cVRuleHalf: TC;     {"Half height" of bar for overlapping rules}
        cHRuleHalf: TC;     {Half Width of the horizontal bar for overlapping rules}
    END;
    TPSpokeOffset = ^TSpokeOffset;
    THSpokeOffset = ^TPSpokeOffset;

    TSpokeEtc = RECORD
        ksfiller: ARRAY [0..12] OF TC;

        spokeOffsets: TSpokeOffsets;         {Spoke offsets stuff}

        mpccSpkHam: TmpccSpkHam;
        rgMacros: TrgMacros;
    END;
    TPSpokeEtc  = ^TSpokeEtc;
    THSpokeEtc  = ^TPSpokeEtc;

{----------------------------  Main Dev and Dlg Types  --------------------------

    TFeeder   = (feedCut,feedFanfold,feedMechCut,feedOther);
    TPrintMode= (HighRes,Draft);
    TTyScan   = (tyScanTB,tyScanLR);

    TDWInfo   = RECORD
      tyScan      : TTyScan;
      cPatScale,
      cULThick,
      cULOffset,
      cULShadow   : TC;

      rRoller     : Rect;
      rBand       : Rect;
      rBounds     : Rect;
      lBandSize   : TL;
      numBands    : TC;
      DeltaHBand  : TC;
      DeltaVBand  : TC;
    END;

    TDWCfg    = RECORD
      feeder  : TFeeder;
      mode    : TPrintMode;
      wheel   : TEwhcl;             (*the print wheel*)
    END;

    TpDWRec   = ^TDWRec;
    TDWRec    = RECORD
      DWInfo  : TDWInfo;
      DWCfg   : TDWCfg;
    END;

{================================================================================}

VAR
  cError          : TC;
  DWAlertFile     : TAlertFile;

  Listen          : Channel;
  ListenCall      : Channel;
  QDHrefnum       : TC;
  PicRefNum       : TC;
  FilRefNum       : TC;
  DWPrinter       : ThPrPrinter;
  JLPrRec         : TPrRec;         {Job latent PrRec}
  DWPrRec         : TPrRec;         {Daisy Working PrRec (while printing)}
  DWRecPtr        : TpDWRec;

  DWBandPtr       : QDPtr;          {Points to the printing band}
  DWPicPtr        : QDPtr;          {Points to picture elements in picture data seg}
  DWBegPtr        : QDPtr;          {Beginning pointer}

  PrGPort         : TPrPort;        {GrafPort for printing}
  hPfPages        : ThPfPages;
  GlobalAbort     : TF;
  DWGo            : TF;             {Not Abort.  FALSE when aborting}
  CallerID        : TL;
  {fInReverse      : TF;             {TRUE implies printing goes from left to right}

{----------------------------------  RhDev VARs   -------------------------------}

  RhDev           : TRhDev;

{---------------------------------  RhProc VARs   -------------------------------}

  fRhDraft        : TF;             {Set true if we're in draft mode}
  fRhBits         : TF;             {Set true if bits in the bitmap}
  hSpokeOffsets   : THSpokeOffset;  {Current wheel offsets}
  fPgDirty        : TF;             {TRUE if page written to.}
  firstpage       : TF;             {Set TRUE if this is first page of a document}
  firstband       : TF;             {Set TRUE on first band of first page}
  lastDoc         : TC;             {ID of last document printed}
  HighestTop      : TC;             {Value of highest bit on document hit by text}

{============================= PROCEDURE DIRECTORY ==============================}

FUNCTION FindBit(base,startBit,limitBit:LONGINT):LONGINT;               EXTERNAL;

{--------------------------------  QDStd Procs  ---------------------------------}

PROCEDURE DWColorMap;                                                   FORWARD;
PROCEDURE PatFix    (verb: GrafVerb );                                  FORWARD;

PROCEDURE DWStdArc  (verb :GrafVerb;r:Rect;cStart,cArc: TC);            FORWARD;
PROCEDURE DWStdBits (bmSrc:BitMap;rSrc,rDest:Rect;cMode:TC;RgnMask:RgnHandle);FORWARD;
PROCEDURE DWStdLine (newPt:Point);                                      FORWARD;
PROCEDURE DWStdOval (verb :GrafVerb;r:Rect);                            FORWARD;
PROCEDURE DWStdPoly (verb :GrafVerb;poly:PolyHandle);                   FORWARD;
PROCEDURE DWStdRect (verb :GrafVerb;r:Rect);                            FORWARD;
PROCEDURE DWStdRgn  (verb :GrafVerb;rgn:RgnHandle);                     FORWARD;
PROCEDURE DWStdRRect(verb :GrafVerb;r:Rect;ovWd,ovHt:TC);               FORWARD;

{------------------------------------  RhDev  -----------------------------------}

PROCEDURE AToDigits ( a: TA; VAR a1, a2: TA );                          FORWARD;
PROCEDURE IToDigits ( i: TC; VAR a1, a2, a3: TA );                      FORWARD;
PROCEDURE RhCmd;                                                        FORWARD;
PROCEDURE RhDevClose;                                                   FORWARD;
PROCEDURE RhClosePort(RhPort:TC);                                       FORWARD;
{PROCEDURE RhDevInit;                                                    FORWARD;}
PROCEDURE RhDevOpen( cFormLength: TC; fMechFeeder: TF );                FORWARD;
PROCEDURE RhFlushBuffer;                                                FORWARD;
PROCEDURE RhGotoX ( xIn: TC );                                          FORWARD;
PROCEDURE RhGotoXY ( xIn: TC; yIn: TC );                                FORWARD;
PROCEDURE RhGotoY ( yIn: TC );                                          FORWARD;
PROCEDURE RhNewPage;                                                    FORWARD;
PROCEDURE RhOut ( a: TA );                                              FORWARD;
PROCEDURE RhPrSpoke ( spoke: TSpoke; qdx: TC; hammer: THammer );        FORWARD;
FUNCTION  RhReportProblem(cErr:TC;an:TC;at:TAlertKind):TF;              FORWARD;
PROCEDURE RhSetFormLng ( cFormLength: TC );                             FORWARD;
PROCEDURE RhSetPgmCtl ( fPgmCtl: TF );                                  FORWARD;
{PROCEDURE RhSetReverse ( fReverse: TF);                                 FORWARD;}
PROCEDURE RhXMove;                                                      FORWARD;
PROCEDURE RhYMove;                                                      FORWARD;

{-----------------------------------  RhProcs  ----------------------------------}

PROCEDURE RhCleanup(VAR prins: TPrRec);                                 FORWARD;
PROCEDURE RhClose(VAR prins: TPrRec);                                   FORWARD;
FUNCTION  RhDoAlert(an:TC;at:TAlertKind):TC;                            FORWARD;
PROCEDURE RhDumpBand(VAR PrRec:TPrRec);                                 FORWARD;
PROCEDURE RhEjectPage;                                                  FORWARD;
PROCEDURE RhHRule(cLength: TC);                                         FORWARD;
{PROCEDURE RhInit;                                                       FORWARD;}
PROCEDURE RhMetrics(VAR prstl: TPrRec);                                 FORWARD;
PROCEDURE RhOpen(VAR prins: TPrRec);                                    FORWARD;
PROCEDURE RhTab(cLength: TC);                                           FORWARD;
PROCEDURE RhVRule(cLength: TC);                                         FORWARD;
PROCEDURE RhXMetrics(VAR prins: TPrRec);                                FORWARD;

FUNCTION  RhChkHRule(VAR cmd: TPbCommand; hPbData: THPbData): TF;       FORWARD;
FUNCTION  RhChkText (VAR cmd: TPbCommand; hPbData: THPbData): TF;       FORWARD;
FUNCTION  RhChkVRule(VAR cmd: TPbCommand; hPbData: THPbData): TF;       FORWARD;

PROCEDURE RhDumpHRule(VAR cmd: TPbCommand; hPbData: THPbData);          FORWARD;
PROCEDURE RhDumpScanLine(scan: TC);                                     FORWARD;
PROCEDURE RhDumpText (VAR cmd: TPbCommand; hPbData: THPbData);          FORWARD;
PROCEDURE RhDumpVRule(VAR cmd: TPbCommand; hPbData: THPbData);          FORWARD;

PROCEDURE RhPrXChar(c: CHAR; qdx: TC);                                  FORWARD;
PROCEDURE RhStdText(cCount: TC; p: TP; ptNumer, ptDenom: Point);        FORWARD;
FUNCTION  RhSwapSpokes(VAR cError: TC): THSpokeEtc;                     FORWARD;

FUNCTION  fPsPageOK(fDMZDirty:TF;feedtype:Tfeeder):TF;                  FORWARD;

{---------------------------------  Main Procs  ---------------------------------}

PROCEDURE CallService(environPtr:p_env_blk;excepDataPtr:p_ex_data);     FORWARD;
PROCEDURE DocBegin(VAR filname:STR255;VAR PrRec:TPrRec);                FORWARD;
PROCEDURE DocEnd(VAR PrRec:TPrRec);                                     FORWARD;
PROCEDURE DWAlerts;                                                     FORWARD;
PROCEDURE DWDefMetrics(VAR PrRec:TPrRec);                               FORWARD;
PROCEDURE DWDrawPicture(Pic:PicHandle;rframe:Rect);                     FORWARD;
PROCEDURE DWGetPicProc(QDP:QDPtr;ByteCount:TC);                         FORWARD;
PROCEDURE DWInit;                                                       FORWARD;
PROCEDURE DWOpenFile(VAR filename:STR255;VAR PrRec:TPrRec);             FORWARD;
PROCEDURE DWPageEnd;                                                    FORWARD;
PROCEDURE DWPrintPicture(VAR PrRec:TPrRec;hPic:PicHandle;rFrame:Rect);  FORWARD;
PROCEDURE DWReadPicture(Amount:TL;refnum:TC);                           FORWARD;
PROCEDURE DWQuit;                                                       FORWARD;
PROCEDURE Main;                                                         FORWARD;
PROCEDURE PrintFile(VAR FileName:STR255;VAR PrRec:TPrRec);              FORWARD;
PROCEDURE PrSysTerm(environPtr:p_env_blk;excepDataPtr:p_ex_data);       FORWARD;
PROCEDURE SetPrinter(VAR PrRec:TPrRec);                                 FORWARD;
PROCEDURE Suicide;                                                      FORWARD;

{================================================================================}

{[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]}
{                                  QD StdProcs                                   }
{[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]}

{================================================================================}
{$S Rh}
PROCEDURE DWColorMap;
Begin
  ThePort^.FGColor:=33;
  ThePort^.BKColor:=30;
End;

{================================================================================}
{$S Rh}
PROCEDURE PatFix{verb: GrafVerb };
VAR
    fBlack: TF;
BEGIN
    WITH thePort^ DO BEGIN
        CASE verb OF
            frame,
            paint:  fBlack:= fEQBlk(@pnPat, @black, 8);
            invert,
            fill:   fBlack:= fEQBlk(@theport^.fillpat, @black, 8);  {!New QuickDraw Fix}
            erase:  fBlack:= fEQBlk(@bkPat, @black, 8);
        END;
        IF fBlack THEN patStretch:=0
        ELSE patStretch:=DWRecPtr^.DWInfo.cPatScale;
    END;                                                            {!New QuickDraw Fix}
END;

{================================================================================}
{$S Rh}
PROCEDURE DWStdArc  {(verb :GrafVerb;r:Rect;cStart,cArc: TC)};
BEGIN
  DWColorMap;
  PatFix(verb);
  StdArc(verb,r,cStart,cArc);
END;

{================================================================================}
{$S Rh}
PROCEDURE DWStdBits {(bmSrc:BitMap;  rSrc,rDest:Rect;cMode:TC;RgnMask:RgnHandle)};
BEGIN
  DWColorMap;
  StdBits(bmSrc,rSrc,rDest,cMode,RgnMask);
END;

{================================================================================}
{$S Rh}
PROCEDURE DWStdLine {(newPt:Point)};
BEGIN
  DWColorMap;
  WITH ThePort^ DO BEGIN
    IF fRhDraft OR ((pnLoc.v <> newPt.v) AND (pnLoc.h <> newPt.h)) THEN BEGIN
      PatFix(frame);
      StdLine(newPt);
    END
    ELSE BEGIN
      IF (pnloc.v < HighestTop) THEN HighestTop:=pnloc.v;
      IF (newPt.v < HighestTop) THEN HighestTop:=newPt.v;
      IF (pnLoc.v = newPt.v) THEN BEGIN    {--Same vertical level, do HRule}
        RhHRule(newPt.h-pnloc.h);
      END
      ELSE BEGIN                           {--Same horizontal level, do VRule}
        RhVRule(newPt.v-pnloc.v);
      END;
    END;
  END;
END;

{================================================================================}
{$S Rh}
PROCEDURE DWStdOval {(verb :GrafVerb;r:Rect)};
BEGIN
  DWColorMap;
  PatFix(verb);
  StdOval(verb,r);
END;

{================================================================================}
{$S Rh}
PROCEDURE DWStdPoly {(verb :GrafVerb;poly:PolyHandle)};
BEGIN
  DWColorMap;
  PatFix(verb);
  StdPoly(verb,poly);
END;

{================================================================================}
{$S Rh}
PROCEDURE DWStdRect {(verb :GrafVerb;r:Rect)};
VAR
  savePen   : Point;
BEGIN
  DWColorMap;
  IF (fRhDraft) OR (verb <> frame) OR (ThePort^.pnSize.h > 1) THEN BEGIN
    PatFix(verb);
    StdRect(verb,r);
  END
  ELSE  WITH ThePort^ DO BEGIN
    IF (r.top < HighestTop) THEN HighestTop:=r.top;
    savePen:=pnloc;
    pnloc:=r.topleft;
    RhHRule(r.right-r.left-1);
    RhVRule(r.bottom-r.top-1);
    RhHRule(r.left-r.right+1);
    RhVRule(r.top-r.bottom+1);
    pnloc:=savePen;
  END;
END;

{================================================================================}
{$S Rh}
PROCEDURE DWStdRgn  {(verb :GrafVerb;rgn:RgnHandle)};
BEGIN
  DWColorMap;
  PatFix(verb);
  StdRgn(verb,rgn);
END;

{================================================================================}
{$S Rh}
PROCEDURE DWStdRRect{(verb :GrafVerb;r:Rect;ovWd,ovHt:TC)};
BEGIN
  DWColorMap;
  PatFix(verb);
  StdRRect(verb,r,ovWd,ovHt);
END;

{================================================================================}

{[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]}
{                                     RhDev                                      }
{[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]}
{  This is the primitive interface to the Rh (like!) printer.
   It mainly contains the code to execute the Rh device commands.
   We also put here the table initialization code.  }

{================================================================================}
{$S Rh}
PROCEDURE AToDigits {( a: TA; VAR a1, a2: TA ) };
{ Transforms a (small) positive number to 2 text digits. }
VAR units, tens: TC;
BEGIN
    units := a MOD 10;
    tens := a DIV 10;

    IF (tens > 9) THEN a1 := ORD ('A') + tens-10 ELSE a1 := ORD ('0') + tens;
    a2 := ORD ('0') + units;
END;

{================================================================================}
{$S Rh}
PROCEDURE IToDigits { ( i: INTEGER; VAR a1, a2, a3: TA ) };
{ Transforms a relative motion of the carrage into Qume's 3 special characters. }
BEGIN
    a1 := 64; a2 := a1; a3 := a1;
    IF i < 0 THEN BEGIN
       a1 := a1 + 16;
       i := -i;
    END;

    a1 := a1 + i DIV 256;
    i := i MOD 256;
    a2 := a2 + i DIV 16;
    a3 := a3 + i MOD 16;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhCmd;
{ A "macro" for the start of a command; for the lazy typer! }
BEGIN
    RhOut(ESC);
END;

{================================================================================}
{$S Rh}
PROCEDURE RhClosePort(RhPort:TC);
VAR
  Error       : TC;
  devControl  : dcType;
  devName     : E_Name;
  path        : PathName;
BEGIN
  (*-----Get the port name.*)
  PsPortToDevName(RhPort,devName);
  path:=CONCAT('-', devName, '-x');
  WITH devControl DO BEGIN
    dcversion:=2;
    dccode:=25;                     {--code to disable/enable break on closing}
    dcdata[0]:=0;                   {--disable (1 = enable)}
  END;
  DEVICE_CONTROL(Error,path,devControl);
  PsClosePort(Error,RhPort);
END;

{================================================================================}
{$S Rh}
PROCEDURE RhDevClose;
BEGIN
  RhCmd;
  RhCmd;
  RhCmd;
  RhOut(cmReset1);
  RhOut(ORD(cmReset2));   {!PR033 - reset the Qume so Workshop
                                    can use it. DC 9/16/83}
  RhFlushBuffer;
END;

{================================================================================}
{$S Rh}
(*
PROCEDURE RhDevInit;
BEGIN
END;
*)

{================================================================================}
{$S Rh}
PROCEDURE RhDevOpen { cFormLength: TC; fMechFeeder: TF };
VAR
  i, j, cError  : TC;
  interval      : TimeStmp_Interval;
  fakeTime      : Time_Rec;
BEGIN
  WITH RhDev DO BEGIN
    cCharsBuf:=0;
{Possibly a set top of form call should be implmented}
    IF fMechFeeder THEN rollerGap:= 0 ELSE rollerGap:= RhRollerGap;

    x    := 0;
    y    := rollerGap;
    xOld := x;
    yOld := y;
  END;

  RhDevClose;                 {Clear any hanging commands}
  RhSetPgmCtl(TRUE);

{Delay two seconds for reset to take effect}
  WITH interval DO BEGIN
    sec:=2;
    msec:=0;
  END;
  DELAY_TIME( cError, interval, fakeTime );

  RhSetFormLng ( cFormLength );
  RhCmd; RhOut ( ORD(cmLangSel) ); RhOut ( ORD(cmLangWP) ); {Chose WP char set}
END;

{================================================================================}
{$S Rh}
PROCEDURE RhFlushBuffer;
VAR
  cError    : TC;
  state     : TC;
BEGIN
  WITH RhDev DO BEGIN
    IF fDevDbg THEN WRITELN ('flushing buffer' );

    IF (cCharsBuf > 0) THEN BEGIN
      REPEAT
        PsOutPort(cError,POINTER(ORD(@rgChBuf)),cCharsBuf);
      UNTIL RhReportProblem(cError,cAxDifficulties,cautionProc);
      cCharsBuf:=0;
    END;
  END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhGotoX { ( xIn: TQx ) };
{  Move to the given x location.  Uses the change from current location.}
BEGIN
WITH RhDev DO BEGIN
   IF fDevDbg THEN WRITELN ('RhGotoX: ', x:1, ' => ', xIn:1 );
   x := xIn;
END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhGotoXY { ( xIn: TQx; yIn: TQy ) };
{ Ditto for both x and y. }
BEGIN
    RhGotoX (xIn);
    RhGotoY (yIn);
END;

{================================================================================}
{$S Rh}
PROCEDURE RhGotoY { ( yIn: TQy ) };
{ Ditto for y location.  }
BEGIN
WITH RhDev DO BEGIN
    IF fDevDbg THEN WRITELN ('RhGotoY: ', y:1, ' => ', yIn:1 );
    y := yIn;
END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhNewPage;
VAR
  ylong       : TL;
BEGIN
  IF fDevDbg THEN WRITELN ('RhNewPage.' );

  WITH RhDev DO BEGIN
    yLong:=DWPrinter^^.PrRec.PrInfo.PgSize.Height;
    yLong:=((yLong*vResolution) DIV PrPgFract)+rollerGap;
    RhGoToY(yLong);   {--Tabulate y distance}
    RhYMove;          {--Execute pending y movement}
    RhFlushBuffer;

    y := rollerGap;
    x := 0;
    yOld := y;
  END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhOut { ( a: TA ) };
{ This is the ONLY proc communicating to the Printer!
   It outputs both the commands and data.}
BEGIN
  IF fDevDbg THEN WRITELN (' [', a:1, ']' );

  WITH RhDev DO BEGIN
    rgChBuf[cCharsBuf]:=CHR(a);
    cCharsBuf:=cCharsBuf + 1;
    IF cCharsBuf > cRhMaxBuf THEN BEGIN
      RhFlushBuffer;
    END;
  END;
END;

{================================================================================}
{$S Rh}
FUNCTION  RhReportProblem{(cErr:TC;an:TC;at:TAlertKind):TF};
{--Returns TRUE if there is no problem or if there is a problem and the user said Cancel.
   Returns FALSE if there is a problem but the user said OK.
   TRUE means go ahead, FALSE means try it over again, whatever it was that caused the problem.}
BEGIN
  RhReportProblem:=TRUE;
  IF DWGo THEN BEGIN
    IF (cErr > 0) THEN BEGIN
      IF (RhDoAlert(an,at) = CancelOpt) THEN WITH DWPrinter^^.PrRec.PrInfo DO BEGIN
        {--cErr is not used again for anything so we'll just use it in this next procedure}
        PrCall(cErr,lParentID,ePrintTerminate,0,0,PrinterID,Port);
        DWGo:=FALSE;
      END
      ELSE BEGIN
        RhReportProblem:=FALSE;
      END;
    END;
  END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhPrSpoke { ( spoke: TSpoke; qdx: TC; hammer: THammer ) };
{ Print the character at the given spoke, using PgmCtl pair.
  The space (blank) cannot be printed here: use RhOut ( SP ).}
VAR
  iDx, iDy  : TC;
  a1, a2, a3: TA;
  cOut      : TC;
BEGIN
   WITH RhDev DO BEGIN
      IF GlobalAbort THEN BEGIN
         x := x + qdx;
      END
      ELSE BEGIN
         qdx := CMAX (1, qdx);  { OD: Qume Bug!!! 0 dx => no ribbon advance! }

         RhXMove;     {--Execute any pending X movement}
         RhYMove;     {--Execute any pending Y movement}

         IF fDevDbg THEN WRITE ('RhPrSpoke: spoke=', spoke[0], spoke[1],
                                ', qdx=', qdx:1, ', hammer=', hammer:1 );


         RhOut(ORD(spoke[0]) );
         RhOut(ORD(spoke[1]) );

         iDx:=cMIN( qdx, 15 );
         cOut:=iDX + 16*hammer;
         RhOut ( cOut );
         IF fDevDbg THEN WRITE (' (', x:1, ' => ' );

         IF fInReverse THEN x := x - iDx ELSE x := x + iDx;
         xOld:=x;

 {Move the remainder if needed}
         IF fInReverse THEN x := x - qdx+iDx ELSE x := x + qdx-iDx;

         IF fDevDbg THEN WRITELN ( x:1, ')' );
      END;
   END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhSetFormLng { ( cFormLength: TC ) };
{ Sets the page height in 48ths of an inch. }
VAR aTens, aUnits: TA;
BEGIN
    IF fDevDbg THEN WRITELN ('RhSetFormLng: lng=', cFormLength:1 );
{Convert from 48ths to 6ths by dividing by eight}
    AToDigits ( cFormLength DIV 8, aTens, aUnits);
    RhCmd;
    RhOut ( ORD ( cmFormLng ) );
    RhOut ( aTens );
    RhOut ( aUnits );
END;

{================================================================================}
{$S Rh}
PROCEDURE RhSetPgmCtl { ( fPgmCtl: TF ) };
BEGIN
    IF fDevDbg THEN WRITELN ('RhSetPgmCtl: ', fPgmCtl );
    RhCmd;
    IF fPgmCtl THEN RhOut( cmPCtlOn )
               ELSE RhOut( cmPCtlOff );
END;

{================================================================================}
{$S Rh}
(*
PROCEDURE RhSetReverse { ( fReverse: TF) };
BEGIN
    IF fDevDbg THEN WRITELN ('RhSetReverse: ', fReverse );
    RhCmd;
    IF fReverse THEN RhOut ( ORD( cmRvrsOn ) )
                ELSE RhOut ( ORD( cmRvrsOff ) );
END;
*)

{================================================================================}
{$S Rh}
PROCEDURE RhXMove;
VAR
  iDx     : TC;
  a1,a2,a3: TA;
BEGIN
  WITH RhDev DO BEGIN
    IF (x <> xOld) THEN BEGIN
      IF fInReverse THEN iDx := xOld-x ELSE iDx := x-xOld;
      RhCmd;
      RhOut ( ORD ( cmDx ) );
      IToDigits ( iDx, a1, a2, a3 );
      RhOut ( a1 ); RhOut ( a2 ); RhOut ( a3 );
      xOld:=x;
    END;
  END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhYMove;
VAR
  iDy     : TC;
  a1,a2,a3: TA;
BEGIN
  WITH RhDev DO BEGIN
    IF (y <> yOld) THEN BEGIN
      iDy := y-yOld;

      RhCmd;
      RhOut ( ORD ( cmDy ) );
      IToDigits ( iDy, a1, a2, a3 );
      RhOut ( a1 ); RhOut ( a2 ); RhOut ( a3 );
      yOld:=y;
    END;
  END;
END;

{================================================================================}

{[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]}
{                                    RhProcs                                     }
{[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]}

{================================================================================}
{$S Rh}
FUNCTION  RhChkHRule{ (cmd: TPbCommand; hPbData: THPbData): TF };
BEGIN
    WITH cmd DO BEGIN
{Adjust for the device}
        v:=v-hSpokeOffsets^^.cULOffset;

{See if in band range}
        WITH ThePort^.portRect DO
            RhChkHRule:= (v >= top) AND (v <= bottom)
    END;
END;

{================================================================================}
{$S Rh}
FUNCTION  RhChkText{ (cmd: TPbCommand; hPbData: THPbData): TF };
VAR
    chWidth: TC;
BEGIN
    WITH cmd DO BEGIN
        chWidth:=CharWidth( hPbData^^[ cFirstChar ] );          {s/b textwidth?}

{Do UL if desired}
        RhTab( chWidth );
        Move( -chWidth, 0 );            {Undo effects of tab}

{See if in band range}
        WITH ThePort^.portRect DO {--Use the port in current graph port}
            RhChkText:= (v >= top) AND (v <= bottom) AND (cFont <> marker);
    END;
END;

{================================================================================}
{$S Rh}
FUNCTION  RhChkVRule{ (cmd: TPbCommand; hPbData: THPbData): TF };
VAR
    vSave: TC;
BEGIN
    WITH cmd, ThePort^, hSpokeOffsets^^ DO BEGIN {--Use the port in current graph port}
        IF v < portRect.top-cVRuleOffset THEN BEGIN
{Stitch to the original v location and then print first one in this band}
            vSave:=v;
            v:=v + (portRect.top - (v+cVRuleOffset)+cVRuleHalf-1) DIV cVRuleHalf *
               cVRuleHalf;

            cHeight:=cHeight - (v-vSave);       {Adjust length accordingly}

{Make sure minimum slops above}
            IF cHeight < cVRuleHeight THEN v:=v+cHeight-cVRuleHeight;
        END;

{Adjust for the device}
        v:=v + cVRuleOffset;
(*        cHeight:=cHeight-cVRuleHeight;      three strikes, you're out *)

{See if in band range}

(*        RhChkVRule:= (v >= portRect.top) AND (v <= portRect.bottom)  *)
{In order to do proper coalescing across band boundaries, we'll make the rejection band a little
  larger than the port band to accept a few more short vrules around the band boundaries.
  Why this kludge should work, you've got me.  }   {BH}
          WITH portRect DO BEGIN
              RhChkVRule:= (v >= (top - cVRuleHeight)) AND (v <= (bottom+cVRuleHeight));
          END;
    END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhCleanup{(VAR prins: TPrRec)};
BEGIN
{If an abort has been hit, eject page}
    IF fPgDirty THEN RhNewPage;
    RhClose(prins);
END;

{================================================================================}
{$S Rh}
PROCEDURE RhClose{(VAR prins: TPrRec)};
VAR
  cError    : TC;
BEGIN
    RhDevClose;
    RhClosePort(prins.PrInfo.Port);
END;

{================================================================================}
{$S Rh}
FUNCTION  RhDoAlert{(an:TC;at:TAlertKind):TC};
BEGIN
{PsNonPreemptive;}
RhDoAlert:=PrOtherAlert(DWAlertFile,an,at,TRUE{Background});
{PsPreemptive;}
END;

{================================================================================}
{$S Rh}
PROCEDURE RhDumpBand{(VAR PrRec:TPrRec)};
VAR
    DeviceRec : TpDWRec;
BEGIN
    IF fDevDbg THEN WRITELN( 'RhDumpBand' );
    DeviceRec:=@PrRec.PrDevInfo;
{Defer dumping if first band and either cut sheet or stuff in DMZ}
    WITH ThePort^ DO IF fPsPageOK((HighestTop < RhDev.rollerGap) OR
        {(PortRect.top < RhRollerGap) OR }(NOT fClrBitmap(portBits,DeviceRec^.DWInfo.rRoller))
        ,DeviceRec^.DWCfg.feeder) THEN BEGIN
        fRhBits:=NOT fClrBitmap( portBits, portRect );
        fPgDirty:=fPgDirty OR fRhBits;
        IF DWGo THEN BEGIN
          RhSetPgmCtl(TRUE);
          PbDumpBand;
        END;
    END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhDumpHRule{ VAR cmd: TPbCommand; hPbData: THPbData };
VAR
    endH: TC;
    c: CHAR;
BEGIN
    WITH cmd, hSpokeOffsets^^ DO BEGIN
{Adjust for the device spoke offsets and band offset}
        h:=h + cHRuleOffset{ - ThePort^.visRgn^^.rgnBBox.left};
        cWidth:=cWidth-cHRuleOffset;

        endH:=h + cWidth;

        IF fDevDbg THEN WRITELN( 'RhDumpHRule', h, v, cWidth, endH );

        RhGoToY(RhDev.y+1);  {Makes the bitmap - to - text baseline adjustment}
        RhGoToX( h );
        WHILE RhDev.x < endH-cHRuleHalf-1 DO BEGIN
            RhPrXChar( '_', cHRuleHalf );
        END;
        RhGoToX( endH-cHRuleHalf-1 );
        RhPrXChar( '_', cHRuleWidth );
        RhGoToY(RhDev.y-1);
    END; {with}
END;

{================================================================================}
{$S Rh}
PROCEDURE RhDumpScanLine{ scan: TC };
CONST
  firstposition = -2;
VAR
    current     : TL;
    c           : CHAR;
    p           : TL;
    r           : Rect;
    last        : TL;
BEGIN
   IF fDevDbg THEN WRITELN( 'RhScanLine @', scan );

{Do the business for each scan line}
   {PsYieldCpu;}

   RhGoToY( scan );

{Send the bits for this scanline if need be}
   IF fRhBits THEN BEGIN
      RhGoToY( scan + 1 );  {Makes the bitmap - to - text baseline adjustment}
{Normalize the port rect}
      WITH ThePort^{, visRgn^^.rgnBBox} DO BEGIN
         r:= portRect;
         {OffsetRect( r, -left, -top );}
      END;

      WITH ThePort^, portBits DO BEGIN
         p:=ORD4(baseAddr) + (scan-portRect.top)*rowBytes;

         current:=FindBit(p,r.left,r.right);
         IF (current <> -1) THEN BEGIN
            RhSetPgmCtl(TRUE);
            {--Position to first pixel}
            RhGoToX(current);
            REPEAT
               last:=current;
               {--Scan to next non zero bit}
               current:=FindBit(p,current+1,r.right);
               IF (current = -1) THEN last:=current;
               RhPrXChar('.',current-last);
            UNTIL (current = -1);
         END;

      END; {with}
      RhGoToY(scan);
   END; {if bits}
END;

{================================================================================}
{$S Rh}
PROCEDURE RhDumpText{ VAR cmd: TPbCommand; hPbData: THPbData };
VAR
    i, cWidth: TC;
    c1, c2: CHAR;
BEGIN
    WITH cmd DO BEGIN
        IF fDevDbg THEN WRITELN( 'RhDumpText ', h, v, cFirstChar, cLength );

        TextFont( cFont );
        TextFace( seteface );

{Adjust for the device center strike model and band offset}
        cWidth:=CharWidth( hPbData^^[ cFirstChar ] );
        h:=h + (cWidth+1) DIV 2{ - ThePort^.visRgn^^.rgnBBox.left};

        RhGoToY(RhDev.y+1);  {Makes the bitmap - to - text baseline adjustment}
        RhGoToX( h );
        c1:= hPbData^^[cFirstChar];
        FOR i:=1 TO cLength DO BEGIN
            c2:= hPbData^^[cFirstChar + i ];
            IF fDevDbg THEN WRITELN( 'width c ', CharWidth(c1));

            cWidth:= (CharWidth(c1) + CharWidth(c2)) DIV 2;
         (* IF cFont=marker THEN c1 := 'X'; {Draft only.} *)
            IF (c1 = ' ') OR (c1 = CHR($00CA)) THEN BEGIN {!PR:SpokeTables} {Non blank space}
                RhGoToX( RhDev.x + cWidth );
            END
            ELSE BEGIN
                RhSetPgmCtl(TRUE);
                IF Bold IN seteface {AND mpccSpkHam[ORD(c1)].fBoldOK}
                THEN BEGIN
                    RhPrXChar( c1, 1 );
                    RhPrXChar( c1, cWidth-1 );
                END
                ELSE BEGIN
                    RhPrXChar( c1, cWidth );
                END;
            END; {if c1 = ' '}
            c1:=c2;
        END; {for i:=1 to ...}
        RhGoToY(RhDev.y-1);
    END; {with}
END;

{================================================================================}
{$S Rh}
PROCEDURE RhDumpVRule{ VAR cmd: TPbCommand; hPbData: THPbData };
BEGIN
    WITH cmd, hSpokeOffsets^^ DO BEGIN
        IF fDevDbg THEN WRITELN( 'RhDumpvrule ', h, v, cHeight );
        RhGoToY(RhDev.y+1);  {Makes the bitmap - to - text baseline adjustment}
        RhGoToX( h{ - ThePort^.visRgn^^.rgnBBox.left} );
        RhPrXChar( CHR(124), 1);                {Vertical bar}
(*        IF cHeight > 0 THEN BEGIN      three strikes, you're out *)
        IF cHeight > cVRuleHeight THEN BEGIN
            v:=v+CMIN(cHeight-cVRuleHeight, cVRuleHalf)     { -cVRuleHeight is new }
        END;
        RhGoToY(RhDev.y-1);
        cHeight:=cHeight - cVRuleHalf;
    END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhEjectPage;
BEGIN
   IF fPgDirty THEN RhNewPage; {?: maybe dump anyway??}
   fPgDirty := FALSE;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhHRule{ cLength: TC};
BEGIN
    IF fDevDbg THEN WRITELN( 'RhHRule ', ThePort^.pnLoc.h, ThePort^.pnLoc.v, cLength );
    PbHRule( clength );
END;

{================================================================================}
{$S Rh}
(*
PROCEDURE RhInit;      {DC 9/6/83}
BEGIN
  RhDevInit;
END;
*)

{================================================================================}
{$S Rh}
PROCEDURE RhMetrics{(VAR prstl: TPrRec)};
VAR
    cBitsAcross, cBitsDown : TC;
    DeviceRec              : TpDWRec;
BEGIN
    DeviceRec:=@prstl.PrDevInfo;
    WITH prstl.prInfo, DeviceRec^, DWInfo DO BEGIN
        WITH ADev DO BEGIN
          foffline:=TRUE;   {--Don't substitute, use real font}
          edev:=edevTyper;
          fSpoke:=FALSE;
          ewhcl:=DWCfg.wheel;
        END;
        hRes :=  hResolution; vRes := vResolution;

        cBitsAcross:= cMIN( ORD4(hRes)*pgSize.Width DIV prPgFract, qxLast );
        cBitsDown:= ORD4(vRes)*pgSize.Height DIV prPgFract;

        SetRect( rPaper,     0, 0,           cBitsAcross, cBitsDown );
        SetRect( rPrintable, 0, 0,           cBitsAcross, cBitsDown );
        SetRect( rRoller,    0, 0,           cBitsAcross, RhRollerGap ); {7/8 inch waste}

{Return values}
        tyScan:=tyScanTB;           {Scan top to bottom}
        cPatScale:=-2;              {Spread the patterns}
        cULThick :=1;               {Underscoring parameters}
        cULOffset:=2;
        cULShadow:=3;
    END;

END;

{================================================================================}
{$S Rh}
PROCEDURE RhOpen{(VAR prins: TPrRec)};
VAR
    cError, cBitsDown : TC;
    hSpokeEtc         : THSpokeEtc;
    DeviceRec         : TpDWRec;
BEGIN

    DeviceRec:=@prins.PrDevInfo;
{Call the device open}
    cBitsDown:= ORD4(vResolution)*prins.PrInfo.pgSize.Height DIV prPgFract;

    IF DWGo THEN BEGIN

      WITH prins.PrInfo DO BEGIN
        RhClosePort(Port);
        REPEAT
          PsOpenPort(cError,Port);
        UNTIL RhReportProblem(cError,cAxDifficulties,CautionProc);
      END;

      RhDevOpen(cBitsDown, DeviceRec^.DWCfg.feeder = feedMechCut );

      hSpokeEtc:=RhSwapSpokes( cError );
      hSpokeOffsets^^:=hSpokeEtc^^.spokeOffsets;
    END;

    fRhDraft := (DeviceRec^.DWCfg.mode = Draft);
    fPgDirty := FALSE;
END;

{================================================================================}
{$S Rh}
FUNCTION RhSwapSpokes{ ( VAR cError: TC ): THSpokeEtc };
VAR
    lFntID: TLfntId;
    pCharStyle: TPCharStyle;
    iJunk: TC;
BEGIN
    {Build up lfntid from graf port and config}
    WITH lfntID, ThePort^ DO BEGIN
        fam:=txFont;
        seteface:=txFace;
        fOffline:=FALSE;                {--Do the substitution now}
        edev:=eDevTyper;
        fSpoke:=TRUE;                   {--And use spokes}
        ewhcl:=DWRecPtr^.DWCfg.wheel;   {--The real wheel that we have on this machine}
    END;

    PsNonPreemptive;  {Lock}
    pCharStyle:=FMSwapFont( lFntID, cError );
    PsPreemptive;     {UnLock}

    RhSwapSpokes:=POINTER(pCharStyle^.hKS);
END;

{================================================================================}
{$S Rh}
FUNCTION  fPsPageOK{(fDMZDirty:TF;feedtype:Tfeeder):TF};
{--This routine returns true if it is OK for printing to continue, otherwise cancel}
VAR
  opt     : TC;
BEGIN
  fPsPageOK:=TRUE;
  IF firstband THEN
    CASE feedtype OF
      feedCut: BEGIN
        IF fDMZDirty THEN opt:=cAxCutRollerBack ELSE opt:=cAxFeedSheet;
        fPsPageOK:=RhReportProblem(opt,opt,CautionProc);
        fPsPageOK:=DWGo;
      END;

      feedFanfold: BEGIN
        IF (fDMZDirty AND firstpage) THEN BEGIN
          RhNewPage;
        END;
      END;

      feedMechCut: BEGIN
        {--Do nothing}
      END;

      OTHERWISE;

    END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhExtractSpoke( VAR cError: TC; c: CHAR; VAR spkHam: TSpkHam );
VAR
    hSpokeEtc: THSpokeEtc;
    ch: CHAR;
BEGIN
{The private, 3-byte packing for the spoke is:
 .        spoke[0](8)                 .
 .        spoke[1](8)                 .
 .fMacro(1).fBoldOk(1). . . .hammer(3). }

    hSpokeEtc:=RhSwapSpokes( cError );

    IF cError <=0 THEN WITH hSpokeEtc^^, spkHam DO BEGIN
        spoke[0] := mpccSpkHam[ORD(c)*3];
        spoke[1] := mpccSpkHam[ORD(c)*3+1];
        ch       := mpccSpkHam[ORD(c)*3+2];
        ham      := PrAND( ORD(ch), $7 );      {Do our own unpacking}
        fMacro   := ODD( PrShRight( ORD(ch), 7 ) );
        fBoldOK  := ODD( PrShRight( ORD(ch), 6 ) );
    END;
END;

{================================================================================}
{$S Rh}
(*
PROCEDURE RhPrChar { ( c: CHAR; qdx: TC ) }; { NOT CALLED! }
{Prints a character WITHOUT macro mapping}
VAR spkHam: TSpkHam;
    cError: TC;
BEGIN
    RhExtractSpoke( cError, c, spkHam );
    IF cError <=0 THEN WITH spkHam DO BEGIN
        RhPrSpoke( spoke, qdx, ham );
    END;
END;
*)

{================================================================================}
{$S Rh}
PROCEDURE RhPrXChar { ( c: CHAR; qdx: TC ) };
{Prints a character WITH macro mapping}
CONST bOpChar  = -127{$81 in a byte};   {!PR:SpokeTables}
      bOpHMove = -126{$82 in a byte};
      bOpVMove = -125{$83 in a byte};
      bOpMacro = -124{$84 in a byte};
      bOpSpoke = -123{$85 in a byte};   {!PR:SpokeTables}
      bOpDef   = -113{$8F in a byte};
VAR spkHam: TSpkHam;
    hSpokeEtc: THSpokeEtc;
    cError: TC;

    PROCEDURE DoMacro( b: TB );
    VAR i: TC;
        fDone: TF;
    BEGIN
        i:=0;
        hSpokeEtc:=RhSwapSpokes( cError );
        IF cError <= 0 THEN BEGIN
            WHILE ((hSpokeEtc^^.rgMacros[i].bOp <> bOpDef) OR
                  ((hSpokeEtc^^.rgMacros[i].bOperand <> b) AND
                   (hSpokeEtc^^.rgMacros[i].bOperand <> $FF)))
            DO BEGIN
                i:=i+1;
            END;

            fDone:=FALSE;
            IF fDevDbg THEN WRITELN( 'expanding macro', i );
            REPEAT
                i:=i+1;
                WITH hSpokeEtc^^.rgMacros[i] DO BEGIN
                    IF fDevDbg THEN WRITELN( 'x ', i, bOP, bOperand );
                    CASE bOp OF
                        bOpChar : BEGIN
                            RhExtractSpoke( cError, bChar , spkHam );   {!PR:SpokeTables}
                            IF cError <= 0 THEN WITH spkHam DO BEGIN
                                RhPrSpoke( spoke, 1, ham );
                                RhGoToX( RhDev.x - 1 );
                            END;
                        END;
                        bOpHMove: RhGoToX( RhDev.x + bOperand );
                        bOpVMove: RhGoToY( RhDev.y + bOperand );
                        bOpMacro: DoMacro( bOperand      );
                        bOpSpoke: RhOut  ( ORD(bOperand) );               {!PR:SpokeTables}
                        bOpDef:   fDone:=TRUE;
                        OTHERWISE fDone:=TRUE;                            {--For Safety}
                    END;
                END;
            UNTIL fDone;
        END; { if no error}
    END;

BEGIN
    RhExtractSpoke( cError, c, spkHam );
    IF cError <= 0 THEN BEGIN
        WITH spkHam DO BEGIN
            IF fMacro THEN BEGIN
                DoMacro( ORD(spoke[0]) );
                RhGoToX( RhDev.x + qdx );
            END
            ELSE BEGIN
                RhPrSpoke( spoke, qdx, ham );
            END;
        END;
    END;
    fPgDirty := TRUE;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhTab{ cLength: TC};
BEGIN
    IF Underlined IN ThePort^.txFace THEN BEGIN
{Issue a horizontal rule for the tab width}
        Move( 0, hSpokeOffsets^^.cULlocation );
        RhHRule( clength );
        Move( 0, -hSpokeOffsets^^.cULlocation );
    END
    ELSE BEGIN
        ThePort^.pnLoc.h:=ThePort^.pnLoc.h + clength;
    END;

END;

{================================================================================}
{$S Rh}
PROCEDURE RhStdText{ ( cCount: TC; p: TP; ptNumer, ptDenom: Point ) };
BEGIN
  DWColorMap;
  {--The elite and courier entries in the following statement refer to 14 point fonts as per Annette's memo}
  IF (ThePort^.txFont IN [ tile18, tile24, cent18, cent24, marker{, elite, courier} ]) AND (NOT fRhDraft)
  THEN BEGIN
    IF fDevDbg THEN WRITELN( 'RhStdText: bit font');
    StdText( cCount, POINTER(ORD(p) ), ptNumer, ptDenom );
  END
  ELSE BEGIN
    WITH ThePort^.pnloc DO IF (v < HighestTop) THEN HighestTop:=v;
    PbText( cCount, p );
  END;
END;

{================================================================================}
{$S Rh}
PROCEDURE RhVRule{ cLength: TC};
BEGIN
  IF fDevDbg THEN WRITELN( 'RhVRule ', ThePort^.pnLoc.h, ThePort^.pnLoc.v, cLength );
  PbVRule( clength );
END;

{================================================================================}
{$S Rh}
PROCEDURE RhXMetrics{(VAR prins: TPrRec)};
VAR
    hBytes, vBytes: TC;
    DeviceRec     : TpDWRec;
BEGIN
  DeviceRec:=@prins.PrDevInfo;
  WITH DeviceRec^ DO IF (DWCfg.mode = Draft) THEN BEGIN
      WITH DWInfo DO BEGIN
          rBand:=prins.prInfo.rPrintable;
          SetRect( rBounds, 0, 0, 0, 0 );
          lBandSize:=2;       {Afraid of zero}
      END;
  END
  ELSE BEGIN
  {Band pre-calculations}
      WITH prins.prInfo DO BEGIN
          hBytes:=((rPrintable.right-rPrintable.left + 15) DIV 16) * 2;
          vBytes:=(prMaxBand DIV hBytes) DIV 16 * 2;
      END;

      WITH DWInfo DO BEGIN
          SetRect ( rBand, 0, 0, hBytes*8, vBytes*8 );
          rBounds:=rBand;

          lBandSize:=hBytes*vBytes*8;
      END;
  END;
END;

{================================================================================}

{[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]}
{                                  Main Procs                                    }
{[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]}

{================================================================================}
{$S DWDlg}
PROCEDURE CallService{(environPtr:p_env_blk;excepDataPtr:p_ex_data)};
VAR
  pevData   : ^PrEventBlk;
  Message   : ^PrMessage;
  excepName : t_ex_name;
BEGIN
  pevData:=POINTER(excepDataPtr);
  Message:=@pevData^.eventBytes[0];
  CallerID:=pevData^.event_header.send_pid;
  CASE Message^ OF
    ESettingsDialog: WITH pevData^, pPrMgrDS^, DlgArgs DO BEGIN
      ThePrRec.PrInfo.Port:=DWPrinter^^.PrRec.PrInfo.Port;
      BIND_DATASEG(cError,DDSRefNum);
      ReturnOpt:=FFmtDlg (ThePrRec, NewStyle, MaxHigh, MaxWide, MinHigh, MinWide, nospecsize);
      UNBIND_DATASEG(cError,DDSRefNum);
      IF NewStyle THEN DWPrinter^^.PrRec:=ThePrRec;
      fBackGround:=FALSE;
      ACTIVATE_PROCESS(cError,CallerID,FALSE);
    END;

    EPrintDialog: WITH pevData^, pPrMgrDS^, DlgArgs DO BEGIN
      ThePrRec.PrInfo.Port:=DWPrinter^^.PrRec.PrInfo.Port;
      BIND_DATASEG(cError,DDSRefNum);
      ReturnOpt:=FInsDlg (ThePrRec, NewStyle, MenuSuppress);
      UNBIND_DATASEG(cError,DDSRefNum);
      IF NewStyle THEN DWPrinter^^.PrRec:=ThePrRec;
      fBackGround:=FALSE;
      ACTIVATE_PROCESS(cError,CallerID,FALSE);
    END;

    EPrintTerminate: BEGIN
      DWGo:=FALSE;
    END;
  END;
  excepName:=COPY(ListenCall.ChName,1,ECNameSize);
  ENABLE_EXCEP(cError,excepName);
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DocBegin{(VAR filname:STR255;VAR PrRec:TPrRec)};
VAR
  cError    : TC;
  Remainder : TC;
  sSegName  : PathName;
  lSegPtr   : TL;
  DeltaHPic : TC;
  DeltaVPic : TC;
  DWPtr     : TpDWRec;
  StartSize : TL;
  localDev  : TAdev;
BEGIN
  {--Open up the file and read in print file parameters}
  IF DWGo THEN BEGIN
    DWOpenFile(filname,PrRec);     {--Returns a valid working prRec}
    DWPtr:=@PrRec.PrDevInfo;

    RhXMetrics(PrRec);

    SetPrinter(PrRec);

    {--Make data seg for the picture to reserve space for the printing band.}
    sSegName:=sPicDataSeg;
    StartSize:=cPicDataSize+DWPtr^.DWInfo.lBandSize;
    IF DWGo THEN MAKE_DATASEG(cError,sSegName,StartSize,StartSize,PicRefNum,lSegPtr,cPicLDSN,ds_private);

    {--Set up pointers}
    DWBandPtr:=POINTER(lSegPtr);
    DWBegPtr :=POINTER(lSegPtr+DWPtr^.DWInfo.lBandSize);
    DWPicPtr :=DWBegPtr;

    WITH PrGPort.gPort, portBits, DWPtr^, PrRec DO BEGIN
      patStretch:=DWInfo.cPatScale;
      localDev:=PrInfo.Adev;
      WITH localDev DO BEGIN
        foffline:=TRUE;  {--We're not printing yet, so don't substitute}
        fSpoke:=FALSE;
        GrafDevice(Dev);
      END;
      {--Build Port bits}
      bounds:=DWInfo.rbounds;
      rowBytes:=(bounds.right-bounds.left) DIV 8;
      baseAddr:=DWBandPtr;

      portRect:=DWInfo.rBand;
      RectRgn(visRgn,PrInfo.rPrintable);
    END;

    {--Compute number of bands and remainder in last band}
    WITH PrRec.PrInfo.rPrintable DO BEGIN
      DeltaVPic:=Bottom-Top;
      DeltaHPic:=Right-Left;
    END;
    WITH DWPtr^.DWInfo, rBand DO BEGIN
      DeltaVBand:=Bottom-Top;
      DeltaHBand:=Right-Left;
    END;
    WITH DWPtr^.DWInfo DO CASE tyScan OF
      tyScanTB:  BEGIN
        NumBands :=DeltaVPic div DeltaVBand;
        Remainder:=DeltaVPic mod DeltaVBand;
      END;

      tyScanLR:  BEGIN
        NumBands :=DeltaHPic div DeltaHBand;
        Remainder:=DeltaHPic mod DeltaHBand;
      END;
    END;
    WITH DWPtr^.DWInfo DO IF Remainder > 0 THEN NumBands:=NumBands+1;
    IF DWGo THEN RhOpen(PrRec);
  END;
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DocEnd{(VAR PrRec:TPrRec)};
BEGIN
  RhClose(PrRec);
  CLOSE_DATASEG(cError,PicRefNum);
  FMCacheSize(minCache,cError);
  JLPrRec:=PrRec;
  DWGo:=TRUE;
END;

{================================================================================}
{$S     }
PROCEDURE DWAlerts;
VAR
  cAlerts   : TC;
BEGIN
  InitAlerts(CacheSize,CacheBytes,theHeap,nil,nil);
  OpenPhraseFile(cAlerts,sDWAlertFile);
  IF (AlertError <= 0) THEN BEGIN
    DWAlertFile:=ReadAlerts(cAlerts,cAxVersion);
  END;
  IF (AlertError > 0) THEN {Suicide};
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DWDefMetrics{(VAR PrRec:TPrRec)};
TYPE
  Kludge    = ARRAY [1..300] OF TC;
VAR
  DWRPtr    : TpDWRec;
  J         : TC;
  pPr       : ^Kludge;
BEGIN
  DWRPtr:=@PrRec.PrDevInfo;
  pPr:=@PrRec;
  FOR J:=1 TO (SIZEOF(PrRec) DIV 2) DO pPr^[J]:=0;
  WITH PrRec, PrInfo, DWRPtr^ DO BEGIN
    PrVersion:=cPrPrfVersion;
    PrJobInfo.Immediate:=FALSE;
    WITH PgSize DO BEGIN
      PrintDirect:=Portrait;
      PaperDirect:=Portrait;
      Height:=11*PrPgFrac;
      Width :=(17*PrPgFrac) DIV 2;
    END;
    DWCfg.feeder:=FeedFanFold;
    DWCfg.mode  :=HighRes;
    DWCfg.wheel :=ewhcl12; {--pick a 12 pitch apple wheel}
  END;
  RhMetrics(PrRec);
  RhXMetrics(PrRec);
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DWDrawPicture{(Pic:PicHandle;rframe:Rect)};
BEGIN
  DWPicPtr:=POINTER(ORD4(DWBegPtr)+8);
  PsNonPreemptive;
  DrawPicture(Pic,rFrame);
  PsPreemptive;
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DWGetPicProc{(QDP:QDPtr;ByteCount:TC)};
BEGIN
  MOVELEFT(DWPicPtr^,QDP^,ByteCount);
  DWPicPtr:=POINTER(ORD4(DWPicPtr)+ByteCount);
END;

{================================================================================}
{$S     }
PROCEDURE DWInit;
VAR
  excepName       : t_ex_name;
  sSegname        : PathName;
  lSegPtr         : TL;
  knil            : TProc;
  cError          : TC;
  DSInfo          : DSInfoRec;
  pbInstall       : TPbInstall;
BEGIN
knil:=POINTER(procNil);{.StdUnit}
DWPrinter:=NIL;
GlobalAbort:=FALSE;
CallerID:=ActiveProcess;

{--What to do if I die  ..(The first thing)}
excepName:='SYS_TERMINATE';
DECLARE_EXCEP_HDL(cError,excepName,@PrSysTerm);
IF (cError <> 0) THEN Suicide;

DWGo:=TRUE;            {--We're not aborting.  Set FALSE only when terminate is sent from Dad.}

{--Initialize QuickDraw and open the Window Manager}

{--OpenWM must be called before any other creation of any other datasegment due to the concurrency}
{--problem. }
InitGraf(@thePort);
OpenWM;

PsNonPreemptive;
sSegName:=sQDHeapName;
MAKE_DATASEG(cError,sSegName,QDHeapSize,QDHeapSize,QDHrefnum,lSegPtr,QDHeapldsn,ds_private);
IF cError <> 0 THEN Suicide;
INFO_DATASEG(cError,QDHrefnum,DSInfo);
InitHeap(POINTER(lSegPtr),POINTER(lSegPtr+DSInfo.mem_size),knil);

{--Initialize the Print Manager.  Events and Alerts should be inited now.}
PrBgdInit;
DWAlerts;
PsPreemptive;

{--Bind to the data segment}
PrMgrDSBind(cError);

{--Initialize some globals}
lastDoc:=-1;

{--Open up the graf port}
OpenPort(@PrGPort.gport);
PrGPort.gport.grafprocs:=@PrGPort.gProcs;
SetStdProcs(PrGPort.gProcs);
WITH PrGPort.gProcs DO BEGIN
{Divert the std procs to here}
  TextProc  :=@RhStdText;
  LineProc  :=@DWStdLine;
  RectProc  :=@DWStdRect;
  RRectProc :=@DWStdRRect;
  OvalProc  :=@DWStdOval;
  PolyProc  :=@DWStdPoly;
  RgnProc   :=@DWStdRgn;
  BitsProc  :=@DWStdBits;
  ArcProc   :=@DWStdArc;
  GetPicProc:=@DWGetPicProc;
END;
PrGPort.gport.FillPat:=White;

{Install ourselves into PrBuf}
  WITH pbInstall DO BEGIN
    chkProcs[pbCmdHRule]:=@RhChkHRule;
    chkProcs[pbCmdText]:=@RhChkText;
    chkProcs[pbCmdVRule]:=@RhChkVRule;

    dumpProcs[pbCmdHRule]:=@RhDumpHRule;
    dumpProcs[pbCmdText]:=@RhDumpText;
    dumpProcs[pbCmdVRule]:=@RhDumpVRule;

    scanLine:=@RhDumpScanLine;
  END;
  PbOpen( pbInstall );

{Allocate offsets for the graphics spokes}
  hSpokeOffsets:=POINTER(HAllocate(TheHeap, SIZEOF(TSpokeOffsets)));

{--Set the DWPrRec.PrDevInfo DWInfo pointer}
DWRecPtr:=@DWPrRec.PrDevInfo;

DWDlgInit;

{--Open the Global Event Channels on which we receive commands from the world.}
{--This is safe only after the dialogs have been initialized.}
PrOpenChan(Listen,TRUE{Receiver});
PrOpenCall(ListenCall,@CallService);

END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DWOpenFile{(VAR filename:STR255;VAR PrRec:TPrRec)};
VAR
  cError    : TC;
  DirLength : TC;
  PrRecfp   : TL;
  PageDirfp : TL;
  FileRec   : TPrFileRec;
  DWPtr     : TpDWRec;
BEGIN
  FileRec.FileName:=filename;
  FilRefNum:=PrNilRefNum;
  OpenBlock(cError,FileRec,[Dread,Private]);
  IF (cError <= 0) THEN BEGIN
    FilRefNum:=FileRec.RefNum;

    {--Read positions of prrec and directory}
    ReadBlock(cError,@PrRecfp,4,FilRefNum);
    ReadBlock(cError,@PageDirfp,4,FilRefNum);

    {--Read Prrec}
    PfSetPos(cError,PrRecfp,FilRefNum);
    ReadBlock(cError,@PrRec,SIZEOF(PrRec),FilRefNum);
    DWPtr:=@PrRec.PrDevInfo;

    RhMetrics(PrRec);       {--Mask off any application boo boos}

    {--Stuff correct actual port}
    PrRec.PrInfo.Port:=DWPrinter^^.PrRec.PrInfo.Port;

    {--Read page directory}
    PfSetPos(cError,PageDirfp,FilRefNum);
    DirLength:=SIZEOF(TPfPage)*PrRec.PrJobInfo.SpooledPages;
    hPfPages:=POINTER(NewHandle(DirLength));
    ReadBlock(cError,@hPfPages^^,DirLength,FilRefNum);
  END;
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DWPageEnd;
VAR
  cError    : TC;
BEGIN
  firstPage:=FALSE;
  RhEjectPage;
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DWPrintPicture{(VAR PrRec:TPrRec;hPic:PicHandle;rFrame:Rect)};
VAR
  cError      : TC;
  NextBand    : Rect;
  DWPtr       : TpDWRec;
  BandCount   : TC;
BEGIN
  DWPtr:=@PrRec.PrDevInfo;
  firstBand:=TRUE;
  rPrBounds.Left:=-32000; {.PrBuf}
  HighestTop:=RhDev.rollerGap;

  IF (fRhDraft = FALSE) THEN WITH NextBand,DWPtr^.DWInfo,PrRec.PrInfo DO BEGIN
      Top:=rPrintable.Top;
      Bottom:=Top+DeltaVBand;
      Left:=rPrintable.Left;
      Right:=Left+DeltaHBand;
  END;

  BandCount:=1;
  {fInReverse:=FALSE;{FALSE;}
  WITH DWPtr^, DWInfo DO IF (NumBands >= BandCount) THEN IF DWGo THEN BEGIN
    REPEAT
      DWPicPtr:=POINTER(ORD4(DWBegPtr)+8);
      IF (fRhDraft = FALSE) THEN WITH ThePort^ DO BEGIN
        PortRect         := NextBand;
        PortBits.Bounds  := NextBand;
      END;
      ClrBitMap(@ThePort^.PortBits);
      DWDrawPicture(hPic,rFrame);
      RhDumpBand(PrRec);
      IF (fRhDraft = FALSE) THEN CASE {DWPtr^.DWInfo.}tyScan OF
        tyscanTB:  WITH NextBand DO BEGIN
          Top:=Bottom;
          Bottom:=Bottom+DeltaVBand;
          WITH PrRec.PrInfo DO IF (Bottom > rPrintable.Bottom) THEN Bottom:=rPrintable.Bottom;
        END;

        tyscanLR:  WITH NextBand DO BEGIN
          Left:=Right;
          Right:=Right+DeltaHBand;
          WITH PrRec.PrInfo DO IF (Right > rPrintable.Right) THEN Right:=rPrintable.Right;
        END;
      END;
      BandCount:=BandCount+1;
      firstBand:=FALSE;
    UNTIL (BandCount > NumBands) OR (DWGo = FALSE);
  END;
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE DWReadPicture{(Amount:TL;refnum:TC)};
VAR
  cError    : TC;
BEGIN
  ReadBlock(cError,POINTER(DWBegPtr),Amount,refnum);
  DWPicPtr:=DWBegPtr;
END;

{================================================================================}
{$S Finish}
PROCEDURE DWQuit;
VAR
  sSegName    : PathName;
  cError      : TC;
BEGIN
{--Make sure any suspended foreground task is awake.}
fBackGround:=FALSE;
ACTIVATE_PROCESS(cError,CallerID,FALSE);

{--Open communications channels}
WITH Listen DO BEGIN
  CLOSE_EVENT_CHN(cError,refnum);
  KILL_EVENT_CHN(cError,ChName);
END;
WITH ListenCall DO BEGIN
  CLOSE_EVENT_CHN(cError,refnum);
  KILL_EVENT_CHN(cError,ChName);
END;

PsNonPreemptive;
{--Make sure any dialog goes away if we die in a dialog}
DialogHeight(0,FALSE);

IF (DWPrinter <> NIL) THEN BEGIN
  RhClosePort(DWPrinter^^.PrRec.PrInfo.Port);
  DWPrinter^^.SonID:=PrNilProcess;
END;

DWDlgQuit;

PrMgrDSUnBind(cError);

CLOSE_DATASEG(cError,QDHRefNum);    {--Get rid of the heap data seg}
PsPreemptive;

END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE Main;
VAR
  cError    : TC;
  FileID    : TPrFileID;
BEGIN
REPEAT
  {--Get a command and do something}
  IF (DWGo = FALSE) THEN DocEnd(DWPrRec);
  CASE PrAccept(Listen) OF
    {--A Print Job}
    EPrintRequest: WITH Listen.EvBlock DO BEGIN
      FileID.LongID:=eventLongs[1];  {--The pic file ID to print}
      GetFileName(FileID);           {--Fills in the name of the file from the ID}
      CASE FileID.BlockNum OF
        0:  BEGIN
          IF (FileID.ID <> lastDoc) THEN BEGIN
            lastDoc:=FileID.ID;
            firstpage:=TRUE;
          END;
          {--Pass only DWPrRec to these procedures else Bottlenecks die.}
          DocBegin(FileID.sFileName,DWPrRec);
          PrintFile(FileID.sFileName,DWPrRec);
        END;

        LastBlock:  BEGIN
          DocEnd(DWPrRec);
        END;

        OTHERWISE PrintFile(FileID.sFileName,DWPrRec);
      END;
      {--Decrement the number of copies field and tell papa we're done printing.}
      PrCall(cError,lParentID,EDone,FileID.LongID,eventLongs[2]-1,0,0);
    END;

    {--Update the metrics for this device}
    EMetrics:  BEGIN
      DWPrRec:=DWPrinter^^.PrRec;
      DWDefMetrics(DWPrRec);
      WITH DWPrinter^^, PrRec.PrInfo, Listen.EvBlock DO BEGIN
        PrRec:=DWPrRec;
        PrinterID:=eventLongs[2];   {--Contains the printer ID from dad}
        Port     :=eventLongs[3];   {--The port number from dad.}
        IF (fPrPrfValid(JLPrRec) = FALSE) THEN BEGIN
          JLPrRec:=PrRec;
        END;
      END;
    END;

    {--Update the printer handle.  The first event received after start up.  Used to synchronize and
       initialize some of our globals.}
    ETalkToMe:  BEGIN
      DWPrinter:=POINTER(Listen.EvBlock.event_text[1]); {--Points into DataSeg space to which we're bound.}
      DWPrinter^^.SonID:=MY_ID;  {--Lets everyone know that I'm alive.}
      JLPrRec:=DWPrinter^^.PrRec;
    END;

    OTHERWISE {We're not equipped to handle anything else};
  END;
UNTIL FALSE;
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE PrintFile{(VAR FileName:STR255;VAR PrRec:TPrRec)};
VAR
  PageCount   : TC;
  rFrame      : Rect;
  hPic        : PicHandle;
  DWPtr       : TpDWRec;
  Dummy,Delta : TL;
  DSInfo      : DSInfoRec;
  PicLong     : TL;
  CurPicSize  : TL;
  LeftOver    : TL;
  DWDevInfo   : TPrDevInfo;
BEGIN
  IF (FilRefNum = PrNilRefNum) THEN IF DWGo THEN BEGIN
    DWDevInfo:=PrRec.PrDevInfo;       {--Save the DevInfo established by DocBegin}
    DWOpenFile(FileName,PrRec);
    PrRec.PrDevInfo:=DWDevInfo;       {--Save the DevInfo established by DocBegin}
  END;
  DWPtr:=@PrRec.PrDevInfo;
  INFO_DATASEG(cError,PicRefNum,DSInfo);
  LeftOver:=DSInfo.mem_size-cPicDataSize;
  PageCount:=1;

  IF DWGo THEN REPEAT
    {--Size the dataseg to make room for the proper size picture}
    PicLong:=hPfPages^^[PageCount].Length;
    INFO_DATASEG(cError,PicRefNum,DSInfo);
    Delta:=PicLong-(DSInfo.mem_size-LeftOver);
    IF (Delta > 0) THEN IF DWGo THEN BEGIN {--Seg must grow}
      SIZE_DATASEG(cError,PicRefNum,Delta,Dummy,Delta,Dummy);
    END;

    PfSetPos(cError,hPfPages^^[PageCount].Start,FilRefNum);
    DWReadPicture(hPfPages^^[PageCount].Length,FilRefNum);

    DWGetPicProc(@rFrame,8);
    PsNonPreemptive;
    hPic:=OpenPicture(rFrame);
    ClosePicture;
    PsPreemptive;

    DWPrintPicture(PrRec,hPic,rFrame);
    DWPageEnd;

    DisposeHandle(POINTER(hPic));
    PageCount:=PageCount+1;
  UNTIL (PageCount > PrRec.PrJobInfo.SpooledPages) OR (DWGo = FALSE);

    {--Size this thing back down to original size}
  INFO_DATASEG(cError,PicRefNum,DSInfo);
  Delta:=LeftOver+cPicDataSize-DSInfo.mem_size;
  IF (Delta < 0) THEN BEGIN
    SIZE_DATASEG(cError,PicRefNum,Delta,Dummy,Delta,Dummy);
  END;

  CLOSE_OBJECT(cError,FilRefNum);
  FilRefNum:=PrNilRefNum;
END;

{================================================================================}
{$S Finish}
PROCEDURE PrSysTerm{(environPtr:p_env_blk;excepDataPtr:p_ex_data)};
BEGIN
{$IFC PrDebug}
WRITELN('DaisyWheel: PrSysTerm');
{$ENDC}
DWQuit;
END;

{================================================================================}
{$S DaisyWheel}
PROCEDURE SetPrinter{(VAR PrRec:TPrRec)};
VAR
  DWPtr     : TpDWRec;
  JLPtr     : TpDWRec;
  opt       : TC;
BEGIN
  DWPtr:=@PrRec.PrDevInfo;
  JLPtr:=@JLPrRec.PrDevInfo;
  WITH PrRec.PrInfo.PgSize, DWPtr^.DWCfg, JLPrRec.PrInfo, JLPtr^ DO BEGIN
    IF (PaperDirect <> PgSize.PaperDirect) OR
       (PrintDirect <> PgSize.PrintDirect) OR
       (Width       <> PgSize.Width      ) OR
       (Height      <> PgSize.Height     ) OR
       (feeder      <> DWCfg.feeder      ) OR
       (wheel       <> DWCfg.wheel       ) THEN BEGIN
         opt:=RhDOAlert(cAxHardChange,NoteProc);
    END;
  END;
END;

{================================================================================}
{$S Finish}
PROCEDURE Suicide;
BEGIN
EXIT(DaisyWheel);
END;

{================================================================================}
{$S     }
BEGIN
DWInit;
Main;
DWQuit;
END.
{================================================================================}


