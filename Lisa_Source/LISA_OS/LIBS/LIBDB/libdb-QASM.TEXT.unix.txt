LTVAL           .EQU    0
GTVAL           .EQU    1
EQVAL           .EQU    2

OFFSET          .EQU    0
DIRECT          .EQU    2
FTYPE           .EQU    3
SIZE            .EQU    4
NBITS           .EQU    4
SBIT            .EQU    5
FDESCSIZE       .EQU    6

FTYPVSTR        .EQU    9
FTYPVNULL       .EQU    10
FTYPSVSTR       .EQU    11
FTYPSVNULL      .EQU    12

        .SEG    "access"
        .FUNC   ENTRYSIZE,16

;------------------------------------------------------------------------
;
;       FUNCTION ENTRYSIZE(FIRSTFLD,LASTFLD,DOITFLD,ISIZE : INTEGER;
;                          PEDESC : PTRRECPTR;
;                          PREC : PTRDATA) : INTEGER;
;
;       RETURNS SIZE OF RECORD @ PREC^ BY ADDING SIZES OF ALL VAR. LEN
;       FIELDS TO ISIZE.  CHECKS FIELDS FIRSTFLD TO LASTFLD FOR VAR.
;       LEN FIELDS.  IF DOITFLD IS -1 THEN THERE ARE NO VAR. LEN. FLDS
;
;
;       USES
;               A0,A1,A2
;               D0,D1
;
;       SAVES
;               A2
;
NPARM           .EQU    16
FIRSTFLD        .EQU    18
LASTFLD         .EQU    16
DOITFLD         .EQU    14
ISIZE           .EQU    12
PEDESC          .EQU    8
PREC            .EQU    4

        MOVE.W  ISIZE(SP),D0            ;D0 := ISIZE
        TST.W   DOITFLD(SP)             ;
        BLT.S   RETURN                  ;IF DOITFLD >= 0 THEN
        MOVE.L  PEDESC(SP),A0           ;  BEGIN
        MOVE.W  FIRSTFLD(SP),D1         ;  A0 := @PEDESC^[FIRSTFLD];
        MULU    #FDESCSIZE,D1
        ADDA.L  D1,A0
        MOVE.L  PREC(SP),A1             ;  A1 := PREC
        MOVE.W  LASTFLD(SP),D1          ;  CNT := LASTFLD-FIRSTFLD
        SUB.W   FIRSTFLD(SP),D1

        MOVE.L  D2,-(SP)                ;  SAVE A2
                                        ;  REPEAT
ADDVAR  CMPI.B  #FTYPVSTR,FTYPE(A0)     ;    IF A0^.FTYPE >= FTYPVSTR THEN
        BLT.S   @1                      ;      BEGIN
        MOVE.W  OFFSET(A0),D2           ;      P(S)VFLD := @PREC^[A0^.OFFSET]
        CMPI.B  #FTYPSVSTR,FTYPE(A0)    ;      IF A0^.FTYPE >= FTYPSVSTR THEN
        BLT.S   @2                      ;          BEGIN
        MOVE.W  0(A1,D2),D2             ;          ISIZE +:= PSVFLD^.SIZE
        ANDI.W  #$003F,D2               ;
        ADD.W   D2,D0                   ;
        BRA.S   @1                      ;          END
                                        ;      ELSE
@2      ADD.W   0(A1,D2),D0             ;          ISIZE +:= PVFLD^.SIZE
                                        ;      END
@1      ADDQ.L  #FDESCSIZE,A0           ;    A0++
        DBF     D1,ADDVAR               ;    CNT--
                                        ;  UNTIL CNT < 0
        MOVE.L  (SP)+,D2                ;  RESTORE A2

RETURN  BTST    #0,D0                   ;IF ODD(ISIZE) THEN ISIZE +:= 1
        BEQ.S   @2
        ADDQ.W  #1,D0

@2      MOVE.L  (SP)+,A0
        MOVEQ   #NPARM,D1
        ADDA.L  D1,SP
        MOVE.W  D0,(SP)                 ;ENTRYSIZE := ISIZE
        JMP     (A0)


        .PROC EXTRACTKEY,20
        .REF  EXTFLD,DEPFLD

;------------------------------------------------------------------------
;       PROCEDURE EXTRACTKEY(PDESC1
;                            PDESC2  : PTRRECPTR;
;                            NFIELDS  : INTEGER;
;                            PREC1,
;                            PREC2    : PTRDATA;
;                            VFLDS    : INTEGER)
;
;       USES
;               A0,A1,A2,A3
;               D0,D1,D2,D3,D4
;
;       SAVES
;               A2,A3
;               D2,D3,D4
;

PDESC1          .EQU    40
PDESC2          .EQU    36
NFIELDS         .EQU    34
PREC1           .EQU    30
PREC2           .EQU    26
VFLDS           .EQU    24
NPARMS          .EQU    20

        MOVEM.L D2-D4/A2-A3,-(SP)
        MOVE.W  NFIELDS(SP),D4                  ;NFIELDS
        MOVE.L  PDESC1(SP),A2                   ;@PDESC1
        MOVE.L  PDESC2(SP),A3                   ;@PDESC2


TLOOP   MOVEA.W OFFSET(A2),A0                   ;A0 := @FIELD1[I]
        MOVEA.W OFFSET(A3),A1                   ;A1 := @FIELD2[I]
        ADDA.L  PREC1(SP),A0
        ADDA.L  PREC2(SP),A1
        CLR.W   D0
        MOVE.B  FTYPE(A2),D0                    ;CASE PDESC1^[I].FTYPE OF
        ADD.W   D0,D0
        JMP     JTAB(D0)


CASE1                                           ;0..255
        MOVE.B  (A0),(A1)
        BRA.S   LOOPTST

CASE2                                           ;16 BIT INTEGER
        MOVE.W  (A0),(A1)
        BRA.S   LOOPTST

CASE5                                           ;32 BIT UNSIGNED INTEGER
CASE3                                           ;32 BIT INTEGER
        MOVE.L  (A0),(A1)
        BRA.S   LOOPTST

CASE4                                           ;64 BIT INTEGER
        MOVE.L  (A0)+,(A1)+
        MOVE.L  (A0),(A1)
        BRA.S   LOOPTST

CASE7                                           ;PACKED FIELD
        CLR.W   D1                              ;D1 := PDESC1^[I].BO.SBIT
        MOVE.B  SBIT(A2),D1
        CLR.W   D2
        MOVE.B  NBITS(A2),D2                    ;D2 := PDESC1^[I].BO.NBITS
        JSR     EXTFLD                          ;D0 := EXTRACTED FLD
        CLR.W   D2
        MOVE.B  NBITS(A3),D2                    ;D2 := PDESC2^[I].BO.NBITS
        JSR     DEPFLD
        BRA.S   LOOPTST

;-------------------------------THIS CODE MOVED TO SHORTEN BRANCH LENGTHS

                                                ;JUMPTABLE FOR CASE
JTAB    BRA.S   CASE0                           ;PACKED ARRAY OF BYTE
        BRA.S   CASE1                           ;INT1
        BRA.S   CASE2                           ;INT2
        BRA.S   CASE3                           ;INT4
        BRA.S   CASE4                           ;INT8
        BRA.S   CASE5                           ;UNSINT4
        BRA.S   CASE6                           ;TICKET
        BRA.S   CASE7                           ;PACKED FIELD
        BRA.S   CASE8                           ;PACKED ARRAY OF CHAR
        BRA.S   CASE9                           ;VAR. LEN. CHAR ARRAY
        BRA.S   CASE10                          ;VAR. LEN. BYTE ARRAY
        BRA.S   CASE11                          ;SHORT VAR. LEN. CHAR ARRAY
        BRA.S   CASE12                          ;SHORT VAR. LEN. BYTE ARRAY


LOOPTST ADDQ.L  #FDESCSIZE,A2                   ;A2 ++
        ADDQ.L  #FDESCSIZE,A3                   ;A3 ++
        SUBQ.W  #1,D4                           ;TEST AGAINST END OF ARRAY
        BNE.S   TLOOP

        MOVEM.L (SP)+,D2-D4/A2-A3
        MOVE.L  (SP)+,A0                        ;POP RETURN ADDRESS
        MOVEQ   #NPARMS,D0                      ;AND PARAMETERS
        ADDA.L  D0,SP
        JMP     (A0)                            ;RTS





CASE11                                          ;SHORT VAR. LEN. CHAR ARRAY
CASE12                                          ;SHORT VAR. LEN. BYTE ARRAY
        MOVE.W  (A0),D0                         ;D0 := OFFSET:LEN1
        MOVE.W  D0,D1                           ;A0 := OFFSET1
        ANDI.W  #$003F,D0                       ;D0 := LEN1
        LSR.W   #6,D1
        MOVEA.W D1,A0
        MOVE.W  VFLDS(SP),D1                    ;D1 := VFLD OFFSET;LEN1
        MOVE.W  D1,D2
        LSL.W   #6,D1
        OR.W    D0,D1
        MOVE.W  D1,(A1)                         ;STORE NEW DESCRIPTOR
        MOVEA.W D2,A1                           ;A1 := OFFSET2
        BRA.S   VARLEN

CASE9                                           ;VAR. LEN. CHAR ARRAY
CASE10                                          ;VAR. LEN. BYTE ARRAY
        MOVE.W  (A0)+,D0                        ;D0 := LEN1
        MOVE.W  D0,(A1)+                        ;LEN2 := LEN1
        MOVE.W  VFLDS(SP),D1                    ;D1 := CURRENT VFLD OFFSET
        MOVE.W  D1,(A1)                         ;OFFSET2 := CURRENT VFLD OFF
        MOVEA.W (A0),A0                         ;A0 := OFFSET1
        MOVEA.W D1,A1                           ;A1 := OFFSET2
VARLEN  TST     D0
        BEQ.S   LOOPTST                         ;CHECK IF NULL STRING
        ADD.W   D0,VFLDS(SP)                    ;VFLDS :=+ LEN2
        ADDA.L  PREC1(SP),A0                    ;A0 := @FIELD1
        ADDA.L  PREC2(SP),A1                    ;A1 := @FIELD2
        BRA.S   BTRANS

CASE0                                           ;PACKED ARRAY OF 0..255
CASE6                                           ;TICKET FIELD
CASE8                                           ;PACKED ARRAY OF CHAR
        MOVE.W  SIZE(A3),D0                     ;D0 := DESCRIPT^[I].SIZE
BTRANS  MOVE.B  (A0)+,(A1)+                     ;TRANSFER FOR SIZE BYTES
        SUBQ.W  #1,D0
        BNE.S   BTRANS
        BRA.S   LOOPTST



        .FUNC COMPARE,18
        .REF  EXTFLD
        .REF  CompChrMagnitude;(char1,char2 : compstrp;length1,length2 : integer;
                              ; veryWeak : boolean)

;------------------------------------------------------------------------
;       FUNCTION COMPARE(PDESC1
;                        PDESC2  : PTRRECPTR;
;                        NFIELDS  : INTEGER;
;                        PREC1,
;                        PREC2    : PTRDATA) : INTEGER
;
;       USES
;               A0,A1,A2,A3
;               D0,D1,D2,D3,D4
;
;       SAVES
;               A2-A3
;               D2-D4
;

PDESC1          .EQU    38
PDESC2          .EQU    34
NFIELDS         .EQU    32
PREC1           .EQU    28
PREC2           .EQU    24
NPARMS          .EQU    18


        MOVEM.L D2-D4/A2-A3,-(SP)
        MOVE.W  NFIELDS(SP),D4                  ;NFIELDS
        MOVE.L  PDESC1(SP),A2                   ;@PDESC1
        MOVE.L  PDESC2(SP),A3                   ;@PDESC2


CLOOP   MOVEA.W OFFSET(A2),A0                   ;A0 := @FIELD1[I]
        MOVEA.W OFFSET(A3),A1                   ;A1 := @FIELD2[I]
        ADDA.L  PREC1(SP),A0
        ADDA.L  PREC2(SP),A1
        CLR.W   D0
        MOVE.B  FTYPE(A2),D0                    ;CASE PDESC1^[I].FTYPE OF
        ADD.W   D0,D0
        JMP     JTAB(D0)

CASE1                                           ;-128..127 6-3-83
        CMPM.B  (A1)+,(A0)+
        BRA.S   SIGNED                          ;!6-3-83

CASE2                                           ;16 BIT INTEGER
        CMPM.W  (A1)+,(A0)+
        BRA.S   SIGNED

CASE4                                           ;64 BIT INTEGER
        CMPM.L  (A1)+,(A0)+
        BEQ.S   CASE5
        BGT.S   RETGT
        BRA.S   RETLT

CASE3                                           ;32 BIT INTEGER
        CMPM.L  (A1)+,(A0)+
SIGNED  BEQ.S   LOOPTST
        BGT.S   RETGT
        BRA.S   RETLT

CASE5                                           ;32 BIT UNSIGNED INTEGER
        CMPM.L  (A1)+,(A0)+
UNSIGN  BEQ.S   LOOPTST
        BHI.S   RETGT
        BRA.S   RETLT

CASE7                                           ;PACKED FIELD
        CLR.W   D1                              ;D1 := PDESC1^[I].BO.SBIT
        MOVE.B  SBIT(A2),D1
        CLR.W   D2
        MOVE.B  NBITS(A2),D2                    ;D2 := PDESC1^[I].BO.NBITS
        JSR     EXTFLD                          ;D0 := EXTRACTED FLD
        MOVE.W  D0,D3
        MOVE.L  A1,A0
        CLR.W   D2
        MOVE.B  NBITS(A3),D2                    ;D2 := PDESC2^[I].BO.NBITS
        JSR     EXTFLD
        CMP.W   D0,D3
        BRA.S   UNSIGN

CASE8                                           ;INTERNATIONAL STRINGS
        MOVE.W  SIZE(A2),D0                     ;D0 := DESCRIPT^[I].SIZE
        move.w  d0,d1                           ;length1 = length2
        BRA     scomp

CASE6                                           ;TICKET (UNSIGNED INTEGER)
CASE0                                           ;PACKED ARRAY OF 0..255
        MOVE.W  SIZE(A2),D0                     ;D0 := PDESC1^[I].SIZE
BCOMP   CMPM.B  (A1)+,(A0)+                     ;COMPARE FOR SIZE BYTES
        BEQ.S   TESTCNT
        BHI.S   RETGT
        BRA.S   RETLT
TESTCNT SUBQ.W  #1,D0
        BNE.S   BCOMP
        BRA     LOOPTST

RETGT   CLR.W   D0                              ;CHECK DIRECTION TO SEE IF
        TST.B   DIRECT(A2)                      ;MEANING OF COMPARE IS REVERSED
        BNE.S   RETALL
        ADDQ.W  #1,D0
@1      BRA.S   RETALL

RETLT   CLR.W   D0
        TST.B   DIRECT(A2)
        BEQ.S   RETALL
        ADDQ.W  #1,D0
@2      BRA.S   RETALL

;------------------------------- THIS CODE MOVED HERE TO REDUCE BRANCH LENGTH


JTAB                                            ;JUMPTABLE FOR CASE
        BRA.S   CASE0                           ;PACKED ARRAY OF BYTE
        BRA.S   CASE1                           ;INT1
        BRA.S   CASE2                           ;INT2
        BRA.S   CASE3                           ;INT4
        BRA.S   CASE4                           ;INT8
        BRA.S   CASE5                           ;UNSINT4
        BRA.S   CASE6                           ;TICKET
        BRA.S   CASE7                           ;PACKED FIELD
        BRA.S   CASE8                           ;PACKED ARRAY OF CHAR
        BRA.S   CASE9                           ;VAR. LEN. CHAR ARRAY
        BRA.S   CASE10                          ;VAR. LEN. BYTE ARRAY
        BRA.S   CASE11                          ;SHORT VAR. LEN. CHAR ARRAY
        BRA.S   CASE12                          ;SHORT VAR. LEN. BYTE ARRAY


LOOPTST ADDQ.L  #FDESCSIZE,A2                   ;A2 ++
        ADDQ.L  #FDESCSIZE,A3                   ;A3 ++
        SUBQ.W  #1,D4                           ;TEST AGAINST END OF ARRAY
        BNE.S   CLOOP
        MOVE.W  #EQVAL,D0                       ;ALL FIELDS ARE EQUAL

RETALL  MOVEM.L (SP)+,D2-D4/A2-A3
        MOVE.L  (SP)+,A0                        ;POP RETURN ADDRESS
        MOVEQ   #NPARMS,D1
        ADDA.L  D1,SP
        MOVE.W  D0,(SP)                         ;STORE RETURN VALUE
        JMP     (A0)


CASE11                                          ;var len(short) array of char
CASE12                                          ;var len(short) array of byte
        MOVE.W  (A0),D0                         ;D0 := OFFSET1:LEN1
        MOVE.W  D0,D1                           ;A0 := OFFSET1
        ANDI.W  #$003F,D0
        LSR.W   #6,D1
        MOVEA.W D1,A0
        MOVE.W  (A1),D1                         ;D1 := OFFSET2:LEN2
        MOVE.W  D1,D2                           ;A1 := OFFSET1
        ANDI.W  #$003F,D1
        LSR.W   #6,D2
        MOVEA.W D2,A1
        MOVE.B  FTYPE(A2),D3
        CMPI.B  #FTYPSVSTR,D3
        BEQ.S   VARCHAR
        BRA.S   VARBYTE

CASE9                                           ;VAR. LEN. CHAR ARRAY
        MOVE.W  (A0)+,D0                        ;D0 := LEN1
        MOVE.W  (A1)+,D1                        ;D1 := LEN2
        MOVEA.W (A0),A0                         ;A0 := OFFSET1
        MOVEA.W (A1),A1                         ;A1 := OFFSET2
VARCHAR ADDA.L  PREC1(SP),A0                    ;A0 := @FIELD1
        ADDA.L  PREC2(SP),A1                    ;A1 := @FIELD2
        BRA.S   scomp

CASE10                                          ;VAR. LEN. BYTE ARRAY
        MOVE.W  (A0)+,D0                        ;D0 := LEN1
        MOVE.W  (A1)+,D1                        ;D1 := LEN2
        MOVEA.W (A0),A0                         ;A0 := OFFSET1
        MOVEA.W (A1),A1                         ;A1 := OFFSET2
VARBYTE ADDA.L  PREC1(SP),A0                    ;A0 := @FIELD1
        ADDA.L  PREC2(SP),A1                    ;A1 := @FIELD2
        CMP.W   D1,D0                           ;COMPARE FOR SHORTER LENGTH
        MOVE    SR,D3                           ;SAVE CCR
        BLS.S   @1
        MOVE.W  D1,D0
@1      TST     D0
        BEQ.S   COMPEQ                          ;TRAP 0 LENGTH STRINGS

COMPB   CMPM.B  (A1)+,(A0)+                     ;COMPARE FOR SIZE BYTES
        BEQ.S   TEST
        BHI.S   RETGT
        BRA.S   RETLT
TEST    SUBQ.W  #1,D0
        BNE.S   COMPB
        BRA.S   COMPEQ                          ;COMPARED EQUAL,CHECK LEN'S

COMPEQ  MOVE    D3,CCR                          ;INCONCLUSIVE - LONGEST WINS
        BEQ.S   LOOPTST
COMPNE  BHI.S   RETGT
        BRA.S   RETLT

;       calls international compare routine
;       a0 - @array 1
;       a1 - @array 2
;       d0 - length 1
;       d1 - length 2
;       preserves  a2
;       destroys  a0-a1/d0-d3

scomp   move.l  a2,-(sp)
        clr.w   -(sp)
        move.l  a0,-(sp)
        move.l  a1,-(sp)
        move.w  d0,-(sp)
        move.w  d1,-(sp)
        move.b  #1,-(sp)                        ;very weak
        jsr     CompChrMagnitude
        move.w  (sp)+,d0                        ;sets CC from -1,0,1
        movea.l (sp)+,a2                        ;CC unaffected
        bra.s   signed


        .FUNC FINDCHANGES,18
        .REF  EXTFLD

;------------------------------------------------------------------------
;       FUNCTION FINDCHANGES(PDESC1 : PTRRECPTR;
;                            NFIELDS  : INTEGER;
;                            PREC1,
;                            PREC2    : PTRDATA;
;                            PSET : PTRBITS) : BOOLEAN
;
;       FINDS ALL FIELDS THAT ARE DIFFERENT BETWEEN PREC1 AND PREC2 AND
;       SETS THE APPROPRIATE BITS IN PSET.  IF A TICKET IS CHANGED THEN
;       RETURNS TRUE ELSE RETURNS FALSE
;
;       USES
;               A0,A1,A2
;               D0,D1,D2,D3,D4,D5
;
;       SAVES
;               A2
;               D2-D5
;
RETVAL          .EQU    42
PDESC1          .EQU    38
NFIELDS         .EQU    36
PREC1           .EQU    32
PREC2           .EQU    28
PSET            .EQU    24
NPARMS          .EQU    18

        MOVEM.L D2-D5/A2,-(SP)
        CLR.W   RETVAL(SP)                      ;ASSUME TICKET NOT CHANGED

        MOVE.W  NFIELDS(SP),D5                  ;NFIELDS
        MOVE.L  PDESC1(SP),A2                   ;@PDESC1

        CLR.W   D3                              ;D3 WILL BE CURRENT WORD OF
                                                ;BITMAP
        CLR.W   D4                              ;D4 WILL BE CURRENT BIT IN D3

CLOOP   MOVEA.W OFFSET(A2),A0                   ;A0 := @FIELD1[I]
        MOVEA.L A0,A1                           ;A1 := @FIELD2[I]
        ADDA.L  PREC1(SP),A0
        ADDA.L  PREC2(SP),A1
        CLR.W   D0
        MOVE.B  FTYPE(A2),D0                    ;CASE PDESC1^[I].FTYPE OF
        ADD.W   D0,D0
        JMP     JTAB(D0)

CASE1                                           ;0..255
        CMPM.B  (A1)+,(A0)+
        BEQ.S   COMPEQ
        BRA.S   COMPNE

CASE2                                           ;16 BIT INTEGER
        CMPM.W  (A1)+,(A0)+
        BEQ.S   COMPEQ
        BRA.S   COMPNE

CASE7                                           ;PACKED FIELD
        CLR.W   D1                              ;D1 := PDESC1^[I].BO.SBIT
        MOVE.B  SBIT(A2),D1
        CLR.W   D2
        MOVE.B  NBITS(A2),D2                    ;D2 := PDESC1^[I].BO.NBITS
        JSR     EXTFLD                          ;D0 := EXTRACTED FLD
        MOVE.L  A1,A0
        CLR.W   D2
        MOVE.B  NBITS(A2),D2                    ;D2 := PDESC1^[I].BO.NBITS
        MOVE.W  D0,-(SP)
        JSR     EXTFLD
        CMP.W   (SP)+,D0
        BEQ.S   COMPEQ
        BRA.S   COMPNE

CASE8                                           ;CASE INSENSITIVE STRINGS
CASE0                                           ;PACKED ARRAY OF 0..255
        MOVE.W  SIZE(A2),D0                     ;D0 := PDESC1^[I].SIZE
BCOMP   CMPM.B  (A1)+,(A0)+                     ;COMPARE FOR SIZE BYTES
        BNE.S   COMPNE                          ;BREAK IF NOT EQUAL
        SUBQ.W  #1,D0
        BNE.S   BCOMP
        BRA.S   COMPEQ


CASE4                                           ;64 BIT INTEGER
        CMPM.L  (A1)+,(A0)+
        BEQ.S   CASE5
        BRA.S   COMPNE
CASE3                                           ;32 BIT INTEGER
CASE5                                           ;32 BIT UNSIGNED INTEGER
        CMPM.L  (A1)+,(A0)+
        BEQ.S   COMPEQ
        BRA.S   COMPNE

CASE6                                           ;TICKET
        MOVE.W  SIZE(A2),D0                     ;D0 := PDESC1^[I].SIZE
TCOMP   CMPM.B  (A1)+,(A0)+                     ;COMPARE FOR SIZE BYTES
        BNE.S   TICKNE                          ;BREAK IF NOT EQUAL
        SUBQ.W  #1,D0
        BNE.S   TCOMP
        BRA.S   COMPEQ
TICKNE  MOVE.B  #1,RETVAL(SP)                   ;A NO-NO
        BRA.S   COMPNE

;--------------------------------THIS CODE MOVED TO SHORTEN BRANCH LENGTH

JTAB                                            ;JUMPTABLE FOR CASE
        BRA.S   CASE0                           ;PACKED ARRAY OF BYTE
        BRA.S   CASE1                           ;INT1
        BRA.S   CASE2                           ;INT2
        BRA.S   CASE3                           ;INT4
        BRA.S   CASE4                           ;INT8
        BRA.S   CASE5                           ;UNSINT4
        BRA.S   CASE6                           ;TICKET
        BRA.S   CASE7                           ;PACKED FIELD
        BRA.S   CASE8                           ;PACKED ARRAY OF CHAR
        BRA.S   CASE9                           ;VAR. LEN. CHAR ARRAY
        BRA.S   CASE10                          ;VAR. LEN. BYTE ARRAY
        BRA.S   CASE11                          ;SHORT VAR. LEN. CHAR ARRAY
        BRA.S   CASE10                          ;SHORT VAR. LEN. BYTE ARRAY

COMPNE  BSET    D4,D3                           ;SET BIT IF CHANGED
COMPEQ  CMPI.W  #15,D4                          ;STORE WORD ON BIT 15
        BNE.S   INCR                            ;ELSE JUST INCR BIT#
        MOVE.L  PSET(SP),A0                     ;USE PSET FOR LOCAL VAR.
        MOVE.W  D3,(A0)+
        MOVE.L  A0,PSET(SP)
        CLR.W   D4
        CLR.W   D3
        BRA.S   LOOPTST
INCR    ADDQ.W  #1,D4

LOOPTST ADDQ.L  #FDESCSIZE,A2                   ;A2 ++
        SUBQ.W  #1,D5                           ;TEST AGAINST END OF ARRAY
        BNE.S   CLOOP

        ANDI.W  #$000F,NFIELDS(SP)              ;IF NFIELDS MOD 16 <> 0
        BEQ.S   @1                              ;THEN STORE LAST WORD
        MOVE.L  PSET(SP),A0                     ;USE PSET FOR LOCAL VAR.
        MOVE.W  D3,(A0)

@1      MOVEM.L (SP)+,D2-D5/A2
        MOVE.L  (SP)+,A0                        ;POP RETURN ADDRESS
        MOVEQ   #NPARMS,D1
        ADDA.L  D1,SP
        JMP     (A0)



CASE11                                          ;SHORT VAR. LEN. CHAR ARRAY
CASE12                                          ;SHORT VAR. LEN. BYTE ARRAY
        MOVE.W  (A0),D0                         ;D0 := OFFSET1:LEN1
        MOVE.W  D0,D1                           ;A0 := OFFSET1
        ANDI.W  #$003F,D0
        LSR.W   #6,D1
        MOVEA.W D1,A0
        MOVE.W  (A1),D1                         ;D1 := OFFSET2:LEN2
        MOVE.W  D1,D2                           ;A1 := OFFSET1
        ANDI.W  #$003F,D1
        CMP.W   D0,D1
        BNE.S   COMPNE
        LSR.W   #6,D2
        MOVEA.W D2,A1
        BRA.S   VARLEN

CASE9                                           ;VAR. LEN. CHAR ARRAY
CASE10                                          ;VAR. LEN. BYTE ARRAY
        MOVE.W  (A0)+,D0                        ;D0 := LEN1
        CMP.W   (A1)+,D0                        ;CHECK FOR EQUAL LENGTH
        BNE.S   COMPNE
        MOVEA.W (A0),A0                         ;A0 := OFFSET1
        MOVEA.W (A1),A1                         ;A1 := OFFSET2
VARLEN  TST     D0
        BEQ.S   COMPEQ                          ;TRAP 0 LENGTH STRINGS
        ADDA.L  PREC1(SP),A0                    ;A0 := @FIELD1
        ADDA.L  PREC2(SP),A1                    ;A1 := @FIELD2
        BRA.S   BCOMP


        .FUNC EXTRACT,8
        .DEF  EXTFLD,DEPFLD

;----------------------------------------------------
;       FUNCTION EXTRACT(PBYTE : PTRDATA;NBIT,SBIT : INTEGER) : INTEGER
;
;       !!!!!  PBYTE MUST POINT TO A WORD
;
;       USES
;               A0,A1
;               D0,D1,D2
;
;       SAVES
;               D2
;
        MOVE.L  (SP)+,A1                        ;STRIP RETURN ADDRESS
        MOVE.W  (SP)+,D1                        ;STARTING BIT D1
        MOVE.W  (SP)+,D0                        ;NUMBER OF BITS D0
        MOVE.L  (SP)+,A0                        ;GET PBYTE INTO A0
        MOVE.L  D2,-(SP)
        MOVE.L  D0,D2
        BSR     EXTFLD
        MOVE.L  (SP)+,D2
        MOVE.W  D0,(SP)                         ;RETURN VALUE
        JMP     (A1)                            ;RTS

;----------------------------------------------------------------
;       FUNCTION EXTFLD(A0,D1,D2) : D0
;
;       INPUT PARAMETERS
;               A0 - @OF WORD WITH PACKED FIELD
;               D1 - STARTING BIT (RIGHTMOST) OF FIELD
;               D2 - NUMBER OF BITS IN FIELD
;
;       OUTPUT PARAMETERS
;               D0 - EXTRACTED FIELD
;
;       USES
;               A0
;               D0,D2

EXTFLD  ADD.W   D2,D2                           ;MAKE INTO WORD INDEX
        MOVE.W  (A0),D0                         ;LOAD PBYTE^ INTO D0
        LEA     EMASK,A0                        ;GET MASK INTO D2
        MOVE.W  0(A0,D2),D2
        LSR.W   D1,D0                           ;MASK OUT OLD VALUE
        AND.W   D2,D0
        RTS

;-----------------------------------------------------------------------
;       PROCEDURE DEPFLD(A1,D0,D1,D2)
;
;       DEPOSIT DO IN PACKED FIELD
;
;       INPUT PARAMETERS
;               A1 - ADDRESS OF WORD WHERE D0 WILL GO
;               D0 - VALUE OF PACKED FIELD
;               D1 - STARTING BIT OF FIELD (RIGHTMOST)
;               D2 - NUMBER OF BITS IN FIELD
;
;       USES
;               A0
;               D0,D2,D3
;

DEPFLD  ADD.W   D2,D2                           ;MAKE INTO WORD INDEX
        LEA     EMASK,A0                        ;GET MASK INTO D2
        MOVE.W  0(A0,D2),D2
        NOT.W   D2
        ROL.W   D1,D2                           ;MASK OUT OLD VALUE
        MOVE.W  (A1),D3                         ;LOAD PBYTE^ INTO D3
        AND.W   D2,D3
        LSL.W   D1,D0                           ;DEPOSIT NEW VALUE
        OR.W    D0,D3
        MOVE.W  D3,(A1)                         ;STORE IN PBYTE^
        RTS                                     ;RTS


EMASK   .WORD $0000,$0001,$0003,$0007,$000F,$001F,$003F,$007F
        .WORD $00FF,$01FF,$03FF,$07FF,$0FFF,$1FFF,$3FFF,$7FFF


        .PROC DEPOSIT,10
        .REF  DEPFLD

;----------------------------------------------------
;       PROCEDURE  DEPOSIT(VALUE : INTEGER;PBYTE : PTRDATA;
;                          NBIT,SBIT INTEGER)
;
;       !!!!!!! PBYTE MUST POINT TO A WORD
;
;       USES
;               A0,A1
;               D0,D1,D2,D3
;
;       SAVES
;               D2,D3
;
VALUE   .EQU    20
PBYTE   .EQU    16
NBIT    .EQU    14
PSBIT   .EQU    12
PARMS   .EQU    10


        MOVEM.L D2-D3,-(SP)
        MOVE.W  PSBIT(SP),D1                    ;STARTING BIT D1
        MOVE.W  NBIT(SP),D2                     ;NUMBER OF BITS D2
        MOVE.L  PBYTE(SP),A1                    ;GET PBYTE INTO A1
        MOVE.W  VALUE(SP),D0                    ;LOAD NEW VALUE
        JSR     DEPFLD
        MOVEM.L (SP)+,D2-D3
        MOVE.L  (SP)+,A0                        ;STRIP RETURN ADDRESS
        MOVEQ   #PARMS,D0
        ADDA.L  D0,SP
        JMP     (A0)

        .FUNC COMPHAND,8

;---------------------------------------------------
;       FUNCTION COMPHAND(VAR L1,L2 : FINT8) : INTEGER
;
;       USES
;               D0
;               A0,A1
;
;

        MOVE.L  (SP)+,D0                        ;SAVE RETURN ADDRESS
        MOVE.L  (SP)+,A1                        ;@L2 INTO A1
        MOVE.L  (SP)+,A0                        ;@L1 INTO A0
        CMPM.L  (A1)+,(A0)+                     ;COMPARE L2,L1
        BEQ.S   @1
        BHI.S   RETGT
        BRA.S   RETLT
@1      CMPM.L  (A1)+,(A0)+
        BEQ.S   RETEQ
        BHI.S   RETGT
RETLT   CLR.W   (SP)                            ;LESS THAN (ASSM BUG)
        MOVE.L  D0,A0                           ;PUSH RETURN ADDRESS
        JMP     (A0)
RETGT   MOVE.W  #GTVAL,(SP)                     ;GREATER THAN
        MOVE.L  D0,A0                           ;PUSH RETURN ADDRESS
        JMP     (A0)
RETEQ   MOVE.W  #EQVAL,(SP)                     ;EQUAL
        MOVE.L  D0,A0                           ;PUSH RETURN ADDRESS
        JMP     (A0)


        .FUNC COMP44,8

;---------------------------------------------------
;       FUNCTION COMP44(L1,L2 : FILEPTR) : INTEGER
;
;       USES
;               A0

        MOVE.L  (SP)+,A0                        ;SAVE RETURN ADDRESS
        CMPM.L  (SP)+,(SP)+                     ;L1-L2
        BEQ.S   @1
        BHI.S   @2
        CLR.W   (SP)                            ;LESS THAN (ASSM BUG)
        JMP     (A0)                            ;RTS
@1      MOVE.W  #EQVAL,(SP)                     ;EQUAL
        JMP     (A0)
@2      MOVE.W  #GTVAL,(SP)                     ;GREATER THAN
        JMP     (A0)


        .FUNC   MULT424,6
;-------------------------------------------------------
;       FUNCTION MULT424(M4 : FILEPTR
;                        M2 : INTEGER ) : FILEPTR
;
;       USES
;               A0
;               D0,D1,D2
;       SAVES
;               D2
;
        MOVE.L  (SP)+,A0                        ;RETURN ADDRESS IN A1
        MOVE.W  (SP)+,D1                        ;M2 INTO D1
        MOVE.L  (SP)+,D0                        ;M4 INTO D0
        MOVE.L  D2,-(SP)                        ;SAVE D2
        MOVE.W  D0,D2                           ;M4.LW INTO D2
        SWAP    D0                              ;M4.UW INTO D0
        MULU    D1,D0                           ;D0 := D0 * M2
        LSL.L   #8,D0
        LSL.L   #8,D0
        MULU    D1,D2
        ADD.L   D2,D0                           ;M4*M2 INTO D0
        MOVE.L  (SP)+,D2                        ;RESTORE D2
        MOVE.L  D0,(SP)                         ;STORE IN R4
        JMP     (A0)                            ;RTS


                .FUNC   DIV424,8

;---------------------------------------------------------
;       FUCNTION DIV424(    DIV4 : FILEPTR
;                           DIV2 : INTEGER
;                       VAR R2   : INTEGER) : FILEPTR
;
;       USES
;               A0,A1
;               D0,D1

DIV4L   .EQU    4
DIV4U   .EQU    2
PARMS   .EQU    14

        MOVE.L  (SP)+,A0                        ;RETURN ADDRESS
        MOVE.L  (SP)+,A1                        ;@R2 INTO A1

        CLR.L   D1                              ;DIVIDE MSW BY DIV2
        MOVE.W  DIV4U(SP),D1
        DIVU    (SP),D1
        MOVE.L  D1,D0                           ;REM IS MSW OF NEXT DIV
        MOVE.W  DIV4L(SP),D0
        DIVU    (SP)+,D0                        ;2ND REM IS R2
        SWAP    D1                              ;1ST QUO IS MSW OF Q4
        MOVE.W  D0,D1                           ;2ND QUO IS LSW OF Q4

        SWAP    D0                              ;STORE REMAINDER
        MOVE.W  D0,(A1)

        ADDQ.L  #4,SP                           ;POP DIV4
        MOVE.L  D1,(SP)                         ;STORE QUOTIENT

        JMP     (A0)                            ;RTS

                .PROC  CLEARSET,6

;----------------------------------------------------------------------------
;               PROCEDURE CLEARSET(PBITS : PTRDATA;
;                                  NELEMENT : INTEGER)
;
;       USES
;               A0,A1
;               D0

                MOVE.L  (SP)+,A1                ;RETURN ADDRESS IN A1
                MOVE.W  (SP)+,D0                ;# ELEMENTS IN SET (N)
                SUBQ.W  #1,D0                   ;D0 <- # WORDS IN SET
                LSR.W   #4,D0
                MOVE.L  (SP)+,A0                ;A0 <- PBITS
@1              CLR.W   (A0)+
                DBF     D0,@1
                JMP     (A1)                   ;RTS


                .PROC  SETSET,8

;----------------------------------------------------------------------------
;               PROCEDURE SETSET(PBITS : PTRDATA;
;                                LASTELEMENT,
;                                NELEMENT : INTEGER)
;
;       USES
;               A0,A1
;               D0,D1,D2,D3
;
;       SAVES
;               D2,D3
;

                MOVE.L  (SP)+,A1                ;RETURN ADDRESS
                MOVE.W  (SP)+,D1                ;# ELEMENTS IN SET (N)
                SUBQ.W  #1,D1                   ;D1 <- N - 1
                MOVE.W  (SP)+,D0                ;# BITS TO SET (M)
                SUBQ.W  #1,D0                   ;D0 <- M - 1
                MOVE.L  (SP)+,A0                ;A0 <- PBITS

                MOVEM.L  D2-D3,-(SP)
                MOVE.W  D0,D2                   ;D2<- (M-1) DIV 16
                LSR.W   #4,D2
                ANDI.W  #$000F,D0               ;D0<- (M-1) MOD 16
                LSR.W   #4,D1                   ;D1<- (N-1) DIV 16 -
                SUB.W   D2,D1                   ;     (M-1) DIV 16
                TST.W   D2
                BEQ.S   @2
                MOVE.W  #$FFFF,D3
@1              MOVE.W  D3,(A0)+
                SUBQ.W  #1,D2
                BNE.S   @1
@2              MOVEQ   #15,D3                  ;D3 <- 15 - (M-1) MOD 16
                SUB.W   D0,D3
                MOVE.W  #$FFFF,D0               ;SET BITS IN WORD WITH LASTBIT
                LSR.W   D3,D0                   ;(BIT 0 IS RIGHTMOST BIT)
                MOVE.W  D0,(A0)+
                TST     D1                      ;CLEAR REMAINING WORDS OF BITS
                BEQ.S   @4
@3              CLR.W   (A0)+
                SUBQ.W  #1,D1
                BNE.S   @3
@4              MOVEM.L (SP)+,D2-D3
                JMP     (A1)                   ;RTS


                .PROC    CLEARBIT,6

 ;----------------------------------------------------------------------------
 ;              PROCEDURE CLEARBIT(PBITS : PTRDATA;BIT : INTEGER)
 ;
 ;      USES
 ;              A0,A1
 ;              D0,D1,D2
 ;      SAVES
 ;              D2
 ;
                MOVE.L  (SP)+,A1                ;RETURN ADDRESS
                CLR.L   D0
                MOVE.W  (SP)+,D0                ;D0 <- BIT
                MOVE.L  (SP)+,A0                ;A0 <- PBITS
                MOVE.L  D2,-(SP)
                MOVE.L  D0,D1                   ;D1 <- BIT MOD 16
                ANDI.W  #$000F,D1
                LSR.W   #4,D0                   ;D0 <- BYTE OFFSET FOR WORD
                ADD.W   D0,D0                   ;THAT HAS BIT
                ADDA.L  D0,A0                   ;A0 IS THAT WORD'S ADDRESS
                MOVE.W  (A0),D2
                BCLR    D1,D2
                MOVE.W  D2,(A0)
                MOVE.L  (SP)+,D2
                JMP     (A1)                    ;RETURN

                .PROC    SETBIT,6

 ;----------------------------------------------------------------------------
 ;              PROCEDURE SETBIT(PBITS : PTRDATA;BIT : INTEGER)
 ;
 ;      USES
 ;              A0,A1
 ;              D0,D1,D2
 ;
 ;      SAVES
 ;              D2
 ;

                MOVE.L  (SP)+,A1                ;RETURN ADDRESS
                CLR.L   D0
                MOVE.W  (SP)+,D0                ;D0 <- BIT
                MOVE.L  (SP)+,A0                ;A0 <- PBITS
                MOVE.L  D2,-(SP)
                MOVE.L  D0,D1                   ;D1 <- BIT MOD 16
                ANDI.W  #$000F,D1
                LSR.W   #4,D0                   ;D0 <- BYTE OFFSET FOR WORD
                ADD.W   D0,D0                   ;THAT HAS BIT
                ADDA.L  D0,A0                   ;A0 IS THAT WORD'S ADDRESS
                MOVE.W  (A0),D2
                BSET    D1,D2
                MOVE.W  D2,(A0)
                MOVE.L  (SP)+,D2
                JMP     (A1)                    ;RETURN

                .FUNC    INPSET,6

 ;----------------------------------------------------------------------------
 ;              FUNCTION INPSET(PBITS : PTRDATA;BIT : INTEGER)
 ;
 ;      USES
 ;              A0,A1
 ;              D0,D1,D2
 ;
 ;      SAVES
 ;              D2
 ;

                MOVE.L  (SP)+,A1                ;RETURN ADDRESS
                CLR.L   D0
                MOVE.W  (SP)+,D0                ;D0 <- BIT
                MOVE.L  (SP)+,A0                ;A0 <- PBITS
                MOVE.L  D2,-(SP)
                MOVE.L  D0,D1                   ;D1 <- BIT MOD 16
                ANDI.W  #$000F,D1
                LSR.W   #4,D0                   ;D0 <- BYTE OFFSET FOR WORD
                ADD.W   D0,D0                   ;THAT HAS BIT
                ADDA.L  D0,A0                   ;A0 IS THAT WORD'S ADDRESS
                MOVE.W  (A0),D2
                MOVEQ   #1,D0                   ;ASSUME BIT IS THERE
                BTST    D1,D2                   ;PUSH 1 IF BIT SET 0 ELSE
                BNE.S   @1
                CLR.W   D0
@1              MOVE.L  (SP)+,D2
                MOVE.B  D0,(SP)
                JMP     (A1)                    ;RETURN


                .FUNC   PINTERSECT,10

;-----------------------------------------------------------------------------
;               FUNCTION PINTERSECT(PSET1,PSET2 : PTRDATA;
;                                   NBITS : INTEGER) : BOOLEAN;
;
;       USES
;               A0,A1
;               D0,D1,D2
;
;       SAVES
;               D2
;
                MOVE.L  (SP)+,D1                ;RETURN ADDRESS
                MOVE.W  (SP)+,D0                ;D0 <- NUMBER OF WORDS IN SET
                SUBQ.W  #1,D0
                LSR.W   #4,D0
                MOVE.L  (SP)+,A0                ;A0 <- PSET2
                MOVE.L  (SP)+,A1                ;A2 <- PSET1
                MOVE.L  D1,-(SP)                ;PUSH RETURN ADDRESS AND
                MOVE.L  D2,-(SP)                ;SAVE D2

;
               ;ITERATE UNTIL WE FIND TWO WORDS THAT INTERSECT OR WE
               ;EXHAUST BOTH SETS (INTERSECTION IS NULL)
;
                CLR     D1                      ;ASSUME INTERSECTION NULL
@1              MOVE.W  (A0)+,D2
                AND.W   (A1)+,D2
                BEQ.S   @2
                MOVEQ   #1,D1                   ;INTERSECTION NOT NULL
                BRA.S   RETURN
@2              DBF     D0,@1

RETURN          MOVE.L  (SP)+,D2                ;RESTORE D2
                MOVE.L  (SP)+,A0
                MOVE.B  D1,(SP)                 ;FALL THROUGH IF NULL INTER.
                JMP     (A0)

                .PROC   BSEARCHV,32
                .REF    COMPARE

;----------------------------------------------------------------------------
;
;                               bsearchv
;
;     performs binary search to find lowest entry that
;     is greater than or equal to the search entry (if beyond end of array
;     then returns nentries+1).  returns true if key was found.
;
;     procedure bsearchv(var sresult : boolean;
;                            pentries : ptrdata;
;                            po : ptroffsets;
;                            skey : ptrdata;
;                            nentries,
;                            nfields : integer;
;                            var index : integer;
;                            edescript,
;                            kdescript : ptrrecptr);
;
;       USES
;               A0,A3,A4,A6
;               D0,D2,D3,D4
;
;       SAVES
;               D2-D4
;               A3-A6
;
NREGISTERS      .EQU    40
KDESCRIPT       .EQU    NREGISTERS+4
EDESCRIPT       .EQU    NREGISTERS+8
INDEX           .EQU    NREGISTERS+12
NFIELDS         .EQU    NREGISTERS+16
NENTRIES        .EQU    NREGISTERS+18
SKEY            .EQU    NREGISTERS+20
PO              .EQU    NREGISTERS+24
PENTRIES        .EQU    NREGISTERS+28
SRESULT         .EQU    NREGISTERS+32

NPARMS          .EQU    32


                MOVEM.L D2-D7/A3-A6,-(SP)
                MOVE.L  SP,A6                   ;SETUP PARAMETER POINTER IN A6
                MOVE.L  KDESCRIPT(A6),D5        ;D5 := KDESCRIPT
                MOVE.L  EDESCRIPT(A6),D6        ;D6 := EDESCRIPT
                MOVE.W  NFIELDS(A6),D7          ;D7 := NFIELDS
                MOVE.L  SKEY(A6),A3             ;A3 := SKEY
                MOVE.L  PO(A6),A4               ;A4 := PO

                CLR.W   D2                      ;LOWER := 0
                MOVE.W  NENTRIES(A6),D3         ;UPPER := NENTRIES - 1
                SUBQ.W  #1,D3
                CMP.W   D3,D2                   ;WHILE LOWER <= UPPER
                BGT.S   EXIT
LOOPTOP         MOVE.W  D2,D4                   ;INDEX := (UPPER+LOWER) DIV 2
                ADD.W   D3,D4
                LSR.W   #1,D4
                CLR.W   -(SP)                   ;SPACE FOR RETURN VALUE
                MOVE.L  D5,-(SP)                ;TEMP :=
                                                ;    COMPARE(KDESCRIPT,
                MOVE.L  D6,-(SP)                ;            EDESCRIPT,
                MOVE.W  D7,-(SP)                ;            NFIELDS,
                MOVE.L  A3,-(SP)                ;            SKEY,
                MOVE.W  D4,D0                   ;            @PENTRIES^[PO^[
                ADD.W   D0,D0                   ;                   -INDEX]]
                NEG.W   D0                      ;
                MOVE.W  0(A4,D0),D0
                MOVE.L  PENTRIES(A6),A0         ;A0 := PENTRIES
                PEA     0(A0,D0)
                JSR     COMPARE

                MOVE.W  (SP)+,D0
                CMPI.W  #GTVAL,D0               ;IF TEMP = LT THEN
                BEQ.S   ISGT
                BGT.S   ISEQ
                MOVE.W  D4,D3                   ;    UPPER := INDEX-1
                SUBQ.W  #1,D3
                CMP.W   D3,D2                   ;    (TEST FOR
                BLE.S   LOOPTOP                 ;      WHILE LOWER <= UPPER)
                BRA.S   EXIT                    ;

ISEQ                                            ;ELSE IF TEMP=EQ THEN BEGIN
                MOVEQ   #1,D0                   ;    SRESULT := TRUE;
                BRA.S   RETURN                  ;    GOTO 2
                                                ;END
ISGT            MOVE.W  D4,D2                   ;ELSE LOWER := INDEX+1
                ADDQ.W  #1,D2
                CMP.W   D3,D2                   ;END WHILE LOWER <= UPPER
                BLE.S   LOOPTOP

EXIT            MOVE.W  D2,D4                   ;INDEX := LOWER
                CLR.W   D0                      ;SRESULT := FALSE

RETURN          MOVE.L  INDEX(A6),A0            ;2 : STORE INDEX & SRESULT
                MOVE.W  D4,(A0)
                MOVE.L  SRESULT(A6),A0
                MOVE.B  D0,(A0)

                MOVEM.L (SP)+,D2-D7/A3-A6
                MOVE.L  (SP)+,A0
                MOVEQ   #NPARMS,D0
                ADDA.L  D0,SP
                JMP     (A0)

        .PROC MOVR_INC,12
        .DEF  MOVL_INC

;--------------------------------------------------------------------------
;
;       PROCEDURE MOVL_INC(P0,P1 : PTROFFSETS;CNT,INCREMENT :INTEGER)
;
;       ADDS THE CONSTANT VECTOR [INCREMENT...INCREMENT] AND P0, PUTTING
;       THE RESULT IN P1.  MOVE IS DONE FROM THE LEFT.  P0,P1 MUST POINT
;       TO LOW ADDRESS OF VECTOR.  VECTORS ARE 16 BIT INTEGER VECTORS.
;
;
;       USES
;               A0,A1
;               D0,D1,D2
;       SAVES
;               D2
;--------------------------------------------------------------------------
;
;       PROCEDURE MOVL_INC(P0,P1 : PTROFFSETS;CNT,INCREMENT :INTEGER)
;
;       ADDS THE CONSTANT VECTOR [INCREMENT...INCREMENT] AND P0, PUTTING
;       THE RESULT IN P1.  MOVE IS DONE FROM THE RIGHT. P0,P1 MUST POINT
;       TO HIGH ADDRESS OF VECTOR.  VECTORS ARE 16 BIT INTEGER VECTORS.
;
;
;       USES
;               A0,A1
;               D0,D1,D2
;       SAVES
;               D2

P0      .EQU    20
P1      .EQU    16
CNT     .EQU    14
INCR    .EQU    12
NPARMS  .EQU    12

                MOVE.L  D2,-(SP)
                BSR     GETPARM

                CMPM.W  (A0)+,(A1)+     ;PREINCREMENT A0 & A1 FOR LOOP
@1              MOVE.W  -(A0),D2        ;P1-- := P0-- + INCREMENT
                ADD.W   D1,D2
                MOVE.W  D2,-(A1)
                DBF     D0,@1

RETURN          MOVE.L  (SP)+,D2
                MOVE.L  (SP)+,A0
                MOVEQ   #NPARMS,D0
                ADDA.L  D0,SP
                JMP     (A0)

GETPARM         MOVE.W  INCR(SP),D1             ;D1 := INCREMENT
                MOVE.W  CNT(SP),D0              ;D0 := # OF WORDS - 1
                MOVE.L  P1(SP),A1               ;A1 := P1
                MOVE.L  P0(SP),A0               ;A0 := P0
                RTS

MOVL_INC        MOVE.L  D2,-(SP)
                BSR     GETPARM                 ;GET PARAMETERS

@1              MOVE.W  (A0)+,D2                ;P1++ := P0++ + INCREMENT
                ADD.W   D1,D2
                MOVE.W  D2,(A1)+
                DBF     D0,@1                   ;UNTIL --CNT < 0

                BRA.S   RETURN                  ;AWAY WE GO

        .PROC MOVELG,10

;--------------------------------------------------------------------------
;
;       PROCEDURE MOVELG(P1,P2 : PTRDATA;NBYTES : INTEGER);
;
;       DOES A GENERAL MOVELEFT. DOESN'T ASSUME P1,P2 POINT TO WORD BOUNDARIES.
;       NBYTES CAN BE ODD OR EVEN.
;
;
;       USES
;               A0,A1
;               D0,D1

        MOVE.L  (SP)+,D1                ;POP RETURN ADDRESS
        MOVE.W  (SP)+,D0                ;D0 := NBYTES
        MOVE.L  (SP)+,A1                ;A1 := P2
        MOVE.L  (SP)+,A0                ;A0 := P1
        MOVE.L  D1,-(SP)                ;PUSH RETURN ADDRESS FOR RTS
        SUBQ.W  #1,D0                   ;SETUP DBA COUNT
        BLT.S   NOBYTE                  ;NO TRANSFER IF NBYTES <= 0

@1      MOVE.B  (A0)+,(A1)+
        DBF     D0,@1

NOBYTE  RTS


        .PROC MOVERG,10

;--------------------------------------------------------------------------
;
;       PROCEDURE MOVERG(P1,P2 : PTRDATA;NBYTES : INTEGER);
;
;       DOES A GENERAL MOVERIGHT. DOESN'T ASSUME P1,P2 POINT TO WORD BOUNDARIES.
;       NBYTES CAN BE ODD OR EVEN.
;
;
;       USES
;               A0,A1
;               D0,D1

        MOVE.L  (SP)+,D1                ;POP RETURN ADDRESS
        MOVE.W  (SP)+,D0                ;D0 := NBYTES
        MOVE.L  (SP)+,A1                ;A1 := P2
        MOVE.L  (SP)+,A0                ;A0 := P1
        MOVE.L  D1,-(SP)                ;PUSH RETURN ADDRESS FOR RTS
        ADDA.W  D0,A0
        ADDA.W  D0,A1
        SUBQ.W  #1,D0                   ;SETUP DBA COUNT
        BLT.S   NOBYTE                  ;NO TRANSFER IF NBYTES <= 0

@1      MOVE.B  -(A0),-(A1)
        DBF     D0,@1

NOBYTE  RTS

        .PROC MOVELF,10

;--------------------------------------------------------------------------
;
;       PROCEDURE MOVELF(P1,P2 : PTRDATA;NBYTES : INTEGER);
;
;       DOES A FAST MOVELEFT.  ASSUMES P1,P2 POINT TO WORD BOUNDARIES.
;       NBYTES CAN BE ODD OR EVEN.
;
;
;       USES
;               A0,A1
;               D0,D1

        MOVE.L  (SP)+,D1                ;POP RETURN ADDRESS
        MOVE.W  (SP)+,D0                ;D0 := NBYTES
        MOVE.L  (SP)+,A1                ;A1 := P2
        MOVE.L  (SP)+,A0                ;A0 := P1
        MOVE.L  D1,-(SP)                ;PUSH RETURN ADDRESS FOR RTS
        MOVE.W  D0,D1                   ;D1 := NBYTES
        BLE.S   NOBYTE                  ;NO TRANSFER IF NBYTES <= 0

        LSR.W   #2,D0                   ;CONVERT D0 INTO LONG COUNT
        BEQ.S   CLEANUP                 ;CHECK FOR LENGTH < 4 BYTES
        SUBQ.W  #1,D0
XFER    MOVE.L  (A0)+,(A1)+
        DBF     D0,XFER

CLEANUP BTST    #1,D1                   ;CHECK FOR TRAILING WORD
        BEQ.S   NOWORD
        MOVE.W  (A0)+,(A1)+
NOWORD  BTST    #0,D1                   ;CHECK FOR A TRAILING BYTE
        BEQ.S   NOBYTE
        MOVE.B  (A0)+,(A1)+
NOBYTE  RTS


        .PROC MOVERF,10

;--------------------------------------------------------------------------
;
;       PROCEDURE MOVERF(P1,P2 : PTRDATA;NBYTES : INTEGER);
;
;       DOES A FAST MOVERIGHT.  ASSUMES P1,P2 POINT TO WORD BOUNDARIES.
;       NBYTES CAN BE ODD OR EVEN.
;
;
;       USES
;               A0,A1
;               D0,D1

        MOVE.L  (SP)+,D1                ;POP RETURN ADDRESS
        MOVE.W  (SP)+,D0                ;D0 := NBYTES
        MOVE.L  (SP)+,A1                ;A1 := P2
        MOVE.L  (SP)+,A0                ;A0 := P1
        MOVE.L  D1,-(SP)                ;PUSH RETURN ADDRESS FOR RTS
        TST.W   D0                      ;NO TRANSFER IF NBYTES <= 0
        BLE.S   RETURN

        ADDA.W  D0,A0
        ADDA.W  D0,A1
        LSR.W   #1,D0                   ;CONVERT D0 INTO LONG COUNT AND
        BCC.S   @1                      ;CHECK FOR A TRAILING BYTE
        MOVE.B  -(A0),-(A1)
@1      LSR.W   #1,D0                   ;AND A TRAILING WORD?
        BCC.S   @2
        MOVE.W  -(A0),-(A1)

@2      SUBQ.W  #1,D0                   ;TEST FOR LENGTH < 4
        BLT.S   RETURN
XFER    MOVE.L  -(A0),-(A1)
        DBF     D0,XFER

RETURN  RTS


        .END


ÿ