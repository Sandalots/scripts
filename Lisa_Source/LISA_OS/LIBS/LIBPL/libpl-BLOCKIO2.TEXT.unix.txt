

(* file blockio2.text *)

    (***********************************************************************)
    (*                                                                     *)
    (*  BLK IO routines that are supported in stand alone OS for accessing *)
    (*  UCSD files. These are taken from NSYSTEM.C.TEXT from SYSTEM.PASCAL *)
    (*                                                                     *)
    (*  In this file,  blockio2,  the following routines are defined:      *)
    (*    %_FBlockIO, %_FGet, %_FPut, %_WriteLn, %_WriteChar, %_ReadLn     *)
    (*    %_ReadChar.                                                      *)
    (*                                                                     *)
    (***********************************************************************)

Function eoferror : boolean;
  begin
    if (iorslt = 848) or (iorslt = 881) or (iorslt = 883) or (iorslt = 956)
    then eoferror := true
    else eoferror := false;
  end;  (* eoferror *)


(*$IFC MONITOR*)
(* CantStretch ---------------------------------------------------------- *)
FUNCTION CantStretch(VAR f: FIB): BOOLEAN; (*REPLACED BY RJH 2Mar78*)

  (* function to see if requested BLKIO can stretch to the available free *)
  (* space and adjust DLASTBLK in FIB to last available free block number *)

  LABEL 1;

  VAR linx: DIRRANG1;
    found, ok: BOOLEAN;
    lavailblk: INTEGER;
    ldir: DIRP;
    lunit : unitnum;

  BEGIN  (* CantStretch *)
  (*$IFC DEBUG*)
    IF trace (50) THEN
      WRITELN ('e CantStretch: f =', ord (@f));
  (*$ENDC*)
  CantStretch := TRUE;
  ok := FALSE;
  WITH f, FVIDstuff, FHEADER DO
   if FIsOs then (*------------------------- OS File ------------------------*)
    begin
      CantStretch := false;  (* Only OS knows this, so assumes there is room*)
      ok := true;
    end
   else         (*-------------------------- UCSD File ----------------------*)
    IF LENGTH(DTID) > 0 THEN
      BEGIN  (*IN A DIRECTORY FOR SURE*)
      ldir := @gdirectory;
      lunit := VOLSEARCH(FVID,FALSE,ldir);
      IF funit <> lunit THEN
        BEGIN
        IORSLT := ORD(ILOSTUNIT);
        GOTO 1
        END;
      found := FALSE;
      linx := 1;
      WHILE (linx <= ldir^[0].DNUMFILES) AND NOT found DO
        BEGIN
        found := (ldir^[linx].DFIRSTBLK = DFIRSTBLK) AND
                 (ldir^[linx].DLASTBLK = DLASTBLK);
        linx := linx+1
        END;
      IF NOT found THEN
        BEGIN
        IORSLT := ORD(ILOSTFILE);
        GOTO 1
        END;
      IF linx > ldir^[0].DNUMFILES THEN
        lavailblk := ldir^[0].DEOVBLK
      ELSE
        lavailblk := ldir^[linx].DFIRSTBLK;
      IF (DLASTBLK < lavailblk) OR (DLASTBYTE < FBLKSIZE) THEN
                                      (* still has room after DLASTBLK *)
        BEGIN  (* still room *)
        WITH ldir^[linx-1] DO
          BEGIN  (* WITH ldir^[linx-1] *)
          DLASTBLK := lavailblk;
          DLASTBYTE := FBLKSIZE;
          WriteDir(funit,ldir);
          IF IORESULT <> ORD(INOERROR) THEN
            GOTO 1
          END;   (* WITH ldir^[linx-1] *)
        FEOF := FALSE;
        FEOLN := FALSE;
        IF FSTATE <> FJANDW THEN
          FSTATE := FNEEDCHAR; (*RJH 2Mar78*)
        DLASTBLK := lavailblk;
        DLASTBYTE := FBLKSIZE;
        DACCESS.YEAR := 100;
        CantStretch := FALSE  (* make it temp entry *)
        END;   (* still room *)

      ok := TRUE;
1:    unitable [lunit].lockdir := false;
                          (* unlock the dir locked in volsearch *)
      END;   (*IN A DIRECTORY FOR SURE*)
    IF NOT ok THEN
      BEGIN
      f.FEOF := TRUE;
      f.FEOLN := TRUE
      END;
  (*$IFC DEBUG*)
    IF trace (50) THEN
      WRITELN ('l CantStretch: ok = ', ok);
  (*$ENDC*)
  END;   (* CantStretch *)
(*$ENDC*)



(* %_FBlockIO ---------------------------------------------------------------- *)
FUNCTION %_FBlockIO(* VAR f: FIB; a: LONGINT;
                      nblocks, rblock: INTEGER; doread: BOOLEAN) : integer *);
    (* read, write multiple blocks, starting from rblock, called by blockread,
       blockwrite routines in paslib *)
  VAR liorslt : INTEGER;
      mode : iomode;
      offset, actual : longint;
      file_info : fs_info;


  BEGIN  (* %_FBlockIO *)
  (*$IFC DEBUG*)
  IF trace (50) THEN
    BEGIN
    WRITELN ('e %_FBLOCKIO: f =', ord (@f), ' a =', a, ' nblocks =', nblocks);
    WRITELN ('            rblock =', rblock, ' doread = ', doread);
    END;
  (*$ENDC*)
  %_FBLOCKIO := 0;
  IORSLT := ORD(INOERROR);
  WITH f DO

(*$IFC MONITOR*)
   if NOT FIsOs then   (*-------------UCSD file-----------------------------*)
    IF FISOPEN AND (nblocks >= 0) THEN
      IF FISBLKD THEN
        WITH FHEADER DO
          BEGIN  (* WITH Fheader *)
          IF rblock < 0 THEN
            rblock := FNXTBLK; (* rblock = -1 = sequential *)
          rblock := DFIRSTBLK+rblock;
          IF rblock+nblocks > DLASTBLK THEN
            IF NOT doread THEN
              IF CantStretch( f ) THEN;      (* adjust DLASTBLK to the last
                                                 available free block # *)
          IF rblock+nblocks > DLASTBLK THEN
            nblocks := DLASTBLK-rblock;
          FEOF := rblock >= DLASTBLK;
          IF NOT FEOF THEN
            BEGIN  (* No EOF *)
            IF doread THEN
              unitio (iorslt, funit, a, nblocks, rblock, actual, without_header,
                        readop)
            ELSE
              unitio (iorslt, funit, a, nblocks, rblock, actual, without_header,
                        writeop);
            IF iorslt = ORD(INOERROR) THEN
              BEGIN  (* INoError *)
              IF NOT doread THEN
                FMODIFIED := TRUE;
              %_FBLOCKIO := nblocks;
              rblock := rblock+nblocks;
              FEOF := rblock = DLASTBLK;
              FNXTBLK := rblock-DFIRSTBLK;
              IF FNXTBLK > FMAXBLK THEN
                FMAXBLK := FNXTBLK
              END;   (* INoError *)
            END    (* No EOF *)
          END    (* WITH Fheader *)
      ELSE                              (* non-blocked device *)
        iorslt := inotimpl
    ELSE
      IORSLT := ORD(INOTOPEN)
   else (*-----------------------OS file--------------------------------------*)
(*$ENDC*)
     begin
       IF FIsOpen AND (NBLOCKS >= 0) AND (HiByt3 = openpattern) THEN
         IF (Funit <> unitScConsole) and (Funit <> unitScKeyboard)
           and (Funit <> unitWiPrinter) THEN {not console, keyboard, window -printer}
         with FVIDstuff do
           BEGIN
             if funit = unitScPrinter then rblock := -1;
                          {printer or serial device must be sequential}
             IF RBLOCK < 0 THEN                 (* RBLOCK = -1 = sequential *)
               begin
                 mode := sequential;
                 offset := 0;
               end
             else                (* absolute *)
               begin
                 mode := absolute;
                 offset := ord4 (rblock) * Fblksize;     (* byte offset *)
               end;

             if doread then
               read_data (iorslt, FTrefnum, A, ord4 (nblocks) * Fblksize, actual,
                          mode, offset)
             else
               write_data (iorslt, FTrefnum, A, ord4 (nblocks) * Fblksize, actual,
                           mode, offset);

             offset := actual div Fblksize;
             nblocks := offset;                 (* for tracing message only *)
             %_FBLOCKIO := offset;
             if (actual mod Fblksize) > 0 then %_FBLOCKIO := offset + 1;
             IF iorslt = ORD(INOERROR) THEN
               BEGIN
                 if doread then
                   begin
                     info (iorslt, FTrefnum, file_info);
                     feof := file_info.eof;
                   end
                 else
                   FMODIFIED := TRUE;
               END
             else
               if doread and eoferror
               then begin
                      feof := true;
                      iorslt := 0;              (* hit end of file - OK *)
                    end
               else MapToUCSD (iorslt);
           END
         ELSE        (* console or keyboard device *)
           iorslt := inotimpl
       ELSE
         IORSLT := INOTOPEN;
     end; (*---------------------OS file--------------------------------------*)
  (*$IFC DEBUG*)
  IF trace (50) THEN
    BEGIN
    liorslt := iorslt;      (* since the trace message will reset iorslt *)
    WRITELN ('l %_FBLOCKIO: IORSLT =', IORSLT, ' rblock =', rblock,
                                                        ' %_FBLOCKIO =', nblocks);
    iorslt := liorslt;
    END;
  (*$ENDC*)

  END;   (* --------------------- %_FBlockIO ----------------------------------- *)




{------------------------------- ExecRead (01-Feb-82) ------------------------}
FUNCTION ExecRead (VAR errnum : INTEGER; doRead : boolean) : CHAR;

  {get a char from read ahead buffer and read the next char from exec file.}
  {Close exec file and reset exec flag if error or hit eof or not doRead.}

  LABEL 1;
  VAR execfib, execfib2 : fib;
      filename : pathname;
      charin, prechar, greadagain : char;
      flag : boolean;

  BEGIN  {ExecRead}
  errnum := 0;
  if doRead then
    begin
      ExecRead := greadahead;       {get the read ahead}
      charin := greadahead;
      execfib := inputfile;         {to break recursive call to %_fget}

      REPEAT                                               {3.7, Y.C., 7/19/83}
        flag := false;
        prechar := greadahead;
        greadahead := %_readchar (execfib);         {read ahead one char}
        errnum := iorslt;
        IF (errnum > 0) or (execfib.feof) or
           ((prechar = gfirstchar) and (greadahead = gfirstchar)) THEN goto 1;
                                        {stop exec file at two consecutive first chars}
        IF (greadahead = gfirstchar) THEN  {Code allows embedded % to pass through}
                             Begin
                             execfib2 := execfib;
                             greadagain := %_readchar (execfib2);
                             IF (greadagain <> gfirstchar) THEN flag := TRUE
                             END;
      UNTIL (greadahead <> gfirstchar) or Flag;  {but skip the first char}
      inputfile := execfib;
      if execfib.feoln then greadahead := chr (eol);  { back to cr}
      if charin = chr (eol) then
        begin
          charin := ' ';
          inputfile.feoln := true;          { set eoln back after read ahead }
        end
      else inputfile.feoln := false;
      exit (execread);
    end;
1:
  resetinput;               {reset input to console}
  gexecflag := false;
  IF errnum = 0 THEN errnum := e_execeof;
  END;  { ExecRead }




(* --------------------------------- %_FGet ---------------------------------- *)
PROCEDURE %_FGET (* VAR f: FIB *);

  LABEL 1, 2, 3;
  VAR leftoget, wininx, leftinbuf, amount: INTEGER;
    done, callScan_Ahead : BOOLEAN;
    packchar : packed array [0..1] of char;
    charin : CHAR;
    errnum, liorslt : INTEGER;
    actual : longint;
    fbufp, fwindp : ^chararray;
    poutfp : fibp;

  PROCEDURE SCAN_AHEAD ( VAR f : FIB );
    VAR  current_fib : FIB;       (* Returns Current FIB if this is really EOF *)
    BEGIN  (* SCAN_AHEAD *)
    IF callScan_Ahead THEN              {called twice, must be bad text file}
        iorslt := e_badtextfile
    ELSE
     WITH f DO
      BEGIN
        callScan_Ahead := TRUE;
        current_fib := f;
        IF ODD(FNXTBLK) THEN              {skip to next even block}
          FNXTBLK := FNXTBLK + 1;
        FNXTBYTE := FBLKSIZE;
        %_FGET(f);
        IF FEOF THEN
          BEGIN  (* FEOF *)
          f := current_fib;
          FEOF := TRUE;
          FEOLN := TRUE;
          FNXTBYTE := FNXTBYTE - 1;
          END;   (* FEOF *)
      END;   (* WITH f *)
    END;   (* SCAN_AHEAD *)

  BEGIN  (* %_FGET *)
  (*$IFC DEBUG*)
  IF trace (30) THEN
      WRITELN ('e %_FGET: f =', ord (@f));
  (*$ENDC*)
  IORSLT := ORD(INOERROR);
  callScan_Ahead := FALSE;
  WITH f DO                     (* Same code for UCSD and OS file, except i/o *)
    IF FISOPEN AND (HiByt3 = openpattern) THEN
      BEGIN  (* IF FisOpen *)
        if (@f = @outputfile) or (@f = @POutputfile) then
          begin
            iorslt := ibadunit;
            goto 2;
          end;
        IF FREPTCNT > 0 THEN
          BEGIN  (* FReptCnt > 0 *)
          FREPTCNT := FREPTCNT-1;
          IF FREPTCNT > 0 THEN
            GOTO 2
          END;   (* FReptCnt > 0 *)
        IF FSOFTBUF and ((@f <> @inputfile) or (not gexecflag)) THEN
                           (* if execfile completely opened, use execread below *)
          WITH FVIDstuff, FHEADER DO
            BEGIN  (* WITH Fheader *)
            leftoget := FRECSIZE;
            wininx := 0;
            REPEAT
              IF FNXTBLK >= FMAXBLK THEN
                IF FNXTBYTE+leftoget > FMAXBYTE THEN
                  GOTO 1
                ELSE
                  leftinbuf := DLASTBYTE-FNXTBYTE
              ELSE
                leftinbuf := FBLKSIZE-FNXTBYTE;
              amount := leftoget;
              IF amount > leftinbuf THEN
                amount := leftinbuf;
              IF amount > 0 THEN
                BEGIN
                fbufp := pointer (ord (@FBUFFER) + FNXTBYTE);   {3.2, YC, 2/28/83}
                fwindp := pointer (ord (FWINDOW) + wininx);     {3.2, YC, 2/28/83}
                moveleft (fbufp^, fwindp^, amount);             {3.2, YC, 2/28/83}
                FNXTBYTE := FNXTBYTE+amount;
                wininx := wininx+amount;
                leftoget := leftoget-amount
                END;
              done := leftoget = 0;
              IF NOT done THEN
                BEGIN  (* NOT done *)
                IF FBUFCHNGD THEN
                  BEGIN  (* FBUFCHNGD *)
                  FBUFCHNGD := FALSE;
                  FMODIFIED := TRUE;
                  if FisOS then (*---------------- OS File --------------------*)
                    begin
                      write_data (iorslt, FTrefnum, ord (@Fbuffer), Fblksize,
                                  actual, absolute, ord4 (Fnxtblk-1)*Fblksize);
                                                         (* write the buffer out *)
                      if iorslt > 0 then MapToUCSD (iorslt);
                    end
                  {$IFC MONITOR}
                  else {------------------------- UCSD File ------------------}
                    unitio (iorslt, funit, ord (@FBUFFER), 1,
                            DFIRSTBLK+FNXTBLK-1,
                            actual, without_header, writeop);
                  {$ENDC}
                  END;    {FBUFCHNGD}
                IF iorslt > ORD(INOERROR) THEN GOTO 1;
                if FIsOs then  {------------------ OS File --------------------}
                  begin
                    read_data (iorslt, FTrefnum, ord (@Fbuffer), Fblksize,
                               actual, absolute, ord4 (Fnxtblk)*Fblksize);
                    if iorslt > 0 then
                      if eoferror
                      then begin
                             iorslt := 0;        {hit end of file - OK}
                           end
                      else MapToUCSD (iorslt);
                  end
                else  {------------------------- UCSD File -------------------}
                  begin
                    {$IFC MONITOR}
                    unitio (iorslt, funit,ord (@FBUFFER), 1,DFIRSTBLK+FNXTBLK,
                            actual, without_header, readop);
                    {$ENDC}
                  end;
                IF iorslt > ORD(INOERROR) THEN GOTO 1;
                FNXTBLK := FNXTBLK+1; FNXTBYTE := 0;
                END    (* NOT done *)
            UNTIL done
            END    (* WITH Fheader *)

        ELSE
         with FVIDstuff do
          BEGIN  {not fsoftbuf, not blockdev or untyped file (frecsize = 0)
                  or f = inputfile}
                 {Note: QuickPort program can not read from exec file since 8(A5)
                        points to process private fib, not inputfile, even if it
                        can run in the WorkShop lator.}
          poutfp := @POutputfile;
          if gexecflag AND (funit <= unitWiKeyboard) then       {window env. too}
            begin     {exec file open AND to read from INPUT, console or keyboard}
              charin := execread (iorslt, true);
              if inputfile.feoln then
                begin
                  if PAbortFlag then
                    begin
                      charin := execread (iorslt, false);   {stop exec file}
                      goto 1;
                    end;
                end;
              if iorslt > 0 then goto 1;
              if (Funit = unitScConsole) or (Funit = unitWiConsole) then
                begin           {no echo of exec file input if '-KEYBOARD'}
                  IF inputfile.feoln THEN   {if eoln, CR was converted to space}
                    packchar [0] := chr (eol)  { back to cr for echo }
                  else
                    packchar [0] := charin;
                  %_writechar (poutfp^, @packchar, 1);
                                    {echo to console and output file if open}
                  if iorslt > 0 then goto 1;
                end;
            end
          else                  {no exec file open}
            IF (Funit = unitScConsole) OR (Funit = unitScKeyboard) OR
               (PInWindow > 0) {when this is true, funit must be unitWiConsole}
            THEN
              BEGIN       {INPUT, console or keyboard or nested call from window}
3:
                read_data (iorslt, consoleRefnum, ord (@packchar), 1,
                           actual, sequential, 0);      {get from OS console}
                if iorslt > 0 then goto 1;
                if CkDskEventF then CkDiskEvents;                               {3.2, YC, 3/4/83}
                if actual = 1 then
                  begin
                    if packchar [0] = chr (AbortKey) then
                      begin
                        PAbortKeyF := true;
                        goto 3;             {do not pass this to program}
                      end;
                  end
                else goto 3;        {OS returns if disk event, get the real input}
                amount := ord (packchar [0]);
                if (amount > $7f) AND
                   ((apconsole = ord (xsorocA)) OR (apconsole = ord (xsorocB)))
                then amount := amount - $80;            {trim the parity bit}
                charin := chr (amount);
                if (funit <> unitScKeyboard) AND             {no echo if KEYBOARD}
                   ((charin = chr (eol)) or (ord (charin) >= ord (' '))) then
                    %_writechar (poutfp^, @packchar, 1)
              END
            ELSE                {funit <> unitScConsole or unitScKeyboard}
              if funit = unitOSFile then        {serial device}                                 {3.7, Y.C., 7/8/83}
                begin
                    read_data (iorslt, FTRefnum, ord (@packchar), 1,
                               actual, sequential, 0);  {get from OS device}
                    if iorslt > 0 then goto 1;
                    charin := packchar [0];
                end
            else
              if (funit = unitWiConsole) or (funit = unitWiKeyboard) then
                begin                                   {read from window}
                  charin := PasTerm.VRead;
                  if charin = chr (AbortKey) then PAbortKeyF := true;

                  if (funit = unitWiConsole) and
                     ((charin = chr (eol)) or (ord (charin) >= ord (' '))) then
                    begin                               { echo the input }
                      packchar [0] := charin;
                      %_writechar (poutfp^, @packchar, 1);
                    end;
                end
              else                  {other devices}
                BEGIN
                  iorslt := inotimpl;
                  goto 1;
                END;  (* other devices *)

          fwindow^[0] := charin;
          END;  {NOT Fsoftbuf or f = inputfile}

        IF (FHeader.Dfkind = TextFile) and
           ((@f <> @inputfile) or (not gexecflag)) THEN
          BEGIN         {interactive or text}
          FEOLN := FALSE;
          {IF FSTATE <> FJANDW THEN }
            FSTATE := FGOTCHAR;
            IF FWINDOW^[0] = CHR(EOL) THEN
              BEGIN
              FWINDOW^[0] := ' ';
              FEOLN := TRUE;
              GOTO 2
              END;
            IF (FWINDOW^[0] = CHR(DLE)) AND (funit > unitWiKeyboard) THEN
              BEGIN  (* DLE *)
              %_FGET(f);
              amount := ORD(FWINDOW^[0])-32;
              IF (amount > 0) AND (amount <= 127) THEN
                BEGIN  (* 0 - 127 *)
                FWINDOW^[0] := ' ';
                FREPTCNT := amount;
                GOTO 2
                END;   (* 0 - 127 *)
              %_FGET(f)
              END;   (* DLE *)
            IF FWINDOW^[0] = CHR(0) THEN
              BEGIN  (*EOF HANDLING*)
              IF FSOFTBUF AND (FHEADER.DFKIND = TEXTFILE) THEN
                BEGIN
                SCAN_AHEAD(f);  (* END of 2 block page *)
                IF iorslt > 0 THEN GOTO 1;
                END
              ELSE
                BEGIN
                FWINDOW^[0] := ' ';
                GOTO 1
                END
              END;    (*EOF HANDLING*)
          END    (* text or interactive *)
      END    (* IF FisOpen *)

    ELSE
      BEGIN  (* File not open *)
      IORSLT := INOTOPEN;
1:    FEOF := TRUE;
      FEOLN := TRUE
      END;   (* File not open *)
2:
  (*$IFC DEBUG*)
  IF trace (30) THEN
    BEGIN
    liorslt := iorslt;      (* since the trace message will reset iorslt *)
    WRITELN ('l %_FGET: iorslt =', iorslt, ' char = ', f.fwindow^[0]);
    iorslt := liorslt;
    END;
  (*$ENDC*)
  END;   (* ------------------------- %_FGET ----------------------------------- *)



(* ---------------------------------- %_FPut (19-Oct-82) ----------------------- *)
PROCEDURE %_FPUT (*VAR f: FIB*);
  LABEL 1, 2;
  VAR
    leftoput, wininx, leftinbuf, amount: INTEGER;
    done: BOOLEAN;
    charout : CHAR;
    actual : longint;
    packchar : packed array [0..1] of char;
    fbufp, fwindp : ^chararray;

  BEGIN  (* %_FPut *)
  (*$IFC DEBUG*)
    IF trace (30) THEN
        WRITELN ('e %_FPUT: f =', ord (@f), ' char = ', f.fwindow^[0]);
  (*$ENDC*)

  IORSLT := ORD(INOERROR);
  WITH f DO
    IF FISOPEN AND (HiByt3 = openpattern) THEN
      BEGIN  (* FISOPEN *)      (* allow output to inputfile to do erase etc.*)
        WITH FVIDstuff, FHEADER DO
          IF FSOFTBUF THEN
            BEGIN  (* WITH FHEADER *)
            leftoput := FRECSIZE;
            wininx := 0;
            REPEAT
              IF DFIRSTBLK+FNXTBLK = DLASTBLK THEN
                IF FNXTBYTE+leftoput > DLASTBYTE THEN
                  (*$IFC MONITOR*)
                  IF CantStretch( f ) THEN      (* OS files always return false*)
                    BEGIN
                    IORSLT := ORD(INOROOM);
                    GOTO 1
                    END
                  ELSE
                  (*$ENDC*)
                    leftinbuf := FBLKSIZE-FNXTBYTE
                ELSE
                  leftinbuf := DLASTBYTE-FNXTBYTE
              ELSE
                leftinbuf := FBLKSIZE-FNXTBYTE;
              amount := leftoput;
              IF amount > leftinbuf THEN
                amount := leftinbuf;
              IF amount > 0 THEN
                BEGIN
                FBUFCHNGD := TRUE;
                fbufp := pointer (ord (@FBUFFER) + FNXTBYTE);   {3.2, YC, 2/28/83}
                fwindp := pointer (ord (FWINDOW) + wininx);     {3.2, YC, 2/28/83}
                moveleft (fwindp^, fbufp^, amount);             {3.2, YC, 2/28/83}
                FNXTBYTE := FNXTBYTE+amount;
                IF (DFKIND <> Textfile) THEN
                 IF (FNXTBLK = FMAXBLK) AND (FNXTBYTE > FMAXBYTE) THEN
                   FMAXBYTE := FNXTBYTE;
                wininx := wininx+amount;
                leftoput := leftoput-amount
                END;
              done := leftoput = 0;
              IF NOT done THEN
                BEGIN  (* NOT done *)
                IF FBUFCHNGD THEN
                  BEGIN  (* fbufchngd *)
                    FBUFCHNGD := FALSE;
                    FMODIFIED := TRUE;
                    if FisOS then (*---------------- OS File --------------------*)
                      begin
                        write_data (iorslt, FTrefnum, ord (@Fbuffer), Fblksize,
                                    actual, absolute, ord4 (Fnxtblk-1)*Fblksize);
                        if iorslt > 0 then MapToUCSD (iorslt);
                      end
                    (*$IFC MONITOR*)
                    else (*------------------------- UCSD File ------------------*)
                      unitio (iorslt, funit,ord (@FBUFFER), 1, DFIRSTBLK+FNXTBLK-1,
                              actual, without_header, writeop)
                    (*$ENDC*)
                  END;   (* fbufchngd *)
                IF iorslt > ORD(INOERROR) THEN
                  GOTO 1;
                IF FNXTBLK < FMAXBLK THEN
                  if FisOS then {---------------- OS File --------------------}
                    begin
                      read_data (iorslt, FTrefnum, ord (@Fbuffer), Fblksize,
                                 actual, absolute, ord4 (Fnxtblk)*Fblksize);
                      if iorslt > 0 then
                        if eoferror then iorslt := 0
                        else MapToUCSD (iorslt);
                    end
                  else {------------------------- UCSD File ------------------}
                    begin
                      {$IFC MONITOR}
                      unitio (iorslt, funit,ord (@FBUFFER), 1, DFIRSTBLK+FNXTBLK,
                              actual, without_header, readop)
                      {$ENDC}
                    end
                ELSE
                  FILLCHAR(FBUFFER,FBLKSIZE,CHR(0));
                IF iorslt > ORD(INOERROR) THEN
                  GOTO 1;
                FNXTBLK := FNXTBLK+1;
                FNXTBYTE := 0;
                IF FNXTBLK > FMAXBLK THEN
                  BEGIN
                    FMAXBLK := FNXTBLK;
                    FMAXBYTE := FNXTBYTE;
                  END;
                END    (* NOT done *)
            UNTIL done;
            IF FRECSIZE = 1 THEN
              IF FWINDOW^[0] = CHR(EOL) THEN
                IF DFKIND = TEXTFILE THEN
                  IF (FNXTBYTE >= FBLKSIZE-127) AND NOT ODD(FNXTBLK) THEN
                    BEGIN
                    FNXTBYTE := FBLKSIZE-1;
                    FWINDOW^[0] := CHR(0);
                    %_FPUT(f)
                    END
            END    (* WITH FHEADER *)
        ELSE  { fsoftbuf = false, not blockdev or untyped file (frecsize = 0)}
          BEGIN  {NOT FSOFTBUF}
            iorslt := inotimpl;
          END;   (* NOT FSOFTBUF *)
      END  (* IF fisopen *)
    ELSE
      BEGIN  (* NOT fisopen *)
      IORSLT := INOTOPEN;
1:    FEOF := TRUE;
      FEOLN := TRUE
      END;   (* NOT fisopen *)
2:
  (*$IFC DEBUG*)
  IF trace (30) THEN
      WRITELN ('l %_FPUT: iorslt =', iorslt);
  (*$ENDC*)

  END;   (* %_FPut *)


(*$IFC FALSE*)
{ /////////////////////////////////////////////////// This is done in PASIO
(* FEOF ---------------------------------------------------------- *)
FUNCTION FEOF(*VAR f: FIB*);
BEGIN FEOF := f.FEOF END;

(* TEXT FILE INTRINSICS *)

(* FEOLN ---------------------------------------------------------- *)
FUNCTION FEOLN(*VAR f: FIB*);           (* This is done in PASIO *)
  BEGIN
  FEOLN := f.FEOLN
  END;
///////////////////////////////////////////////////////////////////////// }
(*$ENDC*)


(* %_WriteLn ---------------------------------------------------------- *)
PROCEDURE %_WriteLn (*VAR f: FIB*);
  var packchar : packed array [0..1] of char;
  BEGIN  (* %_WriteLn *)
    packchar [0] := chr (eol);
    %_WriteChar (f, @packchar, 1);
  END;   (* %_WriteLn *)



Function %_GetDWMapTableAddr : longint;   External;  {Return DW mapping table}


(* %_WriteChar ---------------------------------------------------------- *)
PROCEDURE %_WRITECHAR (* VAR F: FIB; charaddr : longaddr; count : integer *);
label 1;
var actual : longint;
    i, outcount : integer;
    charstr : Tstr255;
    charstrP : ^chararray;
    outbuffer : packed array [0..1024] of 0..255;       {only if translate}
    citoh : boolean;
    poutfp : fibp;

  FUNCTION HaveLisaChar : BOOLEAN;      {to see whether there is any Lisa char}
  VAR j : INTEGER;
  BEGIN
    for j := 0 to count-1 do
      IF (charstrP^[j] < CHR (1)) OR (charstrP^[j] > CHR(126)) THEN
        begin
          HaveLisaChar := true;
          exit (HaveLisaChar);
        end;
    HaveLisaChar := false;
  END;  {HaveLisaChar}

  FUNCTION HavePrinter (var isCitoh : BOOLEAN) : BOOLEAN;
                                {to see if -printer is C.itoh or Daisy Wheel}
  CONST
     is_dmp = 32;
     is_lqp = 33;
     is_laser = 34; {not handled, YET}
  TYPE
     bitsy = packed record
                     is_printer: boolean;
                     is_default: boolean;
                     drvrid : -8192..8191; {driver id part of first extension word}
                   end; {of bitsy}
  VAR snooker: ^bitsy;
      errnum : integer;
      key: longint;
      my_pmem: pmemrec;
      devname, prname : e_name;
      position: configdev;
  BEGIN
    isCitoh := false;
    HavePrinter := false;
    prname := PrintDevice;
    delete (prname ,1, 1);                      {get rid of the '-'}
    READ_PMEM(errnum, my_pmem);
    key := 0;
    repeat  {find PrintDevice}
      GETNXTCONFIG(errnum, key, my_pmem, position);
      snooker := @position.extwords[1];
      IF errnum <= 0 then
        IF prname = position.devname THEN       {OS returns no '-'}
          IF position.nextwords >= 1 THEN
            IF snooker^.is_printer   THEN
              BEGIN
                HavePrinter := TRUE;
                IF (snooker^.drvrid = is_dmp)
                  THEN isCitoh := TRUE
                  ELSE isCitoh := FALSE {lqp (or laser) };
                EXIT (HavePrinter);
              END;
    UNTIL (errnum > 0);
  END;  {HavePrinter}

  PROCEDURE CiOut (ordch : integer);  {put each ch in outbuffer}
  BEGIN
    outbuffer [outcount] := ordch;
    outcount := outcount + 1;
  END;  {CiOut}


  PROCEDURE CiTranslate;                  {do translate and put in outbuffer}
  CONST
    {These are constants used in CiSetCntry.}
    cmCloseSwitch    = 'D'; {Close DIP switches; takes two OR-mask bytes}
    cmOpenSwitch     = 'Z'; {Open DIP switches; takes two OR-mask bytes}
    US               = 0;   {code for national char set on DMP}
    Italian          = 1;   {code for national char set on DMP}
    UK               = 3;   {code for national char set on DMP}
    German           = 4;   {code for national char set on DMP}
    Swedish          = 5;   {code for national char set on DMP}
    French           = 6;   {code for national char set on DMP}
    Spanish          = 7;   {code for national char set on DMP}

  VAR
    ch : CHAR;
    j : integer;
    charEuropean: SET OF 0..255;  {Chars that can be printed by switching to some European char set.}
    charSubs: SET OF 0..255;      {Chars that can't be printed by using a different
                                   country, but can have a different char substituted.}

    {This function returns substitutions for chars that can't be handled by going to a European character set,
     but do have good substitutions.}
    FUNCTION  CiSubs (ach: CHAR): CHAR;
    BEGIN
      CASE ord(ach) OF
        $82:             CiSubs := 'C';      {for C cedilla}
        $83:             CiSubs := 'E';      {for E acute}
        $87, $89, $8B,
        $BB:             CiSubs := 'a';      {for a acute, circumflex, tilde,
                                                  superscript}
        $BE:             CiSubs := chr($8A); {a umlaut for ae ligature}
        $90, $91:        CiSubs := 'e';      {for e circumflex, umlaut}
        $92, $94, $95:   CiSubs := 'i';      {for i acute, circumflex, umlaut}
        $97, $99, $9B,
        $BC:             CiSubs := 'o';      {for o acute, circumflex, tilde,
                                                  superscript}
        $BF:             CiSubs := chr($9A); {o umlaut for o slashed}
        $9C, $9E:        CiSubs := 'u';      {for u acute, circumflex}
        $A5:             CiSubs := chr($A1); {degree symbol for bullet}
        $AB:             CiSubs := '''';     {for acute alone}
        $AE:             CiSubs := chr($80); {A umlaut for AE ligature}
        $AF:             CiSubs := chr($85); {O umlaut for O slashed}
        $B4:             CiSubs := 'Y';      {for Yen sign}
        $C4:             CiSubs := 'f';      {for function sign}
        $C7:             CiSubs := '<';      {for "<<" character}
        $C8:             CiSubs := '>';      {for ">>" character}
        $CA:             CiSubs := ' ';      {for non-breaking space}
        OTHERWISE        CiSubs := '!';      {This shouldn't happen!}
      END;
    END;  {CiSubs}

    {This is the procedure for accessing different national character sets on the C. Itoh.  CiOut sends
     an ascii char to the C.Itoh.}
    PROCEDURE CiSetCntry (cntry: INTEGER);
    BEGIN
      CiOut(ESC);
      CiOut(ord(cmOpenSwitch));
      CiOut(7);    {open switch 1 bits 0, 1, 2; this happens to be US setting}
      CiOut(0);    {do nothing to switch 2}

      IF cntry<>US THEN BEGIN
        CiOut(ESC);
        CiOut(ord(cmCloseSwitch));
        CiOut(cntry);       {set the country code in switch 1 bits 0, 1, 2}
        CiOut(0);           {do nothing to switch 2}
      END;
    END;  {CiSetCntry}

    {This procedure handles a character that is in one of the C.Itoh's European character sets, but not in the
     US character set.}
    PROCEDURE CiEuropeanOut (ach: CHAR);
    BEGIN
      CASE ord(ach) OF
        $80: BEGIN CiSetCntry(German);  CiOut($5B); END;  {A umlaut}
        $81: BEGIN CiSetCntry(Swedish); CiOut($5D); END;  {A with circle}
        $84: BEGIN CiSetCntry(Spanish); CiOut($5C); END;  {N tilde}
        $85: BEGIN CiSetCntry(German);  CiOut($5C); END;  {O umlaut}
        $86: BEGIN CiSetCntry(German);  CiOut($5D); END;  {U umlaut}
        $88: BEGIN CiSetCntry(Italian); CiOut($7B); END;  {a grave}
        $8A: BEGIN CiSetCntry(German);  CiOut($7B); END;  {a umlaut}
        $8C: BEGIN CiSetCntry(Swedish); CiOut($7D); END;  {a with circle}
        $8D: BEGIN CiSetCntry(Italian); CiOut($5C); END;  {c cedilla}
        $8E: BEGIN CiSetCntry(Italian); CiOut($5D); END;  {e acute}
        $8F: BEGIN CiSetCntry(Italian); CiOut($7D); END;  {e grave}
        $93: BEGIN CiSetCntry(Italian); CiOut($7E); END;  {i grave}
        $96: BEGIN CiSetCntry(Spanish); CiOut($7C); END;  {n tilde}
        $98: BEGIN CiSetCntry(Italian); CiOut($7C); END;  {o grave}
        $9A: BEGIN CiSetCntry(German);  CiOut($7C); END;  {o umlaut}
        $9D: BEGIN CiSetCntry(Italian); CiOut($60); END;  {u grave}
        $9F: BEGIN CiSetCntry(German);  CiOut($7D); END;  {u umlaut}
        $A1: BEGIN CiSetCntry(Italian); CiOut($5B); END;  {degree sign}
        $A3: BEGIN CiSetCntry(Italian); CiOut($23); END;  {pound sign}
        $A4: BEGIN CiSetCntry(Italian); CiOut($40); END;  {section mark}
        $A7: BEGIN CiSetCntry(German);  CiOut($7E); END;  {German double-s}
        $AC: BEGIN CiSetCntry(French);  CiOut($7E); END;  {umlaut alone}
        $C0: BEGIN CiSetCntry(Spanish); CiOut($5D); END;  {inverted ?}
        $C1: BEGIN CiSetCntry(Spanish); CiOut($5B); END;  {inverted !}
      END;
      CiSetCntry(US);
    END;  {CiEuropeanOut}

  BEGIN  {CiTranslate}
    outcount := 0;
    charEuropean := [$80, $81, $84..$86, $88, $8A, $8C..$8F, $93, $96, $98, $9A, $9D, $9F, $A1,
                     $A3, $A4, $A7, $AC, $C0, $C1];

    charSubs     := [$82, $83, $87, $89, $8B, $90..$92, $94, $95, $97, $99, $9B, $9C,
                     $9E, $A5, $AB, $AE, $AF, $B4, $BB, $BC, $BE, $BF, $C4, $C7, $C8,
                     $CA];
    {Each char is checked by this code when it is the first char in the buffer hPbData^^.  If it's plain ascii
      or it's in charEuropean, leave it alone.  If it's in charSubs do the substitution.  Else substitute
     a '?'}
    FOR j := 0 TO count-1 DO
      BEGIN
        ch := charstrP^[j];
        IF {(ch < ' ') OR} (ch > CHR(126)) THEN
          BEGIN
            IF ord(ch) IN charSubs THEN ch := CiSubs(ch)
            ELSE IF NOT (ord(ch) IN charEuropean) THEN ch := '?';
            {else leave it alone, it will be handled.}
          END;
        {If it's in charEuropean then it goes out via CiEuropeanOut, else
         it goes out via CiOut.  CiOut is "vanilla" ascii printing.}
        IF ord(ch) IN charEuropean THEN CiEuropeanOut(ch)
        ELSE CiOut (ord (ch));
      END;

    charstrP := @outbuffer;
    count := outcount;
  END;  {CiTranslate}

  PROCEDURE DwTranslate;
  TYPE
    table = packed array [128..255,1..2] of 0..255;
    Pass_Table = ^table;
  VAR
    ch : CHAR;
    j : integer;
    Euro_1 : Pass_Table;

      {The following procedure will store the <si>,<so>,<bs> and the 'CharStrP '
        characters into the buffer}
    Procedure Ci_Call(Ci_orch1,Ci_orch2 : integer);
     Begin
         if Ci_orch1 >= $7F then             {Store 1ST Character into buffer}
          Begin
             CiOut(SO);  { Store the 'Shift out' character}
             CiOut(Ci_orch1 - $40);
             CiOut(SI);  { Store the 'Shift in ' character}
          End
                            else
             CiOut(Ci_orch1);
         if Ci_orch2 <> $00 then    { If 2nd character is not a null}
           Begin
            CiOut(BS);          { Store 'Backspace' character }
            if Ci_orch2 >= $7F then             {Store 2nd Character into buffer}
              Begin
               CiOut(SO);  { Store the 'Shift out' character}
               CiOut(Ci_orch2 - $40);
               CiOut(SI);  { Store the 'Shift in ' character}
              End
                        else
               CiOut(Ci_orch2);
           End;
     End;

  BEGIN   {DwTranslate}
  outcount:= 0;
  Euro_1 := pointer (%_GetDWMapTableAddr);  { Passing  the address of the mapping table}
  For j := 0 to count-1 do
    Begin
      ch := charstrP^[j];
      if ch > chr (127) then
        BEGIN
         Ci_Call(Euro_1^[ord(ch),1],Euro_1^[ord(ch),2]);
        END
      else CiOut (ord (ch));
    END;
  charstrP := @outbuffer;
  count := outcount;
  End;  {DwTranslate}

  PROCEDURE writedata (refnum : integer);
  begin
    write_data (iorslt, refnum, ord (charstrP), count, actual, sequential, 0);
  end;  {writedata}

  PROCEDURE ckoutredirect;
  begin
    if goutputrflag AND (outputfile.funit <> unitScConsole) then {output redirected}
      if (outputfile.funit = unitScPrinter) AND (charstrP^[0] = chr(ESC)) then
                          {if redirected to printer, don't want to send esc out}
      else
        begin
          %_WriteChar (outputfile, charaddr, count);
          if outputfile.funit <> unitScPrinter then
            if iorslt > 0 then resetoutput;
        end;
  end;  {ckoutredirect}

  BEGIN  (* %_WriteChar *)
  {  All WRITELN related routines can not use WRITELN (trace) again since
     they will recursively call themselves.
  }
    IORSLT := ORD(INOERROR);
    if count <= 0 then exit (%_WriteChar);
    WITH f, FVIDstuff, FHEADER DO
      if FISOPEN AND (HiByt3 = openpattern) then
        BEGIN {FISOPEN}     {allow output to inputfile to do erase etc.}
          charstr := '';
          charstrP := pointer (ord (@charstr)+1);   (* bypass the length byte *)
          if charaddr = nil then        {special case, to space fill}
            fillchar (charstrP^, count, ' ')
          else
            moveleft (charaddr^, charstrP^, count);
                        {copy to local string in case source is in code seg.}
          charstr [0] := CHR (count);

          CASE funit of
            unitWiConsole :             {OUTPUT, -CONSOLE to window}
              begin
                if PInWindow > 0 then writedata (consoleRefnum)   {nested call}
                else PasTerm.VWrite (charstr);
                ckoutredirect;
              end;

            unitScConsole :             {OUTPUT, -CONSOLE to screen}
              begin
                writedata (consoleRefnum);
                ckoutredirect;
              end;

            unitScPrinter :
              begin
                if PTrLisaChar then
                  if HaveLisaChar then
                    if HavePrinter (citoh) then
                      if citoh then CiTranslate else DWTranslate;
                writedata (FTrefnum);
              end;

            unitWiPrinter : iorslt := PasTerm.PrWrite (charstr);

            unitOSFile :
              begin
                IF FSOFTBUF THEN                {write to file}
                  begin
                    for i := 1 to count do
                      BEGIN
                        FWINDOW^[0] := charstr [i];
                        %_FPUT(f);
                        if iorslt > 0 then goto 1;
                      END;
                  end
                else                            {serial devices}
                  writedata (FTrefnum);
              end;

            otherwise iorslt := inotimpl;       {other devices }
          end;  {case}

          if (@f <> @inputfile) and (@f <> @PInputfile) then
            begin
              feof := true;
              feoln := true;
            end;
      END  { IF fisopen }
    ELSE
      BEGIN  (* NOT fisopen *)
      IORSLT := INOTOPEN;
1:    FEOF := TRUE;
      FEOLN := TRUE
      END;   (* NOT fisopen *)

  END {%_WRITECHAR} ;


{ -----------------------------------%_ReadLn ---------------------------------- }
PROCEDURE %_ReadLn (*VAR f: FIB*);                (* taken from nsystem.d.text *)
VAR fp : fibp;

  BEGIN  (* %_ReadLn *)
    IORSLT := ORD(INOERROR);
    WITH f DO
      if FISOPEN AND (HiByt3 = openpattern) then
      BEGIN
        WHILE NOT f.FEOLN DO
          %_FGET(f);
       {IF f.FSTATE = FJANDW THEN
          %_FGET(f)
        ELSE
       }
          BEGIN
          f.FSTATE := FNEEDCHAR;
          f.FEOLN := FALSE;
          if (funit = unitScConsole) or (funit = unitScKeyboard) then                        {3.4 YC 3/22/83}
            begin
              fp := @PInputfile;
              fp^.fstate := fneedchar;          {need to set inputfile ?}
              fp^.feoln := false;
            end;
          END;
      END  (* IF fisopen *)
    ELSE
      BEGIN  (* NOT fisopen *)
      IORSLT := INOTOPEN;
      FEOF := TRUE;
      FEOLN := TRUE
      END;   (* NOT fisopen *)
  END;   (* %_ReadLn *)



(* %_ReadChar ---------------------------------------------------------- *)
FUNCTION %_ReadChar (*VAR f: FIB) : CHAR*);
  VAR liorslt : INTEGER;
      fp : fibp;

  BEGIN  (* %_ReadChar *)
  (*$IFC DEBUG*)
    IF trace (30) THEN
        WRITELN ('e %_READCHAR: f =', ord (@f));
  (*$ENDC*)
    WITH f DO
      if FISOPEN AND (HiByt3 = openpattern) then
      BEGIN
        IORSLT := ORD(INOERROR);
        IF FSTATE = FNEEDCHAR THEN %_FGET(f);
        %_Readchar := FWINDOW^[0];
       {IF FSTATE = FJANDW THEN
          %_FGET(f)
        ELSE
            }
          FSTATE := FNEEDCHAR;
          if (funit = unitScConsole) or (funit = unitScKeyboard) then                        {3.4 YC 3/22/83}
            begin
              fp := @PInputfile;
              fp^.fstate := fneedchar;          {need to set input file ?}
              fp^.feoln := feoln;
            end;
      END  (* IF fisopen *)
    ELSE
      BEGIN  (* NOT fisopen *)
      IORSLT := INOTOPEN;
      FEOF := TRUE;
      FEOLN := TRUE
      END;   (* NOT fisopen *)

  (*$IFC DEBUG*)
  IF trace (30) THEN
    BEGIN
    liorslt := iorslt;      (* since the trace message will reset iorslt *)
    WRITELN ('l %_READCHAR: iorslt =', iorslt);
    iorslt := liorslt;
    END;
  (*$ENDC*)

  END;   (* %_ReadChar *)



PROCEDURE %_FSEEK (* VAR F : FIB; RECORDNUM : integer *);
  label 1;
  var
    block, byte, n : longint;
    liorslt : integer;
    actual, count : longint;

  begin (* ------------------------- %_SEEK --------------------------------- *)
  (*$IFC DEBUG*)
    IF trace (50) THEN
        WRITELN ('e %_FSEEK: f =', ord (@f), ' RECORDNUM =', recordnum);
  (*$ENDC*)
    iorslt := ord (inoerror);
    with F, FVIDstuff, Fheader do
      begin
        if (not fisopen) or (HiByt3 <> openpattern) then
          begin
            iorslt := inotopen;
            goto 1;
          end;
        if (recordnum < 0) or
           (not fsoftbuf) or
           ((dfkind = textfile) and (frecsize = 1)) then
             goto 1;
        n := ord4 (recordnum) * frecsize;
        block := n div fblksize + 1;    (* to next block *)
        byte := n mod fblksize;
        if byte = 0 then               (* if on block boundary *)
          begin
            byte := fblksize;
            block := block - 1;
          end;
        n := FMAXBLK;          {dlastblk - dfirstblk;}
        count := FMaxByte;
        if (block > n) or
           ((block = n) and (byte >= count)) then
          begin
            block := n;                (* can not go beyound last block *)
            byte := count;
          end;
        if block <> fnxtblk then       (* not the current working one *)
          begin
            if fbufchngd then
              begin
                fbufchngd := false;
                fmodified := true;
                if FisOS then (* ---------------- OS File --------------------- *)
                  begin
                    if fnxtblk = FMAXBLK then          (* last block *)
                      count := FNXTBYTE
                    else count := fblksize;
                    write_data (iorslt, FTrefnum, ord (@fbuffer), count,
                                actual, absolute, ord4 (Fnxtblk-1)*Fblksize);
                                                        (* write buffer out *)
                    if iorslt > 0 then MapToUCSD (iorslt);
                  end
                else  (* ----------------------- UCSD File -------------------- *)
                  begin
                    {$IFC MONITOR}
                    UnitIO (iorslt, funit, ord (@fbuffer), 1, dfirstblk+fnxtblk-1,
                            actual, without_header, writeop);
                    {$ENDC}
                  end;
                if iorslt > 0 then goto 1;
              end;
            if (block <= fmaxblk) and (byte <> fblksize) then
              if FisOS then (*---------------- OS File --------------------*)
                begin
                  read_data (iorslt, FTrefnum, ord (@Fbuffer), Fblksize,
                             actual, absolute, ord4 (block-1)*Fblksize);
                  if iorslt > 0 then
                    if eoferror
                    then begin
                           iorslt := 0;        (* hit end of file - OK *)
                         end
                    else MapToUCSD (iorslt);
                end
              else (*------------------------- UCSD File ------------------*)
                begin
                  {$IFC MONITOR}
                  UnitIO (iorslt, funit, ord (@fbuffer), 1, dfirstblk+block-1,
                          actual, without_header, readop);
                  {$ENDC}
                end;
            if iorslt > 0 then goto 1;
          end;

        if fnxtblk > fmaxblk then
          begin
            fmaxblk := fnxtblk;
            fmaxbyte := fnxtbyte;
          end
        else
          if (fnxtblk = fmaxblk) and (fnxtbyte > fmaxbyte) then
            fmaxbyte := fnxtbyte;
        feof := false;
        feoln := false;
        freptcnt := 0;
        if fstate <> fjandw then
          fstate:=fneedchar;
        fnxtblk := block;
        fnxtbyte := byte;
       end;   (* with F, Fheader *)
1:
  (*$IFC DEBUG*)
  IF trace (50) THEN
    BEGIN
    liorslt := iorslt;      (* since the trace message will reset iorslt *)
    WRITELN ('l %_SEEK: iorslt =', iorslt);
    iorslt := liorslt;
    END;
  (*$ENDC*)
  end;  (* ------------------------- %_SEEK --------------------------------- *)


  procedure %_funitiocall (* unitno : integer; bufaddr : longint; nbytes : integer;
                             blocknum : integer; mode : integer; unitcode : integer*);
                   (* for unitread, unitwrite, and unitclear *)
  begin
    (*
    write ('You have called an illegal routine : ');
    case unitcode of
    0 : writeln ('UNITREAD');
    1 : writeln ('UNITWRITE');
    2 : writeln ('UNITCLEAR');
    end;
    writeln ('Type RETURN to continue');
    readln;
    *)

    iorslt := inotimpl;
  end;  (* funitiocall *)


  function %_funitbusy (* unitno : integer *);
  begin
    (*
    writeln ('You have called an illegal routine : UNITBUSY');
    writeln ('Type RETURN to continue');
    readln;
    *)

    %_funitbusy := true;
    iorslt := inotimpl;
  end; (* %_funitbusy *)




procedure moveconsole (* var errnum : integer; applconsole : consoledest *);
  label 1;
  var refnum, lerrnum : integer;
      filename, dcontrolname : pathname;
      vname, devname : e_name;
      cparm :dctype;

  begin
    errnum := 0;
    if apconsole <> ord (applconsole) then      (* console is changed *)
      begin
        case applconsole of
          alscreen   : begin
                         devname := 'ALTCONSOLE';
                         filename := '-ALTCONSOLE-X';
                         dcontrolname := '-ALTCONSOLE';
                       end;
          mainscreen : begin
                         devname := 'MAINCONSOLE';
                         filename := '-MAINCONSOLE-X';
                         dcontrolname := '-MAINCONSOLE';
                       end;
          xsorocA    : begin
                         devname := 'RS232A';
                         filename := '-RS232A-X';
                         dcontrolname := '-RS232A';
                       end;
          xsorocB    : begin
                         devname := 'RS232B';
                         filename := '-RS232B-X';
                         dcontrolname := '-RS232B';
                       end;
          folder     : begin
                       (* this is not supported for now.
                         if (not PConsWindow)  {if UStdTerm not used, disallow the move}
                           or gexecflag or goutputrflag then
                           begin
                             errnum := e_movefolder;
                             goto 1;
                           end;
                               {Don't close console or change consoleRefnum in case
                                of error messages, so change console to altscreen.}
                         moveconsole (errnum, alscreen);
                         if errnum > 0 then
                           moveconsole (errnum, mainscreen);
                         consoleFunit := unitWiConsole;
                         %_FInit (inputfile, @inputfwindow, 0);
                         %_FInit (outputfile, @outputfwindow, 0);
                           { reset (inputfile) and (outputfile) - interactive}
                   { Don't want to open folder until first readln or writeln. }
                   { But want to set up fibs so can pass %_fget and %_writechar }
                         with inputfile do
                           begin
                             FIsOpen := true;
                             Funit := unitWiConsole;
                             FVIDstuff.FTfolderP := nil;
                           end;
                         with outputfile do
                           begin
                             FIsOpen := true;
                             Funit := unitWiConsole;
                             FVIDstuff.FTfolderP := nil;
                           end;
                         apconsole := ord (applconsole);
                       *)
                       end;
        end;  {case}

      if applconsole <> folder then     {not to folder}
        begin
          (* Allow move back to screen. This should only be called by the Selector
             Shell and the Workshop when quitting from office system for now.
          if apconsole = ord (folder) then
            begin       {dont want to allow folder to screen move for now}
              errnum := e_movefolder;          {have to reboot to get this}
              goto 1;
            end;
          *)
          mount (errnum, vname, devname, devname);        {may be in shell}
          if errnum = 1052 then errnum := 0       {OK if already mounted}
          else if errnum > 0 then goto 1;

          cparm.dcversion := 2;
          cparm.dccode := 6;
          cparm.dcdata[0] := 0;         { wait for input} {needed for screen}
          device_control (errnum, dcontrolname, cparm);
          cparm.dccode := 17;
          cparm.dcdata[0] := 1;         {auto LF} {needed for screen}
          device_control (errnum, dcontrolname, cparm);

         (* if errnum > 0 then goto 1;  *)

         (*           { The following is in movesoroc program or LDS shell}
          cparm.dccode := 1;          {no parity}
          cparm.dcdata[0] := 0;
          device_control (errnum, dcontrolname, cparm);
          if errnum > 0 then goto 1;
          cparm.dccode := 3;          {XON/XOFF output handshake}
          device_control (errnum, dcontrolname, cparm);
          if errnum > 0 then goto 1;
          cparm.dccode := 5;          { baud rate }
          cparm.dcdata[0] := 9600;
          device_control (errnum, dcontrolname, cparm);
          if errnum > 0 then goto 1;
          cparm.dccode := 7;          { no input handshake }
          cparm.dcdata[0] := 0;
          device_control (errnum, dcontrolname, cparm);
          if errnum > 0 then goto 1;
          cparm.dccode := 9;          { no input handshake }
          cparm.dcdata[0] := -1;
          cparm.dcdata[1] := -1;
          cparm.dcdata[2] := 65;
          device_control (errnum, dcontrolname, cparm);
          if errnum > 0 then goto 1;  *)

          open (errnum, filename, refnum, [Dread, Dwrite, Global_refnum]);
          if errnum <= 0 then
            begin                 { open OK }
              if consoleRefnum <> -1 then
                close_object (lerrnum, consoleRrefnum);
              consoleRefnum := refnum;
              consoleFunit := unitScConsole;
              inputfile.Funit := unitScConsole;
              outputfile.Funit := unitScConsole;
              apconsole := ord (applconsole);
            end;
        end;
    end;
1:
  end;  {moveconsole}


