
(* file blockio3.text *)

    (***********************************************************************)
    (*                                                                     *)
    (*  BLK IO routines that are supported in stand alone OS for accessing *)
    (*  UCSD files. These are taken from SYSTEM.A.TEXT from SYSTEM.PASCAL  *)
    (*                                                                     *)
    (*  In this file,  blockio3,  the following routines are defined:      *)
    (*    %_Finit, Reseter, FReset, %_FOpen, %_FClose, ExecReset, ExecFlag *)
    (*                                                                     *)
    (***********************************************************************)


        (* FILE STATE HANDLERS *)

{------------------------------ %_Finit ---------------------------------------}
PROCEDURE %_Finit(* VAR f: FIB; window: windowP; {recwords} recbytes : INTEGER *);

  (* The Compiler emits code to call %_Finit when a file is opened.  This  *)
  (* initializes  f,  the file's FIB (File Information Block) so all     *)
  (* subsequent calls to access the file will have the proper file type  *)
  (* and state information available in the FIB.                         *)

  BEGIN  (* %_Finit *)
  (*$IFC DEBUG*)
  IF trace (50) THEN
    WRITELN ('e %_finit: f = ', ORD(@f), ' recwords =', recwords);
  (*$ENDC*)

  WITH f, FVIDstuff, Fheader DO
  BEGIN  (* WITH f *)
   (* a kludge to satisfy some backward buggy ucsd style programming.
   IF (FIsOpen) and (HiByt3 = openpattern) and (funit >= unitScPrinter) THEN
     IORslt := INotClosed       {File already open - error / Bug Fix}
   ELSE                         {except reopen of console or keyboard}
   *)
   IF gexecflag AND (@f = @inputfile) THEN      {reset of input during exec file}
     IORslt := INotClosed       {File already open - error / Bug Fix}
   ELSE
   BEGIN
    FWindow := window;
    FEOF    := TRUE;
    FEOLN   := TRUE;
    FIsOS   := TRUE;
    FState  := fjandw;
    FIsOpen := FALSE;
    FModified := false;
    FNxtblk := 0;
    FIsBlkd := false;
    FSoftBuf := false;
    FTrefnum := -1;
    DOrefnum := -1;
    Fnewfile := false;          {no creation of new files}
    HiByt3 := openpattern;      {this is a simple flag to mean inited}

     {later set FrecSize to recwords here, and do setting of real value in %_fopen,
      since %_fopen needs to check the type of f}
        {pasio just pass #bytes now}
    IF   (recbytes =  0)                        {recbytes 0 = interactive}
      OR (recbytes = -2) THEN                   {recbytes -2 = text}
      BEGIN  { byte File }
      {FRecSize := 1;               (* 1 byte => Char File *)
       FWindow^[1] := CHR(0);}  {what is this for?}    {NULL char}
      {IF recbytes = 0 THEN  }  {text and interactive are merged now}
        FState := FNeedChar;    {no preget for text and interactive}
      FRecSize := -1;           {this will be changed to 1 in %_fopen}
      END    (* Char File *)
    ELSE
      IF recbytes < 0 THEN                    (* recbytes -1 = untyped file *)
        BEGIN  (* Block File *)
        FWindow := NIL;
        FRecSize := 0;                    (* 0 bytes => Block File *)
        END    (* Block File *)
      ELSE                               (* recbytes >0 = typed file *)
        BEGIN
        {FRecSize := recwords + recwords;}   (* n bytes => Typed File *)
        FRecSize := recbytes;
        END;
    (*$IFC DEBUG*)
      IF trace (50) THEN
        WRITELN ('l %_Finit: FRecSize = ', FRecSize);
    (*$ENDC*)
    END;
   END;   (* WITH f *)
  END;  (* %_Finit *)




(* Reseter  (25-June-82) ------------------------------------------------ *)
PROCEDURE Reseter(VAR f:FIB);

  VAR Bigger: BOOLEAN;
      Tempbuf : CharArray;
      ftempp, fbufp : ^chararray;
      actual, count : longint;

  BEGIN  (* Reseter *)
  (*$IFC DEBUG*)
    IF trace (50) THEN
      WRITELN ('e Reseter : f =', ORD (@f));
  (*$ENDC*)
  WITH f DO                        (* same code for UCSD and OS files except i/o *)
    BEGIN  (* WITH f *)
      FReptCnt := 0;
      FEOLN := FALSE;
      FEOF := FALSE;
      IF FIsBlkd THEN
        BEGIN  (* Blocked File *)
        bigger := FNxtBlk > FMaxBlk;
        IF bigger THEN
          FMaxBlk := FNxtBlk;
        IF FSoftBuf THEN
          BEGIN  (* typed file on block-structured device *)
          IF bigger THEN
            FMaxByte := FNxtByte
          ELSE
            IF FNxtBlk = FMaxBlk THEN
              IF FNxtByte > FMaxByte THEN
                BEGIN
                bigger := TRUE;
                FMaxByte := FNxtByte
                END;
          IF FBufChngd THEN
            BEGIN  (* buffer contents have been modified *)
            FBufChngd := FALSE;
            FModified := TRUE;
            IF bigger THEN
              BEGIN  (* Fill extra with nulls *)
                fillchar (tempbuf, fblksize, chr (0));
                ftempp := @tempbuf;
                fbufp := pointer (ord (@FBUFFER) + FNXTBYTE);
                moveleft (ftempp^, fbufp^, FBlkSize-FNxtByte);
              END;   (* Fill extra with nulls *)
            if FIsOs then (* --------------------- OS File --------------------- *)
              begin
                if (FHeader.DFkind = TEXTFILE) OR (FNxtBlk <> FMaxBlk) then
                  count := fblksize
                else count := FMaxByte;
                           (* don't write full block if not text file or last block
                              so we can get real size at next open *)
                write_data (iorslt, FVIDstuff.FTrefnum, ord (@FBuffer), count,
                            actual, absolute, ord4 (FNxtblk-1)*Fblksize);
              end
            else  (* -------------------------- UCSD File ----------------------*)
              begin
                (*$IFC MONITOR*)
                unitio (IORslt, FUnit, ord (@FBuffer), 1,
                    FHeader.DFirstBlk+FNxtBlk-1,actual, without_header,  writeop);
                (*$ENDC*)
              end;
            IF bigger AND (FHeader.DFkind = TEXTFILE)
                AND ODD(FNxtBlk) THEN
              BEGIN  (* Text Files are always even # blocks *)
              FMaxBlk := FMaxBlk+1;
              FILLCHAR(FBuffer,FBlkSize,CHR(0));
              if FIsOs then (* --------------------- OS File --------------------- *)
                write_data (iorslt, FVIDstuff.FTrefnum, ord (@FBuffer), Fblksize,
                                actual, absolute, ord4 (FNxtblk)*Fblksize)
              (*$IFC MONITOR *)
              else  (* -------------------------- UCSD File ----------------------*)
                unitio (IORslt, FUnit, ord (@FBuffer), 1,
                        FHeader.DFirstBlk+FNxtBlk, actual, without_header, writeop)
              (*$ENDC*)
              END;   (* Text Files are always even # blocks *)
            END;   (* buffer contents have been modified *)
          FNxtByte := FBlkSize;
          END;  (* typed file on block-structured device *)
        FNxtBlk := 0;
        IF FSoftBuf AND (FHeader.DFkind = TEXTFILE) THEN
          FNxtBlk := 2;
        END;   (* Blocked File *)

    END    (* WITH f *);

  (*$IFC DEBUG*)
    if trace (50) THEN
      WRITELN ('l Reseter : ');
  (*$ENDC*)
  END;   (* Reseter *)


(* FReset (25-June-82) ------------------------------------------------------ *)
PROCEDURE FReset(VAR f: FIB);

  BEGIN  (* FReset *)
  (*$IFC DEBUG*)
    IF trace (50) THEN
      WRITELN ('e FReset  : f =', ORD (@f));
  (*$ENDC*)

  IORslt := ORD(INoError);
  WITH f DO                                   (* same code for UCSD and OS files *)
      IF FIsOpen THEN
        BEGIN  (* File is open *)
        Reseter(f);
        IF FRecSize > 0 THEN             (* record size - 0 = untyped file,
                                            1 = text or interactive file *)
          BEGIN
          IF FState = FJandW THEN
            %_FGET(f)
          ELSE
            FState := FNeedChar;
          END;
        END;   (* File is open *)

  (*$IFC DEBUG*)
    IF trace (50) THEN
      WRITELN ('l FReset  : ioresult =', IORslt);
  (*$ENDC*)
  END;   (* FReset *)





(* %_FOpen --------------------------------------------------------------------- *)
PROCEDURE %_FOpen(* VAR f: FIB; VAR ftitle: pathname;
                    fopenold: BOOLEAN; junk:FIBP *);
  (*$IFC MONITOR*)
  LABEL 1, 2, 3;
  (*$ELSEC*)
  LABEL 2, 3, 4;
  (*$ENDC*)
  VAR ldirp: DIRP;
      lunit: UNITNUM;
      linx: DIRRANGE;
      lsegs: INTEGER;
      lkind: FILEKIND;
      lvid: VID;
      ltid: TitleID;
      liorslt : INTEGER;
      filename, newfname, UP_FILENAME: PathName;
      entryname : e_name;
      OSInfoRec: Fs_Info;  (* OS Info Record *)
      BytesWritten, actual: LONGINT;
      oserrnum, wiorslt, i, lFrecsize : INTEGER;
      access : Mset;
      ch : char;
      proc_info : procinfoRec;

(*$IFC MONITOR*)
  FUNCTION entertemp(VAR ftid: TitleID; fsegs: INTEGER;
                        fkind: FILEKIND; fdir: DIRP): DIRRANGE;
    (* find an entry of temporary file that is greater than the requested *)
    (* size in the directory.  If there is a free entry, return the entry *)
    (* number, else return 0.                                             *)
    VAR lasti: DIRRANGE;
        i, dinx, sinx : dirrang1;
        RT11ish: BOOLEAN;
        ssegs: INTEGER;
        lde: DIRENTRY;


    PROCEDURE FINDMAX(curinx: DIRRANGE; firstopen, nextused: INTEGER);
                           (* find the bigger size of the current free space
                              and the space between nextused and firstopen *)
      VAR freearea: INTEGER;

      BEGIN  (* FINDMAX *)
      freearea := nextused-firstopen;
      IF freearea > fsegs THEN        (* IF the free space is bigger than the
                                         the requested size *)
        BEGIN
        sinx := dinx;
        ssegs := fsegs;
        dinx := curinx;
        fsegs := freearea;  (* the requested size = free
                                space size *)
        END
      ELSE
        IF freearea > ssegs THEN      (* IF free space greater than the second
                                         largest one, update the second
                                         largest size *)
          BEGIN
          ssegs := freearea;
          sinx := curinx;
          END;
      END;   (* FINDMAX *)


    BEGIN  (* entertemp *)
    (*$IFC DEBUG*)
    IF trace (50) THEN
      WRITELN ('e entertemp: ');
    (*$ENDC*)
    dinx := 0;
    lasti := fdir^[0].DNUMFILES;
    sinx := 0;
    ssegs := 0;          (* second largest entry number and size *)
    IF fsegs <= 0 THEN             (* -1 = [*] specified in file name,
                                      0 = [0] or unspecified, get the largest *)
      BEGIN  (* Largest or Second Largest entry requested *)
      RT11ish := fsegs < 0;
      FOR i := 1 TO lasti DO
        FINDMAX(i,fdir^[i-1].DLASTBLK,fdir^[i].DFirstBlk);
      FINDMAX(lasti+1,fdir^[lasti].DLASTBLK,fdir^[0].DEOVBLK);
                                    (* find the largest free space and
                                       update fsegs, the requested size *)
      IF RT11ish THEN               (* [*] requested, get the larger size of
                                       the second largest and half of the
                                       largest free space *)
        IF fsegs DIV 2 <= ssegs THEN
          BEGIN
          fsegs := ssegs;
          dinx := sinx
          END
        ELSE
          fsegs := (fsegs+1) DIV 2
      END    (* Largest or Second Largest entry requested *)
    ELSE
      BEGIN  (* find a free space larger than requested *)
      i := 1;
      WHILE i <= lasti DO
        BEGIN  (* i <= lasti *)
        IF fdir^[i].DFirstBlk-fdir^[i-1].DLASTBLK >= fsegs THEN
          BEGIN
          dinx := i;
          i := lasti;
          END;
        i := i+1
        END;   (* i <= lasti *)
      IF dinx = 0 THEN
        IF fdir^[0].DEOVBLK-fdir^[lasti].DLASTBLK >= fsegs THEN
          dinx := lasti+1
      END;   (* find a free space larger than requested *)

    IF lasti = MAXDIR THEN
      dinx := 0;
    IF dinx > 0 THEN
      BEGIN  (* dinx > 0 *)
      WITH lde DO
        BEGIN  (* WITH lde *)
        DFirstBlk := fdir^[dinx-1].DLASTBLK;
        DLASTBLK := DFirstBlk+fsegs;
        DFkind := fkind;
        DTID := ftid;
        DLASTBYTE := FBlkSize;
        WITH DACCESS DO
          BEGIN  (* temporary entry*)
          MONTH := 0;
          DAY := 0;
          YEAR := 100
          END;   (* temporary entry*)
        END;   (* WITH lde *)
      INSENTRY(lde,dinx,fdir)        (* put the temp entry into directory *)
      END;   (* dinx > 0 *)
    entertemp := dinx;
    (*$IFC DEBUG*)
      IF trace (50) THEN
        WRITELN ('l entertemp: return ', dinx);
    (*$ENDC*)
    END;  (* entertemp *)
(*$ENDC*)

  BEGIN  (* %_Fopen *)

  (*$IFC DEBUG*)
    IF trace (50) THEN
      WRITELN ('e %_FOpen : f =', ORD (@f), ftitle, ' fopenold = ', fopenold);
  (*$ENDC*)
  filename := ftitle;   (* copy the name before any io, since it may be on other
                           code segment. *)
  (*$IFC MONITOR*)
  (* Check File Name to determine whether UCSD or OS file is to be opened *)
  IF UCSDFileName(ftitle) THEN
    BEGIN  (* ------------------------- UCSD File ----------------------- *)
    WITH f DO
      BEGIN  (* WITH f *)
      FIsOS := FALSE;  (* set FIB to indicate UCSD file *)
      IORslt := ORD(INoError);
      wiorslt := 0;
      IF LENGTH (ftitle) > namelen THEN
        IORslt := ORD(IBadTitle)
      ELSE
        IF FIsOpen THEN
          IORslt := ORD(INotClosed)
        ELSE
          IF SCANTITLE(ftitle,lvid,ltid,lsegs,lkind) THEN
                                 (* scan title and return volume name
                                    and file name, block # requested,
                                    and file kind in lkind *)

            BEGIN  (* Got an OK Title *)
            ldirp := @gdirectory;
            lunit := VOLSEARCH(lvid,TRUE,ldirp); (* ldirp might be zapped *)
                       (* search the volume name and return the unit #
                          and the directory in ldirp^, also lock the dir *)
            IF lunit = 0 THEN
              IORslt := ORD(INOUNIT)
            ELSE
              WITH UNITABLE[lunit] DO
                BEGIN  (*OK...OPEN UP FILE*)
                FIsOpen := TRUE;
                FModified := FALSE;
                FUnit := lunit;
                FVIDstuff.FVID := lvid;
                FNxtBlk := 0;
                FIsBlkd := UISBLKD;
                FSoftBuf := UISBLKD AND (FRecSize <> 0);
                                (* true only for block device and not
                                   untyped file *)
                IF (ldirp <> NIL) AND (LENGTH(ltid) > 0) THEN
                  BEGIN (*LOOKUP OR ENTER FHeader IN DIRECTORY*)
                  linx := DIRSEARCH(ltid,fopenold,ldirp);
                                (* search the directory for the file
                                   name and return the entry # *)
                  IF fopenold THEN     (* RESET call - existing file only *)
                    IF linx = 0 THEN
                      BEGIN
                      IORslt := ORD(INOFILE);
                      GOTO 1
                      END
                    ELSE
                      FHeader := ldirp^[linx]
                  ELSE              (* REWRITE call - OPEN NEW FILE or old*)
                   begin
                    IF linx > 0 THEN    (* REWRITE a temporary file *)
                      BEGIN
                      WIORslt := -ORD(IDUPFILE);  (* return warning and continue *)
                      WIORslt := 0;     (* temporarily fix this to return 0, so
                                           compiler, etc. will work without mods. *)
                      END
                    ELSE
                      BEGIN  (* REWRITE a PERM file *)
                      (* REWRITE a permanant - existing file
                         but MAKE A TEMP ENTRY - leave the
                         perm entry alone until CLOSE time *)
                      IF lkind = UNTYPEDFILE THEN
                        lkind := DATAFILE;
                      linx := entertemp(ltid,lsegs,lkind,ldirp);
                                (* create a temporary file entry *)
                      END;    (* REWRITE a PERM file *)
                    IF (linx > 0) AND (lkind = TEXTFILE) THEN
                      WITH ldirp^[linx] DO
                         BEGIN  (* WITH ldirp^[linx] *)
                           IF ODD(DLASTBLK-DFirstBlk) THEN
                             DLASTBLK := DLASTBLK-1;
                           IF DLASTBLK-DFirstBlk < 4 THEN
                             BEGIN
                             DELENTRY(linx,ldirp);
                             linx := 0
                             END
                         END;    (* WITH ldirp^[linx] *)

                    IF linx = 0 THEN
                      BEGIN
                        IORslt := ORD(INOROOM);
                        GOTO 1
                      END;
                    FHeader := ldirp^[linx];
                    FModified := TRUE;
                    WRITEDIR(lunit,ldirp)   (* update dir to disk *)
                   end;
                  END  (*LOOKUP OR ENTER FHeader IN DIRECTORY*)

                ELSE (* FHeader NOT IN DIRECTORY - ldirp=nil or LENGTH (ltid)=0 *)
                  BEGIN  (* Not in Directory *)

                  (*//////////////////////////////////////////////////////////*)
                  IF (ldirp = NIL) AND (LENGTH(ltid) <> 0) THEN
                    BEGIN  {Don't allow opens of files with no directory }
                    IORslt := ORD(INOFILE);
                    GOTO 1;
                    END;
                  { Back off on this restriction for now ... }
                  (*//////////////////////////////////////////////////////////*)

                  IF ldirp = NIL THEN     (* non-blocked device other than
                                               console not allowed in os *)
                    IF FUnit <> unitScConsole THEN    (* not console *)
                      BEGIN
                      IORslt := ORD(ibadunit);
                      GOTO 1;
                      END;
                  WITH FHeader DO
                    BEGIN  { WITH FHeader }
                    (*DIRECT UNIT OPEN - length (ltid)=0, SET UP DUMMY FHeader*)
                    DFirstBlk := 0;
                    DLASTBLK := MMAXINT;
                    IF UISBLKD THEN
                      DLASTBLK := UEOVBLK;
                    DFkind := lkind;
                    DTID := '';
                    DLASTBYTE := FBlkSize;
                    WITH DACCESS DO
                      BEGIN  (* WITH Daccess *)
                      MONTH := 0;
                      DAY := 0;
                      YEAR := 0
                      END;   (* WITH Daccess *)
                    END;   { WITH FHeader }
                  END;  (* Not in Directory *)
                IF fopenold THEN
                  FMaxBlk := FHeader.DLASTBLK-FHeader.DFirstBlk
                ELSE
                  FMaxBlk := 0;
                IF FSoftBuf THEN              (* for typed files *)
                  BEGIN  (* typed file *)
                  FNxtByte := FBlkSize;
                  FBufChngd := FALSE;
                  IF fopenold THEN
                    FMaxByte := FHeader.DLASTBYTE
                  ELSE
                    FMaxByte := FBlkSize;
                  WITH FHeader DO
                    IF DFkind = TEXTFILE THEN
                      BEGIN  (* text file *)
                      FNxtBlk := 2;
                      IF NOT fopenold THEN
                        BEGIN (*NEW .TEXT, PUT NULLS IN FIRST PAGE*)
                        FILLCHAR(FBuffer,SIZEOF(Fbuffer),CHR(0));
                        unitio (IORslt, FUnit,ORD (@FBuffer), 1,
                                DFirstBlk, actual, without_header, writeop);
                        unitio (IORslt, FUnit,ORD (@FBuffer), 1,
                                DFirstBlk+1, actual, without_header, writeop);
                        END;  (*NEW .TEXT, PUT NULLS IN FIRST PAGE*)
                      END;   (* text file *)
                  END;   (* typed file *)
                IF fopenold THEN
                  FReset(f)
                ELSE
                  Reseter(f); (*NO GET!*)
1:              unitable [lunit].lockdir := false;
                      (* unlock the dir may be locked by volsearch *)
                IF IORslt <> ORD (INoError) THEN
                  BEGIN
                  FIsOpen := FALSE;
                  FEOF := TRUE;
                  FEOLN := TRUE
                  END;
                if iorslt = 0 then iorslt := wiorslt;
              END;  (*OK...OPEN UP FILE*)
            END  (* Got an OK Title *)

      ELSE
         IORslt := ORD(IBadTitle); (* SCANTITLE = false *)

      END;   (* WITH f *)
    END    { ---------------------- UCSD File ------------------------- }

  ELSE
  (*$ENDC*)
    BEGIN  { ---------------------- OS File --------------------------- }

      IF F.FIsOpen THEN
        IORslt := INotClosed            {file already open}
      ELSE
       WITH F, FVIDstuff, Fheader DO
        BEGIN  {File not yet open}
        FIsOS := TRUE;
        IORslt := ORD (INoError);
        wiorslt := 0;                   {warning ioresult}

        { NOTE:  The OS file system allows ANY character  in a file name.}
        {        This makes it hard to say any file name is illegal!     }
        i := 1;                          {convert file name to upper case}
        UP_FILENAME := filename;
        WHILE i <= LENGTH(filename) DO
          BEGIN
          ch := filename[i];
          IF (ch >= 'a') AND (ch <= 'z') THEN
            UP_FILENAME[i] := CHR(ORD(ch)-ORD('a')+ORD('A'));
          i := i+1;
          END;

        FIsOpen := true;
        lFrecsize := FRecSize;
        if FRecSize = -1 then FRecSize := 1;

        IF (UP_FILENAME = 'CONSOLE:') or (UP_FILENAME = '-CONSOLE') THEN
          BEGIN                 {Psudo device '-CONSOLE', no need to do OS open}
            if FRecSize <> 1 then begin  iorslt := e_chardev;  goto 2;  end;
            if PConsWindow AND (PInWindow = 0) then FUnit := unitWiConsole
            else FUnit := unitScConsole;
            FTrefnum := consoleRefnum;
            Dfkind := TextFile;         {text file processing}
            goto 3;
          END
        ELSE
        if UP_FILENAME = '-KEYBOARD' then
          begin                 {Psudo device '-KEYBOARD', no need to do OS open}
            if FRecSize <> 1 then begin  iorslt := e_chardev;  goto 2;  end;
            if PConsWindow AND (PInWindow = 0) then FUnit := unitWiKeyboard
            else FUnit := unitScKeyboard;
            FTrefnum := consoleRefnum;
            Dfkind := TextFile;         {text file processing}
            goto 3;
          end
        else
        if UP_FILENAME = '-PRINTER' then
          begin
            if PConsWindow AND (PInWindow = 0) then
              begin
                FUnit := unitWiPrinter;
                iorslt := PasTerm.OpenPrinter;      {open the print document}
                goto 3;
              end;
            if PrintDevice = '' then
              begin
                iorslt := e_no_printer;
                goto 2;
              end;
            Funit := unitScPrinter;   {printer, it should be mounted before call}
            filename := concat (PrintDevice, '-A');
            access := [Dwrite];
            if @f = @outputfile then access := [Dwrite, Global_refnum];
          end
        else
          begin                 { others devices, not psudo devices - OS devices }
            FUnit := unitOSFile;
            FNewFile := NOT FOpenOld;
            access := [Dread, Dwrite];
              {Can not share typed file, but some lib files already opened by OS,
               so when linking with these lib files, linker will reset(open) them.
               Therefore can not open private here.}
            Hibyt4 := ord(xsorocA);
            IF (POS('-ALTCONSOLE',UP_FILENAME) <> 0) THEN
                   Hibyt4 := ord(alscreen);
            IF (POS('-MAINCONSOLE',UP_FILENAME) <> 0) THEN
                   Hibyt4 := ord(mainscreen);
          end;

        IF FNewFile THEN
          BEGIN  {REWRITE call - create and open a temporary new file}
          open (iorslt, filename, FTrefnum, [DRead, DWrite]);
                 {This is to use OS to save the file name for now, and save the
                    refnum in fib}
                 (* Later on should save the file name in fib when it is expanded*)
          if iorslt = 948 then
            begin
              DOrefnum := -1;            {no org. file, ok}
              newfname := filename;      {use org. file name to create file}
            end
          else if iorslt > 0 then
                 begin
                   maptoUCSD (iorslt);
                   goto 2;
                 end
               else
                 begin
                   info (iorslt, FTrefnum, osinforec);
                   if iorslt > 0 then goto 2;
                   newfname := concat (osinforec.dir_path, '-', RewriteFname);
                   DOrefnum := FTrefnum;
                   with osinforec do
                     IF (otype = object_t) AND (lpsize = 0) THEN
                       BEGIN
                         FNewFile := false;
                         goto 4;
                       END;
                 end;

          make_file (iorslt, newfname, 0);  {create the new file}
          IF iorslt > 0 THEN
            begin
              {$IFC MONITOR}
              if iorslt = 891 then            {catalog is full}
                iorslt := ord (inoroom)
              else
              if iorslt = 890 then      {some one else is in this window, wait}
                iorslt := ord (idupfile)
              else
                MapToUCSD(iorslt);
              {$ENDC}
              goto 2;
            end;

          if @F = @outputfile then  {output file open should use global refnum}
            access := [Dread, Dwrite, Private, Global_refnum]
          else access := [Dread, Dwrite, Private];
                                    {no other access allowed to temp file}
          open (iorslt, newfname, FTrefnum, access);
          kill_object (oserrnum, newfname);  {kill it now, unkill it in close}
          if (iorslt > 0) or (oserrnum > 0) then
            BEGIN
              if iorslt <= 0 then iorslt := oserrnum;
              MapToUCSD(iorslt);
              GOTO 2;
            END;
          END    {REWRITE call - create and open a temporary new file}

        ELSE
          BEGIN  {RESET call - open an existing file}
            if @F = @inputfile then  {exec file open should use global refnum}
              access := [Dread, Dwrite, Global_refnum];
            open (iorslt, filename, FTrefnum, access);
            IF iorslt > 0 THEN
              BEGIN
                MapToUCSD(iorslt);
                GOTO 2;
              END;
            DOrefnum := FTrefnum;
          END;   {RESET call - open an existing file}

                                        {os file is now [created and] opened}
4:      info (iorslt, FTrefnum, OSInfoRec);
        IF iorslt > 0 THEN goto 2;
        with OSInfoRec do
          BEGIN  {with OSInfoRec}
          FIsBlkd := lpsize <> 0;
          if (not FIsBlkd) AND (FRecSize > 1) then {not byte sized or file type}
            begin
              iorslt := e_chardev;
              goto 2;
            end;
          FSoftBuf := FIsBlkd AND (FRecSize <> 0);  {block device and typed file}
          Dfkind := DATAFILE;
          DFirstBlk := 0;                           {alwasys 0 for OS files}
          DLastBlk := size div Fblksize + 1;
          DLastByte := size - ord4 (DLastBlk-1)*Fblksize;
          IF DLastByte = 0 THEN
            BEGIN
              DLastBlk := DLastBlk - 1;
              DLastByte := Fblksize;
            END;
          IF fopenold THEN   {RESET}
            FMaxBlk := DLASTBLK-DFirstBlk
          ELSE               {REWRITE}
            FMaxBlk := 0;

          IF FSoftBuf THEN               {typed file}
            BEGIN
            FNxtByte := FBlkSize;
            FBufChngd := FALSE;
            IF fopenold THEN
              FMaxByte := DLASTBYTE
            ELSE
              FMaxByte := FBlkSize;

            {if (POS('.TEXT', UP_FILENAME) > 0) then}
            if lFrecsize = -1 then      {text type}
              BEGIN
              Dfkind := Textfile;
              FNxtBlk := 2;
              IF FNewFile THEN
                BEGIN  {Rewrite TEXT file;  Write 2 header blocks of null}
                FILLCHAR(FBuffer,SIZEOF(Fbuffer),CHR(0));
                Write_Data(iorslt, FTRefNum, ord (@FBuffer), Fblksize,
                           actual, Sequential, 0);
                IF (iorslt <= 0) and (actual = Fblksize) THEN
                  Write_Data(iorslt, FTRefNum, ord (@FBuffer), Fblksize,
                             actual, Sequential, 0);
                IF (iorslt > 0) or (actual <> Fblksize) THEN
                  BEGIN  {Failed to write both header blocks}
                    {$IFC MONITOR}
                    if iorslt <= 0 then iorslt := ord (Inoroom);
                    MapToUCSD(iorslt);
                    {$ENDC}
                    GOTO 2;
                  END;   {Failed to write both header blocks}
                END   {Rewrite TEXT file;  Write 2 header blocks of null}
              else   {Reset text file}
                if (user_type <> FType_textfile) AND (pos ('.TEXT', UP_FILENAME) = 0)
                then wiorslt := w_opendata;
              END    {text type}
            else                                {not text type}
              if FOpenOld AND
                 ((user_type = FType_textfile) or (pos ('.TEXT', UP_FILENAME) > 0))
              then wiorslt := w_opentext;  {Reset text file with typed file type}
            END;   {typed file}
          END;   {with OSInfoRec}

3:      IF FOpenOld THEN
          FReset(f)
        ELSE
          begin
            Reseter(f);         {without GET}
            FEOF := TRUE;
            FEOLN := TRUE
          end;

2:      IF (IORslt > ORD (INoError)) AND (@f <> @inputfile) AND (@F <> @outputfile)
        THEN WITH f DO
            BEGIN
            if FTrefnum <> -1 then
              close_object (oserrnum, FTrefnum);
            if (DOrefnum <> -1) and (DOrefnum <> FTrefnum) then
              close_object (OSErrnum, DOrefnum);
            FIsOpen := FALSE;
            FEOF := TRUE;
            FEOLN := TRUE
            END;
        if iorslt = 0 then iorslt := wiorslt;
        END;   {File not yet open}
    END;   { ---------- OS File ---------- }

  (*$IFC DEBUG*)
  IF trace (50) THEN
    BEGIN
    liorslt := IORslt;    {since the write of trace message will reset IORslt}
    WRITELN ('l %_FOpen : IORslt = ', IORslt);
    IORslt := liorslt;
    END;
  (*$ENDC*)

  END;   {%_Fopen}


(* %_FClose -------------------------------------------------------------------- *)
PROCEDURE %_FCLOSE(* VAR F: FIB; FTYPE: integer *);

  (* Closes the file identified by the FIB provided.  Disposition of the file is *)
  (* specified by the  FTYPE  parameter, and may be one of [CNormal, CLockF,     *)
  (* CPurge, CCrunch].  Exceptional conditions are signalled by setting IORESULT.*)

  (*$IFC MONITOR*)
  LABEL 1, 2;
  (*$ELSEC*)
  LABEL 2;
  (*$ENDC*)
  VAR linx, DUPINX: DIRRANG1;
      ldirp: DIRP;
      FOUND: BOOLEAN;
      lunit : unitnum;
      liorslt : INTEGER;
      i, refnum, blockno: INTEGER;
      actual : longint;
      filename, tempfname : pathname;
      entryname : e_name;
      file_info : fs_info;

  BEGIN  (* %_FCLOSE *)
  (*$IFC DEBUG*)
    IF trace (50) THEN
      WRITELN ('e %_FCLOSE: f =', ORD (@f), ' FTYPE = ', ORD(FTYPE));
  (*$ENDC*)

  WITH f DO
    BEGIN  (* WITH f *)
    (*$IFC MONITOR*)
    IF NOT FIsOS THEN
      BEGIN  (* --------------------- UCSD FILE --------------------- *)
      IORslt := ORD(INoError);
      IF FIsOpen THEN
        BEGIN  (* File is open *)
        IF FIsBlkd THEN
          WITH FHeader DO
            IF LENGTH(DTID) > 0 THEN
              BEGIN  (*FILE IN A DISK DIRECTORY...FIXUP MAYBE*)
              IF FTYPE = ord (CCrunch) THEN
                BEGIN  (* Crunch the file and remove unused space *)
                FMaxBlk := FNxtBlk;
                DACCESS.YEAR := 100;
                FTYPE :=  ord (CLock);
                IF FSoftBuf THEN
                  FMaxByte := FNxtByte
                END;   (* Crunch the file and remove unused space *)
              Reseter(f);
              IF FModified OR (DACCESS.YEAR = 100) OR (FTYPE = ord (CPurge)) THEN
                 BEGIN  (*HAVE TO CHANGE DIRECTORY ENTRY*)
                 ldirp := @gdirectory;
                                           (* need to get the current time IF it
                                              has not been read in from #5 *)
                 IF thedate.year = 0 THEN  (* just initialized *)
                   IF fetchdir (sysunit, ldirp, IORslt) THEN
                     thedate := ldirp^[0].dlastboot
                   ELSE
                     begin
                       if iorslt = 0 then iorslt := e_bigdir;
                       GOTO 1;               (* IORslt has been set in fetchdir *)
                     end;
                 lunit := VOLSEARCH(FVIDstuff.FVID,FALSE,ldirp);
                 IF FUnit <> lunit THEN
                   BEGIN  (* unit no longer on line *)
                   IORslt := ORD(ILOSTUNIT);
                   unitable [lunit].lockdir := false;
                   GOTO 1;
                   END;   (* unit no longer on line *)
                 linx := 1;
                 FOUND := FALSE;
                 WHILE (linx <= ldirp^[0].DNUMFILES) AND NOT FOUND DO
                   BEGIN (*LOOK FOR FIRST BLOCK MATCH*)
                   FOUND := (ldirp^[linx].DFirstBlk = DFirstBlk) AND
                            (ldirp^[linx].DLASTBLK = DLASTBLK);
                   linx := linx + 1;
                   END;  (*LOOK FOR FIRST BLOCK MATCH*)
                 IF NOT FOUND THEN
                   BEGIN
                   IORslt := ORD(ILOSTFILE);
                   unitable [lunit].lockdir := false;
                   GOTO 1;
                   END;
                 linx := linx - 1; (*CORRECT OVERRUN*)
                 IF ((FTYPE = ord (CNormal)) AND
                     (ldirp^[linx].DACCESS.YEAR = 100)) OR
                                         (* temp file created at REWRITE *)
                     (FTYPE = ord (CPurge)) THEN
                   DELENTRY(linx,ldirp)  (*ZAP FILE OUT OF EXISTENCE*)
                 ELSE
                   BEGIN  (*WELL...LOCK IN A PERM DIR ENTRY*)
                   DUPINX := DIRSEARCH(DTID,TRUE,ldirp);
                   IF (DUPINX <> 0) AND (DUPINX <> linx) THEN
                     BEGIN  (*A DUPLICATE PERM ENTRY...ZAP OLD ONE*)
                     DELENTRY(DUPINX,ldirp);
                     IF DUPINX < linx THEN
                       linx := linx-1;  (* due to DELENTRY call *)
                     END;   (*A DUPLICATE PERM ENTRY...ZAP OLD ONE*)
                   IF ldirp^[linx].DACCESS.YEAR = 100 THEN
                     IF DACCESS.YEAR = 100 THEN    (* in FHeader *)
                       DACCESS := THEDATE
                     ELSE (*LEAVE ALONE...FILER SPECIAL CASE*)
                   ELSE
                     IF FModified { AND (THEDATE.MONTH <> 0) } THEN
                       DACCESS := THEDATE
                     ELSE
                       DACCESS := ldirp^[linx].DACCESS;
                   DLASTBLK := DFirstBlk+FMaxBlk;
                   IF FSoftBuf THEN
                     DLASTBYTE := FMaxByte;
                   FHeader.FILLER1 := 0;  {This had better work, Steve}
                   FModified := FALSE;
                   ldirp^[linx] := FHeader
                   END; (*WELL...LOCK IN A PERM DIR ENTRY*)
                 WRITEDIR(FUnit,ldirp);
                 unitable [FUnit].lockdir := false; (* done with dir, unlock it *)
                 END;   (*HAVE TO CHANGE DIRECTORY ENTRY*)
              END;   (*FILE IN A DISK DIRECTORY...FIXUP MAYBE*)
        IF FTYPE = ord (CPurge) THEN
          IF LENGTH(FHeader.DTID) = 0 THEN    (* direct unit open, no file name *)
            UNITABLE[FUnit].UVID := '';       (* unit will go off line *)
  1:    FEOF := TRUE;
        FEOLN := TRUE;
        FIsOpen := FALSE
        END;   (* File is open *)
      END  (* --------------------- UCSD FILE --------------------- *)

    ELSE
    (*$ENDC*)
    with FVIDstuff do
      BEGIN  (* --------------------- OS FILE --------------------- *)
      IORSLT := ORD(INOERROR);
      if (not FisOpen) or (funit < unitScPrinter) or (HiByt3 <> openpattern) then
        goto 2;              {not open or console or keyboard device}
      if funit = unitWiPrinter then
        begin
          iorslt := PasTerm.ClosePrinter;         {close the print document}
          goto 2;
        end;

      with Fheader do  {is open and not console nor keyboard device}
        BEGIN
          IF FIsBlkd THEN
            begin
              blockno := FNxtblk;       {in case Reseter destroyed it}
              IF (ftype = ord (CLOCK) ) AND (DFKind <> Textfile) THEN   {SEEKBUG FIX}
                            {in case seek back, we want to write out max byte}
                IF (FNxtblk = FMaxblk) AND (FNxtbyte < FMaxbyte) THEN
                  FNxtbyte := FMaxbyte;
              RESETER(F);       {make text file end on even blocks}
              if DOrefnum = -1 then refnum := FTrefnum   {no org. file}
              else refnum := DOrefnum;
              info (iorslt, refnum, file_info);      {get the org.file name}
              if iorslt > 0 then goto 2;
              with file_info do
                filename := concat (dir_path, '-', name);

              if (FTYPE = ord (CCRUNCH)) or (FTYPE = ord (CLOCK)) then
                BEGIN
                  if ftype = ord (ccrunch) then
                    begin
                      if (DFKind = Textfile) and (not Fnewfile) and (odd (blockno))
                      then { reset text file, should end on even # blocks}
                        begin
                          FILLCHAR(FBuffer,FBlkSize,CHR(0));
                          write_data (iorslt, FTrefnum, ord (@FBuffer), Fblksize,
                              actual, absolute, ord4 (blockno)*Fblksize);
                          if iorslt > 0 then goto 2;
                        end;
                      truncate (iorslt, FTrefnum); {locks eof to last access}
                      if iorslt > 0 then goto 2;
                      compact (iorslt, FTrefnum);  {remove unused disk space}
                      if iorslt > 0 then goto 2;
                    end;
                  if Fnewfile then   {REWRITE}
                    begin
                      if DOrefnum <> -1 then  {delete the original if one exists}
                        kill_object (iorslt, filename);
                      if (iorslt <= 0) then
                        unkill_file (iorslt, FTrefnum, file_info.name);
                                {unkill the temp file to original file name}
                      if Dfkind = Textfile then
                        begin
                          file_info.user_type := FType_textfile;
                          Set_File_info (liorslt, FTrefnum, file_info);{3.2, YC, 2/28/83}
                        end;
                    end;  {REWRITE}
                END
              else
              if FTYPE = ord (cpurge) then
                begin   {if rewrite, temp file already killed in open}
                  if not Fnewfile then    {RESET}
                    kill_object (iorslt, filename); {delete the original one}
                end;
              {if normal and rewrite, temp file already killed in open}
            end;  {if Fisblkd}

          if iorslt > 0 then
            begin
              MapToUCSD (iorslt);
              goto 2;
            end;
          if DOrefnum <> -1 then
            begin               {close original file if one exists}
              close_object (iorslt, DOrefnum);
              if iorslt > 0 then begin MaptoUCSD (iorslt); goto 2; end;
            end;
          if DOrefnum <> FTrefnum then
            close_object (iorslt, FTrefnum);
          if iorslt > 0 then MapToUCSD (iorslt);
        END;   (* File is open and not console not keyboard device *)

2:    FEOF := TRUE;
      FEOLN := TRUE;
      FIsOpen := FALSE;
      HiByt3 := closepattern;
      END;   (* --------------------- OS FILE --------------------- *)
      (*$IFC DEBUG*)
      IF trace (50) THEN
        begin
        liorslt := IORslt;      (* since the trace message will reset IORslt *)
        WRITELN ('l %_FCLOSE: IORslt = ', IORslt);
        IORslt := liorslt;
        end;
      (*$ENDC*)
    END;  {WITH f}

  END;   {%_FCLOSE}


(* ExecReset  (19-Jun-82) --------------------------------------------------- *)
PROCEDURE ExecReset (* VAR errnum : INTEGER; VAR execfile : pathname;
                       stopexec : BOOLEAN *);

    (* open the exec file passed, use shared variables for FIB and, *)
    (* read the first char, and read ahead one char, and reset the execflag *)
    (* called by the command interpreter only.                              *)
        {Note that this open of exec file does not affect QuickPort program's INPUT
         fib and read at all. We have to change fib if we need to make that work.}
  LABEL 1;
  VAR
    charin : CHAR;

  BEGIN  (* ExecReset *)
    errnum := 0;
    gexecflag := false;
    IF NOT stopexec THEN
      BEGIN  (* do actual open exec file *)
      %_Fclose (inputfile, ord (Cnormal));        (* close the input *)
      %_FInit (inputfile, @inputfwindow, -2);
                                (* reset (inputfile) - to exec text file *)
      %_Fopen (inputfile, execfile, true, 0);
      errnum := iorslt;
      IF errnum > 0 THEN                (* error from reset exec file *)
        begin
          resetinput;                   (* reset input to console *)
          GOTO 1;
        end;

      gfirstchar := %_ReadChar (inputfile);   (* read and save the first char,
                                                this char will be bypassed *)
      errnum := iorslt;
      IF (errnum > 0) or (inputfile.feof) THEN
        BEGIN  {read error}
        resetinput;
        IF errnum = 0 THEN
          errnum := e_execreset;
        GOTO 1;
        END;   {read error}

      charin := ExecRead (errnum, true);   {read ahead one char into greadahead}
      IF (errnum <= 0) AND (inputfile.funit <> unitScConsole) THEN
        gexecflag := TRUE;     {this can not be set if exec file is closed}
    END   {do actual open exec file}
    else
      resetinput;
1:
  END;  (* ExecReset *)


(* ExecFlag  (19-Jun-82) --------------------------------------------------- *)
FUNCTION ExecFlag (* : BOOLEAN *);

  BEGIN (* ExecFlag *)
    execflag := gexecflag;              (* return execflag *)
  END;  (* ExecFlag *)



PROCEDURE OutputRedirect (* VAR errnum : INTEGER; VAR outfile : pathname;
                            stopoutput : BOOLEAN *);   (* open/stop output file *)
                {This would redirect QuickPort program's output also, since we
                 still use the outputfile for OUTPUT of every program.}
  label 1;
  begin
    errnum := 0;
    goutputrflag := FALSE;
    IF NOT stopoutput THEN
      BEGIN     {do actual open output file}
      %_Fclose (outputfile, ord (Clock));               {close the output}
      %_FInit (outputfile, @outputfwindow, -2);
                                (* rewrite (outputfile) - to output text file *)
      %_Fopen (outputfile, outfile, false, 0);
      errnum := iorslt;
      IF errnum > 0 THEN                {error from reset output file}
        begin
          resetoutput;                  {reset output to console}
          GOTO 1;
        end;
      IF outputfile.funit <> unitScConsole THEN
        goutputrflag := TRUE;     {this can not be set if redirect back to console}
      END       {do actual open output file}
    else
      resetoutput;
1:
  end;  (* outputRedirect *)


FUNCTION OutputRFlag (* : BOOLEAN *);   (* return true if output is redirected *)
  begin
    OutputRFlag := goutputrflag;
  end;  (* OutputRFlag *)

ÿ