PROGRAM InstallShell;  { 27-Dec-83 } { Copyright 1983, 1984 Apple Computer Inc. }

{ This program is an OS system.shell (i.e. it runs automatically on booting) for the
  Lisa Office System Master Diskette(s).  It is used to initialize an Office System
  startup disk, repair it (scavenge), restore it and/or install system software on it.
  This code modified from the original OfficeMaster program which ran with the dual twiggies.
  Now re-written to fit in 800 blocks (400KBytes) on a sony (micro) diskette.
                                                     Ken Krugler 9/15/83 }

{ *** List-O-Minus-O-Minus-O-Things to do *** }
{ Verify the archive streaming tape restore works }
{ Test in 1/2 meg machine }
{ Test split file restoration }
{ Check on file date compare operation }

{ *** Code change log *** }
{ First working version : 9/15/83 }
{ Pepsi re-segmentation changes, pepcall stuff : 10/18/83 }
{ Cleaned up alert messages, verified numbering, removed tool copy stuff from install : 10/19/83 }
{ Install loads system files from Office System 1 diskette  : 10/20/83 }
{ Removed Pepcalls (in OS now), new TPort names for sony & internal disk : 10/25/83 }
{ Finished clean up, removed debugging code : 10/26/83 }
{ Added support for both Lisa 1.0 and Pepsi : 10/28/83 }
{ Install correct verification of diskette volume names : 10/31/83 }
{ CopyAllDiskFile works with Restore : 11/1/83 }
{ Install ejects bad diskettes : 11/3/83 }
{ Main loop always attempts remount, handles new disk correctly, mount error =
  (no disk) works w/Pepsi, Install does write of boot tracks at end of process : 11/3/83 }
{ Fixed writing boot tracks : 11/6/83 }
{ Added support for LisaLite : 12/6/83 }
{ New mount error 663, also Widget time-out fix : 12/8/83 }
{ Groups all unknown mount errors together, adds mount error 625 : 12/27/83 }
{ Returns the unknown startup-disk mount error with alert 150 : 1/3/84 - Happy New Year!! }
{ RELEASED AS 2.0 (final!) TO DUPLICATION - GOLDEN MASTERS : 1/7/84 }
{ Now conditional compilation flags for various workshop options : 1/9/84 }
{ Code for configurable drivers, also disk in any location : 1/30/84 }
{ Added Priam archive support : 2/16/84 }
{ Reworked main loop logic, major config device changes : 2/27/84 }
{ Cleanup for first release to documentation, NPR : 3/1/84 }
{ Cleanup for user abort in CopyDiskFile, removed global err value, REV 3.3 to Doc. & NPR : 3/2/84 }
{ Logic fix in Install w/Bad or New disk (thanks, Bruce), also Repair of disk, REV 3.4 : 3/5/84 }
{ First pass at changes for altering parameter memory record on-the-fly : 3/16/84 }
{ Copies system files for OS1 again, also IOSPASLIB.OBJ : 3/25/84 }
{ Fixed Dismount DLE, cleaned up CopyAllDiskFiles, etc. REV 3.5 : 3/27/84 }
{ Dismount of disk during disk selection (for 1/2 meg. operation) : 3/28/84 }
{ Conditional compilation for locking PasIOLib segment (1/2 meg fix) : 3/28/84 }
{ Fixed Quit system.shell check problem, also Cards_Equipped DLE : 3/28/84 }
{ Cleaned up Restore (DLE), also InitNewDisk : 3/29/84 }
{ CopyDiskFile error handling, CheckPMList zeroing of extwords in cd_config record : 4/2/84 }
{ Restore abort DLE : 4/10/84 }
{ Wrong diskette eject sequence changed, as per Amy's nit : 4/10/84 }
{ CheckPMList DLE, also clean-up of card driver location handling  REV 3.6 : 4/12/84 }
{ CDKill for internal disk : 4/13/84 }
{ Restart from correct disk position : 4/14/84 }
{ Added support for partitioned disk (MacWorks) in InitNewDisk : 4/18/84 }
{ Added new disk-mount error values in MountDisk/MountInit : 4/18/84 }
{ If no disk found & Pepsi (widget), new alert (per Amy nit) : 4/18/84 }
{ Bumped cdd_version number, changed cd_priam -> cd_priam disk : 4/22/84 }
{ Put system.cd_xx file names in Phrase file, modified devList[] algorithm, removed cdd_version
  number and # of cdd entries checks, moved up MatchDrvrXX code REV 3.7 : 4/26/84 }
{ More changes to InitNewDisk for MacWorks partitioned volumes : 4/30/84 }
{ Fixed GetDiskSize/InitNewDisk problem (5 buttons in AskAlert is no-no) REV 3.8 : 5/1/84 }
{ First pass at new restore code for split files, etc : 5/6/84 }
{ Second pass at new Restore code, minor cleanup, selecting partitioning : 5/9/84 }
{ Third pass at new Restore code -- changes to Copy(All)DiskFile(s) per Frank's walk-through,
  password handling, also alert changes in body of RestProfile procedure REV 3.9 : 5/10/84 }
{ Fixed the mysterious disappearing refNum, also Office vs. Workshop comp. cleanup REV 3.10 : 5/18/84 }
{ Multiple restore DLE's, REV 3.11 : 5/23/84 }
{ Re-mounts disk in Quit before checking for 'system.shell' : 5/24/84 }

USES {$U libhw/HwInt         }  HwInt,
     {$U libos/SysCall       }  SysCall,
     {$U libos/PSysCall      }  PSysCall,
     {$U libsm/UnitStd       }  UnitStd,
     {$U libsm/UnitHz        }  UnitHz,
     {$U libqd/Storage       }  Storage,
     {$U libqd/QuickDraw     }  QuickDraw,
     {$U libfm/FontMgr       }  FontMgr,
     {$U libwm/events        }  Events,
     {$U libwm/windows       }  Windows,
     {$U libwm/folders       }  Folders,
     {$U libwm/menus         }  Menus,          { do I really need this? }
     {$U libsb/wmlStd        }  WmlStd,
     {$U libsb/wmlCrs        }  WmlCrs,
     {$U libam/alertmgr      }  AlertMgr,
     {$U libfc/Sys1lock      }  Sys1lock,
     {$U libpm/PMDecl        }  PMDecl,
     {$U libpm/PMM           }  PMM;

{The following compiler directives set up constants to be either TRUE or FALSE in the CONST
 declaration section.  Not all the flags can be true at one time, due to program size constraints
 (won't fit on a Sony with every debugging WRITELN string in the object file).  Use XDebug (which
 sets dbgX = TRUE) to selectively test the current 'Hot Problem'.  Happy Hunting}

{$SETC OfficeDebug := FALSE }             { Set to TRUE for generalized debugging software }
{$SETC ConfigDebug := FALSE }             { Set to TRUE for debug of config device code }
{$SETC InitDebug   := FALSE }             { Set to TRUE for debug of initialization code }
{$SETC CopyDebug   := FALSE }             { Set to TRUE for debug of copy code }
{$SETC RestoreDebug:= FALSE }             { Set to TRUE for debug of restoration code }
{$SETC XDebug      := FALSE }             { Set to TRUE for debug of special sections }
{$SETC DebugOn     := FALSE }             { MUST be true if any preceeding debugging flag is TRUE }

{The following conditional compilation flags control what kind of Install program to make.}

{$SETC ForSony    := TRUE }               { FALSE => making on Twiggies }
{$SETC ForOffice  := TRUE }               { FALSE => must be doing Workshop Install }

{One of the following flags must be set TRUE if ForOffice = FALSE, else all MUST be FALSE}

{$SETC ForWorkshop := FALSE }
{$SETC ForPascal  := FALSE }
{$SETC ForCobol   := FALSE }
{$SETC ForBasic   := FALSE }

{$IFC OfficeDebug }
   {$D+}
{$ELSEC }
   {$D-}
{$ENDC }

{$IFC OfficeDebug }
   {$R+}
{$ELSEC }
   {$R-}
{$ENDC }


CONST

{set up trace/debug flags}

{$IFC OfficeDebug }
   dbgInstall   = TRUE;
{$ELSEC }
   dbgInstall   = FALSE;
{$ENDC }

{$IFC ConfigDebug }
   dbgConfig   = TRUE;
{$ELSEC }
   dbgConfig   = FALSE;
{$ENDC}

{$IFC InitDebug }
   dbgInit   = TRUE;
{$ELSEC }
   dbgInit   = FALSE;
{$ENDC}

{$IFC RestoreDebug }
   dbgRestore = TRUE;
{$ELSEC }
   dbgRestore = FALSE;
{$ENDC}

{$IFC CopyDebug }
   dbgCopy   = TRUE;
{$ELSEC }
   dbgCopy   = FALSE;
{$ENDC}

{$IFC XDebug }
   dbgX     = TRUE;
{$ELSEC }
   dbgX     = FALSE;
{$ENDC}

   { errors in initializing a disk }

   fNotInit    = 1;             { Disk not initialized     }
   fNotMounted = 3;             { Disk not mounted         }
   fBootNotMounted = 4;         { Boot diskette not remounted }

   { errors returned by CopyDiskFile/CopyAllDiskFiles Procedure, error codes in libfc/FilerComm Unit  }

   fceNoErrors =          0;   { All OK                                      }
   fceAborted =        4033;   { User type 'apple .'                         }
   fceBadEventType =   4025;   { Event type must be docOpen/Close/Copy/Terminate}
   fceBadReason =      4026;   { FReason does not match FReply               }
   fceCantRead =       4027;   { Cannot read from the source document        }
   fceCantWrite =      4028;   { Cannot write to the destination document    }
   fceInUse =          4029;   { File opened privately or being written to   }
   fceNoMemory =       4030;   { Insufficient space for IO buffer            }
   fceOutOfDiskSpace = 4031;   { Insufficient space on distination volume    }
   fceBadLDSN =        4032;   { OS error attempting to use the LDSN provided}

   { process termination codes from shell to OS }

   RestartThisShell  = 1;
   PowerOffMachine   = 4;
   RebootMachine     = 5;

   nullErr           = MAXINT;         { used w/SysErr to denote no low level error }
   nullInt2          = $8000;          { for label record (not split indicator) }
   incOffset         = 1000;           { backup diskette offset if diskette is incremental (vs. full) }

   {the following conditional compilation sections are for tailoring the program to each
    particular usage, ie. installing the Office System, Cobol, etc.  The first set of values
    are used to verify that the user is inserting the correct diskettes during an Install
    operation.  The diskette name is something like 'Office System n x.y', where n is the
    diskette number (1..5 for the Office System) and x.y is the version number (such as 3.7).
    The other constants are for number of diskettes, etc. }

{$IFC ForOffice}
   NamePos           = 01;                { Position of the name field in the volume name string }
   NumberPos         = 15;                { Position of the number field in the volume name string }
   VersionPos        = 17;                { Position of the version field in the volume name string }
   auxName           = 'Office System';   { Correct name field for each diskette volume name }
   {$IFC ForSony}
      MaxOsDisks     = 5;                 { Number of system software diskettes to load in install }
   {$ELSEC}
      MaxOsDisks     = 3;
   {$ENDC}
   catName           = '{!Catalog}';      { Filer catalog name }
   sCatName          = '{#Catalog}';      { Special name causes the Filer to redo catalog during boot }
   mNameAlerts       = 'Office';          { phrase file for the alerts = OfficePHRASE }
{$ENDC}

{$IFC ForPascal}
   NamePos           = 01;                { Position of the name field in the volume name string }
   NumberPos         = 08;                { Position of the number field in the volume name string }
   VersionPos        = 10;                { Position of the version field in the volume name string }
   auxName           = 'PASCAL';          { Correct name field for each diskette volume name }
   mNameAlerts       = 'Pascal';          { phrase file for the alerts = PascalPHRASE }
   {$IFC ForSony}
      MaxOsDisks     = 5;                 { Number of system software diskettes to load in install }
   {$ELSEC}
      MaxOsDisks     = 3;
   {$ENDC}
{$ENDC}

{$IFC ForBasic}
   NamePos           = 01;                { Position of the name field in the volume name string }
   NumberPos         = 07;                { Position of the number field in the volume name string }
   VersionPos        = 09;                { Position of the version field in the volume name string }
   auxName           = 'BASIC';           { Correct name field for each diskette volume name }
   mNameAlerts       = 'Basic';           { phrase file for the alerts = BasicPHRASE }
   {$IFC ForSony}
      MaxOsDisks     = 4;                 { Number of system software diskettes to load in install }
   {$ELSEC}
      MaxOsDisks     = 3;
   {$ENDC}
{$ENDC}

{$IFC ForCobol}
   NamePos           = 01;                { Position of the name field in the volume name string }
   NumberPos         = 07;                { Position of the number field in the volume name string }
   VersionPos        = 09;                { Position of the version field in the volume name string }
   auxName           = 'COBOL';           { Correct name field for each diskette volume name }
   mNameAlerts       = 'Cobol';           { phrase file for the alerts = CobolPHRASE }
   {$IFC ForSony}
      MaxOsDisks     = 4;                 { Number of system software diskettes to load in install }
   {$ELSEC}
      MaxOsDisks     = 3;
   {$ENDC}
{$ENDC}


   CRNotice          = 'copyright 1983, 1984 Apple Computer Co.';   {copyright protection}
   version           = '3.0';            { Correct version field, changes w/ each release }
   CacheSize         = 106;               { Number of alerts in <xxx>alert.text to lock down (all) }
   CacheBytes        = 21000;             { Size of heap potentially allocated for alert messages }

   {constants used to check the value returned by the Mach_Info call
    (the I/O board part of the record)}

   IOlisa            = 0;                 { Old I/O board (lisa) w/Twiggys }
   IOpepsi           = 1;                 { New I/O board (pepsi) w/Sonys and Widget }
   IOlisaLite        = 2;                 { Old I/O board (lisa) w/Sonys }
   IOpepsiLite       = 3;                 { New I/O board (pepsi) w/Sonys, no Widget }

   {constants used to index into DrvrList[]}

   ProfDloc          = 1;                 { Profile disk driver }
   PriamDloc         = 2;                 { Priam disk driver }
   ArchiveTloc       = 3;                 { Archive tape driver }
   TwoPortCloc       = 4;                 { 2 Port card driver }
   PriamCloc         = 5;                 { Priam card driver }

   NoCard            = -1;                { For devList[].cardDrvrPos if no card for disk }

   lisaGuide         = 'guide';           { In Fvolctrl Unit }
   heapSize          =  13000;            { Size of the heap set in Initialize }
   myStackSize       =  11000;            { Size of the stack set in Initialize }

   { Global boolean constants for calls to Dismount }

    ejectIt     = TRUE;                   { Should I eject it?}
    dontEject   = FALSE;
    bootDisk    = TRUE;                   { Is it the boot volume? }
    notBoot     = FALSE;

   { Miscellaneous globals }

   fMaxStrLen    = 63;
   maxDevices    = 8;                     { maximum number of devices that can be specified }
   LastDrvr      = 5;                     { total of five drivers on boot sony that are needed }
   maxConfigs    = 20;                    { max number of entries in parameter memory allowed }
   copyDsSize    = 10000;                 { Size of file copy buffer }
   copyDsDfName  = '{!CopyBufr}';         { file copy pathname - set in fdocctrl }
   minDsSize     = 512;                   { smallest data seg size allowed }
   dfCopyLDSN    = 6;                     { logical data segment number for the file copy buffer }

TYPE

   WhenFinished   = (reboot,              { boot from the profile                }
                     off,                 { turn the machine off                 }
                     restart);            { reboot and start this shell          }

   {The following type is returned by the call to MountInit, & indicated the condition of the init disk}
   TInitDisk   = (goodDisk,               { good disk was attached in the indicated location }
                  noDisk,                 { seems that no disk is attached }
                  newDisk,                { disk has a bad format, never initialized, etc. }
                  whatDisk,               { user didn't select a disk }
                  badDisk);               { unknown mount error with indicated disk }

   consoleDest = (altscr, mainscr);       { Console types for MoveConsole procedure }

   FmaxStr     = STRING[fMaxStrLen];      { Generic string type }
   NumberStr   = STRING[11];

   errTypes    = (fatalError,             { restart the install program }
                  askError,               { ask for restart option }
                  warnError);             { warning - error message only }

   {for calls to CopyDiskFile}

   TfileMode   = (MakeFileMode, AppendFileMode);

   TdiskType   = (profileDisk, priamDisk, widgetDisk);

   {this record specifies a disk that could be used for installation/repair/restoring}
   TdevEntry   = RECORD
                 position     : Cd_Position; { position of the disk, ie. slot = 1, chan = 2 }
                 devName      : E_Name;      { device name, ie. '#1#2' }
                 diskDrvrPos  : INTEGER;     { position in drvrList[] of disk driver }
                 cardDrvrPos  : INTEGER;     { position in drvrList[] of card driver (-1 if built-in) }
                 isDisk       : BOOLEAN;     { TRUE => successfully identified as a disk }
                 END;

   TdrvrEntry  = RECORD
                 infoBuf   : Cd_Infobuf;     { info record from system.cdd file }
                 name      : E_Name;         { name of driver file <system.cd_xxx> }
                 hasInfo   : BOOLEAN;        { found entry in system.cdd file }
                 hasFile   : BOOLEAN;        { found system.cd_xxx file on boot Sony }
                 END;

   TcopyMode   = (InstallMode, RestoreMode); { InstallMode => don't copy filer files, overwrite any existing
                                               files.  RestoreMode => copy all files, only overwrite an
                                               existing file if the copying file is the first in a
                                               sequence of split files }

VAR

   alertNum       : INTEGER;
   alertParam     : FmaxStr;       { For parameter to alert }
   alertRefnum    : INTEGER;       { In FGlobals }
   bootdevName    : E_Name;        { Device name of the boot port }
   bootPos        : CD_Position;   { Port (position) to boot from (should always be the mico disk) }
   bootUnmounted  : BOOLEAN;       { Is the boot volume unmounted? }
   bootvolName    : E_Name;        { Volume name of the boot disk }
   CopyDsAddr     : LongInt;       { In FDocCtrl }
   CopyDsMemSize  : LongInt;       { In FDocCtrl }
   CopyDsRefnum   : INTEGER;       { Data segment reference number }
   devList        : ARRAY [1..maxDevices] OF TdevEntry;       { all possible device locations }
   diskSet        : BOOLEAN;       { TRUE => initPos is valid, else hasn't been decided yet }
   diskString     : Str255;        { Argument for Main menu alert, location of disk }
   diskType       : TdiskType;     { What kind of disk does the user want to work with? Set in MountInit }
   drvrList       : ARRAY [1..LastDrvr] OF TdrvrEntry;      { from system.cd_xxx files on boot diskette }
   drvrsSet       : BOOLEAN;       { TRUE => drvrList, devList, lastDevEntry are set up }
   errNumber      : NumberStr;     { For display of error number in alert }
   initdevName    : E_Name;        { Device name of the initialization disk location }
   initPos        : CD_Position;   { Port name (position) of the initialization disk location }
   initvolName    : E_Name;        { Volume name returned from a mount of the initPos device }
   lastDevEntry   : INTEGER;       { highest index to devList[] }
   lastPmEntry    : INTEGER;       { highest index to pmList[] }
   machinetype    : MInfo;         { Type of machine software is running on }
   mountResult    : TInitDisk;     { Result from mounting the disk that is to be initialized }
   installAlert   : TAlertFile;
   myHeap         : ARRAY [0..heapSize] OF CHAR;
   password       : E_Name;        { Meaningless value for disk initialization }
   pmList         : ARRAY [1..maxConfigs] OF ConfigDev;      {array of configured devices}
   slots          : Slot_Array;    { card positions for disk location/verification }
   theEvent       : EventRecord;

   logo,
   copyRight,
   apple        : STRING[1];     { for Main Menu alert }

{ NOTE: Procedure and function interfaces and bodies should be listed alphabetically at all cost }

PROCEDURE BlockIOInit;                                                EXTERNAL;
PROCEDURE LockPasLib (var err: INTEGER);                              EXTERNAL;
PROCEDURE LockPasioLib (var err: INTEGER);                            EXTERNAL;
PROCEDURE MoveConsole (var err: INTEGER; scr: consoleDest);           EXTERNAL;

{ All procedures and funtions in this source have a range of error numbers to return to syserr().
  The main program loop has the errors 1-9, with each successor having an additional 10 error #s
  unique to it.  A list of syserr numbers and the corresponding location in the calling function
  can be found in doc:mastererrors.text }

{ Highest error number is 349 }

PROCEDURE CopyAllDiskFiles (VAR err: INTEGER; sDevPathname, dDevPathname: Pathname;
                           copyMode: TcopyMode);                      FORWARD;   { Syserr 10-19 }
PROCEDURE CopyDiskfile (VAR err: INTEGER; source, destination: Pathname; copyMode: TfileMode);
                                                                      FORWARD;   { Syserr 20-29 }
PROCEDURE CheckPMList (index: INTEGER);                               FORWARD;   { Syserr 310-319 }
FUNCTION  Dismount (devPort: CD_Position; eject, bootvol: BOOLEAN) : BOOLEAN;
                                                                      FORWARD;   { Syserr 30-39 }
PROCEDURE DisplayError (flrErr,err: INTEGER);                         FORWARD;   { Syserr 40-49 }
PROCEDURE DownShift (pStr: StringPtr);                                FORWARD;   { Syserr 50-59 }
PROCEDURE EjectDiskette;                                              FORWARD;   { Syserr 60-69 }
FUNCTION  ErrorFound (errKind: errTypes; flrErr,err: INTEGER) : BOOLEAN;
                                                                      FORWARD;   { Syserr 70-79 }
PROCEDURE FailedAlert;                                                FORWARD;   { Syserr 80-89 }
PROCEDURE Finished (lastAct: WhenFinished);                           FORWARD;   { Syserr 90-99 }
PROCEDURE GetString (alertNumber: INTEGER; pStr: TpStr255);           FORWARD;   { Syserr 100-109 }
FUNCTION  HeapOverflow (hz: THz; bytesNeeded: INTEGER) : INTEGER;     FORWARD;   { Syserr 110-119 }
PROCEDURE Initialize;                                                 FORWARD;   { Syserr 120-129 }
FUNCTION  InitNewDisk : BOOLEAN;                                      FORWARD;   { Syserr 130-139 }
PROCEDURE InitPMList;                                                 FORWARD;   { Syserr 300-309 }
PROCEDURE Install;                                                    FORWARD;   { Syserr 140-149 }
PROCEDURE IntToStr(number: LongInt; VAR str: NumberStr);              FORWARD;   { Syserr 150-159 }
PROCEDURE LastWishes(environPtr: P_env_blk; excepDataPtr: P_term_ex_data);
                                                                      FORWARD;   { Syserr 160-169 }
FUNCTION  LookForMasters (devName: E_Name) : BOOLEAN;                 FORWARD;   { Syserr 170-179 }
PROCEDURE MakeCopyDataSeg;                                            FORWARD;   { Syserr 180-189 }
PROCEDURE MakeDevName (thePos: CD_Position; VAR devName: E_Name);     FORWARD;   { Syserr 270-279 }
FUNCTION  MatchNameDrvr (driverName: E_Name; VAR theIndex: INTEGER) : BOOLEAN;
                                                                      FORWARD;   { Syserr 330-339 }
FUNCTION  MatchIDDrvr (theID: INTEGER; VAR theIndex: INTEGER) : BOOLEAN;
                                                                      FORWARD;   { Syserr 320-329 }
PROCEDURE MountBoot (VAR error: INTEGER; situation: str255);          FORWARD;   { Syserr 250-259 }
PROCEDURE MountInit (VAR result: TInitDisk);                          FORWARD;   { Syserr 260-269 }
PROCEDURE Quit;                                                       FORWARD;   { Syserr 190-199 }
FUNCTION  Repair : BOOLEAN;                                           FORWARD;   { Syserr 200-209 }
PROCEDURE Restore;                                                    FORWARD;   { Syserr 210-219 }
FUNCTION  RestPriam : BOOLEAN;                                        FORWARD;   { Syserr 280-289 }
FUNCTION  RestProfile : BOOLEAN;                                      FORWARD;   { Syserr 290-299 }
PROCEDURE SysErr (err: INTEGER; lowlevelerr: INTEGER);                FORWARD;   { Syserr 230-239 }
FUNCTION  UserAborted (VAR err: INTEGER) : BOOLEAN;                   FORWARD;   { Syserr 240-249 }
PROCEDURE ZapPassword (thePath: Pathname);                            FORWARD;   { Syserr 340-349 }
{$IFC ForOffice}
FUNCTION  SetCatName : BOOLEAN;                                       FORWARD;   { Syserr 220-229 }
{$ENDC}

{****************************************************************************}
PROCEDURE CopyAllDiskfiles {* VAR err: INTEGER; sDevPathname,dDevPathname: Pathname; copyMode: TcopyMode *};
{ Copy all the files from one volume to another }

LABEL 33;

VAR
   prefix,
   tempName,
   dfName      : E_Name;
   dDfInfo     : Fs_info;
   sDfPathname,
   dDfPathname : Pathname;
   keepGoing   : BOOLEAN;
   sDfInfo     : Fs_info;

   {----------------------------------------------------------------------------}
   PROCEDURE CheckErr (theError: INTEGER);

   BEGIN
   IF (theError > 0) THEN
      BEGIN
      err := theError;
      EXIT(CopyAllDiskFiles);
      END;
   END; {of PROC CheckErr}

   {----------------------------------------------------------------------------}
   FUNCTION IsNewer (VAR sourceInfo, destInfo: FS_Info) : BOOLEAN;
   {returns TRUE if the destination time is invalid or the source time is valid and
    source is newer than destination}

   VAR
      destTime    : LongInt;
      sourceTime  : LongInt;

   BEGIN
   IF (destInfo.DTM <> 0) THEN
      destTime := destInfo.DTM
   ELSE
      destTime := destInfo.DTC;
   IF (sourceInfo.DTM <> 0) THEN
      sourceTime := sourceInfo.DTM
   ELSE
      sourceTime := sourceInfo.DTC;
   {if destination doen't have a valid time, or source time is valid and newer, then TRUE
    Why does <greater-than> comparison work??? One of life's mysteries}
   IsNewer := (destTime = 0) OR ((sourceTime <> 0) AND (sourceTime > destTime));
   END; {of FUNC IsNewer}

   {----------------------------------------------------------------------------}
   PROCEDURE KillDupDocs (VAR theInfo: FS_Info; thePath: Pathname);
   {deletes all files on destination volume with same Filer prefix as thePath, unless
    age is a factor}

   LABEL 99;

   VAR
      beginPos : INTEGER;
      endPos   : INTEGER;
      fsInfo   : FS_Info;
      prefix   : E_Name;
      stillMore: BOOLEAN;
      tempName : E_Name;
      tempPath : Pathname;

   BEGIN
   IF dbgCopy THEN WRITELN('   [KillDupDocs], entry: test pathname = ',thePath);
   Reset_Catalog(err, dDevPathname);
   CheckErr(err);
   endPos := POS('}', thePath);
   beginPos := POS('{', thePath);
   IF ((endPos = 0) OR (beginPos = 0)) THEN
      EXIT(KillDupDocs);
   prefix := COPY(thePath, beginPos, endPos-beginPos+1);
   IF dbgX THEN WRITELN('   prefix for doc kill is ',prefix);
   stillMore := TRUE;
   WHILE stillMore DO
      BEGIN
      Get_Next_Entry(err, prefix, tempName);
      IF (err = 848) THEN
         BEGIN
         stillMore := FALSE;
         GOTO 99;
         END
      ELSE
         CheckErr(err);
      tempPath := CONCAT(dDevPathname,'-',tempName);
      LookUp(err, tempPath, fsInfo);
      IF dbgX THEN WRITELN('   Found duplicate file ',tempPath,', error = ',err:1);
      IF IsNewer(theInfo, fsInfo) THEN
         BEGIN
         ZapPassword(tempPath);
         Kill_Object(err, tempPath);
         END;
   99:
      END; {of WHILE block}

   {now reset the position of the 'Next Entry' pointer on the Sony}
   Reset_Catalog(err, sDevPathname);
   stillMore := TRUE;
   {set prefix to the filename that caused the duplication problem, so that next call to
    Get_Next_Entry in the main loop will be set to the correct position}
   prefix := COPY(thePath, beginPos, Length(thePath)-beginPos+1);
   Get_Next_Entry(err, prefix, tempName);

   END; {of PROC KillDocs}

   {----------------------------------------------------------------------------}

BEGIN
IF dbgCopy THEN
   BEGIN
   WRITELN ('[CopyAllDiskfiles], entry: source disk is ',sDevPathname);
   WRITELN ('   Destination disk is ',dDevPathname);
   END;

Reset_Catalog(err, sDevPathname);
CheckErr(err);
prefix := '';
keepGoing := TRUE;

WHILE keepGoing DO
   BEGIN
   prefix := '';
   Get_Next_Entry(err, prefix, dfName);
   IF (err = 848) THEN
      BEGIN
      keepGoing := FALSE;
      err := 0;
      GOTO 33;
      END
   ELSE
      CheckErr(err);
   tempName := dfName;
   DownShift (@tempName);
   IF ((copyMode = InstallMode) AND (POS('{!',tempName) <> 0)) THEN { no filer files }
      GOTO 33
   ELSE
      sDfPathname := CONCAT(sDevPathname,'-',dfName);

   { Rename 'system.shell' to 'shell.system' if we're doing an Install }
   IF ((copyMode = InstallMode) AND (tempname = 'system.shell')) THEN
      dDfPathname := CONCAT(dDevPathname,'-','shell.system')
   ELSE
      dDfPathname := CONCAT(dDevPathname,'-',dfName);

   {get the source file information}
   LookUp(err, sDfPathname, sDfInfo);
   CheckErr(err);

   IF dbgCopy THEN WRITELN ('   copying ',sDfPathname,' to ',dDfPathname);
   IF (copyMode = RestoreMode) THEN         { Don't automatically overwrite files during restore, so }
      BEGIN
      Lookup(err, dDfPathname, dDfInfo);  { get the destination file info }
      IF dbgCopy THEN WRITELN('   Lookup on ',dDfPathname,', error = ',err:1,
                              ', file piece = ',sDfInfo.file_portion);
      IF (err <= 0) THEN                   { The file is there, so check piece numbers }
         IF (ABS(sDfInfo.file_portion) <= 1) THEN
            {either not a split doc or the first piece}
            IF IsNewer(sDfInfo, dDfInfo) THEN
               BEGIN
               KillDupDocs(sDfInfo, dDfPathname);
               CopyDiskFile(err, sDfPathname, dDfPathname, MakeFileMode);
               CheckErr(err);
               END
            ELSE
         ELSE
            {we have a middle/end split piece}
            BEGIN
            CopyDiskFile(err, sDfPathname, dDfPathname, AppendFileMode);
            CheckErr(err);
            END
      ELSE
         {no duplicate file entry}
         BEGIN
         CopyDiskFile(err, sDfPathname, dDfPathname, MakeFileMode);
         CheckErr(err);
         END;
      END {of IF RestoreMode block}
   ELSE
      BEGIN
      ZapPassword(dDfPathname);
      Kill_Object(err, dDfPathname);
      CopyDiskFile(err, sDfPathname, dDfPathname, MakeFileMode);
      CheckErr(err);
      END; {of ELSE block}
33:
   END; {of WHILE loop}

IF dbgCopy THEN WRITELN ('   [CopyAllDiskfiles], exit: err = ',err:1);
END; { of PROC CopyAllDiskFile }

{********************************************************************************}
PROCEDURE CopyDiskfile {* VAR err: INTEGER; source, destination: Pathname; copyMode: TfileMode *};
{ This proc copies a single diskfile from source to destination. It uses
  a memory-resident data seg as a buffer.  }

TYPE
   LabelFmt    = RECORD
                  version  : INTEGER;
                  name     : FmaxStr;
                  kind     : INTEGER;
                  toolOnly : BOOLEAN;
                  multiDoc : BOOLEAN;
                  windLoc  : Rect;
                  split    : INTEGER;
                  totalSize: LongInt;
                  parentID : LongInt;
                 END;

VAR
   atEnd          : BOOLEAN;
   blocksAllocated: LongInt;
   blocksNeeded   : LongInt;
   bytesPerIO     : INTEGER;
   bytesRead      : LongInt;
   bytesWritten   : LongInt;
   dDfRefInfo     : Fs_Info;
   dDfRefNum      : INTEGER;
   dontCare       : BOOLEAN;
   gcdBytesPerBlk : INTEGER;
   labelRecord    : LabelFmt;
   osErr          : INTEGER;
   otherErr       : INTEGER;
   sDfRefInfo     : fs_Info;
   sDfRefNum      : INTEGER;

  {----------------------------------------------------------------------}
  PROCEDURE OSError (at: INTEGER; result: INTEGER);

   BEGIN
   IF Abort THEN                     { Check for user abort        }
      BEGIN
      osErr := fceAborted;
      result := fceAborted;
      END;

   IF (osErr > 0) THEN
      BEGIN
      IF dbgCopy THEN WRITELN ('   Error at ',at:1,' in CopyDiskfile: ',osErr:1,
                               '; copying ',source,' to ',destination);
      err := result;
      Close_Object(osErr, sDfRefNum);          { Close the source file      }
      Close_Object(osErr, dDfRefNum);          { Close the destination file }
      IF (dDfRefnum <> 0) THEN                  { Don't kill if not opened   }
         BEGIN
         ZapPassword(destination);
         Kill_Object(osErr, destination);       { Only part of it was copied }
         END;
      EXIT(CopyDiskfile);
      END;
   END;

   {----------------------------------------------------------------------}
   PROCEDURE CopyFilePwd (sourcePath, destPath: Pathname);
   {makes <destPath> file password be the same as <sourcePath> file password}

   VAR
      uParm : UT_parmt;

   BEGIN
   WITH uParm DO
      BEGIN
      gp_parm := 0;
      command := xfer_passwd;
      path := sourcePath;
      op := pswRead;
      END;
   FS_Utilities(osErr, uParm);
   OsError(21, fceCantRead);
   WITH uParm DO
      BEGIN
      gp_parm := 0;
      command := xfer_passwd;
      path := destPath;
      op := pswWrite;
      END;
   FS_Utilities(osErr, uParm);
   OsError(22, fceCantWrite);
   END; {of PROC SetFilePwd}

   {----------------------------------------------------------------------}
   FUNCTION Gcd (m, n: INTEGER) : INTEGER;

   BEGIN
   IF n = 0
   THEN Gcd := m
   ELSE Gcd := Gcd(n, m MOD n);
   END; {of FUNC Gcd}

   {----------------------------------------------------------------------}

BEGIN
IF dbgCopy THEN
   WRITELN('[CopyDiskFile], entry: copying ',source,' to ',destination,', mode ',ORD(copyMode));

err := 0;
dDfRefNum := 0;

IF UserAborted(err) THEN
   EXIT (CopyDiskFile);

{ Verify allright to copy }
Lookup(osErr, source, sDfRefInfo);           { Need various information     }
OSError(1, fceCantRead);
osErr := 1;                                   { For the following tests      }

IF NOT (sDfRefInfo.fType IN [userFile, userCat, exec, spool, sysData, swapData,
                             swapCode, bootFile]) THEN
   BEGIN                                    { Only certain types are copied }
   IF dbgInstall THEN WRITELN ('   not xfering, file type is ', ORD(sDfRefInfo.fType):1);
   OsError(3, fceCantRead);
   END;

POpen (osErr, source, sDfRefNum, [dread], dontCare);  { Open a source diskfile }
CASE osErr OF
  0, -1173, -1174, -1175: ;                           { Ignore these warnings        }
  950, 951: OsError (4,fceInUse);                     { Already opened privately     }
  OTHERWISE OsError (5,fceCantRead);
  END;

IF (copyMode = MakeFileMode) THEN
   BEGIN
   { Create the destination diskfile }
   Make_File(osErr, destination, max_Label_Size);{ Create destination           }
   IF dbgInstall THEN WRITELN ('   Make_File, error = ',osErr:1);
   IF (osErr = 890) THEN
      BEGIN                                    { See if the file has been damaged}
      Lookup(otherErr, destination, dDfRefInfo);
      IF dDfRefInfo.file_Scavenged THEN
         BEGIN                                  { File scavenged, replace it   }
         Kill_Object(osErr, destination);
         Make_File(osErr, destination, max_Label_Size);
         END;
      END;
   OSError(6, fceOutOfDiskSpace);
   CopyFilePwd(source, destination);

   IF sDfRefInfo.protected THEN                      { Set protections if appropriate}
      Protect(osErr, destination, FALSE, sDfRefInfo.machine_ID);
   OSError(7,fceCantWrite);
   POpen(osErr, destination, dDfRefNum, [dwrite], dontCare);
   IF dbgCopy THEN WRITELN('   POpen on ',destination,', refnum = ',dDfRefNum,', error = ',osErr:1);
   OSError(8, fceCantWrite);
   END
ELSE
   BEGIN
   POpen(osErr, destination, dDfRefNum, [append], dontCare);
   IF dbgCopy THEN WRITELN('   POpen on ',destination,', refnum = ',dDfRefNum,', error = ',osErr:1);
   OSError(20, fceCantWrite);
   END;

{ Allocate the disk space }
IF dbgCopy THEN WRITELN ('   Allocating the disk space');
Info(osErr, dDfRefNum, dDfRefInfo);       { Need the logical block size  }
OSError(9, fceCantWrite);
IF (dDfRefInfo.pSize = 0) THEN                    { Destination is not a blocked dev}
   OSError(10, fceCantWrite);
blocksNeeded := sDfRefInfo.pSize DIV dDfRefinfo.lpSize; { Size of source in blocks }
Allocate(osErr, dDfRefNum, FALSE, blocksNeeded, blocksAllocated);
IF (blocksAllocated < blocksNeeded) THEN
   BEGIN
   IF (osErr < 0) THEN osErr := -osErr;       { Change warning to error }
   IF (osErr = 0) THEN osErr := 826;          { Allocate doesn't necessarily return an error }
   OSError(18, fceOutOfDiskSpace);
   END;

IF (copyMode = MakeFileMode) THEN
   BEGIN
   { Copy the label }
   IF dbgCopy THEN WRITELN('   MakeFileMode, copying the label');
   Read_Label(osErr, source, ORD(@labelRecord), SizeOf(labelRecord), bytesRead);
   IF (osErr <= 0) THEN
      BEGIN
      labelRecord.split := NullInt2;
      labelRecord.totalSize := 0;
      Write_Label(osErr, destination, ORD(@LabelRecord), bytesRead, bytesWritten);
      OSError(11,fceCantWrite);
      END
   ELSE IF (osErr <> 848) THEN
      OSError(12,fceCantRead); { 848 = no label }
   END;

{ Calculate bytes per IO       }
gcdBytesPerBlk := sDfRefInfo.LpSize * (dDfRefInfo.LpSize DIV Gcd(sDfRefInfo.LpSize, dDfRefInfo.LpSize));
IF (gcdBytesPerBlk > copyDsMemSize) THEN
   bytesPerIO := copyDsMemSize              { inefficient but necessary        }
ELSE
   bytesPerIO := (copyDsMemSize DIV gcdBytesPerBlk) * gcdBytesPerBlk;
IF dbgCopy THEN
   IF (bytesPerIO <= 0) THEN
       WRITELN ('ERROR in CopyDiskfile: bytesPerIO = ',bytesPerIO:1,', copyDsMemSize = ',copyDsMemSize:1,
                ', gcdBytesPerBlk =',gcdBytesPerBlk:1);

{Copy the diskfile}
atEnd := FALSE;
REPEAT
   Read_Data(osErr, sDfRefNum, copyDsAddr, bytesPerIO, bytesRead, sequential, 0);
   CASE osErr OF
      0, 848, 881, 883, 956:
         BEGIN    { Various end-of-file conditions   }
         IF (osErr <> 0) THEN
            BEGIN
            atEnd := TRUE;
            osErr := 0;
            END;
         IF (bytesRead > 0) THEN
            Write_Data(osErr, dDfRefNum, copyDsAddr, bytesRead, bytesWritten, sequential, 0);
         CASE osErr OF
           0: ;
           848, 882: OsError(13,fceOutOfDiskSpace);
           OTHERWISE OsError(14,fceCantWrite);
           END;
         END;
      OTHERWISE OsError(15,fceCantRead);
      END; {of CASE block}
   UNTIL atEnd;

sDfRefInfo.file_portion := 0;                      { reset split file info, as we are re-combining }
PSet_File_Info(osErr, dDfRefNum, sDfRefInfo);     { Set date/time, file close flds}
OSError(19,fceCantWrite);

Close_Object(osErr, dDfRefNum);          { Close the destination file        }
OSError(17, fceCantWrite);
Close_Object(osErr, sDfRefNum);          { Close the source file             }

IF dbgCopy THEN WRITELN ('   [CopyDiskFile], exit');
END;

{****************************************************************************}
PROCEDURE CheckPMList {* index: INTEGER *};
{Makes sure that the disk entry specified in devList[] by <index> is also in parameter memory
 (contained somewhere in pmList[]).  If not, adds it so that when Finished calls PMWrite,
 the parameter memory record shows that the disk is present and the user can boot from it.}

TYPE
   TpmEntryState  = (notThere, wrongEntry, goodStuff);

VAR
   config      : configDev;
   theCDpos    : cd_position;
   theDrvrID   : LongInt;

   {----------------------------------------------------------------------------}
   PROCEDURE CheckEntry;

   VAR
      entryState  : TpmEntryState;
      i           : INTEGER;
      matchIndex  : INTEGER;

   BEGIN
   entryState := notThere;
   FOR i := 1 to lastPMEntry DO
      IF (pmList[i].pos.slot = theCDpos.slot) THEN
         IF (pmList[i].pos.chan = theCDpos.chan) THEN
            BEGIN
            {we have a position match}
            IF (pmList[i].driverID = theDrvrID) THEN
               {same exact entry, no change needed}
               entryState := goodStuff
            ELSE
               {same location, different thing configured, better eliminate it}
               entryState := wrongEntry;
            matchIndex := i;
            i := lastPMEntry;
            END;

   CASE (entryState) OF
      goodStuff:
         BEGIN END;
      notThere: {device not in parameter memory}
         BEGIN
         lastPMEntry := lastPMEntry + 1;
         matchIndex := lastPMEntry;
         END;
      wrongEntry: {device in parameter memory, but of wrong type}
         BEGIN END;
      END; {of CASE block}

   IF (entryState <> goodStuff) THEN
      BEGIN
      WITH config DO
         BEGIN
         pos         := theCDpos;
         nExtWords   := 0;
         extWords[1] := 0;
         extWords[2] := 0;
         extWords[3] := 0;
         driverID    := theDrvrID;
         MakeDevName(pos, devName);
         END; {of WITH block}
      pmList[matchIndex] := config;
      END; {of IF THEN block}

   END; {of PROC CheckEntry}

   {----------------------------------------------------------------------------}

BEGIN
{zero the dev position}
theCDpos.slot := devList[index].position.slot;
theCDpos.dev := 0;

{does the disk have a card?}
IF (devList[index].cardDrvrPos <> NoCard) THEN
   BEGIN
   {has a card, in a slot.  Check if the card is configured}
   theCDpos.chan := 0;
   theDrvrID := drvrList[devList[index].cardDrvrPos].infoBuf.cd_driverID;
   CheckEntry;
   END;

{now find out if the disk is there}
theCDpos.chan := devList[index].position.chan;
theDrvrID := drvrList[devList[index].diskDrvrPos].infoBuf.cd_driverID;
CheckEntry;
END; {of PROC CheckPMList}

{****************************************************************************}
FUNCTION Dismount {* devPort: CD_Position; eject, bootvol: BOOLEAN) : BOOLEAN *};
{Attempts to dismount the device, without closing any files.  If an error occurs on hard-disk
 dismount, puts up alert and returns FALSE.  If eject = true, attempts to eject the lower diskette.
 If bootvol = TRUE the device is the boot volume, so do the privileged dismount. }

VAR
   devName  : E_Name;
   err      : INTEGER;
   fs_info  : ut_parmt;

   {------------------------------------------------------------------------------}
   PROCEDURE CheckErr (theError: INTEGER);

   BEGIN
   IF dbgInstall THEN WRITELN ('   Aborting, error = ',theError:1);
   IF (theError = 1062) THEN
      EXIT(CheckErr);
   IF ErrorFound(warnError, 30, theError) THEN
      BEGIN
      Dismount := FALSE;
      EXIT (Dismount);
      END;
   END;
   {------------------------------------------------------------------------------}

BEGIN
IF dbgInstall THEN
   BEGIN
   WRITELN ('[Dismount], entry:slot = ',devPort.slot:1,', chan = ',devPort.chan:1);
   IF eject THEN
      WRITELN ('   Ejecting diskette ')
   ELSE
      WRITELN ('   Not ejecting ');
   IF bootvol THEN
      WRITELN ('   Dismounting the boot volume. ')
   ELSE
      WRITELN ('   Dismounting a regular volume. ');
   END; { of IF block }

MakeDevName (devPort, devName);

IF (bootvol) THEN
   BEGIN
   IF dbgInstall THEN WRITELN ('   Unmounting the boot volume ');
   fs_Info.command := boot_unmount;
   fs_Info.level := 0;          { A meaningless variable }
   fs_Utilities(err, fs_Info);
   END
ELSE
   Unmount (err, devName);

CheckErr(err);
IF (bootVol) THEN
   bootUnmounted := TRUE;

IF eject THEN
   EjectDiskette;

Dismount := TRUE;

IF dbgInstall THEN WRITELN ('   [Dismount], exit');
END; { of PROC Dismount }

{****************************************************************************}
PROCEDURE DisplayError {* flrErr, err: INTEGER *};
{ Displays an error message based on "err."  Some values of "err" result in
  specific messages, otherwise just the number is given.  Note: "flrErr" and "err"
  are always displayed. }

VAR
   alertNum    : INTEGER;
   devName     : FmaxStr;
   errStr      : NumberStr;
   flrErrStr   : NumberStr;
   volName     : FmaxStr;

BEGIN
IF (err <= 0) THEN
   EXIT(DisplayError);

{ convert parameters to strings }
IntToStr(ABS(flrErr),flrErrStr);
ArgAlert(1,flrErrStr);

IF (err = nullErr) THEN
   errStr := ''
ELSE
   BEGIN
   IntToStr(err,errStr);
   errStr := CONCAT('/',errStr);
   END;
ArgAlert(2,errStr);

ArgAlert(3,diskString);

{determine which message to give based on error number}
CASE err OF

   { I/O or bad disk structure errors, suggest reparing disk }
   312,     { Unexpected file system error (Make_Dataseg) }
   606,     { Can't find sector (disk unformatted) }
   617,     { Checksum error }
   618,     { Can't format, or write protected }
   625,     { Scavenger indicated that data is bad }
   654,     { Hard error status returned from ProFile }
   659,     { Corrupt file system header chain found in driver }
   802,     { Asynchronous I/O request not completed successfully }
   810,     { The requested page could not be read in }
   829,     { Partial deallocation only (ran into unallocated region) }
   835,     { s-file number < 0 or > maxfiles }
   837,     { Unallocated s-file or I/O error }
   841,     { Unallocated s-file or I/O error }
   849,     { Invalid page or offset in parameter list }
   875,     { Invalid s-file ID or s-file control block (Close_SFile) }
   884,     { Not first auto-allocation, but file was empty }
   885,     { could not update filesize hints after a write }
   888,     { Entry not found in catalog }
   900,     { Invalid page count or FCB pointer argument }
   966,     { Internal inconsistency of FMARK and LEOF }
   972,     { Entry not found in specified catalog }
   1190,    { Attempt to access a page that is not allocated to the pipe }
   1297,    { Entry name for the object is invalid }
   1298:    { S-list entry for the object is invalid }
      alertNum := 60;

   { out of disk space errors }
   309,     { Insufficient disk space for data segment }
   826,     { No more room to allocate pages on device }
   854,     { No free slots in s-list directory (too many s-files) }
   855,     { No available disk space for file hints }
   882,     { No space on volume for new page of file }
   891,     { Catalog is full, or was not catalog }
   959:     { System resources exhausted }
      alertNum := 61;    { out of disk space error }

      { "technical difficulties", just give error number }

   OTHERWISE
      alertNum := 50;    { other error }
   END; {of CASE block}

   { display the message }

NoteAlert(installAlert,alertNum);

END; {of PROC DisplayError}

{****************************************************************************}
PROCEDURE DownShift {pStr: StringPtr};
{ Converts all upper case chars in pStr to lower case }

VAR
   i  : INTEGER;

BEGIN
For i := 1 to LENGTH(pStr^) DO
   IF (pStr^[i] <= 'Z') THEN
      IF (pStr^[i] >= 'A') THEN
         pStr^[i] := CHR(ORD(pStr^[i]) + 32);
END;

{****************************************************************************}
PROCEDURE EjectDiskette;

VAR
   err      : INTEGER;
   fsParams : Ut_Parmt;

BEGIN
IF dbgInstall THEN WRITELN ('[EjectDiskette], entry ');

fsParams.command := eject;
fsParams.dev_Name := bootDevName;
FS_Utilities (err, fsParams);

IF dbgInstall THEN WRITELN ('   [EjectDiskette], exit: err = ',err:1);
END;

{****************************************************************************}
FUNCTION  ErrorFound { errKind: errTypes; flrErr,err: INTEGER): BOOLEAN };
{ This is the general error handler used throughout the filer.  It Returns FALSE
  if err <= 0, otherwise it presents a message and returns TRUE (unless restarting).
  "errKind" is used to determine the action to be taken after the error message
  is given. The errTypes are:
     fatalError  =>  restart the filer
     askError    =>  give the user the choice of restarting or continuing
     warnError   =>  continue

  "flrErr" should be a unique filer internal number for locating the call.
  "err" is the actual error return to be checked.  Use "nullErr" if no error to check.
}

BEGIN

IF err <= 0 THEN
   BEGIN
   ErrorFound := FALSE;
   EXIT(ErrorFound);
   END
ELSE
   ErrorFound := TRUE;

DisplayError(flrErr,err);   { tell the user about the problem }

CASE errKind OF
   fatalError:
      BEGIN
      StopAlert(installAlert,51);               { system will restart ... }
      Finished(reboot);
      END;
   askError:
      BEGIN
      IF AskAlert(installAlert,52) = 1 THEN     { restart or continue? ... }
         Finished(reboot);
      END;
   warnError:
      BEGIN END;                            { will continue }
   END;
END;

{****************************************************************************}
PROCEDURE FailedAlert;
{ Called by alert manager when an error occurs using the alert manager package }

BEGIN
IF dbgInstall THEN WRITELN('[FailedAlert], entry: Alert manager error = ',alertError);

DisplayError(80,3075);   { Problem reading startup disk ... }

IF dbgInstall THEN WRITELN('   [FailedAlert] , exit');
END;

{****************************************************************************}
PROCEDURE Finished {* lastAct: WhenFinished *};
{Called by Quit, kills off this shell (system.shell) and tells the OS what to do when
 the process terminates}

VAR
   bootRec     : TbootStuff;
   entryKey    : LongInt;
   err         : INTEGER;
   i           : INTEGER;
   termEventBlk: S_EventBlk;

BEGIN
IF dbgInstall THEN WRITELN ('[Finished], entry: lastAct = ',ORD(lastAct):1);

PMReadBoot(bootRec);

CASE lastAct OF
   reboot:
      BEGIN
      termEventBlk[1] := RebootMachine;
      alertNum := 113;
      IF (initPos.slot IN [1,2,3]) THEN
         bootRec.BootVol := initPos.slot * 3 + (initPos.chan - 1)
      ELSE
         bootRec.BootVol := 2; { default boot loc., paraport (Lisa 1.0) or internal (Pepsi) }
      END; {of CASE ITEM reboot}
   restart:
      BEGIN
      termEventBlk[1] := RebootMachine;
      alertNum := 116;
      IF (machineType.io_board = IOLisa) THEN
         {boot from the upper twiggy}
         bootRec.BootVol := 0
      ELSE
         {boot from the sony}
         bootRec.BootVol := 1;
      END;
   off:
      BEGIN
      termEventBlk[1] := PowerOffMachine;
      alertNum := 130;  { Wait: 'Machine turning off...' }
      END;
   END;

WaitAlert(installAlert, alertNum);
IF (termEventBlk[1] = RebootMachine) THEN
   PMWriteBoot(bootRec);

{set up new parameter memory}
entryKey := 0;
FOR i := 1 TO lastPMEntry DO
   PMWRITECONFIG(err, entryKey, pmList[i]);
{flush PM to OS}
PMWrite;

Terminate_Process(err, @termEventBlk);
SysErr (90, err);

IF dbgInstall THEN WRITELN ('   [Finished], exit');
END;

{****************************************************************************}
PROCEDURE GetString {* alertNumber: INTEGER; pStr: TpStr255 *};
{ fetches a string constant from the phrase file }

BEGIN
GetAlert(installAlert, alertNumber, pStr);
END;

{****************************************************************************}
FUNCTION HeapOverflow {hz: THz; bytesNeeded: INTEGER) : INTEGER};

VAR
   bytes:  NumberStr;

BEGIN
IF dbgInstall THEN WRITELN ('[HeapOverflow], entry: bytesNeeded = ',bytesNeeded:1);

SysErr(110, bytesNeeded);
HALT;

IF dbgInstall THEN WRITELN ('   [HeapOverflow], exit');
END;

{****************************************************************************}
PROCEDURE Initialize;

VAR
   deltaSize   : LongInt;
   drvrPos     : INTEGER;
   err         : INTEGER;
   excepName   : T_Ex_Name;
   tempPathname: Pathname;

BEGIN
IF dbgInit THEN WRITELN ('[Initialize], entry');

{ Set up the terminate exception handler }
IF dbgInit THEN WRITELN ('   About to initialize the exception handler');

excepName := 'SYS_TERMINATE';
Declare_Excep_Hdl(err, excepName, @LastWishes);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Declar_Excep_Hdl error: ',err);
   HALT;
   END;

IF dbgInit THEN WRITELN ('   About to initialize BlockIO');
BlockIOinit;                                { Once only call by shell     }

IF dbgInit THEN WRITELN ('   Setting up moveconsole');
MoveConsole (err, mainscr);                         { Make writeln's go to the main screen }

IF dbgInit THEN WRITELN ('   Setting up PMINIT');
PMInit(err);

IF dbgInit THEN WRITELN ('   Setting up InitGraf');
InitGraf(@thePort);                     { each process must init this }

IF dbgInit THEN WRITELN ('   Setting up default grafport');
SetPort(deskPort);      { To assure a default grafport, to be done in OpenWM }

IF dbgInit THEN WRITELN ('   Setting up the heap');
InitHeap (@myHeap[0], @myHeap[heapSize], @HeapOverflow);

IF dbgInit THEN WRITELN ('   Initializing the window manager');
InitWM;                                     { once-only call by shell }

IF dbgInit THEN WRITELN ('   Initializing the cursor');
InitWmlCrs (err);
IF err > 0 THEN
   BEGIN
   WRITELN ('   InitWmlCrs error: ',err:1);
   HALT;
   END;

alertError := 0;     { alertError is a global var set in the calls to the Alert Manager }

{ InitAlerts uses cacheSize and cacheBytes to calculate a maximum permissable heapsize.
  If the number of alert messages changes significantly these values will have to be
  re-calculated using the formula presented in the Alert documentation..Sorry }

{ PS. Make sure that cacheSize is bigger than the number of alerts in installAlert.text!! }

IF dbgInit THEN WRITELN('   Initializing the alert manager');
InitAlerts(cacheSize,cacheBytes,theHeap,NIL,@FailedAlert); { each process calls this }
IF alertError > 0 THEN
   BEGIN
   WRITELN('   InitAlerts error = ',alertError);
   HALT;
   END;

IF dbgInit THEN WRITELN ('   Initializing the phrase file');
OpenPhraseFile(alertRefnum, mNameAlerts);    { the shells alerts }
IF alertError > 0 THEN
   BEGIN
   WRITELN('   OpenPhraseFile ',mNameAlerts,', error = ',alertError:1);
   HALT;
   END;

installAlert := ReadAlerts (alertRefnum,-1);
IF (alertError > 0) THEN
   BEGIN
   WRITELN('   ReadAlerts ',mNameAlerts,', error = ',alertError:1);
   HALT;
   END;

IF dbgInit THEN WRITELN ('   Locking down the alerts');

{ Lock all of the alert messages into the data seg so we can unmount the install diskette.
  Remember...If you add any alerts to the installAlert.text file which you plan to use, you
  must remember to lock them here as well.  Also, if the number of alerts is bigger than
  cacheSize ( CacheSize = 74) then mucho problems, so be careful}

LockAlert (installAlert, 1);
LockAlert (installAlert, 2);
LockAlert (installAlert, 3);
LockAlert (installAlert, 4);
LockAlert (installAlert, 50);
LockAlert (installAlert, 51);
LockAlert (installAlert, 52);
LockAlert (installAlert, 60);
LockAlert (installAlert, 61);
LockAlert (installAlert, 101);
LockAlert (installAlert, 102);
LockAlert (installAlert, 103);
LockAlert (installAlert, 104);
LockAlert (installAlert, 106);
LockAlert (installAlert, 108);
LockAlert (installAlert, 109);
LockAlert (installAlert, 110);
LockAlert (installAlert, 111);
LockAlert (installAlert, 113);
LockAlert (installAlert, 114);
LockAlert (installAlert, 115);
LockAlert (installAlert, 116);
LockAlert (installAlert, 117);
LockAlert (installAlert, 118);
LockAlert (installAlert, 119);
LockAlert (installAlert, 120);
LockAlert (installAlert, 121);
LockAlert (installAlert, 122);
LockAlert (installAlert, 123);
LockAlert (installAlert, 124);
LockAlert (installAlert, 125);
LockAlert (installAlert, 128);
LockAlert (installAlert, 130);
LockAlert (installAlert, 133);
LockAlert (installAlert, 137);
LockAlert (installAlert, 138);
LockAlert (installAlert, 139);
LockAlert (installAlert, 141);
LockAlert (installAlert, 142);
LockAlert (installAlert, 143);
LockAlert (installAlert, 144);
LockAlert (installAlert, 145);
LockAlert (installAlert, 146);
LockAlert (installAlert, 147);
LockAlert (installAlert, 148);
LockAlert (installAlert, 160);
LockAlert (installAlert, 161);
LockAlert (installAlert, 162);
LockAlert (installAlert, 163);
LockAlert (installAlert, 164);
LockAlert (installAlert, 165);
LockAlert (installAlert, 166);
LockAlert (installAlert, 167);
LockAlert (installAlert, 200);
LockAlert (installAlert, 201);
LockAlert (installAlert, 202);
LockAlert (installAlert, 203);
LockAlert (installAlert, 208);
LockAlert (installAlert, 209);
LockAlert (installAlert, 220);
LockAlert (installAlert, 221);
LockAlert (installAlert, 222);
LockAlert (installAlert, 223);
LockAlert (installAlert, 224);
LockAlert (installAlert, 225);
LockAlert (installAlert, 226);
LockAlert (installAlert, 227);
LockAlert (installAlert, 228);
LockAlert (installAlert, 229);
LockAlert (installAlert, 230);
LockAlert (installAlert, 231);
LockAlert (installAlert, 232);
LockAlert (installAlert, 302);
LockAlert (installAlert, 303);
LockAlert (installAlert, 304);
LockAlert (installAlert, 305);
LockAlert (installAlert, 308);
LockAlert (installAlert, 309);
LockAlert (installAlert, 310);
LockAlert (installAlert, 311);
LockAlert (installAlert, 312);
LockAlert (installAlert, 313);
LockAlert (installAlert, 314);
LockAlert (installAlert, 315);
LockAlert (installAlert, 316);
LockAlert (installAlert, 317);
LockAlert (installAlert, 318);
LockAlert (installAlert, 319);
LockAlert (installAlert, 320);
LockAlert (installAlert, 321);
LockAlert (installAlert, 322);
LockAlert (installAlert, 330);
LockAlert (installAlert, 331);
LockAlert (installAlert, 332);
LockAlert (installAlert, 333);
LockAlert (installAlert, 334);
LockAlert (installAlert, 335);
LockAlert (installAlert, 336);
LockAlert (installAlert, 337);
LockAlert (installAlert, 339);
LockAlert (installAlert, 341);

{If heap problem w/alerts, etc., will probably show up at least for last one, so...}
IF (alertError > 0) THEN
   BEGIN
   WRITELN('   LockAlert error, error = ',alertError:1);
   HALT;
   END;

{ Lock the Paslib codes segs down }
IF dbgInit THEN WRITELN ('   Locking down the paslib segs');
LockPasLib (err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   LockPasLib, error = ',err:1);
   HALT;
   END;

{$IFC DebugOn}
   {set up for writelns}
   LockPasioLib (err);
   IF (err > 0) THEN
      BEGIN
      WRITELN ('   LockPas(io)Lib, error = ',err:1);
      HALT;
      END;
{$ENDC}

{ Lock the code segments for the intrinsic lib.  The intrinsic lib used with this
  program is a special, reduced and compacted version of the regular instrinsic
  library and units.  This effects the segment names, as the names locked in here
  are valid only until a new unit (with possibly new segment names) is added or
  updated for this special syslib.obj and intrinsic.lib.  The moral of the story is
  ...BE CAREFUL....}

{ Another note is that the names of the code segments are case sensitive, so watch
  the upper and lower mix of characters }

IF dbgInit THEN WRITELN ('   Locking down all the code segments');

lkActivate(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking ACTIVATE segment, error = ',err:1);
   HALT;
   END;

lkOPSEG1(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking OPENSEG1 segment, error = ',err:1);
   HALT;
   END;

lkOPSEG2(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking OPENSEG2 segment, error = ',err:1);
   HALT;
   END;

lkWorkset(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking WORKSET segment, error = ',err:1);
   HALT;
   END;

lkOTHRWORK(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking OTHRWORK segment, error = ',err:1);
   HALT;
   END;

lkPMMSeg(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking PMMSeg segment, error = ',err:1);
   HALT;
   END;

lkWMalert(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking WMalert segment, error = ',err:1);
   HALT;
   END;

lkalert(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking alert segment, error = ',err:1);
   HALT;
   END;

lkSMcold(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking SMcold segment, error = ',err:1);
   HALT;
   END;

lkINcold(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking INcold segment, error = ',err:1);
   HALT;
   END;

lkWMcold(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking WMcold segment, error = ',err:1);
   HALT;
   END;

lkOpen1LW(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking OPEN1LW segment, error = ',err:1);
   HALT;
   END;

lkLWWork(err);
IF (err > 0) THEN
   BEGIN
   WRITELN('   Locking LWWORK segment, error = ',err:1);
   HALT;
   END;

lkgrafseg (Err);
IF (Err > 0) THEN
   BEGIN
   WRITELN ('   Locking lkgrafseg segment, error = ',Err:1);
   HALT;
   END;

lkNever (Err);
IF (Err > 0) THEN
   BEGIN
   WRITELN ('   Locking NEVER segment, error = ',Err:1);
   HALT;
   END;

lkfmgrutil (err);
IF (err > 0) THEN
   BEGIN
   WRITELN ('   Locking lkfmgrutil segment, error = ',err:1);
   HALT;
   END;

lkWMWarm (err);
IF (err > 0) THEN
   BEGIN
   WRITELN ('   Locking lkWMWarm segment, error = ',err:1);
   HALT;
   END;

lkWMCold (err);
IF (err > 0) THEN
   BEGIN
   WRITELN ('   Locking lkWMCold segment, error = ',err:1);
   HALT;
   END;

lkWMJrnl (err);
IF (err > 0) THEN
   BEGIN
   WRITELN ('   Locking lkWMJrnl segment, error = ',err:1);
   HALT;
   END;

IF dbgInit THEN WRITELN ('   Setting up the screen keyboard and the graph port');
SetScreenKeybd(priScrn);                        {Switch to graphics screen   }
SetPort(filerFolder);                           {get the grey background w/ the menu bar up there}

IF dbgInit THEN WRITELN ('   Initializing the cursor');
InitCursor;                                     { Display the cursor          }

logo          := ' ';
copyright     := ' ';
apple         := ' ';
logo[1]       := CHR(15);
copyright[1]  := CHR(ccCopy);                   { Try to get the copyright symbol }
apple[1]      := CHR(14);
GetString(322, @diskString);                    {'currently not specified'}

diskSet := FALSE;                               { the disk is not specificed currently }
drvrsSet := FALSE;                              { the drivers havent been loaded and initialized }
bootUnmounted := FALSE;                         { The boot volume (floppy drive) is mounted now }
password := '';                                 { The password used to initialize a volume is always '' }

IF dbgInit THEN WRITELN ('   Initializing the machine type');
Mach_Info(err, MachineType);       { Find out what type of Lisa we're dealing with here }
IF (err > 0) THEN
   BEGIN
   IF dbgInit THEN WRITELN ('   Mach_Info returned error ',err:1);
   MachineType.cpu_board := cpub_lisa;               { Set to default }
   MachineType.io_board := IOlisa;                  { Set to default }
   END;

{ A word of explanation here:  bootPos is the position where the Install program disk is
  booted from.  initPos is the position where the disk to be initialized is connected.
  The entire purpose of this program is to get the software that the user has (contained
  on a set of diskettes) onto a disk which he will be able to boot from in the future. }

IF dbgInit THEN WRITELN ('   Initializing the port/device names');
bootPos.slot := 0;
bootPos.chan := 0;
bootPos.dev := 0;
CASE Machinetype.io_board OF
   IOlisa:
      BEGIN
      bootPos.slot := 14;        { boot is from the upper twiggy }
      bootPos.chan := 1;
      END;
   IOpepsi, IOlisaLite, IOPepsiLite:
      bootPos.slot := 13;       { The boot is from the sony }
   END; { of case block }

MakeDevName(bootPos, bootdevName);   { Set devName to the system name for the boot port, eg. = #1#2 }

IF dbgInit THEN WRITELN ('   bootPos device name is ',bootdevName);

IF dbgInit THEN WRITELN ('   Initializing the copy data seg');
MakeCopyDataSeg;        { File copy buffer area - memory resident without swap file space }

IF dbgInit THEN WRITELN ('   Initializing the stack size');
deltaSize := myStackSize;
IF dbgInit THEN WRITELN ('   Guaranteeing a stack size of at least ',deltaSize);
Size_Stack (err, deltaSize);
IF (err > 0) THEN
   BEGIN
   WRITELN ('   Resizing stack, error = ',err:1);
   HALT;
   END;

{ This next business is to force the OS to allocate space off the syslocal stack for the
  reset_catalog call.  This space is set for the rest of the program, so now we can unmount
  the boot volume and not bomb when reset_catalog is called...what a kludge....}

tempPathname := CONCAT('-',bootDevName);     {bootDevice is the sony diskette device}
Reset_Catalog (err, tempPathname);
IF (err > 0) THEN IF dbgInit THEN WRITELN ('   Dummy Reset_catalog, error = ',err:1);

{set up the paramater memory list}
InitPMList;

{set up the slots info}
Cards_Equipped(err, slots);
IF (err > 0) THEN IF dbgInit THEN WRITELN ('   Cards_Equipped, error = ',err:1);

{set up the DrvrList[] array with the boot diskette driver names}
FOR drvrPos := 1 TO LastDrvr DO
   BEGIN
   GetString(350+drvrPos, @drvrList[drvrPos].name);
   drvrList[drvrPos].hasInfo := FALSE;
   drvrList[drvrPos].hasFile := FALSE;
   END;

IF dbgInit THEN WRITELN ('   [Initialize], exit ');
END;


{****************************************************************************}
FUNCTION InitNewDisk {* : BOOLEAN *};
{ This function takes the initialization volume, formats it if necessary, and
  mounts it. If the volume cannot be initialized or mounted, the function
  returns false. }

VAR
   devName     : E_Name;
   diskSize    : LongInt;
   err         : INTEGER;
   fsParams    : Ut_Parmt;
   result      : TInitDisk;
   schedErr    : INTEGER;
   situation   : str255;
   volName     : E_Name;

   {---------------------------------------------------------------------}
   PROCEDURE CantInitDisk (result: INTEGER);
   BEGIN

   CASE result OF
      fNotInit,
      fNotMounted    : StopAlert (installAlert, 104);
      fBootNotMounted: BEGIN END;
      OTHERWISE SysErr (130, result);
      END; { of case block }

   IF dbgInstall THEN WRITELN ('   [CantInitDisk and InitNewDisk], exit: result = ',result:1);
   InitNewDisk := FALSE;
   EXIT(InitNewDisk);
   END;

   {---------------------------------------------------------------------}
   PROCEDURE GetDiskSize;
   {sets up the number of blocks for a segmented volume}

   BEGIN
   diskSize := 0;

   IF (diskType = PriamDisk) THEN
      EXIT(GetDiskSize); { can't share a priam disk }

   {for machines w/a known disk location, allow sharing only at the main boot location}
   CASE (machineType.io_board) OF
      IOLisa, IOLisaLite: IF (initPos.slot <> 11) THEN EXIT(GetDiskSize);
      IOPepsi: IF (initPos.slot <> 12) THEN EXIT(GetDiskSize);
      END; {of CASE block}

   {put up the initial alert}
   IF (AskAlert(installAlert, 165) = 1) THEN
      {user doesn't want to do anything w/Mac segmented disk}
      EXIT(GetDiskSize);

   CASE (diskType) OF
      ProfileDisk:
         CASE (AskAlert(installAlert, 166)) OF
            1: diskSize := 0;
            2: diskSize := 7690;       { full profile disk size is 9690 blocks }
            END;
      WidgetDisk:
         CASE (AskAlert(installAlert, 167)) OF
            1: diskSize := 0;
            2: diskSize := 17448;      { full widget disk size is 19448 blocks (pages) }
            3: diskSize := 13448;
            4: diskSize := 9448;
            END; {of CASE block}
      END; {of CASE block}

   END; {of PROC GetDiskSize}
   {---------------------------------------------------------------------}

BEGIN
IF dbgInstall THEN WRITELN ('[InitNewDisk], entry');

GetString(302, @situation);
MountBoot(err, situation);
IF (err > 0) THEN
   CantInitDisk(fBootNotMounted);

{Dismount the disk for initialization}
IF (NOT Dismount(initPos, DontEject, NotBoot)) THEN
   BEGIN
   InitNewDisk := FALSE;
   EXIT(InitNewDisk);
   END;

{Initialize the disk}
devName := initDevName;

GetDiskSize;

IF (diskSize = 0) THEN
   WaitAlert(installAlert, 122)              { Wait: '..erasing and initializing the disk' }
ELSE
   WaitAlert(installAlert, 119);             { Wait: '..erasing and initializing a partitioned disk' }

WITH fsParams DO
   BEGIN
   command     := initVol;
   idev_Name   := devName;
   pages       := diskSize;                  { if = 0, init to full size }
   newVolName  := CONCAT('AOS ',version);    { give it some reasonable name }
   newPassword := password;                  { this is a no-op }
   max_Sfiles  := 0;                         { if = 0, OS picks a reasonable size for max # of files }
   END;

FS_Utilities(err, fsParams);

IF (err > 0) THEN
   BEGIN
   IF dbgInstall THEN WRITELN ('   FS_Util w/InitVol, error = ',err:1);
   CantInitDisk(fNotInit);
   END;

{ Disk initialized, mount it }
Mount(err, volName, password, devName);
CASE err OF
   0:
      BEGIN    { Mounted without error        }
      InitNewDisk := TRUE;
      EXIT(InitNewDisk);
      END;
   1197,       { Volume is not initialized    }
   866:
      CantInitDisk(fNotInit);
   OTHERWISE   { Unexpect err, release disk   }
      CantInitDisk(fNotMounted);
   END; {of CASE block}

IF dbgInstall THEN WRITELN ('   [InitNewDisk], exit');
END; {of FUNC InitNewDisk}

{****************************************************************************}
PROCEDURE InitPMList;

VAR
   entryKey : LongInt;
   err      : INTEGER;

BEGIN
IF dbgInit THEN WRITELN('[InitPMList], entry');
lastPMEntry := 0;
entryKey := 0;
REPEAT
   lastPMEntry := lastPMEntry + 1;
   PMREADCONFIG(err, entryKey, pmList[lastPMEntry]);
   IF (err > 0) THEN
      lastPMEntry := lastPMEntry - 1;
   UNTIL (err > 0);
IF dbgInit THEN WRITELN('   [InitPMList], exit: LastPMEntry = ',lastPMEntry:1);
END; {of PROC InitPMList}


{****************************************************************************}
PROCEDURE Install;
{copies the files from diskette 2...N onto the specified disk, also fools around with deleting
 system.shell file, renaming it as its copied from the diskette (in copydiskfile), then renaming
 it correctly if the Install goes OK.  Also re-writes the boot tracks after a successful Install}

LABEL 99;

VAR
   blocksAllocated: LONGINT;
   dDfPathname    : Pathname;
   dDevName       : E_Name;
   dDevPathname   : Pathname;
   dfName         : E_Name;
   diskCount      : INTEGER;
   driveName      : Str255;
   err            : INTEGER;
   fsParams       : Ut_Parmt;
   goodInstall    : BOOLEAN;
   moreSys        : BOOLEAN;
   mounted        : BOOLEAN;
   noMore         : BOOLEAN;
   prefix         : E_Name;
   result         : TInitDisk;
   sDfInfo        : Fs_Info;
   sDfPathname    : Pathname;
   sDevName       : E_Name;
   sDevPathname   : Pathname;
   situation      : Str255;
   tempName       : E_Name;
   tempPathname   : Pathname;
   tempString     : NumberStr;
   volName        : E_Name;

   {---------------------------------------------------------------------------}
   PROCEDURE AbortInstall;

   BEGIN
   goodInstall := FALSE;
   GOTO 99;
   END; {of PROC AbortInstall}

   {---------------------------------------------------------------------------}
   FUNCTION CheckLisaGuide : BOOLEAN;
   { Check to make sure that diskette name is not = lisaguide.  If yes, give user
     the message and return true, else return false. }

   VAR
      tempName:  E_Name;

   BEGIN
   tempName := volName;
   DownShift (@tempName);
   IF (tempName = lisaGuide) THEN
      BEGIN
      IF Dismount (bootPos, EjectIt, NotBoot) THEN;  { Eject diskette, not the boot volume }
      StopAlert (installAlert, 138);         { Tell the user s/he can't copy a lisaguide diskette }
      CheckLisaGuide := TRUE;                { So it was a lisaguide diskette! }
      END
   ELSE CheckLisaGuide := FALSE;          { Ah, relief...It wasn't a Lisaguide diskette }
   END; {of FUNC CheckLisaGuide}

   {---------------------------------------------------------------------------}
   FUNCTION ValidDiskette (Volname: E_Name; DiskNumber : INTEGER) : BOOLEAN;
   { Checks the diskette in the bootPos to verify that the name and
     version number are set correctly.  If yes, then returns true, else
     tells the user what's wrong and returns false }

   VAR
      testNumber  : NumberStr;

   BEGIN
   IntToStr (diskNumber, testNumber);
   IF dbgInstall THEN WRITELN ('   Volname = ',volname,' testNumber = ',testNumber);

   ValidDiskette := FALSE;
   IF (POS (auxName, volName) <> NamePos) THEN              { Not '(Office System)/(Install)/etc.' diskette }
      alertNum := 118
   ELSE IF (POS (TestNumber, volName) <> NumberPos) THEN    { Not the right sequence of office system diskettes }
      BEGIN
      ArgAlert (1, TestNumber);
      alertNum := 123;
      END
   ELSE IF (POS (version, volName) <> VersionPos) THEN      { Not the right version }
      alertNum := 120
   ELSE
      BEGIN
      ValidDiskette := TRUE;
      EXIT(ValidDiskette);
      END;

   NoteAlert(installAlert, alertNum);

   END; {of FUNC ValidDiskette}

   {---------------------------------------------------------------------------}

BEGIN
IF dbgInstall THEN WRITELN ('[Install], entry');

goodInstall := TRUE;

GetString(308, @situation);
MountBoot (err, situation);
IF (err > 0) THEN
   AbortInstall;

MountInit(result);
CASE (result) OF
   badDisk,
   newDisk:
      {Alert: 'The disk is bad...do you with to initialize it?'}
      IF (AskAlert(installAlert, 102) = 2) THEN
         IF InitNewDisk THEN
            {do nothing, we're cool}
            BEGIN END
         ELSE
            {initialization failed}
            AbortInstall
      ELSE
         {user didn't want to initialize the disk, so bail out}
         EXIT(Install);
   noDisk,
   whatDisk:
      {user didn't choose a disk (or no disk attached/problems with config), so bail out}
      AbortInstall;
   goodDisk:
      BEGIN
      {see if he wants to erase (re-initialize) the disk first}
      IF AskAlert (installAlert, 106) = 2 THEN
         {user wants to erase the disk first}
         IF NOT InitNewDisk THEN
            {initialization failed}
            AbortInstall;
       END;
   END; {of CASE block}

{we made it with a good disk, so do it up}
ArgAlert(1, version);
WaitAlert(installAlert, 108);

tempPathname := CONCAT('-',initDevname,'-system.shell');
Kill_Object (err, tempPathname);

sDevName := bootDevName;
sDevPathname := CONCAT('-',sDevName);
dDevName := initDevName;
dDevPathname := CONCAT ('-',dDevName);

{$IFC ForOffice}
{Copy the 'system.=' files from Office System 1 to the disk}
{Set up the loop conditions}
moreSys := TRUE;
Reset_Catalog(err, sDevPathname);              { Reset the sony catalog }
SysErr(148, err);
IF (err > 0) THEN
   AbortInstall;
prefix := 'system.';
Get_Next_Entry(err, prefix, dfName);
IF (err <> 848) THEN
   BEGIN
   SysErr(148, err);
   IF (err > 0) THEN
      AbortInstall;
   END;

{Loop through the sony catalog, looking for system.xxx files}
WHILE moreSys DO
   BEGIN
   sDfPathname := CONCAT (sDevPathname,'-',dfName);
   dDfPathname := CONCAT (dDevPathname,'-',dfName);
   Downshift(@dfName);
   IF (dfName = 'system.shell') THEN               { Don't copy the master program over }
      err := 0                                     { Reset the error value }
   ELSE
      BEGIN
      Kill_Object(err, dDfPathname);
      CopyDiskFile(err, sDfPathname, dDfPathname, MakeFileMode);
      END;
   IF (err > 0) THEN
      BEGIN                          { If err, process according to err  }
      IF dbgInstall THEN WRITELN ('   copying from OS 1, err with ',dDfPathname,': err = ',err:1);
      CASE err OF
         fceOutOfDiskSpace: StopAlert (installAlert, 109);
         fceCantRead:  StopAlert (installAlert, 111);
         fceCantWrite: StopAlert (installAlert, 110);
         fceAborted:   StopAlert (installAlert, 115);
         OTHERWISE     SysErr (148, err);
         END; {of case statement}
      IF (err <> fceNoErrors) THEN
         AbortInstall;
      END;
   Get_Next_Entry(err, prefix, dfName);
   IF (err > 0) THEN
      BEGIN
      MoreSys := FALSE;
      IF (err <> 848) THEN
         SysErr(148, err);
      END;
   END; {of WHILE block}

{now copy the IOSPASLIB.OBJ file over}
sDfPathname := CONCAT (sDevPathname,'-IOSPASLIB.OBJ');
dDfPathname := CONCAT (dDevPathname,'-IOSPASLIB.OBJ');
Kill_Object (err, dDfPathname);
CopyDiskFile(err, sDfPathname, dDfPathname, MakeFileMode);
IF (err > 0) THEN
   BEGIN                          { If err, process according to err  }
   IF dbgInstall THEN WRITELN ('   err copying ',dDfPathname,': err = ',err:1);
   CASE err OF
      fceInUse:     err:=fceNoErrors; { Diskfile being written to         }
      fceOutOfDiskSpace: StopAlert (installAlert, 109);
      fceCantRead:  StopAlert (installAlert, 111);
      fceCantWrite: StopAlert (installAlert, 110);
      fceAborted:   StopAlert (installAlert, 115);
      OTHERWISE     SysErr (148, err);
      END; {of case statement}
   IF (err <> fceNoErrors) THEN
      AbortInstall;
   END; {of IF THEN block}
{$ENDC}

{Dismount the boot device}
IF (NOT bootUnmounted) THEN
   IF (NOT Dismount (bootPos, EjectIt, BootDisk)) THEN
      AbortInstall;

Diskcount := 2;                                       { Already used System disk #1, so set to 2 }
noMore    := FALSE;                                   { Set to true when install is over with }
Mounted   := FALSE;                                   { Set to true when a diskette is ready to be copied }

{ Note...In this version of the software no diskettes besides the Office System Diskettes are
  loaded.  This is to avoid the problem of having the user load in additional files with duplicate
  names (ie. the user erases the disk, loads the system software, then loads in two files with
  similar names, creating severe problems with the Filer).}

REPEAT
   IF dbgInstall THEN WRITELN ('   DiskCount = ',Diskcount);

   IF (NOT Dismount (bootPos, EjectIt, NotBoot)) THEN
      AbortInstall;

   IntToStr (diskCount, tempString);
   ArgAlert (1, tempString);
   IF (AskAlert (installAlert, 117) = 1) THEN         { Ask him to insert Office Software Diskette n }
      NoMore := TRUE;                                 { Cancel of Install }

   IF (NoMore = FALSE) THEN
      BEGIN                        { Valid diskette should be in the drive }
      ArgAlert (1, version);
      WaitAlert (installAlert, 108);                   { 'Installing system software' }

      Mount(err, volName, passWord, sDevName);
      IF dbgInstall THEN WRITELN ('   Mounted diskette, error = ',err:1);
      CASE err OF
        0, -1173, -1174, -1175,                       { Bogus mount errors, don's sweat it }
        1052:  BEGIN
               IF CheckLisaGuide THEN                 { Can't Install LisaGuide Diskette }
                  Mounted := FALSE
               ELSE                                   { not a lisaguide, so }
                  BEGIN                               { start checking for version compatibility, etc }
                  Mounted := TRUE;
                  IF NOT ValidDiskette (Volname, DiskCount) THEN  { Right disk for Version, etc }
                     Mounted := FALSE;                { Not the right version and/or name, so don't load }
                  END;
               END;

        1053:  BEGIN                                  { Reinserted the OffSys/Pascal... 1 diskette }
               EjectDiskette;
               tempName := CONCAT (auxName,' 1 ',version);
               IF ValidDiskette (tempName, DiskCount) THEN;      { ValidDiskette => 'wrong sequence' }
               Mounted := FALSE;
               END;

        614,                                          { No diskette in place     }
        1062:  Mounted := FALSE;

        606,                                          { Wrong diskette or bad diskette }
        866,
        1054,
        1197:  BEGIN
               Mounted := FALSE;
               EjectDiskette;
               StopAlert (installAlert, 139);
               END;

        1820:  BEGIN                                  { Write protect tab on diskette }
               Mounted := FALSE;
               EjectDiskette;
               StopAlert (installAlert, 202);
               END;

        OTHERWISE                                     { Unknown error message, stop the install }
               BEGIN
               Mounted := FALSE;
               EjectDiskette;
               SysErr(141, err);
               AbortInstall;
               END; {of CASE ITEM OTHERWISE}
        END; {of CASE block}
     END; { of IF NoMore = FALSE block }

   IF ((Mounted) AND (NoMore = FALSE)) THEN            { Diskette mounted, valid & we're ok }
      BEGIN
      IF (LookForMasters(sDevName) = TRUE) THEN        { User didn't chicken out of deflowering, so}
         BEGIN                                         { copy all of the diskette to the profile }
         { Don't copy filer files, but overwrite everything on the profile }
         CopyAllDiskFiles(err, sDevPathname, dDevPathname, InstallMode);
         IF dbgInstall THEN WRITELN ('   Copied all disk files, error = ',err:1);
         IF (err <= 0) THEN
            BEGIN
            IF (DiskCount = MaxOsDisks) THEN           { Last System software disk copied }
               BEGIN                                   { This block now assumes no other diskettes to load }
               SetFadeDelay (fadeDelay);               { Get the user's attention }
               IF (NOT Dismount(bootPos, EjectIt, NotBoot)) THEN;   { Eject the last Office System diskette }
               NoMore := TRUE;                         { Make sure no additional software added }
               END;
            DiskCount := DiskCount + 1                 { Increment only with a successful copy }
            END
         ELSE                                          { err > 0... }
            BEGIN
            CASE err OF                                { Error while attempting to copy disk }
               fceCantRead:         alertNum := 144;
               fceCantWrite:        alertNum := 142;
               fceOutOfDiskSpace:   alertNum := 143;
               OTHERWISE            alertNum := 133;
               END; { of case block }
            StopAlert(installAlert, alertNum);
            noMore := TRUE;                            { stop the installation }
            END; {of ELSE block}
         END;
      Mounted := FALSE;
      END; { of copying this particular diskette }

   UNTIL NoMore;

IF (DiskCount < MaxOsDisks + 1) THEN                  { Diskcount always incremented after a succ. copy }
   goodInstall := FALSE
ELSE
   BEGIN
   tempPathname := CONCAT('-',initDevName,'-shell.system');
   tempName := 'system.shell';
   IF dbgInstall THEN WRITELN ('Renaming ',tempPathname,' to ',tempName);
   Rename_Entry (err, tempPathname, tempName);
   IF ErrorFound (warnError, 146, err) THEN
      BEGIN
      IF dbgInstall THEN WRITELN ('   Renaming shell.system, error = ',err:1);
      goodInstall := FALSE;
      END;
   END;

{$IFC ForOffice}
IF (SetCatName = FALSE) THEN                             { Try to make '#Catalog' on the profile }
   BEGIN
   NoteAlert (installAlert, 145);                        { Should try to scavange here }
   IF Repair THEN
      IF (NOT SetCatName) THEN
         NoteAlert (installAlert, 146)                   { Software on disk but some trouble w/disk }
      ELSE
   ELSE NoteAlert (installAlert, 126)                    { Couldn't repair disk, so trouble w/disk.. }
   END;
{$ENDC}

{Re-write the boot tracks to give the user that safe, warm fuzzy feeling of total security }

{ First remount the boot volume }
GetString(309, @situation);
MountBoot (err, situation);
IF (err > 0) THEN
   AbortInstall;

IF dbgInstall THEN WRITELN ('Dismounting the disk, about to write the boot tracks');
IF (NOT Dismount(initPos, dontEject, notBoot)) THEN
   AbortInstall;
fsParams.command := writeBT;
fsParams.dev_name := initDevName;
Fs_Utilities (err, fsParams);
IF ErrorFound(warnError, 147, err) THEN
   BEGIN
   goodInstall := FALSE;
   IF dbgInstall THEN WRITELN ('   Writing boot tracks to device ',initDevName,', error = ',err:1);
   END;

99:
{finished all the install stuff, now give the final alert}
IF (goodInstall) THEN
   NoteAlert (installAlert, 128)                      { Startup software installed }
ELSE
   NoteAlert(installAlert, 147);                      { Startup software not installed }

SetFadeDelay (fadeDelay);                             { Wake the user up w/a screen brighten }

IF dbgInstall THEN WRITELN ('   [Install], exit ');
END; {of PROC Install}

{****************************************************************************}
PROCEDURE IntToStr {number: LongInt; VAR str: NumberStr};
{ Converts an integer into a string - from FGlobals }

VAR
   i,
   numDigits : INTEGER;
   negative  : BOOLEAN;
   bkwdStr   : NumberStr;

BEGIN
negative := (number < 0);
numDigits := 0;

REPEAT
   numDigits := numDigits + 1;
   bkwdStr[numDigits] := CHR(ORD('0') + ABS(number MOD 10));
   number := number DIV 10;
UNTIL (number = 0);

IF negative THEN BEGIN
   numDigits := numDigits + 1;
   bkwdStr[numDigits] := '-';
   END;

FOR i := 1 TO numDigits DO
   str[i] := bkwdStr[numDigits-i+1];

{$R-}
str[0] := CHR(numDigits);

{$IFC OfficeDebug }
   {$R+ }
{$ENDC }
END; { of procedure IntToStr }



{****************************************************************************}
PROCEDURE LastWishes {* environPtr: P_env_blk; excepDataPtr: P_term_ex_data *};
{ Exception Handler called by the OS when Install dies }

VAR
   err         : INTEGER;
   termEventBlk: S_EventBlk;

BEGIN
IF dbgX THEN WRITELN ('last wishes, whydied = ', excepDataPtr^.excep_Kind:1);

IF (excepDataPtr^.excep_Kind <> call_term) THEN
   BEGIN
   termEventBlk[1] := RestartThisShell;
   Terminate_Process(err, @termEventBlk);
   SysErr (160, err);
   END;
END; {of PROC LastWishes}

{****************************************************************************}
FUNCTION LookForMasters {* devName: E_Name) : BOOLEAN *};
{ Looks for files on the diskette with the protected and master flags set and
  the machine ID = 0.  If found, asks the user if he wants to deflower it..If
  yes, sets the machine ID to the working system's ID number. }

VAR
   err            : INTEGER;
   dfInfo         : fs_info;
   dfName         : E_Name;
   dfPathname     : Pathname;
   MachineNumber  : LongInt;
   prefix         : E_Name;
   sDevPathname   : PathName;

   {----------------------------------------------------------------------------}
   PROCEDURE CheckErr (Error: INTEGER);

   BEGIN
   IF ErrorFound(warnError, 170, error) THEN
      BEGIN
      LookForMasters := FALSE;
      EXIT (LookForMasters);
      END;
   END; { of procedure CheckErr }

   {----------------------------------------------------------------------------}

BEGIN
IF dbgInstall THEN WRITELN ('[LookForMasters], entry ');

sDevPathname := CONCAT ('-', devName);
Reset_Catalog (err, sDevPathname);
CheckErr (err);
{$IFC ForOffice}
   prefix := '{T';            {deflowering master tools}
{$ELSEC}
   prefix := '';              {deflowering all files}
{$ENDC}
Get_Next_Entry (err, prefix, dfName);
IF dbgInstall THEN WRITELN ( 'Looking for master tools, finished reseting catalog, etc. ');
WHILE (err = 0) DO
   BEGIN
   dfPathname := CONCAT (sDevPathname, '-', dfName);
   Lookup (err, dfPathname, dfInfo);
   CheckErr (err);
   IF (dfInfo.protected AND dfInfo.master_File) THEN
      BEGIN
      IF dbgInstall THEN
         WRITELN (' Found a master tool : ',dfPathname,' from ',dfInfo.machine_ID:1);
      IF (dfInfo.machine_ID = 0) THEN
         BEGIN
         Get_Serial_No (err, MachineNumber);
         CheckErr (err);
         PROTECT (err, dfPathname, TRUE, MachineNumber); { it is a master, and set the machine number }
         CheckErr (err);
         END;
      END;
   Get_Next_Entry (err, prefix, dfName);
   IF (err <> 848) THEN
      CheckErr(err);
   END; { of While loop }

LookForMasters := TRUE;

IF dbgInstall THEN WRITELN ('   [LookForMasters], exit');
END; { of function LookForMasters }

{****************************************************************************}
PROCEDURE MakeCopyDataSeg;
{ Make the data seg for program, sets the following global vars :
     copyDsRefnum : the dataseg reference number
     copyDsAddr   : pointer to the data segment area in memory }


VAR copyDsInfoRec : DsInfoRec;
    copyDsName    : Pathname;
    err           : INTEGER;

BEGIN
IF dbgInstall THEN WRITELN ('[MakeCopyDataSeg], entry');

copyDsName := copyDsDfName;                      { Memory data seg for disk copy }

Make_DataSeg (err, copyDsName, copyDsSize, 0, copyDsRefnum, copyDsAddr, dfCopyLDSN, ds_Private);
copyDsMemSize := copyDsSize;

IF ErrorFound (fatalError, 885, err) THEN;

IF dbgInstall THEN WRITELN ('   exit MakeCopyDataSeg');
END; { of procedure MakeCopyDataSeg }

{****************************************************************************}
PROCEDURE MakeDevName {* thePos: CD_Position; VAR devName: E_Name *};
{turns the cd_position info into a valid '#1#2#6' name}

VAR
   tempNum  : NumberStr;

BEGIN
devName := '';
IF (thePos.slot = 0) THEN
   EXIT(MakeDevName);

IntToStr (thePos.slot, tempNum);
devName := CONCAT('#',tempNum);
IF (thePos.chan <> 0) THEN
   BEGIN
   IntToStr (thePos.chan, tempNum);
   devName := CONCAT(devName,'#',tempNum);
   IF (thePos.dev <> 0) THEN
      BEGIN
      IntToStr (thePos.dev, tempNum);
      devName := CONCAT(devName,'#',tempNum);
      END;
   END;
END; {of PROC MakeDevName}

{****************************************************************************}
FUNCTION MatchIDDrvr {* theID: INTEGER; VAR theIndex: INTEGER) : BOOLEAN *};
{If theID is known, returns the index into drvrList[] for the driver}

VAR
   index    : INTEGER;
   theName  : E_Name;

BEGIN
IF dbgConfig THEN WRITELN('[MatchIDDrvr], entry: driver ID = ',theID);

CASE theID OF
   34: theIndex := TwoPortCloc;  { system.cd_2 port card }
   35: theIndex := ProfDloc;     { system.cd_profile }
   37: theIndex := PriamCloc;    { system.cd_priam card }
   38: theIndex := PriamDloc;    { system.cd_priam disk }
   39: theIndex := ArchiveTloc;  { system.cd_archive tape }
   OTHERWISE
      BEGIN
      IF dbgConfig THEN WRITELN('   [MatchIDDrvr], exit: No name for ID.');
      theIndex := 0;
      MatchIDDrvr := FALSE;
      EXIT(MatchIDDrvr);
      END;
   END; {of CASE block}
MatchIDDrvr := TRUE;

IF dbgConfig THEN WRITELN('   [MatchIDDrvr], exit');
END; {of FUNC MatchIDDrvr}

{****************************************************************************}
FUNCTION MatchNameDrvr {* driverName: E_Name; VAR theIndex: INTEGER) : BOOLEAN *};
{returns the index into drvrList[] of the driver <driverName>, otherwise returns FALSE}

VAR
   i   : INTEGER;

BEGIN
MatchNameDrvr := TRUE;
FOR i := 1 TO LastDrvr DO
   IF (drvrList[i].name = driverName) THEN
      BEGIN
      theIndex := i;
      EXIT(MatchNameDrvr);
      END;
MatchNameDrvr := FALSE;
END; {of FUNC MatchNameDrvr}

{****************************************************************************}
PROCEDURE MountBoot {* var error: INTEGER; situation: str255 *};

VAR
   fsParams:  ut_parmt;

BEGIN

IF dbgInstall THEN WRITELN ('[MountBoot], entry: situation = ',situation);

IF (NOT bootUnmounted) THEN
   BEGIN
   error := 0;
   EXIT(MountBoot);
   END;

{ If there's a diskette in the slot, eject it }
IF (NOT Dismount (bootPos, EjectIt, NotBoot)) THEN
   BEGIN
   error := 1;
   EXIT(MountBoot);
   END;

WHILE bootUnmounted DO
   BEGIN
   ArgAlert (1, situation);
   IF (AskAlert (installAlert, 208) = 1) THEN   { Ask: 'boot diskette must be reinserted at this time' }
      BEGIN                                  { User cancelled boot remount }
      Error := fBootNotMounted;
      EXIT (MountBoot);
      END;

   fsParams.command := boot_remount;
   fs_Utilities (error, fsParams);
   IF dbgInstall THEN WRITELN ('   Boot remount, error = ',error:1);
   IF (Error > 0) THEN
      CASE Error OF
         614:        { No diskette in place }
            BEGIN END;
         1144:       { Not the boot diskette }
            BEGIN
            EjectDiskette;
            StopAlert (installAlert, 209);
            END;
         OTHERWISE
            BEGIN
            IF dbgInstall THEN WRITELN ('   [MountBoot], exit: Unknown error from boot_remount');
            SysErr (250, Error);
            EXIT (MountBoot);
            END;
         END { of case block }
   ELSE
      bootUnmounted := FALSE;
   END; { of WHILE bootUnmounted block }

IF dbgInstall THEN WRITELN ('   [MountBoot], exit');
END; {of PROC MountBoot}

{****************************************************************************}
PROCEDURE MountInit {* VAR result: TInitDisk *};
{mounts the disk to initialize, handles errors accordingly, sets up the initPos,
 initDevName, initVolName correctly}

CONST
   Port2ID     = 2;        { Identity value returned by Cards_Equipped for the 2-Port card }
   PriamID     = 5;        { Identity value returned by Cards_Equipped for the Priam card }

VAR
   cardDrvrLoc : INTEGER;           {index to drvrList[] for specified disk card}
   config      : ConfigDev;
   devName     : E_Name;
   drvrName    : E_Name;
   err         : INTEGER;
   foundOne    : BOOLEAN;           { TRUE => at least one valid disk attached to the Lisa }
   fsInfo      : Fs_Info;
   index       : INTEGER;
   keepGoing   : BOOLEAN;
   path        : Pathname;
   pmRec       : PMemRec;
   thePath     : Pathname;

   {------------------------------------------------------------------------}
   PROCEDURE Abort (location: INTEGER; errorNum: INTEGER);
   {displays the alert, quits gracefully}

   BEGIN
   IF dbgConfig THEN WRITELN ('[Abort], entry: location = ',alertNum:1,', error = ',errorNum:1);
   IF ErrorFound(warnError, location, errorNum) THEN
      BEGIN END;
   result := noDisk;
   EXIT(MountInit);
   END; {of PROC Abort}

   {------------------------------------------------------------------------}
   PROCEDURE CheckErr (error: INTEGER);
   {make sure that the OS call returned an OK value, else let the user know about it}

   BEGIN
   IF ErrorFound(warnError, 261, error) THEN
      BEGIN
      IF dbgConfig THEN WRITELN ('   [CheckErr]: error = ',error:1);
      result := noDisk;
      EXIT(MountInit);
      END;
   END; {of PROC CheckErr}

   {------------------------------------------------------------------------}
   PROCEDURE MountDisk (devName: E_Name);
   {mounts the initialization disk, sets up the result value}

   VAR
      mountErr : INTEGER;

   BEGIN

   Mount(mountErr, initVolName, password, devName);
   CASE mountErr OF        { MountErr is returned during the MOUNT call }
      614,
      660,
      666,
      1051,
      1061,
      1062,
      1091,                { No such entry }
      1092,                { No such entry found }
      1101,
      1882,                { Profile bad response }
      1885:                { Profile time-out }
         BEGIN             { General symptom: No disk attached to initPos connector }
         result := noDisk;
         END;

      606,
      625,                 { Bogus scavenger error, monitor files on disk }
      663,                 { Checksum error }
      866,                 { Bad MDDF header of OS file structure }
      1054,
      1197:                { General symptom: New disk/invalid file system }
         BEGIN
         result := newDisk;
         END;

      0,
      -626,
      1052,
      -1059,
      -1174,
      -1175:               { General symptom: Previously initialized profileDev is mounted }
         BEGIN
         result := goodDisk;
         END;

      OTHERWISE                       { hmmm, something that we're not prepared to handle }
         BEGIN
         result := badDisk;
         END;
      END; {of CASE block}

   IF dbgConfig THEN WRITELN ('[MountDisk], exit: result value is ',ORD(result):1);
   END; {of PROC MountDisk}

   {------------------------------------------------------------------------}
   PROCEDURE SetAlertArgs (thePosition: CD_Position);
   {set up the arguments for the alert to the user (the location string)}

   VAR
      connector   : str255;
      filler      : STRING[20];
      location    : str255;
      numStr      : NumberStr;

   BEGIN
   IF dbgConfig THEN
      WRITELN ('[SetAlertArgs], entry: slot is ',thePosition.slot:1,' chan is ',thePosition.chan:1);

   CASE (thePosition.slot) OF
      1,2,3,4,5,6,7,8,9:
         BEGIN
         {expansion slot card}
         GetString(310, @location);    {'expansion slot'}
         IntToStr(thePosition.slot, numStr);
         location := CONCAT(location,' ',numStr); {'expansion slot 3'}
         CASE (thePosition.chan) OF
            1: alertNum := 312;
            2: alertNum := 311;
            OTHERWISE alertNum := 312;
            END;
         GetString(alertNum, @connector);
         location := CONCAT (connector,', ',location);   {'upper connector, expansion slot 3'}
         CASE (slots[thePosition.slot]) OF
            PriamID: alertNum := 318;
            Port2ID: alertNum := 319;
            OTHERWISE alertNum := 319;
            END; {of CASE block}
         GetString(alertNum, @diskString);
         END; {of CASE ITEM 1...9}
      10:
         BEGIN
         {serial port}
         CASE (thePosition.chan) OF
            1: alertNum := 313;
            2: alertNum := 314;
            END; {of CASE block}
         GetString(alertNum, @location);
         GetString(319, @diskString);
         END; {of CASE ITEM 10}
      11:
         BEGIN
         {parallel port}
         GetString(315, @location);
         GetString(319, @diskString);
         END; {of CASE ITEM 11}
      12:
         BEGIN
         {internal disk}
         GetString(316, @location);
         GetString(319, @diskString);
         END; {of CASE ITEM 12}
      OTHERWISE
         BEGIN
         {a bad location, so abort}
         GetString(317, @location);
         GetString(319, @diskString);
         END;
      END; {of CASE block}

   GetString(321, @filler); {'connected to'}
   {eg. 'the Priam' 'connected to' 'the lower connector, expansion slot 1'}
   diskString := CONCAT(diskString,' ',filler,' ',location);
   ArgAlert (1, diskString);

   IF dbgConfig THEN WRITELN ('   [SetAlertArgs], exit: diskString is ',diskString);
   END; {of PROC SetAlertArgs}

   {------------------------------------------------------------------------}
   PROCEDURE SetDevices;
   {create the list of devices for asking the user}

   VAR
      i           : INTEGER;
      index       : INTEGER;
      index2      : INTEGER;
      prefix      : E_Name;

      {------------------------------------------------------------------}
      PROCEDURE GetDrvrInfo;
      {Parse the CDD file to find out the driver information for the CDMake call, must
       be preceeded by call to GetDrvrNames}

      VAR
         actual   : LongInt;
         cddDescr : cddHeader;
         cddRec   : cddEntry;
         dumpName : E_Name;
         i,j      : INTEGER;
         matchIndex  : INTEGER;
         nameCDD  : Pathname;
         refCDD   : INTEGER;

      {++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
      PROCEDURE AbortClose (alertNum, alertLoc: INTEGER);

      BEGIN
      Close_Object(err, refCDD);          { Close the CDD file before aborting }
      Abort(alertNum, alertLoc);
      END; {of PROC AbortClose}
      {++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}

      BEGIN
      IF dbgConfig THEN WRITELN('[GetDrvrInfo], entry: disk type value is ',ORD(diskType):1);

      {open the SYSTEM.CDD file}
      nameCDD := CONCAT('-',bootDevName,'-system.cdd');
      OPEN(err, nameCDD, refCDD, [dread, dwrite]);
      CheckErr(err);
      {read all cdd entries}
      {read SYSTEM.CDD header}
      READ_DATA(err, refCDD, ord4(@cddDescr), sizeof(cddHeader), actual, sequential, 0);
      CheckErr(err);
      IF (actual <> sizeof(cddheader)) OR (cddDescr.cdcount < 0) THEN
         {SYSTEM.CDD has a bad header descriptor/is in a bad format}
         AbortClose(262, 0);

      {read SYSTEM.CDD entries}
      FOR i := 1 TO cddDescr.cdcount DO
         BEGIN
         READ_DATA(err, refCDD, ord4(@cddRec), sizeof(cddEntry), actual, sequential, 0);
         IF (err > 0) or (actual <> sizeof(cddEntry)) THEN
            {SYSTEM.CDD entry is bad}
            AbortClose(262, 3);

         DownShift(@cddRec.drvr_name);
         IF MatchIDDrvr(cddRec.info.driver_id, matchIndex) THEN
            WITH drvrList[matchIndex] DO
               BEGIN
               infoBuf.cd_drvrname     := cddRec.drvr_name;
               infoBuf.cd_driverID     := cddRec.info.driver_id;
               infoBuf.cd_preload      := cddRec.info.preload;
               infoBuf.cd_perm         := cddRec.info.permanent;
               infoBuf.cd_devT         := cddRec.info.deviceType;
               infoBuf.cd_removable    := cddRec.info.removable;
               infoBuf.cd_ejectable    := cddRec.info.ejectable;
               infoBuf.cd_fs_start     := cddRec.info.fs_start_block;
               infoBuf.cd_start_block  := cddRec.info.start_block;
               hasInfo                 := TRUE;
               END; {of IF THEN block}

         {clean off attachment data}
         IF (cddRec.info.numAttach > 0) THEN
            FOR j := 1 to cddRec.info.numAttach DO
               READ_DATA(err, refCDD, ord4(@dumpName), sizeof(TypeConnect), actual,
                         sequential, 0);

         {clean off connectors data}
         IF (cddRec.info.numConnectors > 0) THEN
            FOR j := 1 to cddRec.info.numConnectors DO
               READ_DATA(err, refCDD, ord4(@dumpName), sizeof(TypeConnect), actual,
                         sequential, 0);

         END; {of FOR loop}

      Close_Object(err, refCDD);          { Close the system.CDD file }

      IF dbgConfig THEN WRITELN ('   [GetDrvrInfo], exit');
      END; {of PROC GetDrvrInfo}

      {------------------------------------------------------------------}
      PROCEDURE GetDrvrNames;
      {Check that all needed drivers (system.cd_xxx files) are on the sony.
       Could move this up into a procedure called from Initialize.}

      VAR
         drvrName : E_Name;
         index    : INTEGER;
         prefix   : E_Name;
         thePath  : PathName;

      BEGIN
      IF dbgConfig THEN WRITELN ('[GetDrvrNames], entry');

      {now loop through the sony, looking for 'system.cd_xxxxx' driver entries}
      thePath := CONCAT('-',bootDevName);
      Reset_Catalog(err, thePath);
      CheckErr(err);
      index := 0;
      prefix := 'system.cd_';
      Get_Next_Entry(err, prefix, drvrName);
      IF (err > 0) THEN
         Abort(263, 0);
      REPEAT
         DownShift(@drvrName);
         IF MatchNameDrvr(drvrName, index) THEN
            drvrList[index].hasFile := TRUE;
         Get_Next_Entry(err, prefix, drvrName);
         IF (err <> 848) THEN
            CheckErr(err);
         UNTIL (err > 0);

      FOR index := 1 TO LastDrvr DO
         IF (NOT drvrList[index].hasFile) THEN
            {all drivers must be present on the diskette}
            Abort(263, 1);

      IF dbgConfig THEN WRITELN ('   [GetDrvrNames], exit');
      END; {of PROC GetDrvrNames}

      {------------------------------------------------------------------}
      PROCEDURE InitDrivers;
      {Do CDMake for each of the device drivers found}

      VAR
         index    : INTEGER;
         tempPos  : cd_position;

         {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
         PROCEDURE InstallDrvr (theListLoc: INTEGER; theDevLoc: Cd_Position);

         VAR
            i        : INTEGER;
            tempLoc  : CD_Position;

         BEGIN
         IF (theListLoc <> 0) THEN
            IF (drvrList[theListLoc].hasInfo) THEN
               BEGIN
               CDMake(err, theDevLoc, drvrList[theListLoc].infoBuf);
               IF dbgConfig THEN WRITELN('CDMake on ',theDevLoc.slot:1,', chan ',theDevLoc.chan:1,
                                    ', error = ',err:1);
               CheckErr(err);
               END;
         END; {of PROC InstallDrvr}

         {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}

      BEGIN
      IF dbgConfig THEN WRITELN ('[InitDrivers], entry: lastDevEntry = ',lastDevEntry:1);

      {first do CDKill on everything important}
      tempPos.slot := 1;
      tempPos.chan := 0;
      tempPos.dev  := 0;
      REPEAT
         tempPos.chan := 3;
         REPEAT
            CDKill(err, tempPos);
            IF dbgConfig THEN WRITELN ('CDKill on slot ',tempPos.slot:1,', chan ',tempPos.chan:1,
                                  ', error = ',err:1);
            tempPos.chan := tempPos.chan - 1;
            {last channel to do CDKill on is the actual slot (slot x, chan 0, dev 0)}
            UNTIL (tempPos.chan < 0);
         tempPos.slot := tempPos.slot + 1;
         UNTIL (tempPos.slot > 12);

      {next do the CDMake for all the cards}
      tempPos.slot := 0;
      tempPos.chan := 0;
      tempPos.dev  := 0;
      FOR index := 1 TO 3 DO
         BEGIN
         tempPos.slot := index;
         CASE (slots[index]) OF
            Port2ID: InstallDrvr(TwoPortCloc, tempPos);
            PriamID: InstallDrvr(priamCloc, tempPos);
            OTHERWISE BEGIN END;
            END; {of CASE block}
         END; {of FOR loop}

      {now do the CDMake for all the potential disks (and archive tape)}
      FOR index := 1 TO lastDevEntry DO
         BEGIN
         IF (devList[index].diskDrvrPos > 0) THEN
            {has a driver, ie. isn't driverless or a built-in device (widget)}
            InstallDrvr(devList[index].diskDrvrPos, devList[index].position);
         END; {of FOR loop}

      IF dbgConfig THEN WRITELN ('   [InitDrivers], exit');
      END; {of PROC InitDrivers}

      {------------------------------------------------------------------}
      PROCEDURE NewDevEntry (VAR theIndex: INTEGER);
      BEGIN
      theIndex := theIndex + 1;
      devList[theIndex].position.slot := 0;
      devList[theIndex].position.chan := 0;
      devList[theIndex].position.dev  := 0;
      devList[theIndex].devName       := '';
      devList[theIndex].diskDrvrPos   := 0;
      devList[theIndex].cardDrvrPos   := 0;
      devList[theIndex].isDisk        := FALSE;
      END; {of PROC NewDevEntry}

      {------------------------------------------------------------------}
      PROCEDURE SetDevPos (theIndex, theSlot, theChan: INTEGER);
      {Sets devList[theIndex] using <theSlot>, <theChan>}

      BEGIN
      devList[theIndex].position.slot := theSlot;
      devList[theIndex].position.chan := theChan;
      devList[theIndex].position.dev  := 0;
      MakeDevName(devList[theIndex].position, devList[theIndex].devName);
      END; {of PROC SetDevPos}

      {------------------------------------------------------------------}
   BEGIN
   IF dbgConfig THEN WRITELN ('[SetDevices], entry');

   {first check that all the needed files are on the boot sony}
   GetDrvrNames;
   {load drvrList[].infobuf w/data from system.cdd file}
   GetDrvrInfo;
   index := 0;
   NewDevEntry(index);
   {first generate machine-dependent list}
   CASE (machineType.io_board) OF
      IOLisa, IOLisaLite:
         BEGIN
         {parallel port}
         SetDevPos(index,11,0);
         {assume profile driver}
         devList[index].diskDrvrPos := ProfDloc;
         devList[index].cardDrvrPos := NoCard;
         END;
      IOPepsi:
         BEGIN
         {internal disk}
         SetDevPos(index,12,0);
         devList[index].diskDrvrPos := ProfDloc;
         devList[index].cardDrvrPos := NoCard;
         END;
      IOPepsiLite:
         BEGIN
         {no internal disk or parallel port}
         END;
      END; {of CASE block}

   FOR i := 1 TO 3 DO
      BEGIN
      CASE slots[i] OF
         Port2ID:
            BEGIN
            {make two entries for the upper and lower connector}
            NewDevEntry(index);
            SetDevPos(index, i, 1);
            devList[index].diskDrvrPos := ProfDloc;
            devList[index].cardDrvrPos := TwoPortCloc;
            NewDevEntry(index);
            SetDevPos(index, i, 2);
            devList[index].diskDrvrPos := ProfDloc;
            devList[index].cardDrvrPos := TwoPortCloc;
            END;
         PriamID:
            BEGIN
            NewDevEntry(index);
            SetDevPos(index, i, 1);
            devList[index].diskDrvrPos := PriamDloc;
            devList[index].cardDrvrPos := PriamCloc;
            NewDevEntry(index);
            SetDevPos(index, i, 3);
            devList[index].diskDrvrPos := ArchiveTloc;
            devList[index].cardDrvrPos := PriamCloc;
            END;
         OTHERWISE
            BEGIN END;
         END; {of CASE block}
      END; {of FOR loop}
   lastDevEntry := index;
   IF dbgConfig THEN WRITELN ('   There were ',lastDevEntry:1,' device locations for the Lisa.');
   {do CDMake for the appropriate driver at each location (cards and disks)}
   InitDrivers;
   {now check each potential device to see if it's a disk, set devList[].isDisk flag}
   FOR index := 1 TO lastDevEntry DO
      BEGIN
      IF (devList[index].diskDrvrPos > 0) THEN
         BEGIN
         {we now know that the disk has a driver}
         thePath := CONCAT('-',devList[index].devName);
         IF dbgConfig THEN WRITELN('   Doing LOOKUP on ',thePath);
         LookUp(err, thePath, fsInfo);
         IF (err <= 0) AND (fsInfo.devT = diskDev) THEN
            devList[index].isDisk := TRUE;
         END; {of IF THEN block}
      END; {of FOR loop}
   IF dbgConfig THEN WRITELN ('   [SetDevices], exit');
   END; {of PROC SetDevices}

   {------------------------------------------------------------------------}
{start of main procedure body}
BEGIN
IF dbgConfig THEN WRITELN ('[MountInit], entry');

IF (diskSet) THEN
   BEGIN
   ArgAlert(1, diskString);
   IF (AskAlert(installAlert, 141) = 1) THEN
      BEGIN
      IF dbgConfig THEN WRITELN('   [MountInit], exit: diskSet is TRUE, user did not change.');
      result := goodDisk;
      EXIT (MountInit);          { we've already mounted the initialization disk }
      END;
   END;

{reset the return value and all the global disk variables}
result := noDisk;
IF (NOT diskSet) THEN
   BEGIN
   initPos.slot := 0;
   initPos.chan := 0;
   initPos.dev  := 0;
   initDevName  := '';
   initVolName  := '';
   END;

{start the device loop, asking the user about each one, until he selects one,
 bails out or reaches the last possible disk.  Remember to tell the user he
 fucked up if he bails out or doesn't ever select a disk}

WaitAlert(installAlert, 163);    { 'Alert: Lisa is locating...disks' }

IF (NOT drvrsSet) THEN
   BEGIN
   {create the devList[] entries (CDMake for drivers, isDisk set correctly)}
   SetDevices;
   drvrsSet := TRUE;
   END;
index := 1;
foundOne := FALSE;
keepGoing := TRUE;
WHILE (keepGoing) DO
   BEGIN
   IF dbgConfig THEN
      BEGIN
      WRITELN('   Index ',index:1,' of device list at slot ',devList[index].position.slot:1,', channel');
      WRITELN('   ',devList[index].position.chan:1,' with name ',devList[index].devName,' ===>');
      IF (devList[index].isDisk) THEN
         WRITELN ('   This location is configured for a disk.');
      END; {of IF THEN block}
   IF (devList[index].isDisk) THEN
      MountDisk(devList[index].devName)
   ELSE
      result := noDisk;
   IF (result <> noDisk) THEN
      BEGIN
      {we have a disk in place, possible damaged, but go for it}
      foundOne := TRUE;
      SetAlertArgs (devList[index].position);
      CASE AskAlert (installAlert, 160) OF
         1: {Quit}
            BEGIN
            keepGoing := FALSE;
            IF Dismount(devList[index].position, FALSE, FALSE) THEN;
            {set user weenied out value}
            result := whatDisk;
            END;
         2: {go with this turkey}
            BEGIN
            keepGoing := FALSE;
            diskSet := TRUE;
            initPos := devList[index].position;
            MakeDevName(initPos, initDevName);
            {set up disk type based on what kind of disk driver is specified by devList[index]}
            IF (devList[index].diskDrvrPos = priamDloc) THEN
               diskType := PriamDisk
            ELSE IF (initPos.slot = 12) THEN
               diskType := WidgetDisk
            ELSE
               diskType := ProfileDisk;
            CheckPMList(index);       {make sure it's in parameter memory, otherwise add it}
            END;
         3: {keep going}
            BEGIN
            IF Dismount(devList[index].position, FALSE, FALSE) THEN;
            END;
         END; {of CASE block}
      END; {of IF THEN block}
   index := index + 1;
   IF (index > lastDevEntry) THEN
      BEGIN
      IF (NOT foundOne) THEN
         BEGIN
         {no usable disks were found, abort from the shell}
         IF (machineType.io_board = IOPepsi) THEN
            alertNum := 164
         ELSE
            alertNum := 162;
         IF (AskAlert(installAlert, alertNum) = 1) THEN
            Finished(restart)
         ELSE
            Finished(off);
         END
      {user has cycled through all possible choices, had a chance to select at least one}
      ELSE IF (keepGoing) THEN
         {user was still trying to select a disk, as opposed to cancelling out}
         CASE (AskAlert (installAlert, 161)) OF
            1: BEGIN {try again}
               index := 1;
               foundOne := FALSE;
               END;
            2: BEGIN {cancel}
               result := whatDisk;
               keepGoing := FALSE;
               END;
            END; {of CASE block}
      END; {of IF THEN block}
   END; {of WHILE block}

IF dbgConfig THEN WRITELN('   [MountInit], exit');
END; {of PROC MountInit}

{****************************************************************************}
PROCEDURE Quit;

VAR
   attributes  : Q_Info;
   err         : INTEGER;
   mounted     : BOOLEAN;
   situation   : str255;
   tempPathname: Pathname;
   volName     : E_Name;

BEGIN
IF dbgX THEN WRITELN ('[Quit], entry');

GetString(303, @situation);
MountBoot(err, situation);
IF (err > 0) THEN EXIT (Quit);

{ Successful remount of the boot diskette }

IF (diskSet) THEN
   BEGIN
   {we must have indicated and mounted a disk, thus check for bootability}
   Mount(err, volName, password, initDevName);
   IF dbgX THEN WRITELN('   Mounting ',initDevName,', error = ',err:1);
   tempPathname := CONCAT ('-',initDevname,'-system.shell');
   Quick_LookUp(err, tempPathname, Attributes);
   IF dbgX THEN WRITELN('   Lookup on ',tempPathname,', error = ',err:1);
   IF (err > 0) THEN                                  { Didn't find 'system.shell', so tell user that}
      CASE AskAlert (installAlert, 148) OF
         1: Finished (off);
         2: EXIT (Quit);                              { Go back to the main menu }
         END;
   END;

{ 'System.shell' was there (so we assume that the disk is bootable), or nothing ever was mounted }

CASE AskAlert (installAlert, 124) OF
  1: Finished (off);
  2: Finished (reboot);
  END;
END;


{****************************************************************************}
FUNCTION Repair {* : BOOLEAN *};

VAR
   devPathname  : Pathname;
   err          : INTEGER;
   fsInfo       : Fs_Info;
   fsParams     : Ut_Parmt;
   mounterr,
   repairErr    : INTEGER;
   result       : TInitDisk;
   situation    : str255;

   {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
   PROCEDURE AbortRepair (theError: INTEGER);
   {something went wrong, tell user and finish}

   VAR
      numStr   : NumberStr;

   BEGIN
   IF dbgInstall THEN WRITELN ('   [Repair], exit: aborting');
   IF (theError > 0) THEN
      BEGIN
      IntToStr(theError, numStr);
      ArgAlert(1, '200/');
      ArgAlert(2, numStr);
      StopAlert (installAlert, 103);
      END;
   Repair := FALSE;
   EXIT(Repair);
   END;

   {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}

BEGIN
IF dbgInstall THEN WRITELN ('[Repair], entry');

GetString(304, @situation);
MountBoot (err, situation);
IF (err > 0) THEN
   AbortRepair(0);

{ Successful remount of the boot diskette }

MountInit (result);
CASE (result) OF
   noDisk, whatDisk:
      AbortRepair(0);
   OTHERWISE
      BEGIN END;
   END; {of CASE block}

WaitAlert (installAlert, 114);

Unmount(err, initDevName);
IF dbgInstall THEN WRITELN ('   Unmount err = ',err:1,' initdevName = ',initdevName);

IF dbgInstall THEN WRITELN ('   scavenging');
fsParams.command := fsScavenge;
fsParams.sDev_Name := initDevName;
fsParams.sOptions := [];
Fs_Utilities (repairErr, fsParams);
IF dbgInstall THEN WRITELN ('   Scavange error = ',repairErr:1);

IF dbgInstall THEN WRITELN ('   remounting');
Mount (mounterr, initVolName, password, initDevName);
IF dbgInstall THEN WRITELN ('   initVolname = ', initVolName:1, 'Mounterr = ',mounterr:1);
IF (mounterr <= 0) THEN
   BEGIN
   devPathname := CONCAT('-',initDevName);
   Lookup (err, devPathname, fsInfo);
   IF (err <= 0) THEN
      IF fsInfo.scavenge_Flag THEN
         BEGIN
         fsInfo.scavenge_Flag := FALSE;
         fsInfo.vol_left_mounted := FALSE;        { Otherwise an error during future startups w/this vol }
         PSet_Vol_Info (err, devPathname, fsInfo);
         END;
   IF dbgInstall THEN IF err > 0 THEN WRITELN ('   scavenge flag not reset: err = ',err:1);
   END;

SetFadeDelay (fadeDelay);
IF (repairErr > 0) THEN
   AbortRepair(repairErr)
ELSE IF (mountErr > 0) THEN
   BEGIN
   DisplayError(201, mountErr);
   AbortRepair(0);
   END
ELSE
   BEGIN
   NoteAlert (installAlert, 137);
   Repair := TRUE;
   END;

IF dbgInstall THEN WRITELN ('   [Repair], exit: repairErr = ',repairErr:1);
END;

{****************************************************************************}
PROCEDURE Restore;
{Restores the user-selected disk from (priam) the archival
 tape or (profile/widget) sonies}

VAR
   err         : INTEGER;
   result      : TinitDisk;
   situation   : Str255;

   {-------------------------------------------------------------------------}
   PROCEDURE AbortRestore;

   BEGIN
   StopAlert(installAlert, 232);    {Alert: 'The disk was not restored'}
   EXIT(Restore);
   END; {of PROC AbortRestore}

   {-------------------------------------------------------------------------}

BEGIN
IF dbgInstall THEN WRITELN('[Restore], entry');

GetString(305, @situation);
MountBoot(err, situation);
IF (err > 0) THEN
   AbortRestore;

MountInit(result);
CASE (result) OF
   badDisk,
   newDisk,
   goodDisk:
      BEGIN END;
   noDisk,
   whatDisk:
      {user didn't choose a disk (or no disk attached/problems with config), so bail out}
      AbortRestore;
   END; {of CASE block}

IF (CautionAlert (installAlert, 125)) THEN
   IF (NOT InitNewDisk) THEN
      AbortRestore
   ELSE
ELSE
   AbortRestore;

{Note: diskType set in call to MountInit}
IF (diskType = ProfileDisk) OR (diskType = WidgetDisk) THEN
   IF (NOT RestProfile) THEN
      AbortRestore
   ELSE
ELSE
   IF (NOT RestPriam) THEN
      AbortRestore;

NoteAlert(installAlert, 231);    {Alert: 'The disk has been restored'}

IF dbgInstall THEN WRITELN ('   [Restore], exit');
END; {of PROC Restore}

{****************************************************************************}
FUNCTION RestProfile { : BOOLEAN};
{restores a profile/widget from backup diskettes}

LABEL 33;

TYPE
   TmountResult   = (validFullDisk, validIncDisk, wrongSequence, wrongSet, noSequence,
                     noDisk, badDisk, wrongDisk, lastfullDisk, lastIncDisk, writeProtected);
   TrestoreMode   = (FirstFull, MoreFull, FirstInc, MoreInc, OldBackup);

VAR
   checkOne    : UID;
   checkTwo    : LongInt;
   checkThree  : LongInt;
   currentMode : TrestoreMode;
   dDevPathname: Pathname;
   diskCount   : INTEGER;           { sequence number of required disk }
   diskNum     : INTEGER;           { sequence number of inserted disk }
   err         : INTEGER;
   mountResult : TmountResult;
   noMore      : BOOLEAN;
   numStr      : NumberStr;
   result      : TInitDisk;
   seqNum      : INTEGER;
   sDevPathname: Pathname;
   sFsInfo     : Fs_Info;
   tempStr     : FmaxStr;
   volName     : E_Name;

   {-------------------------------------------------------------------------}
   PROCEDURE AbortRestore;

   BEGIN
   RestProfile := FALSE;
   EXIT(RestProfile);
   END; {of PROC AbortRestore}

   {-------------------------------------------------------------------------}
   PROCEDURE AnotherDiskette (theDiskNum: INTEGER; VAR mountResult: TmountResult);
   {This procedure attempts to mount a diskette.  If successful, it then verifies that it is of the
    correct sequence number}

      {-------------------------------------------------------------------------}
      PROCEDURE ExitMount (why: TmountResult);
      BEGIN
      mountResult := why;
      EXIT(AnotherDiskette);
      END; {of PROC ExitMount}

      {-------------------------------------------------------------------------}
      PROCEDURE CheckSet;
      {make sure the backup diskettes are of the same backup set}
      BEGIN
      IF (sFsInfo.backup_VolID.a <> checkOne.a) OR (sFsInfo.backup_VolID.b <> checkOne.b) OR
         (sFsInfo.copy_thread <> checkTwo) OR ((checkThree <> 0) AND (sFsInfo.DTCC <> checkThree)) THEN
         ExitMount(wrongSet);
      END; {of PROC CheckSet}

      {-------------------------------------------------------------------------}

   BEGIN
   Mount(err, volName, passWord, bootDevName);
   CASE err OF
      0, 1052, -626, -1059, -1060, -1174, -1175: {we have a diskette, now verify sequence}
         BEGIN
         Lookup(err, sDevPathname, sFsInfo);
         IF (err > 0) THEN
            ExitMount(BadDisk);
         IF (sFsInfo.backup_VolID.b = 0) THEN
            ExitMount(WrongDisk);
         {now check the sequence}
         seqNum := sFsInfo.volNum;
         CASE (currentMode) OF
            FirstFull:     {this will always happen w/first diskette (old or new style backup)}
               BEGIN
               checkOne := sFsInfo.backup_VolID;
               checkTwo := sFsInfo.copy_thread;
               END;
            FirstInc:
               BEGIN
               checkThree := sFsInfo.DTCC;
               CheckSet;
               END;
            MoreFull, MoreInc, OldBackup:
               CheckSet;
            END;
         IF (seqNum = 0) THEN
            ExitMount(NoSequence);       {an old backup diskette w/o sequencing}
         diskNum := ABS(seqNum) MOD incOffset;
         IF (diskNum <> theDiskNum) THEN
            ExitMount(WrongSequence);
         {now we have a diskette in the correct sequence, find mode}
         IF (ABS(seqNum) < incOffset) THEN
            {full backup diskette}
            IF (seqNum < 0) THEN
               {last diskette in full backup series}
               mountResult := LastFullDisk
            ELSE
               mountResult := ValidFullDisk
         ELSE
            {incremental backup diskette}
            IF (seqNum < 0) THEN
               mountResult := LastIncDisk
            ELSE
               mountResult := ValidIncDisk;
         END; {of CASE ITEM}

      1053:    {inserted boot sony}
         mountResult := wrongDisk;

      614,
      1062:    {No diskette in place}
         mountResult := noDisk;

      1820:
         mountResult := writeProtected;

      OTHERWISE
         mountResult := badDisk;
      END; {of CASE block}

   END; {of PROC AnotherDiskette}

   {-------------------------------------------------------------------------}
   PROCEDURE BadBackup (alertNum: INTEGER);
   {tell user why it's not any good, go to end of restore loop}

   BEGIN
   StopAlert(installAlert, alertNum);
   END;

   {-------------------------------------------------------------------------}
   PROCEDURE DoDiskRestore;
   {AnotherDiskette returned (Valid/Last)(Full/Inc)Disk, no other problems, so do it up}

   BEGIN
   ArgAlert(1, diskString);
   WaitAlert(installAlert, 220);       { The lisa is rebuilding the disk... }
   CopyAllDiskFiles(err, sDevPathname, dDevPathname, RestoreMode);
   IF (err <> fceNoError) THEN
      BEGIN
      IF dbgRestore THEN WRITELN('   CopyAllDiskFiles, error = ',err:1);
      CASE err OF                               { Error while attempting to copy disk }
         fceCantRead    : alertNum := 144;      { Couldn't get a file from sony }
         fceCantWrite   : alertNum := 142;      { Problems with CopyDiskFile }
         fceAborted     : alertNum := 0;        { don't slap hand if abort on purpose }
         OTHERWISE        alertNum := 133;      { General tech difficulties alert }
         END; { of case block }
      IF (alertNum <> 0) THEN
         StopAlert(installAlert, alertNum);
      AbortRestore;
      END; {of IF block}
   diskCount := diskCount + 1;
   END; {of PROC DoDiskRestore}

   {-------------------------------------------------------------------------}

BEGIN
IF dbgInstall THEN WRITELN ('[RestProfile], entry');

IF (NOT bootUnmounted) THEN
   IF (NOT Dismount(bootPos, EjectIt, BootDisk)) THEN
      AbortRestore;

sDevPathname := CONCAT('-',bootDevName);
dDevPathname := CONCAT('-',initDevName);
noMore := FALSE;
diskCount := 1;
seqNum := 0;
checkThree := 0;
currentMode := FirstFull;

REPEAT
   AnotherDiskette(diskCount, mountResult);
   IF dbgRestore THEN WRITELN('   diskCount = ',diskCount:1,', mountResult = ',ORD(mountResult));
   CASE mountResult OF

      ValidIncDisk, LastIncDisk:
         BEGIN
         DoDiskRestore;
         IF (mountResult = LastIncDisk) THEN
            noMore := TRUE
         ELSE IF (currentMode = FirstInc) THEN
            currentMode := MoreInc;
         END;

      ValidFullDisk, LastFullDisk:
         BEGIN
         DoDiskRestore;
         IF (mountResult = LastFullDisk) THEN
            currentMode := FirstInc
         ELSE IF (currentMode = FirstFull) THEN
            currentMode := MoreFull;
         END;

      NoSequence:
         BEGIN
         IF (currentMode <> OldBackup) THEN
            IF (currentMode = FirstFull) THEN
               {OK to switch modes if first diskette inserted is of an old style backup (no sequencing)}
               BEGIN
               DoDiskRestore;
               currentMode := OldBackup;
               END
            ELSE
               {got an old backup diskette while in middle of doing full/incremental restore}
               BadBackup(230) { not part of the current backup set }
         ELSE
            DoDiskRestore;
         END; {of CASE NoSequence}

      WrongDisk:
         BadBackup(229);

      WriteProtected:      {write protect tab is set on the sony}
         BadBackup(202);

      WrongSet:            {a backup diskette, but from the wrong set of sonys}
         BadBackup(230);

      NoDisk:
         BEGIN
         CASE (currentMode) OF
            FirstFull: alertNum := 228;
            FirstInc: alertNum := 222;
            MoreFull, MoreInc:
               BEGIN
               IF (currentMode = MoreFull) THEN
                  alertNum := 224
               ELSE
                  alertNum := 225;
               GetString(alertNum, @tempStr);
               ArgAlert(1, tempStr);
               IntToStr(diskCount, numStr);
               ArgAlert(2, numStr);
               alertNum := 223;
               END;
            OldBackup: alertNum := 221;
            END; {of CASE block}
         IF (AskAlert (installAlert, alertNum) = 1) THEN
            IF (currentMode = OldBackup) OR (currentMode = FirstInc) THEN
               NoMore := TRUE
            ELSE
               AbortRestore;
         GOTO 33;    { skip dismounting the diskette }
         END; {of CASE NoDisk}

      BadDisk:
         BadBackup(139);

      WrongSequence:
         BEGIN
         ArgAlert(1, diskString);
         IntToStr(diskCount, numStr);
         ArgAlert(2, numStr);
         IntToStr(diskNum, numStr);
         ArgAlert(3, numStr);

         CASE currentMode OF
            FirstFull:
               alertNum := 227;
            FirstInc, MoreInc:
               BEGIN
               GetString(225, @tempStr);
               ArgAlert(4, tempStr);
               alertNum := 226;
               END;
            MoreFull:
               BEGIN
               GetString(224, @tempStr);
               ArgAlert(4, tempStr);
               alertNum := 226;
               END;
            END; {of CASE block}
         BadBackup(alertNum);
         END; {of CASE ITEM}

      END; {of CASE block}

   IF (NOT Dismount(bootPos, EjectIt, NotBoot)) THEN
      AbortRestore;

33:
   UNTIL noMore;

RestProfile := TRUE;

IF dbgInstall THEN WRITELN ('   [RestProfile], exit');
END; {of FUNC RestProfile}

{****************************************************************************}
FUNCTION RestPriam { : BOOLEAN};
{ This proc copies the contents of a priam from the attached archive
  tape.  The code is a modified version of the Workshop archiver program. }

CONST
   Version        = '1.6';          {current Archiver version number}
   TapeFormatVer  = 1;              {format version of tapes}

   RewindTape     = 1;              {tape op - rewind tape}
   EraseTape      = 2;              {tape op - erase tape}
   RetensionTape  = 3;              {tape op - retension tape}
   AdvanceTMs     = 4;              {tape op - advance n tape marks}
   WriteTMs       = 5;              {tape op - write n tape marks}
   Read1TM        = 6;              {tape op - read one tape mark}
   ReadStatus     = 7;              {tape op - read drive status}
   CopyTape       = 8;              {tape op - copy disk to tape/tape to disk}
   ResumeCopy     = 9;              {tape op - resume copy operation}
   AbortCopy      = 10;             {tape op - abort copy operation}
   IssuePkt       = 11;             {tape op - issue packet}
   ResumePkt      = 12;             {tape op - resume packet}
   AbortPkt       = 13;             {tape op - abort packet}

   Resumable      = -1840;          {copy or pkt command ended resumable}

   TapeId1        = $FFFF0000;      {these are used to identify Archiver tapes}
   TapeId2        = $0000FFFF;      {they are the 1st 4 fields in tape header }
   TapeId3        = $10101010;
   TapeId4        = $01010101;

   TapeTitle   = 'Archiver PRIAM Streamer Tape'; {put into tape header}

VAR
   alertNum    : INTEGER;
   CopyOk      : Boolean;
   DCplist     : DCType;           {device control parameter list}
   deviceName  : E_Name;
   DiskChannel : Integer;          {io channel for the disk}
   DiskDevNbr  : Integer;          {disk device number}
   diskPathname: Pathname;
   err         : INTEGER;
   Header      : RECORD            {tape header layout}
                 CASE Integer OF
                     0:
                        (Block:         PACKED ARRAY [0..511] OF Char);
                     1:
                        (Id1, Id2, Id3, Id4: LongInt;
                         Title:         String[80];
                         FmtVersion:    Integer;
                         ProgVersion:   String[10];
                         dateTime:      String[20];
                         SeqNbr:        Integer;
                         UserTitle:     Str255;
                         Group:         String[20]);
                 END;
   i           : INTEGER;
   NbrOfTMs    : Integer;          {nbr of TM's to advance or write}
   numStr      : NumberStr;
   SeqNo       : Integer;
   TapeName    : E_Name;           {slot name of the tape}
   TapePathname: Pathname;
   TapeVolName : E_Name;           {volume name of the mounted tape}
   TapeChannel : Integer;          {io channel for the tape}
   TapeDevNbr  : Integer;          {tape device number}
   TD          : String[20];       {time and data of execution and tape tag}
   UserLabel   : Str255;           {user's private label}

   {-------------------------------------------------------------------------------}
   PROCEDURE TapeIO (VAR err: INTEGER; Control: Integer);
   {TapeIO - all the tape I/O functions are performed here.  It is up to
    the *caller* to interpret the DCplist.DCData array. For the controls AdvanceTMs
    and WriteTMs, the number of TM's to advance is determined from the global
    NbrOfTMs which is preset to be 1. For IssuePkt it is assumed DCplist.DCData is
    already set up by the caller.}

   BEGIN
   IF dbgInstall THEN WRITELN ('[TapeIO], entry: control is ',control:1);

   WITH DCplist DO
      BEGIN
      DCCode := Control; {DCVersion is already set}
      IF (Control = AdvanceTMs) OR (Control = WriteTMs) THEN
         DCData[0] := NbrOfTMs
      ELSE IF (Control = CopyTape) THEN
         BEGIN
         DCData[0] := TapeChannel;
         DCData[1] := TapeDevNbr;
         DCData[2] := DiskChannel;
         DCData[3] := DiskDevNbr;
         DCData[4] := 1;            { 0 => direction is tape to disk }
         END;
      END; {with}

   Device_Control(err, TapePathname, DCplist);

   IF dbgInstall THEN WRITELN ('   [TapeIO], exit: err is ',err:1);
   END; {of PROC TapeIO}

   {-------------------------------------------------------------------------------}
   PROCEDURE UnmountTape;

   BEGIN
   IF dbgInstall THEN WRITELN ('[UnmountTape], entry');

   TapeIO(err, RewindTape);     {make sure tape is rewound}
   Unmount(err, TapeName);

   IF dbgInstall THEN WRITELN ('   [UnmountTape], exit: err = ',err:1);
   END; {of PROC UnmountTape}

   {-------------------------------------------------------------------------------}
   PROCEDURE AbortPTCopy (alertNum: INTEGER);

   BEGIN
   IF dbgInstall THEN
      BEGIN
      WRITELN ('[AbortPTCopy], entry');
      WRITELN ('   err is ',err:1,', ',DCPlist.DCData[0]:1,' sectors copied');
      END;

   IF (alertNum > 0) THEN
      StopAlert (installAlert, alertNum);
   TapeIO(err, AbortCopy);
   UnmountTape;
   Mount(err, initVolName, password, initDevName);

   IF dbgInstall THEN WRITELN ('   [RestPriam], exit: aborting');
   RestPriam := FALSE;
   EXIT(RestPriam);

   END; {of PROC AbortPTCopy}

   {-------------------------------------------------------------------------------}
   PROCEDURE AbortWithError (theAlertNum: INTEGER; theError: INTEGER);
   {sets the alert arg and calls AbortPTcopy}

   VAR
      tempNum  : NumberStr;

   BEGIN
   IntToStr(theError, tempNum);
   ArgAlert(1, tempNum);
   AbortPTCopy(theAlertNum);
   END; {of PROC AbortWithError);

   {-------------------------------------------------------------------------------}
   PROCEDURE MountTape (VAR err: INTEGER);
   {MountTape - this mounts the tape and sets up all the device info for the tape and
    disk. }

   LABEL 33;

   VAR
      attributes  : FS_Info;
      diskInfo    : FS_Info;
      Delim       : Char;
      Mounted     : Boolean;

   BEGIN
   IF dbgInstall THEN WRITELN ('[MountTape], entry');

   DiskPathname := CONCAT('-',initDevName);

   TapeName := initDevName;
   TapeName[4] := '3';
   TapePathname := CONCAT('-',TapeName);
  33:
   IF dbgInstall THEN WRITELN ('   mounting ',tapeName);
   Mount(err, TapeVolName, Password, TapeName);
   IF NOT ((err <= 0) OR (err = 1052 {device already mounted} )) THEN
      BEGIN
      IF dbgInstall THEN WRITELN ('   mount err ',err:1);
      AbortWithError(339, err);
      END;


   LookUp(err, TapePathname, Attributes);
   IF (err > 0) THEN
      BEGIN
      IF dbgInstall THEN WRITELN ('   Lookup on ',tapePathname,', error = ',err:1);
      AbortPTCopy (333);
      END;
   LookUp(err, DiskPathname, diskInfo);
   IF (err > 0) THEN
      BEGIN
      IF dbgInstall THEN WRITELN ('   Lookup on ',diskPathname,', error = ',err:1);
      AbortWithError(341, err);
      END;

   DiskChannel := diskInfo.IOChannel;
   DiskDevNbr := diskInfo.DeviceNumb;
   IF dbgInstall THEN WRITELN ('   disk channel is ',diskChannel:1);
   IF dbgInstall THEN WRITELN ('   disk device is  ',diskDevNbr:1);
   TapeChannel := Attributes.IOChannel;
   IF dbgInstall THEN WRITELN ('   tape channel is ',tapeChannel:1);
   TapeDevNbr := Attributes.DeviceNumb;
   IF dbgInstall THEN WRITELN ('   tape device is  ',tapeDevNbr:1);

   IF dbgInstall THEN WRITELN ('   [MountTape], exit: err is ',err:1);
   END;

   {-------------------------------------------------------------------------------}
   PROCEDURE HdrBlockIO (SeqNo: INTEGER);

   LABEL 33;

   VAR
      RefNum   : Integer;
      Actual   : LongInt;
      Filename : Pathname;
      dummyErr : INTEGER;
      curTapeNumStr: NumberStr;

      {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}
      FUNCTION ValidHdr: Boolean;
      BEGIN
      ValidHdr := False;
      WITH Header DO
         IF Id1=TapeId1 THEN
            IF Id2=TapeId2 THEN
               IF Id3=TapeId3 THEN
                  IF Id4=TapeId4 THEN
                     IF Title=TapeTitle THEN ValidHdr := True;
      END; {ValidHdr}

      {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}

   BEGIN
   IF dbgInstall THEN WRITELN ('HdlBlockIO: seqNo is', seqNo:1);

   { read/write header }
   Filename := Concat(TapePathname, '-Header');
   IntToStr (seqNo, numStr);
   REPEAT                     { ask user to insert the tape }
      IF (seqNo = 1) THEN
         alertNum := 330
      ELSE
         BEGIN
         alertNum := 331;
         ArgAlert (1, numStr);
         END;
  33: IF askAlert (installAlert, alertNum) = 1 THEN
         AbortPTCopy(0);
      TapeIO(err, RewindTape);
      IF err > 0 THEN
         BEGIN
         alertNum := 332;
         GOTO 33;
         END;
      UNTIL (err <= 0);

   Open(err, Filename, RefNum, [Dread]);
   IF (err <= 0) THEN
      Read_Data(err, RefNum, Ord4(@Header), 512, Actual, Sequential, 0);
   Close_Object (dummyErr, RefNum);

   WITH Header DO                                  { verify header }
      BEGIN
      IF NOT (ValidHdr OR (FmtVersion = TapeFormatVer)) THEN
         BEGIN
         ArgAlert (1, numStr);
         alertNum := 334;
         TapeIO(dummyErr, RewindTape);  { rewind before 'remove tape' alert }
         GOTO 33;
         END;
      IF (seqNo <> seqNbr) THEN
         BEGIN
         IntToStr (Header.SeqNbr, curTapeNumStr);
         ParamAlert (curTapeNumStr, numStr, '');
         alertNum := 335;
         TapeIO(dummyErr, RewindTape);  { rewind before 'remove tape' alert }
         GOTO 33;
         END;
      IF (seqNo = 1) THEN
         BEGIN                          { tell user the date on the tape }
         ArgAlert (1, Group);
         IF (AskAlert (installAlert, 337) = 1) THEN
            BEGIN
            alertNum := 331;
            TapeIO(dummyErr, RewindTape);  { rewind before 'remove tape' alert }
            GOTO 33;
            END;
         END; {of IF THEN block}
      END; {of WITH block}

   TapeIO(err, Read1TM);

   err := 0;
   IF dbgInstall THEN WRITELN ('[HdrBlockIO], exit');
   END; {HdrBlockIO}

   {-------------------------------------------------------------------------------}
   {start of main body, PROC RestPriam}
BEGIN
IF dbgInstall THEN WRITELN ('[RestPriam], entry');

DCplist.DCVersion := 2; {always}
NbrOfTMs := 1;
FOR i := 0 TO 511 DO
   Header.Block[i] := Chr(0);
FOR i := 0 TO SIZEOF(UserLabel)-1 DO
   UserLabel[i] := Chr(0);

{ copy }
IF (NOT Dismount(initPos, FALSE, FALSE)) THEN
   AbortPTCopy(333);
MountTape (err);
SeqNo := 1;
copyOk := FALSE;
REPEAT
   HdrBlockIO (seqNo);
   ParamAlert (diskString, numStr, Header.Group);
   WaitAlert (installAlert, 336);
   IF (SeqNo = 1) THEN
      TapeIO(err, CopyTape)
   ELSE TapeIO(err, ResumeCopy);
   IF (err > 0) THEN
      AbortPTCopy (333);
   copyOK := NOT (err = resumable);
   TapeIO(err, RewindTape);
   SeqNo := SeqNo + 1;
   UNTIL copyOK;

UnmountTape;

Mount(err, initVolName, password, initDevName);
IF (err <= 0) THEN
   RestPriam := TRUE
ELSE
   AbortPTCopy(333);

IF dbgInstall THEN WRITELN ('   [RestPriam], exit: err = ',err:1);
END;

{$IFC ForOffice}
{****************************************************************************}
FUNCTION SetCatName {: BOOLEAN};
{ Makes sure that there is a '#Catalog' system file on the profile }

VAR
   attributes     : fs_info;
   err            : INTEGER;
   filerCatName   : pathname;
   ResetPathname  : pathname;
   ResetCatName   : E_Name;

BEGIN
IF dbgInstall THEN WRITELN ('[SetCatName], entry ');

filerCatName := CONCAT ('-',initDevname,'-',catname);    { CatName := '!Catalog' }
resetCatname := sCatName;                                { sCatName := '#Catalog' }
resetPathname := CONCAT ('-',initDevname,'-',resetCatName);
IF dbgInstall THEN
   WRITELN ('   filer: ',filerCatName,' reset: ',resetCatName,' resetpath: ',resetPathname);

LookUp (err, resetPathname, Attributes);                 { Check for '#Catalog' name on the Profile }
IF (err <= 0) THEN
   BEGIN
   IF dbgInstall THEN WRITELN ('   [SetCatName], exit:Found #Catalog on the Profile ');
   SetCatName := TRUE;
   EXIT (SetCatName)
   END;

LookUp (err, filerCatName, Attributes);                   { Check for '!Catalog' name }
IF (err <= 0) THEN
   BEGIN
   IF dbgInstall THEN WRITELN ('   Found <!Catalog> on the disk, renaming to <#Catalog> ');
   Rename_Entry (err, filerCatName, resetCatName);        { '!Catalog' -> '#Catalog }
   IF (err <= 0) THEN
      BEGIN
      IF dbgInstall THEN WRITELN('   [SetCatName], exit: Succ. rename of !Catalog to #Catalog.');
      SetCatName := TRUE;
      EXIT (SetCatName);
      END
   ELSE
      BEGIN
      IF dbgInstall THEN WRITELN ('   [SetCatName], exit:Renaming, error = ',err:1);
      SetCatName := FALSE;
      EXIT (SetCatName)
      END
   END;

IF dbgInstall THEN WRITELN('   Making a #Catalog entry on the profile ');
Make_File(err, resetPathname, 0);                    { make a '#Catalog' entry on the profile }
IF (err <= 0) THEN
   SetCatName := TRUE
ELSE
   SetCatName := FALSE;

IF dbgInstall THEN WRITELN ('   [SetCatName], exit: make_file error = ',err:1);
END; { of FUNC SetCatName }
{$ENDC}

{****************************************************************************}
PROCEDURE SysErr {err: INTEGER; lowlevelerr: INTEGER};
{ Routine originally in one of the Filer Units }

VAR
   response    : FMaxStr;
   tempStr     : NumberStr;
   errStr      : STRING[5];
   lowlvlStr   : STRING[5];


BEGIN
IF dbgInstall THEN
   IF lowlevelerr < 0 THEN WRITELN ('   warning: ',lowlevelerr:1);
IF lowlevelerr <= 0 THEN EXIT (SysErr);

IntToStr (ABS(err), tempStr);                      { Build alert msg params }
errStr := tempStr;
IF lowlevelerr <> nullErr THEN
   BEGIN
   IntToStr(lowlevelerr, tempStr);
   lowlvlstr := CONCAT('/',tempStr);
   END
ELSE lowlvlstr := '';

IF dbgInstall THEN
   WRITELN ('*** SysErr ',errStr,lowlvlStr);

ParamAlert(errStr, lowlvlstr, '');

IF ((err < 0) OR dbgInstall) THEN
   BEGIN
   IF AskAlert (installAlert, 201) = 2 THEN
      EXIT (SysErr)
   ELSE HALT;
   END
ELSE
   BEGIN
   StopAlert (installAlert, 200);
   HALT;
   END
END; { of function SysErr }

{****************************************************************************}
FUNCTION UserAborted {* (VAR err: INTEGER) : BOOLEAN *};
{ Checks for Apple period sequence }

BEGIN
IF Abort THEN
   BEGIN
   err := fceAborted;
   UserAborted := TRUE;
   END
ELSE UserAborted := FALSE;
END; { of FUNC UserAborted }

{****************************************************************************}
PROCEDURE ZapPassword {* thePath: Pathname *};
{sets <thePath> file's password to nil}

VAR
   err   : INTEGER;
   uParm : UT_Parmt;

BEGIN
WITH uParm DO
   BEGIN
   gp_parm := 0;
   command := xfer_passwd;
   path := thePath;
   password := '';
   op := pswWrite;
   END;
FS_Utilities(err, uParm);
END; {of PROC ZapPassword}

{****************************************************************************}


BEGIN   { Mainline code }

Initialize;                         { Must be before dismount of the boot diskette, as
                                      all the segs, alerts, etc are locked down here }

WHILE EventAvail DO                 { Drain abort/update/etc. events so that later alerts work }
   BEGIN
   GetEvent(theEvent);
   IF (theEvent.what = folderUpdate) THEN
      BEGIN
      BeginUpdate(filerFolder);
      EndUpdate(filerFolder);
      END;
   END;

REPEAT
   SetFadeDelay (fadeDelay);

   {set up the Apple Logo stuff}
   ArgAlert(1,logo);
   ArgAlert(2,version);
   ArgAlert(3,copyright);
   ArgAlert(4,apple);
   ArgAlert(5,diskstring);

   CASE AskAlert (installAlert, 101) OF
      1: {'Finished'}
         Quit;
      2: {'Repair'}
         IF Repair THEN
            IF AskAlert (installAlert, 121) = 2 THEN Install;
      3: {'Install'}
         Install;
      4: {'Restore'}
         Restore;
      END; {of CASE block }
   UNTIL FALSE; {end of main menu REPEAT loop}

END. {of InstallShell program}

