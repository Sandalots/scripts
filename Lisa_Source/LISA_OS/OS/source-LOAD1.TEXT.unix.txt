{ Copyright 1983, 1984, Apple Computer Inc. }

(*$S ProcComm *)

procedure Get_UnitDir_Entry (* unit_num : iUnitRange;
                               var uEntry_ptr : ptr_UnitDirEntry *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to return a pointer to the Unit Directory     *)
        (*   entry for the specified Intrinsic Unit.  The Unit       *)
        (*   Directory is scanned linearly for the requested entry.  *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   unit_num : the number of the Intrinsic Unit whose       *)
        (*              entry in the Directory is to be located.     *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   uEntry_ptr : a pointer to the Directory entry for the   *)
        (*                specified Intrinsic Unit.                  *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   If the Directory pointer in the LCB is nil, it is       *)
        (*   assumed that the Directory has not yet been set up and  *)
        (*   Setup_Directory is called to build the Directory from   *)
        (*   Intrinsic.Lib.                                          *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   If the specified entry is not found, nil is returned    *)
        (*   for the pointer.                                        *)
        (*                                                           *)
        (*************************************************************)

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    bottom : int2;                        { for binary search of Unit Dir Table }
    mid : int2;
    top : int2;

  begin
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);

    with lcb_ptr^ do
      begin
        bottom := 1;   top := num_IUs;
        repeat
          mid := (bottom + top) DIV 2;
          if unit_num > iUnit_Dir^[mid].uNumber then bottom := mid + 1
          else
            top := mid - 1
        until (iUnit_Dir^[mid].uNumber = unit_num) or (bottom > top);

        if iUnit_Dir^[mid].uNumber = unit_num then
          uEntry_ptr := @iUnit_Dir^[mid]
        else
          uEntry_ptr := nil
      end { with }
  end { Get_UnitDir_Entry };


(*$IFC debug2 *)
(*$S kr_mmgr *)   { for displaying swap errors from MemMgr }
(*$ENDC *)

procedure Get_SegDir_Entry (seg_num : sSegRange;
                            var sEntry_ptr : ptr_SegDirEntry);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to return a pointer to the Segment Directory  *)
        (*   entry for the specified shared segment.  The Segment    *)
        (*   Directory is scanned linearly for the requested entry.  *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   seg_num : the number of the shared segment whose entry  *)
        (*             in the Directory is to be located.            *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   sEntry_ptr : a pointer to the Directory entry for the   *)
        (*                specified shared segment.                  *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   If the specified entry is not found, nil is returned    *)
        (*   for the pointer.                                        *)
        (*                                                           *)
        (*************************************************************)

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    bottom : int2;                        { for binary search of Seg Dir Table }
    mid : int2;
    top : int2;

  begin
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);

    with lcb_ptr^ do
      begin
        bottom := 1;   top := num_sSegs;
        repeat
          mid := (bottom + top) DIV 2;
          if seg_num > sSeg_Dir^[mid].sNumber then bottom := mid + 1
          else
            top := mid - 1
        until (sSeg_Dir^[mid].sNumber = seg_num) or (bottom > top);

        if sSeg_Dir^[mid].sNumber = seg_num then
          sEntry_ptr := @sSeg_Dir^[mid]
        else
          sEntry_ptr := nil
      end { with }
  end { Get_SegDir_Entry };


(*$IFC debug2 *)
(*$S kr_mmgr *)

procedure CodeSwapError (* csSdb_ptr : sdb_ptr;  error : int2;
                           mrbtPtr : mrbt_ptr *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  var
    plcb_ptr : ptr_PLCB;                  { ptr to PLCB for program of process }
    seg_num : int2;                       { # of failing seg as used by process }
    private : boolean;                    { true if failing segment is private }
    cseg_sdbRP : relptr;                  { relptr to SDB for failing seg }
    mmrbPtr : mmrb_ptr;                   { ptr to MMRB }
    i : int2;                             { loop index for scanning lists }
    checkByte : ^int1;                    { 1st byte of seg in mem for checking }
    IUD_refnum : int2;                    { refnum for opening IU Directory seg }
    sDirEntry_ptr : ptr_SegDirEntry;      { ptr to a Segment directory entry }

  begin
    checkByte := pointer(ord4(realmemmmu)*maxmmusize +
                         ord4(csSdb_ptr^.memaddr)*mempgsize);

    { report the error to the user }
    { calculate the segment # as used by the process }
    seg_num := codespacemmu;
    cseg_sdbRP := ord(csSdb_ptr) - b_sysglobal_ptr;
    mmrbPtr := pointer(mmrb_addr);
    while mrbtPtr^[seg_num].sdbRP <> cseg_sdbRP do
      seg_num := seg_num + 1;

    { determine whether the segment was private or shared }
    plcb_ptr := pointer(mmrbPtr^.req_pcb_ptr^.plcbRP + b_sysglobal_ptr);
    with plcb_ptr^ do
      begin
        { scan private segment SDB list }
        i := 1;   private := false;
        while (i <= n_pri_segs) and not private do
          if pSeg_list^[i] = csSdb_ptr then
            private := true
          else
            i := i + 1
      end;

    {Open_IUDirectory (IUD_refnum);
    if not private then Get_SegDir_Entry (seg_num, sDirEntry_ptr);}

    write ('*** Error swapping in ');
    if private then write ('private ')
      else write ('shared ');
    write ('code seg # ', seg_num:1);
    {if not private then
      write (' (', sDirEntry_ptr^.sName, ')');}
    writeln (' for process id # ',
             mmrbPtr^.req_pcb_ptr^.glob_id:1, ' ***');
    write ('    sdb_ptr = ', ord(csSdb_ptr));
    writeln ('    pcb_ptr = ', ord(mmrbPtr^.req_pcb_ptr));
    if error <> 0 then
      writeln ('    segment read error = ', error:1);
    if checkByte^ <> -123 { $85 } then
      writeln ('    invalid code segment at address ',
               ord(checkByte));
    writeln ('    press <ret> to abort the process and continue...');
    readln;

    {Close_IUDirectory (IUD_refnum)}
  end { CodeSwapError };
(*$ENDC *)


(*$IFC debug1 *)
(*$S kr_mmgr *)

procedure ShowCode (* segSdb_ptr : sdb_ptr;  mrbtPtr : mrbt_ptr *);
  { procedure to display a particular code segment for the Memory Contents
    Display.  Assumes the IUDirectory has already been mapped by the calling
    process. }

  var
    plcb_ptr : ptr_PLCB;                  { ptr to PLCB for program of process }
    seg_num : int2;                       { # of failing seg as used by process }
    private : boolean;                    { true if failing segment is private }
    cseg_sdbRP : relptr;                  { relptr to SDB for failing seg }
    mmrbPtr : mmrb_ptr;                   { ptr to MMRB }
    i : int2;                             { loop index for scanning lists }
    error : int2;                         { return from Get_PName }
    sDirEntry_ptr : ptr_SegDirEntry;      { ptr to a Segment directory entry }
    disk_addr : addrdisc;                 { disk address for program }
    prog_fcbptr : sfcb_ptr;               { ptr to FCB for prog s-file }
    progName : string[12];                { program name for display }
    pname : pathname;                     { program name from Get_PName }

  begin
    { calculate the segment # as used by the process }
    seg_num := codespacemmu;
    cseg_sdbRP := ord(segSdb_ptr) - b_sysglobal_ptr;
    mmrbPtr := pointer(mmrb_addr);
    while (mrbtPtr^[seg_num].sdbRP <> cseg_sdbRP) and (seg_num <= lusercodemmu) do
      seg_num := seg_num + 1;

    { determine whether the segment is private, shared, or unrelated }
    if seg_num > lusercodemmu then
      write ('Code Seg                  ')
    else
      begin  { private or shared }
        plcb_ptr := pointer(mmrbPtr^.req_pcb_ptr^.plcbRP + b_sysglobal_ptr);
        with plcb_ptr^ do
          begin
            { scan private segment SDB list }
            i := 1;   private := false;
            while (i <= n_pri_segs) and not private do
              if pSeg_list^[i] = segSdb_ptr then
                private := true
              else
                i := i + 1
          end;

        if not private then
          begin
            Get_SegDir_Entry (seg_num, sDirEntry_ptr);
            write (sDirEntry_ptr^.sName, '        ')
          end
        else
          begin
            write (seg_num:3, ' ');
            if mmrbPtr^.req_pcb_ptr^.plcbRP = 0 then
              pname := ''
            else
              begin
                plcb_ptr := pointer(mmrbPtr^.req_pcb_ptr^.plcbRP +
                                    b_sysglobal_ptr);
                disk_addr := plcb_ptr^.pSeg_list^[1]^.discaddr;
                prog_fcbptr := pointer(disk_addr.fid + b_sysglobal_ptr);
                pname := prog_fcbptr^.fname
              end;
            if Length(pname) > 12 then
              progName := Copy (pname, 1, 12)
            else
              begin
                progName := pname;
                for i := Length(pname)+1 to 12 do
                  progName := Concat (progName, ' ')   { left justified }
              end;
            write (progName)
          end;

        write ('  ', mmrbPtr^.req_pcb_ptr^.glob_id:3, '     ')
      end { private or shared }
  end { ShowCode };
(*$ENDC *)


(*$S ProcTerm *)

procedure Free_SharedIUs (unit_list : IUuse_list;  last_IUnum : iUnitRange;
                          release : boolean);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to free the global spaces for the shared      *)
        (*   intrinsic units in the specified used unit list.  The   *)
        (*   units with #s <= last_IUnum will be freed if their use  *)
        (*   counts fall to 0.                                       *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   used_unit : the list of intrinsic units from which the  *)
        (*               shared intrinsic units to be freed are to   *)
        (*               be selected.                                *)
        (*                                                           *)
        (*   last_IUnum : the highest shared intrinsic unit number   *)
        (*                to be freed from the used_unit list.       *)
        (*                                                           *)
        (*   release :                                               *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This procedure is intended to be used only from         *)
        (*   Make_Process and Prog_Info for freeing up shared        *)
        (*   intrinsic units that were allocated during a process    *)
        (*   creation that failed.                                   *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   None.                                                   *)
        (*                                                           *)
        (*************************************************************)

  var
    index : int2;                         { for scanning Directory }
    uDirEntry_ptr : ptr_UnitDirEntry;     { ptr to entry in Unit Directory }
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }

  begin
    index := last_IUnum;
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    uDirEntry_ptr := @lcb_ptr^.iUnit_Dir^[last_IUnum];

    with unit_list do
      repeat
        with uDirEntry_ptr^ do
          if uType = 2 then
            begin  { shared unit }
              if use_list[uNumber] then
                begin  { unit used }
                  if not release then
                    uUse_count := uUse_count - 1
                  else if (uUse_count = 0) and (uData_ptr <> nil) then
                    begin  { 'release' the shared IU data space }
                      { set ptr to start of space for RelSpace }
                      uData_ptr := pointer(ord(uData_ptr) - uDatasize);
                      RelSpace (ord(uData_ptr), MMU_Base (shrsegmmu));
                      uData_ptr := nil
                    end { release shared IU }
                end { unit used }
            end { shared unit };

        uDirEntry_ptr := pointer(ord(uDirEntry_ptr) - Sizeof (UnitDirEntry));
        index := index - 1
      until index = 0
  end { Free_SharedIUs };


(*$S ProcStart *)

procedure Get_Shared_Ptr (uDirEntry_ptr : ptr_UnitDirEntry;
                          var IUdata_ptr : data_ptr);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to get a pointer (in the shared segment) to   *)
        (*   the global data for a shared Intrinsic Unit.  If the    *)
        (*   specified shared Intrinsic Unit is not currently in     *)
        (*   use, a piece of the shared segment is allocated for     *)
        (*   its global data.  The space is deallocated when the     *)
        (*   shared Intrinsic Unit is no longer used by any          *)
        (*   remaining loaded program.                               *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   unit_num : the number of the shared Intrinsic Unit for  *)
        (*              which the pointer to the global data is to   *)
        (*              be returned.                                 *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   IUdata_ptr : the pointer to the global data for the     *)
        (*                specified shared Intrinsic Unit.  Note     *)
        (*                that the global data for an Intrinsic      *)
        (*                Unit is accessed like program global data  *)
        (*                (i.e. stack-like) so that the pointer      *)
        (*                returned must point to the end of the      *)
        (*                space allocated to the unit.               *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This routine is intended to be used only during         *)
        (*   process creation.                                       *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   If space can't be obtained in the shared segment, a     *)
        (*   nil is returned for the data pointer.  This should      *)
        (*   only occur if the segment can't be expanded.            *)
        (*   Note that the managment of the shared segment should    *)
        (*   be changed later so that the space allocation           *)
        (*   structures are not in the shared segment itself.  The   *)
        (*   GetSpace/RelSpace mechanism was used because it was an  *)
        (*   easy 1st implementation.                                *)
        (*                                                           *)
        (*************************************************************)

  var
    ord_ptr : absptr;                     { ptr returned by GetSpace }

  begin
    with uDirEntry_ptr^ do
      begin
        if uData_ptr = nil then
          begin  { try to allocate space for the IU }
            if GetSpace (uDatasize, MMU_Base (shrsegmmu), ord_ptr) then
              { return ptr to end of area since vars are accessed stack-like }
              uData_ptr := pointer(ord_ptr + uDatasize)
            else
              begin  { couldn't get the space }
                IUdata_ptr := nil;
                exit (Get_Shared_Ptr)
              end
          end;

        if uUse_count = 0 then
          begin
            { 'initialize' kludgy shared IUs - K.F. }
            uData_ptr := pointer(ord(uData_ptr) - 2);
            uData_ptr^ := 0;
            uData_ptr := pointer(ord(uData_ptr) + 2)
          end;

        uUse_count := uUse_count + 1;
        IUdata_ptr := uData_ptr
      end { with uDirEntry_ptr^ }
  end { Get_Shared_Ptr };


{procedure SumIUData (* ss_depList : dependList;  var sum_IUdata : int4;
                       var high_unit : iUnitRange *);}

      (*************************************************************)
      (*                                                           *)
      (* Description:                                              *)
      (*                                                           *)
      (* Input Parameters:                                         *)
      (*                                                           *)
      (* Output Parameters:                                        *)
      (*                                                           *)
      (* Side Effects:                                             *)
      (*                                                           *)
      (* Special Conditions of Use:                                *)
      (*                                                           *)
      (* Error Conditions:                                         *)
      (*                                                           *)
      (*************************************************************)

 (* var
    index : int2;                         { for scanning Directory }
    last_iuIndex : int2;                  { local copy # IUs in Directory }
    uDirEntry_ptr : ptr_UnitDirEntry;     { ptr to entry in Unit Directory }
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }

  begin
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    index := 1;   sum_IUdata := 0;   high_unit := 0;
    with lcb_ptr^ do
      begin
        uDirEntry_ptr := @iUnit_Dir^[1];
        last_iuIndex := num_IUs;
      end;

    { scan Unit Directory for those units in the required Software Systems }
    repeat
      with uDirEntry_ptr^ do
        if ss_depList[uSysNumber] then
          begin
            high_unit := uNumber;
            if uType = 1 { not shared } then
              sum_IUdata := sum_IUdata + uDatasize
          end;

      uDirEntry_ptr := pointer(ord(uDirEntry_ptr) + Sizeof (UnitDirEntry));
      index := index + 1
    until index > last_iuIndex
  end { SumIUData };*)


procedure Build_DPT (var errnum : int2;  var stk_info : stkInfo_rec;
                     var unit_list : IUuse_list;  jt_ptr : ptr_JumpTable);

      (*************************************************************)
      (*                                                           *)
      (* Description:                                              *)
      (*                                                           *)
      (* Input Parameters:                                         *)
      (*                                                           *)
      (* Output Parameters:                                        *)
      (*                                                           *)
      (* Side Effects:                                             *)
      (*                                                           *)
      (* Special Conditions of Use:                                *)
      (*                                                           *)
      (* Error Conditions:                                         *)
      (*                                                           *)
      (*************************************************************)

  const
    e_noshrspace = 18;                    { error no space for shared IU globals }

  var
    index : int2;                         { for scanning Directory }
    uDirEntry_ptr : ptr_UnitDirEntry;     { ptr to entry in Unit Directory }
    dataptr_Table : ^IUdata_ptrs;         { ptr to data ptr table in stack }
    IUdata_sum : int4;                    { sum of data sizes in stack for IUs }
    stk_data : int4;                      { where IU data starts in stack terms }
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }

  procedure Recover;
    { procedure used by Build_DPT to recover from any errors that occur while
      getting information from the program file. }

    begin
      { handle any shared IU data 'unloads' that may be necessary }
      Free_SharedIUs (unit_list, index - 1, false);   { decrement counts }
      Free_SharedIUs (unit_list, index - 1, true);    { release spaces }

      errnum := e_noshrspace;
      exit (Build_DPT)
    end { Recover };


  begin  { Build_DPT }
    errnum := 0;
    with stk_info do
      begin
        dataptr_Table := pointer(ord(jt_ptr) - dpt_size);

        stk_data := jt_size + dpt_size + jt_delta + stk_delta;
        stk_data := MMU_Base (stackmmu+1) - stk_data;   { stack seg terms }
        stk_data := stk_data - glob_size - comm_size
      end;
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    uDirEntry_ptr := @lcb_ptr^.iUnit_Dir^[1];
    index := 1;   IUdata_sum := 0;

    { scan Unit Directory for those units required by the program }
    with unit_list do
      repeat
        with uDirEntry_ptr^ do
          if uNumber > index then
            { unit is not used - not even defined in Directory }
            dataptr_Table^[index] := nil
          else if not use_list[uNumber] then
            begin  { unit is not required }
              dataptr_Table^[index] := nil;
              uDirEntry_ptr := pointer(ord(uDirEntry_ptr) + Sizeof (UnitDirEntry))
            end
          else
            begin  { unit is required by the program }
              if uDatasize = 0 then
                { unit has no global data }
                dataptr_Table^[index] := nil
              else if uType = 1 then
                begin  { regular intrinsic unit }
                  dataptr_Table^[index] := pointer(stk_data - IUdata_sum);
                  IUdata_sum := IUdata_sum + uDatasize
                end
              else
                begin  { shared intrinsic unit }
                  Get_Shared_Ptr (uDirEntry_ptr, dataptr_Table^[index]);
                  if dataptr_Table^[index] = nil then Recover
                end;
              uDirEntry_ptr := pointer(ord(uDirEntry_ptr) + Sizeof (UnitDirEntry))
            end;

        index := index + 1
      until index > high_iunit
  end { Build_DPT };


(*$S init *)

procedure Change_Directory (* var errnum : int2;  restartShell : boolean *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to change the memory copy of the Intrinsic    *)
        (*   Unit and Shared Segment Directory while the system is   *)
        (*   running.  The current Directory is released and the     *)
        (*   new one is read in.  It is assumed that the new         *)
        (*   INTRINSIC.LIB file has already been placed on the OS    *)
        (*   volume.                                                 *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   restartShell : true if the Shell process must be        *)
        (*                  because some of the shared segments it   *)
        (*                  requires have changed with the new       *)
        (*                  library.                                 *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   errnum : the error return parameter for this            *)
        (*            procedure.                                     *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This procedure is in the privileged interface of the    *)
        (*   Operating System.  It is intended to be used only by    *)
        (*   Shell programs to change the Directory dynamically.     *)
        (*   It assumes that NO other user processes exist in the    *)
        (*   system at the time it is called by the Shell.  Note     *)
        (*   that PasLib can not be changed in the Directory by      *)
        (*   mechanism currently.                                    *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   Any errors returned by Setup_Directory currently cause  *)
        (*   a system error.  If a file error is returned by         *)
        (*   Setup_Directory, the Directory file is killed so that   *)
        (*   a new file can be placed on the OS volume during the    *)
        (*   next boot to try getting the Directory again.           *)
        (*                                                           *)
        (*************************************************************)

  const
    uBlkIO = 103;                         { unit # for BlkIO unit }
    sPasLib1 = 17;                        { segment # for PasLib1 segment }
    nDirBuffBlocks = 4;                   { # blocks for directory buffer }

  var
    IUD_refnum : int2;                    { refnum for opening IU Directory seg }
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    uDirEntry_ptr : ptr_UnitDirEntry;     { ptr to entry in Unit Directory }
    sDirEntry_ptr : ptr_SegDirEntry;      { ptr to entry in Segment Directory }
    saveData_ptr : data_ptr;              { saved ptr into shared seg for BlkIO }
    saveSdb_ptr : sdb_ptr;                { saved ptr to SDB for PasLib1 segment }
    obj_ptr : ObjHandle;                  { obj descriptor for new Directory }
    IUD_ptr : absptr;                     { ptr to base of IU Directory segment }
    dir_pathname : pathname;              { pathname for Kill_Object }

  procedure Recover;
    begin
      (*$IFC debug2 *)
      writeln ('   Error in Change_Directory...');
      writeln ('   errnum = ', errnum:1,
               '   obj_ptr^.error = ', obj_ptr^.error:1);
      (*$ENDC *)
      System_Error (10100)
    end { Recover };

  begin
    (*{ save needed info from current Directory }
    Open_IUDirectory (IUD_refnum);
    if IUD_refnum = -1 then Recover;
    Get_UnitDir_Entry (uBlkIO, uDirEntry_ptr);
    saveData_ptr := uDirEntry_ptr^.uData_ptr;
    Get_SegDir_Entry (sPasLib1, sDirEntry_ptr);
    saveSdb_ptr := sDirEntry_ptr^.sSegsdb_ptr;

    { release current Directory }
    IUD_ptr := MMU_Base (LDSN_to_MMU (IUDir_ldsn));
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    with lcb_ptr^ do
      begin
        RelSpace (ord(iUnit_dir), IUD_ptr);
        RelSpace (ord(sSeg_Dir), IUD_ptr);
        RelSpace (ord(File_Dir), IUD_ptr)
      end;

    { set up new Directory }
    InitObjFile (obj_ptr, nDirBuffBlocks);
    if obj_ptr = nil then Recover;
    OpenObjFile (obj_ptr, dir_name, false { existing file });

    while obj_ptr^.error = 948 { not found } do
      begin
        writeln;
        writeln ('INTRINSIC.LIB not found.  Please transfer it.');
        writeln;
        Size_Stack (errnum, 11264);
        if errnum <> 0 then
          writeln ('   error from Size_Stack in Setup_IUInfo = ', errnum:1);
        FTP;
        OpenObjFile (obj_ptr, dir_name, false { existing file });
      end;

    if obj_ptr^.error > 0 then Recover;

    Setup_Directory (errnum, obj_ptr, IUD_ptr);
    if errnum <> 0 then Recover;

    { set appropriate use counts to 1 and restore saved values }
    Get_UnitDir_Entry (uBlkIO, uDirEntry_ptr);
    if uDirEntry_ptr = nil then Recover
    else
      with uDirEntry_ptr^ do
        begin
          uUse_count := 1;   { for SYSTEM.SHELL }
          uData_ptr := saveData_ptr
        end;

    Get_SegDir_Entry (sPasLib1, sDirEntry_ptr);
    if sDirEntry_ptr = nil then Recover
    else
      with sDirEntry_ptr^ do
        begin
          sUse_count := 1;   { for SYSTEM.SHELL }
          sSegsdb_ptr := saveSdb_ptr
        end;

    { clean up }
    Close_IUDirectory (IUD_refnum);
    CloseObjFile (obj_ptr, true);*)
    errnum := 1199
  end { Change_Directory };


(*$S ProcStart *)

procedure List_LibFiles (* var errnum : integer;  var progfile : pathname;
                           var file_list : lFile_list *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   System call procedure to return the list of intrinsic   *)
        (*   library files needed by a program to execute.  The      *)
        (*   list returned is a list of booleans - 1 for each        *)
        (*   posible library file number in the Intrinsic Unit       *)
        (*   Directory.                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   progfile : the pathname for the program file whose      *)
        (*              library file requirements are to be          *)
        (*              returned.                                    *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   errnum : the error return parameter for this system     *)
        (*            call procedure (see values below).             *)
        (*                                                           *)
        (*   file_list : the list of booleans indicating which       *)
        (*               library files (numbers) are used by the     *)
        (*               program.                                    *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This routine is intended to be called from the          *)
        (*   privileged interface of the OS.                         *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   Several.  See constants below+190 (error base for       *)
        (*   Process Mgmt and this procedure).                       *)
        (*                                                           *)
        (*************************************************************)

  const
    nObjBuffBlocks = 2;                   { # blocks buffer space for prog file }

    e_noobjblock = 0;                     { error no sysloc space for ObjDesc }
    e_prog_open = 1;                      { error opening program file }
    e_fsread = 2;                         { error reading program file }
    e_inv_progfile = 4;                   { error invalid program file }
    e_noseg = 5;                          { error looking for shared seg }
    e_badseg = 6;                         { error matching name of shared seg }

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    obj_ptr : ObjHandle;                  { ptr to ObjDescriptor for prog file }
    obj_block : ObjBlock;                 { 'invariant' block from prog file }
    obj_varblock : ObjVarBlock;           { 'variant' block from prog file }
    IUD_refnum : int2;                    { refnum for opening IU Directory seg }
    found : boolean;                      { true if segment table found }
    sDirEntry_ptr : ptr_SegDirEntry;      { ptr to a Segment directory entry }
    i : int2;                             { loop index for scanning seg table }
    seg_list : sseg_list;                 { list of segments required by program }
    max_segs : int2;


  procedure Recover (error : int2);
    { procedure used by List_LibFiles to recover from any errors encounterd
      while building the list of library files used by the program. }
    var
      i : int2;                           { loop index for file list }

    begin
      if IUD_refnum <> -1 then Close_IUDirectory (IUD_refnum);
      if obj_ptr <> nil then CloseObjFile (obj_ptr, true);
      for i := 1 to maxFile do file_list[i] := false;

      errnum := 190 + error;
      exit (List_LibFiles)
    end { Recover };

  procedure Build_SegList;

    var
      index : int2;                         { for building segment use list }
      obj_varblock : ObjVarBlock;           { 'variant' block from prog file }
      sDirEntry_ptr : ptr_SegDirEntry;      { ptr to a Segment directory entry }

    begin
      index := 1;
      repeat
        seg_list[index] := false;
        index := index + 1
      until index > maxSeg;

      index := 1;
      repeat
        GetObjVar (obj_ptr, SegVariant, obj_varblock);
        if obj_ptr^.error <> 0 then Recover (e_fsread);
        with obj_varblock.bSegVariant do
          begin
            Get_SegDir_Entry (SegNumber, sDirEntry_ptr);
            if sDirEntry_ptr = nil then Recover (e_noseg);

            with sDirEntry_ptr^ do
              if (SegName <> sName) or (sSegSize <= 0) then
                Recover (e_badseg);

            seg_list[SegNumber] := true
          end { with obj_varblock.bSegVariant };

        index := index + 1
      until index > obj_block.bSegmentTable.nSegments
    end { Build_SegList };

  begin  { List_LibFiles }
    IUD_refnum := -1;
    for i := 1 to maxFile do file_list[i] := false;

    InitObjFile (obj_ptr, nObjBuffBlocks);
    if obj_ptr = nil then Recover (e_noobjblock);

    OpenObjFile (obj_ptr, progfile, false { existing file });
    if (obj_ptr^.error > 0) and (obj_ptr^.error <> 1130 { protected }) then
      begin  { couldn't open program file }
        if obj_ptr^.ObjFile^.refnum = -1 then
          Recover (e_prog_open)
        else
          Recover (e_fsread)
      end;

    found := false;
    repeat
      GetObjInvar (obj_ptr, obj_block);
      if obj_ptr^.error > 0 then Recover (e_fsread);

      case obj_block.blockHeader of
        VersionCtrl, OSData, UnitTable, Executable :
          { skip };

        SegmentTable :
          found := true;

        otherwise
          Recover (e_inv_progfile)
      end
    until found;

    Open_IUDirectory (IUD_refnum);
    if IUD_refnum = -1 then Recover (e_fsread);

    Build_SegList;
    if obj_ptr^.error > 0 then Recover (e_fsread);

    { determine library segments needed by the program }
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    with lcb_ptr^ do
      begin
        sDirEntry_ptr := pointer(ord(@sSeg_Dir^[1]) - Sizeof (SegDirEntry));
        max_segs := num_sSegs;
        i := 1;

        repeat
          sDirEntry_ptr := pointer(ord(sDirEntry_ptr) + Sizeof (SegDirEntry));
          with sDirEntry_ptr^ do
            if seg_list[sNumber] then
              file_list[File_Dir^[sFileNum].fNumber] := true;

          i := i + 1
        until i > max_segs
      end;

    Close_IUDirectory (IUD_refnum);
    CloseObjFile (obj_ptr, true);
    errnum := 0
  end { List_LibFiles };


procedure LibFileName (* var errnum : integer;  lf_num : integer;
                         var lf_name : pathname *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   System call procedure to return the pathname of a       *)
        (*   particular intrinsic library file.                      *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   lf_num : the number of the library file whose name is   *)
        (*            to be returned.                                *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   errnum : the error return parameter for this system     *)
        (*            call procedure (see values below).             *)
        (*                                                           *)
        (*   lf_name : the pathname of the specified library file.   *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This routine is intended to be called only from the     *)
        (*   privileged OS interface.                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   If no entry exists in the Intrinsic Unit Directory for  *)
        (*   the specified library file number, an error is          *)
        (*   returned.                                               *)
        (*                                                           *)
        (*************************************************************)

  var
    IUD_refnum : int2;                    { refnum for opening IU Directory seg }
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    i : int2;                             { for scanning Library File Table }
    found : boolean;                      { true if directory entry found }

  begin
    Open_IUDirectory (IUD_refnum);
    if IUD_refnum = -1 then
      begin  { error opening IU Directory }
        errnum := 198;
        exit (LibFileName)
      end;

    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);

    with lcb_ptr^ do
      begin
        i := 1;   found := false;
        while (i <= num_lFiles) and not found do
          if File_Dir^[i].fNumber = lf_num then
            found := true
          else
            i := i + 1;

        if not found then
          errnum := 199   { can't find library file # }
        else
          begin
            lf_name := File_Dir^[i].fName_ptr^;
            errnum := 0
          end
      end { with lcb_ptr^ };

    Close_IUDirectory (IUD_refnum)
  end { LibFileName };

(*$S kr_prims *)   { for Process Display }

procedure Get_PName (* var errnum : int2;  proc_id : int4;  fullName : boolean;
                       var progname : pathname *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to return the name of the program file being  *)
        (*   executed by the specified process.  The Loader's data   *)
        (*   structures are used to get to the DCB and FCB for the   *)
        (*   program file being executed by the process.  From       *)
        (*   data structures, the device and file names are          *)
        (*   obtained and the full pathname for the program file is  *)
        (*   constructed.                                            *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   proc_id : the global process ID of the process whose    *)
        (*             program file name is to be returned.          *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   errnum : the errnum parameter for this procedure.  See  *)
        (*            values below.                                  *)
        (*                                                           *)
        (*   progname : the full pathname of the program file being  *)
        (*              executed by the process.  The name '' is     *)
        (*              if proc_id specifies a system process.       *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   None, although this procedure has some knowledge of     *)
        (*   File System structures which could change.              *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   errnum = 100   specified process doesn't exist          *)
        (*                                                           *)
        (*************************************************************)

  var
    pcb_ptr : ptr_PCB;                    { ptr to PCB for specified process }
    plcb_ptr : ptr_PLCB;                  { ptr to PLCB for program }

  begin
    Find_PCB (errnum, true, proc_id, pcb_ptr);

    if errnum = 0 then
      begin  { proc_id is for an existing process }
        if pcb_ptr^.plcbRP = 0 then
          progname := ''   { a system process or one that's unloading }
        else
          begin  { a user process }
            plcb_ptr := pointer(pcb_ptr^.plcbRP + b_sysglobal_ptr);

            { s-file is open for sure, so fcb_ptr is valid }
            with plcb_ptr^ do
              if fullName then GetPathname (progfcb_ptr, progname)
              else
                with progfcb_ptr^ do
                  progname := Concat ('-', configinfo[curdev]^.devname, '-...-',
                                      fname)
          end { user process }
      end { proc_id is valid }
  end { Get_PName };


(*$S ProcTerm *)

procedure Unload_SharedSegs (seg_list : sseg_list;  last_sseg : sSegRange);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to unload the shared segments in the shared   *)
        (*   segment list of the specified PLCB for the specified    *)
        (*   range.  The 1st through last_sseg segments in the list  *)
        (*   are unloaded.                                           *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   plcb_ptr : a ptr to the PLCB of the program whose       *)
        (*              shared segments are to be unloaded.          *)
        (*                                                           *)
        (*   last_sseg : the last segment in the shared segment      *)
        (*               list of the PLCB to be unloaded.            *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This procedure is intended to be used only by           *)
        (*   procedures Load_Program and Unload_Program.             *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   None should occur since the library files are all       *)
        (*   open.  Any errors are ignored.                          *)
        (*                                                           *)
        (*************************************************************)

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }
    sDirEntry_ptr : ptr_SegDirEntry;      { ptr to a Segment directory entry }
    index : int2;                         { index for scanning Segment Directory }
    sseg_fcbptr : sfcb_ptr;               { ptr to FCB for shared seg s-file }
    sseg_sdbptr : sdb_ptr;                { ptr to SDB for a shared segment }
    errnum : int2;                        { error return from Close_SFile }

  begin
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);

    index := last_sseg;
    sDirEntry_ptr := @lcb_ptr^.sSeg_Dir^[last_sseg];

    while index > 0 do
      begin
        with sDirEntry_ptr^ do
          if seg_list[sNumber] then
            begin  { segment is used by program }
              sUse_count := sUse_count - 1;

              if sUse_count = 0 then
                begin  { release the segment }
                  sseg_sdbptr := sSegsdb_ptr;
                  sSegsdb_ptr := nil;
                  Rel_Seg (sseg_sdbptr);

                  with lcb_ptr^.File_Dir^[sFileNum] do
                    begin
                      fUse_count := fUse_count - 1;
                      if fUse_count = 0 then
                        begin  { close the library file }
                          sseg_fcbptr := pointer(fFid + b_sysglobal_ptr);
                          fFid := 0;
                          Close_SFile (errnum, sseg_fcbptr);
                          (*$IFC debug2 *)
                          if errnum <> 0 then
                            begin
                              writeln ('Unload_SharedSegs: error closing s-file = ',
                                       errnum:1);
                              readln
                            end;
                          (*$ENDC *)
                        end { close lib file }
                    end { with File_Dir^[sFileNum] }
                end { release segment }
            end { segment is used };

        sDirEntry_ptr := pointer(ord(sDirEntry_ptr) - Sizeof (SegDirEntry));
        index := index - 1
      end { while }
  end { Unload_SharedSegs };


procedure Free_Program (plcb_ptr : ptr_PLCB;  var fcb_ptr : sfcb_ptr);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to 'unload' a program from the operating      *)
        (*   system.  The # of processes running this program is     *)
        (*   decremented.  If the count goes to 0, the program is    *)
        (*   unloaded.  Unloading involves releasing all private     *)
        (*   segments used by the program, decrementing use counts   *)
        (*   and releasing space for shared Intrinsic Units used by  *)
        (*   the program, and decrementing use counts and releasing  *)
        (*   any shared segments used by the program.                *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This procedure is intended only to be used by Expire    *)
        (*   only when a process is terminating.                     *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   If the IU Directory can't be opened, the process will   *)
        (*   continue terminating, but the program will be left      *)
        (*   loaded.  This could probably only occur if i/o errors   *)
        (*   are encountered during swapping.                        *)
        (*                                                           *)
        (*************************************************************)

  var
    errnum : int2;                        { error return from Close_SFile }
    IUD_refnum : int2;                    { refnum for opening IU Directory seg }
    i : int2;                             { loop index for scanning PLCB lists }
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }

  procedure Recover;
    { procedure used by Free_Program to recover from errors encountered while
      unloading the calling process's program. }

    begin
      { recover from error opening IU Directory }
      RelSpace (ord(plcb_ptr), b_sysglobal_ptr);

      with lcb_ptr^ do
        n_progs_loaded := n_progs_loaded - 1;

      { shared IU data spaces & shared code segments are left loaded }
      exit (Free_Program)
    end { Recover };


  begin
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);

    with plcb_ptr^ do
      begin
        { remove PLCB from Loader's list }
        bkwd_chain^.fwd_chain := fwd_chain;
        fwd_chain^.bkwd_chain := bkwd_chain;

        { unload program's private segments 1st }
        Close_SFile (errnum, progfcb_ptr);
        (*$IFC debug2 *)
        if errnum <> 0 then
          begin
            writeln ('   Unload: error closing prog s-file = ', errnum);
            readln
          end;
        (*$ENDC *)
        fcb_ptr := progfcb_ptr;   { for use by Free_LPs & its callers }

        for i := 1 to n_pri_segs do Rel_Seg (pSeg_list^[i]);

        Open_IUDirectory (IUD_refnum);
        if IUD_refnum = -1 then Recover;

        { 'unload' shared intrinsic unit data spaces }
        Free_SharedIUs (prog_iuList, lcb_ptr^.num_IUs, true { release });

        { unload all shared segments used by program }
        Unload_SharedSegs (prog_segList, lcb_ptr^.num_sSegs);

        { release PLCB for the unloaded program }
        RelSpace (ord(jmpTable), MMU_Base (LDSN_to_MMU (IDir_ldsn)));
        RelSpace (ord(plcb_ptr), b_sysglobal_ptr);

        { decrement # of program loads }
        with lcb_ptr^ do
          n_progs_loaded := n_progs_loaded - 1;

        Close_IUDirectory (IUD_refnum)
      end { with plcb_ptr^ }
  end { Free_Program };


