; Copyright 1983, 1984, Apple Computer Inc.


; File build:osdefs.text

; contains conditional falgs definitions for paslib
; to be included in pasio, and pasinit

; conditional flag for producing paslib for os vs application program

ospaslib        equ     0               ; to generate paslib for os to link with
appaslib        equ     1               ; to generate paslib for application program
                                        ; to link with

LIBPRODUCING    equ     ospaslib


; conditional flag for producing paslib for monitor based os vs stand alone os

undermonitor    equ     1               ; paslib to be linked with in monitor based os
                                        ; environment
standalone      equ     2               ; paslib to be linked with in stand alone os
                                        ; environment

PRODUCING       equ     standalone

; File: PASINIT.TEXT
; Date: 09-Oct-81, Modified : 8-Dec-81
;

        .PROC   %%%INIT

        .DEF    %_BEGIN,%_END,%_INIT

        .if     libproducing=appaslib
        .ref    init_excep, %_pphhpreinit, %_pphhreinit, blockiosetup
        .ref    force_term_excep
        .ref    %_initfp
        .ref    getFileaddr
        .endc

;
; %_BEGIN - The initial routine when executing under UCSD
;
; Upon entry the stack is:
;
; |-----------|
; | ^$$FIRST  |         Note : This is not true in OS environment.
; |  Segbank  |
; |  Old A6   |
; |  Old A5   |
; |  Old A4   |
; |  Old A3   |
; |  Old A2   |
; |  Old D7   |
; |  Old D6   |
; |  Old D5   |
; |  Old D4   |
; |  Old D3   |
; | ^ output  |
; |  ^ input  |
; | Ret. Addr |
; | Ret. Addr | <-- SP
; |-----------|
;

%_BEGIN:
        RTS

;
; Once the main program has done a:
;
;       LINK    #xxx,A5
;
; the stack will be:
;
; |-----------|    +62
; | ^$$FIRST  |    +58          Note : This is not true in OS environment.
; |  Segbank  |    +56
; |  Old A6   |    +52
; |  Old A5   |    +48
; |  Old A4   |    +44
; |  Old A3   |    +40
; |  Old A2   |    +36
; |  Old D7   |    +32
; |  Old D6   |    +28
; |  Old D5   |    +24
; |  Old D4   |    +20
; |  Old D3   |    +16
; | ^ Output  |    +12
; |  ^ Input  |     +8
; | Ret. Addr |     +4
; |  Old A5   | <-- A5
; |-----------|
; |    ...    |
; |  Globals  |
; |    ...    |
; |-----------| <-- SP
;

;
; %_END - The Final Routine when executing under UCSD
;

%_END:
        RTS

;
; The resulting stack is:
;
; |-----------|
; | ^$$FIRST  |                 Note : This is not true in OS environment.
; |  Segbank  |
; |  Old A6   |
; |  Old A5   |
; |  Old A4   |
; |  Old A3   |
; |  Old A2   |
; |  Old D7   |
; |  Old D6   |
; |  Old D5   |
; |  Old D4   |
; |  Old D3   |
; | ^ output  |
; |  ^ input  |
; | Ret. Addr |
; | Ret. Addr | <-- SP
; |-----------|
;

;
; %_INIT - Initialization routine for every program
;
; Note : with current resident program scheme, the main program must have the
;   following preemble and postemble
;       JSR     %_BEGIN
;       LINK    A6,#0
;       MOVE.L  (A7)+,A6        ; for Lisabug to find preemble
;       LINK    A5,#0
;       SUBA.L  $10(A5),A7      ; reserve space for unit global data
;       JSR     %_INIT
;       ...                     ; program code
;
;       JSR     %_TERM          ; should terminate the process here
;       UNLK    A5              ; the following is not executed on OS.
;       JSR     %_END
;       RTS
;       UNLK    A6
;       RTS
;
;  If this code is no longer true, %_init must be changed to make resident work.
;
;

;
%_INIT:
        TST.W   -100(A7)                ; force stack expansion, if needed

        .if     libproducing=appaslib

        lea     def_fline,a0            ; get default f-line trap routine address
        move.l  a0,d0
        andi.l  #$ffffff,d0             ; get 24 bits only
        ori.l   #iujmpop,d0             ; put the iujmp op code in front
        move.l  d0,flineoffset(a5)      ; put 'iujmp def_fline' into the proper
                                        ; offset from a5

        pea     inputfo(a5)             ; infaddr par
        pea     outputfo(a5)            ; outfaddr par
        jsr     getFileaddr             ; get the INPUT/OUTPUT file address

; at this point, the stack should have just the return pc
                                        ; set up environment record
        move.l  sp,-(sp)                ; sp_init
        move.l  4(sp),-(sp)             ; pc_retinit
        pea     PC2Blockiosetup         ; pc_2setup
        move.l  a6,-(sp)                ; a6_init
        move.b  #1,-(sp)                ; firsttime := true
        pea     2(sp)                   ; address of regis param
        jsr     blockiosetup            ; first call to blockiosetup, in blockio
        adda.l  #sizeenvir,sp           ; pop envir record

        jsr     init_excep              ; in oslib to initialize syslocal cell
        jsr     %_pphhpreinit           ; in pasheap to init heap pointer

PC2Blockiosetup                         ; resident program restarts from here
        clr.b   -(sp)                   ; firsttime := false;
        pea     2(sp)                   ; address of regis param, not used
        jsr     blockiosetup            ; second call and restart init call

        jsr     %_pphhreinit            ; reinit the heap
        move.l  fpptr_data(a5),d0       ; pointer to fplib unit's data
        ble     @1                      ; nil or bad pointer - fplib not linked
        move.l  d0,-(sp)                ; pointer argument
        jsr     %_initfp                ; in fpinit
@1
        .endc

        RTS
;

; The follow rouitne will be entered when f-line trap occurs in a process
; that does not use the floating point library routines

        .if     libproducing=appaslib
exdatasize      .equ    48              ; excep_data has 48 bytes
line_1111       .equ    27              ; excep_kind in the excep_data for
                                        ; f-line trap
def_fline                               ; default f-line trap handler routine
        move.l  #exdatasize,d0          ; exception data block size
        suba.l  d0,sp                   ; set sup space for it on stack
        move.l  #line_1111,(sp)         ; excep_kind = line_1111
        move.w  sr,4(sp)                ; save sr
        move.l  a0,6(sp)                ; save user's pc
        move.l  sp,-(sp)                ; address of excep_data
        jsr     force_term_excep        ; system call to froce termination
                                        ; with excep_data passed to terminate
                                        ; exception handler
                                        ; This will never return
        .endc






; File: PASMISC.TEXT
; Date: 09-Oct-81

        .PROC   %%%MISC

        .DEF    %_IOERR,%_GOTOXY,%_GOTO,%_LSTSG      ; %_HALT is moved to PASTERM

        .if     libproducing=appaslib
        .ref    gotoxy
        .endc

;
; %_IOERR - I/O Error check
;

%_IOERR:
        MOVEM.L D0-D7/A0-A6,-(SP)
        PEA     IO.DONE
        MOVE.W  #84,-(A7)
        TRAP    #$E
IO.DONE:MOVEM.L (SP)+,D0-D7/A0-A6
        RTS

;
; %_GOTOXY - gotoxy
;
; Parameters: ST.W - X coordinate
;             ST.W - Y coordinate
;

%_GOTOXY:
        .if     libproducing=ospaslib
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.W  (SP)+,D0        ; Pop Y value
        MOVE.W  (SP)+,D1        ; Pop X value
        MOVEM.L D0-D7/A0-A6,-(SP)
        PEA     GO.DONE         ; Push return address
        MOVE.W  D1,-(SP)        ; Push X
        MOVE.W  D0,-(SP)        ; Push Y
        MOVE.W  #88,-(A7)
        TRAP    #$E
GO.DONE:MOVEM.L (SP)+,D0-D7/A0-A6
        JMP     (A2)
        .endc

        .if     libproducing=appaslib
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.W  (SP)+,D0        ; Pop Y value
        MOVE.W  (SP)+,D1        ; Pop X value
        MOVEM.L D0-D7/A0-A6,-(SP)
        MOVE.W  D1,-(SP)        ; Push X
        MOVE.W  D0,-(SP)        ; Push Y
        jsr     gotoxy          ; in blkiointr unit
        MOVEM.L (SP)+,D0-D7/A0-A6
        JMP     (A2)
        .endc

;
; %_GOTO - Global GOTO code segment remover
;
; Parameters: ST.L - Pointer to the desired last-segment jump table
;

%_GOTO
        MOVE.L  (SP)+,A0                          ; return pc
        ADDQ.L  #4,SP                             ; pop unload level (not used)
        JMP     (A0)                              ; return


;
; %_LSTSG - Return the address of the last segment descriptor
;
; Parameters: ST.L - Room for the result
;

%_LSTSG:
        CLR.L   4(SP)           ; Return zero.
        RTS


; File: PASMOVE.TEXT
; Date: 09-Oct-81

        .PROC   %%%MOVE

        .DEF    %_MOVEL,%_MOVER,%_FILLC,%_SCANE,%_SCANN

;
; %_MOVEL - Moveleft
;
; Parameters: ST.L - From Address
;             ST.L - To Address
;             ST.W - # Bytes to move
;
; uses do, d1, d2, a0, a1, a2

%_MOVEL:
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.W  (SP)+,D0        ; Pop # bytes
        MOVE.L  (SP)+,A0        ; Pop TO address
        MOVE.L  (SP)+,A1        ; Pop FROM address
        tst.b   (a1)            ; make data resident in case it is in code seg
;        BRA.S   L.TEST
;L.LOOP: MOVE.B  (A1)+,(A0)+
;L.TEST: dbra    d0,L.LOOP       ; dec d0 and branch if d0 <> -1
        ;LOAD SOURCE INTO A1, DEST INTO A0, LENGTH INTO D0
        ;ALSO USES D1-D2  ***** The following code is supplied by Dave Offen
        CMP     #7,D0
        BLE.S   FWD1                    ;SHORT MOVES GO 1 AT A TIME
        MOVE.L  A1,D2
        ADDQ.L  #2,D2
        CMP.L   A0,D2                   ;IF SOURCE+2 = DEST THEN
        BEQ.S   FWD1                    ;MOVE 1 AT A TIME BECAUSE 4 WON'T PROPAGATE
        MOVE    A0,D1                   ;FIND OUT IF SOURCE OR DEST ADDR ARE ODD
        AND     #1,D1                   ;D1 =1 IFF DEST IS ODD
        AND     #1,D2                   ;D2 =1 IFF SOURCE IS ODD
        ADD     D1,D2
        BEQ.S   @3                      ;SKIP IF BOTH EVEN
        SUBQ    #1,D2
        BEQ.S   FWD1                    ;ONE AT A TIME IF ONE EVEN, ONE ODD
        SUBQ    #1,D0                   ;BOTH ODD, TAKE 1 OFF TOTAL LENGTH
        MOVE.B  (A1)+,(A0)+             ; AND XFER 1 BYTE FIRST
@3      MOVE    D0,D1                   ;SOURCE & DEST BOTH EVEN OR BOTH ODD
        AND     #3,D0                   ;1-BYTE-COUNT
        LSR     #2,D1                   ;4-BYTE COUNT INTO D0
        SUBQ    #1,D1                   ;NON-NEG RESULT SINCE ALWAYS MOVE >= 4
@4      MOVE.L  (A1)+,(A0)+             ;4-BYTE MOVES
        DBF     D1,@4

        ;1-BYTE MOVES

        SUBQ    #1,D0                   ;LENGTH
        BMI.S   DUN                     ;NO SINGLE BYTES TO MOVE
F       MOVE.B  (A1)+,(A0)+
FWD1    DBF     D0,F
DUN
        JMP     (A2)

;
; %_MOVER - Moveright
;
; Parameters: ST.L - From Address
;             ST.L - To Address
;             ST.W - # Bytes to move
;

%_MOVER:
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.W  (SP)+,D0        ; Pop # bytes
        MOVE.L  (SP)+,A0        ; Pop TO address
        MOVE.L  (SP)+,A1        ; Pop FROM address
        tst.b   (a1)            ; make data resident in case it is in code seg
        ADDA.W  D0,A0
        ADDA.W  D0,A1
        BRA.S   R.TEST
R.LOOP: MOVE.B  -(A1),-(A0)
R.TEST: dbra    d0,R.LOOP       ; dec d0 and branch if d0 <> -1
        JMP     (A2)

;
; %_FILLC - Fillchar
;
; Parameters: ST.L - Address to fill
;             ST.W - # Bytes
;             ST.W - Char
;

%_FILLC:
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.W  (SP)+,D0        ; Pop character
        MOVE.W  (SP)+,D1        ; Pop # bytes
        MOVE.L  (SP)+,A0        ; Pop address to fill
        BRA.S   F.TEST
F.LOOP: MOVE.B  D0,(A0)+
F.TEST: dbra    d1,F.LOOP       ; dec d0 and branch if d0 <> -1
        JMP     (A2)

;
; %_SCANE - Scan equal
;
; Parameters: ST.W - Length to scan
;             ST.W - Character to scan for
;             ST.L - Address to scan
;
; Result:     ST.W - Result
;
; All registers are preserved.
;

%_SCANE:
        MOVEM.L D0-D2/A0,-(SP)
        CLR.W   D2              ; The Result
        MOVE.L  20(SP),A0       ; Address to scan
        tst.b   (a0)            ; make data resident in case it is in code seg
        MOVE.W  24(SP),D0       ; Character to scan for
        MOVE.W  26(SP),D1       ; Length to scan
        BEQ.S   SE.DONE
        BMI.S   SE.MI
EP.LOOP:CMP.B   (A0)+,D0
        BEQ.S   SE.DONE
        ADDQ.W  #1,D2           ; Bump result
        SUBQ.W  #1,D1
        BGT.S   EP.LOOP
        BRA.S   SE.DONE
SE.MI:  ADDQ.L  #1,A0
EM.LOOP:CMP.B   -(A0),D0
        BEQ.S   SE.DONE
        SUBQ.W  #1,D2
        ADDQ.W  #1,D1
        BMI.S   EM.LOOP
SE.DONE:MOVE.W  D2,26(SP)       ; Store the result
        MOVE.L  16(SP),22(SP)   ; Set up return address
        MOVEM.L (SP)+,D0-D2/A0
        ADDQ.L  #6,SP
        RTS

;
; %_SCANN - Scan not equal
;
; Parameters: ST.W - Length to scan
;             ST.W - Character to scan for
;             ST.L - Address to scan
;
; Result:     ST.W - Result
;
; All registers are preserved.
;

%_SCANN:
        MOVEM.L D0-D2/A0,-(SP)
        CLR.W   D2              ; The Result
        MOVE.L  20(SP),A0       ; Address to scan
        tst.b   (a0)            ; make data resident in case it is in code seg
        MOVE.W  24(SP),D0       ; Character to scan for
        MOVE.W  26(SP),D1       ; Length to scan
        BEQ.S   SN.DONE
        BMI.S   SN.MI
NP.LOOP:CMP.B   (A0)+,D0
        BNE.S   SN.DONE
        ADDQ.W  #1,D2           ; Bump result
        SUBQ.W  #1,D1
        BGT.S   NP.LOOP
        BRA.S   SN.DONE
SN.MI:  ADDQ.L  #1,A0
NM.LOOP:CMP.B   -(A0),D0
        BNE.S   SN.DONE
        SUBQ.W  #1,D2
        ADDQ.W  #1,D1
        BMI.S   NM.LOOP
SN.DONE:MOVE.W  D2,26(SP)       ; Store the result
        MOVE.L  16(SP),22(SP)   ; Set up return address
        MOVEM.L (SP)+,D0-D2/A0
        ADDQ.L  #6,SP
        RTS


; File: PASRANGE.TEXT
; Date: 3-Dec-81

        .PROC   %%%RANGE

        .DEF    %_RCHCK,%_SRCHK
        .ref    rangeerror

;
; %_RCHCK - Range check
;
;
; Parameters:  ST.W - Value to check
;              ST.W - Lower bound
;              ST.W - Upper bound
;
; Returns:     ---
;
; All regsters are preserved.
;

%_RCHCK
        MOVEM.L D0-D2,-(SP)
        MOVE.W  20(SP),D0       ; value to check
        MOVE.W  18(SP),D1       ; lower bound
        MOVE.W  16(SP),D2       ; upper bound
        CMP.W   D0,D2
        blt.S   @2
        CMP.W   D0,D1
        bgt.S   @2
        MOVEM.L (SP)+,D0-D2     ; everything ok
@1      MOVE.L  (SP),6(SP)      ; Move return address
        ADDQ.L  #6,SP           ; Pop junk
        RTS

@2      movem.l (sp)+,d0-d2
        movem.l d0-d7/a0-a6,-(sp)       ; save all registers before calling os
        move.w  15*4+8(sp),-(sp)        ; get value to check
        move.w  15*4+8(sp),-(sp)        ; get lower bound
        move.w  15*4+8(sp),-(sp)        ; get upper bound
        move.b  #1,-(sp)                ; rangekind = true for value range error
        jsr     rangeerror              ; call rangeerror in oslib to signal excep
        movem.l (sp)+,d0-d7/a0-a6       ; restore all registers
        bra.s   @1

;
; %_SRCHK - String range check
;
;
; Parameters:  ST.B - Value to check: 0..255
;              ST.W - Upper bound
;
; Returns:     ---
;
; All regsters are preserved.
;

%_SRCHK
        MOVEM.L D0-D1,-(SP)
        MOVE.B  14(SP),D0       ; value to check
        EXT.W   D0
        MOVE.W  12(SP),D1       ; upper bound
        CMP.W   D0,D1
        blt.S   @2
        MOVEM.L (SP)+,D0-D1
@1      MOVE.L  (SP),4(SP)      ; Move return address
        ADDQ.L  #4,SP           ; Pop junk
        RTS

@2      movem.l (sp)+,d0-d1
        movem.l d0-d7/a0-a6,-(sp)       ; save all registers before calling os
        move.b  15*4+6(sp),d0           ; value to check
        ext.w   d0
        move.w  d0,-(sp)                ; push value on stack
        move.w  #1,-(sp)                ; lower bound = 1 for string index
        move.w  15*4+8(sp),-(sp)        ; upper bound
        clr.w   -(sp)                   ; rangekind = false for string index error
        jsr     rangeerror              ; call rangeerror in oslib to signal excep.
        movem.l (sp)+,d0-d7/a0-a6       ; restore all registers
        bra.s   @1


; File: PASSCOMP.TEXT
; Date: 09-Oct-81

        .PROC   %%%SCOMP

        .DEF    %S_EQ,%S_NE,%S_LE,%S_GE,%S_LT,%S_GT

;
; String  compares:  The format for all string compares is as follows:
;
; Parameters: ST.L - Address of first string
;             ST.L - Address of second string
;
; Returns:    ST.B - Boolean result
;
; All registers are preserved.
;

;
; %S_NE - String not equal
;

%S_NE:
        MOVEM.L D0-D1/A0-A1,-(SP)
        MOVEQ   #1,D1           ; D1 get result if strings <>
        BRA.S   S.EQNE

;
; %S_EQ - String equal
;

%S_EQ:
        MOVEM.L D0-D1/A0-A1,-(SP)
        CLR.W   D1              ; D1 gets result if strings <>
S.EQNE: MOVE.L  24(SP),A0       ; Address of first string
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.L  20(SP),A1       ; Address of second string
        tst.b   (a1)            ; make resident in case it is in code seg
        CLR.W   D0
        MOVE.B  (A0)+,D0        ; Length of first string
        CMP.B   (A1)+,D0        ; Compared to length of second
        BNE.S   NOT.EQ
        BRA.S   EQ.TEST
EQ.LOOP:CMPM.B  (A0)+,(A1)+
        BNE.S   NOT.EQ
EQ.TEST:dbra    D0,EQ.LOOP      ; dec d0 and branch if d0 <> -1
        EORI.W  #1,D1           ; They are equal. Negate result.
NOT.EQ: MOVE.B  D1,26(SP)       ; Store the result
        MOVE.L  16(SP),22(SP)   ; Set up return address
        MOVEM.L (SP)+,D0-D1/A0-A1
        ADDQ.L  #6,SP           ; Adjust SP
        RTS

;
; %S_GT - String greater than
;

%S_GT:
        MOVEM.L D0-D3/A0-A1,-(SP)
        MOVE.L  32(SP),A1       ; Address of first string
        tst.b   (a1)            ; make resident in case it is in code seg
        MOVE.L  28(SP),A0       ; Address of second string
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVEQ   #1,D3           ; D3 = result if (A0) < (A1)
        BRA.S   STRCOMP

;
; %S_LE - String less than or equal
;

%S_LE:
        MOVEM.L D0-D3/A0-A1,-(SP)
        MOVE.L  32(SP),A1       ; Address of first string
        tst.b   (a1)            ; make resident in case it is in code seg
        MOVE.L  28(SP),A0       ; Address of second string
        tst.b   (a0)            ; make resident in case it is in code seg
        CLR.W   D3              ; D3 = result if (A0) < (A1)
        BRA.S   STRCOMP

;
; %S_LT - String less than
;

%S_LT:
        MOVEM.L D0-D3/A0-A1,-(SP)
        MOVE.L  32(SP),A0       ; Address of first string
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.L  28(SP),A1       ; Address of second string
        tst.b   (a1)            ; make resident in case it is in code seg
        MOVEQ   #1,D3           ; D3 = result if (A0) < (A1)
        BRA.S   STRCOMP

;
; %S_GE - String grater than or equal
;

%S_GE:
        MOVEM.L D0-D3/A0-A1,-(SP)
        MOVE.L  32(SP),A0       ; Address of first string
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.L  28(SP),A1       ; Address of second string
        tst.b   (a1)            ; make resident in case it is in code seg
        CLR.W   D3              ; D3 = result if (A0) < (A1)
STRCOMP:CLR.W   D0
        MOVE.B  (A0)+,D0        ; D0 = length of (A0)
        CLR.W   D1
        MOVE.B  (A1)+,D1        ; D1 = length of (A1)
        CMP.W   D0,D1
        BLT.S   A1SHORT
        MOVE.W  D0,D2
        BRA.S   X.TEST
A1SHORT:MOVE.W  D1,D2           ; D2 gets minimum length
        BRA.S   X.TEST
X.LOOP: CMPM.B  (A0)+,(A1)+
        BNE.S   X.NE
X.TEST: dbra    D2,X.LOOP       ; dec d2 and branch if d2 <> -1
        CMP.W   D0,D1           ; Common part is equal
        BGT.S   X.DONE          ; So shorter one is less than
X.TRUE: EORI.W  #1,D3           ; Update result
        BRA.S   X.DONE
X.NE:   BLS.S   X.TRUE
X.DONE: MOVE.B  D3,34(SP)       ; Store result
        MOVE.L  24(SP),30(SP)   ; Set up return address
        MOVEM.L (SP)+,D0-D3/A0-A1
        ADDQ.L  #6,SP
        RTS


; File: PASSET.TEXT
; Date: 09-Oct-81

        .PROC   %%%SET

        .DEF    %_UNION,%_DIFF,%_RDIFF,%_INTER
        .DEF    %_SING,%_RANGE
        .DEF    %_ADJ,%_SETGE,%_SETLE,%_SETEQ,%_SETNE

;
; The format of a set on the stack is:
;
;  +---------+
;  | 15 - 0  |
;  +---------+
;  | 31 - 16 |
;  +---------+
;  |   ...   |
;  +---------+
;  | Last Wd |
;  +---------+
;  | # Bytes |
;  +---------+
;

;
; %_INTER - Set intersection
;
; Parameters: ST.S - First set
;             ST.S - Second set
;
; Returns:    ST.S - Result set
;
; This procedure saves all registers
;

%_INTER:
        CLR.L   -(SP)           ; Need room if both sets []
        MOVEM.L D0-D2/A0-A1,-(SP)
        LEA     28(SP),A0       ; Address of second set
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.W  (A0)+,D0        ; Size of second set
        ADDA.W  D0,A0           ; Address of top of set 2 +
        MOVE.L  A0,A1           ; Address of first set
        tst.b   (a1)            ; make resident in case it is in code seg
        MOVE.W  (A1)+,D1        ; Size of first set
        ADDA.W  D1,A1           ; Address of top of set 1 +
        CMP.W   D0,D1
        BGE.S   I.GOON
        MOVE.W  D1,D0
I.GOON: MOVE.W  D0,D1           ; D0 and D1 = smallest size set
        LSR.W   #1,D0           ; D0 = number words
        BRA.S   I.TEST
I.LOOP: MOVE.W  -(A0),D2
        AND.W   D2,-(A1)
I.TEST: dbra    D0,I.LOOP       ; dec d0 and branch if d0 <> -1
        MOVE.W  D1,-(A1)        ; Store set size
        MOVE.L  24(SP),A0       ; Set up return address
        MOVE.L  A0,-(A1)        ; Can't do MOVE.L 24(SP),-(A0)
        MOVE.L  A1,20(SP)       ; Set up new SP value
        MOVEM.L (SP)+,D0-D2/A0-A1
        MOVE.L  (SP)+,SP        ; Pop new SP value
        RTS

;
; %_SING - Singleton set
;
; Parameters: ST.W - Singleton value
;
; Result:     ST.S - Resulting set
;
; This routine saves all registers
;

%_SING:
        MOVEM.L D0-D4/A0-A2,-(SP)
        LEA     36(SP),A0       ; address of singleton value
        MOVE.W  (A0),D0         ; D0 = singleton value
        CLR.W   (A0)            ; Default 1st word of result to zero
        MOVE.W  D0,D1
        LSR.W   #4,D1           ; D1 = # Words of leading zeroes
        MOVE.W  D1,D2
        ADD.W   #1,D2           ; D2 = # Words to insert into stack
        MOVE.W  D2,D3
        LSL.W   #1,D3           ; D3 = # Bytes to insert into stack
        MOVE.L  SP,A1           ; Current top of stack
        SUB.W   D3,SP
        MOVE.L  SP,A2           ; New top of stack
        MOVE.W  #18,D4          ; # Words to copy in D4
S.LOOP1:MOVE.W  (A1)+,(A2)+     ; Copy each remaining word
        SUB.W   #1,D4
        BNE.S   S.LOOP1
ZEROSTK:MOVE.L  A2,A0
S.LOOP2:CLR.W   (A2)+           ; Default each word of result to zero
        SUB.W   #1,D2
        BNE.S   S.LOOP2
        MOVE.W  D3,(A0)+        ; Copy #bytes in last word of set
        CLR.W   D2
        ANDI.W  #$F,D0          ; Mask off 4 bits
        BSET    D0,D2           ; Set the bit
        MOVE.W  D2,(A0)         ; Copy word with bit set into stack
        MOVEM.L (SP)+,D0-D4/A0-A2
        RTS

;
; %_UNION - Set union
;
; Parameters: ST.S - First set
;             ST.S - Second set
;
; Returns:    ST.S - Result set
;
; This procedure saves all registers
;

%_UNION:
        CLR.L   -(SP)
        MOVEM.L D0-D3/A0-A1,-(SP)
        LEA     32(SP),A0       ; Address of second set
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.W  (A0)+,D0        ; Size of second set
        ADDA.W  D0,A0           ; Address of top of set 2 +
        MOVE.L  A0,A1           ; Address of first set
        MOVE.W  (A1)+,D1        ; Size of first set
        ADDA.W  D1,A1           ; Address of top of set 1 +
        MOVE.W  D0,D3
        CMP.W   D0,D1
        BGE.S   U.GOON
        MOVE.W  D1,D3           ; D3 = smallest set size
U.GOON: LSR.W   #1,D3           ; D3 = # Words
        BRA.S   U.TEST
U.LOOP: MOVE.W  -(A0),D2
        OR.W    D2,-(A1)
U.TEST: dbra    D3,U.LOOP       ; dec d3 and branch if d3 <> -1
        SUB.W   D1,D0           ; Compare set sizes
        BEQ.S   U.DONE          ; Finish up if same size
        BLT.S   U.A.BIG
        ADD.W   D0,D1           ; D1 = Biggest Size
        LSR.W   #1,D0           ; D0 = # Words bigger
UB.LOOP:MOVE.W  -(A0),-(A1)
        SUBQ.W  #1,D0
        BGT.S   UB.LOOP
        BRA.S   U.DONE
U.A.BIG:ADDA.W  D0,A1           ; First set is bigger
U.DONE: MOVE.W  D1,-(A1)        ; Store set size
        MOVE.L  28(SP),A0       ; Set up return address
        MOVE.L  A0,-(A1)
        MOVE.L  A1,24(SP)       ; Set up new SP value
        MOVEM.L (SP)+,D0-D3/A0-A1
        MOVE.L  (SP)+,SP        ; Pop new SP value
        RTS

;
; %_DIFF - Set difference
;
; Parameters: ST.S - First set
;             ST.S - Second set
;
; Returns:    ST.S - Result set
;
; This procedure saves all registers
;

%_DIFF:
        CLR.L   -(SP)
        MOVEM.L D0-D3/A0-A1,-(SP)
        LEA     32(SP),A0       ; Address of second set
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.W  (A0)+,D0        ; Size of second set
        ADDA.W  D0,A0           ; Address of top of set 2 +
        MOVE.L  A0,A1           ; Address of first set
        MOVE.W  (A1)+,D1        ; Size of first set
        ADDA.W  D1,A1           ; Address of top of set 1 +
        MOVE.W  D0,D3
        CMP.W   D0,D1
        BGE.S   D.GOON
        MOVE.W  D1,D3           ; D3 = smallest set size
D.GOON: LSR.W   #1,D3           ; D3 = # Words
        BRA.S   D.TEST
D.LOOP: MOVE.W  -(A0),D2
        NOT.W   D2
        AND.W   D2,-(A1)
D.TEST: dbra    D3,D.LOOP       ; dec d3 and branch if d3 <> -1
        SUB.W   D1,D0           ; Compare set sizes
        BGT.S   D.DONE          ; Finished if A <= B in size
        ADDA.W  D0,A1           ; First set is bigger
D.DONE: MOVE.W  D1,-(A1)        ; Store set size
        MOVE.L  28(SP),A0       ; Set up return address
        MOVE.L  A0,-(A1)
        MOVE.L  A1,24(SP)       ; Set up new SP value
        MOVEM.L (SP)+,D0-D3/A0-A1
        MOVE.L  (SP)+,SP        ; Pop new SP value
        RTS

;
; %_RDIFF - Reverse set difference
;
; Parameters: ST.S - First set
;             ST.S - Second set
;
; Returns:    ST.S - Result set
;
; This procedure saves all registers
;

%_RDIFF:
        CLR.L   -(SP)
        MOVEM.L D0-D3/A0-A1,-(SP)
        LEA     32(SP),A0       ; Address of second set
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.W  (A0)+,D0        ; Size of second set
        ADDA.W  D0,A0           ; Address of top of set 2 +
        MOVE.L  A0,A1           ; Address of first set
        MOVE.W  (A1)+,D1        ; Size of first set
        ADDA.W  D1,A1           ; Address of top of set 1 +
        MOVE.W  D0,D3
        CMP.W   D0,D1
        BGE.S   V.GOON
        MOVE.W  D1,D3           ; D3 = smallest set size
V.GOON: LSR.W   #1,D3           ; D3 = # Words
        BRA.S   V.TEST
V.LOOP: NOT.W   -(A1)
        MOVE.W  -(A0),D2
        AND.W   D2,(A1)
V.TEST: dbra    D3,V.LOOP       ; dec d3 and branch if d3 <> -1
        SUB.W   D1,D0           ; Compare set sizes
        BLE.S   V.DONE          ; Finished if A <= B in size
        ADD.W   D0,D1           ; D1 = Biggest Size
        LSR.W   #1,D0           ; D0 = # Words bigger
VB.LOOP:MOVE.W  -(A0),-(A1)
        SUBQ.W  #1,D0
        BGT.S   VB.LOOP
V.DONE: MOVE.W  D1,-(A1)        ; Store set size
        MOVE.L  28(SP),A0       ; Set up return address
        MOVE.L  A0,-(A1)
        MOVE.L  A1,24(SP)       ; Set up new SP value
        MOVEM.L (SP)+,D0-D3/A0-A1
        MOVE.L  (SP)+,SP        ; Pop new SP value
        RTS

;
; %_RANGE - Set range
;
; Parameters: ST.W - Minimum value
;             ST.W - Maximum value
;
; Result:     ST.S - Resulting set
;
; This procedure saves all registers.
;

%_RANGE:
        MOVEM.L D0-D4/A0-A2,-(SP)
        MOVE.W  36(SP),D1       ; D1 = max value
        MOVE.W  38(SP),D0       ; D0 = min value
        CLR.L   36(SP)          ; Zero the parameters
        LEA     40(SP),A0       ; A0 = address of set + 1
        TST.W   D0              ; if Min < 0 then Min := 0
        BPL.S   MINPOS
        CLR.W   D0
MINPOS: CMP.W   D0,D1           ; Compare Min to Max
        BLT.S   NULLSET
        MOVE.W  D1,D2
        LSR.W   #4,D2           ; D2 = Size in words - 1 of final set
        MOVE.W  D2,D3
        LSL.W   #1,D3           ; D3 = Size in bytes - 2 of final set
        BEQ.S   NOEXPAN
        MOVE.L  SP,A1           ; Current top of stack
        SUB.W   D3,SP
        MOVE.L  SP,A2           ; New top of stack
        MOVE.W  #18,D4          ; # Words to copy in D4
R.LOOP1:MOVE.W  (A1)+,(A2)+     ; Copy each remaining word
        SUB.W   #1,D4
        BNE.S   R.LOOP1
R.LOOP3:CLR.W   (A2)+           ; Default each word of result to zero
        SUB.W   #1,D2
        BNE.S   R.LOOP3
NOEXPAN:ADD.W   #2,D3           ; D3 = Size in bytes
        MOVE.W  D3,36(SP)       ; Copy #bytes in last word of set
R.LOOP2:MOVE.W  D0,D2
        MOVE.W  D2,D3
        LSR.W   #4,D2
        LSL.W   #1,D2
        NEG.W   D2
        ANDI.W  #$F,D3
        CLR.W   D4
        BSET    D3,D4           ; Build the set one bit at a time
        OR.W    D4,-2(A0,D2)
        ADDQ.W  #1,D0
        CMP.W   D0,D1
        BGE.S   R.LOOP2
        MOVEM.L (SP)+,D0-D4/A0-A2
        RTS
NULLSET:MOVE.L  32(SP),A0       ; Move return address up one word
        MOVE.L  A0,34(SP)
        MOVEM.L (SP)+,D0-D4/A0-A2
        TST.W   (SP)+           ; Delete extra word
        RTS

;
; %_ADJ - Set adjust
;
; Parameters: ST.S - Set
;             ST.W - Desired size in bytes
;
; Returns:    ST.S' - Adjusted set without size word
;
; This routine preserves all registers
;

%_ADJ:
        SUBA.W  #256,SP         ; Allow for worst-case set expansion
        MOVEM.L D0-D1/A0-A1,-(SP)
        MOVE.W  276(SP),D0      ; Desired size
        MOVE.W  278(SP),D1      ; Current size
        LEA     280(SP),A0      ; Points to end of set
        MOVE.L  272(SP),A1      ; Return address
        SUB.W   D0,D1
        BGE.S   A.OK
A.LOOP: CLR.W   -(A0)
        ADDQ.W  #2,D1
        BMI.S   A.LOOP
        BRA.S   A.DONE
A.OK:   ADDA.W  D1,A0
A.DONE: MOVE.L  A1,-(A0)        ; Set up return address
        MOVE.L  A0,16(SP)       ; Set up new SP
        MOVEM.L (SP)+,D0-D1/A0-A1
        MOVE.L  (SP)+,SP
        RTS

;
; %_SETNE - Set inequality test
;
; Parameters: ST.S - First set
;             ST.S - Second set
;
; Returns:    ST.W - Result
;
; This procedure saves all registers
;

%_SETNE:
        CLR.L   -(SP)
        MOVEM.L D0-D3/A0-A2,-(SP)
        MOVEQ   #1,D3           ; Result if <>
        BRA.S   EQ.NE

;
; %_SETEQ - Set equality test
;
; Parameters: ST.S - First set
;             ST.S - Second set
;
; Returns:    ST.B - Result
;
; This procedure saves all registers
;

%_SETEQ:
        CLR.L   -(SP)
        MOVEM.L D0-D3/A0-A2,-(SP)
        CLR.W   D3              ; Result if <>
EQ.NE:  LEA     36(SP),A0       ; Address of second set
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.W  (A0)+,D0        ; Size of second set
        ADDA.W  D0,A0           ; Address of top of set 2 +
        MOVE.L  A0,A1           ; Address of first set
        MOVE.W  (A1)+,D1        ; Size of first set
        ADDA.W  D1,A1           ; Address of top of set 1 +
        MOVE.L  A1,A2           ; Save address for result
        MOVE.W  D0,D2
        CMP.W   D0,D1
        BGE.S   EQ.GOON
        MOVE.W  D1,D2           ; D2 = smallest set size
EQ.GOON:SUBA.W  D2,A0
        SUBA.W  D2,A1
        LSR.W   #1,D2           ; D2 = # Words
        BRA.S   EQ.TEST
EQ.LOOP:CMPM.W  (A0)+,(A1)+
        BNE.S   EQ.FALS
EQ.TEST:dbra    D2,EQ.LOOP      ; dec d2 and branch if d2 <> -1
        SUB.W   D0,D1           ; Compare set sizes
        BEQ.S   EQ.TRUE         ; Finish up if same size
        BMI.S   E.TOP.S
        SUBA.W  D0,A1           ; Set A1 to address of first
                                ; word in extra stuff + 2
        LSR.W   #1,D1           ; D1 = # Words bigger
EQLOOP2:TST.W   -(A1)
        BNE.S   EQ.FALS
        SUBQ.W  #1,D1
        BGT.S   EQLOOP2
        BRA.S   EQ.TRUE
E.TOP.S:SUBA.W  D0,A0           ; Top set is smaller
        SUBA.W  D1,A0
        ASR.W   #1,D1
EQLOOP3:TST.W   -(A0)
        BNE.S   EQ.FALS
        ADDQ.W  #1,D1
        BMI.S   EQLOOP3
EQ.TRUE:EORI.W  #1,D3
EQ.FALS:CLR.B   -(A2)           ; Push result as if
        MOVE.B  D3,-(A2)        ;   MOVE.B -(SP)
        MOVE.L  32(SP),A0       ; Set up return address
        MOVE.L  A0,-(A2)
        MOVE.L  A2,28(SP)       ; Set up new SP value
        MOVEM.L (SP)+,D0-D3/A0-A2
        MOVE.L  (SP)+,SP        ; Pop new SP value
        RTS

;
; %_SETGE - Set inclusion test
;
; Parameters: ST.S - First set
;             ST.S - Second set
;
; Returns:    ST.B - Result
;
; This procedure saves all registers
;

%_SETGE:
        CLR.L   -(SP)
        MOVEM.L D0-D3/A0-A2,-(SP)
        LEA     36(SP),A1       ; Address of second set
        tst.b   (a1)            ; make resident in case it is in code seg
        MOVE.W  (A1)+,D1        ; Size of second set
        ADDA.W  D1,A1           ; Address of top of set 2 +
        MOVE.L  A1,A0           ; Address of first set
        MOVE.W  (A0)+,D0        ; Size of first set
        ADDA.W  D0,A0           ; Address of top of set 1 +
        MOVE.L  A0,A2           ; Save address for result
        BRA.S   LE.GE           ; Compute (A1) <= (A0)

;
; %_SETLE - Set inclusion test
;
; Parameters: ST.S - First set
;             ST.S - Second set
;
; Returns:    ST.B - Result
;
; This procedure saves all registers
;

%_SETLE:
        CLR.L   -(SP)
        MOVEM.L D0-D3/A0-A2,-(SP)
        LEA     36(SP),A0       ; Address of second set
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.W  (A0)+,D0        ; Size of second set
        ADDA.W  D0,A0           ; Address of top of set 2 +
        MOVE.L  A0,A1           ; Address of first set
        MOVE.W  (A1)+,D1        ; Size of first set
        ADDA.W  D1,A1           ; Address of top of set 1 +
        MOVE.L  A1,A2           ; Save address for result
LE.GE:  MOVE.W  D0,D2
        CMP.W   D0,D1
        BGE.S   LE.GOON
        MOVE.W  D1,D2           ; D2 = smallest set size
LE.GOON:LSR.W   #1,D2           ; D2 = # Words
        BRA.S   LE.TEST
LE.LOOP:MOVE.W  -(A0),D3
        NOT.W   D3
        AND.W   -(A1),D3
        BNE.S   LE.FALS
LE.TEST:dbra    D2,LE.LOOP      ; dec d2 and branch if d2 <> -1
        SUB.W   D0,D1           ; Compare set sizes
        BEQ.S   LE.TRUE         ; Finish up if same size
        BMI.S   LE.TRUE         ; True if (A1) shorter
        LSR.W   #1,D1           ; D1 = # Words bigger
LELOOP2:TST.W   -(A1)
        BNE.S   LE.FALS
        dbra    D1,LELOOP2      ; dec d1 and branch if d1 <> -1
        BRA.S   LE.TRUE
LE.TRUE:MOVEQ   #1,D3
        BRA.S   LE.DONE
LE.FALS:CLR.W   D3
LE.DONE:CLR.B   -(A2)           ; Push the result as if
        MOVE.B  D3,-(A2)        ;   MOVE.B -(SP)
        MOVE.L  32(SP),A0       ; Set up return address
        MOVE.L  A0,-(A2)
        MOVE.L  A2,28(SP)       ; Set up new SP value
        MOVEM.L (SP)+,D0-D3/A0-A2
        MOVE.L  (SP)+,SP        ; Pop new SP value
        RTS


; File: PASTERM.TEXT
; Date: 09-Oct-81

;        .PROC   %%%TERM                ; this introduces another entry point
                                        ; for reusability, comment this out
;        .DEF    %_TERM
        .PROC   %_TERM
        .def    %_HALT

        .if     libproducing=appaslib
        .ref    CkResident, terminate_process


;
; %_TERM - Terminate
;

;%_TERM:                        ; comment out since use .proc %_term
        moveq   #1,d4                   ; entry from %_TERM
term
        suba.l  #sizeenvir,sp           ; space for regis for restarting
        clr.w   -(sp)                   ; function result
        pea     2(sp)                   ; address of regis
        jsr     CkResident              ; Check whether its resident
        tst.w   (sp)+
        beq     nonresid                ; not resident, no restart
        move.l  (sp)+,a6                ; restore registers for restarting
        move.l  (sp)+,a0                ; pc of PC2Blockiosetup
        move.l  (sp)+,a1                ; return pc of %_INIT
        move.l  (sp)+,sp                ; restore sp
        move.l  a1,(sp)                 ; setup return pc for %_INIT
                ; now the top of stack has return pc of %_init
                ; leave it there so can do rts after done with %_init
        jmp     (a0)                    ; jump to do second blockiosetup in %_init


nonresid
        tst.w   d4                      ; see if from %_TERM
        beq     haltterm
        gentrap #52,#0                          ; trap to Hit_End
                                                ; no return
;        RTS

        .endc

;
; %_HALT - Halt
;

%_HALT:
        .if     libproducing=appaslib
        clr.w   d4                      ; entry to %_HALT       {3.2, YC, 2/28/83}
        bra.s   term                    ;                       {3.2, YC, 2/28/83}

haltterm
        clr.l   -(sp)                   ; make room for errnum
        move.l  sp,-(sp)                ; @errnum
        clr.l   -(sp)                   ; event_ptr := nil
        jsr     terminate_process       ; terminate_process (errnum, event_ptr)
                                        ; it will not return
        RTS
        .endc




; File: OSPASTEXT.TEXT                                   (FOR OS PASLIB ONLY)

        .PROC   %%%TEXT


        .DEF    %W_LN,%W_C,%W_I,%W_B,%W_STR,%W_PAOC,%_PAGE
        .DEF    %R_C,%R_I,%R_STR,%R_PAOC,%R_LN
        .def    %initstdio
        .def    %charput, %charget        ;use by rs232-type drivers
;
;   Macro TrapToHW is used to call the hardware interface routines.
;   Parameter %1 is the magic number associated with the routine begin called.
;
        .MACRO  TRAPTOHW                ; trap to hardware interface
        MOVE.L  D7,-(SP)                ; save register
        MOVE.W  #%1,D7                  ; routine number
        TRAP    #5                      ; trap
        MOVE.L  (SP)+,D7                ; restore register
        .ENDM

;
;   Routine numbers for the hardware interface routines.
;

CursorHide      EQU     16      ; $10
CursorDisplay   EQU     20      ; $14
ScreenAddr      equ     $18
AltScreenAddr   equ     $1a
KeybdEvent      EQU     58      ; $3a
AltKeyEvent     equ     $94
KeybdPeek       EQU     60      ; $3c
AltKeyPeek      equ     $92


;LOW CORE READLN/WRITELN DATA ALLOCATION:
;  ( *** NEEDS TO BE MOVED ELSEWHERE, PERHAPS TO SYSGLOBAL *** )
ateol           equ     $1ef    ;'eol' flag for console driver             (byte)
chan_select     equ     $1f0    ;address holding channel select code      (longint)
msbase          equ     $1f4    ;address holding main screen context      (longint)
altmsbase       equ     $1f8    ;address holding alternate screen context (longint)
osconsole       equ     $1fc    ;address holding console screen SELECTOR  (integer)


; consoledest type definition, from blockio:
alscreen        equ     0       ; console to alternate screen
mainscreen      equ     1       ; console to main screen
xsoroca         equ     2       ; console to external soroc

;
; ASCII Character EQUs
backsp  equ     8               ;backspace
lf      equ     $a              ;ascii line feed
cr      equ     $d              ;ascii carriage return
dle     equ     $10             ;ascii dle
toggle  equ     $13             ;^S toggles whether to halt writelns
blank   equ     $20             ;ascii blank char
rubout  equ     127


;
;       SCC MACROS
;
        .MACRO SCCWT            ; <register number>,<source operand>
        NOP
        MOVE.B  %1,(A0)         ; specify the register
        NOP                     ; we have to delay for latency timing limits
        MOVE.B  %2,(A0)         ; write to that register
        .ENDM

        .MACRO SCCWT0           ; <register number>,<source operand = 0>
        NOP
        MOVE.B  %1,(A0)         ; specify the register
;undone NOP                 *** ; we have to delay for latency timing limits
        MOVE.L  D0,-(SP)        ;DONT CLOBBER TEMPORARY REGISTER
        CLR.B   D0
        MOVE.B  D0,(A0)         ; write to that register
        MOVE.L  (SP)+,D0        ;RESTORE TEMPORARY REGISTER
        .ENDM

        .MACRO SCCRD            ; <register number >,<destination operand>
        NOP
        MOVE.B  %1,(a0)         ; read from that register
        NOP
        MOVE.B  (A0),%2         ; read from that register
        .ENDM

        .MACRO SCCRD0           ; <register number = 0>,<destination operand>
        NOP
        MOVE.B  (A0),%1         ; read from that register
        .ENDM

;
;       SCC EQUATES
;
SCCBASE .EQU    $FCD204         ; would have been $FCD200 but SCC wired wrong
                                ; requires subtract of 1 or 3 to get to A or B
SCCCB   .EQU    $FCD201
SCCCA   .EQU    $FCD203
SCCDATA .EQU    4
RDA     .EQU    0               ;RECEIVE STATUS BIT
TBE     .EQU    2               ;XMIT STATUS BIT
ALL_SENT .EQU   0               ;all characters ACTUALLY sent

;
; %INITSTDIO - Initialize standard read/write channel logic
;       (no-op for this go round, may need to be revived.)
;    called by blockioinit once only.
;
%initstdio:
        MOVEM.L D0-D7/A0-A6,-(SP)

     ;init potential SOROC channel.  Should be CONDITIONAL IF RS232A EXISTS.
        jsr     initio

        move.l  #osconsole,a0
        move.w  (a0),d4
        beq     @1                      ; 0 = altscreen, 1 = main screen
        move.l  #msbase,a3
        bra.s   @2
@1      MOVE.L  #ALTMSBASE,A3           ; init screen states
@2      MOVE.L  #$20010000,(A3)         ; row=20, col=1, state=0, flag=0
        BSR     SETCUR                  ; then, set the cursor on
        traptohw  CursorDisplay         ; put cursor back on screen

        MOVEM.L (SP)+,D0-D7/A0-A6
        rts



;
; INITIO - initialize channel.
;
allints equ     $700            ;way to disable all interrupts
initio:
        move.l  (SP)+,a1        ;catch return address
        move    SR,-(SP)        ;disable interrupts while programming channel
        move    SR,d0
        ori     #allints,d0
        lea     *+6,a0          ;stash return address in a0
        TRAP    #7              ;(moves d0 into SR, returns via a0)
        move.l  #chan_select,a0
        move.l  (a0),d0
        beq.s   @3
        sub.l   #1,d0
        beq.s   @1

        move.l  #scccb,a0       ; channel B for lisabug
        bsr     scc96b
        bra     @3

@1      move.l  #sccca,a0       ; channel A for lisabug
        bsr     scc96a

@3      move    (SP)+,d0        ;restore interrupts (via trap 7)
        move.l  a1,a0           ;a0 := return address of THIS routine
        TRAP    #7              ;(trap returns to location in a0)

;
;
;
SCC96A  MOVE.L  #SCCCA,A0       ; set up channel A
        MOVE.B  (A0),D0         ; sync up
        SCCWT   #9,#$8A         ; channel A reset, no interrupt vector
        SCCWT   #4,#$44         ; no parity, x16, 1 stop bits
        SCCWT   #11,#$50        ; Rcv,Xmt clock = BR generator, TRxC in
        SCCWT0  #14             ; BR enable, source = PClk
        SCCWT   #12,#$0B        ; Baud rate LSB (4=19200,11=9600)
        SCCWT0  #13             ; Baud rate MSB
        SCCWT   #14,#$03        ; BR enable, source = PClk
        SCCWT0  #10             ; NRZ
        SCCWT   #3,#$C1         ; Rcv enable, 8 bits/char
        SCCWT   #5,#$EA         ; Xmt enable, 8 bits/char, send break
        SCCWT0  #15
        SCCWT0  #1
        RTS
;
;
;
SCC96B  MOVE.B  (A0),D0         ; sync up
        SCCWT   #9,#$4A         ; channel B reset, no interrupt vector
        SCCWT   #4,#$44         ; no parity, x16, 1 stop bits
        SCCWT   #11,#$50        ; Rcv,Xmt clock = BR generator, TRxC in
        SCCWT0  #14             ; BR enable, source = PClk
        SCCWT   #12,#$0B        ; Baud rate LSB (4=19200,11=9600)
        SCCWT0  #13             ; Baud rate MSB
        SCCWT   #14,#$03        ; BR enable, source = PClk
        SCCWT0  #10             ; NRZ
        SCCWT   #3,#$C1         ; Rcv enable, 8 bits/char
        SCCWT   #5,#$E8         ; Xmt enable, 8 bits/char, send break
        SCCWT0  #15
        SCCWT0  #1
        RTS


; STDGET and it's alias, %CHARGET
;          EACH Reads one char from the standard input channel
;
; Parameters: d0 returns the char (right justified)
;          (DESTROYS MOST REGISTERS, ie, a0, a1, d0, d4)
%charget:       ;an external interface available to rs232 drivers
stdget:
        move.l  #osconsole,a0
        move.w  (a0),d4         ; check console destination
        cmp.w   #xsoroca,d4     ; soroc ?
        bne     screenget

        move.l  #sccbase,a0     ;load base address
        move.l  #chan_select,a1
        sub.l   (a1),a0         ;add port offset
        move.b  (a0),d0         ;  (synch ???)
getloop sccrd0  d1              ;receiver ready?
        btst    #rda,d1         ;wait for rda
        beq.s   getloop
        move.b  sccdata(a0),d0  ;get it
gotchar
        bclr    #7,d0           ;trim leading bit
        move.l  #ateol,a0
        clr.b   (a0)            ;most characters dont signal 'at end of line'
        cmpi.b  #cr,d0          ;if char = cr then echo crlf:
        bne.s   notcr
        addq.b  #1,(a0)         ;signal at end of line to ateol flag
        bsr     sorocput        ;  (first echo cr)
        move.b  #lf,d0
        bsr     sorocput        ;  (then echo lf)
        move.b  #cr,d0          ;  (then restore cr char)
        bra     echodone
notcr
        cmpi.b  #blank,d0       ;if char >= ' ' then echo char
        blt.s   echodone
        bsr     sorocput
echodone
        rts

;
; SCREENGET - screen input routine, get a character into D0
;
screenget
        clr.w   d7              ; non-echo read
        move.b  d0,-(sp)        ; create buffer for input
        move.l  sp,a2           ; buffer address
        moveq   #1,d2           ; byte count to read
        bsr     read            ; get a character from Lisa keyboard into buffer
        move.b  (sp),d0
sgotchar
        tst.w   d4
        beq     @5
        move.l  #msbase,a3      ; set up screen states base
        bra.s   @6
@5      move.l  #altmsbase,a3
@6      move.l  #ateol,a0
        clr.b   (a0)            ; most characters dont signal 'at end of line'
        bsr     clrcur          ; set cursor off to echo character
        cmpi.b  #cr,d0          ; cr ?
        bne.s   @1              ; no,
        move.l  #ateol,a0
        addq.b  #1,(a0)         ; yes, signal at end of line
        bsr     putc            ; echo the cr onto screen
        move.b  #lf,d0          ; if cr, echo cr and lf
        bra.s   @2
@1      cmpi.b  #blank,d0       ;if char >= ' ' then echo char
        blt.s   @3              ; no echo if control char
@2      bsr     putc            ; echo the character onto screen
@3      bsr     setcur          ; set cursor on
        move.b  (sp)+,d0        ; restore the input
        rts

;
; SOROCPUT - Write one char to soroc
;
; Parameters: d0 holds the char to be written.
;       (DESTROYS MOST REGISTERS)
sorocput:
        move.w  d0,-(SP)        ;dont let char get clobbered
        move.l  #sccbase,a0     ;load base address
        move.l  #chan_select,a1
        sub.l   (a1),a0         ;add port offset
        move.b  (a0),d0         ;  (synch ???)
        bsr     pollchar        ;d0 := any char currently in the uart
        cmp.b   #toggle,d0      ;if lookahead char is the toggle signal,
        bne     putloop
waitfortoggle                   ;then scan input chars until SECOND toggle arrives.
        bsr     pollchar
        cmp.b   #toggle,d0
        bne     waitfortoggle
putloop sccrd0  d1              ;transmitter ready?
        btst    #tbe,d1
        beq.s   putloop
        move.w  (SP)+,d0        ;get char back
        move.b  d0,sccdata(a0)  ;output a character
putlop  sccrd   #1,d1            ;stall until all chars actually sent
        btst    #all_sent,d1
        bne.s   putlop
        rts

;
; POLLCHAR - read any char ALREADY in the SCC.
;  d0 - returns the char, if any, and 0 otherwise.
;  a0 - passes to pollchar a pointer to the logic for
; (d1 - is clobbered)
pollchar
        clr.b   d0              ;assume nothing will be received
        sccrd0  d1              ;see if there's anybody home
        btst    #rda,d1
        beq     nonehome
        move.b  sccdata(a0),d0  ;get the char
        bclr    #7,d0           ;trim leading bit
nonehome
        rts

;
; CHARPUT - output a character to console
;
%charput:       ;an external interface available to rs232 drivers
charput:
        move.l  #osconsole,a0
        move.w  (a0),d4         ; in shared var
        cmp.w   #xsoroca,d4     ; soroc ?
        bne     screenput
                                ; output to external soroc
        cmp.b   #cr,d0          ;cr is translated to cr-lf
        bne     dochar
        bsr     sorocput
        move.b  #lf,d0
dochar: bsr     sorocput
        rts

;
; SCREENPUT - screen output routine
;
screenput
        moveq   #1,d2           ; byte count to write
        move.b  d0,-(sp)        ; byte buffer
        move.l  sp,a2           ; buffer address
        bsr     write           ; output a character to screen
        move.b  (sp)+,d0        ; pop the character
        rts



; OUTCH - Display a character on the CRT
;
; Parameters:  D0.B - Character to be output
;              A0.L - Address of output file (is ignored, console used instead)
;

OUTCH:  MOVEM.L D0-D7/A0-A6,-(SP)
        bsr     charput         ; output a character to console
        MOVEM.L (SP)+,D0-D7/A0-A6
        RTS



;
; %W_LN - WRITELN
;
; Parameters:  ST.L - Address of output file, which is ignored
;
; Scratches A0,A2
;

%W_LN:
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.L  (SP)+,A0        ; Pop (and ignore) file address
        MOVEM.L D0-D7/A0-A6,-(SP)
        move.b  #cr,d0
        bsr     charput         ; output it to console
        MOVEM.L (SP)+,D0-D7/A0-A6
        JMP     (A2)




;
; %W_C - Display a character on the CRT
;
; Parameters:  ST.L - Address of output file
;              ST.B - Character to be output
;              ST.W - Size of field to print
;
; Scratches:   D2,D3,A0,A2
;

%W_C:
        MOVE.L  (SP)+,A2        ; return address
        MOVE.W  (SP)+,D2        ; size of field to print
        MOVE.B  (SP)+,D3        ; character to be output
        MOVE.L  (SP)+,A0        ; address of output file
        BRA.S   WC.TEST
WC.LOOP:MOVEQ   #' ',D0
        JSR     OUTCH
WC.TEST:SUBQ.W  #1,D2
        BGT.S   WC.LOOP
        MOVE.B  D3,D0
        JSR     OUTCH
        JMP     (A2)



;
; %W_STR - WRITE STRING
;
; Parameters:  ST.L - Address of output file
;              ST.L - Address of string
;              ST.W - Size of field to print
;
; Scratches:   D0,D2,D3,A0,A1,A2
;

%W_STR:
        MOVE.L  (SP)+,A2        ; return address
        MOVE.W  (SP)+,D3        ; size of field to print
        MOVE.L  (SP)+,A1        ; address of string
        tst.b   (a1)            ; make resident in case it is in code seg
        MOVE.L  (SP)+,A0        ; address of output file
        CLR.W   D2
        MOVE.B  (A1)+,D2        ; Get string size
        SUB.W   D2,D3           ; Check for xtra blanks
        BLE.S   S.TEST2
        MOVEQ   #' ',D0
S.LOOP: JSR     OUTCH
        SUBQ.W  #1,D3
        BNE.S   S.LOOP
        BRA.S   S.TEST2
S.LOOP2:MOVE.B  (A1)+,D0
        JSR     OUTCH
S.TEST2:dbra    D2,S.LOOP2      ; dec d2 and branch if d2 <> -1
        JMP     (A2)



;
; %W_PAOC - WRITE PACKED ARRAY OF CHARACTER
;
; Parameters:  ST.L - Address of output file
;              ST.L - Address of string
;              ST.W - Acutal length
;              ST.W - Size of field to print
;
; Scratches:   D0,D2,D3,A0,A1,A2
;

%W_PAOC:
        MOVE.L  (SP)+,A2        ; return address
        MOVE.W  (SP)+,D3        ; size of field to print
        MOVE.W  (SP)+,D2        ; actual length
        MOVE.L  (SP)+,A1        ; address of string
        tst.b   (a1)            ; make resident in case it is in code seg
        MOVE.L  (SP)+,A0        ; address of output file
        SUB.W   D2,D3           ; Check for xtra blanks
        BLE.S   P.LOOP2
        MOVEQ   #' ',D0
P.LOOP: JSR     OUTCH
        SUBQ.W  #1,D3
        BNE.S   P.LOOP
P.LOOP2:MOVE.B  (A1)+,D0
        JSR     OUTCH
        SUBQ.W  #1,D2
        BGT.S   P.LOOP2
        JMP     (A2)



;
; %W_I - WRITE INTEGER
;
; Parameters:  ST.L - Address of output file
;              ST.L - Value to print
;              ST.W - Size of field
;
; Scratches:   D0,D1,D2,D3,A0,A2
;

%W_I:
        MOVE.L  (SP)+,A2        ; return address
        MOVE.W  (SP)+,D1        ; size of field
        MOVE.L  (SP)+,D0        ; value to print
        MOVE.L  (SP)+,A0        ; address of output file
        MOVEM.L D4-D6,-(A7)
        CLR.W   D2              ; # of chars on stack
        MOVE.L  D0,D6
        BGE.S   I.POS
        NEG.L   D0
I.POS:  MOVE.L  D0,D3
I.LOOP: MOVE.L  D3,D4
        CLR.W   D4
        SWAP    D4              ; D4 = 0000 MSHV
        DIVU    #10,D4          ; D4 = MSHR MSHQ
        MOVE.L  D4,D5           ; D5 = MSHR MSHQ
        MOVE.W  D3,D5           ; D5 = MSHR LSHV
        DIVU    #10,D5          ; D5 = REMN LSHQ
        SWAP    D4              ; D4 = MSHQ MSHR
        MOVE.L  D4,D3           ; D3 = MSHQ MSHR
        MOVE.W  D5,D3           ; D3 = MSHQ LSHQ
        SWAP    D5
        ADDI.W  #'0',D5
        MOVE.W  D5,-(SP)
        ADDQ.W  #1,D2
        TST.L   D3
        BNE.S   I.LOOP
        TST.L   D6
        BGE.S   I.POS2
        ADDQ.W  #1,D2
        MOVE.W  #'-',-(SP)
I.POS2: MOVE.W  D1,D3
        SUB.W   D2,D3
        BLE.S   I.LOOP3
I.LOOP2:MOVEQ   #' ',D0
        JSR     OUTCH
        SUBQ.W  #1,D3
        BGT.S   I.LOOP2
I.LOOP3:MOVE.W  (SP)+,D0
        JSR     OUTCH
        SUBQ.W  #1,D2
        BGT.S   I.LOOP3
        MOVEM.L (A7)+,D4-D6
        JMP     (A2)



;
; %W_B - WRITE BOOLEAN
;
; Parameters:  ST.L - Address of output file
;              ST.B - Value to print
;              ST.W - Size of field
;
; Scratches D2,D3,A2

%W_B:
        MOVE.L  (SP)+,A2        ; return address
        MOVE.W  (SP)+,D2        ; Size of field
        MOVE.B  (SP)+,D3        ; Value to print
        BEQ.S   B.FALSE
        PEA     C.TRUE          ; Print 'TRUE'
        BRA.S   B.GOON
B.FALSE:PEA     C.FALSE         ; Print 'FALSE'
B.GOON: MOVE.W  D2,-(SP)
        MOVE.L  A2,-(SP)
        JMP     %W_STR

C.FALSE:.BYTE   5,70,65,76,83,69        ; 5,'FALSE'
C.TRUE: .BYTE   4,84,82,85,69,0         ; 4,'TRUE '



;
; %_PAGE - PAGE
;
; Parameters:  ST.L - Address of output file
;
; Scratches D0,A0,A1

%_PAGE:
        MOVE.L  (SP)+,A1        ; Pop return address
        MOVE.L  (SP)+,A0        ; Pop file address
        MOVEQ   #12,D0          ; ASCII FF
        MOVE.L  A1,-(SP)
        JSR     OUTCH
        RTS



;
; INCH - Reads a character from the console
;
; Parameters:  A0 - Address of (ignored) input file
;
; Returns:     D0 - the character
;
INCH:   MOVEM.L D1-D7/A0-A6,-(SP)
        bsr     stdget
        MOVEM.L (SP)+,D1-D7/A0-A6
        RTS



;
; %R_C - Read a character
;
; Parameters: ST.L - File Address
;
; Returns:    ST.B - The character read
;
; Scratches D0,A0,A2
;

%R_C:
        MOVEM.L D0/A0,-(SP)
        MOVE.L  12(SP),A0       ; A0 = file address
        JSR     INCH
        MOVE.B  D0,14(SP)
        MOVE.L  8(SP),A0
        MOVE.L  A0,10(SP)
        MOVEM.L (SP)+,D0/A0
        ADDQ.L  #2,SP
        RTS



;
; %R_LN - READLN
;
; Parameters:  ST.L - Address of input file (which is ignored)
;
; Scratches A0,A2
;

%R_LN:
        MOVE.L  (SP)+,A2        ; return address
        MOVE.L  (SP)+,A0        ; address of (ignored) input file
        MOVEM.L D0-D7/A0-A6,-(SP)
        move.l  #ateol,a1
        move.b  (a1),d0         ;exit if already at end of line
        bne     alrateol
getcr   bsr     stdget
        cmp.b   #cr,d0
        bne     getcr
alrateol                        ;already at eol
        move.l  #ateol,a1
        clr.b   (a1)            ;consume cr
        MOVEM.L (SP)+,D0-D7/A0-A6
        JMP     (A2)



;
; %R_PAOC - Read Packed Array of Character
;
; Parameters: ST.L - File Address
;             ST.L - Array Address
;             ST.W - Size of array in bytes
;
; Scratches D0,D1,D2,D3,A0,A1,A2
;

%R_PAOC:
        MOVE.L  (SP)+,A2        ; return address
        MOVE.W  (SP)+,D2        ; Size of array
        MOVE.W  D2,D3           ; Save size for RUBOUT and BACK-SPACE
        MOVE.L  (SP)+,A1        ; Address of PAOC
        MOVE.L  (SP)+,A0        ; Address of File
        MOVEM.L A3/D4,-(A7)
        move.l  a0,d1           ;distinguish monitor or standalone
        bne     mon1
        move.l  #ateol,a3
        move.b  (a3),d1         ;standalone check for end of line
        bra     test1
mon1    TST.B   4(a0)           ;monitor check for end of line
test1
        BNE.S   RP.EOLN         ; PAOCs never eat an EOLN
RP.LOOP:JSR     INCH
        move.l  a0,d1           ;distinguish monitor or standalone
        bne     mon2
        move.l  #ateol,a3
        move.b  (a3),d1         ;standalone check for end of line
        bra     test2
mon2    TST.B   4(a0)           ;monitor check for end of line
test2
        BNE.S   RP.EOLN
        CMP.B   #RUBOUT,D0      ; Was it a RUBOUT?
        BEQ.S   RP.RUB
        CMP.B   #BACKSP,D0      ; Was it a BACK-SPACE?
        BEQ.S   RP.BAC
        MOVE.B  D0,(A1)+
        SUBQ.W  #1,D2
        BGT.S   RP.LOOP
        MOVEM.L (A7)+,A3/D4
        JMP     (A2)
RP.RUB: MOVE.W  D3,D4
        SUB.W   D2,D4           ; How many to erase?
        BEQ.S   RP.LOOP         ; Exit if none
        SUBA.W  D4,A1           ; Reset pointer
        MOVE.W  D3,D2           ; Reset counter
        JSR     ERASED4
        BRA.S   RP.LOOP
RP.BAC: CMP.W   D2,D3           ; See if anything to erase
        BEQ.S   RP.LOOP
        ADDQ.W  #1,D2           ; Yes. Bump counter
        SUBQ.W  #1,A1           ; Bump character pointer
        MOVEQ   #1,D4
        JSR     ERASED4
        BRA.S   RP.LOOP
RP.LOP2:MOVE.B  #' ',(A1)+
RP.EOLN:SUBQ.W  #1,D2
        BGE.S   RP.LOP2
        MOVEM.L (A7)+,A3/D4
        JMP     (A2)



;
; ERASED4 - Type BS,SP,BS (D4) times
;

ED4LOOP:MOVEQ   #BACKSP,D0
        JSR     OUTCH
        MOVEQ   #' ',D0
        JSR     OUTCH
        MOVEQ   #BACKSP,D0
        JSR     OUTCH
ERASED4:dbra    D4,ED4LOOP      ; dec d4 and branch if d4 <> -1
        RTS



;
; %R_STR - Read String
;
; Parameters: ST.L - File Address
;             ST.L - String Address
;             ST.W - Max size of string
;
; Scratches D0,D1,D2,A0,A1,A2
;

%R_STR:
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.W  (SP)+,D2        ; Size of array
        MOVE.L  (SP)+,A1        ; Address of String
        MOVE.L  (SP)+,A0        ; Address of File
        MOVE.L  A2,-(SP)        ; Push return address
        MOVEM.L D4/A3,-(A7)
        MOVE.L  A1,A2           ; Save pointer to length byte
        CLR.B   (A1)+
        move.l  a0,d1           ;distinguish monitor or standalone
        bne     mon3
        move.l  #ateol,a3
        move.b  (a3),d1        ;standalone check for end of line
        bra     test3
mon3    TST.B   4(a0)           ;monitor check for end of line
test3
        BNE.S   RS.EOLN         ; Strings never eat an EOLN
RS.LOOP:JSR     INCH
        move.l  a0,d1           ;distinguish monitor or standalone
        bne     mon4
        move.l  #ateol,a3
        move.b  (a3),d1        ;standalone check for end of line
        bra     test4
mon4    TST.B   4(a0)           ;monitor check for end of line
test4
        BNE.S   RS.EOLN
        CMP.B   #RUBOUT,D0      ; Was it a RUBOUT?
        BEQ.S   RS.RUB
        CMP.B   #BACKSP,D0      ; Was it a BACK-SPACE?
        BEQ.S   RS.BAC
        MOVE.B  D0,(A1)+
        ADDQ.B  #1,(A2)
        SUBQ.W  #1,D2
        BGT.S   RS.LOOP
RS.EOLN:MOVEM.L  (A7)+,D4/A3
        RTS
RS.RUB: CLR.W   D4
        MOVE.B  (A2),D4
        BEQ.S   RS.LOOP         ; Anything to erase?
        CLR.B   (A2)
        ADD.W   D4,D2
        SUBA.W  D4,A1
        JSR     ERASED4
        BRA.S   RS.LOOP
RS.BAC: TST.B   (A2)            ; Anything to erase?
        BEQ.S   RS.LOOP
        SUBQ.B  #1,(A2)
        ADDQ.W  #1,D2
        SUBQ.L  #1,A1
        MOVEQ   #1,D4
        JSR     ERASED4
        BRA.S   RS.LOOP



;
; %R_I - Read Integer
;
; Parameters: ST.L - File Address
;
; Returns:    ST.L - The integer read
;

%R_I:
        MOVEM.L D0-D7/A0-A6,-(SP)
        MOVE.L  64(SP),A0       ; File Address
        CLR.L   D2              ; Value
        CLR.W   D6              ; D6 = #chars
        CLR.B   D7              ; Sign
RI.LOPB:JSR     INCH
        CMPI.B  #' ',D0
        BEQ.S   RI.LOPB
        CMPI.B  #'+',D0
        BEQ.S   RI.PLUS
        CMPI.B  #'-',D0
        BNE.S   RI.NUM
        SUBQ.B  #1,D7
RI.PLUS:ADDQ.W  #1,D6
RI.LOOP:JSR     INCH
RI.NUM: CMP.B   #RUBOUT,D0      ; Was it a RUBOUT?
        BEQ.S   RI.RUB
        CMP.B   #BACKSP,D0      ; Was it a BACK-SPACE?
        BEQ.S   RI.BAC
        ADDQ.W  #1,D6
        SUBI.B  #'0',D0
        BLT.S   RI.TEST
        CMPI.B  #9,D0
        BGT.S   RI.TEST
        EXT.W   D0
        EXT.L   D0
        MOVE.L  D2,D3
        MULU    #10,D2
        SWAP    D3
        MULU    #10,D3
        ASL.L   #8,D3
        ASL.L   #8,D3
        ADD.L   D3,D2
        ADD.L   D0,D2
        BRA.S   RI.LOOP
RI.TEST:TST.B   D7
        BEQ.S   RI.DONE
        NEG.L   D2
RI.DONE:MOVE.L  D2,64(SP)
        MOVEM.L (SP)+,D0-D7/A0-A6
        RTS
RI.RUB: TST.W   D6
        BEQ.S   RI.LOPB
        MOVE.L  D6,D4
        JSR     ERASED4
RI.RUB2:CLR.W   D6
        CLR.W   D7
        CLR.L   D2
        BRA.S   RI.LOPB
RI.BAC: TST.W   D6
        BEQ.S   RI.LOPB
        MOVEQ   #1,D4
        JSR     ERASED4
        SUBQ.W  #1,D6
        BEQ.S   RI.RUB2
        MOVE.L  D2,D3
        SWAP    D2              ; D3 = MSHS LSHV   D2 = LSHV MSHV
        EXT.L   D2              ; D3 = MSHV LSHV   D2 = 0000 MSHV
        DIVU    #10,D2          ; D3 = MSHV LSHV   D2 = MSHR MSHQ
        SWAP    D3              ; D3 = LSHV MSHV   D2 = MSHR MSHQ
        SWAP    D2              ; D3 = LSHV MSHV   D2 = MSHQ MSHR
        MOVE.W  D2,D3           ; D3 = LSHV MSHR   D2 = MSHQ MSHR
        SWAP    D3              ; D3 = MSHR LSHV   D2 = MSHQ MSHR
        DIVU    #10,D3          ; D3 = LSHR LSHQ   D2 = MSHQ MSHR
        MOVE.W  D3,D2           ; D3 = LSHR LSHQ   D2 = MSHQ LSHQ
        BRA.S   RI.LOOP


;
;       Soroc emulator on Lisa screen - from FILENAME: MS
;

CRTROW          EQU     0               ;BYTE, ROW FOR SIMULATED CRT
CRTCOL          EQU     CRTROW+1        ;BYTE, COLUMN FOR SIMULATED CRT
CRTSTATE        EQU     CRTCOL+1        ;BYTE, STATE OF CRT SIMULATOR
CTLSFLAG        EQU     CRTSTATE+1      ;BYTE, COUNT OF THROWN AWAY CMND-PERIODS

;
;       row equates
;
R0      .EQU    0                       ; row 0 offset
R1      .EQU    R0+90                   ;  etc.
R2      .EQU    R1+90
R3      .EQU    R2+90
R4      .EQU    R3+90
R5      .EQU    R4+90
R6      .EQU    R5+90
R7      .EQU    R6+90
RBYTES  .EQU    900                     ; bytes for each row
RLONGS  .EQU    225                     ; long-words for each row


;         .PROC   MONSOROC,0
;        MOVE.L  #MSBASE,A0              ; initialization
;        MOVE.L  #$01010000,(A0)         ; row=1, col=1, state=0, flag=0
;        MOVE.L  #ALTMSBASE,A0           ; initialization
;        MOVE.L  #$01010000,(A0)         ; row=1, col=1, state=0, flag=0
;        RTS

;
;       We use the registers as follows:
;       A0, A1  working regs (A1 points to screen, usually)
;       A2      buffer ptr (input)
;       A3      ptr to MSBASE or ALTMSBASE,
;       D0      data byte of interest
;       D2      byte count (input)
;       D4.W    which screen, 0 = alt. screen, 1 = main screen
;       D1, D3, D5, D6  our own pleasure
;       D7.W    echo flag for read routine (input)
;

exit
        rts                             ; return to screenput and screenget



;----------------------------------------------------------
;
;  READ    The entry to simulate keyboard input.  We pull data from
;  the key event queue maintained in hardware interface driver.
;
READ                                    ; come in with regs setup
        TST.W   D4                      ; which screen
        BEQ     @10                     ; alt. screen
        MOVE.L  #MSBASE,A3              ; set up screen states base
        BRA.S   @11
@10     MOVE.L  #ALTMSBASE,A3
@11     BSR     GETCHAR                 ;GET CHARACTER INTO D0
        MOVE.B  D0,(A2)+                ;   and copy to buffer
        TST.W   D7                      ; are we to echo this?
        BEQ.S   @1                      ;  skip if not
        BSR     CLRCUR                  ; otherwise, put it out
        BSR     PUTC
@2      BSR     SETCUR
@1      SUBQ    #1,D2
        BGT.S   READ                    ;  and keep going
        BRA.S   EXIT


;-------------------------------------------------------------
;
;       WRITE   The entry for performing an output function.  We get
; here from main DRIVER entry with A2 set with buffer address, D2 with
; byte count.  We freely use most of the other regs.
;       To simulate the SOROC, a state machine is used (CRTSTATE always
; containing the current state value).  State 0 is the normal state, while
; the others have to do with ESC and cursor addressing functions.  The
; current cursor location is in CRTROW & CRTCOL;  we always leave it
; appropriately updated.
;
WRITE                                   ; ah, ha...
        TST.W   D4                      ; which screen
        BEQ     @10                     ; alt. screen
        MOVE.L  #MSBASE,A3              ; set up screen states base
        BRA.S   @11
@10     MOVE.L  #ALTMSBASE,A3
@11     TST     D2                      ; any at all?
        BLE.S   EXIT                    ;  no, just leave
        traptohw CursorHide             ; remove cursor from screen
        BSR     CLRCUR                  ; remove cursor once per call
WRITE1  MOVE.B  (A2)+,D0                ;  and loop thru buffer
        CMP.B   #$0D,D0                 ; is this a CR ?
        BEQ.S   CRLF                    ;  yes, simulate extra stuff
        CMP.B   #$10,D0                 ; how about a DLE?
        BEQ.S   WRDLE                   ;  yes, it's special too
        BSR     PUTC
WRNEXT  SUBQ    #1,D2
        BGT.S   WRITE1
WREXIT  BSR     SETCUR                  ; then, set it on again
        traptohw CursorDisplay          ; put cursor back on screen
        BRA.S   EXIT
CRLF    BSR     PUTC                    ; put out the explicit CR
        MOVE.B  #$0A,D0                 ; then, the implicit LF
        BSR     PUTC
CRLF2   MOVE    SR,D1                   ; repeat
        AND.W   #$700,D1
        CMP.W   #$700,D1                ;   if interuppts are enabled then exit
        BEQ.S   WRNEXT
        BSR     CTRLS                   ; check for CTLS
        TST.B   CTLSFLAG(A3)            ; until not ctlsflag
        BNE.S   CRLF2
        BRA.S   WRNEXT
WRDLE   MOVE.B  #4,CRTSTATE(A3)
        BRA.S   WRNEXT

;
;       Cursor routines.

CLRCUR                                  ; code is the same folks
SETCUR
        BSR.S   SETA1                   ; set A1 with proper byte address
        NOT.B   (A1)                    ;  then complement it
        NOT.B   R1(A1)
        NOT.B   R2(A1)
        NOT.B   R3(A1)
        NOT.B   R4(A1)
        NOT.B   R5(A1)
        NOT.B   R6(A1)
        NOT.B   R7(A1)
        RTS                             ; and thats all there is...


;       SETA1           Sets A1 to proper address based upon
; current values of CRTROW and CRTCOL.

SETA1
        move.l  a0,-(SP)                ;dont clobber a0
        CLR     D3                      ; note: we assume D3 is free
        MOVE.B  CRTROW(A3),D3
        MULU    #RBYTES,D3              ; D3 = byte offset of "CRT"
        ADD     #RBYTES,D3              ;  plus an extra one
        TST.W   D4                      ; see which screen
        BEQ     @6                      ; alt screen
        traptohw ScreenAddr             ; get screen address
        BRA.S   @7
@6      traptohw AltScreenAddr          ; get alt screen address
@7      ADD.L   A0,D3                   ; addin real screen address
        MOVE.L  D3,A1                   ;  and set it up
        CLR     D3
        MOVE.B  CRTCOL(A3),D3
        ADDA    D3,A1                   ; and add in column offset
        move.l  (SP)+,a0                ;restore a0
        RTS


;       SCROLL  - move contents of screen up one whole line
; We assume that we are at bottom line when called. CRTCOL will be
; left alone, but CRTROW will be set at 32

SCROLL                                  ; entry from anywhere
        MOVE    CRTROW(A3),-(SP)        ; save current COLumn
        MOVE    #$0100,CRTROW(A3)       ;  and set to beginning of first row
        BSR.S   SETA1                   ;  and get address of screen
        MOVE.L  A1,A0                   ; set from ptr also
        ADDA    #RBYTES,A0
        MOVE    #32*RLONGS,D1           ; set loop for long copies
@1      MOVE.L  (A0)+,(A1)+
        SUBQ    #1,D1
        BGT.S   @1
        MOVE    (SP)+,CRTROW(A3)        ; restore old info
        MOVE.B  #32,CRTROW(A3)          ;  but peg at bottom
        RTS


;       PUTLF   advance CRTROW; this may cause a scroll if at bottom
PUTLF   ADDQ.B  #1,CRTROW(A3)
        CMPI.B  #32,CRTROW(A3)
        BLS.S   @9                      ; skip if its ok
        BSR     SCROLL                  ;  else, do a scroll operation
@9      RTS

;       PUTVT   move cursor up one row;  peg at top
PUTVT   SUBQ.B  #1,CRTROW(A3)
        BGT.S   @9
        MOVE.B  #1,CRTROW(A3)
@9      RTS

;       PUTBS   move cursor left one position;
PUTBS   SUBQ.B  #1,CRTCOL(A3)
        BGT.S   @9
        MOVE.B  #1,CRTCOL(A3)
@9      RTS

;       PUTFF   move cursor right one position;
PUTFF   ADDQ.B  #1,CRTCOL(A3)
        CMPI.B  #88,CRTCOL(A3)
        BLS.S   @9
        MOVE.B  #88,CRTCOL(A3)           ; pin at right
@9      RTS

;
;       PUTSPCL         Handle special characters here; such things
; as cursor controls and ESC non-sense.

PUTSPCL                                 ; character is now in D0 (-32)
        ADD.B   #$20,D0                 ; just for niceness.

        CMP.B   #$1B,D0                 ; ESC ?
        BNE.S   @1                      ;  no, skip
        MOVE.B  #1,CRTSTATE(A3)         ; else, set state for next time
        RTS                             ;  and exit

@1      CMP.B   #$1E,D0                 ; RS
        BNE.S   @2
        MOVE    #$0101,CRTROW(A3)       ; set to home (1,1)
        RTS

@2      CMP.B   #$08,D0                 ; BS (left arrow)
        BEQ.S   PUTBS

        CMP.B   #$0C,D0                 ; FF (right arrow)
        BEQ.S   PUTFF

        CMP.B   #$0B,D0                 ; VT (up arrow)
        BEQ.S   PUTVT

        CMP.B   #$0A,D0                 ; LF (down arrow)
        BEQ     PUTLF

        CMP.B   #$0D,D0                 ; CR
        BNE.S   @9
        MOVE.B  #1,CRTCOL(A3)

@9      RTS                             ; none of the above

;       special ESC characters here

ESCT                                    ; erase to end of line
        MOVE    #89,D1                  ; compute number at end
        SUB.B   CRTCOL(A3),D1
        BLE.S   @9
        BSR     SETA1                   ; set screen pointer
@1      CLR.B   R1(A1)                  ; kludgy clear
        CLR.B   R2(A1)
        CLR.B   R3(A1)
        CLR.B   R4(A1)
        CLR.B   R5(A1)
        CLR.B   R6(A1)
        CLR.B   R7(A1)
        CLR.B   (A1)+
        SUBQ    #1,D1
        BGT.S   @1
@9      RTS

ESCSTAR                                 ; clear the whole screen here folks
        move.l  a0,-(sp)
        MOVE    #$1FA3,D1               ; clear 8192-64 longs
        TST.W   D4                      ; see which screen
        BEQ     @6                      ; alt screen
        TrapToHW     ScreenAddr              ; get screen address
        BRA.S   @7
@6      TrapToHW     AltScreenAddr           ; get alt screen address
@7      MOVE.L  a0,A1
@1      CLR.L   (A1)+
        DBF     D1,@1
        MOVE    #$0101,CRTROW(A3)       ; set starting cursor location
        move.l  (sp)+,a0
        RTS

ESCY                                    ; clear from cursor loc to end of screen
        CMPI    #$0101,CRTROW(A3)       ; is this at top of screen?
        BEQ.S   ESCSTAR                 ;  yes, do full screen then
        MOVE    CRTROW(A3),-(SP)        ; save current location
        CMPI.B  #1,CRTCOL(A3)           ;  is it at left?
        BEQ.S   @1                      ;  yes, save some time
        BSR.S   ESCT                    ; no, clear end of this line
        ADDQ.B  #1,CRTROW(A3)

@1      CLR.B   CRTCOL(A3)              ;  and pretend at start of next line
        MOVE    #33,D1                  ; compute rows to clear
        SUB.B   CRTROW(A3),D1
        BLE.S   @9                      ; skip out if none
        MULU    #RLONGS,D1              ; else, compute loop values
        BSR     SETA1                   ;  setup A1 with address
@2      CLR.L   (A1)+                   ; and do it to it
        SUBQ    #1,D1
        BGT.S   @2

@9      MOVE    (SP)+,CRTROW(A3)        ; restore correct cursor location
        RTS



;--------------------------------------------------------
;
;       PUTC    The real worker of this whole mess.  On entry, D0 has
; the byte to be output.  We are responsible for putting it out (if
; a valid byte), updating CRT pointers, etc.  We also use CTLSKNT
; as a ctrl-S emulation function. So, we don't hang up the debugger
; we ignore the CTLSKNT if interrupts are shut off
;
PUTC
        TST.W   D4                      ; which screen
        BEQ     @10                     ; alt. screen
        MOVE.L  #MSBASE,A3              ; set up screen states base
        BRA.S   @11
@10     MOVE.L  #ALTMSBASE,A3
@11                                     ; D0 is data
        AND.W   #$7F,D0                 ; make sure of upper stuff
        BEQ.S   @2                      ; NUL doesn't do anything
        CLR.W   D1                      ; handle state simulation
        MOVE.B  CRTSTATE(A3),D1
        LSL     #2,D1                   ; QUAD FOR JUMP INDEX
        JMP     PUTCTBL(D1)
@2      RTS                             ; NULs are totally ignored

PUTCTBL JMP     PUTC0
        JMP     PUTC1
        JMP     PUTC2
        JMP     PUTC3
        JMP     PUTC4


PUTC0                                   ; state 0, normal stuff
        SUB.B   #$20,D0                 ;  check it for graphic symbol
        BLT     PUTSPCL                 ; and skip out if it isn't
        LSL     #3,D0                   ;  else, set up as offset into FONTTBL
        LEA     FONTTBL,A0              ; point to start of font
        ADD     D0,A0                   ; A0 = address of first (upper) byte
        BSR.S   SETA1                   ; get screen ptr to A1
        MOVE.B  (A0)+,(A1)              ;  and copy them bits
        MOVE.B  (A0)+,R1(A1)
        MOVE.B  (A0)+,R2(A1)
        MOVE.B  (A0)+,R3(A1)
        MOVE.B  (A0)+,R4(A1)
        MOVE.B  (A0)+,R5(A1)
        MOVE.B  (A0)+,R6(A1)
        MOVE.B  (A0),R7(A1)
        BRA     PUTFF                   ; share code to advance cursor

PUTC1                                   ; ESC was just seen
        CMP.B   #$3D,D0                 ;  ESC-=  (cursor addressing)
        BNE.S   @1
        MOVE.B  #2,CRTSTATE(A3)         ;  and wait for Y value
        RTS

@1      CLR.B   CRTSTATE(A3)            ; reset state for the rest
        CMP.B   #$54,D0                 ; ESC-T, erase to end of line
        BEQ.S   ESCT
        CMP.B   #$59,D0                 ; ESC-Y, erase to end of screen
        BEQ.S   ESCY
        CMP.B   #$2A,D0                 ; ESC-*, erase screen
        BEQ.S   ESCSTAR
        RTS                             ; none of the above


PUTC2                                   ; ESC-= seen, expect row value
        SUB.B   #$1F,D0
        MOVE.B  D0,CRTROW(A3)
        MOVE.B  #3,CRTSTATE(A3)
        RTS

PUTC3                                   ; ESC-=, Y, expect column value
        SUB.B   #$1F,D0
        MOVE.B  D0,CRTCOL(A3)
        CLR.B   CRTSTATE(A3)
        CMP.B   #32,CRTROW(A3)          ; make limit checks now
        BLS.S   @1
        MOVE.B  #32,CRTROW(A3)
@1      CMP.B   #88,CRTCOL(A3)
        BLS.S   @2
        MOVE.B  #88,CRTCOL(A3)
@2      RTS


PUTC4   CLR.B   CRTSTATE(A3)            ; handles dle expansion
        ANDI    #$7F,D0
        SUB     #$20,D0
        BLE.S   @2
        MOVE    D0,-(SP)
@1      MOVE.B  #$20,D0
        BSR     PUTC
        SUBQ    #1,(SP)
        BGT.S   @1
        ADDQ    #2,SP
@2      RTS
;
;       PROCEDURE CTRLS
;           Check for CTLS key in the event queue and flush all keys up to
;           CTLS key, also set the CTLSFLAG. Exit when no CTLS key in the queue.
;
CTRLS   MOVEM.L D0-D6,-(A7)
        MOVE.W  #1,-(A7)                ; index:=1
@1      MOVE.L  #1,D0                   ; while TRUE do
        MOVE.W  (A7),D1                 ; begin           { D1 is index }

        TST.W   20(SP)                  ; *** WARNING,DEPENDS ON STACK DEPTH! ***
                                        ;                 { see which screen }
        BEQ     @8                      ;                 { alt screen }
        traptohw KeybdPeek
        BRA.S   @9
@8      traptohw AltKeyPeek              ;   peek(repeat,index) next event
@9      TST.B   D0                      ;   if no event then exit
        BEQ.S   CTRLSX
        BTST    #3,D3                   ;   if command key is down then
        BEQ.S   @4
        CMP.B   #'s',D2                 ;     if char = 's' or 'S' then
        BEQ.S   @2
        CMP.B   #'S',D2
        BNE.S   @4                      ;       begin
@2      NOT.B   CTLSFLAG(A3)            ;         CTLSflag:=not CTLSflag
@3      MOVE.L  #1,D0                   ;         repeat
        MOVE.L  D0,D1                   ;        { discard all keys up to CTLS }

        TST.W   20(SP)                  ; *** WARNING,DEPENDS ON STACK DEPTH! ***
                                        ;        { see which screen }
        BEQ     @6                      ;        { alt screen }
        traptohw KeybdEvent
        BRA.S   @7
@6      traptohw AltKeyEvent             ;           KeybdEvent(repeat,wait)
@7      SUB.W   #1,(A7)                 ;           index:=index-1
        BGT.S   @3                      ;         until index=0
                                        ;       end;
@4      ADD.W   #1,(A7)                 ;   index:=index+1
        BRA.S   @1                      ; end;
CTRLSX  TST.W   (A7)+                   ;  discard index
        MOVEM.L (A7)+,D0-D6
        RTS
;
;       FUNCTION ISCHAR(EVENT)
;         { Return true (ff) if event is keyboard event, false (0) if other events
;       IUPUT is D2, output of KeybdEvent, ASCII value of the key }
;       OUTPUT IS BOOLEAN IN D0.B
;
ISCHAR  CLR.B   D0
        TST.B   D2              ; D0 = 0 or 1 => disk or mouse event
        BEQ.S   ISCHARX
        CMP.B   #1,D2
        BEQ.S   ISCHARX
        NOT.B   D0
ISCHARX RTS
;
;       FUNCTION GETCHAR
;           called by screenget, inch, for read, readln
;       OUTPUT IS CHAR IN D0
;
GETCHAR
        BSR     CTRLS
        MOVEM.L D1-D6,-(A7)
@1      MOVE.L  #1,D0                   ; repeat
        MOVE.L  D0,D1
        TST.W   14(A7)                  ;       { see which screen }
        BEQ     @8                      ;       { alt screen }
        traptohw KeybdEvent
        BRA.S   @7
@8      traptohw AltKeyEvent            ;   event(repeat,wait)
@7      BSR     ISCHAR                  ; { false if disk or mouse events }
        TST.B   D0
        BEQ.S   @1                      ; until next event is a character
        CMP.B   #$1C,D2                 ; is it a LEFT arrow ?
        BNE.S   @2
        MOVE.B  #$08,D2
@2      CMP.B   #$1D,D2                 ; is it a RIGHT arrow ?
        BNE.S   @3
        MOVE.B  #$0C,D2
@3      CMP.B   #$1E,D2                 ; is it a UP arrow ?
        BNE.S   @4
        MOVE.B  #$0B,D2
@4      CMP.B   #$1F,D2                 ; is it a DOWN arrow ?
        BNE.S   @5
        MOVE.B  #$0A,D2
@5      BTST    #3,D3                   ; is command key down ?
        BEQ.S   @6
        AND.B   #$1F,D2                 ; make it a control character
@6      MOVE.B  D2,D0
        MOVEM.L (A7)+,D1-D6
        RTS
;
;       FUNCTION CHARAVAIL:BOOLEAN
;
CHARAVAIL
        BSR     CTRLS
        MOVEM.L D0-D6,-(A7)
        MOVE.B  #0,32(A7)               ; charavail:=false
@1      MOVE.L  #1,D0                   ; while TRUE do
        MOVE.L  D0,D1                   ; begin
        TST.W   18(A7)                  ;                 { see which screen }
        BEQ     @8                      ;                 { alt screen }
        traptohw KeybdPeek
        BRA.S   @9
@8      traptohw AltKeyPeek             ;   peek(repeat,index) next event
@9      TST.B   D0                      ;   if no event then exit(false)
        BEQ.S   CHARAVX
        BSR     ISCHAR                  ;   if next event is a character then
        TST.B   D0
        BNE.S   @2                      ;     exit(true)
        MOVE.L  #1,D0
        MOVE.L  D0,D1                   ;   else
        TST.W   18(a7)                  ;               {see which screen}
        BEQ     @6                      ;               {alt screen}
        traptohw KeybdEvent
        BRA.S   @7
@6      traptohw AltKeyEvent             ;     flush this event
@7      BRA.S   @1                      ; end
@2      MOVE.B  #1,32(A7)               ; return TRUE, ie. char available
CHARAVX MOVEM.L (A7)+,D0-D6
        RTS
;
FONTTBL                                   ; font table origin here folks
  .BYTE  $00,$00,$00,$00,$00,$00,$00,$00  ;  (space)
  .BYTE  $10,$10,$10,$10,$00,$00,$10,$00  ;  !
  .BYTE  $48,$48,$48,$00,$00,$00,$00,$00  ;  "
  .BYTE  $48,$48,$FC,$48,$FC,$48,$48,$00  ;  #
  .BYTE  $10,$3C,$50,$38,$14,$78,$10,$00  ;  $
  .BYTE  $00,$C4,$C8,$10,$20,$4C,$8C,$00  ;  %
  .BYTE  $60,$90,$90,$60,$94,$88,$74,$00  ;  &
  .BYTE  $08,$10,$20,$00,$00,$00,$00,$00  ;  '
  .BYTE  $08,$10,$20,$20,$20,$10,$08,$00  ;  (
  .BYTE  $40,$20,$10,$10,$10,$20,$40,$00  ;  )
  .BYTE  $10,$54,$38,$7C,$38,$54,$10,$00  ;  *
  .BYTE  $00,$10,$10,$7C,$10,$10,$00,$00  ;  +
  .BYTE  $00,$00,$00,$00,$00,$30,$30,$60  ;  ,
  .BYTE  $00,$00,$00,$FC,$00,$00,$00,$00  ;  -
  .BYTE  $00,$00,$00,$00,$00,$30,$30,$00  ;  .
  .BYTE  $00,$04,$08,$10,$20,$40,$80,$00  ;  /
  .BYTE  $78,$84,$8C,$B4,$C4,$84,$78,$00  ;  0
  .BYTE  $10,$30,$50,$10,$10,$10,$7C,$00  ;  1
  .BYTE  $78,$84,$04,$18,$60,$80,$FC,$00  ;  2
  .BYTE  $78,$84,$04,$38,$04,$84,$78,$00  ;  3
  .BYTE  $08,$18,$28,$48,$FC,$08,$08,$00  ;  4
  .BYTE  $FC,$80,$F0,$08,$04,$88,$70,$00  ;  5
  .BYTE  $38,$40,$80,$F8,$84,$84,$78,$00  ;  6
  .BYTE  $FC,$84,$08,$10,$20,$20,$20,$00  ;  7
  .BYTE  $78,$84,$84,$78,$84,$84,$78,$00  ;  8
  .BYTE  $78,$84,$84,$7C,$04,$08,$70,$00  ;  9
  .BYTE  $00,$00,$30,$30,$00,$30,$30,$00  ;  :
  .BYTE  $00,$00,$30,$30,$00,$30,$30,$60  ;  ;
  .BYTE  $08,$10,$20,$40,$20,$10,$08,$00  ;  <
  .BYTE  $00,$00,$F8,$00,$F8,$00,$00,$00  ;  =
  .BYTE  $40,$20,$10,$08,$10,$20,$40,$00  ;  >
  .BYTE  $78,$84,$04,$18,$20,$00,$20,$00  ;  ?
  .BYTE  $38,$44,$94,$AC,$98,$40,$3C,$00  ;  @
  .BYTE  $30,$48,$84,$FC,$84,$84,$84,$00  ;  A
  .BYTE  $F8,$44,$44,$78,$44,$44,$F8,$00  ;  B
  .BYTE  $78,$84,$80,$80,$80,$84,$78,$00  ;  C
  .BYTE  $F8,$44,$44,$44,$44,$44,$F8,$00  ;  D
  .BYTE  $FC,$80,$80,$F0,$80,$80,$FC,$00  ;  E
  .BYTE  $FC,$80,$80,$F0,$80,$80,$80,$00  ;  F
  .BYTE  $78,$84,$80,$9C,$84,$84,$78,$00  ;  G
  .BYTE  $84,$84,$84,$FC,$84,$84,$84,$00  ;  H
  .BYTE  $38,$10,$10,$10,$10,$10,$38,$00  ;  I
  .BYTE  $1C,$08,$08,$08,$08,$88,$70,$00  ;  J
  .BYTE  $84,$88,$90,$E0,$90,$88,$84,$00  ;  K
  .BYTE  $80,$80,$80,$80,$80,$80,$FC,$00  ;  L
  .BYTE  $84,$CC,$B4,$B4,$84,$84,$84,$00  ;  M
  .BYTE  $84,$C4,$A4,$94,$8C,$84,$84,$00  ;  N
  .BYTE  $78,$84,$84,$84,$84,$84,$78,$00  ;  O
  .BYTE  $F8,$84,$84,$F8,$80,$80,$80,$00  ;  P
  .BYTE  $78,$84,$84,$84,$94,$88,$74,$00  ;  Q
  .BYTE  $F8,$84,$84,$F8,$90,$88,$84,$00  ;  R
  .BYTE  $78,$84,$80,$78,$04,$84,$78,$00  ;  S
  .BYTE  $7C,$10,$10,$10,$10,$10,$10,$00  ;  T
  .BYTE  $84,$84,$84,$84,$84,$84,$78,$00  ;  U
  .BYTE  $84,$84,$84,$48,$48,$30,$30,$00  ;  V
  .BYTE  $84,$84,$84,$B4,$B4,$CC,$84,$00  ;  W
  .BYTE  $84,$84,$48,$30,$48,$84,$84,$00  ;  X
  .BYTE  $44,$44,$44,$38,$10,$10,$10,$00  ;  Y
  .BYTE  $FC,$04,$08,$30,$40,$80,$FC,$00  ;  Z
  .BYTE  $78,$40,$40,$40,$40,$40,$78,$00  ;  [
  .BYTE  $00,$80,$40,$20,$10,$08,$04,$00  ;  \
  .BYTE  $78,$08,$08,$08,$08,$08,$78,$00  ;  ]
  .BYTE  $10,$28,$44,$00,$00,$00,$00,$00  ;  ^
  .BYTE  $00,$00,$00,$00,$00,$00,$00,$FE  ;  _
  .BYTE  $20,$10,$08,$00,$00,$00,$00,$00  ;  `
  .BYTE  $00,$00,$70,$08,$78,$88,$74,$00  ;  a
  .BYTE  $80,$80,$B8,$C4,$84,$C4,$B8,$00  ;  b
  .BYTE  $00,$00,$78,$80,$80,$80,$78,$00  ;  c
  .BYTE  $04,$04,$74,$8C,$84,$8C,$74,$00  ;  d
  .BYTE  $00,$00,$78,$84,$FC,$80,$78,$00  ;  e
  .BYTE  $18,$24,$20,$F8,$20,$20,$20,$00  ;  f
  .BYTE  $00,$00,$74,$8C,$8C,$74,$04,$78  ;  g
  .BYTE  $80,$80,$B8,$C4,$84,$84,$84,$00  ;  h
  .BYTE  $10,$00,$30,$10,$10,$10,$38,$00  ;  i
  .BYTE  $08,$00,$18,$08,$08,$08,$88,$70  ;  j
  .BYTE  $80,$80,$88,$90,$A0,$D0,$88,$00  ;  k
  .BYTE  $30,$10,$10,$10,$10,$10,$38,$00  ;  l
  .BYTE  $00,$00,$E8,$54,$54,$54,$54,$00  ;  m
  .BYTE  $00,$00,$F8,$44,$44,$44,$44,$00  ;  n
  .BYTE  $00,$00,$38,$44,$44,$44,$38,$00  ;  o
  .BYTE  $00,$00,$B8,$C4,$C4,$B8,$80,$80  ;  p
  .BYTE  $00,$00,$74,$8C,$8C,$74,$04,$04  ;  q
  .BYTE  $00,$00,$B8,$C4,$80,$80,$80,$00  ;  r
  .BYTE  $00,$00,$7C,$80,$78,$04,$F8,$00  ;  s
  .BYTE  $20,$20,$F8,$20,$20,$24,$18,$00  ;  t
  .BYTE  $00,$00,$84,$84,$84,$8C,$74,$00  ;  u
  .BYTE  $00,$00,$84,$84,$84,$48,$30,$00  ;  v
  .BYTE  $00,$00,$44,$44,$54,$54,$6C,$00  ;  w
  .BYTE  $00,$00,$84,$48,$30,$48,$84,$00  ;  x
  .BYTE  $00,$00,$84,$84,$8C,$74,$04,$78  ;  y
  .BYTE  $00,$00,$FC,$08,$30,$40,$FC,$00  ;  z
  .BYTE  $38,$40,$40,$C0,$40,$40,$38,$00  ;  {
  .BYTE  $20,$20,$20,$20,$20,$20,$20,$20  ;  |
  .BYTE  $E0,$10,$10,$18,$10,$10,$E0,$00  ;  }
  .BYTE  $28,$50,$00,$00,$00,$00,$00,$00  ;  ~
  .BYTE  $FE,$FE,$FE,$FE,$FE,$FE,$FE,$FE  ;  rubout
;
;
; File: PASTRING.TEXT
; Date: 09-Oct-81

        .PROC   %%%TRING

        .DEF    %_CAT,%_POS,%_COPY,%_DEL,%_INS

;
; %_CAT - Concatenate strings
;
; Parameters: ST.L - Address of 1st string
;             ST.L - Address of 2nd string
;             ...
;             ST.L - Address of Nth string
;             ST.L - Address to put result
;             ST.W - N
;
; This routine preserves all registers
;

%_CAT:
        MOVEM.L D0-D2/A0-A2,-(SP)
        MOVE.W  28(SP),D0       ; N
        MOVE.L  30(SP),A0       ; Address of result
        LEA     34(SP),A1       ; Addr of Addr of Nth parameter
        MOVE.W  D0,D2           ; Incr A1 to point to ...
        LSL.W   #2,D2           ; ... the address of ...
        ADDA.W  D2,A1           ; ... the first parameter
        CLR.W   D1              ; Length of result
        ADDQ.L  #1,A0
        BRA.S   C.TEST
C.LOOP: MOVE.L  -(A1),A2        ; Address of Kth string
        tst.b   (a2)            ; make resident in case it is in code seg
        CLR.W   D2
        MOVE.B  (A2)+,D2        ; Length of Kth string
        ADD.W   D2,D1           ; Update total length
        BRA.S   C.TEST2
C.LOOP2:MOVE.B  (A2)+,(A0)+
C.TEST2:dbra    D2,C.LOOP2      ; dec d2 and branch if d2 <> -1
C.TEST: dbra    D0,C.LOOP       ; See if any more strings
        MOVE.L  30(SP),A0       ; Address of result
        MOVE.B  D1,(A0)         ; Store length of result
        LEA     34(SP),A1       ; Addr of Addr of Nth parameter
        MOVE.W  28(SP),D0       ; N
        LSL.W   #2,D0           ; Set A1 to the address of ...
        ADDA.W  D0,A1           ; ... the first parameter
        MOVE.L  24(SP),-(A1)    ; Set up return address
        MOVE.L  A1,24(SP)       ; Set up final SP
        MOVEM.L (SP)+,D0-D2/A0-A2
        MOVE.L  (SP)+,SP
        RTS

;
; %_POS - Position of one string in another
;
; Parameters: ST.L - Address of SubString
;             ST.L - Address of Main String
;
; Returns:    ST.W - Position
;
; This procedure preserves all registers.
;

%_POS:
        MOVEM.L D0-D2/A0-A2,-(SP)
        MOVE.L  28(SP),A0       ; Address of Main String
        tst.b   (a0)            ; make resident in case it is in code seg
        CLR.W   D0
        MOVE.B  (A0)+,D0        ; Length of Main String
        CLR.W   D1              ; Result
POS.TOP:MOVE.L  32(SP),A1       ; Address of SubString
        tst.b   (a1)            ; make resident in case it is in code seg
        CLR.W   D2
        MOVE.B  (A1)+,D2        ; Length of Substring
        CMP.W   D2,D0           ; Compare lengths
        BGE.S   POS.TRY
        CLR.W   D1              ; No match if substring shorter
        BRA.S   POSDONE
POS.TRY:MOVE.L  A0,A2           ; Get fresh copy of main pointer
        ADDQ.L  #1,D1           ; Update result counter
        BRA.S   POSTEST
POSLOOP:CMPM.B  (A2)+,(A1)+
        BNE.S   TRYNEXT         ; No Match if not equal
POSTEST:dbra    D2,POSLOOP      ; dec d2 and branch if d2 <> -1
        BRA.S   POSDONE         ; Fall through means found it
TRYNEXT:ADDQ.L  #1,A0           ; Update main pointer for next try
        SUBQ.W  #1,D0           ; Decrement remaining length of main string
        BRA.S   POS.TOP
POSDONE:MOVE.W  D1,34(SP)       ; Store the result
        MOVE.L  24(SP),30(SP)   ; Set up the return address
        MOVEM.L (SP)+,D0-D2/A0-A2
        ADDQ.L  #6,SP
        RTS

;
; %_COPY - Copy a substring
;
; Parameters: ST.L - Source string address
;             ST.W - Starting index
;             ST.W - Size to copy
;             ST.L - Address of result
;
; This routine saves all registers
;

%_COPY:
        MOVEM.L D0-D2/A0-A1,-(SP)
        MOVE.L  24(SP),A0       ; Address for result
        MOVE.W  28(SP),D0       ; Size to copy
        MOVE.W  30(SP),D1       ; Index
        SUBQ.W  #1,D1
        MOVE.L  32(SP),A1       ; Address of source string
        tst.b   (a1)            ; make resident in case it is in code seg
        CLR.W   D2              ; to get length of source
        MOVE.B  (A1)+,D2        ;
        SUB.W   D1,D2
        SUB.W   D0,D2
        BLT.S   Y.ERROR         ; Error if too little source
        ADDA.W  D1,A1           ; Point to first byte to copy
        MOVE.B  D0,(A0)+        ; Store result length
        BRA.S   Y.TEST
Y.LOOP: MOVE.B  (A1)+,(A0)+
Y.TEST: dbra    D0,Y.LOOP       ; dec d0 and branch if d0 <> -1
Y.LEAVE:MOVE.L  20(SP),32(SP)   ; Set up return address
        MOVEM.L (SP)+,D0-D2/A0-A1
        ADD.L   #12,SP
        RTS
Y.ERROR:CLR.B   (A0)            ; Set result to null for now
        BRA.S   Y.LEAVE         ; And return

;
; %_DEL - Delete a substring form a string
;
; Parameters: ST.L - Address of string
;             ST.W - Position to start deleting
;             ST.W - Number bytes to delete
;

%_DEL:
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.W  (SP)+,D0        ; Pop Number bytes
        MOVE.W  (SP)+,D1        ; Pop position
        MOVE.L  (SP)+,A0        ; Pop string address
        CMPI.W  #0,D0           ; Exit if bytes to delete
        BLE.S   D.DONE          ; is <= 0
        CMPI.W  #0,D1           ; or if starting position
        BLE.S   D.DONE          ; is <= 0
        CLR.W   D2              ; Fetch ...
        MOVE.B  (A0),D2         ; ... string size
        CMP.W   D1,D2           ; Exit if starting position
        BLT.S   D.DONE          ; is > string size
        MOVE.W  D1,D3           ; Compare position
        ADD.W   D0,D3           ; plus number bytes
        SUBQ.W  #1,D3           ; minus 1
        SUB.W   D2,D3           ; to string size
        BLE.S   D.SETUP
        SUBQ.W  #1,D1           ; Compute result size
        MOVE.B  D1,(A0)         ; and store it
        BRA.S   D.DONE
D.SETUP:SUB.W   D0,D2           ; Compute result size
        MOVE.B  D2,(A0)         ; and store it
        ADDA.W  D1,A0           ; Point to first char to delete
        MOVE.L  A0,A1
        ADDA.W  D0,A1           ; Point to first char to move
        BRA.S   D.TEST
D.LOOP: MOVE.B  (A1)+,(A0)+
D.TEST: ADDQ.W  #1,D3
        BLE.S   D.LOOP
D.DONE: JMP     (A2)

;
; %_INS - Insert a string in another
;
; Parameters: ST.L - Address of string to insert
;             ST.L - Address of main string
;             ST.W - Position in main string to insert
;
; must preserve d4-d7, a3-a7

%_INS:
        MOVE.L  (SP)+,A2        ; Pop return address
        MOVE.W  (SP)+,D0        ; Pop index
        MOVE.L  (SP)+,A1        ; Pop address of main string
        MOVE.L  (SP)+,A0        ; Pop address of string to insert
        tst.b   (a0)            ; make resident in case it is in code seg
        MOVE.L  A2,-(SP)
        SUBQ.W  #1,D0
        BLT.S   I.DONE          ; Exit if index < 0
        CLR.W   D1
        MOVE.B  (A0)+,D1        ; Length of substring
        CLR.W   D2
        MOVE.B  (A1),D2         ; Length of Main String
        CMP.W   D0,D2           ; Exit if index
        BLT.S   I.DONE          ; not in main string
        MOVE.W  D1,D3
        ADD.W   D2,D3           ; Final string size
        MOVE.B  D3,(A1)+
        MOVE.L  A1,A2
        ADDA.W  D3,A2           ; points to last byte in result string +1
        ADDA.W  D2,A1           ; points to last byte of main string +1
        SUB.W   D0,D2           ; How many bytes to move
        BRA.S   I.TEST
I.LOOP: MOVE.B  -(A1),-(A2)
I.TEST: dbra    D2,I.LOOP       ; dec d2 and branch if d2 <> -1
        BRA.S   I.TEST2
I.LOOP2:MOVE.B  (A0)+,(A1)+     ; A1 is Address of hole
I.TEST2:dbra    D1,I.LOOP2      ; dec d1 and branch if d1 <> -1
I.DONE: RTS

        .END



