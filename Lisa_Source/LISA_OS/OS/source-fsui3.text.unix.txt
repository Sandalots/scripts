
(*********************************************************************************)
(*                                                                               *)
(*  (c) copyright 1983, 1984  Apple Computer Inc.                                *)
(*                                                                               *)
(*********************************************************************************)


{
Table of Contents of this module:

  1.  READ_LABEL
  2.  WRITE_LABEL
  3.  MOUNT
  4.  UNMOUNT
  5.  SET_WORKING_DIR
  6.  GET_WORKING_DIR
  7.  SET_SAFETY
  8.  DEVICE_CONTROL
* 9.  RESET_CATALOG
*10.  GET_NEXT_ENTRY
*11.  GET_DEV_NAME    *** removed in release 5.3 ***
*12.  PROTECT
*13.  GET_SERIAL_NO
*14.  PSET_VOL_INFO
 15.  SET_FILE_INFO
*16.  PSET_FILE_INFO
-17.  PMSnapShot
*18.  Write_PMem    *** moved to unit pmem in release 10 ***
*19.  Read_PMem     *** moved to unit pmem in release 10 ***
-20.  FINDMONADR
-21.  PFTP
-22.  FTP
(23.  TEMPLATE)

Note: * indicates a privileged interface.
      - indicates an internal interface.

}

  {$S fs3}
  procedure  UserLabel_IO ( var ecode   : integer;
                            var path    : pathname;
                                addrBuf : longint;
                                count   : longint;
                                op      : ioop;
                            var actual  : longint );
  label   1, 2;

  var
       ParmArr : ParmCheck;
       device  : integer;
       volPath : pathname;
       ptrDCB  : DCBptr;
       S       : s_entry;
       C       : centry;
       DirRec  : ObjRec;
       parID   : NodeIdent;

  begin
      ecode := 0;
      actual := 0;

      with ParmArr do
      begin
        numcheck := 4;
        with parms[1] do
        begin
          addr := addrBuf;
          readwrite := true;
        end{with};
        with parms[2] do
        begin
          if count > 0 then
            addr := addrBuf + count-1
          else
            addr := addrBuf;
          readwrite := true;
        end{with};
        with parms[3] do
        begin
          addr := ord(@actual);
          readwrite := true;
        end{with};
        with parms[4] do
        begin
          addr := ord(@path);
          readwrite := false;
        end{with};
      end{with};
      if not valid_addr(ecode, ParmArr) then goto 1;

      DecompPath(ecode, path, device, parID, volPath);

      if (ecode > 0) or
         (length(volPath) = 0) then
      begin
        ecode := E5_PATH_INVALID;
        goto 1;
      end{if};

      ptrDCB := mounttable[device];
      if not configinfo[device]^.blockstructured then
      begin
        ecode := E5_PATH_INVALID;
        goto 1;
      end{if};

      if (count < 0) or (count > ptrDCB^.MDDFdata^.flabel_size) then
      begin
        ecode := E1_LABL_RANGE;
        goto 1;
      end{if};

      wait_sem(ptrDCB^.volSem, []);
      ReadDir(device, parID, volPath, DirRec, C, ecode);
      if ecode > 0 then
      begin
        ecode := E5_NOT_FOUND;     (* could not find the named entry, or catptr was not a cat *)
        goto 2;
      end;
      if DirRec.eType = direntry then
      begin
        ecode := E_DIR_OP;
        goto 2;
      end;

      slist_io(ecode, device, C.sfile, readop, S); (* get s-entry to find hints *)
      if ecode > 0 then goto 2;
      if S.hintaddr <= 0 then
      begin
        ecode := E_BADSENTRY;
        goto 2;
      end;

      vm(ecode, device, S.hintaddr,
         sizeof(PageLabel)+ptrDCB^.MDDFdata^.flabel_offset, addrBuf, count, op);
      if ecode <= 0 then actual := count;

  2:
      signal_sem(ptrDCB^.volSem);

  1:  (* exit *)

  end{proc UserLabel_IO};





  {$S fs3 }
  procedure Read_Label (* var ecode     : error;
                          var path      : pathname;
                              data_addr : longint;
                              count     : longint;
                          var actual    : longint *);

  begin
      UserLabel_IO(ecode, path, data_addr, count, readop, actual);
  end{proc Read_Label};


  {$S fs3 }
  procedure Write_Label (* var ecode     : error;
                           var path      : pathname;
                               data_addr : longint;
                               count     : longint;
                           var actual    : longint *);

  begin
      UserLabel_IO(ecode, path, data_addr, count, writeop, actual);
  end{proc Write_Label};








(*$S fs3 *)
procedure MOUNT (*var ecode:error; var vname : e_name; var password, devname : e_name*);

label 1;

var device : integer;

begin


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('MOUNT:  request to mount device ', devname);
  end;
(*$ENDC*)

  ecode := 0;

  device := map_dev_name (devname);     (* find device number by requested name *)

  if device < 0 then
  begin
    ecode := E2_DEV_INVALID;                          (* no such device or volume name *)
    goto 1;
  end;

  if mounttable [device] <> pointer (badptr1) then     (* something already mounted *)
  begin
    ecode := E_DEV_MOUNTED;     (* could be a mounted volume with same name as a device *)
    goto 1;
  end;

  fs_mount (ecode, device);           (* mount the volume on the requested device *)

  if (ecode <= 0) then  (* < 0 are warnings only *)
  begin
    vname := mounttable [device]^.name;
  end
  else vname := '';


1:

  {if (ecode > 0) and (ecode < 100) then
                             ecode := EXTERRBASE + UIERRBASE + PERRBASE + ecode;}


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('MOUNT:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;   (* of procedure MOUNT *)










{$S fs3 }
procedure Unmount (* var ecode : error;
                     var vname : e_name *);

label 1;

var
     device         : integer;
     c_syslocal_ptr : slocal_ptr;
     ptrDCB         : DCBptr;

begin

{$IFC DEBUG2}
    if trace (FS, 70) then
      writeln ('UNMOUNT:  ', vname);
{$ENDC}

    ecode := 0;

    device := map_dev_name (vname);     (* find device number of requested name *)
    if device < 0 then
    begin
      ecode := E3_DEV_INVALID;
      goto 1;
    end{if};

    ptrDCB := mounttable[device];
    if ptrDCB = pointer (badptr1) then     (* nothing mounted *)
    begin
      ecode := E3_NO_DEV_MOUNTED;
      goto 1;
    end
    else if ptrDCB^.status <> fsmounted then
    begin
      ecode := E3_NO_DEV_MOUNTED;
      goto 1;
    end;

    fs_unmount (ecode, device);      (* unmount the volume from the requested device *)

    (* re-establish default working dev if unmounting current working dev *)
    c_syslocal_ptr := pointer (b_syslocal_ptr);
    with c_syslocal_ptr^ do
    begin
      if working_dev = device then
      begin
        working_dev := bootdev;
        workDirID := ROOT_NID;
      end{if};
    end{with};

1:  (* exit *)

{$IFC DEBUG2}
    if trace (FS, 70) then
      writeln ('UNMOUNT:  exit error = ',ecode);
{$ENDC}

end{proc Unmount};





(*$S fs3 *)
procedure SET_WORKING_DIR (*var ecode:error; var path:pathname*);

label 1;

var devnum : integer;
    volPath : pathname;
    c_syslocal_ptr : slocal_ptr;
    partial : boolean;
    ptrDCB  : DCBptr;
    parID   : NodeIdent;

begin

(*$IFC DEBUG2*)
  if trace(FS, 70) then
    writeln ('SET_WORKING_DIR  path = "',path,'"');
(*$ENDC*)

  ecode := 0;
  if path = '' then exit(SET_WORKING_DIR);

  DecompPath(ecode, path, devnum, parID, volPath);

  if ecode > 0 then ecode := E7_PATH_INVALID
   (* invalid device, or not mounted, or an entry in a catalog *)
  else if not configinfo[devnum]^.blockstructured then
    ecode := E7_PATH_INVALID
  else
  begin
    c_syslocal_ptr := pointer(b_syslocal_ptr);
    if not flat_catalog(devnum) then
    begin
      ptrDCB := mounttable[devnum];
      SetWorkingDir(ptrDCB, parID, volPath, ecode);
      if ecode > 0 then exit(SET_WORKING_DIR);
    end
    else if (length(volPath) <> 0) then
    begin
      ecode := E7_PATH_INVALID;
      exit(Set_Working_Dir);
    end
    else
      c_syslocal_ptr^.workDirID := ROOT_NID;
    c_syslocal_ptr^.working_dev := devnum;
  end;

1:

(*$IFC DEBUG2*)
  if trace (FS, 70) then
    writeln ('SET_WORKING_DIR  exit error = ',ecode);
(*$ENDC*)

end;   (* of procedure SET_WORKING_DIR *)











(*$S fs3 *)
procedure GET_WORKING_DIR (*var ecode:error; var path:pathname*);

begin

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('GET_WORKING_DIR:  request to get working dir');
  end;
(*$ENDC*)

  ecode := 0;

  GetWorkingDir(path, ecode);

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('GET_WORKING_DIR:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;   (* of procedure GET_WORKING_DIR *)





{$S fs2}
(*
 *  Returns holding root catalog semaphore if ecode <= 0
 *)
procedure  FetchHentry (* var ecode  : integer;
                          var path   : pathname;
                          var device : integer;
                          var sfile  : integer;
                          var S      : s_entry;
                          var H      : hentry *);

label   2;

var
     name  : e_name;
     volPath : pathname;
     C : centry;
     DirRec : ObjRec;
     parID  : NodeIdent;

begin
  ecode := 0;

  DecompPath(ecode, path, device, parID, volPath);

  if (ecode > 0) or (length(volPath) = 0) then
    ecode := E8_PATH_INVALID
  else
  if not configinfo [device]^.blockstructured then
  begin
    ecode := E8_PATH_INVALID;
  end
  else
  begin
    wait_sem(mounttable[device]^.volSem, []);
    ReadDir(device, parID, volPath, DirRec, c, ecode);
    if (ecode > 0) then
    begin
      ecode := E7_NOT_FOUND;     (* could not find the named entry, or catptr was not a cat *)
      goto 2;
    end;
    if DirRec.eType = direntry then
    begin
      ecode := E_DIR_OP;
      goto 2;
    end;

    slist_io(ecode, device, c.sfile, readop, S); (* get s-entry to find hints *)
    if ecode > 0 then goto 2;
    if S.hintaddr <= 0 then
    begin
      ecode := E_BADSENTRY;
      goto 2;
    end;
    sfile := c.sfile;

    hentry_io(ecode, device, S.hintaddr, H, readop); (* get hints *)
    if ecode > 0 then goto 2;
    if length(h.name) > max_ename then
    begin
      ecode := E_BADENAME;
      goto 2;
    end;
    exit(FetchHentry);

2:
    signal_sem(mounttable[device]^.volSem);
  end;

end{proc FetchHentry};




{$S fs2}
procedure Set_Hentry (* var ecode  : error;
                        var path   : pathname;
                            ptrFCB : SFCB_ptr;
                        var parm   : sh_parmt *);

label 1, 2;

var
     s        : s_entry;
     h        : hentry;
     snum     : integer;
     devnum   : integer;
     objKey   : RecKey;
     ptrDCB   : DCBptr;
     hpage    : longint;
     ptrBuf   : buffer_ptr;
     DirRec   : ObjRec;
     found    : boolean;
     ptrEntry : entry_ptr;

begin
{$IFC DEBUG2}
  if trace (FS, 70) then
    writeln ('SET_HENTRY:  ', path);
{$ENDC}

    if ptrFCB = pointer(badptr2) then
    begin
      FetchHentry(ecode, path, devnum, snum, s, h);
      if ecode > 0 then goto 1;  (* signal already done *)
      hpage := s.hintaddr;
      ptrDCB := mounttable[devnum];
    end
    else
    begin
      with ptrFCB^ do
      begin
        hpage := sent.hintaddr;
        devnum := curdev;
        snum := sfilenum;
      end{with};
      ptrDCB := mounttable[devnum];
      wait_sem(ptrDCB^.volSem, []);
      hentry_io(ecode, devnum, hpage, h, readop);
      if ecode > 0 then goto 2;
    end{if};

    with parm do case command of
      c_safety:
        begin
          h.safety_on := on_off;
        end;
      c_protect:
        begin
          h.protected := true;
          h.master := ismaster;
          h.machine_id := m_serial_no;
        end;
      c_dates:
        begin
          h.DTC := date_created;
          h.DTM := date_modified;
          h.DTA := date_accessed;
          h.DTB := date_backup;
          h.DTS := date_scavenged;
        end;
      c_etc:
        begin
          h.protected := protect_flag;
          h.scavenged := scavenge_flag;
          h.closed_by_OS := OS_close_flag;
          h.file_open := left_open_flag;
          h.user_type := utype;
          h.user_subtype := usubtype;
          h.system_type := stype;
          h.file_portion := file_part;
          h.build_info := build_cntrl;
        end;
      c_passwd:
        begin
          (* password is already encrypted *)
          moveleft(newPassword, h.password, sizeof(Str8));
        end;
      otherwise ;
    end;   (* of case command of *)

    hentry_io (ecode, devnum, hpage, h, writeop); (* write hints *)

    (* Update the catalog record *)

    if not flat_catalog(devnum) then
    begin
      MakeKey(h.parentID, @h.name, @objKey);
      E_Search(ptrDCB, @objKey, ptrBuf, ptrEntry, found, ecode);
      if ecode > 0 then goto 2;
      if not found then
      begin
        ecode := E_TREE_MUNCH;
        FreeBuf(ptrBuf);
        goto 2;
      end{if};

      with parm, ptrEntry^ do
      begin
        case command of
          c_safety:     flags[fSafety] := on_off;
          c_protect:
            begin
                        flags[fProtect] := true;
                        flags[fMaster] := ismaster;
            end;
          c_dates:
            begin
                        fileDTC := date_created;
                        fileDTM := date_modified;
            end;
          c_etc:
            begin
                        flags[fProtect] := protect_flag;
                        flags[fScavenged] := scavenge_flag;
                        flags[fClosed] := OS_close_flag;
                        flags[fCrashed] := left_open_flag;
            end;
          otherwise  ;
        end{case};
      end{with};
      ptrBuf^.dirty := TRUE;
      FreeBuf(ptrBuf);
    end{if};

    (* see if file is open, and if so, set hentry in sfile control block *)
    sopencheck (ecode, devnum, snum, ptrFCB);
    if ecode > 0 then goto 2;

    if ptrFCB <> pointer (badptr2) then with parm do
    case command of
      c_safety:
        begin
          ptrFCB^.sswitch := on_off;
        end;
      c_protect:
        begin
          ptrFCB^.sfcb_protected := true;    (* is protection on for this file *)
          ptrFCB^.sfcb_master := ismaster;   (* if so, is this a master file *)
          ptrFCB^.mid := m_serial_no; (* for protection, machine allowing open *)
        end;
      c_dates:
        begin
          ptrFCB^.DTC := date_created;
          ptrFCB^.DTM := date_modified;
          ptrFCB^.DTA := date_accessed;
          ptrFCB^.DTB := date_backup;
          ptrFCB^.DTS := date_scavenged;
        end;
      c_etc:
        begin
          ptrFCB^.sfcb_protected := protect_flag;
          ptrFCB^.scav_flag := scavenge_flag;
          ptrFCB^.OS_close_flag := parm.OS_close_flag;
          ptrFCB^.file_still_open := left_open_flag;
          ptrFCB^.user_type := utype;
          ptrFCB^.user_subtype := usubtype;
          ptrFCB^.system_type := stype;
          ptrFCB^.file_portion := file_part;
          ptrFCB^.build_info := build_cntrl;
        end;
      c_passwd:
        begin
          moveleft(newPassword, ptrFCB^.password, sizeof(Str8));
        end;
      otherwise ;
    end{case};

2:
    signal_sem (ptrDCB^.volSem);

1:  (* exit *)

{$IFC DEBUG2}
  if trace (FS, 70) then
    writeln ('SET_HENTRY:  exit error = ',ecode);
{$ENDC}

end{proc Set_Hentry};



{$S fs3}
procedure Change_Password (* var ecode     : integer;
                             var path      : pathname;
                             var oldPasswd : e_name;
                             var newPasswd : e_name *);

var
     locl_password : e_name;
     device : integer;
     S      : s_entry;
     snum : integer;
     H      : hentry;
     wcode  : integer;
     Parm   : SH_Parmt;

begin
    (* Copy the old password *)
    locl_password := oldPasswd;

    FetchHentry(ecode, path, device, snum, S, H);
    if ecode > 0 then exit(Change_Password);  (* signal already done *)
    (* have catalog semaphore *)

    CheckPasswd(ecode, locl_password, H);
    if ecode > 0 then
    begin
      signal_sem(mounttable[device]^.volSem);
      exit(Change_Password);
    end;

    wcode := ecode;

    signal_sem(mounttable[device]^.volSem);

    locl_password := newPasswd;
    crypt(locl_password);
    Parm.command := c_passwd;
    Parm.newPassword := locl_password;
    Set_Hentry(ecode, path, pointer(badptr2), Parm);

    if ecode = 0 then ecode := wcode;
end{proc Change_Password};





{$S fs3}
procedure Verify_Password (* var ecode  : integer;
                             var path   : pathname;
                             var passwd : e_name *);

var
     locl_password : e_name;
     device : integer;
     S      : s_entry;
     H      : hentry;
     snum   : integer;

begin
    (* Copy the trial password *)
    locl_password := passwd;

    FetchHentry(ecode, path, device, snum, S, H);
    if ecode > 0 then exit(Verify_Password);  (* signal already done *)
    (* have catalog semaphore *)

    CheckPasswd(ecode, locl_password, H);

    signal_sem(mounttable[device]^.volSem);

end{proc Verify_Password};




(*$S fs3 *)
procedure SET_SAFETY (*var ecode:error; var path:pathname; on_off:boolean*);

var parm : sh_parmt;

begin


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('SET_SAFETY:  request to set safety switch on ', path);
  end;
(*$ENDC*)

  parm.command := c_safety;
  parm.on_off := on_off;

  set_hentry (ecode, path, pointer(badptr2), parm);   (* also updates sfcb if file is open *)


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('SET_SAFETY:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;   (* of procedure SET_SAFETY *)







(*$S fs3 *)
procedure DEVICE_CONTROL (*var ecode : error;
                            var path : pathname;
                           var cparm : dctype*);

       (* NOTE:  cparm is the address of a record *)

label 1;

const parmbytes =  12;    (* calculated by hand for each procedure *)
      perrbase = 180;

var devnum : integer;
    volPath : pathname;
    dev_name : e_name;
    parm : params;
    dash_loc : integer;
    parID    : NodeIdent;

begin


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('DEVICE_CONTROL:  request for device control on ', path);
  end;
(*$ENDC*)

  ecode := 0;

  DecompPath(ecode, path, devnum, parID, volPath);

  if (ecode > 0) and (ecode <> E_NOT_MOUNTED) then
    ecode := E4_DEV_INVALID
  else
  begin
    if ((length(volPath) = 0) and (parID = ROOT_NID))
        or (not configinfo [devnum]^.blockstructured) then
    begin
      (*$IFC OS15*)
      if configinfo[devnum]^.devt <> non_io then
        UP(ecode,configinfo[devnum],nil);
      if ecode > 0 then goto 1;
      (*$ENDC*)
      parm.fnctn_code := dcontrol;
      (*$IFC NOT OS15*)
      parm.dvindex := devnum;
      (*$ENDC*)
      parm.parptr := ord(@cparm);   (* absptr of user parameter structure *)
      drivercall (ecode, devnum, @parm);
    end
    else
    begin
      ecode := E_NOT_IMPLEMENTED;      (* not yet implemented for files *)
    end;
  end;

1:

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('DEVICE_CONTROL:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;   (* of procedure DEVICE_CONTROL *)




(*$S fs2 *)
procedure RESET_CATALOG (*var ecode:error; var path:pathname*);


label 1;

var devnum : integer;
    c_syslocal_ptr : slocal_ptr;
    gnerecp : ^gne_rec_t;
    volPath : pathname;
    parID   : NodeIdent;

begin

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('RESET_CATALOG:  request to reset catalog ',path);
  end;
(*$ENDC*)

  ecode := 0;

  DecompPath(ecode, path, devnum, parID, volPath);

  if ecode > 0 then
    ecode := E9_PATH_INVALID
   (* invalid device, or not mounted, or not a catalog *)
  else if not configinfo [devnum]^.blockstructured then
    ecode := E9_PATH_INVALID
  else
  begin
    if flat_catalog(devnum) then
    begin
      if length(volPath) <> 0 then
        ecode := E9_PATH_INVALID
      else
      begin
        c_syslocal_ptr := pointer (b_syslocal_ptr);
        if c_syslocal_ptr^.gne_recptr = badptr2 then  (* do we have gne rec space? *)
        begin
          if not getspace (sizeof (gne_rec_t), b_syslocal_ptr,
                                                     c_syslocal_ptr^.gne_recptr) then
          begin
            ecode := E1_GNEBUF_NOSPACE;
            goto 1;
          end;
        end;
        c_syslocal_ptr^.scanDevice := devnum;
        c_syslocal_ptr^.scanPage := rootptr[devnum]^.sent.fileaddr;
        c_syslocal_ptr^.scanIndex := 0;
        c_syslocal_ptr^.scanID := ROOT_NID;
        gnerecp := pointer (c_syslocal_ptr^.gne_recptr);
        gnerecp^.cecount := 0;                        (* none read, none scanned *)
      end{if};
    end
    else
      ResetDir(mounttable[devnum], parID, volPath, ecode);
  end;

1:

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('RESET_CATALOG:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;   (* of procedure RESET_CATALOG *)





{$S fs2}
procedure  Reset_Subtree (* var ecode : integer;
                            var path  : pathname *);

var
     device    : integer;
     ptrSysloc : slocal_ptr;
     volPath   : pathname;
     parID     : NodeIdent;

begin
    ecode := 0;

    DecompPath(ecode, path, device, parID, volPath);

    if ecode > 0 then
      ecode := E9_PATH_INVALID
     (* invalid device, or not mounted, or not a catalog *)
    else if not configinfo [device]^.blockstructured then
      ecode := E9_PATH_INVALID
    else if flat_catalog(device) then
      ecode := 1285 (* E_FLAT_OP *)
    else
      ResetDir(mounttable[device], parID, volPath, ecode);
    ptrSysloc := pointer(b_syslocal_ptr);
    if ecode <= 0 then ptrSysloc^.scanMode := treescan;
end{proc Reset_Subtree};

















(*$S fs2 *)
procedure GET_NEXT_ENTRY (*var ecode:error; var prefix, entry : e_name*);


label 1;

var devnum, l, index, bindex : integer;
    c_syslocal_ptr : slocal_ptr;
    gnerecp : ^gne_rec_t;
    actual : longint;
    match, ioerr : boolean;
    uc_prefix, uc_ename : e_name;
    volPath : pathname;
    DirRec : ObjRec;
    level : integer;

begin
  ecode := 0;
  c_syslocal_ptr := pointer (b_syslocal_ptr);
  devnum := c_syslocal_ptr^.scanDevice;

  if c_syslocal_ptr^.scanPage = -1 then
  begin
    ecode := E_EOF;
    goto 1;
  end;

  if flat_catalog(devnum) then
  begin
    if c_syslocal_ptr^.gne_recptr = badptr2 then  (* do we have gne rec space? *)
    begin
      if not getspace (sizeof (gne_rec_t), b_syslocal_ptr,
                                                 c_syslocal_ptr^.gne_recptr) then
      begin
        ecode := E2_GNEBUF_NOSPACE;
        goto 1;
      end;
      gnerecp := pointer (c_syslocal_ptr^.gne_recptr);
      gnerecp^.cecount := 0;                        (* none read, none scanned *)
    end
    else
    begin
      gnerecp := pointer (c_syslocal_ptr^.gne_recptr);
    end;

    l := length (prefix);
    match := false;
    ioerr := false;
    uc_prefix := prefix;   (* local copy *)
    upshift (@uc_prefix);

    wait_sem (mounttable [devnum]^.volSem, []);
                                  (* to prevent rename or kill entry from coming in *)
    index := gnerecp^.cecount;    (* how many scanned already *)

    while (index < mounttable [devnum]^.MDDFdata^.rootmaxentries) AND
          (not ioerr) AND
          (not match) do
    begin
      bindex := (index mod gne_cecount) + 1;
      if (bindex = 1) then                        (* get next chunk of entries *)
      begin
        fileio (ecode, rootptr [devnum], ord(@gnerecp^.centries), sizeof (ce_at),
            actual, c_syslocal_ptr^.scanPage, c_syslocal_ptr^.scanIndex, readop);
        if ecode > 0 then   (* some kind of error condition *)
        begin
          ioerr := (ecode <> E_EOF) AND (ecode <> E_READ_PAST_LEOF);  (* eof is not error *)
          if not ioerr then ecode := 0;                (* clear eof condition *)
        end;
      end;
      if not ioerr then
      begin
        if (gnerecp^.centries [bindex].cetype <> emptyentry) AND
           (gnerecp^.centries [bindex].cetype <> removed) then
        begin                            (* skip empty entries *)
          if l <= length(gnerecp^.centries [bindex].name) then
          begin   (* prefix is not longer than entry name, so check it *)
            if gnerecp^.centries [bindex].name = '' then
            begin
              if l=0 then match := true;   (* should not see any null names, though *)
            end   (* of null name *)
            else
            begin
              uc_ename := copy (gnerecp^.centries [bindex].name, 1, l);
              upshift (@uc_ename);
              if uc_prefix = uc_ename then match := true;
            end;  (* of non-null name *)
          end;  (* of prefix not longer than entry name *)
        end;  (* of non-empty or removed entry *)
        index := index + 1;
      end;  (* of no error on fileio *)
    end;

    gnerecp^.cecount := index;

    signal_sem (mounttable [devnum]^.volSem);

           (* return matched full name *)
    if match then entry := gnerecp^.centries [bindex].name
    else if not ioerr then      (* I/O worked OK, but we could be at eof *)
    begin
      if index >= mounttable [devnum]^.MDDFdata^.rootmaxentries then ecode := E_EOF;
    end;
  end
  else
  begin
    uc_prefix := prefix;
    upshift(@uc_prefix);
    repeat
      GetNextEntry(entry, DirRec, level, ecode);
      uc_ename := entry;
      upshift(@uc_ename);
    until (ecode > 0) or (pos(uc_prefix, uc_ename) = 1) or (length(uc_prefix) = 0);
  end{if};

1:
  if ecode > 0 then entry := '';

{$IFC DEBUG2}
  if trace(FS, 70) then
    writeln('GET_NEXT_ENTRY  exit error = ',ecode);
{$ENDC}

end{proc Get_Next_Entry};




  {$S fs2 }
  procedure Lookup_Next_Entry (* var ecode   : integer;
                                 var prefix  : e_name;
                                 var InfoRec : Q_Info *);

  var
       ptrSysLoc   : slocal_ptr;
       name        : e_name;
       path        : pathname;
       attributes  : FS_Info;
       DirRec      : ObjRec;
       uc_ename    : e_name;
       uc_prefix   : e_name;
       device      : integer;
       level       : integer;
       ptrFCB      : SFCB_ptr;
       locl_ecode  : integer;

  begin
      ecode := 0;
      ptrSysLoc := pointer(b_syslocal_ptr);
      device := ptrSysLoc^.scanDevice;
      ClearMem(ord(@InfoRec), sizeof(InfoRec));

      if flat_catalog(device) then
      begin
        Get_Next_Entry(ecode, prefix, name);
        if ecode > 0 then exit(Lookup_Next_Entry);
        path := concat('-',configinfo[device]^.devname,'-',name);
        Lookup(ecode, path, attributes);
        if ecode > 0 then exit(Lookup_Next_Entry);
        with attributes, InfoRec do
        begin
          name := attributes.name;
          eType := attributes.etype;
          DTC := attributes.DTC;
          DTM := attributes.DTM;
          size := attributes.size;
          psize := attributes.psize;
          fs_overhead := attributes.fs_overhead;
          master := master_file;
          protected := attributes.protected;
          safety := safety_on;
          left_open := file_left_open;
          scavenged := file_scavenged;
          closed_by_OS := file_closed_by_OS;
          nreaders := attributes.nreaders;
          nwriters := attributes.nwriters;
        end{with};
      end
      else
      begin
        uc_prefix := prefix;
        upshift(@uc_prefix);
        repeat
          GetNextEntry(name, DirRec, level, ecode);
          uc_ename := name;
          upshift(@uc_ename);
        until (ecode > 0) or (pos(uc_prefix, uc_ename) = 1) or (uc_prefix = '');
        sopencheck(locl_ecode, device, DirRec.sfile, ptrFCB);
        Dir_Report(DirRec, InfoRec);
        if ptrFCB <> pointer(BADPTR2) then
        begin
          InfoRec.nreaders := ptrFCB^.nreaders;
          InfoRec.nwriters := ptrFCB^.nwriters;
        end{if};
        InfoRec.level := level;
      end{if};
  end{proc Lookup_Next_Entry};






(*$S fs3 *)
procedure PROTECT (* var ecode : error;
                      var path : pathname;
                      ismaster : boolean;
                   m_serial_no : longint   *);


var parm : sh_parmt;

begin

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    write ('PROTECT:  request to protect object ', path,', ');
    if not ismaster then write ('not ');
    writeln ('master, serial no. ',m_serial_no);
  end;
(*$ENDC*)

  parm.command := c_protect;
  parm.ismaster := ismaster;
  parm.m_serial_no := m_serial_no;

  set_hentry (ecode, path, pointer(badptr2), parm);   (* also updates sfcb if file is open *)

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('PROTECT:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;    (* of procedure PROTECT *)







(*$S fs3 *)
procedure GET_SERIAL_NO (* var ecode : error; var s_no : longint *);

label 1;

const perrbase = 215;

begin


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('GET_SERIAL_NO:  requested.');
  end;
(*$ENDC*)

  ecode := 0;
  s_no := serial_no;    (* serial number of machine this is now running on *)

1:

  {if (ecode > 0) and (ecode < 100) then
                            ecode := EXTERRBASE + UIERRBASE + PERRBASE + ecode;}


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('GET_SERIAL_NO:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;    (* of procedure GET_SERIAL_NO *)









(*$S fs2 *)
procedure PSET_VOL_INFO (*  var ecode : error;
                            var path  : pathname;
                                fsi   : fs_info  *);

label 1;

var
     devnum  : integer;
     h       : hentry;
     s       : s_entry;
     volPath : pathname;
     parID   : NodeIdent;

begin

{$IFC DEBUG2}
     if trace (FS, 70) then
       writeln ('PSET_VOL_INFO:  ',path);
{$ENDC}

     ecode := 0;

     DecompPath(ecode, path, devnum, parID, volPath);

     if (ecode > 0) or (length(volPath) <> 0) or (parID <> ROOT_NID) then
       ecode := E10_PATH_INVALID  (* invalid device name, or device not mounted *)
     else if not configinfo[devnum]^.blockstructured then
       ecode := E4_NOT_BLOCK_DEV  (* not a structured device *)
     else
     begin
       with mounttable[devnum]^.MDDFdata^ do
       begin
         volnum := fsi.volnum;
         password := fsi.password;

         copy_thread := fsi.copy_thread;

         DT_created := fsi.DTVC;
         DT_copy_created := fsi.DTCC;
         DT_copied := fsi.DTVB;
         DT_scavenged := fsi.DTVS;

         init_machine_id := fsi.machine_id;
         master_machine_id := fsi.master_copy_id;
         vol_scavenged := fsi.scavenge_flag;
         tbt_copied := fsi.copy_flag;
         backup_volid := fsi.backup_volid;
         vol_seq_no := fsi.vol_sequence;
       end{with};

       mounttable[devnum]^.left_mounted := fsi.vol_left_mounted;
       mounttable[devnum]^.MDDFdirty := true;
     end{if};

1:  (* exit *)

{$IFC DEBUG2}
     if trace (FS, 70) then
       writeln ('PSET_VOL_INFO:  exit error = ',ecode);
{$ENDC}

end{proc Pset_Vol_Info};








{$S fs2 }
procedure Set_File_Info (* var ecode  : error;
                               refnum : integer;
                               fsi    : fs_info  *);

label 1;

var
     addrRefDB : absptr;
     ptrRefDB  : fref_ptr;
     parm_rec  : sh_parmt;
     path      : pathname;

begin
{$IFC DEBUG2}
    if trace (FS, 70) then
      writeln ('SET_FILE_INFO:  refnum = ', refnum);
{$ENDC}

     ecode := 0;
     path := '';

     chk_refnum (ecode, refnum, frefdb, addrRefDB);
     if ecode <> 0 then
     begin
       ecode := E9_REFNUM_INVALID;    (* invalid refnum *)
       goto 1;
     end;

     ptrRefDB := pointer (addrRefDB);   (* make a pointer to the fs_refdb *)

     with fsi, ptrRefDB^ do
     begin
       if not configinfo[refdb_devnum]^.blockstructured then
         ecode := E5_NOT_BLOCK_DEV
       else
       begin
         with parm_rec do
         begin
           command := c_etc;

           scavenge_flag := file_scavenged;
           OS_close_flag := file_closed_by_OS;
           left_open_flag := file_left_open;
           utype := user_type;
           usubtype := user_subtype;
           file_part := file_portion;

           (*
            *  This interface does not allow changing of the
            *  protected bit or the system file type; so get
            *  this information from the FCB.
            *)

           wait_sem(fcbptr^.semgp, []);
           protect_flag := fcbptr^.sfcb_protected;
           stype := fcbptr^.system_type;
           build_cntrl := fcbptr^.build_info;
           signal_sem(fcbptr^.semgp);
         end{with};

         set_hentry(ecode, path, fcbptr, parm_rec);
       end{if};
     end{with};

1:  (* exit *)

{$IFC DEBUG2}
     if trace (FS, 70) then
       writeln ('SET_FILE_INFO:  exit error = ',ecode);
{$ENDC}

end{proc Set_File_Info};









{$S fs2 }
procedure Pset_File_Info (* var ecode   : error;
                                refnum  : integer;
                                fsi     : fs_info  *);

label 1;

var
     addrRefDB : absptr;
     ptrRefDB  : fref_ptr;
     parm_rec  : sh_parmt;
     path      : pathname;

begin
{$IFC DEBUG2}
     if trace (FS, 70) then
       writeln ('PSET_FILE_INFO:  refnum = ', refnum);
{$ENDC}

     ecode := 0;

     chk_refnum (ecode, refnum, frefdb, addrRefDB);
     if ecode > 0 then
     begin
       ecode := E9_REFNUM_INVALID;    (* invalid refnum *)
       goto 1;
     end;

     ptrRefDB := pointer (addrRefDB);   (* make a pointer to the fs_refdb *)

     with fsi, ptrRefDB^ do
     begin
       if not configinfo[refdb_devnum]^.blockstructured then
            ecode := E5_NOT_BLOCK_DEV
       else
       begin
         (*  Set flags in the catalog hint  *)

         with parm_rec do
         begin
           command := c_etc;

           scavenge_flag := file_scavenged;
           OS_close_flag := file_closed_by_OS;
           left_open_flag := file_left_open;
           protect_flag := protected;
           utype := user_type;
           usubtype := user_subtype;
           stype := system_type;
           file_part := file_portion;
           build_cntrl := build_info;
         end{with};

         set_hentry(ecode, path, fcbptr, parm_rec);


         (*  Set dates in the catalog hint  *)

         with parm_rec do
         begin
           command := c_dates;

           date_created := DTC;
           date_modified := DTM;
           date_accessed := DTA;
           date_backup := DTB;
           date_scavenged := DTS;
         end{with};

         set_hentry(ecode, path, fcbptr, parm_rec);

       end{if};
     end{with};

1:  (* exit *)

{$IFC DEBUG2}
    if trace (FS, 70) then
      writeln ('PSET_FILE_INFO:  exit error = ',ecode);
{$ENDC}

end{proc Pset_File_Info};







(*$S fs4 *)
procedure PMSnapshot;

      (*************************************************************)
      (*                                                           *)
      (* Description:                                              *)
      (*   Procedure to write the current contents of the          *)
      (*   sysglobal copy of parameter memory to the snapshot of   *)
      (*   parameter memory on the boot disk.                      *)
      (*                                                           *)
      (* Input Parameters:                                         *)
      (*   None, although the sysglobal copy of parameter memory   *)
      (*   and the ID of this machine are used to write the        *)
      (*   snapshot.                                               *)
      (*                                                           *)
      (* Output Parameters:                                        *)
      (*   None.                                                   *)
      (*                                                           *)
      (* Side Effects:                                             *)
      (*   The file system buffers are flushed in the course of    *)
      (*   rewriting the MDDF of the boot disk.                    *)
      (*                                                           *)
      (* Special Conditions of Use:                                *)
      (*   This routine is intended to be used only by the         *)
      (*   parameter memory support routines.                      *)
      (*                                                           *)
      (* Error Conditions:                                         *)
      (*   None.                                                   *)
      (*                                                           *)
      (*************************************************************)

  var
    ecode : error;                       { error return from FlushFS }

  begin
    with mounttable [bootdev]^ do
    begin
      wait_sem (semMDDF, []);
      with MDDFdata^ do
      begin
        pmem.parm_mem := param_mem.parm_mem;   { get sysglobal copy }
        pmem_id := serial_no;
      end;
      MDDFdirty := true;   { so it will be written out }
      signal_sem (semMDDF);
    end;

    FlushFS (ecode);
  end { PMSnapshot };





  {$S fs5}
  procedure Read_Attributes (* var ecode   : integer;
                               var path    : pathname;
                                   bufaddr : longint;
                                   count   : integer;
                                   offset  : integer;
                               var actual  : integer *);

  begin
      ecode := E_NOT_IMPLEMENTED;
  end{proc Read_Attributes};



  {$S fs5}
  procedure Write_Attributes (* var ecode   : integer;
                                var path    : pathname;
                                    bufaddr : longint;
                                    count   : integer;
                                    offset  : integer;
                                var actual  : integer *);

  begin
      ecode := E_NOT_IMPLEMENTED;
  end{proc Write_Attributes};






(*$IFC DEBUG2*)
(*$S fs5 *)
procedure FINDMONADR (var error : integer; vol : integer;
                      fname : e_name; var fstart, flen : integer) ;

{**************************************}
{ Find the start address and length of a monitor file (in blocks). }
{**************************************}


const
   MAXDIR = 77;       (*MAX NUMBER OF ENTRIES IN A DIRECTORY*)
   VIDLENG = 7;       (*NUMBER OF CHARS IN A VOLUME ID*)
   TIDLENG = 15;      (*NUMBER OF CHARS IN TITLE ID*)
   FBLKSIZE = 512;    (*STANDARD DISK BLOCK LENGTH*)
   fsui_base = 1200;
   dir_blk = 2;
   dir_leng = 4;

type
   DATEREC = PACKED RECORD
               YEAR: 0..100;          (*100 IS TEMP DISK FILE FLAG*)
               DAY: 0..31;            (*DAY OF MONTH*)
               MONTH: 0..12;          (*0 IMPLIES DATE NOT MEANINGFUL*)
             END (*DATEREC*) ;

                                         (*VOLUME TABLES*)
   VID = STRING[VIDLENG];

                                         (*DISK DIRECTORIES*)
   DIRRANGE = 0..MAXDIR;
   TID = STRING[TIDLENG];
   FILEKIND = (UNTYPEDFILE,XDSKFILE,CODEFILE,TEXTFILE,
               INFOFILE,DATAFILE,GRAFFILE,FOTOFILE,SECUREDIR);

   DIRENTRY = PACKED RECORD
                DFIRSTBLK: INTEGER;           (*FIRST PHYSICAL DISK ADDR*)
                DLASTBLK: INTEGER;            (*POINTS AT BLOCK FOLLOWING*)
                STATUS : BOOLEAN;             (*for FILER wildcards*)
                FILLER1 : 0..1024;            (*for downward compatibility*)
                CASE DFKIND: FILEKIND OF
                  SECUREDIR,
                  UNTYPEDFILE: (*ONLY IN DIR[0]...VOLUME INFO*)
                     (DVID: VID;              (*NAME OF DISK VOLUME*)
                      DEOVBLK: INTEGER;       (*LASTBLK OF VOLUME*)
                      DNUMFILES: INTEGER;     (*NUM FILES IN DIR*)
                      DLOADTIME: INTEGER;     (*TIME OF LAST ACCESS*)
                      DLASTBOOT: DATEREC);    (*MOST RECENT DATE SETTING*)
                  XDSKFILE,CODEFILE,TEXTFILE,INFOFILE,
                  DATAFILE,GRAFFILE,FOTOFILE:
                     (DTID: TID;              (*TITLE OF FILE*)
                      DLASTBYTE: 1..FBLKSIZE; (*NUM BYTES IN LAST BLOCK*)
                      DACCESS: DATEREC)       (*LAST MODIFICATION DATE*)
              END (*DIRENTRY*) ;

   DIRECTORY = ARRAY [DIRRANGE] OF DIRENTRY;

var
   actual : longint;
   i : integer;
   dir_index : integer;
   mydir : ^directory;
   numbfiles : integer;
   scr_space : array[0..2047] of byte;
   (*$IFC OS15*)
   p_extconfig: ^ext_diskconfig;
   (*$ENDC*)

begin
   error := 0;  {start out optimistic}

   if (vol<5) or (vol>20) then
      begin
         error := fsui_base+0;         {illegal volume}
         EXIT(FINDMONADR);
      end;

   if (fname='') then
      begin
         error := fsui_base+1;         {blank name is illegal}
         EXIT(FINDMONADR);
      end;

   mydir := @scr_space[0];

   {verify volume next}

   LISAIO(error, vol, ord4(mydir), dir_blk, dir_leng, actual,
                        without_header, nil, readop);

   if error>0 then EXIT(FINDMONADR);   {any sort of IO error}


   numbfiles := mydir^[0].dnumfiles;

   if (mydir^[0].dlastblk<>6) or (numbfiles>77) then
      begin
         error := fsui_base+3;                  {not a real directory}
         EXIT(FINDMONADR);
      end;

   {verify file existence here}
     UPSHIFT(@fname);
     dir_index := 0;
     for i := 1 to numbfiles do
        begin
           if mydir^[i].dtid=fname then
              dir_index := i;
        end; {of searching directory}

     if dir_index=0 then
        begin
           error := fsui_base+4;               {file not found}
           EXIT(FINDMONADR);
        end;

     with mydir^[dir_index] do
        begin
           fstart := dfirstblk;
           flen := dlastblk - dfirstblk;
        end; {of with directory entry for fname}

     with configinfo[vol]^ do
        begin
           (*$IFC OS15*)
           p_extconfig:=pointer(ext_addr);
           with p_extconfig^ do
           (*$ENDC*)
           if ( (strt_blok+num_bloks) <= (fstart+flen) ) then
              error := fsui_base+3;   {a second sanity check for directory contents}
        end;

end; {of findmonadr}




(*$S fs5 *)
procedure PFTP{var error1, error2: integer; srcvol: integer;
                filename, lfilename: pathname; delete_if_exists: boolean};

{**************************************}
{ Programmable FTP interface:          }
{**************************************}

const
   fsui_base = 1200;
   blocks = 20;
   maxbuf = 10239;     (* (512*blocks)-1 *)
   dont_replace = false;
   replace = true;

var
   actual : longint;
   refnum : integer;
   blockcount : integer;
   databuf : array [0..maxbuf] of byte;
   newlisafile : boolean;
   starts_at, length : integer;
   access : mset;
begin
   error1 := 0;  {start out optimistic}
   error2 := 0;

   FINDMONADR (error1, srcvol, filename, starts_at, length);
   if error1>0 then EXIT(PFTP);        {any sort of UCSD error};

   newlisafile := true;
   MAKE_FILE (error2, lfilename, 0);   (* create the new file *)
   if (error2=890) and delete_if_exists then
      begin
         newlisafile := false;
         error2 := 0;
      end
   else
      if error2>0 then EXIT(PFTP);

  (* open the Lisa file to transfer into     *)

   access := [dwrite];
   OPEN (error2, lfilename, refnum, access);
   if error2 > 0 then EXIT(PFTP);

   (*  read UCSD file and write to Lisa file until end of file   *)
   repeat
      if blocks>length then blockcount := length
      else blockcount := blocks;
      length := length - blockcount;
      LISAIO(error1, srcvol, ord4(@databuf), starts_at, blockcount, actual,
                        without_header, nil, readop);
      if error1 > 0 then EXIT(PFTP);

      if blockcount > 0 then
      begin
        actual := 0;
        write_data (error2, refnum, ord(@databuf), 512*blockcount,
                                       actual, sequential, 0);
        if error2 > 0 then EXIT(PFTP)
        else if (actual <> (512*blockcount) ) then
                begin
                   error2 := fsui_base+2;  {didnt write as much as expected}
                   EXIT(PFTP);
                end;
      end;
      starts_at := starts_at + blockcount;
    until length=0;


    (*  close Lisa file   *)
    (*  if writing to an old file, truncate it to the current size, then close it *)

    if not newlisafile (* was an old file *) then TRUNCATE (error2, refnum);
    if (error2<>982) and (error2>0) then EXIT(PFTP);

    CLOSE_OBJECT (error2, refnum);
    if error2 > 0 then EXIT(PFTP);

end; {of PFTP}




(*$S fs5 *)
procedure FTP;

{**************************************}
{  Good old interactive file transfer utility. }
{**************************************}

label 2;
const
   dont_replace = false;
   replace = true;
var
   ans : string [1];
   vol : integer;
   srcname, dstname : pathname;
   error1, error2 : integer;
begin
   writeln;
   writeln('Welcome to the (Internal) File Transfer Procedure');
  repeat
     writeln;
     writeln('The source file to transfer is specified in two parts, first the');
     writeln('number of the UCSD volume, and then the file name in that volume:');
     writeln;
     writeln('  Which volume number has the UCSD file?');
     writeln('    (answer with a pure number, not with ''#'' or '':'') ');
     writeln('    ( 0 can be used to leave FTP)');
     write('  ');
     readln(vol);
     if (vol=0) then EXIT(FTP);
     if (vol<5) or (vol>20) then
        begin
           writeln('illegal volume');
           goto 2;
        end;

     repeat
        writeln;
        writeln('  UCSD filename within that volume?');
        writeln('    (15 char max, please)');
        writeln('    (CR can be used to leave FTP)');
        write('  ');
        readln(srcname);
        if (srcname='') then EXIT(FTP);
        if LENGTH(srcname) > 15 then writeln('UCSD filename is too long');
     until LENGTH(srcname) <= 15;

      (*  find out the destination file to transfer to in the Lisa file system  *)
     repeat
        writeln;
        writeln('  What Lisa file to transfer into?  ');
        writeln('    (enter CR to inherit the same name)');
        writeln('    (enter ''QUIT'' to avoid the file transfer)');
        write('  ');
        readln (dstname);
        if (dstname='quit') or (dstname='QUIT') then goto 2;
        if length (dstname) > 64 then writeln ('Lisa filename is too long.');
     until length (dstname) <= 64;

     if dstname = '' then
        begin
           dstname := srcname;
           writeln ('OK, I''ll use the filename ''',dstname,'''.');
        end;

     PFTP(error1, error2, vol, srcname, dstname, dont_replace);

     if error2 = 890 then
        begin     (* file already exists, does the user want to write over it? *)
          writeln;
          write ('Lisa file ',dstname,' already exists.  Do you want to replace it?  ');
          readln (ans);
          if (ans='y') or (ans='Y') then
             PFTP(error1, error2, vol, srcname, dstname, replace);
        end;

     if error1 > 0 then
        begin
          writeln ('Error ',error1:6,' with UCSD vol ',vol,', file ',srcname,'.');
          goto 2;
        end;

     if error2 > 0 then
        begin
          writeln ('Error ',error2:6,' with lisa file ',dstname,'.');
          goto 2;
        end;

     writeln;
     writeln('Closed lisa file named ',dstname,'.');

  2:  {route to repeating the master loop}
     writeln;

  until false;  {all exits are done explicitly}


end;  {of FTP}

(*$ENDC*)  {of debug2}








{***************************START OF COMMENTED-OUT SECTION************************
procedure TEMPLATE (*var ecode:error;*);


label 1;

const parmbytes =  12;    (* calculated by hand for each procedure *)
      perrbase = 200;

var devnum : integer;

begin


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('TEMPLATE:  request to');
  end;
(*$ENDC*)

  ecode := 0;

1:

  if (ecode > 0) and (ecode < 100) then
                                  ecode := EXTERRBASE + UIERRBASE + PERRBASE + ecode;


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('TEMPLATE:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;   (* of procedure TEMPLATE *)
***************************END OF COMMENTED-OUT SECTION***************************}
ÿ