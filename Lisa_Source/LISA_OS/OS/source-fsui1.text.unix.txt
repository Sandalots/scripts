
(*********************************************************************************)
(*                                                                               *)
(*  (c) copyright 1983, 1984  Apple Computer Inc.                                *)
(*                                                                               *)
(*********************************************************************************)


{
Table of Contents of this module:

- 1.  LEFT_JUSTIFY_STRING
- 2.  MAP_DEV_NAME
- 3.  PARSE_PATHNAME
- 4.  FS_MOUNT
- 5.  FS_UNMOUNT
  6.  MAKE_FILE
  7.  MAKE_PIPE
# 8.  MAKE_CATALOG
# 9.  MAKE_LINK
 10.  KILL_OBJECT
 11.  UNKILL_FILE
 12.  OPEN
 13.  CLOSE_OBJECT
 14.  READ_DATA
 15.  WRITE_DATA

Note:  - indicates not callable from applications environment.
       # indicates an interface that has been removed

}



  {$S fs1 }
  function map_dev_name (* var name : e_name ) : integer *);

  label 1;

  const
       LISA1 = 0;
       PEPSI = 1;
       LIGHT = 2;

  var
       i    : integer;
       fval : integer;
       uc_uname   : e_name;
       uc_devname : e_name;
       trialName  : e_name;
       loclName   : e_name;
       ptrDCB     : DCBptr;


      procedure  Alias ( var name : e_name);

        procedure  Match ( pattern : e_name );

        var
             numc : char;
             endi : integer;

        begin
            if length(loclName) > 0 then
            begin
              if pos(pattern, loclName) <> 1 then exit(Alias);
              endi := length(pattern)+1;
              numc := loclName[endi];
              if (numc < '0') or (numc > '9') then exit(Alias);
              trialName := concat(trialName, '#?');
              trialName[length(trialName)] := numc;
              delete(loclName, 1, endi);
            end{if};
        end{proc Match};

      begin
               if name = 'RS232A'  then name := '#10#1'
          else if name = 'RS232B'  then name := '#10#2'
          else if name = 'UPPER'   then
          begin
               if iomodel <> LISA1 then name := '#12'     (* built-in widget *)
                                   else name := '#14#1';  (* upper twiggy    *)
          end
          else if name = 'LOWER'   then
          begin
              if iomodel <> LISA1  then name := '#13'    (* lower sony *)
                                   else name := '#14#2'; (* lower twiggy *)
          end
          else if name = 'PARAPORT' then
          begin
              if iomodel <> PEPSI  then name := '#11'    (* parallel port   *)
                                   else name := '#12';   (* built-in widget *)
          end
          else if name = 'ALTCONSOLE'  then name := '#15#1'
          else if name = 'MAINCONSOLE' then name := '#15#2'
          else
          begin
            loclName := name;
            trialName := '';
            Match('SLOT');
            Match('CHAN');
            Match('DEV');
            if length(loclName) > 0 then exit(Alias);
            name := trialName;  (* commit to alias name *)
          end{if};
      end{proc Alias};

  begin
      if length(name) > max_ename then
      begin
        fval := -1;  (* device name is bad, return an invalid device number *)
        goto 1;
      end;

      (* Upper-case local copy of device name *)
      uc_uname := name;
      upshift (@uc_uname);

      (* Match boot device wildcard name *)
      if uc_uname = '#BOOT' then
      begin
        fval := bootdev;
        goto 1;
      end{if};

      (* Map common mneumonic device names into standard numeric device names *)
      Alias(uc_uname);

      i := 0;
      repeat
        ptrDCB := mounttable[i];
        if ptrDCB <> pointer(BADPTR1) then
        begin
          uc_devname := ptrDCB^.name;
          upshift(@uc_devname);
          if uc_uname = uc_devname then
          begin
            fval := i;
            goto 1;
          end{if};
        end;
        i := i + 1;
      until i > MAXDEV;

      i := 0;
      repeat
        uc_devname := configinfo[i]^.devname;
        upshift (@uc_devname);
        if uc_uname = uc_devname then
        begin
          fval := i;
          goto 1;
        end{if};
        i := i + 1;
      until i > MAXDEV;

      fval := -1;  (* couldn't match the device name *)

  1:
      map_dev_name := fval;

  end{proc map_dev_name};





  {$S fs1 }
  procedure DecompPath ( var ecode   : integer;
                         var path    : pathname;
                         var device  : integer;
                         var parID   : NodeIdent;
                         var volPath : pathname );

  var
       ptrSyslocal : slocal_ptr;
       volName     : e_name;
       i           : integer;
       delim       : char;
       ptrDCB      : DCBptr;

  begin
      ptrSyslocal := pointer(b_syslocal_ptr);
      device := -1;
      parID := -1;
      volPath := path;
      ecode := 0;

      {
      if path[1] = '>' then
      begin
        (* Used to support metacharacter for working device *)
        delete(volPath, 1, 1);
        device := ptrSyslocal^.working_dev;
        parID := ROOT_NID;
      end
      else
      }
      i := 1;
      Gobble(path, i, volName, delim);
      case delim of
        '-':  begin
                device := map_dev_name(volName);
                parID := ROOT_NID;
                delete(volPath, 1, i);
              end;
        ' ',
        '+':  begin
                device := ptrSyslocal^.working_dev;
                parID := ptrSyslocal^.workDirID;
              end;
      end{case};

      if device >= 0 then
      begin
        (*
         *  If the device is not mounted, then an error is returned, but
         *  the returned device number is still good.
         *)
        ptrDCB := mounttable[device];
        if ptrDCB = pointer(BADPTR1) then
          ecode := E_NOT_MOUNTED
        else if ptrDCB^.status <> fsmounted then
          ecode := E_NOT_MOUNTED;
      end
      else
        (* Couldn't find the device *)
        ecode := E_NO_DEVICE;

      (*
       *  For flat catalog:
       *    check length of volPath.
       *    check for '-'s in volPath.
       *)

{$IFC FSUIBUG}
    if trace(FS,99) then
      writeln('  "',path,'"  dev = ',device:1,'  parID = ',
               parID:1,'  "',volPath,'"  err = ',ecode:1);
{$ENDC}

  end{proc DecompPath};



  (*  Simulates behavior of the old SplitPathname *)
  procedure SplitPathname (* var ecode   : integer;
                             var path    : pathname;
                             var device  : integer;
                             var volPath : pathname *);
  var parID : NodeIdent;

  begin
      DecompPath(ecode, path, device, parID, volPath);
  end{proc SplitPathname};


(* Assumes protection by DCB.volSem *)
procedure  ReadDir (     device  : integer;
                         parID   : NodeIdent;
                     var volPath : pathname;
                     var DirRec  : ObjRec;
                     var CatRec  : Centry;
                     var ecode   : integer );

label  1;

var
     name     : e_name;
     id       : integer;
     size     : integer;
     ptrBuf   : buffer_ptr;
     found    : boolean;
     ptrEntry : entry_ptr;
     key      : RecKey;

begin
    DirRec.eType := fileentry;
    if flat_catalog(device) then
    begin
      name := volPath;
      Lookup_by_Ename(ecode, name, rootptr[device], CatRec);
    end
    else
    begin
      (* Find the directory *)
      PathSearch(mounttable[device], parID, volPath, @key, ptrBuf, ptrEntry, found, ecode);
      if ecode > 0 then goto 1;
      if not found then
      begin
        ecode := 888;  (* emulate LOOKUP_BY_ENAME *)
        FreeBuf(ptrBuf);
        goto 1;
      end{if};

      (* Return the directory record *)
      moveleft(ptrEntry^, DirRec, sizeof(ObjectRec));

      FreeBuf(ptrBuf);

      (* Return goodies in CatRec too *)
      DecompKey(@DirRec.key, @CatRec.name, id);
      CatRec.cetype := DirRec.eType;
      CatRec.sfile := DirRec.sfile;
    end{if};

1:  (* exit *)
end;



(*
 *  Pathname cannot refer to a directory object
 *)
(*$S fs1 *)
procedure parse_pathname (* var ecode  : integer;
                            var p      : pathname;
                            var device : integer;
                            var sfile  : integer *);

var
     ptrSysloc : slocal_ptr;
     volPath   : pathname;
     DirRec    : ObjRec;
     CatRec    : centry;
     parID     : NodeIdent;

begin
    sfile := -1;
    ptrSysloc := pointer(b_syslocal_ptr);
    DecompPath(ecode, p, device, parID, volPath);
    if ecode > 0 then exit(parse_pathname);
    if not configinfo[device]^.blockstructured then
    begin
      ecode := E1_NOT_BLOCK_DEV;
      exit(parse_pathname);
    end{if};
    ReadDir(device, parID, volPath, DirRec, CatRec, ecode);
    if (ecode = E_NOT_FOUND) or (CatRec.cetype <> fileentry) then
      ecode := E_NO_ENTRY;
    if ecode > 0 then exit(parse_pathname);
    sfile := CatRec.sfile;
end;




  {$S fs3 }
  procedure fs_mount (* var ecode  : error;
                            device : integer *);

  label  1;

  var
      ptrUbdDCB  : DCBptr;      (* boot disk's dcb pointer during ubd *)
      ptrDCB     : DCBptr;
      ptrBuf     : buffer_ptr;
      wcode      : integer;
      must_unmnt : boolean;

  begin
      ecode := 0;
      must_unmnt := FALSE;

      (* Mount the device *)
      real_mount(ecode, device);
      if ecode > 0 then exit(FS_Mount);
      must_unmnt := TRUE;
      wcode := ecode;   (* save warning from real_mount *)

      ptrDCB := mounttable[device];

      if configinfo[device]^.blockstructured then
      begin
        (****************************)
        (*  Block-structured Device *)
        (****************************)
        with ptrDCB^.MDDFdata^ do
        begin
          if vol_scavenged then wcode := W_SCAVENGED;
          if ptrDCB^.left_mounted then wcode := W_LEFT_OPEN;

          if mountinfo = temp_unmounted then
          begin
            (*
             *  The volume being mounted is a boot-volume that has been
             *  temporarily unmounted from some Lisa.  Temporarily unmounted
             *  boot volumes should be remounted only through the FS_Utilities
             *  RBD facility which glues everything back together properly.
             *)
            if boot_dcbptr <> BADPTR1 then
            begin
              (*
               *  The boot volume of this Lisa is temporarily unmounted.  Return
               *  a specific error code if the volume being mounted is actually
               *  this machine's temporarily unmounted boot volume.
               *)
              ptrUbdDCB := pointer(boot_dcbptr); (* unmounted boot device's DCB *)
              if (overmount_stamp.a = ptrUbdDCB^.MDDFdata^.overmount_stamp.a)
                                             and
                 (overmount_stamp.b = ptrUbdDCB^.MDDFdata^.overmount_stamp.b)
                                             and
                 (mountinfo = ptrUbdDCB^.MDDFdata^.mountinfo)  then
              begin
                ecode := E_TBOOT_MOUNT;
                goto 1;
              end{if};
            end
            else
              wcode := W_FOREIGN_MOUNT;
          end{if};


          (* Normal mount should not change mountinfo or overmount_stamp so that the
             temp-unmounted boot disk can be re-mounted. *)
          (* But if the disk is used for booting, it should not be re-mountable,
             since booting will cause the filer process's system segments to change
             such that they do not match with the memory copies at the ubd time.
             This could happen if the boot disk is from another machine.
             This means mount at boot time should change mountinfo and
             overmount_stamp. Or allow boot of boot disk from the same machine, but
             disallow boot of boot disk from another machine, more restriction than
             theft protection. This is waiting for Filer to gain more experience to
             specify the right way. *)

          if flat_catalog(device) then
          begin
            open_sfile(ecode, rootsnum, device, rootptr[device]);
            (* normal occurrence is OS closed rootcat *)
            if ecode = W_OS_CLOSED then ecode := 0;
          end
          else
          begin
            (* Pre-fetch the root node of the directory tree *)
            if root_page <> REDLIGHT then
            begin
              GetNode(ptrDCB, root_page, TRUE, ptrBuf, ecode);
              if ecode <= 0 then FreeBuf(ptrBuf);
            end{if};
          end{if};
          if ecode > 0 then goto 1;
        end{with};
      end{if};

      ptrDCB^.status := fsmounted;

      (* Everything went OK *)
      must_unmnt := FALSE;

      if wcode <> 0 then ecode := wcode;

  1:  (* exit *)

      if must_unmnt then real_unmount(wcode, device);

  end{proc FS_Mount};











  {$S fs3 }
  procedure fs_unmount (* var ecode  : error;
                              device : integer *);

  label 1;

  var
      tempecode : error;
      openlptr, oldlptr, endptr : ^openlist;
      relopenlist : boolean;
      nil_ptr : SFCB_ptr;
      ptrDCB : DCBptr;

  begin
      ptrDCB := mounttable[device];
      if ptrDCB = pointer(BADPTR1) then goto 1;

      if ptrDCB^.status <> fsmounted then
      begin
        ecode := E1_NO_DEV_MOUNTED;
        goto 1;
      end{if};

      if configinfo[device]^.blockstructured then
      begin
        (* Short-circuit a user-level unmount attempt against the boot volume *)
        (* only do this if the boot device is mounted (i.e., not temp unmounted) *)
        if (device = bootdev) and (boot_dcbptr = BADPTR1) then
        begin
          ecode := E_VOL_IN_USE;
          goto 1;
        end{if};

        wait_sem(ptrDCB^.volSem, []); (* wait for pathname intfcs to finish *)
        signal_sem(ptrDCB^.volSem);
        wait_sem(ptrDCB^.semio, []); (* wait for open_sfile to complete *)
        signal_sem(ptrDCB^.semio);

        (* let process mgmt unload all program files residing on this volume *)
        nil_ptr := NIL;
        Free_LPs(nil_ptr, device);

        if flat_catalog(device) then
        begin
          close_sfile(ecode, rootptr[device]);  (* close root catalog *)
          if ecode > 0 then goto 1;  (* rootcat damaged:  refuse to unmount, and let *)
        end{if};
      end{if};

      (* the root catalog is now definitely closed *)
      ptrDCB^.status := realmounted;
                                          (* save the pointers to open list chain *)
      openlptr := pointer(ptrDCB^.openchain.fwd_link + b_sysglobal_ptr);
      endptr := pointer(ptrDCB^.openchain.bkwd_link + b_sysglobal_ptr);

      if (openlptr <> @ptrDCB^.openchain) then
        relopenlist := TRUE
      else
        relopenlist := false;

      real_unmount(ecode, device);
      if ecode = E_VOL_IN_USE then  (* something still open on device *)
      begin
        tempecode := 0;
        if (configinfo[device]^.blockstructured) then
        if flat_catalog(device) then
          open_sfile(tempecode, ptrDCB^.MDDFdata^.rootsnum, device, rootptr[device]);
        if tempecode <= 0 then ptrDCB^.status := fsmounted;
      end{if};

      if ecode <= 0 then
      begin                  (* if successful unmount, release open list blocks *)
        if relopenlist then
        begin
          while(openlptr <> endptr) do
          begin
            oldlptr := openlptr;
                                                  (* go to next open list block *)
            openlptr := pointer (openlptr^.head.fwd_link + b_sysglobal_ptr);
            relspace(ord(oldlptr), b_sysglobal_ptr);
          end{while};
                                                  (* the last block in chain *)
          relspace (ord (openlptr), b_sysglobal_ptr);
        end{if};
      end{if};

  1:  (* exit *)

  end{proc FS_Unmount};




  {$S fs2 }
  procedure  Make_Object ( var ecode     : error;
                           var path      : pathname;
                               labelSize : integer;
                               passwd    : e_name;  (* copied in *)
                               objKind   : entrytype );

  var
       device  : integer;
       volPath : pathname;
       parID   : NodeIdent;

  begin
      ecode := 0;
      DecompPath(ecode, path, device, parID, volPath);

      if (ecode > 0) or (length(volPath) = 0) then
        ecode := E1_PATH_INVALID
      else if (labelSize < 0) or (labelSize > max_label_size) then
        ecode := E1_LABEL_SIZE
      else if configinfo[device]^.blockstructured then
        make_entry (ecode, device, parID, volPath, objKind, passwd);
  end{proc Make_Object};








  {$S fs2 }
  procedure Make_File (* var ecode      : error;
                         var path       : pathname;
                             label_size : integer*);

  begin
  {$IFC DEBUG2}
    if trace(FS, 70) then
      writeln('MAKE_FILE  ',path,' label size = ',label_size);
  {$ENDC}

      Make_Object(ecode, path, label_size, '', fileentry);

  {$IFC DEBUG2}
    if trace(FS, 70) then
      writeln('MAKE_FILE  exiting error = ',ecode);
  {$ENDC}
  end{proc Make_File};




  {$S fs3 }
  procedure Make_Secure (* var ecode  : integer;
                           var path   : pathname;
                           var passwd : e_name *);

  begin
      Make_Object(ecode, path, 0, passwd, fileentry);
  end{proc Make_Secure};






  {$S fs5 }
  procedure Make_Pipe (* var ecode      : error;
                         var path       : pathname;
                             label_size : integer *);
  begin
      ecode := E_NOT_IMPLEMENTED;
  end{proc Make_Pipe};

  {$S fs5 }
  procedure Make_Link (* var ecode      : error;
                         var path       : pathname;
                         var ref        : pathname;
                             label_size : integer *);
  begin
      ecode := E_NOT_IMPLEMENTED;
  end{proc Make_Link};





  {$S fs5 }
  procedure Make_Catalog (* var ecode      : error;
                            var path       : pathname;
                                label_size : integer *);

  begin
  {$IFC DEBUG2}
      if trace (FS, 70) then
        writeln ('MAKE_CATALOG  ',path);
  {$ENDC}

      Make_Object(ecode, path, label_size, '', direntry);

  {$IFC DEBUG2}
      if trace (FS, 70) then
        writeln ('MAKE_CATALOG  exit error = ',ecode);
  {$ENDC}
  end{proc Make_Catalog};





(*$S fs2 *)
procedure KILL_OBJECT (*var ecode:error; var path:pathname*);

var volPath : pathname;
    devnum  : integer;
    parID   : NodeIdent;

begin

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('KILL_OBJECT:  request to kill object named ',path);
  end;
(*$ENDC*)

  ecode := 0;

  DecompPath(ecode, path, devnum, parID, volPath);

  if (ecode > 0) or (length(volPath) = 0) then
    ecode := E2_PATH_INVALID
  else if configinfo [devnum]^.blockstructured then
    kill_entry (ecode, devnum, parID, volPath, '' (* no password *));

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('KILL_OBJECT:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;   (* of procedure KILL_OBJECT *)




{$S fs3}
procedure Kill_Secure (* var ecode  : integer;
                         var path   : pathname;
                         var passwd : e_name *);

var
     device  : integer;
     volPath : pathname;
     parID   : NodeIdent;

begin
    ecode := 0;
    DecompPath(ecode, path, device, parID, volPath);

    if (ecode > 0) or (length(volPath) = 0) then
      ecode := E1_PATH_INVALID
    else if configinfo[device]^.blockstructured then
      kill_entry(ecode, device, parID, volPath, passwd);
end{proc Kill_Secure};





(*$S fs3 *)
procedure  UNKILL_FILE (*var ecode : error; refnum : integer; var new_name : e_name*);

label  1, 2;

var
   addrRefDB  : absptr;
   ptrRefDB   : fref_ptr;
   ptrFCB     : sfcb_ptr;
   devnum     : integer;
   CatEntry   : centry;
   HintEntry  : hentry;
   actual     : longint;
   locl_ecode : error;
   savepage   : longint;
   saveoffset : integer;
   path       : pathname;
   NewRec     : ObjRec;
   ptrBuf     : buffer_ptr;
   found      : boolean;
   nullName   : e_name;
   ptrDCB     : DCBptr;

begin

   (*$IFC DEBUG2*)
      if trace(FS, 70) then
      begin
         writeln('UNKILL_FILE:  request to unkill refnum ',refnum,
                 'with name ',new_name);
      end;
   (*$ENDC*)

   ecode := 0;
   nullName := '';


   (* check refnum argument *)

   chk_refnum(ecode, refnum, frefdb, addrRefDB);
   if ecode > 0 then goto 1;

   ptrRefDB := pointer(addrRefDB);
   ptrFCB := ptrRefDB^.fcbptr;
   devnum := ptrRefDB^.refdb_devnum;

   (* check entry name argument *)

   if (length(new_name) > max_ename) or
      (not configinfo[devnum]^.blockstructured) then
   begin
      ecode := E1_NAME_INVALID;
      goto 1;
   end;

   if pos('-', new_name) <> 0 then
   begin
      ecode := E1_NAME_INVALID;
      goto 1;
   end;

   (*
    *  check that
    *              1.  the file is really a file.
    *              2.  the file is in the killed state.
    *)

   with ptrFCB^ do
   begin
      if ftype <> USERFILE then
      begin
         ecode := E_NOT_A_FILE;   (* object is not a file *)
         goto 1;
      end;

      if not kswitch then
      begin
         ecode := E_NOT_KILLED;  (* object is not killed *)
         goto 1;
      end;
   end;



   (*
    *  exclude entry into other file system interface procedures
    *  that would tamper with this device.
    *)
   ptrDCB := mounttable[devnum];
   wait_sem(ptrDCB^.volSem, []);

   (* see if the name is already in the catalog *)
   if flat_catalog(devnum) then
   begin
     lookup_by_ename(ecode, new_name, rootptr[devnum], CatEntry);
     with rootptr[devnum]^ do
     begin
       savepage := curpage;
       saveoffset := curoffset;
     end;

     if ecode = 0 then
     begin
        ecode := E_ENTRY_EXISTS;
        goto 2;
     end;

     if (ecode <> E_NOT_FOUND) or (CatEntry.cetype <> emptyentry) then
     begin
        ecode := E_CATALOG_FULL;   (* error reading catalog or *)
        goto 2;                    (* no empty entries left    *)
     end;
   end
   else
   begin
     (* Make sure the parent directory still exists *)
     MakeKey(ptrFCB^.parID, @nullName, @NewRec);
     Search(ptrDCB, @NewRec, ptrBuf, found, ecode);
     if ecode > 0 then goto 2;
     FreeBuf(ptrBuf);
     if not found then
     begin
       ecode := E_DIR_GONE;
       goto 2;
     end{if};

     (* Directory exists, now see if the new name collides *)
     MakeKey(ptrFCB^.parID, @new_name, @NewRec);
     Search(ptrDCB, @NewRec, ptrBuf, found, ecode);
     if ecode > 0 then goto 2;
     if found then
     begin
       ecode := E_ENTRY_EXISTS;
       FreeBuf(ptrBuf);
       goto 2;
     end{if};
   end{if};
   (* Holding the buffer *)

   ecode := 0;

   (* clear the killed bit in the FCB and the hints *)

   with ptrFCB^ do
   begin
      kswitch := false;   (* clear in FCB *)
      fname := new_name;

      hentry_io(ecode, devnum, sent.hintaddr, HintEntry, readop);
      if ecode > 0 then goto 2;  (* couldn't read hint entry *)

      HintEntry.killed := false;   (* clear on device *)
      HintEntry.name := new_name;

      hentry_io(ecode, devnum, sent.hintaddr, HintEntry, writeop);
      if ecode > 0 then goto 2;
   end;


   (* create the new catalog entry *)

   if flat_catalog(devnum) then
   begin
     with CatEntry do
     begin
        name := new_name;
        sfile := ptrFCB^.sfilenum;
        cetype := fileentry;
        readpage := 0;
        readoffset := 0;
        writepage := 0;
        writeoffset := 0;
     end;


     (* write the new catalog entry *)

     with rootptr[devnum]^ do
        fileio(ecode, rootptr[devnum], ord(@CatEntry), sizeof(centry), actual,
               savepage, saveoffset, writeop);
   end
   else
   begin
     (* build the record to be inserted *)
     with NewRec, ptrFCB^ do
     begin
       eType := fileentry;
       sfile := sfilenum;
       fileDTC := DTC;
       fileDTM := DTM;
       size := sent.filesize;
       physSize := phys_size;
       fsOvrhd := fsOverhead;
       (* Wonder what kind of code this generates *)
       flags[fMaster] := sfcb_master;
       flags[fProtect] := sfcb_protected;
       flags[fSafety] := sswitch;
       flags[fCrashed] := file_still_open;
       flags[fScavenged] := scav_flag;
       flags[fClosed] := OS_close_flag;
     end{with};
     Insert(mounttable[devnum], @NewRec, sizeof(ObjectRec), ptrBuf, ecode);
   end;


   if ecode > 0 then    (* catalog entry didn't make it *)
   begin
      (* Back-out of unkill *)

      with ptrFCB^ do
      begin
         kswitch := true;
         HintEntry.killed := true;

         hentry_io(locl_ecode, devnum, sent.hintaddr, HintEntry, writeop);
      end;
   end;



2:
   signal_sem(mounttable[devnum]^.volSem);

1:

   (*$IFC DEBUG2*)
      if trace(FS, 70) then
      begin
         writeln('UNKILL_FILE:  exiting with error code of ',ecode);
      end;
   (*$ENDC*)

end;  (* of procedure UNKILL_FILE *)







(*$S fs1 *)
function is_global_refnum (refnum : integer) : boolean;
begin
  is_global_refnum := ((refnum >= beg_glorefnum) and (refnum <= max_glorefnum));
end;






(*$S fs3 *)
procedure GET_OPEN_LIST (* var ecode : integer; var devname : e_name;
                           var openinfo : openrec *);
                 (* get the first open object entry in the open list of a device,
                    to be called by FILER process only *)
label 1;
var
  device : integer;
  openlptr : ^openlist;
  continue : boolean;
  i : integer;

begin
(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('GET_OPEN_LIST:  request to get open list of device ', devname);
  end;
(*$ENDC*)

  ecode := 0;

  device := map_dev_name (devname);     (* find device number by requested name *)

  if device < 0 then
  begin
    ecode := E_DEV_INVALID;                          (* no such device or volume name *)
    goto 1;
  end;

  if mounttable [device] = pointer (badptr1) then      (* nothing mounted *)
  begin
    ecode := E2_NO_DEV_MOUNTED;
    goto 1;
  end
  else
    if mounttable [device]^.status <> fsmounted then   (* not fully mounted *)
    begin
      ecode := E2_NO_DEV_MOUNTED;
      goto 1;
    end;

  continue := true;
  openlptr := pointer (mounttable [device]^.openchain.fwd_link + b_sysglobal_ptr);
  while (openlptr <> @mounttable [device]^.openchain) and continue do
  begin
    i := 0;
    while i <= maxopenlist do
    with openlptr^, openentry [i] do
      if refnum <> null_refnum then        (* not an empty entry *)
      begin
        openinfo.procid := procid;
        openinfo.refnum := refnum;
        openinfo.refntype := refntype;
        openinfo.globalrefn := is_global_refnum (refnum);

        i := maxopenlist + 1;         (* to exit the loop *)
        continue := false;            (* no more search *)
      end
      else                      (* skip the empty entry *)
        i := i + 1;

    if continue then
      openlptr := pointer (openlptr^.head.fwd_link + b_sysglobal_ptr);
  end;   (* while *)

  if continue then              (* did not find an open file entry, all closed *)
    ecode := E_END_OPEN_LIST;

1:

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('GET_OPEN_LIST:  exiting with error code of ',ecode);
  end;
(*$ENDC*)
end;  (* procedure GET_OPEN_LIST *)








(*$S fs1 *)
procedure REG_OPEN_LIST (* var ecode : integer;
                           device, oldrefnum, newrefnum : integer;
                           newrntype : refnum_type *);

        (* It is to be called by OPEN_DATA_SEG and OPEN_EVENT_CHN to register an
           open refnum in the open list. The underlying fsrefnum should be passed
           as oldrefnum and ds or ec refnum as newrefnum. This procedure will find
           the corresponding entry and change it to newrefnum and new refnumtype.
           It is to be called by OPEN to add an entry in the open list. OPEN
           should pass 0 as oldrefnum and fs refnum as newrefnum.
           It is also to be called by CLOSE_OBJECT, CLOSE_DATA_SEG and
           CLOSE_EVENT_CHN to delete an entry from the open list. The corresponding
           fs, ds or ec refnum should be passed as oldrefnum and 0 as
           newrefnum. This procedure will mark the entry to be empty. *)
var
  openlptr, oldlptr : ^openlist;
  continue, allempty : boolean;
  i : integer;
  pcb_ptr : ptr_pcb;
  aptr : absptr;

begin
(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('REG_OPEN_LIST:  request to register open list of device ', device);
  end;
(*$ENDC*)

  ecode := 0;
  continue := true;
  pcb_ptr := pointer (c_pcb_ptr);
  openlptr := pointer (mounttable [device]^.openchain.fwd_link + b_sysglobal_ptr);
  while (openlptr <> @mounttable [device]^.openchain) and continue do
  begin
    allempty := true;           (* assuming all entries empty in this block *)
    i := 0;                     (* always search from the first entry *)
    while i <= maxopenlist do
    with openlptr^, openentry [i] do
    begin
      if (refnum = oldrefnum)                (* found an entry with same refnum*)
         and ((oldrefnum = null_refnum)      (* to add an entry *)
             or (is_global_refnum (refnum))  (* to change an global refnum entry *)
             or (procid = pcb_ptr^.glob_id)) (* or to change an local refnum entry
                                                - must be for the same process *)
      then
      begin
        procid := pcb_ptr^.glob_id;
        refnum := newrefnum;
        refntype := newrntype;
        if refnum <> null_refnum then         (* not empty entry *)
          allempty := false;

        if i< maxopenlist then allempty := false;
                 (* had not gone through all entries, so may not be all empty *)

        i := maxopenlist + 1;         (* to exit the loop *)
        continue := false;            (* no more search *)
      end
      else                      (* not found yet, try next entry in this block *)
      begin
        if refnum <> null_refnum then      (* not an empty entry *)
          allempty := false;
        i := i + 1;
      end;
    end;  (* while i loop *)

    oldlptr := openlptr;
    if continue then            (* go to next open list block *)
      openlptr := pointer (openlptr^.head.fwd_link + b_sysglobal_ptr);

    if allempty then      (* the current block has only empty entries, delete it *)
    begin
      dequeue (oldlptr^.head, b_sysglobal_ptr);
      relspace (ord (oldlptr), b_sysglobal_ptr);
    end;
  end;   (* while openlptr loop *)

  if continue then              (* did not find the entry *)
    if oldrefnum = null_refnum then   (* it is to add an entry, get another block *)
    begin
      if not getspace (sizeof (openlist), b_sysglobal_ptr, aptr) then
        ecode := E_OPENLIST_NOSPACE
      else
      begin
        openlptr := pointer (aptr);
        with openlptr^, openentry [0] do
        begin
          enqueue (head, mounttable [device]^.openchain, b_sysglobal_ptr);
          procid := pcb_ptr^.glob_id;
          refnum := newrefnum;
          refntype := newrntype;
          for i := 1 to maxopenlist do
            openentry [i].refnum := null_refnum;      (* init the open list block *)
        end;
      end;
    end
    else                        (* to change an entry, but did not find it *)
      ecode := E1_NOT_FOUND;

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('REG_OPEN_LIST:  exiting with error code of ', ecode);
  end;
(*$ENDC*)
end;  (* procedure REG_OPEN_LIST *)







(*$S fs1 *)
procedure GOPEN ( var ecode : error;
                   var path : pathname;
                 var refnum : integer;
                      manip : mset;
                 privileged : boolean;
                var allowed : boolean;
                    passwd  : e_name );

label 1, 2;

var volPath : pathname;
    openfcbptr : sfcb_ptr;
    refdbptr : fref_ptr;
    c : centry;
    openrefnum, devnum : integer;
    refdbaddr, sys_ptr : absptr;
    ac : accesses;
    c_syslocal_ptr : slocal_ptr;   (* current pointer to syslocal *)
    gref : boolean;
    loc_ecode : error;
    wcode : integer;
    DirRec : ObjRec;
    parID  : NodeIdent;

begin

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    write ('GOPEN:  request to open ',path,' with mode [');
    for ac := dread to global_refnum do
    begin
      if ac in manip then
      case ac of
        dread : write (' DREAD ');
        dwrite: write (' DWRITE ');
        append: write (' APPEND ');
        private:write (' PRIVATE ');
        global_refnum: write (' GLOBAL_REFNUM ');
      end; (* of case ac of *)
    end;
    write ('] ');
    if not privileged then write ('not ');
    writeln ('privileged.');
  end;
(*$ENDC*)



  ecode := 0;
  wcode := 0;
  refnum := -1;    (* in case of error later *)

  DecompPath(ecode, path, devnum, parID, volPath);

  if (ecode > 0) or (length(volPath) = 0) then
  begin
    ecode := E3_PATH_INVALID;
    goto 1;
  end;

  if configinfo [devnum]^.blockstructured then   (* block structured device *)
  begin
    wait_sem(mounttable[devnum]^.volSem, []);

    ReadDir(devnum, parID, volPath, DirRec, c, ecode);

    if ecode <= 0 then if c.cetype in [pipeentry, ecentry] then
    begin        (* pipes and event channels are no longer supported *)
      ecode := E_NOT_IMPLEMENTED;
      goto 2;
    end;

    if (ecode > 0) or (c.cetype <> fileentry) then
    begin     (* no such name, or entry is not a file *)
      ecode := E_NO_FILE;
      goto 2;
    end;

    if c.cetype = direntry then
    begin
      ecode := E_DIR_OP;
      goto 2;
    end{if};

    (* open the requested s-file *)
    open_sfile (ecode, c.sfile, devnum, openfcbptr);
    if ecode > 0 then goto 2;   (* couldn't open the file *)

    with openfcbptr^ do
    begin
      if private_in_use then
      begin   (* file or pipe is already opened privately *)
        close_sfile (ecode, openfcbptr);
        ecode := E1_OPEN_PRIVATE;
        goto 2;
      end
      else
      begin            (* check for theft protection *)
        allowed := true;         (* assume we can open the file, to start with *)
        if sfcb_protected then                   (* check if file is protected *)
        begin
          if not privileged then     (* it is, see if we are privileged or not *)
          begin
            close_sfile (ecode, openfcbptr);  (* not, don't allow the open *)
            ecode := E_PROTECTION;    (* can not open protected file *)
            allowed := false;
            goto 2;
          end
          else if not sfcb_master then   (* we are priv., see if it can run here *)
          begin
            if mid <> serial_no then     (* privileged violation ! ! ! ! ! *)
            begin
              allowed := false;   (* should not allow access to file *)
            end;
          end
          else  (* protected master *)
          begin
            (* there should be no protected masters on a copy volume *)
            if mounttable[devnum]^.MDDFdata^.tbt_copied then
              allowed := false;
          end;
        end;
      end;

      if (dread in manip) then nreaders := nreaders + 1;
      if (dwrite in manip) or (append in manip) then nwriters := nwriters + 1;

      if private in manip then
      begin
        if (nusers = 1) then private_in_use := true
        else
        begin
          if (dread in manip) then nreaders := nreaders - 1;
          if (dwrite in manip) or (append in manip) then nwriters := nwriters - 1;
          close_sfile (ecode, openfcbptr);   (* open for shared access by somebody *)
          ecode := E2_OPEN_PRIVATE;
          goto 2;
        end;
      end;

      (* Check for access restriction by password *)
      if not privileged then
      begin
        if openfcbptr^.password <> '' then
        begin
          (* the file is password protected *)
          crypt(passwd);  (* zaps the password that was passed *)
          if openfcbptr^.password <> passwd then
          begin
            (* the passwords do not match *)
            close_sfile(ecode, openfcbptr);
            ecode := E_PASSWORD;
            goto 2;
          end;
        end
        else    (* not password protected *)
          if passwd <> '' then
            wcode := W_NO_PASSWORD;  (* secure kill on a file w/ null password *)
      end;
    end;
2:
    signal_sem (mounttable [devnum]^.volSem);
    if (ecode > 0) then (* couldn't open the file *) goto 1;

  end   (* of blockstructured case *)
  else
  begin (* non-block-structured device being opened *)
    if mounttable [devnum]^.private then
    begin   (* device already opened for private access *)
      ecode := E1_OPEN_PRIVATE;
      goto 1;
    end;
    if (private in manip) and (mounttable [devnum]^.opencount > 0) then
    begin   (* request for private access, but already opened shared *)
      ecode := E2_OPEN_PRIVATE;
      goto 1;
    end;
    if private in manip then mounttable [devnum]^.private := true;
    mounttable [devnum]^.opencount := mounttable [devnum]^.opencount + 1;
  end;      (* of non-block-structured case *)


  (* get space for a fs_refdb *)

  gref := (global_refnum in manip);
        (* global refdb's are allocated in sysglobal *)
  if gref then sys_ptr := b_sysglobal_ptr else sys_ptr := b_syslocal_ptr;
  if not getspace (sizeof (fs_refdb), sys_ptr, refdbaddr) then
  begin        (* no space for a fs refdb *)
    if configinfo [devnum]^.blockstructured then   (* block structured device *)
    with openfcbptr^ do
    begin
      if (dread in manip) then nreaders := nreaders - 1;
      if (dwrite in manip) or (append in manip) then nwriters := nwriters - 1;
      if (private in manip) then private_in_use := false;
      close_sfile (ecode, openfcbptr);
      ecode := E_REFDB_NOSPACE;
      goto 1;
    end
    else
    begin  (* non-block-structured case *)
      mounttable [devnum]^.opencount := mounttable [devnum]^.opencount - 1;
      if (private in manip) then mounttable [devnum]^.private := false;
    end;
  end;

  refdbptr := pointer (refdbaddr);   (* set up pointer to the fs_refdb *)
  refdbptr^.head.kind := frefdb;     (* this is a file system refdb    *)


  (* get an available refnum for this opening of this file *)

  openrefnum := get_refnum (refdbaddr, gref);
                                     (* will work or system error is called! *)
                                               (*    ( according to WAH )    *)

  (* set up the fs_refdb for use by read, write, close, etc. *)
  with refdbptr^ do
  begin
    if gref then
    begin        (* do not link global refnum refdb's together *)
      head.refdb_list.fwd_link := 0;
      head.refdb_list.bkwd_link := 0;
    end
    else
    begin
      c_syslocal_ptr := pointer (b_syslocal_ptr);  (* get pointer to syslocal *)
      enqueue (head.refdb_list, c_syslocal_ptr^.head_fs_refdb, b_syslocal_ptr);
    end;
    refnum := openrefnum;
    fmark := 0;
    curoffset := 0;
    eof := false;
    acmode := manip;
    refdb_devnum := devnum;
    if configinfo [devnum]^.blockstructured then
    begin   (* block structured device *)
      fcbptr := openfcbptr;
      curpage := openfcbptr^.sent.fileaddr;
    end
    else
    begin   (* non-block-structured file *)
      fcbptr := pointer (badptr1);   (* no fcb for non-block-structured devices *)
      curpage := 0;
    end;
  end;

  refnum := openrefnum;   (* return refnum to caller *)
  reg_open_list (loc_ecode, devnum, 0, refnum, frefnum);
                        (* register this open and its refnum in the open list *)

1:
  if ecode = 0 then ecode := wcode;

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('GOPEN:  exiting with error code of ',ecode,' and refnum ',refnum);
  end;
(*$ENDC*)

end;   (* of procedure GOPEN *)







(*$S fs1 *)
procedure OPEN (*var ecode:error; var path:pathname; var refnum:integer; manip:mset*);

var ac : accesses;
    junk : boolean;

begin

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    write ('OPEN:  request to open ',path,' with mode [');
    for ac := dread to global_refnum do
    begin
      if ac in manip then
      case ac of
        dread : write (' DREAD ');
        dwrite: write (' DWRITE ');
        append: write (' APPEND ');
        private:write (' PRIVATE ');
        global_refnum: write (' GLOBAL_REFNUM ');
      end; (* of case ac of *)
    end;
    writeln (']');
  end;
(*$ENDC*)

  gopen (ecode, path, refnum, manip, false, junk, '' (* no password *));  (* non-privileged open *)


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('OPEN:  exiting with error code of ',ecode,' and refnum ',refnum);
  end;
(*$ENDC*)

end;   (* of procedure OPEN *)









(*$S fs1 *)
procedure POPEN (*var ecode:error; var path:pathname; var refnum:integer;
                                         manip:mset; var allowed:boolean*);

var ac : accesses;

begin

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    write ('POPEN:  request to open ',path,' with mode [');
    for ac := dread to global_refnum do
    begin
      if ac in manip then
      case ac of
        dread : write (' DREAD ');
        dwrite: write (' DWRITE ');
        append: write (' APPEND ');
        private:write (' PRIVATE ');
        global_refnum: write (' GLOBAL_REFNUM ');
      end; (* of case ac of *)
    end;
    writeln (']');
  end;
(*$ENDC*)

  gopen(ecode, path, refnum, manip, true, allowed, '' (* no password *));  (* privileged open *)


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('POPEN:  exiting with error code of ',ecode,' and refnum ',refnum);
  end;
(*$ENDC*)

end;   (* of procedure POPEN *)



{$S fs3}
procedure Open_Secure (* var ecode  : integer;
                         var path   : pathname;
                         var refnum : integer;
                             manip  : mset;
                         var passwd : e_name *);
var
     junk : boolean;

begin
    gopen(ecode, path, refnum, manip, false, junk, passwd);
end;






(*$S fs1 *)
procedure CLOSE_OBJECT (*var ecode:error; refnum:integer*);

label 1;

const parmbytes = 6;    (* calculated by hand for each procedure *)
      perrbase = 31;

var refdbaddr, sys_ptr : absptr;
    refdbptr : fref_ptr;
    c_syslocal_ptr : slocal_ptr;   (* current pointer to syslocal *)
    devnum : integer;
    reqptr : reqptr_type;
    locl_ecode : integer;
    DrvrParams : Params;

begin

(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('CLOSE_OBJECT:  request to close refnum ',refnum);
  end;
(*$ENDC*)

  ecode := 0;

  chk_refnum (ecode, refnum, frefdb, refdbaddr);
  if ecode <> 0 then
  begin
    ecode := E1_REFNUM_INVALID;
    goto 1;
  end;

  refdbptr := pointer (refdbaddr);   (* make a pointer to the fs_refdb *)

  free_refnum (refnum);  (* gets rid of refnum control block only, not fs_refdb *)
                      (* to make other read_data etc using same refnum to fail *)

  with refdbptr^ do
  begin
    devnum := refdb_devnum;
    reg_open_list (ecode, devnum, refnum, 0, frefnum);
                        (* unregister the open of this file in the open list *)
    if configinfo [devnum]^.blockstructured then
    with fcbptr^ do
    begin       (* block structured device *)
      if (dread in acmode) then nreaders := nreaders - 1;
      if (dwrite in acmode) or (append in acmode) then
                             nwriters := nwriters - 1;
      wait_sem (semgp, []);     (* wait for the write_data etc to complete *)
      signal_sem (semgp);
      wait_sem(mounttable[curdev]^.volSem, []);
      signal_sem(mounttable[curdev]^.volSem);

      (* let process mgmt see if this is a program file requiring unloading *)
      (* only do this if the file has been modified since the last flush *)
      if fcbptr^.time_dirty then
        Free_LPs(fcbptr, -1);

      close_sfile (ecode, fcbptr);   (* close the underlying s-file *)
    end   (* if blockstructured device *)
    else
    with mounttable [devnum]^ do
    begin    (* non block structured device *)
      opencount := opencount - 1;
      if opencount = 0 then private := false;

      (* Notify driver that device file has been closed by process *)
      with DrvrParams do
      begin
        fnctn_code := ddiscon;
        {$IFC NOT OS15}
        dvindex := devnum;
        {$ENDC}
      end;
      drivercall(locl_ecode, devnum, @DrvrParams);
      (* ignore error return *)
    end;

    if is_global_refnum (refnum) then
    begin
      (* global refdb's are not linked together *)
      sys_ptr := b_sysglobal_ptr;
    end
    else
    begin
      sys_ptr := b_syslocal_ptr;
      c_syslocal_ptr := pointer (b_syslocal_ptr);  (* get pointer to syslocal *)
      dequeue (head.refdb_list, b_syslocal_ptr);
    end;
  end;

  relspace (refdbaddr, sys_ptr);   (* release fs_refdb space *)

  if flush_level <= makeFlush then flushfs(locl_ecode);

1:

  {if (ecode > 0) and (ecode < 100) then
                            ecode := EXTERRBASE + UIERRBASE + PERRBASE + ecode;}


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('CLOSE_OBJECT:  exiting with error code of ',ecode);
  end;
(*$ENDC*)

end;  (* of procedure CLOSE_OBJECT *)








(*$S fs1 *)
(*
 *  performance
 *  1.  Uses the new abspage procedure
 *)
procedure READ_DATA (*var ecode : error;
                        refnum : integer;
                     data_addr : absptr;
                         count : longint;
                    var actual : longint;
                          mode : iomode;
                        offset : longint*);

label 1;

const parmbytes = 24;    (* calculated by hand for each procedure *)
      perrbase = 33;

var refdbaddr : absptr;
    refdbptr : fref_ptr;
    absbyte, relpage, apage, actual1, amountend, locsize : longint;
    poffset, pgdatasize : integer;
    otype : filetype;
    reqptr : reqptr_type;
    status : reqsts_type;
    locecode : error;
    parmarr: parmcheck;


procedure set_fmark_reader;

(* to be called only in the selected places below *)

begin
  with refdbptr^ do
  begin
    if (absbyte < 0) or (absbyte >= fcbptr^.sent.filesize)
    then  (* do not allow access past eof *)
    begin           (* attempt to position past end of file is illegal *)
      (* set EOF if reading from an empty file *)
      if absbyte = 0 then eof := true;
      ecode := E1_SET_FMARK;
     { goto 1;  }
    end
    else
    begin
{$IFC BLK512}
      PgOffset(absbyte, relpage, poffset);
{$ELSEC}
      relpage := absbyte div pgdatasize;
      poffset := absbyte mod pgdatasize;
{$ENDC}
      apage := abspage(ecode, relpage, fcbptr);
      if ecode = 0 then
      begin
        fmark := absbyte;    (* reset fmark to next byte to transfer *)
        curpage := apage;
        curoffset := poffset;
      end;
    end;
  end;
end;  (* of procedure set_fmark_reader *)

begin


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('READ_DATA:  request to read ',count,' bytes into address ',data_addr,
                                                          ' using refnum ',refnum);
    write ('            (Mode is ');
    case mode of
      absolute:  write ('ABSOLUTE from absbyte ',offset);
      relative:  write ('RELATIVE to fmark with offset ',offset);
      sequential:write ('SEQUENTIAL');
    end;  (* case mode of *)
    writeln (')');
  end;
(*$ENDC*)

  with parmarr do
  begin
    numcheck := 3;
    with parms[1] do
    begin
         addr := data_addr;
         readwrite := true;
    end;
    with parms[2] do
    begin
         if count > 0 then
              addr := data_addr + count-1
         else
              addr := data_addr;
         readwrite := true;
    end;
    with parms[3] do
    begin
         addr := ord (@actual);
         readwrite := true;
    end;
  end;
  if not valid_addr (ecode, parmarr) then goto 1;

  ecode := 0;
  actual := 0;

  chk_refnum (ecode, refnum, frefdb, refdbaddr);
  if ecode <> 0 then
  begin
    ecode := E2_REFNUM_INVALID;
    goto 1;
  end;

  refdbptr := pointer (refdbaddr);   (* make a pointer to the fs_refdb *)

  with refdbptr^ do
  begin

    (* check access modes *)

    if (not (dread in acmode))
    then
    begin
      ecode := E_NO_READ_ACCESS;    (* read access not allowed *)
      goto 1;
    end;

    if count < 0 then
    begin
      ecode := E1_COUNT_ILLEGAL;
      goto 1;
    end;

    if configinfo[refdb_devnum]^.blockstructured then
    begin      (* block structured device *)

      (* check to see if this is an open file or what *)
      otype := fcbptr^.ftype;

      if otype = pipe then (* pipes no longer supported *)
      begin
        ecode := E_NOT_IMPLEMENTED;
        goto 1;
      end;

      pgdatasize := mounttable [fcbptr^.curdev]^.MDDFdata^.datasize;

      (* access should be allowed now, so proceed with I/O *)

      wait_sem (fcbptr^.semgp, []);
                  (* read_data from pipe must not use the same sem as write_data,
                     since it needs to get in to unblock the writer if any,
                     while the writer is holding the sem when blocked *)
      case mode of
        absolute:
          begin       (* convert absolute byte offset to absolute page and offset *)
            absbyte := offset;
            set_fmark_reader;
            if ecode <> 0 then signal_sem (fcbptr^.semgp);
          end;
        relative:
          begin
            absbyte := fmark + offset;
            set_fmark_reader;
            if ecode <> 0 then signal_sem (fcbptr^.semgp);
          end;
        sequential:
          begin   (* normally, we can use curpage, curoffset in refdb or sfcb *)
            if (curpage = redlight) or (curpage = 0) then
            begin  (* if we read to a page boundary *)
              absbyte := fmark;
              set_fmark_reader;  (* in case someone wrote to it since that read *)
              if ecode <> 0 then signal_sem (fcbptr^.semgp);
            end;
          end;
      end;  (* of case mode of *)

      if ecode = 0 then
      begin        (* abspage and page offset set up ok, so perform I/O *)

        eof := false;   (* assume we won't run into end of file *)

        fileio (ecode, fcbptr, data_addr, count, actual,
                                     curpage, curoffset, readop); (* not pipe *)

        fmark := fmark + actual;  (* update fmark *)

        signal_sem (fcbptr^.semgp);

        if (ecode <> 0) or (fmark >= fcbptr^.sent.filesize) then
          eof := true;    (* any error => end-of-file *)
      end;  (* if ecode = 0 *)
    end     (* if blockstructured *)
    else
    begin    (* non block structured device *)
      if mode = sequential then
      begin
        if count > 0 then
        begin
          lisaio (ecode, refdb_devnum, data_addr, 0, count, actual,
                                                 without_header, nil, readop);
          if ecode <> 0 then
          begin
            eof := true;
          end;
          fmark := fmark + actual;
        end
        else actual := 0;
      end
      else
      begin
        actual := 0;
        ecode := E1_SEQ_ACCESS_ONLY;
        goto 1;
      end;
    end;
  end;   (* of with refdbptr^ do *)

1:

  {if (ecode > 0) and (ecode < 100) then
                            ecode := EXTERRBASE + UIERRBASE + PERRBASE + ecode;}


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('READ_DATA:  exiting with error code of ',ecode,'; actual xfer count is ',
                                                                               actual);
  end;
(*$ENDC*)

end;  (* of procedure READ_DATA *)








(*$S fs1 *)
(*
 *  performance
 *  1.  Uses the new abspage procedure
 *)
procedure WRITE_DATA (*var ecode : error;
                         refnum : integer;
                      data_addr : absptr;
                          count : longint;
                     var actual : longint;
                           mode : iomode;
                         offset : longint*);

label 1;

const parmbytes = 24;    (* calculated by hand for each procedure *)
      perrbase = 40;

var refdbaddr : absptr;
    refdbptr : fref_ptr;
    absbyte, relpage, apage, actual1, amountend, locspace : longint;
    poffset, pgdatasize : integer;
    otype : filetype;
    reqptr : reqptr_type;
    status : reqsts_type;
    locecode : error;
    firstwrite : boolean;
    parmarr: parmcheck;


procedure set_fmark_writer;

(* to be called only at the selected places below *)

begin
  with refdbptr^ do
  begin
    if (absbyte < 0) or (absbyte > fcbptr^.sent.filesize)
    then (* ok to write 1 past eof*)
    begin         (* attempt to position too far past end of file is illegal *)
      ecode := E2_SET_FMARK;
     { goto 1;  }
    end
    else
    begin
{$IFC BLK512}
      PgOffset(absbyte, relpage, poffset);
{$ELSEC}
      relpage := absbyte div pgdatasize;
      poffset := absbyte mod pgdatasize;
{$ENDC}
      apage := abspage(ecode, relpage, fcbptr);
      if (ecode = 0) or ((ecode = E_PAST_PEOF) and (poffset = 0)) (* page boundary *) then
      begin
        fmark := absbyte;         (* reset fmark to next byte to transfer *)
        if (ecode = 0) then
        begin
          if (absbyte < fcbptr^.sent.filesize) OR (poffset > 0) then
          begin
            curpage := apage;     (* access to already written part of file *)
          end
          else
          begin
            curpage := redlight;  (* pg allocated but not written *)
          end;
        end
        else curpage := redlight; (* space not allocated or not written to *)
        curoffset := poffset;
        ecode := 0;
      end;
    end;
  end;
end;   (* of procedure set_fmark_writer *)



begin


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('WRITE_DATA:  request to write ',count,' bytes from address ',data_addr,
                                                          ' using refnum ',refnum);
    write ('            (Mode is ');
    case mode of
      absolute:  write ('ABSOLUTE to absbyte ',offset);
      relative:  write ('RELATIVE to fmark with offset ',offset);
      sequential:write ('SEQUENTIAL');
    end;  (* case mode of *)
    writeln (')');
  end;
(*$ENDC*)

  with parmarr do
  begin
    numcheck := 3;
    with parms[1] do
    begin
         addr := data_addr;
         readwrite := false;
    end;
    with parms[2] do
    begin
         if count > 0 then
              addr := data_addr + count-1
         else
              addr := data_addr;
         readwrite := false;
    end;
    with parms[3] do
    begin
         addr := ord (@actual);
         readwrite := true;
    end;
  end;
  if not valid_addr (ecode, parmarr) then goto 1;

  ecode := 0;
  actual := 0;

  chk_refnum (ecode, refnum, frefdb, refdbaddr);
  if ecode <> 0 then
  begin
    ecode := E_REFNUM_INVALID;
    goto 1;
  end;

  refdbptr := pointer (refdbaddr);   (* make a pointer to the fs_refdb *)

  with refdbptr^ do
  begin

    if not ((dwrite in acmode) or (append in acmode)) then
    begin
      ecode := E_NO_WRITE_ACCESS;    (* write or append access not allowed *)
      goto 1;
    end;

    if count < 0 then
    begin
      ecode := E2_COUNT_ILLEGAL;      (* count is negative *)
      goto 1;
    end;

    if configinfo [refdb_devnum]^.blockstructured then
    begin      (* block structured device *)

      (* check to see if this is an open file or what *)
      (* yet to do this *)

      otype := fcbptr^.ftype;

      if otype = pipe then
      begin
        ecode := E_NOT_IMPLEMENTED;  (* pipes are no longer supported *)
        goto 1;
      end;

      pgdatasize := mounttable [fcbptr^.curdev]^.MDDFdata^.datasize;

      (* access should be allowed now, so proceed with I/O *)

      wait_sem (fcbptr^.semgp, []);  (* sem_control is not yet implemented *)
          (* for pipe or file, use semaphore to allow one writer to do wait and io
                               at a time, also to protect from allocate, compact *)

      firstwrite := fcbptr^.sent.fileaddr = 0;

      case mode of
        absolute:
          begin       (* convert absolute byte offset to absolute page and offset *)
            if dwrite in acmode then
            begin
              absbyte := offset;
              set_fmark_writer;
            end
            else ecode := E_ABS_APPEND;   (* absolute append not allowed *);
            if ecode <> 0 then signal_sem (fcbptr^.semgp);
          end;
        relative:
          begin
            if dwrite in acmode then
            begin
              absbyte := fmark + offset;
              set_fmark_writer;
            end
            else ecode := E_REL_APPEND;  (* relative append not allowed *);
            if ecode <> 0 then signal_sem (fcbptr^.semgp);
          end;
        sequential:
          begin   (* if append mode, set up fmark to end of existing data in file *)
            if append in acmode then  (* append but not write *)
            begin
              absbyte := fcbptr^.sent.filesize;  (* where new data would go *)
              set_fmark_writer;
            end;
            if ecode <> 0 then signal_sem (fcbptr^.semgp);
          end;
      end;  (* of case mode of *)

      if ecode = 0 then
      begin    (* abspage and page offset set up OK, so do the I/O *)

        eof := false;   (* assume we won't run into end of file *)

        fileio (ecode, fcbptr, data_addr, count, actual,
                                    curpage, curoffset, writeop);  (* not pipe *)
        fmark := fmark + actual;  (* update fmark *)

        if fmark > fcbptr^.sent.filesize then
        begin  (* file expanded, check for update errors *)

      (* fileio should have updated the fcbptr s_entry.filesize and .fileaddr in  *)
      (* case a first block was allocated or data was written past eof, thus      *)
      (* expanding the file.  If the fmark now appears to be greater than the     *)
      (* sfcb indicated filesize, somebody didn't do the bookkeeping correctly.   *)
      (* The I/O operation was probably OK, but flag this operation anyway, and   *)
      (* print a warning if tracing.  The other code tries to restore a consistent*)
      (* state so that the filesize, which is more basic, becomes the fmark.      *)

(*$IFC DEBUG2*)
          if trace (FS, 50) then
          begin
            writeln ('WRITE_DATA:  file expanded, but fmark and filesize disagree.');
            writeln ('WRITE_DATA:  fmark ', fmark,
                                       ', filesize ',
                                       fcbptr^.sent.filesize,
                                       ', refnum ',
                                       refnum);
          end;
(*$ENDC*)
          fmark := fcbptr^.sent.filesize;    (* update fmark     *)
          (* internal inconsistency of fmark and filesize, maybe it's fixed now *)
          if ecode = 0 then ecode:=E_FMARK_FUDGED;  (* return warning only if no errors *)
        end;

        signal_sem (fcbptr^.semgp);

        if ecode <> 0 then
        begin
          eof := true;
          {ecode := 7;}
        end;

      end;  (* if ecode = 0 *)
    end   (* of block structured case *)
    else
    begin    (* non block structured case *)
      if mode = sequential then
      begin
        lisaio (ecode, refdb_devnum, data_addr, 0, count, actual,
                                               without_header, nil, writeop);
        if ecode <> 0 then
        begin
          eof := true;
        end;
        fmark := fmark + actual;
      end
      else
      begin
        actual := 0;
        ecode := E2_SEQ_ACCESS_ONLY;   (* non-sequential access not allowed to non blocked dev *)
        goto 1;
      end;
    end;

  end;   (* of with refdbptr^ do *)

1:

  {if (ecode > 0) and (ecode < 100) then
                            ecode := EXTERRBASE + UIERRBASE + PERRBASE + ecode;}


(*$IFC DEBUG2*)
  if trace (FS, 70) then
  begin
    writeln ('WRITE_DATA:  exiting with error code of ',ecode,
                           '; actual xfer count is ', actual);
  end;
(*$ENDC*)

end; (* of procedure WRITE_DATA *)

