{ Copyright 1983, 1984, Apple Computer Inc. }

(*$S ProcStart *)

procedure Find_PLCB (var errnum : int2;  progname_ptr : ptr_pathname;
                     var plcb_ptr : ptr_PLCB);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  var
    endoflist : ptr_PLCB;                 { ptr to end of PLCB list in LCB }
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    progUnit : int2;                      { unit # of prog pathname }
    progSFnum : int2;                     { s-file # for prog pathname }
    filename : e_name;                    { local copy of name from FCB }

  begin  { Find_PLCB }
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    endoflist := @lcb_ptr^.plcb_fwdChain;
    plcb_ptr := endoflist;
    Parse_Pathname (errnum, progname_ptr^, progUnit, progSFnum);

    if errnum = 0 then
      begin  { pathname is valid }
        plcb_ptr := endoflist^.fwd_chain;

        while plcb_ptr <> endoflist do
          begin
            with plcb_ptr^.progfcb_ptr^ do
              begin
                if sfilenum = progSFnum then
                  begin
                    if curdev = progUnit then
                      { a match of both s-file # and device }
                      exit (Find_PLCB)
                  end
              end { with };

            plcb_ptr := plcb_ptr^.fwd_chain
          end { while }
      end { pathname valid };

    { program not loaded }
    plcb_ptr := nil
  end { Find_PLCB };


procedure CheckLoaded (* var errnum : int2;  var prog_pathname : pathname;
                         var stack_info : stkInfo_rec;  var unit_list : IUuse_list;
                         var loadedJT_ptr : ptr_JumpTable *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    plcb_ptr : ptr_PLCB;                  { ptr to PLCB for desired program }

  begin
    Find_PLCB (errnum, @prog_pathname, plcb_ptr);

    if errnum <> 0 then
      { program file not found or i/o errors }
      loadedJT_ptr := nil
    else if plcb_ptr = nil then
      { program is not loaded }
      loadedJT_ptr := nil
    else
      { program is loaded }
      with plcb_ptr^ do
        begin
          stack_info := stk_info;
          unit_list := prog_iuList;
          loadedJT_ptr := jmpTable
        end
  end { CheckLoaded };


procedure FreeSysglobal (var no_space : boolean);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to attempt to free up some sysglobal space    *)
        (*   for use in loading a new program.  The list of PLCBs    *)
        (*   for the currently loaded programs is scanned for the    *)
        (*   least recently loaded program that has no processes     *)
        (*   using it.  If such a program is found, it is unloaded   *)
        (*   and its sysglobal space freed.  Otherwise, any pending  *)
        (*   sysglobal expansions are allowed to complete in the     *)
        (*   hope that more space will become available.             *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   no_space : true if no additional sysglobal space could  *)
        (*              be made.                                     *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   A sysglobal expansion could occur as a result of        *)
        (*   calling this procedure.                                 *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This procedure is intended to be used only by           *)
        (*   Load_Program.                                           *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   None.                                                   *)
        (*                                                           *)
        (*************************************************************)

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }
    endoflist : ptr_PLCB;                 { ptr to end of PLCB list in LCB }
    plcb_ptr : ptr_PLCB;                  { ptr to PLCBs being freed }

  begin
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    endoflist := @lcb_ptr^.plcb_fwdChain;
    plcb_ptr := endoflist^.bkwd_chain;

    { try to free least recently loaded program with no current users }
    while plcb_ptr <> endoflist do
      with plcb_ptr^ do
        begin
          if n_loads = 0 then
            begin
              Free_Program (plcb_ptr, progfcb_ptr);
              no_space := false;
              exit (FreeSysglobal)
            end;

          plcb_ptr := bkwd_chain
        end { with };

    { complete pending sysglobal expansions as a last resort }
    MakeSGSpace (no_space)
  end { FreeSysglobal };


procedure Load_Program (* var errnum : int2;  progname_ptr : ptr_pathname;
                          obj_ptr : ObjHandle;  loadedJT_ptr : ptr_JumpTable;
                          stack_info : stkInfo_rec;  jt_ptr : ptr_JumpTable;
                          var plcbRP : relptr;  unit_list : IUuse_list;
                          fetch_bitmap : seg_bitmap;  var start_addr : int4 *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to 'load' a program under the operating       *)
        (*   system.  Loading basically involves setting up the      *)
        (*   SDBs for the private and shared code segments required  *)
        (*   by the specified program.  If the program is already    *)
        (*   loaded, the load count is incremented.  Otherwise, a    *)
        (*   PLCB is allocated, the required shared segments are     *)
        (*   loaded, the required Intrinsic Unit data spaces are     *)
        (*   allocated, and the private segments are loaded.         *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   progname_ptr : a pointer to the pathname of the         *)
        (*                  program to be loaded.                    *)
        (*                                                           *)
        (*   obj_ptr : a pointer to the ObjDescriptor for the        *)
        (*             program file (opened by Make_Process).        *)
        (*                                                           *)
        (*   num_sharedIUs : the # of shared Intrinsic Units that    *)
        (*                   program uses.                           *)
        (*                                                           *)
        (*   used_unit : a local list of the Intrinsic Units         *)
        (*               (regular & shared) and associated data      *)
        (*               sizes used by the program.                  *)
        (*                                                           *)
        (*   jt_ptr : a pointer to the memory copy of the jump       *)
        (*            table of the program being loaded.             *)
        (*                                                           *)
        (*   sloc_ptr : a pointer to the syslocal segment being      *)
        (*              built for the new process being created to   *)
        (*              run the program.                             *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   errnum : the error return parameter for this            *)
        (*            procedure.  Any errors returned are            *)
        (*            translated by Make_Process for return to the   *)
        (*            user (see values below).                       *)
        (*                                                           *)
        (*   start_addr : the offset from the start of the jump      *)
        (*                table to the procedure descriptor which    *)
        (*                the entry to the program (1st procedure    *)
        (*                in 1st private segment).                   *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This procedure is intended to be used only by           *)
        (*   Make_Process.                                           *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   Lots.  See constants below.                             *)
        (*                                                           *)
        (*************************************************************)

  const
    e_fsread = 1;                         { error reading program file }
    e_inv_progfile = 2;                   { error invalid program file }
    e_nosysglob = 5;                      { error no sysglobal space }

    e_progfile = 8;                       { error accessing program file }
    e_noseg = 15;                         { error looking for shared seg }
    e_badseg = 16;                        { error matching name of shared seg }
    e_segfile = 11;                       { error accessing a shared seg file }
    e_noshrspace = 18;                    { error no space for shared IU globals }
    w_lfscaved = -20;                     { warning lib file was scavenged }

  (*$IFC debug1 *)
  type
    ev_log = record
               ev_type: int1;             { type = 11 }
               ev_segT: int1;             { seg type 1=private code }
                                          {          4=intrinsic code }
               ev_sdb: sdb_ptr;           { seg sdb ptr }
               ev_segN: int2;             { seg number }
               ev_pcb: absptr;            { c_pcb_ptr }
             end;
  (*$ENDC*)

  var
    pseg_index : int2;                    { loop index for private seg SDB list }
    sseg_index : int2;                    { loop index for private seg SDB list }
    last_segIndex : int2;                 { last segment index in Directory }
    sDirEntry_ptr : ptr_SegDirEntry;      { ptr to a Segment directory entry }
    prog_fcbptr : sfcb_ptr;               { ptr to FCB for prog s-file }
    sseg_fcbptr : sfcb_ptr;               { ptr to FCB for shared seg s-file }
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }
    plcb_ptr : ptr_PLCB;                  { ptr to PLCB for program being loaded }
    obj_block : ObjBlock;                 { 'invariant' block from prog file }
    obj_varblock : ObjVarBlock;           { 'variant' block from prog file }
    disk_addr : addrdisc;                 { disk address for building segments }
    seg_size : int4;                      { memory size for building segments }
    ord_ptr : absptr;                     { general ordinal of a ptr }
    sfileid : int2;                       { id for prog or seg s-file }
    unit_num : int2;                      { unit # for vol w/ prog or seg s-file }
    refdb_ptr : fref_ptr;                 { ptr to refdb for program file }
    plcb_size : int2;                     { size of PLCB needed to load program }
    lfile_scavenged : boolean;            { true if a lib file was scavenged }
    no_space : boolean;                   { true if no sysglobal space available }

    (*$IFC debug1 *)
    c_event: ev_log;                      { logging event }
    (*$ENDC*)


  procedure Recover (error : int2);
    { procedure used by Load_Program to recover from any errors that occur while
      the specified program file is being loaded. }

    var
      j : int2;                           { for unloading any private segs }
      num_ssegs : sSegRange;              { # shared segments to unload }

    begin
      (*$IFC debug2 *)
      if Trace (mm, 30) then
        begin
          writeln (' *** Load_Program error ', error, ' ***');
          writeln ('     errnum = ', errnum);
          writeln ('     obj_ptr^.error = ', obj_ptr^.error)
        end;
      (*$ENDC *)

      Signal_sem (lcb_ptr^.load_sem);

      if prog_fcbptr <> nil then
        begin
          Close_SFile (errnum, prog_fcbptr);
          (*$IFC debug2 *)
          if errnum <> 0 then
            begin
              writeln ('    Load/Recover: error closing program s-file = ',
                       errnum);
              readln
            end
          (*$ENDC *)
        end;

      if (error = e_nosysglob) and (sDirEntry_ptr <> nil) then
        { no sysglobal space for an SDB for a shared code segment }
        with lcb_ptr^.File_Dir^[sDirEntry_ptr^.sFileNum] do
          begin
            fUse_count := fUse_count - 1;
            if fUse_count = 0 then
              begin  { close the library file }
                sseg_fcbptr := pointer(fFid + b_sysglobal_ptr);
                fFid := 0;
                Close_SFile (errnum, sseg_fcbptr);
                (*$IFC debug2 *)
                if errnum <> 0 then
                  begin
                    writeln ('Load/Recover: error closing shared seg s-file = ',
                             errnum:1);
                    readln
                  end;
                (*$ENDC *)
              end { close lib file }
          end { with lcb_ptr^.File_Dir^[sFileNum] };

      if plcb_ptr <> nil then
        with plcb_ptr^ do
          begin
            { recover from any private segments that were loaded }
            for j := pseg_index - 1 downto 1 do Rel_Seg (pSeg_list^[j]);

            { recover from any shared segments that were loaded }
            if sDirEntry_ptr = nil then num_ssegs := last_segIndex
              else num_ssegs := sseg_index - 1;
            Unload_SharedSegs (prog_segList, num_ssegs);

            if jmpTable <> nil then
              RelSpace (ord(jmpTable), MMU_Base (LDSN_to_MMU (IDir_ldsn)));

            if error = e_noshrspace then
              begin  { remove PLCB from Loader's list }
                bkwd_chain^.fwd_chain := fwd_chain;
                fwd_chain^.bkwd_chain := bkwd_chain;
              end;

            RelSpace (ord(plcb_ptr), b_sysglobal_ptr)
          end { plcb_ptr <> nil };

      errnum := error;   { Make_Process will fix it up for return to user }
      exit (Load_Program)
    end { Recover };


  procedure Build_SegList (var seg_list : sseg_list);

    var
      index : int2;                       { for building segment use list }
      num_segs : int2;                    { # segments in Segment Table }
      obj_varblock : ObjVarBlock;         { 'variant' block from prog file }
      sDirEntry_ptr : ptr_SegDirEntry;    { ptr to a Segment directory entry }

    begin
      index := 1;
      repeat
        seg_list[index] := false;
        index := index + 1
      until index > maxSeg;

      index := 1;   num_segs := obj_block.bSegmentTable.nSegments;
      (*$IFC debug2 *)
      if Trace (mm, 30) then
        writeln ('   checking ', num_segs:1, ' shared segments...');
      (*$ENDC *)

      repeat
        GetObjVar (obj_ptr, SegVariant, obj_varblock);
        if obj_ptr^.error <> 0 then Recover (e_fsread);
        with obj_varblock.bSegVariant do
          begin
            Get_SegDir_Entry (SegNumber, sDirEntry_ptr);
            if sDirEntry_ptr = nil then
              begin
                (*$IFC debug2 *)
                write ('   Segment # ', SegNumber:1, ' (', SegName);
                writeln (') not found in INTRINSIC.LIB');
                (*$ENDC *)
                Recover (e_noseg)
              end;

            with sDirEntry_ptr^ do
              if (SegName <> sName) or (sSegSize <= 0) then
                begin
                  (*$IFC debug2 *)
                  write ('   Segment # ', SegNumber:1, ' (', SegName);
                  writeln (') doesn''t match name in INTRINSIC.LIB');
                  (*$ENDC *)
                  Recover (e_badseg)
                end;

            seg_list[SegNumber] := true
          end { with obj_varblock.bSegVariant };

        index := index + 1
      until index > num_segs
    end { Build_SegList };


  begin  { Load_Program }
    (*$IFC debug2 *)
    if Trace (mm, 30) then
      writeln ('   entering Load_Program for ', progname_ptr^);
    (*$ENDC *)

    prog_fcbptr := nil;   plcb_ptr := nil;   plcbRP := 0;
    pseg_index := 0;   sseg_index := 0;   last_segIndex := 0;
    sDirEntry_ptr := nil;   lfile_scavenged := false;
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    Wait_sem (lcb_ptr^.load_sem, []);

    if loadedJT_ptr <> nil then
      begin  { program already loaded }
        { scan Loader's list for the PLCB for the program }
        plcb_ptr := pointer(ord(lcb_ptr));

        repeat
          plcb_ptr := plcb_ptr^.fwd_chain
        until plcb_ptr^.jmpTable = loadedJT_ptr;

        with plcb_ptr^ do
          n_loads := n_loads + 1
      end
    else
      begin  { must do a full load }
        Chk_Refnum (errnum, obj_ptr^.ObjFile^.refnum, frefdb, ord_ptr);
        refdb_ptr := pointer(ord_ptr);
        with refdb_ptr^.fcbptr^ do
          begin
            sfileid := sfilenum;
            unit_num := curdev
          end;

        GetObjInvar (obj_ptr, obj_block);
        if (obj_ptr^.error <> 0) then Recover (e_fsread);
        if obj_block.blockHeader <> SegmentTable then Recover (e_inv_progfile);

        { allocate PLCB and initialize it }
        plcb_size := Sizeof (PLCB) + jt_ptr^.numSegs * Sizeof (sdb_ptr);

        repeat
          if GetSpace (plcb_size, b_sysglobal_ptr, ord_ptr) then
            plcb_ptr := pointer(ord_ptr)
          else
            FreeSysglobal (no_space)
        until (plcb_ptr <> nil) or no_space;

        if plcb_ptr = nil then Recover (e_nosysglob);

        with plcb_ptr^ do
          begin
            jmpTable := nil;
            Open_SFile (errnum, sfileid, unit_num, prog_fcbptr);
            if errnum > 0 then Recover (e_progfile);   { can't occur? }

            progfcb_ptr := prog_fcbptr;
            n_loads := 1;
            must_delete := false;
            n_pri_segs := jt_ptr^.numSegs;
            pSeg_list := pointer(ord(plcb_ptr) + Sizeof (PLCB));
            prog_iuList := unit_list;
            Build_SegList (prog_segList);

            if not GetSpace (stack_info.jt_size,
                             MMU_Base (LDSN_to_MMU (IDir_ldsn)), ord_ptr) then
              Recover (e_nosysglob);
            jmpTable := pointer(ord_ptr);

            stk_info := stack_info;
            prog_bitMap := fetch_bitmap;

            { save copy of jump table in the IUDirectory cache }
            MoveLeft (jt_ptr^, jmpTable^, stk_info.jt_size)
          end { with plcb_ptr^ };

        { make sure all required shared segments are loaded }
        with lcb_ptr^ do
          begin
            sDirEntry_ptr := pointer(ord(@sSeg_Dir^[1]) - Sizeof (SegDirEntry));
            last_segIndex := num_sSegs
          end;
        sseg_index := 1;

        repeat
          sDirEntry_ptr := pointer(ord(sDirEntry_ptr) + Sizeof (SegDirEntry));
          with sDirEntry_ptr^ do
            if plcb_ptr^.prog_segList[sNumber] then
              begin  { segment is required by program }
                if sSegsdb_ptr = nil then
                  begin  { load the shared segment }
                    with lcb_ptr^.File_Dir^[sFileNum] do
                      begin
                        if fFid = 0 then
                          begin  { must open the library file }
                            Opn_LibFile (errnum, fName_ptr, sseg_fcbptr);
                            if errnum > 0 then
                              begin
                                (*$IFC debug2 *)
                                writeln ('   error accessing lib file ',
                                         fName_ptr^);
                                (*$ENDC *)
                                Recover (e_segfile)
                              end
                            else if errnum = -1176 then
                              lfile_scavenged := true;
                            fFid := ord(sseg_fcbptr) - b_sysglobal_ptr
                          end { open library file };

                        (*$IFC debug2 *)
                        if Trace (mm, 30) then
                          begin
                            write ('   loading shared seg ', sName);
                            writeln (' from file ', fName_ptr^)
                          end;
                        (*$ENDC *)
                        fUse_count := fUse_count + 1;
                        disk_addr.fid := fFid
                      end { with lcb_ptr^.File_Dir^[sFileNum] };

                    disk_addr.offset := sFileOffset;
                    seg_size := sSegSize;
                    repeat
                      Bld_Seg (code, seg_size, 0, disk_addr, 0, sPackedSize,
                               sSegsdb_ptr);
                      if sSegsdb_ptr = nil then FreeSysglobal (no_space)
                    until (sSegsdb_ptr <> nil) or no_space;

                    if sSegsdb_ptr = nil then Recover (e_nosysglob);

                    (*$IFC debug1 *)
                    if TRACE(spare2,10) then
                      begin
                        if LOGGING then
                          begin
                            with c_event do
                              begin
                                ev_type:=11;
                                ev_segT:=120;
                                ev_sdb:=sSegsdb_ptr;
                                ev_segN:=sNumber;
                                ev_pcb:=c_pcb_ptr;
                                LOG(errnum,ord(@c_event));
                              end;
                          end;
                      end;
                    (*$ENDC*)
                  end { load segment };

                sUse_count := sUse_count + 1
              end { segment is required };

          sseg_index := sseg_index + 1
        until sseg_index > last_segIndex;

        { load all private segments for program }
        sDirEntry_ptr := nil;   { for Recover }
        with plcb_ptr^, jt_ptr^ do
          begin
            disk_addr.fid := ord(progfcb_ptr) - b_sysglobal_ptr;
            for pseg_index := 1 to n_pri_segs do
              begin
                disk_addr.offset := segDesc[pseg_index].SegmentAddr;
                seg_size := segDesc[pseg_index].SizeUnpacked;
                repeat
                  Bld_Seg (code, seg_size, 0, disk_addr, 0,
                           segDesc[pseg_index].SizePacked, pSeg_list^[pseg_index]);
                  if pSeg_list^[pseg_index] = nil then FreeSysglobal (no_space)
                until (pSeg_list^[pseg_index] <> nil) or no_space;

                if pSeg_list^[pseg_index] = nil then Recover (e_nosysglob);

                (*$IFC debug1 *)
                if TRACE(spare2,10) then
                  begin
                    if LOGGING then
                      begin
                        with c_event do
                          begin
                            ev_type:=11;
                            ev_segT:=1;
                            ev_sdb:=pSeg_list^[pseg_index];
                            ev_segN:=pseg_index;
                            ev_pcb:=c_pcb_ptr;
                            LOG(errnum,ord(@c_event));
                          end;
                      end;
                  end;
                (*$ENDC*)
              end { for }
          end { with };

        { add new PLCB to Loader's list }
        with lcb_ptr^ do
          begin
            with plcb_ptr^ do
              begin
                fwd_chain := plcb_fwdChain;
                bkwd_chain := pointer(ord(lcb_ptr));
                fwd_chain^.bkwd_chain := plcb_ptr;
                plcb_fwdChain := plcb_ptr
              end;

            n_progs_loaded := n_progs_loaded + 1
          end { with lcb_ptr^ }
      end { full load };

    { build Intrinsic Unit data pointer table }
    Build_DPT (errnum, stack_info, unit_list, jt_ptr);
    if errnum > 0 then Recover (errnum);

    { set return values }
    Signal_sem (lcb_ptr^.load_sem);
    if lfile_scavenged then errnum := w_lfscaved
      else errnum := 0;
    start_addr := jt_ptr^.numSegs * Sizeof(jtSegEntry) + 4 { numSegs & numProcs };
    plcbRP := ord(plcb_ptr) - b_sysglobal_ptr
  end { Load_Program };


procedure MM_Setup (* stk_refnum, sloc_refnum: int2;  jt_ptr: ptr_JumpTable;
                      plcbRP : relptr;  var sl_sdbRP: relptr *);

       (**********************************************************)
       (*                                                        *)
       (* Description:                                           *)
       (*    Sets up the memory manager cells in syslocal of a   *)
       (*    new process.                                        *)
       (*                                                        *)
       (* Input Parameters:                                      *)
       (*    stk_refnum - refnum to the stack data segment of the*)
       (*                 new process                            *)
       (*    sloc_refnum- refnum to the syslocal data segment of *)
       (*                 the new process                        *)
       (*    jt_ptr - address of jumptable data area             *)
       (*                                                        *)
       (* Output Parameters:                                     *)
       (*    sl_sdbRP     - the relptr to the sdb used to define *)
       (*                   the syslocal data segment of the new *)
       (*                   process                              *)
       (*                                                        *)
       (**********************************************************)

(*$IFC debug1 *)
type
  ev_log = record
             ev_type: int1;             { type = 18 - change of sdb type }
             ev_res1: int1;             { reserved }
             ev_sdb: sdb_ptr;           { seg sdb ptr }
             ev_oldsegT: int1;          { seg type }
             ev_newsegT: int1;          { seg type }
             ev_res2: int4;             { reserved }
           end;
(*$ENDC*)

var
  index,errnum: int2;
  long_ptr: ^int4;
  mapSum: int4;
  stkrefdbptr, slocrefdbptr: absptr;
  ptr_stk_refdb, ptr_sl_refdb: ptr_ds_refdb;
  l_ldsn: int2;
  c_syslocal_ptr: slocal_ptr;
  ordlbtptr, ordmrbtptr, ordsmrbtptr: absptr;
  c_mrbt_ptr: mrbt_ptr;
  c_smrbt_ptr: smrbt_ptr;
  plcb_ptr : ptr_PLCB;
  seg_num : sSegRange;
  sDirEntry_ptr : ptr_SegDirEntry;      { ptr to a Segment directory entry }
  lcb_ptr : ptr_LCB;                    { ptr to LCB }
  last_segIndex : int2;                 { last segment index in Directory }
  c_lbt_ptr: lbt_ptr;
  fcbptr: sfcb_ptr;

  (*$IFC debug1 *)
  c_event: ev_log;                      { logging event }
  (*$ENDC*)

begin
  CHK_REFNUM(errnum,stk_refnum,dsrefdb,stkrefdbptr);
  CHK_REFNUM(errnum,sloc_refnum,dsrefdb,slocrefdbptr);

  ptr_stk_refdb:=pointer(stkrefdbptr);
  ptr_sl_refdb:=pointer(slocrefdbptr);

  (* initialize the syslocal data segment *)
  l_ldsn:=ptr_sl_refdb^.ldsn;
  c_syslocal_ptr:=pointer(MMU_BASE(LDSN_TO_MMU(l_ldsn)));
  with c_syslocal_ptr^ do
    begin
      (* code segment trap info *)
      csreq_addr:=ord(nil);
      csreq_type:=0;

      (* head ds_refdb list *)
      hd_ds_refdb_list.fwd_link:=ord(@hd_ds_refdb_list.fwd_link)-
                                                ord(c_syslocal_ptr);
      hd_ds_refdb_list.bkwd_link:=hd_ds_refdb_list.fwd_link;

      (* head of locked seg list *)
      hd_seglock_list.fwd_link:=ord(@hd_seglock_list.fwd_link)-
                                                ord(c_syslocal_ptr);
      hd_seglock_list.bkwd_link:=hd_seglock_list.fwd_link;

      (* mrbt *)
      if not GETSPACE(SIZEOF(mrbt),ord(c_syslocal_ptr),ordmrbtptr)
        then SYSTEM_ERROR(10581);

      c_mrbt_ptr:=pointer(ordmrbtptr);
      mrbt_addr:=MMU_BASE(syslocmmu)+ordmrbtptr-ord(c_syslocal_ptr);

      (* smrbt *)
      if not GETSPACE(SIZEOF(smrbt),ord(c_syslocal_ptr),ordsmrbtptr)
        then SYSTEM_ERROR(10581);

      c_smrbt_ptr:=pointer(ordsmrbtptr);
      smrbt_addr:=MMU_BASE(syslocmmu)+ordsmrbtptr-ord(c_syslocal_ptr);

      { set all SMRBT entries to no access first }
      index := minsysldsnmmu;
      repeat
        with c_smrbt_ptr^[index] do
          begin
            access := mmuabsent;
            sdbRP := 0
          end;
        index := index + 1
      until index > maxsysldsnmmu;

      { set up the MRBT for the new process using jump table and PLCB }
      { set all entries to no access first }
      index := minmmu;
      repeat
        with c_mrbt_ptr^[index] do
          begin
            access := mmuabsent;
            sdbRP := 0
          end;
        index := index + 1
      until index > maxmmu;

      { set stack & shared IU data seg entry }
      with c_mrbt_ptr^[stackmmu] do
        begin
          access := mmustack;
          sdbRP := ord(ptr_stk_refdb^.a_sdb_ptr) - b_sysglobal_ptr
        end;
      with c_mrbt_ptr^[shrsegmmu] do
        begin
          access := mmureadwrite;
          lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
          sdbRP := ord(lcb_ptr^.sdSegsdb_ptr) - b_sysglobal_ptr
        end;

      if plcbRP = 0 then
        begin  { no code space for process }
          { set fetch ahead structures so MemMgr won't try it }
          preLoaded := true;   recordFaults := false;
          long_ptr := pointer(ord(@initSegMap) + Sizeof(initSegMap));
          repeat
            long_ptr := pointer(ord(long_ptr) - 4);
            long_ptr^ := 0
          until long_ptr = @initSegMap
        end
      else
        begin  { set code space mapping }
          plcb_ptr := pointer(plcbRP + b_sysglobal_ptr);
          with plcb_ptr^ do
            begin
              { map shared segments used by program }
              with lcb_ptr^ do
                begin
                  sDirEntry_ptr := pointer(ord(@sSeg_Dir^[1]) -
                                             Sizeof (SegDirEntry));
                  last_segIndex := num_sSegs
                end;
              index := 1;

              repeat
                sDirEntry_ptr := pointer(ord(sDirEntry_ptr) +
                                           Sizeof (SegDirEntry));
                with sDirEntry_ptr^ do
                  if prog_segList[sNumber] then
                    with c_mrbt_ptr^[sNumber] do
                      begin
                        access := mmureadonly;
                        sdbRP := ord(sSegsdb_ptr) - b_sysglobal_ptr
                      end;

                index := index + 1
              until index > last_segIndex;

              { map private segments of program file }
              with jt_ptr^ do
                for index := 1 to numSegs do
                  begin
                    seg_num := segDesc[index].MemLoc DIV maxmmusize;
                    with c_mrbt_ptr^[seg_num] do
                      begin
                        access := mmureadonly;
                        sdbRP := ord(pSeg_list^[index]) - b_sysglobal_ptr
                      end
                  end;

              { set up fetch ahead structures }
              mapSum := 0;
              long_ptr := pointer(ord(@prog_bitMap) + Sizeof(prog_bitMap));
              repeat
                long_ptr := pointer(ord(long_ptr) - 4);
                mapSum := mapSum + long_ptr^
              until long_ptr = @prog_bitMap;

              if mapSum = 0 then
                begin  { program has not been recorded yet }
                  recordFaults := true;
                  preLoaded := true    { so MemMgr won't bother trying }
                end
              else if long_ptr^ = no_FAinfo then
                begin  { no fetch ahead info available }
                  recordFaults := false;
                  preLoaded := true;   { so MemMgr won't bother trying }
                  long_ptr^ := 0
                end
              else
                begin  { program has been recorded }
                  recordFaults := false;
                  preLoaded := false
                end;
              initSegMap := prog_bitMap
            end { with plcb_ptr^ }
        end { set code space mapping };

      (* initialize ldsn binding table *)
      if not GETSPACE(SIZEOF(lbt),ord(c_syslocal_ptr),ordlbtptr)
        then SYSTEM_ERROR(10581);
      c_lbt_ptr:=pointer(ordlbtptr);
      lbt_addr:=MMU_BASE(syslocmmu)+ordlbtptr-ord(c_syslocal_ptr);
      for index:=min_ldsn to max_ldsn do c_lbt_ptr^[index]:=0;

    end; (*with c_syslocal_ptr^ *)


  (* bump the opencount for syslocal and stack *)
  (* data segments for use by the new process  *)
  with ptr_sl_refdb^.a_sdb_ptr^ do
    begin
      (*$IFC debug1 *)
      if TRACE(spare2,10) then
        begin
          if LOGGING then
            begin
              with c_event do
                begin
                  ev_type:=18;
                  ev_res1:=0;
                  ev_oldsegT:=ord(sdbtype);
                  ev_newsegT:=ord(slocal);
                  ev_sdb:=ptr_sl_refdb^.a_sdb_ptr;
                  ev_res2:=0;
                  LOG(errnum,ord(@c_event));
                end;
            end;
        end;
      (*$ENDC*)

      sdbtype := slocal;  (* data segment becomes a syslocal segment *)
      numbopen := numbopen + 1;
    end;

  with ptr_stk_refdb^.a_sdb_ptr^ do
    begin
      (*$IFC debug1 *)
      if TRACE(spare2,10) then
        begin
          if LOGGING then
            begin
              with c_event do
                begin
                  ev_type:=18;
                  ev_res1:=0;
                  ev_oldsegT:=ord(sdbtype);
                  ev_newsegT:=ord(stack);
                  ev_sdb:=ptr_stk_refdb^.a_sdb_ptr;
                  ev_res2:=0;
                  LOG(errnum,ord(@c_event));
                end;
            end;
        end;
      (*$ENDC*)

      sdbtype := stack;   { data segment becomes a stack }
      numbopen := numbopen + 1;
    end;

  (* return sdb_ptr to syslocal data segment *)
  sl_sdbRP:=ord(ptr_sl_refdb^.a_sdb_ptr)-b_sysglobal_ptr;
end;(* MM_SETUP *)


(*$S ProcTerm *)

procedure Unload_Program;

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  var
    plcb_ptr : ptr_PLCB;                  { ptr to PLCB for prog being unloaded }
    sysloc_ptr : slocal_ptr;              { ptr to syslocal for current process }
    long_ptr : ^int4;                     { for dealing with bitmaps }
    plcbSum : int4;                       { sum of bitmap entries in PLCB }
    syslocSum : int4;                     { sum of bitmap entries in syslocal }
    pcb_ptr : ptr_PCB;                    { ptr to PCB for current process }
    IUD_refnum : int2;                    { refnum for opening IU Directory seg }
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }


  procedure WriteFAInfo (thisBitmap : seg_bitmap);
    { procedure used by Unload_Program to update the segment fetch ahead bitmap in
      the program file. }

    var
      obj_block : ObjBlock;               { 'invariant' block from prog file }
      obj_ptr : ObjHandle;                { ptr to ObjDescriptor for prog file }
      progname : pathname;                { local copy of pathname to prog file }

    begin
      exit (WriteFAInfo);   { do nothing for Spring release }
      InitObjFile (obj_ptr, 2);
      if obj_ptr = nil then exit (WriteFAInfo);
      with plcb_ptr^.progfcb_ptr^ do
        progname := Concat ('-', configinfo[curdev]^.devname, '-', fname);
      OpenObjFile (obj_ptr, progname, false { existing file });
      if obj_ptr^.error > 0 then exit (WriteFAInfo);
      repeat
        GetObjInvar (obj_ptr, obj_block)
      until (obj_block.blockHeader = OSData) or
            (obj_block.blockHeader = UnknownBlock) or (obj_ptr^.error > 0);

      if (obj_ptr^.error = 0) and (obj_block.blockHeader = OSData) then
        PutObjSeq (obj_ptr, @thisBitmap, Sizeof(thisBitmap));

      CloseObjFile(obj_ptr, false)
    end { WriteFAInfo };


  begin  { Unload_Program }
    sysloc_ptr := pointer(b_syslocal_ptr);
    pcb_ptr := pointer(c_pcb_ptr);
    plcb_ptr := pointer(pcb_ptr^.plcbRP + b_sysglobal_ptr);
    pcb_ptr^.plcbRP := 0;   { unloading }
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);

    with plcb_ptr^ do
      begin
        { 'unload' shared IU data spaces - process relative counts }
        Open_IUDirectory (IUD_refnum);
        if IUD_refnum = -1 then exit (Unload_Program);
        Free_SharedIUs (prog_iuList, lcb_ptr^.num_IUs, false { don't release });
        Close_IUDirectory (IUD_refnum);

        { determine whether fetch ahead bitmap should be written to program file }
        plcbSum := 0;
        long_ptr := pointer(ord(@prog_bitMap) + Sizeof(prog_bitMap));
        repeat
          long_ptr := pointer(ord(long_ptr) - 4);
          plcbSum := plcbSum + long_ptr^
        until long_ptr = @prog_bitMap;

        if plcbSum = 0 then
          with sysloc_ptr^ do
            begin  { possibly update fetch ahead map }
              syslocSum := 0;
              long_ptr := pointer(ord(@initSegMap) + Sizeof(initSegMap));
              repeat
                long_ptr := pointer(ord(long_ptr) - 4);
                syslocSum := syslocSum + long_ptr^
              until long_ptr = @initSegMap;

              if (syslocSum <> 0) and (termE_cause <= ord(fthr_term)) then
                WriteFAInfo (initSegMap)
            end { possibly update };

        { 'free' the program file if necessary }
        n_loads := n_loads - 1;

        if (n_loads = 0) and must_delete then
          { unload the program }
          Free_Program (plcb_ptr, progfcb_ptr)
      end { with plcb_ptr^ }
  end { Unload_Program };


procedure Load_Cleanup;
  { procedure called from Root to unload all loaded programs }

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }
    plcb_ptr : ptr_PLCB;                  { ptr to PLCBs being freed }
    endoflist : ptr_PLCB;                 { ptr to end of PLCB list in LCB }
    old_fFence : FlushLevel;              { current value of flush fence }

  begin
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    with lcb_ptr^ do
      begin
        endoflist := @plcb_fwdChain;   plcb_ptr := plcb_fwdChain;

        { set File system flushing down while unloading programs }
        SetFlushLevel (lowFlush, old_fFence);

        while plcb_ptr <> endoflist do
          begin
            Free_Program (plcb_ptr, plcb_ptr^.progfcb_ptr);

            plcb_ptr := plcb_fwdChain
          end;

        SetFlushLevel (old_fFence, old_fFence)
      end { with lcb_ptr^ }
  end { Load_Cleanup };


(*$S fs1 *)   { segment with Close_Object, etc. - used to be in ProcComm }

procedure Free_LPs (* var fcb_ptr : sfcb_ptr;  disk_num : int2 *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  { procedure to force unloading of program(s) due to File System activity }

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB in sysglobal }
    endoflist : ptr_PLCB;                 { ptr to end of PLCB list in LCB }
    plcb_ptr : ptr_PLCB;                  { ptr to PLCBs being freed }
    temp_ptr : ptr_PLCB;

  begin
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    endoflist := @lcb_ptr^.plcb_fwdChain;   plcb_ptr := endoflist^.fwd_chain;

    if disk_num > -1 then
      { free loaded programs on a device being unmounted }
      while plcb_ptr <> endoflist do
        with plcb_ptr^ do
          if progfcb_ptr^.curdev <> disk_num then
            plcb_ptr := fwd_chain
          else
            begin  { found a program on device }
              temp_ptr := fwd_chain;
              if n_loads > 0 then must_delete := true
                else Free_Program (plcb_ptr, progfcb_ptr);

              plcb_ptr := temp_ptr
            end;

    plcb_ptr := endoflist^.fwd_chain;

    if fcb_ptr <> nil then
      { free a loaded program being closed/modified or killed }
      while plcb_ptr <> endoflist do
        with plcb_ptr^ do
          begin
            if progfcb_ptr = fcb_ptr then
              begin
                if n_loads > 0 then must_delete := true
                  else Free_Program (plcb_ptr, fcb_ptr);

                exit (Free_LPs)
              end;

            plcb_ptr := fwd_chain
          end { with plcb_ptr^ }
  end { Free_LPs };


ÿ