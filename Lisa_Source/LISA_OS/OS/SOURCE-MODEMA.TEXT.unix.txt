
  UNIT MODEM;           (* built-in port A modem driver *)

      (*  By Dave Offen *)
      (*  Copyright 1983, 1984, Apple Computer Inc. *)

  INTERFACE

    USES
      (*$Uobject/driverdefs.obj*)
        driverdefs,
      (*$Uobject/driversubs.obj*)
        driversubs;

      function MODEMA (parameters: param_ptr): integer;

      procedure COPYBYTES (port_ptr: absptr);

  IMPLEMENTATION

    (*$R-*)

    CONST
      errbase = 640;
      axmit = 0;
      amodem = 1;
      arecv = 2;
      aerr = 3;

    TYPE
  (**)send_hs = (hw_hs, xmt_xon, xmit_delay);  (*transmit handshake type*)
  (**)recv_hs = (hwhs, rec_xon);  (*receive handshake type*)

  (**)int1ptr = ^int1;

  (**)int1recptr = ^int1rec;
  (**)int1rec = record
  (**)            controlreg: int1;
  (**)          end;


  (**)                reg0_type = record
  (**)                            case integer of
  (**)                            0: (byte: int1);
  (**)                            1: (bits: packed record
  (**)                               brk: boolean;
  (**)                               fill1: boolean; (*1-bit fill*)
  (**)                               cts: boolean;
  (**)                               dsr: boolean;
  (**)                               dcd: boolean;
  (**)                               fill2: -4..3  (*3-bit fill*)
  (**)                            end)
  (**)                 end;

      portrec_ptr = ^portrec;
      portrec = record
  (**)            frozen_addr: absptr; (*holds result of freeze_seg*)
  (**)            flags: record
  (**)                   case integer of
  (**)                   0: (byte: int1);
  (**)                   1: (bits: packed record
  (**)                               junk: -8..7; (*4 garbage bits*)
  (**)                               DCD_wait: boolean;
  (**)                               no_cur_req: boolean;
  (**)                               cur_read_flag: boolean;
  (**)                               xmit_wait: boolean;
                                       (*waiting for XON, modem signal or timeout*)
  (**)                             end)
  (**)                 end;
  (**)            restrt_out: boolean;
  (**)            prev_char: int1;
  (**)            autolf: boolean;
  (**)            lastwr1: int1; (*for use by ALLOW_OTHER and RESTORE *)
  (**)            hwcontrol: int1recptr;  (* actual I/O address *)
  (**)            cur_req_ptr: reqptr_type;
  (**)            sdb_ptr: absptr; (*copy of buff_rdb_ptr in req extent*)
  (**)            offset: absptr; (*copy of buff offset in req extent*)
  (**)            xfercnt: longint; (*copy of xfer_count in req extent*)
  (**)            numbytes: longint; (*coyp of num_bytes in req extent*)
  (**)            hi_speed: boolean; (*true when >= 4800 baud*)


                  (*MODEMA output variables*)

  (**)            xmt_hs: send_hs;  (*handshake for transmitting*)
  (**)            xmit_ref: integer;  (*timer refnum*)

                    (*xmt_hs = hw_hs or xmt_xon. (modem or xoff/xon handshake): *)
  (**)              xmit_timeout: longint;  (*hardware handshake timeout*)

                    (*xmt_hs = xmit_delay. (delay after CR, LF): *)
  (**)              crlfdelay: longint; (*timer count *)
  (**)              waitb4next: boolean; (*cr or lf was xmitted *)

                  (*MODEMA input variables*)

                    (*rec_hs = rec_xon. (send xoff/xon when threshhold reached): *)
  (**)              hschar_pending: (no_char, xoff_char, xon_char);

  (**)            strip_parity: boolean; (*TRUE when 8th bit gets zero'd*)
  (**)            size_typeah: 34..1024; (*size of type-ahead input buffer*)
  (**)            start_typeah, get_typeah, put_typeah: int1ptr; (*type ahead ptrs*)
  (**)            start_errbuf: absptr; (*equals start_typeah+size_typeah*)
  (**)            er_framing,er_parity,er_overrun,er_ovflow: longint; (*err counters*)
  (**)            er_lostcary: longint; (*more error counters*)
  (**)            rec_hs: recv_hs;  (*handshake for receiving*)
  (**)            last_stopped: boolean; (*XOFF last sent*)
  (**)            num_typeah: integer;  (*number of chars currently in buffer*)
  (**)            full_thresh: integer; (*threshhold for sending "buffer-full"*)
  (**)            wr5: record
  (**)                   case integer of
  (**)                   0: (byte: int1);
  (**)                   1: (bits: packed record
  (**)                               dtr: boolean;
  (**)                               eight: boolean;
  (**)                               fill1: boolean; (*1-bit fill*)
  (**)                               break: boolean;
  (**)                               fill2: -2..1;  (*2-bit fill*)
  (**)                               rts: boolean;
  (**)                               fill3: boolean; (*1-bit fill*)
  (**)                             end)
  (**)                 end;
  (**)            prior_rr0: reg0_type;
  (**)            rr0_changes: reg0_type;
  (**)            wr15: int1;
  (**)            await_tx: int1; (*for use by RESTORE*)
  (**)            allow_status: integer; (*int prio for ALLOW_OTHER, w/super bit set*)
                  empty_thresh: integer;(*threshhold for sending "buffer-empty"*)
                  input_ref: integer;   (*refnum for input timeout*)
                  input_timeout: longint; (* = 0 if no timeout*)
                  restrt_in: boolean;
                  no_block: boolean; (*blocking/non-blocking read mode*)
                  state:  (online, aborting, recovering, offline, waiting);
                  lost_carrier: boolean;
                  start_of_wait: longint;
                  modem_ref: integer;
                  recovery_timeout,carrier_timeout,answer_timeout: longint;
                  cur_info_ptr: seqextptr_type;
                  nullink: linkage;  (* points to head of queue *)

                  (*configuration state vars needed only for devcontrol #19*)
                  grp_a: integer;
                  grp_b: integer;
                  grp_c: longint;
               end;


      procedure RSOUT (port: portrec_ptr); external; (*replaces byteo*)

      procedure FINISH_REQ (port: portrec_ptr; ok_flag: boolean); forward;

      procedure WR_SCC (regno: int1; val: int1; port_ptr: portrec_ptr); external;

      procedure FINDBIT(var newlen: integer; base: absptr; start: integer;
                             len: integer; size: integer); external;

      procedure ALLOW_OTHER (port_ptr: portrec_ptr; var prevstatus: intson_type);
                                                                        external;
      procedure RESTORE (port_ptr: portrec_ptr; prevstatus: intson_type); external;

      procedure COPYBYTES (*port_ptr: absptr*);
       (*************************************************************)
       (*                                                           *)
       (* Description:  Copy bytes from typeahead buffer to user buffer*)
       (*                                                           *)
       (* Input Parameters:  Port points to the current port in the *)
       (*         MODEMA device control block.                      *)
       (*                                                           *)
       (* Output Parameters:                                        *)
       (*                                                           *)
       (* Side Effects:                                             *)
       (*                                                           *)
       (* Special Conditions of Use:  RS-232 interrupts must be off.*)
       (*                                                           *)
       (* Error Conditions:                                         *)
       (*                                                           *)
       (*************************************************************)

      VAR
        i, errnum, cnt: integer;
        data_ptr: int1ptr;
        real_addr: longint;
        port: portrec_ptr;

      begin
        port := pointer(port_ptr);
        WITH port^ do
        begin
          i := numbytes - xfercnt;
          if i > num_typeah then
            i := num_typeah + 1; (*look for error @ end if reading past end*)
          FINDBIT(cnt, start_errbuf, ord(get_typeah)-ord(start_typeah),
                  i, size_typeah); (*see if there are any errors for this data*)
          if i <> cnt then
            cur_req_ptr^.hard_error := errbase+3;

          if cnt > num_typeah then
            cnt := num_typeah; (*re-adjust for read-past-end case*)

          if cnt > 0 then
          begin
              FREEZE_SEG (errnum, sdb_ptr, offset, ord(cur_req_ptr), real_addr);
              if errnum <> 0 then
                restrt_in := true
              else
              begin (*transfer typed-ahead characters to user buffer*)
                data_ptr := pointer(real_addr + xfercnt);
                i := ord(get_typeah) + cnt - start_errbuf; (*# wraparound chars*)
                if i < 0 then (*transfer all chars in single move of length "cnt"*)
                  i := cnt
                else
                begin (*transfer requires two moves*)
                  moveleft (get_typeah^, data_ptr^, cnt - i);
                  data_ptr := pointer (ord(data_ptr) + cnt - i);
                  get_typeah := start_typeah
                end;
                moveleft (get_typeah^, data_ptr^, i);
                get_typeah := pointer (ord(get_typeah) + i);

                UNFREEZE_SEG (sdb_ptr); (*allow buffer to move*)
                num_typeah := num_typeah - cnt;
                if last_stopped then
                  if num_typeah <= empty_thresh then (*allow input*)
                  begin
                    last_stopped := false;
                    hschar_pending := xon_char;
                    RSOUT (port);
                  end;
                xfercnt := xfercnt + cnt
              end;
            end;

            if cur_req_ptr^.hard_error <> 0 then
              FINISH_REQ (port, false)
            else
              if (xfercnt = numbytes) or no_block then (*read complete*)
                FINISH_REQ (port, true)
              else
                if input_timeout > 0 then
                  ALARMRELATIVE (input_ref, input_timeout);
        end
      end; (*copybytes*)


      procedure START_NEW_REQUEST (port: portrec_ptr);
       (*************************************************************)
       (*                                                           *)
       (* Description:  Start a new read or write from the queue.   *)
       (*                                                           *)
       (* Input Parameters:  Port points to the current port in the *)
       (*         MODEMA device control block.                      *)
       (*                                                           *)
       (* Output Parameters:  none                                  *)
       (*                                                           *)
       (* Side Effects:  Modem control signals are affected.        *)
       (*                                                           *)
       (* Special Conditions of Use:  MODEMA interrupts must be off.*)
       (*                                                           *)
       (* Error Conditions:                                         *)
       (*                                                           *)
       (*************************************************************)

      VAR
        r0: reg0_type;

      begin
        WITH port^ do
          begin
            cur_req_ptr := CHAIN_FORWARD (nullink);
            flags.bits.no_cur_req := false;
            cur_req_ptr^.reqstatus.reqsrv_f := in_service;
            cur_info_ptr := pointer (cur_req_ptr^.req_extent);
            WITH cur_info_ptr^ do
            begin
              sdb_ptr := buff_rdb_ptr;
              offset := buff_offset;
              numbytes := num_bytes;
              if read_flag then
                flags.bits.cur_read_flag := true
              else
                flags.bits.cur_read_flag := false;
              xfercnt := 0;
              if state <> online then
              begin  (*abort this request*)
                flags.bits.xmit_wait := false;  (*fixes bug*)
                cur_req_ptr^.hard_error := errbase + 8;
                FINISH_REQ (port, false)
              end
              else (*start up i/o for new request*)
                if flags.bits.cur_read_flag then
                  COPYBYTES (ord(port))
                else (*write*)
                begin
                  waitb4next := false;
                  if flags.bits.dcd_wait then
                    lost_carrier := true
                  else
                  begin
                    lost_carrier := false;
                    r0.byte := hwcontrol^.controlreg; (*read RR0 on SCC*)
                    if flags.bits.xmit_wait or not r0.bits.cts then
                    begin (*last received xoff, or cts off*)
                      flags.bits.xmit_wait := true;
                      if xmit_timeout > 0 then
                        ALARMRELATIVE (xmit_ref, xmit_timeout)
                    end
                    else
                      RSOUT (port)
                  end
                end
            end
          end
      end;  (*start_new_request*)

       procedure FINISH_REQ (*port: portrec_ptr; ok_flag: boolean*);
       (*************************************************************)
       (*                                                           *)
       (* Description:  Complete the current request                *)
       (*                                                           *)
       (* Input Parameters:  Port points to the current port in the *)
       (*         MODEMA device control block. Ok-flag is param to  *)
       (*         UNBLK_REQ.                                        *)
       (* Output Parameters:  none                                  *)
       (*                                                           *)
       (* Side Effects:  Modem control signals are affected.        *)
       (*                                                           *)
       (* Special Conditions of Use:  Cur_req_ptr must be valid.    *)
       (*                                                           *)
       (* Error Conditions:                                         *)
       (*                                                           *)
       (*************************************************************)

      VAR
        err: integer;
        ptrsysg: ^longint;

      begin
          ptrsysg := pointer(bsysglob);   (*set up pointer to b_sysglobal_ptr*)
          WITH port^, cur_req_ptr^ do
          begin
            ADJ_IO_CNT (false, sdb_ptr);  (*allow swapout*)
            if lost_carrier then
            begin
              lost_carrier := false;
              if ok_flag then
                hard_error := -650; (*warning: lost carrier during xmit*)
              UNBLK_REQ (cur_req_ptr, false);
            end
            else
              UNBLK_REQ (cur_req_ptr, ok_flag);
            DEQUEUE (dev_chain, ptrsysg^);
            cur_info_ptr^.xfer_count := xfercnt;
            if flags.bits.xmit_wait then
              ALARMOFF (xmit_ref);
            if flags.bits.cur_read_flag then
            begin
              if input_timeout > 0 then
                ALARMOFF (input_ref);
              restrt_in := false (*prevent reqrestart after completion. fixes bug*)
            end
            else (*write*)
            begin
              if hschar_pending = no_char then
                restrt_out := false; (*fixes bug*)
                if frozen_addr <> ord(nil) then
                begin
                  UNFREEZE_SEG (sdb_ptr);
                  frozen_addr := ord(nil);
                end
            end;
            if (nullink.fwd_link + ptrsysg^) <> ord(@nullink) then
              START_NEW_REQUEST (port)
            else
              flags.bits.no_cur_req := true
          end
      end; (*finish_req*)


       procedure XMT_TO_HNDL (port: portrec_ptr);
       (*************************************************************)
       (*                                                           *)
       (* Description:  Timeout handler when waited too long for    *)
       (*     resuming output to MODEMA channel A, or Delaying *)
       (*     after transmitting CR or LF.                          *)
       (*                                                           *)
       (* Input Parameters:  pointer to data for Port A or B        *)
       (*                                                           *)
       (* Output Parameters:  none                                  *)
       (*                                                           *)
       (* Side Effects:  completes the request with an error        *)
       (*                                                           *)
       (* Special Conditions of Use:                                *)
       (*                        Called with all ints off.          *)
       (* Error Conditions:                                         *)
       (*                                                           *)
       (*************************************************************)

       VAR
         ptrsysg: ^longint;

       begin
         WITH port^ do
           if wr5.bits.break then
           begin
             wr5.bits.break := false;
             case state of
             online:
               begin (*remove from break state*)
                 WR_SCC (5, wr5.byte, port);
                 ptrsysg := pointer (bsysglob);
                 if (nullink.fwd_link + ptrsysg^) <> ord(@nullink) then
                   START_NEW_REQUEST (port) (*start next pending request*)
               end;
             recovering:
               begin
                 state := offline;
                 WR_SCC (5, wr5.byte, port);
               end;
             waiting:
               begin
                 wr5.bits.dtr := true;
                 wr5.bits.rts := true;
                 WR_SCC (5, wr5.byte, port);
                 ALARMRELATIVE (modem_ref, 1000); (*poll dcd, dsr every sec*)
               end;
             end (*case*)
           end
           else
             if flags.bits.xmit_wait then
               if not flags.bits.no_cur_req then
               begin
                 if xmt_hs = xmit_delay then  (*time up after CR or LF*)
                 begin
                   flags.bits.xmit_wait := false;
                   if xfercnt < numbytes then
                     RSOUT (port)  (*send next byte out*)
                   else  (*complete previous request*)
                     FINISH_REQ (port, true)
                 end
                 else
                 begin  (*handshake has been delayed too long*)
                   cur_req_ptr^.hard_error := errbase + 7;
                   FINISH_REQ (port, false)
                 end
               end
       end; (*xmt_to_hndl*)


      function MODEMA(*parameters: param_ptr): integer*);
       (*************************************************************)
       (*                                                           *)
       (* Description:  MODEMA external interface via DRIVERCALL    *)
       (*                                                           *)
       (* Input Parameters:  Parameters depend on function code     *)
       (*                                                           *)
       (* Output Parameters:  Function returns integer errnum.      *)
       (*                                                           *)
       (* Side Effects:                                             *)
       (*                                                           *)
       (* Special Conditions of Use:  none                          *)
       (*                                                           *)
       (* Error Conditions:                                         *)
       (*                                                           *)
       (*************************************************************)

      VAR
        prevstat: intson_type;
        port_ptr: portrec_ptr;
        ptrsysg: ^longint;
        r0: reg0_type;
        i1: int1;
        i: integer;
        p: params;
        dcrec: dc_rec;


      procedure INITIT;
       (*************************************************************)
       (*  internal procedure to handle initialize "case" and reduce*)
       (*    code size of main MODEMA procedure                     *)
       (*************************************************************)

      VAR
        ptrsysg: ^longint;
        err,i: integer;
        temp : longint;
        p: params;
        dcrec: dc_rec;

      begin
            err := 0;
            ptrsysg := pointer(bsysglob);   (*set up pointer to b_sysglobal_ptr*)
            if not GETSPACE (sizeof(portrec), ptrsysg^, temp) then
              err := errbase + 6
            else
            begin
              parameters^.configptr^.cb_addr := temp;
              port_ptr := pointer(temp)
            end;

            (* initialize either port A or B *)

            if err = 0 then
            WITH parameters^, port_ptr^ do
              begin
                case configptr^.slot_no of
                0: begin (*slot 1 at int prio 5*)
                     i := ord(configptr^.iochannel=0); (*channel reversed*)
                     hwcontrol := pointer (iospacemmu*$20000 + $2003);
                     allow_status := $2400 (*set one lower than priority*)
                   end;
                1: begin (*slot 2 at int prio 4*)
                     i := ord(configptr^.iochannel=0); (*channel reversed*)
                     hwcontrol := pointer (iospacemmu*$20000 + $6003);
                     allow_status := $2300
                   end;
                2: begin (*slot 3 at int prio 3*)
                     i := ord(configptr^.iochannel=0); (*channel reversed*)
                     hwcontrol := pointer (iospacemmu*$20000 + $0A003);
                     allow_status := $2200
                   end;
                otherwise begin (*built-in at int prio 6*)
                     i := configptr^.iochannel;
                     hwcontrol := pointer (iospacemmu*$20000 + $0D203);
                     allow_status := $2500
                   end;
                end; (*case*)

                if i <> 0 then
                begin (*only channel A works with this driver*)
                  RELSPACE (ord(port_ptr), ptrsysg^);
                  err := errbase + 6;
                end
                else
                begin
                  state := offline;
                  lastwr1 := 0; (*causes next ALLOW_OTHER to not enable ints in WR1*)
                  flags.byte := 0; (*xmit_wait, dcd_wait, cur_read_flag := false*)
                  flags.bits.no_cur_req := true;
                  i := hwcontrol^.controlreg; (*make sure initially writes to reg 0*)
                  WR_SCC (9, -118, port_ptr);  (* = $8a, reset chan A*)

                  WR_SCC (4, $44, port_ptr);  (*set operating mode*)

                  WR_SCC (11, $50, port_ptr); (*Port A uses baud rate generator*)

                  (*set baud rate*)

                  p.configptr := configptr;
                  p.fnctn_code := dcontrol;
                  dcrec.dversion := 2;
                  dcrec.dcode := 5;
                  dcrec.ar10[0] := 1200;
                  p.parptr := ord(@dcrec);
                  i := MODEMA (@p);  (*call internal device control routine*)

                  WR_SCC (10, 0, port_ptr);

                  WR_SCC (3, -31, port_ptr);  (*set receiver state to $E1*)

                  wr5.byte := $68;
                  WR_SCC (5, wr5.byte, port_ptr);  (*set to standard modem signals*)

                  wr15 := -72; (*=$B8: brk, sync, cts, dcd*)
                  WR_SCC (15, wr15, port_ptr);

                  hwcontrol^.controlreg := $10; (*reset modem latch*)

                  er_framing := 0;
                  er_parity := 0;
                  er_overrun := 0;
                  er_ovflow := 0;
                  er_lostcary := 0;
                  recovery_timeout := 10000; (*10 seconds*)
                  carrier_timeout := 25;
                  answer_timeout:= 30000000; (*30 seconds*)
                  prior_rr0.byte := 0;
                  await_tx := 0;
                  grp_a := 0;
                  grp_b := 11;
                  restrt_in := false;
                  restrt_out := false;
                  prev_char := 0;
                  frozen_addr := ord(nil);
                  autolf := false;
                  nullink.fwd_link := ord(@nullink) - ptrsysg^;
                  nullink.bkwd_link := nullink.fwd_link;
                  xmt_hs := hw_hs;

                  (*receiver initializations*)

                  no_block := true;
                  rec_hs := hwhs;
                  strip_parity:= false;
                  last_stopped := false;
                  input_timeout := 0;
                  xmit_timeout := 20000;  (*20 seconds*)
                  ALARM_ASSIGN(xmit_ref, configptr, rsints);
                  if xmit_ref = 0 then
                  begin
                    err := 602; (*timer table full*)
                    RELSPACE (ord(port_ptr), ptrsysg^)
                  end
                  else
                  begin
                    ALARM_ASSIGN(modem_ref, configptr, rsints);
                    if modem_ref = 0 then
                    begin
                      err := 602; (*timer table full*)
                      ALARMRETURN (xmit_ref);
                      RELSPACE (ord(port_ptr), ptrsysg^)
                    end
                    else
                    begin  (*initialize type-ahead buffer*)
                      size_typeah := 0; (*temporary value*)
                      p.configptr := configptr;
                      p.fnctn_code := dcontrol;
                      dcrec.dversion := 2;
                      dcrec.dcode := 9;
                      dcrec.ar10[0] := 64; (*size of typeahead buffer*)
                      dcrec.ar10[1] := 16; (*low threshhold*)
                      dcrec.ar10[2] := 32; (*high threshhold*)
                      p.parptr := ord(@dcrec);
                      if MODEMA (@p) > 0 then (*calls internal device control routine*)
                      begin (*device control error*)
                        ALARMRETURN (xmit_ref);
                        ALARMRETURN (modem_ref);
                        RELSPACE (ord(port_ptr), ptrsysg^);
                        err := errbase + 6
                      end
                    end
                  end
                end
              end;
          MODEMA := err
      end; (*initit*)



      procedure CONTROLIT;
       (*************************************************************)
       (*  internal procedure to handle DCONTROL "case" and reduce  *)
       (*    code size of main MODEMA procedure                     *)
       (*************************************************************)

      VAR
        speed: integer;
        ptrsysg,longptr: ^longint;
        temp : longint;
        dc_rec_ptr: ^dc_rec;
        reqptr: reqptr_type;
        prevstat: intson_type;

      begin
        WITH parameters^ do
          begin
            MODEMA := 0;
            dc_rec_ptr := pointer(parptr);
            ALLOW_OTHER (port_ptr, prevstat);
            WITH port_ptr^, dc_rec_ptr^ do
              if dversion <> 2 then
                MODEMA := errbase + 0 (*wrong application version*)
              else
              case dcode of
              1: begin  (*set parity and leave break-state*)
                   strip_parity := true;
                   wr5.bits.eight := false;
                   wr5.bits.break := false;

                   grp_a := ar10[0];
                   case grp_a of
                   0,5: begin (*no parity(0) or odd parity(5),
                                8 data, 1 stop, leave input bit 7*)
                        if grp_a=0 then
                          WR_SCC (4, $44, port_ptr)
                        else
                          WR_SCC (4, $45, port_ptr);
                        WR_SCC (3, -31, port_ptr); (* =$E1 *)
                        wr5.bits.eight := true;
                        strip_parity := false
                      end;
                   1,2: begin (*odd parity, 7 data, 1 stop, strip input bit 7*)
                        WR_SCC (4, $45, port_ptr);
                        WR_SCC (3, $61, port_ptr);
                      end;
                   3,4: begin (*even parity, 7 data, 1 stop, strip input bit 7*)
                        WR_SCC (4, $47, port_ptr);
                        WR_SCC (3, $61, port_ptr);
                      end;
                   6: begin (*no parity, strip input bit 7, 8 data 1 stop*)
                        WR_SCC (4, $44, port_ptr);
                        WR_SCC (3, -31, port_ptr); (* =$E1 *)
                        wr5.bits.eight := true;
                      end;
                   end; (*case*)

                   WR_SCC (5, wr5.byte, port_ptr);
                 end;

              2,11: begin (*set up for no handshake on output*)
                   grp_b := 11;
                   xmt_hs := hw_hs;
                   last_stopped := false;
                   flags.bits.xmit_wait := false  (*clear xoff state. fixes bug*)
                  end;

              3:  if not flags.bits.no_cur_req then
                    MODEMA := errbase + 9 (*don't change xmt_hs during I/O*)
                  else
                  begin (*set up for xon xoff handshake on output*)
                   grp_b := 3;
                   xmt_hs := xmt_xon;
                   flags.bits.xmit_wait := false  (*put in xon state. fixes bug*)
                 end;

              4: begin  (*set up for delay on cr lf *)
                   xmt_hs := xmit_delay;
                   crlfdelay := ar10[0];
                   grp_b := -crlfdelay;
                   flags.bits.xmit_wait := false  (*clear xoff state. fixes bug*)
                 end;

              5: begin  (*set baud rate *)
                   grp_c := ar10[0];
                   hi_speed := (grp_c >= 4800);
                   temp := 125000; (*constant for baud rate computation*)
                   speed := ( temp DIV grp_c ) - 2;
                   WR_SCC (14, 0, port_ptr); (*turn off baud rate generator*)
                   WR_SCC (12, speed, port_ptr); (*lsb*)
                   WR_SCC (13, speed DIV 256, port_ptr); (*msb*)
                   WR_SCC (14, 3, port_ptr)
                 end;

              6: no_block := (ar10[0] <> 0); (*set input blocking/not-blocking mode*)

              7: rec_hs := hwhs;   (*set input mode to hardware handshake*)

              8: begin  (*set input mode to xon/xoff*)
                   rec_hs := rec_xon;
                   if num_typeah >= full_thresh then
                   begin
                     last_stopped := true;
                     hschar_pending := xoff_char;
                     RSOUT (port_ptr);
                   end
                   else
                   begin
                     last_stopped := false;
                     hschar_pending := xon_char;
                     RSOUT (port_ptr);
                   end;
                 end;
              9: begin (*flush and redefine typeahead buffer*)
                   num_typeah := 0;
                   get_typeah := put_typeah;
                   hschar_pending := no_char;
                   if last_stopped then
                   begin
                     last_stopped := false;
                     hschar_pending := xon_char;
                     RSOUT (port_ptr);
                   end;
                   ptrsysg := pointer (bsysglob);
                   if ar10[0] >= 0 then
                   begin (*allocate new buffer*)
                     if size_typeah > 0 then
                       RELSPACE (ord(start_typeah), ptrsysg^);
                     size_typeah := ar10[0];
                     if size_typeah < 34 then
                       size_typeah := 34 (*min size required by FINDBIT*)
                     else
                       if odd(size_typeah) then (*forces start_errbuf to even addr*)
                         size_typeah := size_typeah+1;

                     (*next allocate input byte buffer and corresponding
                       bit array of error flags -- one bit for each input byte.
                       The bit array begins at the end of the input byte buffer*)

                     if not GETSPACE (size_typeah + ((size_typeah+31) DIV 8),
                                                              ptrsysg^, temp) then
                       MODEMA := errbase + 6
                     else
                     begin
                         start_typeah := pointer (temp);
                         get_typeah := start_typeah;
                         put_typeah := get_typeah;
                         start_errbuf := temp + size_typeah;
                     end
                   end;

                   (*zero out error buffer that follows typeahead buffer*)

                   longptr := pointer(start_errbuf);
                   longptr^ := 0;
                   ptrsysg := pointer(start_errbuf+4);
                   moveleft (longptr^, ptrsysg^, (size_typeah-1) DIV 8 );

                   if ar10[1] >= -1 then (*-2 means don't change, -1 means disable*)
                     empty_thresh := ar10[1];
                   if ar10[2] >= -1 then (*-2 means don't change, too big means disable*)
                     full_thresh := ar10[2]
                 end;

              10: ; (*discon detect calls ignored*)

              12: xmit_timeout := ar10[0] * 1000;
                  (*set transmit-handshake timeout in seconds. =0 is infinite*)

              13:  (*put into break state for specified period of time*)
                if (state = online) or (state = aborting) then
                  if not flags.bits.no_cur_req then
                    MODEMA := errbase + 9 (*don't start break during I/O*)
                  else
                  begin
                      ALARMRELATIVE (xmit_ref, ar10[0]); (*remain in break state until
                                                        alarm or dcontrol 1*)
                      wr5.bits.break := true; (*enable break*)
                      if ar10[1] <> 0 then
                      begin
                        wr5.bits.dtr := false; (*no DTR*)
                        wr5.bits.rts := false;
                        state := recovering;
                        ALARMOFF (modem_ref);
                        i1 := prevstat; (*truncate to just low byte*)
                        prevstat := prevstat - i1; (*no more interrupts port A*)
                      end;
                      WR_SCC (5, wr5.byte, port_ptr) (*enable receive handshake signals*)
                  end;

              14: begin  (*set input timeout in seconds. =0 is infinite*)
                    if input_timeout > 0 then
                      ALARMRETURN (input_ref);
                    input_timeout := ar10[0] * 1000;
                    if input_timeout > 0 then
                    begin
                      ALARM_ASSIGN(input_ref, configptr, rsints);
                      if input_ref = 0 then
                      begin
                        input_timeout := 0;
                        MODEMA := 602
                      end
                    end
                  end;

              17: autolf := (ar10[0] <> 0);  (*enable/disable auto LF*)

              18: begin (*read and clear error buckets*)
                    ar10[0] := er_framing;
                    ar10[1] := er_parity;
                    ar10[2] := er_overrun;
                    ar10[3] := er_ovflow;
                    ar10[4] := er_lostcary;
                    er_framing := 0;
                    er_parity := 0;
                    er_overrun := 0;
                    er_ovflow := 0;
                    er_lostcary := 0;
                  end;

              19: begin (*return configured state*)
                    ar10[0] := grp_a;
                    ar10[1] := grp_b;
                    ar10[2] := grp_c;
                    temp := ord(rec_hs)+7;
                    if no_block then
                      temp := temp + $10000;
                    ar10[3] := temp;
                    ar10[4] := size_typeah;
                    ar10[5] := $10000*empty_thresh + full_thresh;
                    ar10[6] := xmit_timeout DIV 1000;
                    ar10[7] := ord(autolf) + $10000;
                    ar10[8] := input_timeout DIV 1000;
                    ar10[9] := num_typeah;
              end;

              22: begin (*set timeouts*)
                recovery_timeout := ar10[0];
                carrier_timeout := ar10[1];
                answer_timeout := ar10[2]*1000;
              end;

              23: begin
                ar10[0] := recovery_timeout;
                ar10[1] := carrier_timeout;
                ar10[2] := answer_timeout DIV 1000;
                ar10[3] := ord(state=online);
              end;

              24: case state of (*establish connection to modem*)
                waiting: MODEMA := errbase + 9; (*already waiting for modem*)

                recovering,offline:
                begin (*create a request and block current process*)
                  ptrsysg := pointer(bsysglob);
                  if not GETSPACE(sizeof(reqblk), ptrsysg^, temp) then
                    MODEMA := errbase + 6
                  else
                  begin
                    reqptr := pointer (temp);  (*point to the request*)
                    cur_req_ptr := reqptr;
                    WITH reqptr^ do
                    begin
                      cfigptr := configptr;
                      req_extent := ord(nil);    (*no extension block present*)
                      LINK_TO_PCB (reqptr);
                      if state = offline then
                      begin
                        wr5.bits.dtr := true;
                        wr5.bits.rts := true;
                        WR_SCC (5, wr5.byte, port_ptr);
                        ALARMRELATIVE (modem_ref, 1000); (*poll dcd, dsr every sec*)
                      end;
                      state := waiting;
                      hwcontrol^.controlreg := $10; (*reset modem latches*)
                      start_of_wait := MICROTIMER;
                      INTSON (prevstat); (*interrupts on instead of RESTORE*)

                      with list_chain do               (* set up request block linkage *)
                      begin
                        fwd_link := ord(@fwd_link) - ptrsysg^;
                        bkwd_link := fwd_link
                      end;
                      BLK_REQ(reqptr,reqptr);
                      if not reqptr^.reqstatus.reqsuccess_f then
                        MODEMA:= reqptr^.hard_error;
                      CANCEL_REQ(reqptr);
                    end;
                    EXIT (controlit)
                  end
                end; (*recovering,offline*)

                end; (*case*)

              otherwise
                MODEMA := errbase + 9;
            end;  (*case*)

          RESTORE (port_ptr, prevstat);
        end
    end; (*controlit*)

      procedure STARTIT;
       (*************************************************************)
       (*  internal procedure to handle SEQIO "case"                *)
       (*************************************************************)

      VAR
        ptrsysg: ^longint;
        leftlink: link_ptr;
        ext_ptr: seqextptr_type;
        cnt: integer;

      begin
        WITH parameters^, req^ do
          begin
            ext_ptr := pointer (req_extent);
            WITH ext_ptr^ do
            if num_bytes <= 0 then
              MODEMA := errbase + 1  (*illegal parameters *)
            else
            begin
              WITH port_ptr^ do
              begin (* add request to the device queue or finish the request now*)
                MODEMA := 0;  (*no errors*)
                ptrsysg := pointer(bsysglob);   (*set pointer to b_sysglobal_ptr*)
                ALLOW_OTHER (port_ptr, prevstat);
                leftlink := pointer (nullink.bkwd_link + ptrsysg^);
                if (state <> online) or
                 ( read_flag and no_block and
                   ((num_typeah = 0) or (leftlink <> @nullink)) ) then
                begin (*ok to complete request since non-blocking read w/o char*)
                  ADJ_IO_CNT (false, buff_rdb_ptr);
                  if state <> online then
                  begin  (*return with error when offline*)
                    flags.bits.xmit_wait := false;
                    hard_error := errbase + 8;
                  end
                  else
                    if num_typeah = 0 then
                    begin (*about to unblock with no data..see if rec'd error*)
                      FINDBIT(cnt, start_errbuf, ord(get_typeah)-ord(start_typeah),
                        1, size_typeah);
                      if cnt = 0 then (*yes, have input error*)
                        hard_error := errbase+3
                    end;
                  UNBLK_REQ (req, (hard_error = 0) )
                end
                else
                begin
                  ENQUEUE (dev_chain, leftlink^, ptrsysg^);
                  if flags.bits.no_cur_req then
                    if not wr5.bits.break then
                     START_NEW_REQUEST (port_ptr);
                end;
                RESTORE (port_ptr, prevstat);
              end
            end
          end
      end; (*startit*)

      procedure BREAKOFF;
       (*************************************************************)
       (*  internal procedure to call break & lower DTR             *)
       (*************************************************************)

       VAR
         i: integer;

       begin
          p.configptr := parameters^.configptr;
          p.fnctn_code := dcontrol;
          dcrec.dversion := 2;
          dcrec.dcode := 13;
          dcrec.ar10[0] := port_ptr^.recovery_timeout;
          dcrec.ar10[1] := 1;
          p.parptr := ord(@dcrec);
          i := MODEMA (@p);  (*call internal device control routine*)
        end; (*breakoff*)

      begin (*MODEMA*)
        port_ptr := pointer(parameters^.configptr^.cb_addr);

        WITH parameters^ do
        case fnctn_code of
        seqio:  STARTIT;

        dinit:  INITIT;  (*call subroutine to reduce size of MODEMA*)

        dcontrol:  CONTROLIT; (*call subroutine to reduce size *)

        dalarms:
        WITH port_ptr^ do
        begin
          ALLOW_OTHER (port_ptr, prevstat);
          if intpar = xmit_ref then
            XMT_TO_HNDL (port_ptr) (*output alarm routine*)
          else
            if intpar = input_ref then
            begin
              if not flags.bits.no_cur_req then
                if flags.bits.cur_read_flag then
                begin
                  cur_req_ptr^.hard_error := errbase + 4;
                  FINISH_REQ (port_ptr, false)
                end;
            end
            else
              if intpar = modem_ref then
              begin
                if state = waiting then
                begin
                  hwcontrol^.controlreg := $10; (*reset modem latches*)
                  i := -128; (*delay*)
                  r0.byte := hwcontrol^.controlreg;
                end;
                if (state = waiting) and
                   r0.bits.dsr and r0.bits.dcd and not r0.bits.brk and
                  ((xmt_hs = hw_hs) or r0.bits.cts) then
                  begin (*Safe to make online. Initialize some vars.*)
                    state := online;
                    prior_rr0 := r0;
                    flags.byte := 0;
                    flags.bits.no_cur_req := true;
                    if not r0.bits.cts then
                      flags.bits.xmit_wait := true;
                    await_tx := 0;
                    prev_char := 0;
                    er_framing := 0;
                    er_parity := 0;
                    er_overrun := 0;
                    er_ovflow := 0;
                    er_lostcary := 0;
                    p.configptr := configptr;
                    p.fnctn_code := dcontrol;
                    dcrec.dversion := 2;
                    dcrec.dcode := 9;
                    dcrec.ar10[0] := -1; (*flush typeahead buffer*)
                    dcrec.ar10[1] := -2;
                    dcrec.ar10[2] := -2;
                    p.parptr := ord(@dcrec);
                    i1 := MODEMA (@p); (*calls internal device control routine*)
                    UNBLK_REQ(cur_req_ptr, true);
                    prevstat := $0617 (*cause ALLOW_OTHER to enable port A ints*)
                  end
                  else
                    if (state = waiting) and
                       ( (MICROTIMER - start_of_wait) < answer_timeout ) then
                      ALARMRELATIVE (modem_ref, 1000) (*poll dcd, dsr every sec*)
                    else
                    begin (*disconnect because not answered or carrier-loss T/O*)
                      if state = waiting then
                      begin
                        cur_req_ptr^.hard_error := errbase+5;
                        UNBLK_REQ (cur_req_ptr, false);
                      end;
                      state := aborting;
                      if not flags.bits.no_cur_req then
                      begin
                        cur_req_ptr^.hard_error := errbase + 8;
                        FINISH_REQ (port_ptr, false)
                      end;
                      BREAKOFF;
                      INTSON (prevstat);  (*instead of RESTORE, leaving wr0 off*)
                      EXIT (modema)
                    end
              end;
            RESTORE (port_ptr, prevstat);
        end; (*dalarms*)

        dinterrupt: (*ignore returned function value for ints*)
         WITH port_ptr^, hwcontrol^ do
         begin
          case intpar of

          axmit:  (*assembly language intercepts this and executes a bunch of
                    stuff before ever getting here! *)
                  FINISH_REQ (port_ptr, true);

          amodem: begin
                if ((xmt_hs <> hw_hs) and not prior_rr0.bits.cts)
                   or prior_rr0.bits.brk or not prior_rr0.bits.dsr then
                begin (*put offline*)
                  state := aborting;
                  if not flags.bits.no_cur_req then
                  begin
                    cur_req_ptr^.hard_error := errbase + 8;
                    FINISH_REQ (port_ptr, false)
                  end;
                  BREAKOFF;
                  INTSON (rsints);  (*instead of RESTORE, leaving wr0 off*)
                  EXIT (modema)
                end
                else
                begin
                  if rr0_changes.bits.dcd then
                    if prior_rr0.bits.dcd then
                    begin (*DCD just came back on*)
                      ALARMOFF (modem_ref);
                      flags.bits.DCD_wait := false;
                      if flags.byte = 0 then
                        (*no_cur_req,cur_read_flag,dcd_wait and xmit_wait all false*)
                        RSOUT (port_ptr)
                    end
                    else
                    begin (*lost DCD. Assemb lang already flagged input error.*)
                      flags.bits.DCD_wait := true;
                      ALARMRELATIVE (modem_ref, carrier_timeout);
                      lost_carrier := true;
                    end;
                  if rr0_changes.bits.cts then
                    if prior_rr0.bits.cts then
                    begin  (*CTS just came back on*)
                      flags.bits.xmit_wait := false;
                      ALARMOFF (xmit_ref);
                      if flags.byte = 0 then
                      (*no_cur_req,cur_read_flag,dcd_wait and xmit_wait all false*)
                        RSOUT (port_ptr)
                    end
                    else
                    begin  (*lost CTS*)
                      flags.bits.xmit_wait := true;
                      if not flags.bits.no_cur_req then
                        if not flags.bits.cur_read_flag then
                        begin
                          if xmit_timeout > 0 then
                            ALARMRELATIVE (xmit_ref, xmit_timeout);
                          if frozen_addr <> ord(nil) then
                          begin
                            UNFREEZE_SEG (sdb_ptr);
                            frozen_addr := ord(nil);
                          end
                        end
                    end
                end;
              end; (*amodem*)

          (*aerr and arecv cases are handled in assembly language*)

          end;  (*case*)

          RESTORE(port_ptr, $0617) (*for interrupts, restore ints to 6, WR1 to 17*)
        end;  (*dinterrupt*)

        reqrestart:
          begin
            MODEMA := 0;
            WITH port_ptr^ do
            begin
              ALLOW_OTHER (port_ptr, prevstat);
              if restrt_in then
              begin
                COPYBYTES (ord(port_ptr));
                restrt_in := false
              end;
              if restrt_out then
              begin
                RSOUT (port_ptr);
                restrt_out := false
              end;
              RESTORE (port_ptr, prevstat);
            end
          end; (*reqrestart*)

        ddown: begin
          MODEMA := 0;
          WITH port_ptr^ do
          begin
            if not flags.bits.no_cur_req then
              MODEMA := 607
            else
            begin
              ALLOW_OTHER (port_ptr, prevstat);
              ptrsysg := pointer(bsysglob);   (*set up pointer to b_sysglobal_ptr*)
              if size_typeah > 0 then
                RELSPACE (ord(start_typeah), ptrsysg^);
              ALARMRETURN (modem_ref);
              ALARMRETURN (xmit_ref);
              if input_timeout > 0 then
                ALARMRETURN (input_ref);
              WR_SCC (9, -118, port_ptr); (*=$8A*)
              configptr^.cb_addr := ord(nil);
              RELSPACE (ord(port_ptr), ptrsysg^);
              INTSON (prevstat) (*no more interrupts*)
            end
          end;
        end;

        ddiscon: BREAKOFF; (*called during close*)

        otherwise
          MODEMA := errbase + 2;   (*currently unimplemented w/ error*)
        end;  (*case*)
      end; (*MODEMA*)

   end.


