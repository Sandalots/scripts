(*********************************************************************************)
(*                                                                               *)
(*  (c) copyright 1983, 1984  Apple Computer Inc.                                *)
(*                                                                               *)
(*********************************************************************************)

UNIT  volcheck;

INTERFACE

  (*$U- *)

  {$SETC MONfs := FALSE}  (* for compiling under Monitor   *)
  {$SETC LDSfs := TRUE}   (* for compiling under Workshop  *)

  USES

    {$IFC MONfs}
    (*$U object : driverdefs.obj*)         driverdefs,
    (*$U object : sysglobal.obj *)         globalda,
    (*$U object : procprims.obj *)         proc_prims,
    (*$U object : mmprim.obj    *)         mmprimitives,
    (*$U object : asynctr.obj   *)         asynctr,
    (*$U object : genio.obj     *)         genio,
    (*$U object : twiggy.obj    *)         twiggy,
    (*$U object : vmstuff.obj   *)         vmstuff,
    (*$U object : sfileio.obj   *)         sfileio,
    (*$U object : fsprim.obj    *)         fs_primitives,
    (*$U object : objio.obj     *)         objio,
    (*$U object : mm0.obj       *)         memorymanager,
    (*$U object : ds0.obj       *)         datasegs,
    (*$U object : fsui.obj      *)         fs_interface,
    (*$U object : clock.obj     *)         clock,
    (*$U object : exceprim.obj  *)         exceprim,
    (*$U object : eventchn.obj  *)         eventchn,
    (*$U object : timemgr.obj   *)         timemgr,
    (*$U object : hwint.obj     *)         hwint;
    {$ENDC}
    {$IFC LDSfs}
    (*$U object/driverdefs.obj*)         driverdefs,
    (*$U object/sysglobal.obj *)         globalda,
    (*$U object/procprims.obj *)         proc_prims,
    (*$U object/mmprim.obj    *)         mmprimitives,
    (*$U object/asynctr.obj   *)         asynctr,
    (*$U object/genio.obj     *)         genio,
    (*$U object/twiggy.obj    *)         twiggy,
    (*$U object/vmstuff.obj   *)         vmstuff,
    (*$U object/sfileio.obj   *)         sfileio,
    (*$U object/fsprim.obj    *)         fs_primitives,
    (*$U object/objio.obj     *)         objio,
    (*$U object/mm0.obj       *)         memorymanager,
    (*$U object/ds0.obj       *)         datasegs,
    (*$U object/fsui.obj      *)         fs_interface,
    (*$U object/clock.obj     *)         clock,
    (*$U object/exceprim.obj  *)         exceprim,
    (*$U object/eventchn.obj  *)         eventchn,
    (*$U object/timemgr.obj   *)         timemgr,
    (*$U object/hwint.obj     *)         hwint;
    {$ENDC}


{$SETC VCBUG = FALSE}
{$IFC DEBUG2 or VCBUG}

procedure  DumpSys ( DeviceName : e_name;
                     FirstPage  : longint );
{$ENDC}


IMPLEMENTATION

(*$S ni_volchk *)

{$IFC DEBUG2 or VCBUG}


procedure  DumpSys (* DeviceName : e_name;
                      FirstPage  : longint *);


const
     SCREENSZ = 23;
     ESC = 27;
     CR = 13;

type
     nibble = 0..15;
     FmapPointer = ^filemap;
     Buffer = array[0..511] of byte;
     PageParts = (pglabel, pgdata);
     PageSet = set of PageParts;
     PageClass = (t_userdata, t_hintentry, t_filemap, t_slist,
                  t_rootcat, t_MDDF, t_bitmap, t_bootrack);
     tFullPage = record
                     hint : PageLabel;
                     data : Buffer;
                end;
     date_string = string[25];
     MonthDesc = record
                      name : string[3];
                      days : integer;
                 end;

     MountType = (m_def, m_real, m_fs);

var
     command : char;
     CurDevice : integer;
     ptrSysLocal : slocal_ptr;
     writeOK : boolean;
     errnumber : integer;
     char_diff : integer;
     priv : boolean;
     months : array[1..12] of MonthDesc;
     mount_state : MountType;
     must_unmount : boolean;









function  AskMore : boolean;

var
     answer : char;

begin
      read(answer);
      AskMore := ((ord(answer) = ESC) or (answer = 'q'));
      if answer <> ' ' then writeln;
end;




procedure  AdjustCase(var c : char);

begin
     if (c <= 'Z') and (c >= 'A') then
          c := chr(ord(c) + char_diff);  (*  map char to lower case  *)
end;






(*******************************************************************************)
(*******************************************************************************)

procedure  GetArgs(var arg1, arg2 : longint; var flag1, flag2 : boolean);

var
     ArgString : string[30];
     i : integer;



     function  getc : char;

     begin
          i := i + 1;

          if i > length(ArgString) then
               getc := '$'
          else
               getc := ArgString[i];

     end;



     function  GetNum(var num : longint) : boolean;

     var
          c : char;
          negative : boolean;
          result : boolean;

     begin

          negative := false;
          result := false;

          (*  Gobble-up leading delimiters  *)

          repeat
               c := getc;
          until (c <> ' ') and (c <> ',');

          (*  Look for sign character  *)

          if c = '+' then
               c := getc
          else if c = '-' then
          begin
               negative := true;
               c := getc;
          end;


          (*  Loop:  read string and convert to integer  *)

          num := 0;

          while (c >= '0') and (c <= '9') do
          begin
               result := true;
               num := num*10 + (ord(c) - ord('0'));
               c := getc;
          end;

          GetNum := result;

     end;





begin

     i := 0;

     readln(ArgString);

     flag1 := GetNum(arg1);
     flag2 := GetNum(arg2);

end;





procedure  InitDumpSys;

begin
     months[1].name := 'Jan';
     months[1].days := 31;
     months[2].name := 'Feb';
     months[2].days := 28;
     months[3].name := 'Mar';
     months[3].days := 31;
     months[4].name := 'Apr';
     months[4].days := 30;
     months[5].name := 'May';
     months[5].days := 31;
     months[6].name := 'Jun';
     months[6].days := 30;
     months[7].name := 'Jul';
     months[7].days := 31;
     months[8].name := 'Aug';
     months[8].days := 31;
     months[9].name := 'Sep';
     months[9].days := 30;
     months[10].name := 'Oct';
     months[10].days := 31;
     months[11].name := 'Nov';
     months[11].days := 30;
     months[12].name := 'Dec';
     months[12].days := 31;

     char_diff := ord('a') - ord('A');   (* character set case difference *)

     priv := true;  (* privileged user *)

     ptrSysLocal := pointer(b_syslocal_ptr);

     CurDevice := ptrSysLocal^.working_dev;
     must_unmount := false;
     mount_state := m_fs;  (* working dev better be fully mounted *)
end;





procedure WriteDate ( tstamp     : longint );

var
     date_info : DateArray;
     i : integer;

begin
     TimeToDate(tstamp, date_info);

     with date_info do
     begin
          (* Compute the day and month *)

          i := 1;
          while day > months[i].days do
          begin
               day := day - months[i].days;
               i := i + 1;
          end;

          (* Print the date/time *)

          writeln(months[i].name,' ',day:2,', ',year:4,'   ',
                  hour:2,':',minute:2,':',second:2);
     end;
end;






procedure  PageIO (       pagenum : longint;
                          device  : integer;
                    var PageHint  : Pagelabel;
                        addrPage  : longint;
                            mode  : ioop;
                      var ecode   : integer );

label   1;

var
     BlockNum : longint;
     actual : longint;
     Nada : plrect;
     ThePage : tFullPage;
     ptrPageBuffer : ^byte;

begin

     ecode := 0;

     with mounttable[device]^.MDDFdata^.geography do
     begin
          BlockNum := pagenum + firstblock;

          if (BlockNum < 0) or (BlockNum > lastblock) then
          begin
               ecode := 806;
               goto 1;
          end;
     end;

     ptrPageBuffer := pointer(addrPage);

     if mode = writeop then
     begin
          ThePage.hint := PageHint;
          moveleft(ptrPageBuffer^, ThePage.data, 512);
     end;

     if mount_state > m_def then
          vm(ecode, device, pagenum, 0, ord(@ThePage), 536, mode)
     else
          lisaio(ecode, device, ord(@ThePage), BlockNum, 1,
                 actual, raw_io, @Nada, mode);

     if mode = readop then
     begin
          PageHint := ThePage.hint;
          moveleft(ThePage.data, ptrPageBuffer^, 512);
     end;


1:   (*  exit  *)

end;









(*****************************************************************************)
(*  HEXCHAR:  Convert nibble to hexadecimal character                        *)
(*****************************************************************************)

function  HexChar(n : nibble) : char;

begin

     if n < 10 then
          HexChar := chr(ord('0') + n)
     else
          HexChar := chr(ord('A') + (n - 10));

end;






(*****************************************************************************)
(*  WRITEHEXBYTE:  Print byte in hexadecimal representation                  *)
(*****************************************************************************)

procedure  WriteHexByte(b : byte);

var
     unsigned : integer;     (* unsigned 8-bit value *)
     high, low : integer;    (* nibbles              *)

begin
     (*  convert byte to unsigned representation *)

     if b < 0 then
          unsigned := b + 256
     else
          unsigned := b;

     (*  get nibbles and print  *)

     high := unsigned div 16;
     low := unsigned mod 16;

     write(HexChar(high), HexChar(low));

end;






(*****************************************************************************)
(*  WRITECATENTRY:  Print a single catalog entry                             *)
(*****************************************************************************)

procedure  WriteCatEntry(RootEntry : centry);

var
     tab1, tab2 : string[33];

begin

     tab1 := '                             ';
     tab2 := ':                   ';

     with RootEntry do
     begin
          if name = '' then
          begin
               write('NULL');
               delete(tab2, 2, 3);
          end
          else
          begin
               write(name);
               delete(tab2, 2, length(name)-1);
          end;

          write(tab2,sfile:4,'    ');

          case cetype of

               fileentry:    writeln('file');
               pipeentry:    writeln('pipe');
               ecentry:      writeln('event channel');
               direntry:     writeln('catalog');
               killedentry:  writeln('killed');
               emptyentry:   writeln('empty');
               linkentry:    writeln('link');
               removed:      writeln('removed');
               otherwise     writeln('** BAD **');
          end;

          if (cetype = pipeentry) or
             (cetype = ecentry)   or
             (cetype = killedentry) then
               writeln(tab1,'read -> ',readpage:5,'[',readoffset:3,']        ',
                       'write -> ',writepage:5,'[',writeoffset:3,']');
     end;
end;








(*****************************************************************************)
(*  DUMPROOTCAT:  Print the root catalog of the device                       *)
(*****************************************************************************)

procedure  DumpRootCat(device : integer; short : boolean);

var
     RootEntry : centry;   (* single catalog entry  *)
     actual : longint;     (* fileio:  byte count   *)
     ecode : integer;      (* fileio:  error return *)
     LineCount : integer;
     quit : boolean;

begin

     ecode := 0;

     (*  set IO pointer in root catalog FCB to beginning of file  *)

     with rootptr[device]^ do
     begin
          curpage := sent.fileaddr;
          curoffset := 0;

          writeln;   writeln;
          writeln('ROOT CATALOG  @  ',curpage:5);   writeln;
     end;

     LineCount := 2;
     quit := false;

     (*  read first catalog entry  *)

     fileio(ecode, rootptr[device], ord(@RootEntry), sizeof(RootEntry), actual,
            rootptr[device]^.curpage, rootptr[device]^.curoffset, readop);


     (*  loop:  read and print successive catalog entries  *)

     while (ecode = 0) and (actual > 0) and not quit do
     begin

          with RootEntry do
               if not short or (name <> '')
                            or ((cetype <> emptyentry) and (cetype <> removed))
                            or (sfile <> 0) then
               begin
                    WriteCatEntry(RootEntry);
                    LineCount := LineCount + 1;
               end;

          if (LineCount mod SCREENSZ) = 0 then
          begin
               quit := AskMore;
               LineCount := LineCount + 1;
          end;

          fileio(ecode, rootptr[device], ord(@RootEntry), sizeof(RootEntry), actual,
                 rootptr[device]^.curpage, rootptr[device]^.curoffset, readop);

     end;

     writeln;

     (*  print exit condition  *)

     if not quit then
          if (ecode = 848) and (actual = 0) then
               writeln('END-OF-FILE')
          else
               writeln('*** Error ',ecode,' from catalog file I/O ***');

     writeln;   writeln;

end;







(*****************************************************************************)
(*  ALTERROOTCAT:  Change the root catalog of the device                     *)
(*****************************************************************************)

procedure  AlterRootCat(device : integer);

label  1;

type
     itype = record   (* template for 16-bit integer  *)
               value : integer;
               end;

var
     EntryName : e_name;    (* name of catalog entry        *)
     RootEntry : centry;    (* single catalog entry         *)
     cmd, cmd2 : char;      (* alteration commands          *)
     actual : longint;      (* fileio: byte count           *)
     ecode : integer;       (* fileio, lookup: error return *)
     ptrInteger : ^itype;   (* pointer to 16-bit integer    *)
     quit : boolean;
     SfileNumber : integer;
     savepage : longint;
     saveoffset : integer;
     catptr : sfcb_ptr;
     temp_name : e_name;

begin

     catptr := rootptr[device];
     writeln;

     repeat
          write('L(ookup  N(ameSearch  S(numSearch ? ');  read(cmd);  writeln;
          AdjustCase(cmd);
     until (cmd = 'l') or (cmd = 'n') or (cmd = 's');

     wait_sem(catptr^.semgp, []);

     if cmd = 'l' then
     begin
          (*  Get entry name and perform catalog search  *)

          write('Entry name: ');
          readln(EntryName);

          lookup_by_ename(ecode, EntryName, catptr, RootEntry);
          savepage := catptr^.curpage;
          saveoffset := catptr^.curoffset;
          if (ecode <> 0) and (ecode <> 888) then
          begin
               writeln('*** Error ',ecode:4,' from entry name lookup ***');
               goto 1;
          end;
     end
     else
     begin
          if cmd = 'n' then
          begin
               write('Entry name: ');
               readln(EntryName);
               upshift(@EntryName);
          end
          else
          begin
               write('Sfile number: ');
               readln(SfileNumber);
          end;

          ecode := 0;

          (*  set IO pointer in root catalog FCB to beginning of file  *)

          with catptr^ do
          begin
               curpage := sent.fileaddr;
               curoffset := 0;
          end;

          quit := false;

          (*  read first catalog entry  *)

          savepage := catptr^.curpage;
          saveoffset := catptr^.curoffset;
          fileio(ecode, catptr, ord(@RootEntry), sizeof(RootEntry),
             actual, catptr^.curpage, catptr^.curoffset, readop);


          (*  loop:  read and test successive catalog entries  *)

          while (ecode = 0) and (actual > 0) and not quit do
          begin

               with RootEntry do
               begin
                    temp_name := name;
                    upshift(@temp_name);
                    if ((cmd = 'n') and (temp_name = EntryName)) or
                       ((cmd = 's') and (sfile = SfileNumber)) then quit := true
                    else
                    begin
                         savepage := catptr^.curpage;
                         saveoffset := catptr^.curoffset;
                         fileio(ecode, catptr, ord(@RootEntry), sizeof(RootEntry),
                            actual, catptr^.curpage, catptr^.curoffset, readop);
                    end;
               end;
          end;

          writeln;

          (*  print exit condition  *)

          if not quit then
          begin
               if (ecode = 848) and (actual = 0) then
                    writeln('END-OF-FILE')
               else
                    writeln('*** Error ',ecode,' from catalog file I/O ***');
               goto 1;
          end;
     end;


     (*  Print the catalog entry  *)

     writeln;
     WriteCatEntry(RootEntry);
     writeln;


     (*  Loop: accept and apply alteration commands  *)

     repeat

          writeln;
          write('N(ame  S(file#  T(ype  Q(uit ? ');
          read(cmd);   writeln;
          AdjustCase(cmd);

          if (cmd <> 't') then
          begin
               (*  Change catalog entry name or s-file number  *)

                with RootEntry do
                case cmd of

                    'n':   begin  write(': ');  readln(name);  end;
                    's':   begin  write(': ');  readln(sfile); end;
                    'q':   ;

                    otherwise
               end;
          end
          else
          begin
               (*  Change catalog entry type  *)

               writeln;
               write('F(ile  P(ipe  E(vent  C(atalog  K(illed  N(ull  R(emoved  B(ad ? ');
               read(cmd2);   writeln;
               AdjustCase(cmd2);

               with RootEntry do
               case cmd2 of

                    'f':   cetype := fileentry;
                    'p':   cetype := pipeentry;
                    'e':   cetype := ecentry;
                    'c':   cetype := direntry;
                    'k':   cetype := killedentry;
                    'n':   cetype := emptyentry;
                    'r':   cetype := removed;

                    'b':   begin   (* jam in 16-bit bad value *)
                           ptrInteger := pointer(ord(@cetype));
                           ptrInteger^.value := -1;
                           end;
               end;
          end;

     until cmd = 'q';


     (*  write back the changed catalog entry  *)

     fileio(ecode, catptr, ord(@RootEntry), sizeof(RootEntry), actual,
            savepage, saveoffset, writeop);
     if ecode <> 0 then
          writeln('*** Error ',ecode:4,' from catalog file I/O ***');

1:   (*  exit  *)

     signal_sem(catptr^.semgp);
     writeln;

end;






(*****************************************************************************)
(*  WRITESENTRY:  Print an s-list entry                                      *)
(*****************************************************************************)

procedure  WriteSentry(snum : integer; SlistEntry : s_entry);

begin

     with SlistEntry do
          writeln(snum:4,'    hint -> ',hintaddr:5,'     data -> ',
                  fileaddr:5,'     size = ',filesize,'  vers = ',version:4);

end;







(*****************************************************************************)
(*  DUMPSLIST:  Print the s-file list for the device                         *)
(*****************************************************************************)

procedure  DumpSlist(device : integer);

var
     SlistEntry : s_entry;   (* single s-list entry    *)
     snum : integer;         (* s-file number          *)
     ecode : integer;        (* slist_io: error return *)
     LineCount : integer;
     quit : boolean;

begin
     ecode := 0;

     writeln;   writeln;
     writeln('S-FILE LIST');   writeln;

     LineCount := 2;
     quit := false;

     (*  read the first s-list entry  *)

     snum := 0;
     slist_io(ecode, device, snum, readop, SlistEntry);


     (*  loop:  read and print successive s-list entries  *)

     while (ecode = 0) and not quit do
     begin
          WriteSentry(snum, SlistEntry);
          LineCount := LineCount + 1;

          if (LineCount mod SCREENSZ) = 0 then
               quit := AskMore;

          snum := snum + 1;
          slist_io(ecode, device, snum, readop, SlistEntry);
     end;

      writeln;


      (*  print exit condition  *)

      if not quit then
           if ecode = 848 then
                writeln('END-OF-FILE')
           else
                writeln('*** Error ',ecode,' from s-list I/O ***');

      writeln;   writeln;
end;






(*****************************************************************************)
(*  ALTERSLIST:  Change the s-list for the device                            *)
(*****************************************************************************)

procedure  AlterSlist(device : integer);

label  1;

var
     cmd : char;             (* alteration command     *)
     SlistEntry : s_entry;   (* single s-list entry    *)
     snum : integer;         (* s-file number          *)
     ecode : integer;        (* slist_io: error return *)

begin

     writeln;
     ecode := 0;

     (*  Get s-file number and search s-list  *)

     write('S-file #: ');
     readln(snum);

     slist_io(ecode, device, snum, readop, SlistEntry);
     if ecode <> 0 then
     begin
          writeln('*** Error ',ecode:4,' from S-list I/O ***');
          goto 1;
     end;

     (*  Print the s-list entry  *)

     writeln;
     WriteSentry(snum, SlistEntry);
     writeln;

     (*  Loop:  accept and apply alteration commands  *)

     repeat

          writeln;
          write('H(intptr  D(ataptr  S(ize  V(ersion  Q(uit ? ');
          read(cmd);   writeln;
          AdjustCase(cmd);

          with SlistEntry do
          case cmd of

               's':   begin  write(': ');  readln(filesize);  end;
               'h':   begin  write(': ');  readln(hintaddr);  end;
               'd':   begin  write(': ');  readln(fileaddr);  end;
               'v':   begin  write(': ');  readln(version);   end;

               otherwise
          end;

     until cmd = 'q';


     (*  write back the changed s-list entry  *)
     slist_io(ecode, device, snum, writeop, SlistEntry);
     if ecode <> 0 then
          writeln('*** Error ',ecode:4,' from s-list I/O ***');

1:   (*  exit  *)

     writeln;
end;






(*****************************************************************************)
(*  DUMPLABEL:  Print the label of a page                                    *)
(*****************************************************************************)

procedure  DumpLabel(PageHint : pagelabel);

begin
     writeln('PAGE LABEL');  writeln;

     with PageHint do
     begin
          write('version : ',version);    writeln('          abspage: ',abspage);
          write('volume  : ',volume);     writeln('          relpage: ',relpage);
          write('fileid  : ',fileid);     writeln('          fwdlink: ',fwdlink);
          write('dataused: ',dataused);   writeln('          bwdlink: ',bkwdlink);
          write('datastat: ');
          case datastat of
               dataok   :  writeln('ok');
               databad  :  writeln('bad');
               datamaybe:  writeln('maybe');
          end;
     end;

     writeln;  writeln;

end;






(*****************************************************************************)
(*  HEXPRINT:  Print the contents of buffer in hexadecimal                   *)
(*             Print is done in units of 16-byte lines                       *)
(*****************************************************************************)

procedure  HexPrint(addrPage : longint; StartByte : integer; QuitByte : integer);

label 1;

var
     CharDisplay : packed array[0..15] of char;   (* ASCII version of buffer line *)

     ptrDataBuf : ^Buffer;   (* pointer to buffer of data            *)
     DataByte : byte;        (* a byte to be displayed               *)
     ByteNum : integer;    (* offset of first byte in display line *)
     i : integer;            (* index into ASCII display             *)

begin

     ptrDataBuf := pointer(addrPage);

     (*  loop:  print the buffer contents (from LineCount to QuitLine) *)

     ByteNum := StartByte;

     repeat

          (*  print offset of line  *)

          write(ByteNum:3,':  ');

          (* print line and generate ASCII version of line  *)

          for i := 0 to 15 do
          begin
               DataByte := ptrDataBuf^[ByteNum];
               if (DataByte > 31) and (DataByte < 127) then
                    CharDisplay[i] := chr(DataByte)
               else
                    CharDisplay[i] := '.';

               if ByteNum > QuitByte then
                    write('..')
               else
                    WriteHexByte(DataByte);
               write(' ');

               ByteNum := ByteNum + 1;
          end;

          (*  print ASCII version of line  *)

          write(' ');
          for i := 0 to 15 do
               write(CharDisplay[i]);

          writeln;

     until ByteNum > QuitByte;


1:   (* exit *)

end;






(*****************************************************************************)
(*  QUERY:  Query user for command during page dump                          *)
(*****************************************************************************)

function  Query : char;

var
     cmd : char;
     quit : boolean;

begin
     quit := false;
     repeat
         write('R(ept  T(empl  P(red  S(ucc  F(link  B(link  D(ataFix',
               '  L(blFix  M(ore  Q(uit *?');
         read(cmd);   writeln;
         AdjustCase(cmd);
         case cmd of
              'p', 's', 'f', 'b', 'd', 't',
              'l', 'm', 'c', 'q', 'r', 'z':  quit := true;
              otherwise
         end;
     until  quit;

     Query := cmd;
end;







(*****************************************************************************)
(*  DUMPMDDF:  Print the MDDF for the device                                 *)
(*****************************************************************************)

function  DumpMDDF(addrPage : longint) : char;

var
     ptrMDDF : ^MDDFdb;
     cmd : char;
     quit : boolean;

begin

     writeln('MDDF');   writeln;

     ptrMDDF := pointer(addrPage);

     with ptrMDDF^ do
     begin
          writeln('volume ',volnum:2,':  ',volname);
          writeln('volid: ',volid.a,' / ',volid.b);
          if priv then writeln('password: ',password);
          writeln('file system version: ',fsversion);
          writeln('init machine: ',init_machine_id);
          writeln('master machine: ',master_machine_id);

          writeln;
          with ptrMDDF^.geography do
               writeln('page 0 -> ',firstblock:5,'     page ',lastfspage:5,
                       ' -> ',lastblock:5);

          writeln;
          writeln('MDDF @ ',MDDFaddr:5,'/size  = ',MDDFsize:3,' bytes');
          writeln('Bit Map @ ',bitmap_addr:5,'/size  = ',bitmap_size:5,' bits; ',
                   bitmap_bytes:5,' bytes; ',bitmap_pages:2,' pages');

          writeln('S-file List @ ',slist_addr:5,'/size = ',
                  slist_block_count:2,' pages/packing = ',slist_packing,
                  '/limit = ',maxfiles:4,' entries');

          cmd := Query;
          if cmd = 'm' then
          begin
               quit := false;
               writeln;

               writeln('block count: ',blockcount:5);
               writeln('block size: ',blocksize:3,' bytes');
               writeln('data size: ',datasize:3,' bytes');

               writeln;
               writeln('First s-file:          ',first_file:5);
               writeln('Next available s-num:  ',empty_file:5);
               writeln('S-files allocated:     ',filecount:5);
               writeln('Maximum s-files:       ',maxfiles:5);
               writeln('Free pages:            ',freecount:5);
               writeln('Copy thread:           ',copy_thread:5);
               writeln('FS overhead:           ',fs_overhead:5);
               writeln('scavenge result:       ',result_scavenge:5);
               writeln('File label offset:     ',flabel_offset:5);

               write('Scavenged = ');
               if vol_scavenged then write('on') else write('off');
               write('     Copied = ');
               if tbt_copied then writeln('on') else writeln('off');

               writeln;
               write('created:       ');  WriteDate(DT_created);
               write('copy created:  ');  WriteDate(DT_copy_created);
               write('copied:        ');  WriteDate(DT_copied);
               write('scavenged:     ');  WriteDate(DT_scavenged);

               writeln;
               writeln('Root catalog:  s-file # = ',rootsnum:4,'/limit = ',
                       rootmaxentries:4,' entries');

               cmd := Query;
               if cmd = 'm' then
               begin
                    (*  Dump parameter memory snapshot  *)

                    quit := false;
                    writeln;
                    writeln('Parameter Memory Snapshot');  writeln;

                    HexPrint(ord(@pmem)+1, 0, 63);
               end;

               cmd := Query;
               if cmd = 'm' then
               begin
                    writeln;
                    if unusedi1 = -1 then
                         writeln('Volume is blessed')
                    else
                         writeln('Volume is cursed');
               end;
          end
          else
               quit := true;

     end;


     writeln;   writeln;

     if quit then
          DumpMDDF := cmd
     else
          DumpMDDF := Query;

end;






(*****************************************************************************)
(*  BITPRINT:  Print the contents of a buffer in bit notation                *)
(*****************************************************************************)

procedure  BitPrint(addrPage : longint; offset : integer;
                    bitlabel : longint; size : integer; var nfree : longint);

var
     ptrBitMap : ^bitmap;   (* pointer to a buffer of bits *)
     BitNumber : integer;   (* index into bit-map          *)
     i : integer;           (* display line-size counter   *)

begin

     BitNumber := 0;
     ptrBitMap := pointer(addrPage);

     (*  Loop:  print bit map until size reached  *)

     while BitNumber < size do
     begin

          write(BitNumber+bitlabel:5,':  ');

          (*  print a line of the bit map  *)

          for i := offset to offset+63 do
          begin
               if BitNumber >= size then
                    write('.')
               else
                    (*$R-*)
                    if ptrBitMap^[i] then
                         write('A')
                    else
                    begin
                         write('F');
                         nfree := nfree + 1;
                    end;
                    (*$IFC DEBUG2*)
                    (*$R+*)
                    (*$ENDC*)
               BitNumber := BitNumber + 1;
          end;

               offset := offset + 64;
               writeln;
     end;
end;






(*****************************************************************************)
(*  DUMPFILEMAP:  Print file map page                                        *)
(*****************************************************************************)

function  DumpFileMap ( addrIndex : longint; MapNum : integer; max_index : integer ) : char;

var
     i : integer;           (* index into file map               *)
     quit : boolean;        (* early termination of display loop *)
     LineCount : integer;   (* display line count                *)
     cmd : char;            (* next command                      *)
     ptrIndex : FmapPointer;

begin
     cmd := ' ';
     ptrIndex := pointer(addrIndex);

     with ptrIndex^ do
     begin
          writeln('FILE MAP PAGE');   writeln;

          if MapNum = 0 then
               write('file size = ',size,'   ');
          write('entry count = ',ecount:4,'   ');
          writeln('max = ',max_entries:4);
          writeln;

          (*  loop:  print index entries  *)

          LineCount := 14;
          quit := false;
          i := 0;

          while (i <= max_index) and not quit do
          begin
               with map[i] do
                    writeln('page = ',address:5,'    length = ',cpages:5);

               LineCount := LineCount + 1;

               (*  Give viewer a chance to bail-out  *)

               if (LineCount mod SCREENSZ) = 0 then
               begin
                    cmd := Query;

                    if cmd <> 'm' then
                         quit := true;
               end;
               i := i + 1;
          end;
     end;

     writeln;   writeln;

     if cmd = ' ' then cmd := Query;
     DumpFileMap := cmd;
end;





(*****************************************************************************)
(*  DUMPHINTENTRY:  Print catalog entry page of hints                        *)
(*****************************************************************************)

function  DumpHintEntry(addrPage : longint) : char;

label 1;

var
     ptrHintEntry : ^hentry;
     ptrFmap : flmap_ptr;
     date_time : date_string;
     cmd : char;

begin
     writeln('HINT ENTRY');   writeln;

     ptrHintEntry := pointer(addrPage);
     ptrFmap := pointer(addrPage + 128);

     with ptrHintEntry^ do
     begin
          if name = '' then
               write('NULL:  ')
          else
               write(name,':  ');

          case ftype of

               userfile:      writeln('user file');
               pipe:          writeln('pipe');
               userdir:       writeln('user catalog');
               rootcat:       writeln('root catalog');
               Killedobject:  writeln('killed object');
               undefined:     writeln('undefined');
               bootfile:      writeln('boot file');
               exec:          writeln('exec file');
               spool:         writeln('spool file');
               sysdata:       writeln('system data file');
               swapdata:      writeln('data swap file');
               swapcode:      writeln('code swap file');
               ramap:         writeln('ramap file');
               MDDFfile:      writeln('media descriptor data file');
               freelist:      writeln('free page file');
               badblocks:     writeln('bad block file');
               otherwise      writeln('** BAD **');
          end;

          writeln;

          writeln('version:         ',version);
          writeln('machine id:      ',machine_id);
          writeln('system type:     ',system_type);
          writeln('user_type:       ',user_type);
          writeln('user_subtype:    ',user_subtype);
          writeln('scavenge result: ',result_scavenge);

          writeln;

          write('killed = ');
          if killed  then write('on ')  else write('off');

          write('        safety = ');
          if safety_on  then writeln('on ')  else writeln('off');

          write('master = ');
          if master  then write('on ')  else write('off');

          write('        protected = ');
          if protected  then writeln('on ')  else writeln('off');

          write('scavenged = ');
          if scavenged  then  write('on ')  else write('off');

          write('     closed by OS = ');
          if closed_by_os  then  writeln('on ')  else writeln('off');

          write('left open = ');
          if file_open  then writeln('on')  else writeln('off');

          writeln;

          write('created  : ');  WriteDate(DTC);
          write('accessed : ');  WriteDate(DTA);
          write('modified : ');  WriteDate(DTM);
          write('backed-up: ');  WriteDate(DTB);
          write('scavenged: ');  WriteDate(DTS);

     end;

     writeln;  writeln;

     cmd := Query;

     if cmd = 'm' then
     begin
          writeln;
          writeln('SMALL FILE MAP');  writeln;

          cmd := DumpFileMap(ord(ptrFmap), 0, MAXSMALLINDEX);
     end;

     if cmd = 'm' then
     begin
          writeln;
          writeln('USER-DEFINED LABEL');  writeln;

          HexPrint(ord4(addrPage + 512 - sizeof(hentry)), 0, 128);

          writeln;  writeln;

          cmd := Query;
     end;

     DumpHintEntry := cmd;

1:   (* exit *)

end;






(*****************************************************************************)
(*  HEXDUMPPAGE:  Print a page of user data                                  *)
(*****************************************************************************)

function  HexDumpPage(addrPage : longint) : char;

var
     cmd : char;
     count : integer;

begin

     writeln('PAGE');   writeln;

     (*  Print first half of page  *)

     count := ((SCREENSZ - 12) * 16) - 1;
     HexPrint(addrPage, 0, count);

     (*  Give viewer chance to bail-out  *)

     cmd := Query;

     if cmd = 'm' then
     begin
          (*  Print rest of page  *)

          HexPrint(addrPage, count+1, 511);
          writeln;   writeln;
          cmd := Query;
     end;

     HexDumpPage := cmd;

end;





(*****************************************************************************)
(*  DUMPUSERLABEL:  Print user-defined label page of hints                   *)
(*****************************************************************************)

function DumpUserLabel(addrPage : longint) : char;

begin

     write('OBJECT LABEL ');

     DumpUserLabel := HexDumpPage(addrPage);

end;




(*****************************************************************************)
(*  DUMPCATPAGE:  Print page of root catalog                                 *)
(*****************************************************************************)

function DumpCatPage(addrPage : longint) : char;

begin

     write('ROOT CATALOG ');

     DumpCatPage := HexDumpPage(addrPage);

end;





(*****************************************************************************)
(*  DUMPBOOTTRACK:  Print page preceding page 0 of the FS volume             *)
(*****************************************************************************)

function  DumpBootTrack(addrPage : longint) : char;

begin

     write('BOOT TRACKS ');

     DumpBootTrack := HexDumpPage(addrPage);

end;







(*****************************************************************************)
(*  DUMPSPAGE:  Print page of s-list                                         *)
(*****************************************************************************)

function DumpSpage(device : integer; addrPage : longint; abspage : longint) : char;

var
     ptrSentry : ^s_entry;
     SlistEntry : s_entry;
     base : integer;
     LineCount : integer;
     cmd : char;
     quit : boolean;
     i : integer;

begin

     writeln('S-LIST PAGE');   writeln;

     with mounttable[device]^.MDDFdata^ do
          base := (abspage - slist_addr) * slist_packing;

     LineCount := 12;
     quit := false;

     i := 0;
     while (i <= mounttable[device]^.MDDFdata^.slist_packing-1) and not quit do
     begin
          ptrSentry := pointer(addrPage + i*sizeof(s_entry));

          WriteSentry(base+i, ptrSentry^);

          LineCount := LineCount + 1;

          if (LineCount mod SCREENSZ) = 0 then
          begin
               cmd := Query;

               if cmd <> 'm' then
                    quit := true;
          end;

          i := i + 1;

     end;

     if quit then
          DumpSpage := cmd
     else
          DumpSpage := Query;

end;






function  DumpBitMap(device : integer; page : longint; addrMap : longint) : char;

var
     cmd : char;
     quit : boolean;
     count, offset : integer;
     bitnum, high : longint;
     free_count : longint;

begin
     writeln('BIT MAP PAGE');  writeln;

     with mounttable[device]^.MDDFdata^ do
     begin
          bitnum := (page - bitmap_addr) * DEFPGDATASIZE * 8;
          high := bitnum + (DEFPGDATASIZE * 8) - 1;

          count := (SCREENSZ - 12) * 64;

          quit := false;
          offset := 0;

          free_count := 0;
          while (bitnum < bitmap_size) and
                (bitnum <= high) and not quit do
          begin
               if bitnum+count >= bitmap_size then
                    count := bitmap_size - bitnum - 1;

               if bitnum+count > high then
                    count := (high - bitnum) + 1;

               BitPrint(addrMap, offset, bitnum, count, free_count);

               writeln('Free count = ',free_count);

               cmd := Query;
               if cmd <> 'm' then
                    quit := true;

               offset := offset + count;
               bitnum := bitnum + count;

               count := SCREENSZ * 64;
          end;

          if quit then
               DumpBitMap := cmd
          else
               DumpBitMap := Query;

     end;
end;









(*****************************************************************************)
(*  DUMPPAGE:  Print a page according to page type                           *)
(*             Return the next page dump command                             *)
(*****************************************************************************)

function  DumpPage(device : integer; PageHint : pagelabel; addrPage : longint;
                   kind : PageClass) : char;

var
     cmd : char;

begin

     case kind of

          t_userdata:
                           cmd := HexDumpPage(addrPage);

          t_rootcat:
                           cmd := DumpCatPage(addrPage);

          t_hintentry:
                           begin
                             cmd := DumpHintEntry(addrPage);
                           end;

          t_filemap:
                           begin
                             cmd := DumpFilemap(addrPage,
                                                PageHint.relpage-1, MAXMAPINDEX);
                           end;

          t_slist:
                           cmd := DumpSpage(device, addrPage,
                                            PageHint.abspage);

          t_MDDF:
                           begin
                             cmd := DumpMDDF(addrPage);
                           end;

          t_bitmap:
                           begin
                             cmd := DumpBitMap(device, PageHint.abspage, addrPage);
                           end;

          t_bootrack:
                           begin
                             cmd := DumpBootTrack(addrPage);
                           end;

          end;

     DumpPage := cmd;
end;




(*****************************************************************************)
(*  ALTERMDDF:  Change the MDDF of the device                                *)
(*****************************************************************************)

procedure  AlterMDDF(addrPage : longint);

var
     ptrMDDF : ^MDDFdb;
     cmd : char;

begin

     ptrMDDF := pointer(addrPage);

     (*  Loop:  accept and apply alteration commands  *)

     repeat
          writeln;
          write('F(reePgs  S(fileCnt  E(mptyF  V(ers  R(ootEnts  P(aswd  Q(uit ? ');
          read(cmd);   writeln;
          if cmd = '?' then
          begin
               write('B(less  C(urse ? ');  read(cmd);  writeln;
          end;
          AdjustCase(cmd);

          with ptrMDDF^ do
          case cmd of

               'f':   begin  write(': ');  readln(freecount);  end;
               's':   begin  write(': ');  readln(filecount);  end;
               'e':   begin  write(': ');  readln(empty_file); end;
               'v':   begin  write(': ');  readln(fsversion);  end;
               'r':   begin  write(': ');  readln(rootmaxentries);  end;
               'p':   begin  write(': ');  readln(password);   end;
               'b':   unusedi1 := -1;
               'c':   unusedi1 := 0;

               otherwise

          end;

          if mount_state > m_def then
               with mounttable[CurDevice]^, ptrMDDF^ do
               begin
                    MDDFdata^.freecount := freecount;
                    MDDFdata^.filecount := filecount;
                    MDDFdata^.empty_file := empty_file;
                    MDDFdata^.fsversion := fsversion;
                    MDDFdata^.unusedi1 := unusedi1;
                    MDDFdata^.rootmaxentries := rootmaxentries;
                    MDDFdirty := true;
               end;

     until cmd = 'q';

     writeln;
end;





(*****************************************************************************)
(*  ALTERBITMAP:  Change the allocation bit map of the device                *)
(*****************************************************************************)

procedure  AlterBitMap(device : integer; page : longint; addrPage : longint);

label  1;

var
     start, stop, BitNum : longint;
     low, high : longint;
     ptrBitMap : ^bitmap;
     BitVal : boolean;
     cmd : char;
     finished : boolean;
     i, LineFill : integer;
     GotStart, GotStop : boolean;
     quit : boolean;

begin

     writeln;

     ptrBitMap := pointer(addrPage);
     finished := false;

     with mounttable[device]^.MDDFdata^ do
     begin
          low := (page - bitmap_addr) * DEFPGDATASIZE * 8;
          if page = (bitmap_addr + bitmap_pages - 1) then
               high := bitmap_size - 1
          else
               high := low + (DEFPGDATASIZE * 8) - 1;
     end;

     while not finished do
     begin
          writeln;
          write('page range: ');
          GetArgs(start, stop, GotStart, GotStop);

          if not GotStart then
               goto 1
          else
               if not GotStop then
                    stop := start;

          if (stop > high) or (start < low) then
               writeln('This page maps pages ',low:5,' to ',high:5)
          else
          begin
               writeln;
               LineFill := 0;
               write(start:5,':  ');

               for i := start-low to stop-low do
               begin
                    (*$R-*)
                    if ptrBitMap^[i] then
                         write('A')
                    else
                         write('F');
                    (*$IFC DEBUG2*)
                    (*$R+*)
                    (*$ENDC*)

                    LineFill := LineFill + 1;
                    if LineFill = 16 then
                    begin
                         LineFill := 0;
                         writeln;
                         write(i+1:5,':  ');
                    end;

               end;

               writeln;   writeln;

               quit := false;
               repeat
                    write('A(llocate  F(ree  W(indow  Q(uit ? ');
                    read(cmd);   writeln;
                    AdjustCase(cmd);

                    case cmd of

                         'a', 'f', 'w', 'q':   quit := true;

                         otherwise
                    end;

               until quit;

               case cmd of

                    'a', 'f':
                             for i := start-low to stop-low do
                                  begin
                                      (*$R-*)
                                      with mounttable[device]^ do
                                      if cmd = 'a' then
                                      begin
                                           ptrBitMap^[i] := true;
                                           if mount_state > m_def then
                                           begin
                                                allocmap^[low+i] := true;
                                                mapdirty := true;
                                           end;
                                      end
                                      else
                                      begin
                                           ptrBitMap^[i] := false;
                                           if mount_state > m_def then
                                           begin
                                                allocmap^[low+i] := false;
                                                mapdirty := true;
                                           end;
                                      end;
                                      (*$IFC DEBUG2*)
                                      (*$R+*)
                                      (*$ENDC*)
                                end;

                    'q':   finished := true;
                    'w':   ;
               end;
          end;
     end;

1:   (*  exit  *)

     writeln;
end;




(*****************************************************************************)
(*  ALTERHINTENTRY:  Change a catalog page of hints                          *)
(*****************************************************************************)

procedure  AlterHintEntry(addrPage : longint);

var
     ptrHintEntry : ^hentry;
     cmd, cmd2 : char;

begin

     ptrHintEntry := pointer(addrPage);

     (*  Loop:  accept and apply alteration commands  *)

     repeat

          writeln;
          write('N(ame  T(ype  K(illed  S(afety  O(Sclosed  L(eftOpen  scA(venged  Q(uit ? ');
          read(cmd);   writeln;
          AdjustCase(cmd);

          if cmd <> 't' then
          begin
               (*  Change entry name, flags  *)

               with ptrHintEntry^ do
                    case cmd of

                         'n':   begin  write(': ');  readln(name);  end;
                         'k':   killed := not killed;
                         's':   safety_on := not safety_on;
                         'o':   closed_by_OS := not closed_by_OS;
                         'l':   file_open := not file_open;
                         'a':   scavenged := not scavenged;
                         'z':   begin
                                DTA := 0;  DTM := 0;
                                writeln('OK');
                                end;

                         otherwise
                    end;
           end
           else
           begin
                (*  Change entry type  *)

                writeln;
                write('F(ile  P(ipe  R(ootCat  K(illed  U(ndefined ? ');
                read(cmd2);   writeln;
                AdjustCase(cmd2);

                with ptrHintEntry^ do
                case cmd2 of

                     'f':   ftype := userfile;
                     'p':   ftype := pipe;
                     'r':   ftype := rootcat;
                     'k':   ftype := killedobject;
                     'u':   ftype := undefined;

                     otherwise
                end;
           end;

     until cmd = 'q';

     writeln;
end;




(*****************************************************************************)
(*  ALTERFILEMAP:  Change a file map page of hints                           *)
(*****************************************************************************)

procedure  AlterFileMap(addrPage : longint; MapNum : integer);

label  1;

var
     ptrIndex : FmapPointer;
     RelatPage, AbsolPage : longint;
     GotRel, GotAbs : boolean;
     MapIndex : integer;
     cmd : char;
     junk : longint;
     bjunk, found : boolean;

begin

     ptrIndex := pointer(addrPage);

     (*  Loop:  accept and apply alteration commands  *)

     repeat

          writeln;
          write('S(ize  N)umEntries  M(ap  Q(uit ? ');
          read(cmd);   writeln;
          AdjustCase(cmd);

          with ptrIndex^ do
          case cmd of

               'n':   begin  write(': ');  readln(ecount);  end;
               's':   begin  write(': ');  readln(size);   end;

               otherwise
          end;

          if cmd = 'm' then
               (*  Loop:  change the index entries  *)

               while true do
               begin
                    writeln;
                    write('page: ');
                    GetArgs(AbsolPage, junk, GotAbs, bjunk);

                    if not GotAbs then  goto 1;

                    (*  Convert rel page number to index  *)

                    found := false;
                    MapIndex := 0;
                    while (MapIndex <= MAXMAPINDEX) and not found do
                    begin
                         if ptrIndex^.map[MapIndex].address = AbsolPage then
                              found := true
                         else
                              MapIndex := MapIndex + 1;
                    end;

                    if found then
                    begin
                         with ptrIndex^.map[MapIndex] do
                         begin
                              writeln;
                              writeln('page = ',address:5,'   length = ',cpages:5);

                              writeln;

                              repeat
                                   write('P)age  L)ength  Q)uit ? ');
                                   read(cmd);  writeln;
                                   AdjustCase(cmd);

                                   case cmd of

                                        'p':  begin
                                              write(': ');  readln(address); end;
                                        'l':  begin
                                              write(': ');  readln(cpages)   end;

                                        otherwise
                                   end;

                              until cmd = 'q';

                              cmd := ' ';

                         end;
                    end
                    else
                         writeln('No such file map entry on this page');

               end;

1:        (*  exit loop  *)

     until cmd = 'q';

     writeln;
end;




(*****************************************************************************)
(* ALTERLABEL:  Change the label of a page                                   *)
(*****************************************************************************)

procedure  AlterLabel(device : integer; page : longint; PageHint : pagelabel;
                      addrPage : longint);

var
     cmd, cmd2 : char;
     j : longint;
     ecode : integer;

begin

     (*  Loop:  accept and apply alteration commands  *)

     repeat

          writeln;
          write('S(file#  D(ataused  A(bs#  R(el#  F(link  B(link  X(bits  V(ers  Q(uit ? ');
          read(cmd);   writeln;
          AdjustCase(cmd);

          with PageHint do
          case cmd of

               's':   begin  write(': ');  readln(j); fileid := j;   end;
               'd':   begin  write(': ');  readln(j); dataused := j; end;
               'a':   begin  write(': ');  readln(j); abspage := j;  end;
               'r':   begin  write(': ');  readln(j); relpage := j;  end;
               'f':   begin  write(': ');  readln(j); fwdlink := j;  end;
               'b':   begin  write(': ');  readln(j); bkwdlink := j; end;
               'v':   begin  write(': ');  readln(j); version := j;  end;
               'x':   begin
                      write('O(kay  M(aybe  B(ad ? ');
                      read(cmd2);  writeln;
                      AdjustCase(cmd2);

                      case cmd2 of

                           'o':  datastat := dataok;
                           'm':  datastat := datamaybe;
                           'b':  datastat := databad;
                           otherwise
                      end;
                      end;

               otherwise
          end;

     until cmd = 'q';

     (*  Write back the changed page label  *)

     PageIO(page, device, PageHint, addrPage, writeop, ecode);
     {pglblio(PageHint, device, page, writeop, ecode);}
     if ecode <> 0 then
          writeln('*** Error ',ecode:4,' from Page I/O ***');

     writeln;

end;





(*****************************************************************************)
(*  ALTERPAGE:  Page alteration driver                                       *)
(*****************************************************************************)

procedure  AlterPage(device : integer; page : longint; PageHint : pagelabel;
                 addrPage : longint; kind : PageClass);

var
     ecode : integer;
     actual : longint;
     Nada : plrect;
     block : longint;

begin
     ecode := 0;

     case kind of

          t_userdata:
                           writeln('Not implemented for this type page.');

          t_rootcat:
                           AlterRootCat(device);

          t_hintentry:
                           AlterHintEntry(addrPage);

          t_filemap:
                           AlterFilemap(addrPage,
                                        PageHint.relpage-1);

          t_slist:
                           AlterSlist(device);

          t_MDDF:
                           AlterMDDF(addrPage);

          t_bitmap:
                           AlterBitMap(device, PageHint.abspage, addrPage);

          end;


     (*  Write back the changed page  *)

     PageIO(page, device, PageHint, addrPage, writeop, ecode);
     if ecode <> 0 then
          writeln('*** Error ',ecode:4,' from Page I/O ***');

end;






(*****************************************************************************)
(*  PAGEKIND:  Return type of page as determined by info in page's label     *)
(*             and info in MDDF for device                                   *)
(*****************************************************************************)

function  PageKind(device : integer; PageHint : pagelabel) : PageClass;

begin

     (*  Hint Page  *)

     if PageHint.fileid < 0 then
          case PageHint.relpage of

               0:   (*  catalog entry  *)
                    PageKind := t_hintentry;

               otherwise

                    (* file map *)
                    PageKind := t_filemap;

               end


     (*  Root Catalog Page  *)

     else if PageHint.fileid = mounttable[device]^.MDDFdata^.rootsnum then
          PageKind := t_rootcat


     (*  Primitive S-file Pages  *)

     else

          (*  detect primitive s-file pages from s-file number  *)

          case PageHint.fileid of

               1:   (*  MDDF  *)
                     PageKind := t_MDDF;

               2:   (*  Bit Map Page  *)
                     PageKind := t_bitmap;

               3:   (*  S-list Page  *)
                     PageKind := t_slist;

               otherwise
                    PageKind := t_userdata;

               end

end;





(*****************************************************************************)
(*  GETKIND:  Query user for a page kind to be used as a template for        *)
(*            display.                                                       *)
(*****************************************************************************)

procedure  GetKind(var kind : PageClass);

var
     cmd2 : char;
     finished : boolean;

begin

     writeln;

     repeat
          write('D(ata  H(int  F(map  S(list  M(DDF  B(itmap ? ');
          read(cmd2);  writeln;
          AdjustCase(cmd2);

          finished := true;

          case cmd2 of

               'd':   kind := t_userdata;
               'h':   kind := t_hintentry;
               'f':   kind := t_filemap;
               's':   kind := t_slist;
               'm':   kind := t_MDDF;
               'b':   kind := t_bitmap;

               otherwise
                      finished := false;

               end;

          writeln;

     until finished;
end;






(*****************************************************************************)
(*  GetPassword:  Query user for password, and match it                      *)
(*****************************************************************************)

procedure  GetPassword(var correct : boolean);

const
     PSWLEN = 20;
var
     passwd : string[PSWLEN];
     cover_up : string[3];
     c : char;
     i : integer;

begin
     passwd := '                    ';
     cover_up := '...';
     cover_up[1] := chr(8);
     cover_up[2] := ' ';
     cover_up[3] := chr(8);
     i := 1;

     writeln;
     write('Password: ');
     read(c);

     while ord(c) <> CR do
     begin
          if i <= PSWLEN then
          begin
               passwd[i] := c;
               i := i + 1;
          end;

          write(cover_up);
          read(c);
     end;

     readln;  (* clear eoln *)

     if pos('bermuda',passwd) <> 0 then
     begin
          correct := true;
          writeln('* * *');
     end
     else
          correct := false;

     writeln;   writeln;

end;





(*****************************************************************************)
(*  TOYWITHPAGE:  Accept page alteration commands until a page display       *)
(*                command is entered                                         *)
(*****************************************************************************)

function  ToyWithPage(var cmd : char; device : integer; var page : longint;
                      PageHint : pagelabel; addrPage : longint;
                      var kind : PageClass) : boolean;

var
     quit : boolean;
     finished : boolean;
     DestPage : longint;
     ecode : integer;

begin

     quit := false;
     finished := false;

     repeat
          case cmd of

               'p':   (*  dump previous absolute (contiguous) page  *)
                      begin
                        if (page - 1) < 0 then
                        begin
                             writeln('Sorry, that was the first page on the volume.');
                             writeln;
                             cmd := Query;
                        end
                        else
                        begin
                             page := page - 1;
                             quit := true;
                        end;
                      end;

               's':   (*  dump next absolute (contiguous) page  *)
                      begin
                        if (page + 1) > mounttable[device]^.MDDFdata^.geography.lastfspage
                        then begin
                             writeln('Sorry, that was the last page on the volume.');
                             writeln;
                             cmd := Query;
                        end
                        else
                        begin
                             page := page + 1;
                             quit := true;
                        end;
                      end;

               'b':   (*  dump previous relative (linked) page  *)
                      begin
                        if PageHint.bkwdlink = REDLIGHT then
                        begin
                             writeln('Sorry, there is no backward link.');
                             writeln;
                             cmd := Query;
                        end
                        else
                        begin
                             page := PageHint.bkwdlink;
                             quit := true;
                        end;
                      end;

               'f':   (*  dump next relative (linked) page  *)
                      begin
                        if PageHint.fwdlink = REDLIGHT then
                        begin
                             writeln('Sorry, there is no forward link.');
                             writeln;
                             cmd := Query;
                        end
                        else
                        begin
                             page := PageHint.fwdlink;
                             quit := true;
                        end;
                      end;

               'c':   (*  copy this page  *)
                      begin
                        writeln;
                        write('destination page: ');
                        readln(DestPage);
                        PageIO(DestPage, device, PageHint, addrPage, writeop, ecode);
                        if ecode <> 0 then
                             writeln('*** Error ',ecode:4,' from page I/O ***');
                        cmd := Query;
                      end;

               'd':   (*  alter this page  *)
                      begin
                        if priv then
                            AlterPage(device, page, PageHint,
                                      addrPage, kind)
                        else
                             writeln('Modify-access Denied');
                        cmd := Query;
                      end;

               'l':   (* alter this page's label *)
                      begin
                        if priv then
                             AlterLabel(device, page, PageHint, addrPage)
                        else
                             writeln('Modify-access Denied');
                        cmd := Query;
                      end;

               'q':   begin
                        finished := true;
                        quit := true;
                      end;

               'r':   quit := true;

               't':   (*  dump page as a specific kind of page  *)
                      begin
                        GetKind(kind);
                        quit := true;
                      end;

               'z':   (* password accepted at this level too  *)
                      begin
                        GetPassword(priv);
                        cmd := Query;
                      end;

               otherwise
                      cmd := Query;

          end;

     until quit;

     ToyWithPage := finished;

     writeln;
end;








(*****************************************************************************)
(*  DUMP:  Page dump driver                                                  *)
(*****************************************************************************)

procedure  Dump(device : integer; what : PageSet; first_time : boolean);

label 1, 2;

var
     page : longint;
     PageHint : pagelabel;
     ThePage : record
                labl : pagelabel;
                contents : array[0..511] of byte;
                end;
     kind : PageClass;
     ecode : integer;
     addrPageContents : longint;
     finished : boolean;
     cmd : char;

begin

     ecode := 0;

     writeln;

     if first_time then
     begin
          page := FirstPage;
          goto 2;
     end;

     (*  query user for starting page  *)

     with mounttable[device]^.MDDFdata^ do
     begin
          repeat
               write('page: ');
               readln(page);
          until (page+geography.firstblock >= 0) and
                (page <= geography.lastfspage);
     end;

2:
     (*  loop:  print pages  *)

     finished := false;

     while not finished do
     begin
          (*  read the page label *)

          writeln;   writeln;

          addrPageContents := ord(@ThePage.contents);

          PageIO(page, device, PageHint, addrPageContents, readop, ecode);
          if ecode <> 0 then
          begin
               writeln('*** Error ',ecode:4,' from Page I/O ***');
               writeln;
               if (ecode > 0) and (ecode <> 625) and (ecode <> 663) then goto 1;
          end;

          (*  and dump it if necessary  *)

          if pglabel in what then
               DumpLabel(PageHint);

          (*  don't compute kind for pages being dumped with a template  *)

          if cmd <> 't' then
          begin
               if page < 0 then
                    kind := t_bootrack
               else
                    kind := PageKind(device, PageHint);
          end;

          if pgdata in what then
          begin
               (*  dump the page  *)

               cmd := DumpPage(device, PageHint, addrPageContents, kind);
          end
          else
               cmd := Query;

          finished := ToyWithPage(cmd, device, page, PageHint,
                                  addrPageContents, kind);
     end;


1:   (* exit *)

end;




(*****************************************************************************)
(*  SLISTMGR:  S-list dump/alteration driver                                 *)
(*****************************************************************************)

procedure  SlistMgr(device : integer);

var

     cmd : char;

begin

     writeln;

     if mount_state < m_real then
          writeln('Device is Def mounted -- cannot access the S-list')
     else
     begin
          repeat

               write('P(rint   A(lter  Q(uit ? ');
               read(cmd);   writeln;
               AdjustCase(cmd);

               case cmd of

                    'p':   (* print s-list *)
                           DumpSlist(device);

                    'a':   (* alter s-list *)
                           if mount_state > m_def then
                                if priv then
                                     AlterSlist(device)
                                else
                                     writeln('Modify-access Denied')
                           else
                                writeln('Cannot alter S-list of Def mounted device');

                    otherwise

               end;

          until cmd = 'q';
     end;

     writeln;
end;





(*****************************************************************************)
(*  ROOTCATMGR:  Root catalog dump/alteration driver                         *)
(*****************************************************************************)

procedure  RootCatMgr(device : integer);

var

     cmd : char;

begin

     writeln;

     if mount_state < m_real then
          writeln('Device is not FS mounted -- cannot access root catalog')
     else
     begin
          repeat

               write('P(rint  S(hortPrint  A(lter  Q(uit ? ');
               read(cmd);   writeln;
               AdjustCase(cmd);

               case cmd of

                    'p':   (* print root catalog *)
                           DumpRootCat(device, false);

                    's':   (* print only interesting cat  entries *)
                           DumpRootCat(device, true);

                    'a':   (* alter root catalog *)
                           if mount_state > m_def then
                                if priv then
                                     AlterRootCat(device)
                                else
                                     writeln('Modify-access Denied')
                           else
                                writeln('Cannot alter catalog of Def mounted device');

                    otherwise

               end;

          until cmd = 'q';
     end;

     writeln;
end;








procedure  DoMount(device : integer;  var ecode : integer);

var
     cmd : char;
     finished : boolean;

begin
     repeat
          write('D(efault  R(eal  F(ileSys ? ');  read(cmd);  writeln;
          AdjustCase(cmd);
     until (cmd = 'd') or (cmd = 'r') or (cmd = 'f');

     must_unmount := true;

     finished := false;
     repeat
          ecode := 0;
          case cmd of

               'd':  def_mount(ecode, device);
               'r':  real_mount(ecode, device);
               'f':  fs_mount(ecode, device);
          end;

          if ecode > 0 then
          begin
               case cmd of

                    'd':  begin
                            cmd := 'X';
                            finished := true;
                            must_unmount := false;
                          end;
                    'r':  cmd := 'd';
                    'f':  cmd := 'r';
               end;
          end
          else
               finished := true;

     until finished;

     case cmd of

          'd':  begin
                  writeln('Device is def mounted');
                  mount_state := m_def;
                end;
          'r':  begin
                  writeln('Device is real mounted');
                  mount_state := m_real;
                end;
          'f':  begin
                  writeln('Device is FS mounted');
                  mount_state := m_fs;
                end;
          'X':  writeln('Device could not be mounted');
     end;
end;







procedure  DoUnmount(var device : integer;  var ecode : integer);

begin
     ecode := 0;

     case mount_state of

          m_def:
                 def_unmount(ecode, device);
          m_real:
                 real_unmount(ecode, device);
          m_fs:
                 fs_unmount(ecode, device);
     end;
     device := -1;
     must_unmount := false;
     if ecode > 0 then
     begin
          writeln('*** Error ',ecode:4,' unmounting device');
          writeln;
     end;
end;





(*****************************************************************************)
(*  SWITCHVOL:  Change the current volume being accessed                     *)
(*****************************************************************************)

procedure  SwitchVol(var device : integer; first_time : boolean);

label   2;

var
     name : e_name;
     temp_device : integer;
     VolName : e_name;
     ecode, locl_ecode : integer;
     finished : boolean;

begin
     writeln;
     finished := false;

     if first_time then  (* Sleazy compromise with FS_UTILITIES interface *)
     begin
          name := DeviceName;
          goto 2;
     end;

     (*  Display the current mount state  *)

     case mount_state of

          m_def:
             writeln('Current Def-mounted device is ',configinfo[device]^.devname);
          m_real:
             writeln('Current Real-mounted volume is ',mounttable[device]^.name,
                     ' on device ',configinfo[device]^.devname);
          m_fs:
             writeln('Current FS-mounted volume is ',mounttable[device]^.name,
                     ' on device ',configinfo[device]^.devname);
     end;

     writeln;

     (*  query for name of new volume  *)

     repeat
          writeln;
          write('device/volume: ');
          readln(name);
2:

          (* remove a possible leading '-' from the name *)

          if name[1] = '-' then
               delete(name, 1, 1);

          temp_device := map_dev_name(name);

          (* CR causes exit if a valid device number is still around *)

          if (name = '') and (device >= 0) then
               finished := true

          (* Otherwise demand a valid device number *)

          else if temp_device < 0 then
               writeln('Cannot mount device/volume')

          else if not configinfo[temp_device]^.blockstructured then
               writeln('Device is not block-structured')

          else
          begin
               ecode := 0;

               (*
                *  Got a good device number.  Now unmount the current device,
                *  and mount the new device.
                *)
               if must_unmount then
                    DoUnmount(device, locl_ecode);

               if mounttable[temp_device] = pointer(BADPTR1) then
                    DoMount(temp_device, ecode)
               else
                   (*  Device is already (FS)mounted and ready to go  *)

                    mount_state := m_fs;

               (*  Let the user out only if the new mount succeeded  *)

               if ecode <= 0 then
               begin
                    finished := true;
                    device := temp_device;
               end;
          end;

     until finished;
end;


procedure  ChkChain ( device : integer );

var
     page_no  : longint;
     PageBuf  : tFullPage;
     LastHint : PageLabel;
     ecode    : integer;
     break    : boolean;

     function  CmpHints ( Hint1, Hint2 : PageLabel ) : boolean;

     begin
          with Hint1 do
          begin
               CmpHints :=
                   (( version <> Hint2.version   ) or
                    ( fileid <> Hint2.fileid     ) or
                    ( abspage <> Hint2.bkwdlink  ) or
                    ( relpage <> Hint2.relpage-1 ) or
                    ( fwdlink <> Hint2.abspage   ) or
                    ( dataused < 0               ) or
                    ( dataused > 512             ) or
                    ( volume <> 0                ));
          end;
     end;

begin
     write('starting page: ');  readln(page_no);
     writeln;  writeln;
     PageIO(page_no, device, PageBuf.hint, ord(@PageBuf.data), readop, ecode);
     if ecode <> 0 then
          writeln('* error ',ecode:4,' reading page ',page_no:4);
     LastHint := PageBuf.hint;
     page_no := PageBuf.hint.fwdlink;
     break := FALSE;
     while (ecode <= 0) and (page_no > 0) and (not break) do
     begin
          PageIO(page_no, device, PageBuf.hint, ord(@PageBuf.data), readop, ecode);
          if ecode <> 0 then
               writeln('* error ',ecode:4,' reading page ',page_no:4);
          break := CmpHints(LastHint, PageBuf.hint);
          if not break then LastHint := PageBuf.hint;
          page_no := PageBuf.hint.fwdlink;
     end;
     if break then
     begin
          writeln('          *** BREAK ***');
          writeln;
          DumpLabel(LastHint);
          DumpLabel(PageBuf.hint);
     end
     else
          writeln('End of chain at page ',PageBuf.hint.abspage:4);
end;




begin
     InitDumpSys;

     writeln;  writeln;
     writeln('***  Welcome to the Libra volume check utility  ***');
     writeln;

     SwitchVol(CurDevice, true);
     writeln;

     Dump(CurDevice, [pgdata, pglabel], true);

     repeat

          write('V(olume  P(age  L(abel  S(list  R(ootcat  F(lush  C(hain  Q(uit ? ');
          read(command);   writeln;
          AdjustCase(command);

          case command of

               'v':   (* change current volume *)
                      SwitchVol(CurDevice, false);

               'p':   (* page dump  *)
                      Dump(CurDevice, [pgdata, pglabel], false);

               'l':   (* page label dump *)
                      Dump(CurDevice, [pglabel], false);

               's':   (* s-list dump *)
                      SlistMgr(CurDevice);

               'r':   (* root catalog dump *)
                      RootCatMgr(CurDevice);

               'f':   (* flush the FS buffers *)
                      flushfs(errnumber);

               'z':   (* password allows alteration of FS structures *)
                      GetPassword(priv);

               'c':   (* verify a chain of pages *)
                      ChkChain(CurDevice);

               otherwise
          end;

     until command = 'q';

     (*  Make sure a volchk-mounted volume isn't left around  *)

     if must_unmount then
          DoUnmount(CurDevice, errnumber);

     flushfs(errnumber);    (*  clean out the cache  *)

end;   (* DumpSys *)

{$ENDC}

END.


