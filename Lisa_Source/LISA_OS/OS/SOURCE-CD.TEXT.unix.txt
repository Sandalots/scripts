      (*  Copyright 1983, 1984, Apple Computer Inc. *)

{File: source/cd}

UNIT CD;

INTERFACE

USES
     (*$U object/driverdefs.obj*)  driverdefs,
     (*$U object/hwint.obj*)       hwint,
     (*$U object/sysglobal.obj *)  globaldata,
     (*$U object/procprims.obj *)  proc_prims,
     (*$U object/mmprim.obj *)     mmprimitives,
     (*$U object/sched.obj *)      sched,
     (*$U object/asynctr.obj *)    asynctr,
     (*$U object/genio.obj *)      genio,
     (*$U object/twiggy.obj *)     twiggy,
     (*$U object/hdisk.obj *)      hdisk,
     (*$U object/vmstuff.obj *)    vmstuff,
     (*$U object/sfileio.obj *)    sfileio,
     (*$U object/fsprim.obj *)     fs_primitives,
     (*$U object/fsui.obj *)       fs_interface,
     (*$U object/pmem.obj *)       pm_interface,
     (*$U object/objio.obj *)      objio,
     (*$U object/mm0.obj *)        memorymanager,
     (*$U object/ds0.obj *)        datasegs,
     (*$U object/clock.obj *)      clock,
     (*$U object/osunitio.obj *)   osunitio,
     (*$U object/exceprim.obj *)   exceprim,
     (*$U object/eventchn.obj *)   eventchn,
     (*$U object/excepmgr.obj *)   excepmgr,
     (*$U object/timemgr.obj *)    timemgr,
     (*$U object/scavenger.obj *)  scavnger,
     (*$U object/volcheck.obj *)   volcheck,
     (*$U object/fsinit.obj *)     initialize,
     (*$U object/load.obj *)       loader,
     (*$U object/measure.obj *)    measure;

const
   permbitbucket = 8;   {configinfo index of the permanent bitbucket}

   twig_fs_block0 = 41; {number of boot blocks reserved to twiggy }

  {cpuodel values, showing which cpu board type is present: }
   cpub_lisa = 0;
   cpub_pepsi = 1;

  {iomodel values, showing which io board type is present: }
   iob_lisa = 0;
   iob_pepsi = 1;
   iob_twiggy = -1; {Pepsi, BUT with twiggies}
   iob_sony = 2;    {Lisa, BUT with builtin Sony}
   iob_lite = 3;    {Pepsi with Sony but no hard disk built-in}

   sys_err_base = 10000; {base of system error range}

  {STartupUP system error numbers:}
   badloaderparms=10700;{loader data version mismatch with startup}
   stup_nospace = 10701;{getspace failed during initialize}
                        {separately declared in mm8 module}
   stup_opmakerr=10702; {cant make system process}
   stup_didntblock = 10703;{blocked proc returned}
   stup_driver = 10704; {couldn't create driver}
   stup_twig = 10706;   {couldn't initialize twiggy}
   stup_fsinit = 10707; {couldn't initialize the filesystem}
   stup_mount = 10708;  {hard disk monitor mount table not readable}
   stup_cantmapscreen = 10709; {screen mmu is too long}
   stup_config_full = 10710; {slot quota in configinfo exhausted}
   stup_find_boot = 10738; {can't find boot cd}
   stup_load_boot = 10739; {can't load boot cd}
   stup_init_boot = 10740; {can't init boot cd}
   stup_seq_boot  = 10741; {can't boot from sequential device}

  {possible cd make/kill/info errors: }
   cdbadparms = 750;     {parameters corrupt/out of range}
   cdnodev = 751;        {no device at selected position}
   cdbusy = 752;         {device is busy}
   cdnotterm = 753;      {device is not a terminal node}
   cdbuiltin = 754;      {builtin device is operating there}
   cdisolated = 755;     {position is an isolated node}
   cdoccupied = 756;     {position is already occupied}
   cdnoparaport = 757;   {tried to configure non-existent parallel port}
   cdtoomany = 758;      {too many configured devices (configinfo entries full) }
   cdnospace = 701;      {sysglobal space not available}

   empty = -1;           {whether slot/chan/dev position exists (in configinfo)}

  {indexes into 'pmid', below, and 'cdbooter' decl (see startup)}
   devcd  = 1;
   chancd = 2;
   slotcd = 3;

  {maximum legit index of dimension (in parameter memory):}
   max_slot = 14;
   max_chan = 6;
   max_dev = 30;

  {index showing showing dimension is empty/irrelevant (in parameter memory)}
   emptyslot = 15;
   emptychan = 7;
   emptydev = 31;

   cdd_version = 5; {current version of the CDD data.}

  {potential values for self_ident field of devrec:}
   no_card = $7fff;
   not_slot = $7ffe;

type
   cd_infobuf = record
                  cd_driverid: longint;
                  cd_perm: boolean;
                  cd_drvrname: e_name;
                  case cd_devt: devtype of
                     diskdev:
                        (cd_start_block: longint;
                         cd_fs_start: longint;
                         cd_ejectable: boolean;
                         cd_removable: boolean;
                         cd_preload: boolean;)
               end; {of cd_infobuf}

   slot_array = array [1..3] of integer;

   ptrpathname = ^pathname; (*s/b USES*)
   arrybites = array [0..511] of byte;

   ld_filename = e_name;
   prompter = string[80];

{configurable driver records: }
   TypeConnect = string[32];

   Ch_info = record
      version: integer;
      driver_id: longint;
      bootable: boolean;
      preload: boolean;
      permanent: boolean;
      devicetype: devtype;
      size_exten: integer;
      def_cdinfo: array[1..3] of integer;
      removable: boolean;
      ejectable: boolean;
      fs_start_block: longint;
      start_block: longint;
      numattach: integer;
      numConnectors: integer;
   {  Attachment: array[0..0] of TypeConnect; (Optional repeating groups)}
   {  Connector: array[0..0] of TypeConnect;                             }
   end; {of Ch_info}

   cddEntry = record
      drvr_name: e_name;
      active:  integer;
      info: ch_info;
   end; {of cddEntry}

   cddHeader = record
      version: integer;
      cdcount: integer;
   end; {of cddheader}

   systemCdd = record
      descr: cddheader;
   {  info: array[0..0] of cddEntry;  (Optional repeating group)}
   end; {of system.cdd}

var
   pmpos: array [1 {devcd} .. 3 {slotcd}] of cd_position;{Inited by Init_boot_cds}

{loader call administration}
   procedure LD_INITMEDIA(a5value: longint);
   procedure LD_DISABLE;

{loader calls:}
   function  LD_OPENINPUT(var inputfile: ld_filename) : boolean;
   procedure LD_FILLBUF(byteadr: longint);
   function  LD_GETBYTE: byte;
   function  LD_GETWORD: integer;
   function  LD_GETLONG: longint;
   procedure LD_MOVEMULTIPLE(bytecount:longint; destination:longint);
   procedure LD_READSEQ  (block, destination: longint; pages: integer);
   procedure LD_READBLOCK(block, destination: longint);

   function  FIND_EMPTYSLOT(var config_index: integer): boolean;
   function  ENABLEDBG(enableit : boolean) : boolean;
   function  ADR_DISK_CONTROL(slot, chan : integer) : absptr;
   procedure OSBOOTVOL(var error : integer; var bootname: e_name);
   procedure CARDS_EQUIPPED(var error : integer;
                            var in_slot : slot_array);
   procedure MACH_INFO(var error : integer; var the_info: minfo);
(*$IFC FALSE*)
   procedure INITCONSOLE(which_config : integer);
(*$ENDC*)
   procedure MAKE_NAME(var itsname: e_name; slot, chan, dev: integer);
   procedure MAKE_DISK_INFO(wrkptr : ptrdevrec;
                            slot, chan, devno : integer);
   function ALREADY_EXISTS(slot, chan, dev: integer;
                         var builtin: boolean; var where: integer) : boolean;

   procedure NEW_DEVICE(var error: integer;
                            which_config, slot, chan, dev: integer;
                        var the_info: cd_infobuf);

   procedure MAKE_INTERNAL(var this_pos: cd_position);

   procedure CDINFO(var error: integer;
                        the_pos: cd_position;
                    var the_info: cd_infobuf);
   procedure CDKILL(var error: integer;
                        the_pos: cd_position);
   procedure CDMAKE(var error: integer;
                        the_pos: cd_position;
                    var this_info: cd_infobuf);

   procedure INIT_CDS;
   procedure UNLOAD_DRIVER(var errnum: integer; addr: absptr);
   procedure LOAD_DRIVER(var errnum: integer;
                         var codebase: absptr;
                             drvrname: e_name);

   function  EXISTS_CARD(x : absptr) : boolean;
   function  GET_ID_FIELD(control_adr: absptr) : integer;

IMPLEMENTATION

{WARNING!!  Some of these constants/types are declared in LDLFS, too.}
const
  {opcodes identifying each of the loader calls:}
   call_open = 0;
   call_fill = 1;
   call_byte = 2;
   call_word = 3;
   call_long = 4;
   call_move = 5;
   call_read = 6;

type

   fake_parms = record {fields used to communicate with the loader:}
                   error:  integer;
                   opcode: integer;
                   addr:   longint;
                   header: longint;
                   blok:   longint;
                   count:  longint;
                   result: boolean;
                   longvalue: longint;
                   wordvalue: integer;
                   bytevalue: byte;
                   path:   ld_filename;
                end; {of fake_parms}

var
   boot_accessible: boolean;
   ldr_a5: longint;  {contents of loader program A5 register}


   function  EXISTS_CARD(*x : absptr) : boolean *); external;
   function  GET_ID_FIELD(*control_adr: absptr) : integer*); external;
   procedure INIT_READ_PM(bufptr : absptr); external;


(*********)
(*$S init*)
(*********)

procedure ENTER_LOADER(var params: fake_parms; a5: longint); external;

procedure LDR_CALL(var params: fake_parms);
var
   oldvalue : intson_type;
begin
   with params do
      begin
         error := 0;
         if not boot_accessible then SYSTEM_ERROR(10726); {boot device 'read' failed}
         INTSOFF(allints, oldvalue);
         ENTER_LOADER(params, ldr_a5);
         INTSON(oldvalue);
         if error <> 0 then SYSTEM_ERROR(10726);          {all errors are assumed to be fatal}
      end;
end; {of ldr_call}



procedure LD_INITMEDIA(* a5value: longint *); {initialize interface to loader}
begin
   boot_accessible := true;
   ldr_a5 := a5value;
end; {of ld_initmedia}



procedure LD_DISABLE; {bar the door, the loader's driver gone}
begin
  boot_accessible := false;
end; {of ld_read_enable}



function LD_OPENINPUT (*var inputfile: ld_filename) returns boolean*);
var
   cheater: fake_parms;
begin
with cheater do
   begin
      opcode := call_open;
      path := inputfile;
      LDR_CALL(cheater);
      ld_openinput := result;
   end;
end; {of ld_openinput}



procedure LD_FILLBUF (*byteadr: longint *);
var
   cheater: fake_parms;
begin
with cheater do
   begin
      opcode := call_fill;
      addr := byteadr;
      LDR_CALL(cheater);
   end;
end; {of ld_fillbuf}



function LD_GETBYTE (* returns byte *);
var
   cheater: fake_parms;
begin
with cheater do
   begin
      opcode := call_byte;
      LDR_CALL(cheater);
      ld_getbyte := bytevalue;
   end;
end; {of ld_getbyte}



function LD_GETWORD (* returns integer *);
var
   cheater: fake_parms;
begin
with cheater do
   begin
      opcode := call_word;
      LDR_CALL(cheater);
      ld_getword := wordvalue;
   end;
end; {of ld_getword}



function LD_GETLONG (* returns longint *);
var
   cheater: fake_parms;
begin
with cheater do
   begin
      opcode := call_long;
      LDR_CALL(cheater);
      ld_getlong := longvalue;
   end;
end; {of ld_getlong}



procedure LD_MOVEMULTIPLE (*bytecount:longint; destination:longint *);
var
   cheater: fake_parms;
begin
with cheater do
   begin
      opcode := call_move;
      count := bytecount;
      addr := destination;
      LDR_CALL(cheater);
   end;
end; {of ld_movemultiple}



procedure LD_READSEQ (* block, destination :longint;
                         pages  :integer *);
var
   mybuffer: pagelabel;
   cheater: fake_parms;
begin
with cheater do
   begin
      opcode := call_read;
      addr := destination;
      blok := block;
      count := pages;
      header := ord4(@mybuffer);
      LDR_CALL(cheater);
   end;
end; {of ld_readseq}



procedure LD_READBLOCK (* block, destination: longint *);
begin
   LD_READSEQ(block, destination, 1 {block} );
end; {of ld_readblock}


(***********)
(*$S initcd*)  {configurable drivers segment}
(***********)


procedure BUILDNAME(i : integer; var target : e_name);
       (*************************************************************)
       (*
       (* Description:
       (*    Create a 2-digit string from an integer.
       (*
       (* Input Parameter:
       (*    i - the integer
       (*
       (* Output Parameter:
       (*    target - the string
       (*
       (* Note: the integer is scarcely range checked.  Caller beware.
       (*
       (*************************************************************)
var
   s1 : string[2];
begin
   s1 := 'XX';   {establish string length}
   if (i>=0) and (i<=99) then
   begin
      s1[1] := chr (ord ('0') + i div 10); {tens digit}
      s1[2] := chr (ord ('0') + i mod 10); {units digit}
   end;
   if (i>=0) and (i<10) then delete (s1, 1, 1);  {remove redundant zero}
   target := concat (target, s1);
end; {of buildname}



function FIND_EMPTYSLOT(*var config_index: integer) : boolean *);
      (************************************)
      (*
      (* Description:
      (*     Find the last bitbkt in configinfo, when searching from the
      (*     high end.  If that is also the ONLY bitbkt, or if no bitbkt exists,
      (*     then return false, otherwise return true.
      (*
      (*     This call will not find the OFFICIAL bitbkt (index=8).
      (*
      (* Output Parameter:
      (*     Find_emptyslot returns whether an empty position was found.
      (*     Config_index returns the found position in configinfo, if any.
      (*
      (*
      (************************************)
var
   i: integer;
begin
   config_index := 0;
   i := maxdev;
   repeat
      if (configinfo[i]^.devname = 'BITBKT') then
         begin
            config_index := i;
            find_emptyslot := true;
            EXIT(find_emptyslot);
         end;
      i := i - 1
   until i<8 {the official bitbkt};
   find_emptyslot := false; {No bitbkt is available}
end; {of find_emptyslot}



function ENABLEDBG(*enableit : boolean) : boolean *);
      (************************************)
      (*
      (* Description:
      (*     If lisabug exists, then set the lisabug enabled flag
      (*        to the value requested in 'enableit'.
      (*     If lisabug is NOT loaded,the flag can't be enabled.
      (*
      (* Output Parameter:
      (*     The final value of the lisabug enabled flag.
      (*
      (************************************)
var
   error : integer;
begin
   if lb_loaded then lb_enabled := enableit;
   enabledbg := lb_enabled;

   if lb_enabled then Lock_debugRes
     else Unlock_debugRes
end; {of enabledbg}



function ADR_DISK_CONTROL(*slot, chan : integer) : absptr *);
    (*************************************************************)
    (*
    (* Description:
    (*    Calculate the address of control logic for a given
    (*      slot/channel position.  The numbering of slots is from
    (*      0 to 2.  A slot of 'empty' means the parallel port.
    (*
    (*************************************************************)
const
   slot_base = $FC2001;         {adr of logic for slot 0}
   slot_offset = $4000;         {offset to next slot}
   chan_offset = $800;
   para_port = $fcd901;    {adr of logic for parallel port}

begin
   if slot=empty then ADR_DISK_CONTROL := para_port
   else ADR_DISK_CONTROL := slot_base + ord4(slot_offset) * slot +
                         chan_offset * chan;
end; {of adr_disk_control}



procedure CARDS_EQUIPPED(*var error : integer;
                          var in_slot : slot_array*);
      (************************************)
      (*
      (* Description:
      (*     CARDS_EQUIPPED returns in in_slot[1..3] what card,
      (*     if any, is plugged in there.  Prom-less cards are
      (*     assumed to be n-port cards.
      (*
      (************************************)
var
   i : integer;
   control_adr : absptr;
   any_card : boolean;
   parmarr: parmcheck;
   result : integer;

begin
   (*$IFC DEBUG1*)
   with parmarr do
      begin
         numcheck:=1;
         parms[1].addr:=ord(@in_slot[1] );
         parms[1].readwrite:=true;
      end;
   if not VALID_ADDR(error,parmarr) then
       EXIT(cards_equipped);                {also inits the error var}
   (*$ELSEC*)
   error := 0;
   (*$ENDC*)

   for i := 0 to 2 do {all slots}
      begin
        control_adr := ADR_DISK_CONTROL(i,0)-$2000 {convert to low-select};
        any_card := EXISTS_CARD(control_adr);
        result := 0;
        if any_card then
           result:= GET_ID_FIELD(control_adr);
        in_slot[i+1] := result;
      end; {of for loop}
end; {of cards_equipped}


procedure OSBOOTVOL(*var error : integer; var bootname: e_name*);
      (************************************)
      (*
      (* Description:
      (*     OSBOOTVOL returns the name of the boot device.
      (*
      (************************************)
var
   parmarr: parmcheck;
begin
   (*$IFC DEBUG1*)
   with parmarr do
      begin
         numcheck:=1;
         parms[1].addr:=ord(@bootname);
         parms[1].readwrite:=true;
      end;
   if not VALID_ADDR(error, parmarr) then
       EXIT(osbootvol);                {also inits the error var}
   (*$ELSEC*)
   error := 0;
   (*$ENDC*)
   bootname:=configinfo[bootdev]^.devname;
end; {of osbootvol}




procedure MACH_INFO(*var error : integer; var the_info: minfo*);
      (************************************)
      (*
      (* Description:
      (*    Report the machine information.
      (*
      (* Output Parameters:
      (*    Record 'the_info' returns:
      (*       Cpu_board - identifies the cpu version:
      (*          cpub_lisa, cpub_pepsi.
      (*
      (*       Io_board - identifies the io board version:
      (*          iob_lisa, iob_pepsi, iob_sony, iob_twiggy.
      (*
      (*       Memsize - total amount of memory, in bytes.  (Doesn't reflect any
      (*          parameter memory/osconfig memory downsizing of usable memory.)
      (*
      (* Implementation Notes:
      (*    There are not any differences between the Lisa/Pepsi CPU board.
      (*    The Cpu_board parameter always returns cpub_lisa, until we can
      (*    discover any relevant differences.
      (*
      (************************************)
const
   memadr = $2a8;  {place where prom remembers the amount of memory}
var
   poker: ^longint;
   parmarr: parmcheck;
begin
   (*$IFC DEBUG1*)
   with parmarr do
      begin
         numcheck:=1;
         parms[1].addr:=ord(@the_info);
         parms[1].readwrite:=true;
      end;
   if not VALID_ADDR(error,parmarr) then        {also inits the error var}
       EXIT(mach_info);
   (*$ELSEC*)
   error := 0;
   (*$ENDC*)
   with the_info do
      begin
         cpu_board := cpumodel;
         io_board := iomodel;
         if io_board = iob_twiggy then io_board := iob_pepsi;
         poker := pointer(memadr);
         memsize := poker^;
      end;
end; {of mach_info}



(*$IFC FALSE*)
procedure INITCONSOLE(*which_config : integer*);
    (*************************************************************)
    (*
    (* Description:
    (*    Initialize a console channel:
    (*
    (* Input Parameter:
    (*    Which_config - which config_info index is being initialized.
    (*
    (*************************************************************)
type rec = array[0..1] of ptrdevrec;
var
   errnum : integer;
   parm : params;
   config_ptr: ptrdevrec;
   recptr: ^rec;
begin
   if port_cb_ptrs.screen = 0 then
     if not GETSPACE(sizeof(rec),b_sysglobal_ptr,port_cb_ptrs.screen) then
       SYSTEM_ERROR(stup_nospace);
   config_ptr:=configinfo[which_config];
   recptr:=pointer(port_cb_ptrs.screen);
   recptr^[config_ptr^.iochannel]:=config_ptr;
   config_ptr^.cb_addr:=ord(nil);
   parm.fnctn_code := dinit;
   CALLDRIVER(errnum, config_ptr, @parm);
   if errnum> 0 then
      begin
        (*$IFC DEBUG2*)
         writeln('Startup: console channel didn''t initialize, error =',errnum);
        (*$ENDC*)
         SYSTEM_ERROR(stup_driver);
      end;
end; {of INIT_CONSOLE}
(*$ENDC*)


procedure MAKE_NAME(*var itsname: e_name; slot, chan, dev: integer*);
begin
   itsname := '#';
   BUILDNAME(slot+1, itsname);
   if (chan <> emptychan) then
      begin
         itsname := CONCAT(itsname, '#');
         BUILDNAME(chan+1, itsname);
      end;
      if (dev <> emptydev) then
         begin
            itsname := CONCAT(itsname, '#');
            BUILDNAME(dev+1, itsname);
         end;

(*$IFC FALSE*)  {YESTERDAYS HEADLINES FAKE IN THE WIND}
  {SPECIAL CASE ALIASING: }
   if (slot = cd_console) then
      if (chan = 0)      then itsname := 'ALTCONSOLE'
      else if (chan = 1) then itsname := 'MAINCONSOLE';
(*$ENDC*)

end; {of make_name}



procedure MAKE_DISK_INFO(*wrkptr : ptrdevrec;
                          slot, chan, devno : integer*);
    (*************************************************************)
    (*
    (* Description:
    (*    Fill in the configinfo fields for a disk device.
    (*
    (*************************************************************)
var
   errnum: integer;
   parm : params;
   ext_ptr: ^ext_diskconfig;
begin
   with wrkptr^ do
   begin
      if not GETSPACE(sizeof(ext_diskconfig),b_sysglobal_ptr,ext_addr)
        then SYSTEM_ERROR(stup_nospace);
      cb_addr:=ord(nil);
      ext_ptr:=pointer(ext_addr);

      blockstructured := true;
      iochannel := chan;
      slot_no := slot;
      self_ident := not_slot;
      permreq_ptr:= nil; (*no pre-allocated request block*)
      preq_avail:= false;
      drvrec_ptr := ord(nil);  (*flagged as not yet configurable*)

      device_no:=devno;
      devt:=diskdev;
      entry_pt:=ord(@TWIGIO);
      with ext_ptr^ do
        begin
          strt_blok:=0;
          num_bloks:=1684;
          fs_strt_blok:=twig_fs_block0;
          ejectable := true;
          removable := true;
          rvrs_hdr := 0;
        end;
   end; {of with wrkptr}
end; {of make_disk_info}



function NEW_CULT(var error: integer;
                      dogma: longint;
                  var bible: longint) : boolean;
   (**********)
   (*
   (*  Returns the address of this religion's holy book and whether it
   (*  has ever been seen before, ie:
   (*    TRUE if it has NOT been seen before, FALSE otherwise.
   (*
   (*  If the cult is new, we return the address of the new holy book.
   (*
   (**********)
var
   i: integer;
   workptr: ^drvrec;

begin
   error := 0;
   for i := 0 to maxdev do
      WITH configinfo[i]^ do
         if (devt <> bitbkt) then {this configinfo entry 'exists'}
            begin
               workptr := pointer(drvrec_ptr);
               if (workptr <> nil) then {this is a quiche}
                  if (workptr^.driver_id = dogma) then
                     begin
                        new_cult := false;
                        bible := drvrec_ptr;
                        EXIT(new_cult);
                     end;
            end;
  {to get here, the cult does NOT yet exist:}
   if GETSPACE(SIZEOF(drvrec), b_sysglobal, bible) then new_cult := true
   else error := stup_nospace;
end; {of new_cult}



function ALREADY_EXISTS(*slot, chan, dev: integer;
                         var builtin: boolean; var where: integer) : boolean *);
   (***********)
   (*
   (* Returns whether configinfo already has stuff in this position.
   (*
   (*  If the function returns TRUE, we also return the configinfo entry's index,
   (*  in 'where', and whether it is builtin (which includes pseudo-config case).
   (*
   (**********)
var
   i: integer;
   workptr: ^drvrec;
begin
   already_exists := false; {til proven otherwise}
  {convert to internal notation:}
   if chan = emptychan then chan := empty;
   if dev  = emptydev  then dev := empty;
   for i := 0 to maxdev do
      WITH configinfo[i]^ do
         begin
            if (devt <> bitbkt) then {this configinfo entry 'exists'}
               if (slot = slot_no) and (chan = iochannel) and
                  (dev = device_no) then {got it!}
                  begin
                     already_exists := true;
                     if (drvrec_ptr = ord(nil) ) then builtin := true
                     else
                        begin {pseudo-configed is ALSO considered builtin}
                           workptr := pointer(drvrec_ptr);
                           builtin := (workptr^.driver_id <= 0)
                        end;
                     where := i;
                     EXIT(already_exists);
                  end;
         end; {of for/with loop}
end; {of already_exists}



function TERMDRVR(slot, chan, dev: integer) : boolean;
   (***********)
   (*
   (* Returns whether this position is a terminal driver node.
   (*
   (**********)
var
   i: integer;
begin
   termdrvr := true; {til proven otherwise}
   if (dev = emptydev) then {descendent possible}
      for i := 0 to maxdev do
         WITH configinfo[i]^ do
               if (devt <> bitbkt) then {this configinfo entry 'exists'}
                  if (slot = slot_no) then {slot matches}
                     if (chan = emptychan) then {looking for firstborn}
                        begin
                           if (iochannel <> empty) then {this is a descendent}
                           begin
                              termdrvr := false;
                              EXIT(termdrvr);
                           end;
                        end
                     else {looking for descendent at device level}
                        if (chan = iochannel) then {channel matches}
                           if (device_no <> empty) then {this is a descendent}
                              begin
                                 termdrvr := false;
                                 EXIT(termdrvr);
                              end;
end; {of termdrvr}



(*$IFC debug2*)
 procedure SHOWPOS(var message: prompter; slot, chan, dev: integer);
    (***********)
    (*
    (* Display an error message, including the position where it was detected.
    (*
    (***********)
 begin
     writeln(message,' at position:');
     writeln('  Slot ',slot+1);
     if (chan <> emptychan) then
        begin
           writeln('  Chan ',chan+1);
           if (dev <> emptydev) then
              writeln('  Dev  ',dev+1);
        end;
     writeln;
 end; {of showpos}
(*$ENDC*)


procedure NEW_DEVICE(* var error: integer;
                           which_config, slot, chan, dev: integer;
                       var the_info: cd_infobuf*);
       (*************************************************************)
       (*
       (* Description:
       (*    Create a configinfo entry for a new device.
       (*
       (* Input Parameters:
       (*    which_config - which configinfo index was reserved for our use
       (*    slot/chan/dev - which position is being defined.
       (*    the_info - has its attributes
       (*
       (* Output Parameters:
       (*    New_device - returns which configinfo entry was inited.
       (*
       (* Notes:
       (*    The caller is responsible for all parameter range checking and
       (*    reasonableness validation.  This procedure just DOES IT!
       (*
       (*    The caller is responsible for filling in the 'required driver' field,
       (*    and for turning off interrupts BEFORE calling this proc, and leaving
       (*    them off until the required driver field IS filled in.
       (*
       (*    We explicitly guard against creating a CD driver for the
       (*    parallel port on pepsi systems.  The utilities reading
       (*    parameter memory free us from having to similarly check for
       (*    the internal disk being made on lisa systems.
       (*
       (*************************************************************)
const
   maxcharges = 10; {how many times, for one configinfo entry, we can charge_it}
var
   charges: array[1..maxcharges] of longint;
   nextcharge: integer; {which is the next index to record charges in}
   prompt: prompter;
  {building configinfo entry vars: }
   workptr2: ^drvrec;
   ordadr: longint;
   ext_adr: ^ext_diskconfig;
   workptr: ptrdevrec;
   looker: minfo;
   card_id: slot_array;


  procedure PAYBILLS;
     (***********)
     (*
     (* Clears all record of credit purchases.
     (*
     (**********)
  var i: integer;
  begin
     nextcharge := 1;
     for i := 1 to maxcharges do
        charges[i] := 0;
  end; {of paybills}



  procedure REVOKE_CHARGES;
     (***********)
     (*
     (* Free up the space allocated to sysglobal via mastercharge.
     (*
     (***********)
  var i: integer;
  begin
     if (nextcharge > 1) then
        for i := 1 to nextcharge-1 do
           RELSPACE(charges[i], b_sysglobal);
  end; {revoke_charges}



  procedure CHARGE_IT(size: longint; var addr: longint);
     (***********)
     (*
     (*  Allocate the requested 'size' block, returning its address in addr.
     (*  Charge_it returns whether the block was allocated.
     (*
     (*  Accounting is done so that repayments can be made if the purchases
     (*  are returned.
     (*
     (**********)
  begin
     if GETSPACE(size, b_sysglobal, addr) then
        begin
           if (nextcharge <= maxcharges) then
              begin
                 charges[nextcharge] := addr;
                 nextcharge := nextcharge + 1;
              end;
         end
     else
        begin
          (*$IFC debug2*)
           writeln('Can''t get space for driver initialization.');
          (*$ENDC*)
           error := stup_nospace;
           REVOKE_CHARGES;
           EXIT(new_device);
        end;
  end; {of charge_it}


begin {**** new_device starts here ****}

   if (slot = cd_paraport) then
      begin
          MACH_INFO(error, looker);
          if (looker.io_board = iob_pepsi) or (looker.io_board = iob_twiggy) then
             begin
                error := cdnoparaport; {paraport doesn't exist}
                EXIT(new_device);
             end;
      end;

   PAYBILLS; {start out with no debts}
   CHARGE_IT(sizeof(devrec), ordadr);
   workptr := pointer(ordadr);
   with workptr^, the_info do
      begin
         with port_cb_ptrs do
               if (chan = emptychan) {moma} then
               if (slot >= cd_slot1) and
                  (slot <= cd_slot3)  then
                  slotx[slot] := ord(workptr)
               else if (slot = cd_scc) then rs232 := ord(workptr)
               else if (slot = cd_sony) then floppy := ord(workptr)
               else if (slot = cd_twiggy) then floppy := ord(workptr)
               else if (slot = cd_paraport) then via1 := ord(workptr)
               else if (slot = cd_intdisk)  then via1 := ord(workptr);
         entry_pt := ord(nil);
         cb_addr := ord(nil);
         devt := cd_devt;
         if (cd_devt = diskdev) then
            begin
               CHARGE_IT(sizeof(ext_diskconfig), ext_addr);
               ext_adr := pointer(ext_addr);
               WITH ext_adr^ do
                  begin
                     hentry_pt := ord(nil);
                     num_bloks := 0;
                     fs_strt_blok := cd_fs_start;
                     strt_blok := cd_start_block;
                     removable := cd_removable;
                     ejectable := cd_ejectable;
                  end;
            end
         else ext_addr := ord(nil);
         MAKE_NAME(devname, slot, chan, dev);
         if NEW_CULT(error, cd_driverid, drvrec_ptr) then
            begin
               if (error > 0) THEN
                  begin
                     REVOKE_CHARGES;
                     EXIT(new_device);
                  end;
               workptr2 := pointer(drvrec_ptr);
               WITH workptr2^ do
                  begin
                     driver_id := cd_driverid;
                     INIT_SEM (sem, 1);
                     drvname := cd_drvrname;
                     nusers := 0;
                     e_pt := 0;
                     kres_addr := ord(nil);
                  end;
            end;
         permanent := cd_perm;
         blockstructured := (devt = diskdev);
         slot_no := slot; {can't be empty}
         if (chan = emptychan) then iochannel := empty else iochannel := chan;
         if (dev = emptydev)   then device_no := empty else device_no := dev;

         if (slot >= cd_slot1) and (slot <= cd_slot3) and (chan = emptychan) then
            begin
               CARDS_EQUIPPED(error, card_id);
               if (card_id[slot+1] = 0) then self_ident := no_card
               else self_ident := card_id[slot+1];
            end
         else self_ident := not_slot;

         required_drvr := nil;  {just in case no parent exists}
         preq_avail := (devt = seqdev); {allocated for sequentials}
         if preq_avail then
            begin
               CHARGE_IT(sizeof(reqblk)+sizeof(seq_extend), ordadr);
               permreq_ptr := pointer(ordadr);
            end
         else
            permreq_ptr := nil;

     (*$IFC debug2*)
       if TRACE(init, 50) then
         begin
            write('Creating configurable driver ');
            write(devname);
            prompt := '';
            SHOWPOS(prompt, slot, chan, dev);
         end;
     (*$ENDC*)

         configinfo[which_config] := workptr;
      end; {of with}
end; {of new_device}



(*$R-*) {we need range checking off}

procedure MAKE_INTERNAL(*var this_pos: cd_position*);
   (*****)
   (* Translate position name from the public to internal format.
   (*****)
begin
   with this_pos do
      begin
         slot := slot - 1; {doesn't check for 'empty' slot}
         chan := chan - 1;
         if (chan = empty) then
            begin
               chan := emptychan;
               dev  := emptydev;
            end
         else
           begin
              dev :=  dev - 1;
              if (dev = empty) then dev := emptydev;
           end;
      end;
end; {of make_internal}



procedure TRANSPOS(var error: integer;
                       this_pos: cd_position;
                   var some_slot, some_chan, some_dev: integer;
                   var the_info: cd_infobuf);
   (*****)
   (* Translate position name from the public to internal format,
   (*   and check for obvious sillyness.  ('The_info' isn't processed,
   (*   except to verify that its an accessible parameter.)
   (*****)
var
   parmarr: parmcheck;
begin
   (*$IFC DEBUG1*)
   with parmarr do
      begin
         numcheck:=1;
         parms[1].addr:=ord(@the_info);
         parms[1].readwrite:=true;
      end;
   if not VALID_ADDR(error,parmarr) then
       EXIT(transpos);                {also inits the error var}
   (*$ELSEC*)
   error := 0;
   (*$ENDC*)

   with this_pos do
      begin
         some_slot := slot - 1;
        {don't bother checking this case, since it's caught, imm. below:
          if (some_slot = empty) then some_slot := ...
         (end of don't bother) }
         some_chan := chan - 1;
         if (some_chan = empty) then
            begin
               some_chan := emptychan;
               some_dev  := emptydev;
            end
         else
           begin
              some_dev :=  dev - 1;
              if (some_dev = empty) then some_dev := emptydev;
           end;
      end;

 {slot (only) CAN'T be empty, and all must be in range. }
   if (some_slot > max_slot)  or (some_slot < 0) or
      (some_chan > emptychan) or (some_chan < 0) or
      (some_dev  > emptydev)  or (some_dev  < 0)
   then error := cdbadparms;
end; {of transpos}


(*$IFC debug2 *)  {restore range checking, based on global selections:}
(*$R+*)
(*$ELSEC*)
(*$R-*)
(*$ENDC *)



procedure CDINFO(*var error: integer;
                      the_pos: cd_position;
                  var the_info: cd_infobuf*);
       (*************************************************************)
       (*
       (* Description:
       (*    Reports whether any driver is active at a given position, and
       (*    a few driver attributes.
       (*
       (* Input Parameter:
       (*    the_pos - which position is of interest.
       (*
       (* Output Parameter:
       (*    What_dev - The type of device.
       (*    The_info - Returns driver attributes. Some fields are:
       (*       cd_drvrname - driver name.  (Builtin drivers return
       (*           a zero length string.)
       (*       cd_driverid  - Driver number, if configurable.  Builtin drivers
       (*           return -1.
       (*
       (*    Error(s):
       (*       750 - The position is out of the allowed range of devices.
       (*       751 - No device at the specified position.
       (*
       (*************************************************************)
var
   slot, chan, dev: integer;
   which_config: integer;
   dev_builtin: boolean;
   workptr: ^drvrec;
   workptr2: ^ext_diskconfig;
begin
   TRANSPOS(error, the_pos, slot, chan, dev, the_info);
   if (error > 0) then EXIT(cdinfo);

   if not ALREADY_EXISTS(slot, chan, dev, dev_builtin, which_config) then
      error := cdnodev
   else
      with configinfo[which_config]^, the_info do
         begin
            cd_devt := devt;
            cd_perm := permanent;
            if dev_builtin then
                  begin
                     cd_drvrname := '';
                     cd_driverid := -1;
                  end
               else cd_drvrname := devname; {AND expects workptr <> nil}
            workptr := pointer(drvrec_ptr);
            if workptr <> nil then cd_driverid := workptr^.driver_id;

            workptr2 := pointer(ext_addr);
            if blockstructured then with workptr2^ {ext_diskconfig} do
               begin
                  cd_start_block := strt_blok;
                  cd_fs_start := fs_strt_blok;
                  cd_ejectable := ejectable;
                  cd_removable := removable;
                  cd_preload := false; {not stored in configinfo}
               end
            else
               begin
                  cd_start_block := 0;
                  cd_fs_start := 0;
                  cd_ejectable := false;
                  cd_removable := false;
                  cd_preload := false;
               end;
         end; {of with configinfo}
end; {of cdinfo}



procedure CDKILL(*var error: integer;
                      the_pos: cd_position*);
       (*************************************************************)
       (*
       (* Description:
       (*    Deactivate the driver for the given position, freeing the driver's
       (*    resources.  Only a terminal position can be deactivated. Builtin
       (*    device drivers cannot be deactivated.
       (*
       (* Input Parameter:
       (*    the_pos - which position is of interest.
       (*
       (* Output Parameter:
       (*    Error(s):
       (*       750 - The position is out of the allowed range of devices.
       (*       751 - No device at the specified position.
       (*       752 - The device is busy.
       (*       753 - The position is not a terminal node.
       (*       754 - The position is controlled by a builtin driver.
       (*
       (*************************************************************)
var
   slot, chan, dev, i, ignor_error: integer;
   dev_builtin, no_other: boolean;
   which_config: integer;
   workptr: ^drvrec;
   ext_ptr: ^ext_diskconfig;
   dummy: cd_infobuf;

   procedure PDEV_CONTROL(var ecode: integer; devnum: integer; ccode: integer);
   var
      p: params;
   begin
     with p do
     begin
       fnctn_code := ccode;
     end;
     DRIVERCALL(ecode, devnum, @p);
   end;  (* of procedure pdev_control *)

begin
   TRANSPOS(error, the_pos, slot, chan, dev, dummy);
   if (error > 0) then EXIT(cdkill);

   if not ALREADY_EXISTS(slot, chan, dev, dev_builtin, which_config) then
           error := cdnodev
   else if dev_builtin then
           error := cdbuiltin {can't kill built-in drivers}
   else if not TERMDRVR(slot, chan, dev) then
           error := cdnotterm
   else {try to kill it}
      with configinfo[which_config]^ do
         begin
            FS_UNMOUNT(error, which_config);
            if error = 1196 then
               begin
                  error := cdbusy; {files still open}
                  EXIT (cdkill)
               end
            else {nothing is open there}
               begin
                  if (error < 0) or (error = 1062) {not mounted} then
                     error := 0;
                  if blockstructured then
                     begin
                        ext_ptr:=pointer(ext_addr);
                        if ext_ptr^.ejectable then
                           PDEV_CONTROL(ignor_error, which_config, dskunclamp);
                     end; {of blockstr}
                  permanent := false;
                  DOWN (ignor_error, configinfo[which_config], nil, 0); {get rid of driver}
               end;

               {deallocate all internal data blocks:}
                if (permreq_ptr <> nil) then
                   RELSPACE(ord(permreq_ptr), b_sysglobal);
                if (drvrec_ptr <> ord(nil)) then
                   begin
                      workptr := pointer(drvrec_ptr);
                      no_other := true;
                      for i := 0 to maxdev do
                         if configinfo[i]^.drvrec_ptr = ord(workptr) then
                            if no_other then {avoid noticing self}
                               no_other := (i = which_config);
                      with workptr^ do
                         if (nusers = 0) and no_other then
                            RELSPACE(drvrec_ptr, b_sysglobal);
                   end;
                if blockstructured then
                   RELSPACE(ext_addr, b_sysglobal);

               {reclaim configinfo entry:}
                RELSPACE(ord(configinfo[which_config]), b_sysglobal);
                configinfo[which_config] := configinfo[permbitbucket];
         end; {of with configinfo}
end; {of cdkill}



procedure CDMAKE(*var error: integer;
                      the_pos: cd_position;
                  var this_info: cd_infobuf*);
       (*************************************************************)
       (*
       (* Description:
       (*    Activate a driver at a given position.
       (*
       (* Input Parameter:
       (*    the_pos - which position is of interest.
       (*    this_info - the attributes of the driver.
       (*
       (* Output Parameter (in the ORDER they are detected):
       (*    Errors:
       (*       701 - No room for more devices (sysglobal is full).
       (*       750 - The position is out of the allowed range of devices.
       (*       755 - The position is neither a slot controller nor attached
       (*         to some other driver.
       (*       756 - The position is already occupied.
       (*       757 - Tried to create paraport when none exists.
       (*       758 - No room for more devices (configinfo is full).
       (*
       (* Implementation Note:
       (*   CDs need some sort of semaphore to protect configinfo.
       (*
       (*************************************************************)
var
   slot, chan, dev, boss_config, seekchan, dummy, new_config: integer;
   is_builtin, dummybool: boolean;
begin {cdmake}
   TRANSPOS(error, the_pos, slot, chan, dev, this_info);
   if (error > 0) then EXIT(cdmake);

  {see whether non-slot controllers have a boss, and, if so, who: }
   if (chan = emptychan) then boss_config := empty {slots don't need bosses}
   else
      begin
         if (dev = emptydev) then seekchan := emptychan else seekchan := chan;
         if not ALREADY_EXISTS(slot, seekchan, emptydev, is_builtin, boss_config)
         then
            begin
               error := cdisolated;
               EXIT(cdmake);
            end;
      end;

   if ALREADY_EXISTS(slot, chan, dev, dummybool, dummy) then
      begin
         error := cdoccupied;
         EXIT(cdmake);
      end;

   if not FIND_EMPTYSLOT(new_config) then
      begin
         error := cdtoomany;
         EXIT(cdmake);
      end;

   NEW_DEVICE(error, new_config, slot, chan, dev, this_info);
   if (error > 0) then EXIT(cdmake);
   if (boss_config <> empty) then
      configinfo[new_config]^.required_drvr := configinfo[boss_config];
end; {of cdmake}




procedure INIT_CDS;
   (********************)
   (*
   (*  Description:
   (*     Initialize configurable drivers.  Executing within the root process,
   (*     build configinfo entries for the configuration tree, and 'up' all
   (*     terminal nodes wanting to be preloaded.  The main task is to discover
   (*     the geometry of the positions.
   (*
   (*    Here's an example of a connection tree for a single slot:
   (*
   (*     Slot 0.....connects to.....Channel 0.....connects to.....Dev 0
   (*     moma                        first born                    adopted
   (*        \                              \
   (*         \                               \......and to........Dev 1
   (*          \                                                     adopted
   (*           \....and to..........Channel 1
   (*                                 also firstborn
   (*
   (*     Each slot has zero or more channels.  Each channel has zero or more
   (*     devices.   Slots and channels are terminal when nothing is attached
   (*     to them.  All devices are terminal.  Slots are 'moma's, channels are
   (*     'first born's, devices are 'adopted'.  The driver that supports
   (*     anyone is a popa.  A device's channel is its boss.  A channel's
   (*     slot is its boss.  Any position (slot/channel/device) without a popa
   (*     and a boss is an orphan, getting no further attention, except for
   (*     a moma, who has no need for a boss.  Each different driver
   (*     id defines a new religion.
   (*
   (*     A 'town' is the list of everyone's name, EXCEPT for popas, with their
   (*     vital statistics, where a 'name' is an index into the town array.  The
   (*     'pta' is the list of the names of all momas.  The 'brats' are all the
   (*     firstborn of a given moma.  The 'elks' are the list of all popas.
   (*
   (*      A driver who's code lives in the body of the OS (like builtins),
   (*      and whose configinfo info is inited without regard to the user
   (*      supplied (CDD) data (like builtins), but whose configinfo entry
   (*      includes a 'drvrec' (UNLIKE builtins} is called 'pseudo-configurable'.
   (*      Pseudo-config devices are recognized as part of the configuration
   (*      tree, but ONLY at the MOMA level of the tree.
   (*
   (*  Notes:
   (*  1) If we run out of sysglobal space while creating configinfo entries,
   (*     I'm careful to deallocate space for the configinfo entry
   (*     being built at that time, before quitting, but I totally neglect
   (*     a larger problem.  The larger problem is that only SOME of the
   (*     configinfo entries will have been created, in NO PARTICULAR ORDER, and
   (*     may depend on other configinfo entries that were dropped on the floor.
   (*
   (*     A possible solution is to ORDER the creation of configinfo entries,
   (*     so dangling drivers wouldn't be possible.  Another is to pay more
   (*     attention to cleaning up the dangling references.  Neither has yet
   (*     been pursued, nor justified, considering that the vulnerability is
   (*     only there when sysglobal runs out.
   (*
   (*  2) The ground rules of configuration programs (such as CDCONFIG) forbids
   (*     duplicate PM entries for the SAME position.
   (*
   (*     If parameter memory does have more than one entry for the same position
   (*     then the drivers are incorrectly linked, especially configinfo's
   (*     'required_drvr' field.  Code is included to detect the occurence
   (*     (if debug2 is true), but not to maintain consistency among the
   (*     affected driver's 'required_drvr' links.
   (*
   (********************)
const
   maxcdd   = 50; {top legit member of elks}
   maxpm    = 50; {maximum index of the array describing each position}
   not_occupied = 51;{maxpm + 1, please, to mark a non-entity}
type
   posrange  = 0..max_slot; {range of values for slot}
   cddrange  = 1..maxcdd;
   townrange = 1..maxpm;
   township  = 1..not_occupied; {townrange plus empty marker}

   census = record
                info: configdev;        {everything from parameter memory}
                relation: (moma, firstborn, adopted, orphan);
                terminal: boolean;
                made_it:  boolean; {whether configinfo was made}
                boss: integer; {positive values are in terms of a TOWNSHIP INDEX,}
                               {negative values are stored for pseudo-configured }
                               {   momas, and represent bosses CONFIGINFO INDEX. }
                provider: cddrange;     {which popa}
                index_config: integer;  {what is my configinfo index}
             end; {dossier}

   ptr_cddentry = ^cddentry;

var
   town :   array[townrange] of census;
   lastone: townrange; {index of last non-nil entry in town}
   pta:     array[posrange] of township;
   brats:   array[posrange] of township;
   elks:    array[cddrange] of ptr_cddentry;

   tindex: townrange;
   her_name: township;
   cindex: cddrange;
   position, which_slot: posrange;
   index, error, pm_error, itsrefnum, config_index, pseudo_index,
          last_citizen, value:  integer;
   actual, ordadr, key: longint;
   itsname: pathname;
   prefix: e_name;
   pmimage: pmemrec;
   cdd_descr: cddheader;
   wom: typeconnect;
   cddentries, conns: integer;
   giving_up, found_popa, feuding, pretender, is_builtin,
          pseudo_moma: boolean;
   workptr: ptrdevrec;
   int_level: intson_type;
   prompt: prompter;
   tree_buf: cd_infobuf;
   saved_pmem: pmemStatus;



   procedure STUFF_INFOBUF(var source: cddentry; var destiny: cd_infobuf);
      (********************)
      (*
      (*  Warning: a second copy of this routine exists in startup.
      (*   (dont ask why)
      (*
      (********************)
   begin
      with source.info, destiny do
      begin
         cd_driverid := driver_id;
         cd_perm := permanent;
         cd_drvrname := source.drvr_name;
         cd_devt := devicetype;
         cd_start_block := start_block;
         cd_fs_start := fs_start_block;
         cd_ejectable := ejectable;
         cd_removable := removable;
         cd_preload := preload;
      end;
   end; {of stuff_infobuf}



   function IS_BOOTER(btpos: cd_position) : boolean;
      (********************)
      (*
      (*  Description:
      (*     Returns whether a position is the same as one of the boot
      (*     CD positions.
      (*
      (********************)
   var
      foundit: boolean;
      i:integer;
   begin
      for i := devcd to slotcd do
         begin
            with pmpos[i] do
               foundit := (btpos.slot = slot) and
                          (btpos.chan = chan) and
                          (btpos.dev  = dev)  and
                          (btpos.slot <> emptyslot);
            if foundit then
               begin
                  is_booter := true;
                  EXIT(is_booter);
               end; {of foundit}
         end; {of for all levels}
      is_booter := false;
   end; {of is_booter}



  function FIND_POPA(id: longint; var name: cddrange) : boolean;
     (***********)
     (*
     (* Returns whether a father/driver_id is found in the elks club/directory.
     (*
     (**********)
  var i: cddrange;
  begin
     find_popa := false;
     for i := 1 to maxcdd do
        if (elks[i] <> nil) then
           if (elks[i]^.info.driver_id = id)
              then
                 begin
                    find_popa := true;
                    name := i;
                    EXIT(find_popa);
                 end;
  end; {of find_popa}



  procedure CLEANUP;
     (***********)
     (*
     (* Free up all the space allocated to the Elks club, and take a hike.
     (*
     (**********)
  var
     i : cddrange;
  begin
     pmem_state := saved_pmem; {init_cds mustn't count as the first read of pmem}
     INTSON(int_level); {just in case}
     for i := 1 to maxcdd do
        if (elks[i] <> nil) then
           RELSPACE(ord4(elks[i]), b_syslocal);
     EXIT(init_cds); {Here is the ONLY path out of init_cds}
  end; {of CLEANUP}



begin

(************* here begins the body of init_cds *******************)

  (*$IFC DEBUG2*)
   writeln;
   writeln;
  (*$ENDC*)

   saved_pmem := pmem_state; {init_cds mustn't count as the first read of pmem}
   giving_up := false;
   for position := 0 to max_slot do
      pta[position] := not_occupied;
   for cindex := 1 to maxcdd do
      elks[cindex] := nil;
   INTSOFF(allints, int_level); {init int_level, so it'll be available to CLEANUP}
   INTSON(int_level);

   OSBOOTVOL(error, prefix);

 {PROCESS THE CONFIGURABLE DRIVER DIRECTORY: }
   itsname := CONCAT('-', prefix, '-SYSTEM.CDD');
   OPEN(error, itsname, itsrefnum, [dread]);
   if (error > 0) then
      begin
        (*$IFC debug2*)
         writeln('INIT_CDS: Can''t open ',itsname,', error = ',error,'.');
        (*$ENDC*)
         CLEANUP;
       end;

   READ_DATA(error, itsrefnum, ord4(@cdd_descr), sizeof(cddheader), actual,
          sequential, 0);
   if (error > 0) or (actual <> sizeof(cddheader) ) then
      begin
        (*$IFC debug2*)
         write('INIT_CDS: Trouble reading from ',itsname);
         if (error > 0) then writeln(' error = ',error,'.') else writeln('.');
        (*$ENDC*)
        giving_up := true;
      end
   else
      begin
         cddentries := cdd_descr.cdcount;
         if (cdd_descr.version <> cdd_version) or (cddentries < 0) or
                    (cddentries > maxcdd) then
            begin
              (*$IFC debug2*)
               writeln('INIT_CDS: Contents of ',itsname,' are not usable.');
              (*$ENDC*)
              giving_up := true;
            end
         else {go for it}
            if (cddentries > 0) then
               for cindex := 1 to cddentries do
                  if not giving_up then
                     if not GETSPACE(sizeof(cddentry), b_syslocal, ordadr)
                     then
                        begin
                          (*$IFC debug2*)
                           writeln('INIT_CDS: Couldn get workspace to initialize driver.');
                          (*$ENDC*)
                           giving_up := true;
                        end
                     else
                        begin
                           elks[cindex] := pointer(ordadr);
                           READ_DATA(error, itsrefnum, ordadr, sizeof(cddentry),
                                 actual, sequential, 0);
                           if (error > 0) or (actual <> sizeof(cddentry) ) then
                              begin
                                (*$IFC debug2*)
                                 write('INIT_CDS: Trouble reading file ',itsname);
                                 if (error > 0) then writeln(' error = ',error,'.')
                                 else writeln('.');
                                (*$ENDC*)
                                 giving_up := true;
                              end;
                           with elks[cindex]^ do
                              begin
                                 conns := info.numAttach + info.numConnectors;
                                 if conns > 0 then for key := 1 to conns do {skip connector list}
                                    begin
                                       READ_DATA(error, itsrefnum, ord(@wom), sizeof(typeconnect),
                                             actual, sequential, 0);
                                       if (error > 0) or (actual <> sizeof(typeconnect) ) then
                                          begin
                                            (*$IFC debug2*)
                                             write('INIT_CDS: Trouble reading file ',itsname);
                                             if (error > 0) then writeln(' error = ',error,'.')
                                             else writeln('.');
                                            (*$ENDC*)
                                             giving_up := true;
                                          end; {of failed reading conn list}
                                    end; {reading connector list}
                              end; {of with}
                        end; {of reading cdd entry}

      end; {of header was read}
   CLOSE_OBJECT(error, itsrefnum);
   if (error > 0) then
      begin
        (*$IFC debug2*)
         writeln('INIT_CDS: Couldn''t close ',itsname,', error = ',error,'.');
        (*$ENDC*)
         giving_up := true;
      end;
   if giving_up then CLEANUP;


  {READ IN PARAMETER MEMORY NEXT:}
   READ_PMEM(error, pmimage);
   if (error > 0) then
     begin
       (*$IFC debug2*)
        write('INIT_CDS: can''t read parameter memory');
        writeln(' error = ',error,'.');
       (*$ENDC*)
        CLEANUP;
     end;


  {TAKE CENSUS, REJECTING SOULS WITHOUT PROVIDERS, AND IDENTIFYING ALL MOMAS: }
   last_citizen := 0;
   key := 0; {next spot in pm}
   repeat
      WITH town[last_citizen+1] do
         begin
            GETNXTCONFIG(pm_error, key, pmimage, info);
            if (pm_error > 0) then info.pos.slot := emptyslot
            else MAKE_INTERNAL(info.pos);
            if (pm_error <= 0) then
               begin
                  found_popa := FIND_POPA(info.driverid, provider);
                 {We don't care diff between pseudo-config and builtin, here: }
                  feuding := ALREADY_EXISTS(info.pos.slot, info.pos.chan, info.pos.dev,
                       is_builtin, config_index);
                  if feuding and
                     IS_BOOTER(info.pos) then
                     begin
                        index_config:=config_index; {save for use establishing bosses}
                        feuding := false; {don't be concerned pre-inited boot device entry}
                     end;
                  if (info.pos.slot <> emptyslot) then
                     pretender := (pta[info.pos.slot] <> not_occupied) and
                        (info.pos.chan = emptychan) {whether moma is a duplicate}
                  else pretender := false;
                 (*$IFC debug2*)
                  if TRACE(init, 50) then
                     begin
                        if not found_popa then
                           begin
                              prompt := 'INIT_CDS:  Driver not found for the device';
                              SHOWPOS(prompt, info.pos.slot, info.pos.chan, info.pos.dev);
                           end;
                        if pretender or feuding then
                           begin
                              prompt := 'INIT_CDS:  Multiple devices are configured';
                              SHOWPOS(prompt, info.pos.slot, info.pos.chan, info.pos.dev);
                           end;
                     end; {of tracing error cases}
                 (*$ENDC*)

                  if (info.pos.slot <> emptyslot) and found_popa and not feuding
                     and not pretender then {this is a keeper: }
                     begin
                        last_citizen := last_citizen + 1;
                        terminal := true;   {until someone claims you as a boss}
                        boss := not_occupied;{sought later}
                        if (info.pos.chan = emptychan) then
                           begin
                              relation := moma;
                              pta[info.pos.slot] := last_citizen; {moma joins the pta}
                           end
                        else {is an orphan until proven otherwise}
                           relation := orphan;
                     end; {of this is a keeper}
               end; {of looking at next pm entry}
         end; {of with town}
      if (last_citizen = maxpm) then
         begin
           (*$IFC debug2*)
            if TRACE(init, 50) then
               begin
                  writeln;
                  writeln('INIT_CDS:  PM has more entries than I can remember.');
                  writeln('  (the rest are forgotten)');
               end;
           (*$ENDC*)
            pm_error := 1; {force us out of this loop}
         end;
   until (pm_error > 0);
   if (last_citizen = 0) then CLEANUP {since nothing to DO!}
   else lastone := last_citizen;

  {FIND MOMA'S DEPENDENTS: }
   for which_slot := 0 to max_slot do
      begin
         pseudo_moma := false;
         if (pta[which_slot] = not_occupied) then
            if ALREADY_EXISTS(which_slot, emptychan, emptydev,
                  is_builtin, pseudo_index) then
               pseudo_moma := is_builtin; {pseudo moma exists if is builtin}

         if (pta[which_slot] <> not_occupied) or pseudo_moma then
         begin
            her_name := pta[which_slot];

            for position := 0 to max_slot do
               brats[position] := not_occupied;

            for tindex := 1 to lastone do  {find all brats}
               WITH town[tindex] do
                  if (info.pos.slot = which_slot){right slot} and
                     (relation=orphan)           {not a moma} and
                     (info.pos.dev = emptydev)   {firstborn}
                  then
                     begin
                      {Is firstborn a duplicate? (info.pos.chan <> emptychan,
                                                  SINCE this isn't moma) }
                        pretender := (brats[info.pos.chan] <> not_occupied);
                       (*$IFC debug2*)
                        if pretender and TRACE(init, 50) then
                           begin      {Notice that ALL pretenders are active.}
                              prompt := 'INIT_CDS:  Multiple devices configured';
                              SHOWPOS(prompt, info.pos.slot, info.pos.chan, info.pos.dev);
                           end;
                       (*$ENDC*)
                        relation := firstborn;
                        brats[info.pos.chan] := tindex;
                       {moma's child brings responsibilities:}
                        if pseudo_moma then boss := -pseudo_index
                        else
                           begin {not pseudo_moma}
                              boss := her_name;
                              town[her_name].terminal := false;
                           end;
                     end;

            for tindex := 1 to lastone do {find all adoptees}
               WITH town[tindex] do
                  if (info.pos.slot = which_slot) and {right slot}
                     (relation = orphan)              {ie, not moma or firstborn}
                  then
                     if (brats[info.pos.chan] <> not_occupied) then {firstborn exists}
                     begin                            {make an adoption:}
                        relation := adopted;
                        boss := brats[info.pos.chan]; {first born is boss}
                        town[brats[info.pos.chan] ].terminal
                                 := false; {since is boss}
                     end;
         end; {of cd or pseudo-cd moma exists}

      end; {of for each moma and her family}

  {CREATE CONFIGINFO ENTRIES FOR ALL NON-ORPHANS:}
   INTSOFF(allints, int_level); {Left off until all 'required_drvr fields are filled in.}
   for tindex := 1 to lastone do with town[tindex] do
      begin
         made_it := false;
         if (relation = orphan) then
            begin
              (*$IFC debug2*)
               prompt := 'INIT_CDS:  Device misconfigured';
               SHOWPOS(prompt, info.pos.slot, info.pos.chan, info.pos.dev);
              (*$ENDC*)
            end
         else if not IS_BOOTER(info.pos) then
            begin
              (*$IFC debug2*)   {Don't care diff between pseudo-config and builtin}
               if ALREADY_EXISTS(info.pos.slot, info.pos.chan, info.pos.dev,
                              is_builtin, config_index) then {or config_index.}
                  begin {Gripe, but then doit, anyway!! }
                     prompt := 'INIT_CDS:  Multipe devices configured';
                     SHOWPOS(prompt, info.pos.slot, info.pos.chan, info.pos.dev);
                  end;
              (*$ENDC*)
               if not FIND_EMPTYSLOT(config_index) then
                  begin
                    (*$IFC debug2*)
                     writeln('INIT_CDS: no software slots available for driver.');
                    (*$ENDC*)
                     CLEANUP;
                  end;
               STUFF_INFOBUF(elks[provider]^, tree_buf);
               WITH tree_buf do
                  begin
                     index_config := config_index;
                     NEW_DEVICE(error, config_index, info.pos.slot, info.pos.chan, info.pos.dev,
                            tree_buf);
                     if (error > 0) and (error <> cdnoparaport) then CLEANUP;
                     made_it := true;
                  end;
            end; {needs a configinfo entry}
      end; {for all tindex}


   for tindex := 1 to lastone do
      with town[tindex] do
         if made_it and (boss <> not_occupied) then
            begin  {FILL IN THE REQUIRED DRIVER FIELDS:}
               if (boss < 0) then {pseudo-configed boss} value := -boss
               else value := town[boss].index_config;
               configinfo[index_config]^.required_drvr := configinfo[value];
            end;

   INTSON(int_level); {just in case}
   for tindex := 1 to lastone do
      with town[tindex], elks[provider]^.info do
         if (relation <> orphan) then
            if terminal then
               if (devicetype <> non_io) then
                  if preload or IS_BOOTER(info.pos) then
                     UP(error, configinfo[index_config], nil);


  (*$IFC debug2*)
   writeln;
   writeln;
  (*$ENDC*)

   CLEANUP; {doesn't return}

end; {of init_cds}



(*************)
(*$S fs3*)      {store into same segment as used by mount/unmount().}
(*************)

procedure UNLOAD_DRIVER(*var errnum: integer; addr: absptr*);
     (**********)
     (*
     (**********)
begin
  REL_DRIVER_SPACE(errnum, addr);
end; {of unload_driver}


procedure LOAD_DRIVER(*var errnum: integer;
                       var codebase: absptr;
                           drvrname: e_name *);
     (**********)
     (*
     (* Description:
     (*    Load a configurable driver into memory.
     (*
     (* Input Parameter:
     (*   Drvrname - point to the name of the driver.
     (*
     (* Output Parameter:
     (*   Errnum - (if any)
     (*   Codesize - in bytes
     (*   Codebase - the (mapped) address where the driver was loaded.
     (*
     (**********)

label 1; {ala exit}
const
 {possible error return values: }
   cd_base =  790;      {base from which rest of the errors are reported}
   cd_buf =     0;      {couldn't find syslocal buffer space}
   cd_nex =     1;      {driver object file not executable}
   cd_nospace = 2;      {the driver wont fit}
   cd_read =    3;      {any sort of io error READING}
   cd_src =     4;      {driver file not found}
   cd_seg =     5;      {multi-seg program/bad format}
type
   jmp_inst = record
                opcode: integer;
                offset: longint;
              end;

var
   codesize: longint;
   src_desc: objhandle;
   invar :  objblock;
   deviant : objvarblock;
   ptr_jmp: ^jmp_inst;
   ptr: optr;
   numbsegs, error: integer;
   prefix: e_name;
   localname: pathname;

   procedure CHECK_READ_ERROR; {ala recover}
   begin
      if src_desc^.error <> 0 then
      begin
         errnum := cd_base + cd_read;
         goto 1;
      end;
   end; {of check_read_error}

begin

   OSBOOTVOL(errnum, prefix);
   localname := CONCAT('-', prefix, '-SYSTEM.CD_', drvrname);

   errnum := 0;
   INITOBJFILE(src_desc, 4 {blocks of scratch space});
   if src_desc=NIL then
      begin
         errnum := cd_base + cd_buf;
         EXIT(LOAD_DRIVER);
      end;

   OPENOBJFILE(src_desc, localname, false {dont lock it} );
   if ( src_desc^.error=948 {file not found}) then
      begin
         errnum := cd_base + cd_src;
         goto 1;
      end
   else CHECK_READ_ERROR;

  {Is it executable?}
   GETOBJINVAR(src_desc, invar);
   CHECK_READ_ERROR;
   if invar.blockheader=versionctrl then
      begin
         GETOBJINVAR(src_desc, invar);  {skip version ctrl, if present}
         CHECK_READ_ERROR;
      end;
   if invar.blockheader<>Executable then
      begin
         errnum := cd_base + cd_nex;
         goto 1;
      end;

  {The read pointer is now pointing to the variant sequence: }
  {     integer      (holding the number of segments),       }
  {     JTSegVariant (but only ONE segment, please)          }

   GETOBJSEQ(src_desc, @numbsegs, 2); {check number of segs}
   CHECK_READ_ERROR;
   if (numbsegs<>1) then
      begin
         errnum := cd_base + cd_seg;
         goto 1;
      end;

   GETOBJVAR(src_desc, JTSegVariant, deviant); {read loaders size}
   CHECK_READ_ERROR;
   codesize := deviant.bJTSegVariant.sizeUnpacked - 8; {8 bytes overhead}

 {position to the start of the object code}
   repeat
      GETOBJINVAR(src_desc, invar);
      CHECK_READ_ERROR;
   until invar.blockheader=codeblock;

   codebase := GET_DRIVER_SPACE(error,codesize);
   if error > 0 then
      begin
         errnum := cd_base + cd_nospace;
         goto 1;
      end;

   ptr_jmp := pointer(codebase);
   ptr     := pointer(ptr_jmp^.offset);
   GETOBJSEQ(src_desc, ptr, codesize);
   CHECK_READ_ERROR;

   PRO_DRIVER_SPACE;

1:                      {label is for the standard error path exit}
   CLOSEOBJFILE(src_desc, false {nothing special} );
end; {of LOAD_DRIVER}



end. {of unit CD}


