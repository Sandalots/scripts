
(*********************************************************************************)
(*                                                                               *)
(*  (c) copyright 1983, 1984  Apple Computer Inc.                                *)
(*                                                                               *)
(*********************************************************************************)

UNIT sfileio;

INTERFACE

  USES

    {$U object/driverdefs.obj }       driverdefs,
    {$U object/hwint.obj      }       hwint,
    {$U object/sysglobal.obj  }       globalda,
    {$U object/procprims.obj  }       proc_prims,
    {$U object/mmprim.obj     }       mmprimitives,
    {$U object/asynctr.obj    }       asynctr,
    {$U object/genio.obj      }       genio,
    {$U object/twiggy.obj     }       twiggy,
    {$U object/vmstuff.obj    }       vmstuff;

    {$SETC SFILBUG := FALSE}


const firstfile = 5;     (* fnum of first user file *)
      maxmapindex = 83;  (* index of last file map entry in a full map *)
      maxsmallindex = 9; (* index of last file map entry in a small map *)
      cur_version = SPRING_VERSION;  (* LISA file system version identifier  *)
      cur_file_version = 21;  (* LISA file format version number *)
      TEMP_SFILE = 32767; (* impossible sfile number assigned for temp sfiles *)

      (* Generic ecodes *)
      E_BADSENTRY = 1298;    (* S-list entry (on disk) is invalid *)
      E_BADENAME  = 1297;    (* Entry name (on disk) is invalid   *)
      E_BADSTRARG = 1296;    (* Bad string argument has been passed *)

type
     pagetype = record (* 536 bytes long now *)
                   labl : pagelabel; (* 24 bytes long now *)
                   data  : array [0..511] of byte
                end;

     s_entry = record
                 hintaddr  :  longint;
                 fileaddr  :  longint;
                 filesize  :  longint;   (* size in bytes of this s-file *)
                 version   :  integer    (* version number of this s-file *)
               end;
     sentry_ptr = ^s_entry;

     filetype = (undefined, MDDFfile, rootcat, freelist, badblocks,
                 sysdata, spool, exec, userdir, pipe, bootfile,
                 swapdata, swapcode, ramap, userfile, killedobject, tempfile);

     entrytype= (emptyentry, direntry, linkentry, fileentry, pipeentry, ecentry,
                 killedentry, removed, threadentry);

     mapentry = record
                  address : longint;     (* abspage of contiguous chunk *)
                  cpages : integer       (* number of pages in contiguous chunk *)
                end;
     fment_ptr = ^mapentry;

     filemap  = record
                  size  : longint;       (* number of blocks in this s-file *)
                  max_entries : integer; (* size (in mapentry's) of this map *)
                  ecount : integer;      (* number of mapentry's used in this map *)
                  map   : array [0:maxmapindex] of mapentry   (* the map itself *)
                end;
     flmap_ptr = ^filemap;

     smallmap  = record
                  size  : longint;       (* number of blocks in this s-file *)
                  max_entries : integer; (* size (in mapentry's) of this map *)
                  ecount : integer;      (* number of mapentry's used in this map *)
                  map   : array [0:maxsmallindex] of mapentry   (* the map itself *)
                end;
     smap_ptr = ^smallmap;

     FmapRequest = ( FMAPPEND, FMRELEASE, FMABSPAGE, FMRELPAGE );

     FmapInfo = record
                  device    : integer;
                  map_page  : longint;    (* disk page of file map *)
                  ptrFmap   : flmap_ptr;  (* pointer to buffered file map *)
                  addrFbuf  : absptr;     (* buffer for file map I/O *)
                  sfile     : integer;    (* s-file number *)
                  ptrSent   : sentry_ptr; (* pointer to s-list entry of file *)
                  addrSbuf  : absptr;     (* buffer for s-list I/O *)
                  i         : integer;    (* index into file map *)
                  expand    : boolean;    (* OK to grow file map when scanning *)
                  cached    : boolean;    (* file map is buffered somewhere *)
                  scan_only : boolean;    (* permission to read map only *)
                end;
     fminfo_ptr = ^FmapInfo;

     pathnm_ptr = ^pathname;



function SFVERSION : integer;

{
function ABSRELBYTE (var ecode : integer; device : integer;
                     cpage : longint; coffset : integer;
                     sfile : integer) : longint ;
}
     (* convert absolute page and offset to relative byte pointer within a file *)

procedure PGLBLIO ( var p : pagelabel;
                   device : integer;
                     page : longint;
                       op : ioop;
                var ecode : error );

procedure SLIST_IO ( var ecode  :  error;
                         device :  integer;
                        s_file  :  integer;
                            op  :  ioop;
                      var addr  :  s_entry);

procedure  MDDF_IO ( var ecode  : integer;
                         device : integer;
                         addr   : absptr;
                         op     : ioop );

procedure BITMAP_IO ( var ecode  :  error;
                         device  :  integer;
                             op  :  ioop;
                           addr  :  absptr);

function  Old_Volume ( device : integer ) : boolean;

function Flat_Catalog ( device : integer ) : boolean;

procedure  FMAP_IO ( var ecode    : error;
                         device   : integer;
                         ldr_page : longint;
                         rel_page : longint;
                         ptrFmap  : flmap_ptr;
                         op       : ioop );

procedure APPENDPAGES (    appendto:    longint;
                           device :     integer;
                           pagecount:   longint;
                           exact:       boolean;
                       var newpage,
                           actualcount: longint;
                           filenum:     integer;
                           ptrSent:     sentry_ptr;
                           ptrFmap:     flmap_ptr;
                       var ecode:       error   );

procedure RELEASEPAGES (var ecode : error;
                           device : integer;
                             fnum : integer;
                         frompage : longint;
                         ptrFmap  : flmap_ptr;
                         ptrSent  : sentry_ptr );

function NEXTPAGE     ( device :      integer;
                           page:      longint;
                       var ecode:     error      ):longint;

procedure CLEAR_DATAUSED (var ecode : error; device : integer;
                           page : longint; dataused : integer);

procedure FLUSHFS (var ecode:error);

procedure SALLOCATE (var ecode     : error;
                            device : integer;
                    var whereitis,
                        actualsize : longint;
                        start,
                        size       : longint);

  procedure deallocate ( var ecode  : error;
                             device : integer;
                             start  : longint;
                             size   : longint );

procedure NEW_SFILE (var ecode:error; device : integer; var snum:integer);

procedure KILL_SFILE (var ecode:error; device : integer; snum:integer);

procedure DEF_MOUNT (var ecode : error; unitnum : integer);

procedure DEF_UNMOUNT (var ecode : error; unitnum : integer);

procedure REAL_MOUNT (var ecode : error; device : integer);

procedure REAL_UNMOUNT (var ecode : error; device : integer);

function GET_PSIZE (var ecode : error; device : integer; snum : integer) : longint;

procedure ResetFmap (     ptrInfo : fminfo_ptr;
                      var ecode   : integer );

function GetMapEntry (     ptrInfo : fminfo_ptr;
                       var ecode   : integer ) : fment_ptr;

procedure FMAP_MGR ( var ecode   : integer;
                         device  : integer;
                         snum    : integer;
                         ptrFmap : flmap_ptr;
                         ptrSent : sentry_ptr;
                         request : FmapRequest;
                         page    : longint;
                     var return  : longint );

{$IFC DEBUG2}
procedure  PrintFmap ( ptrFmap : flmap_ptr; max_index : integer );
{$ENDC}


IMPLEMENTATION

(*$S kr_fs*)
(*$IFC NOT DEBUG2*)
(*$R-*)
(*$ENDC*)

  const
      vercode = 10;        (* version of the sfile module *)

      (* Error codes *)
      E_FMAP_DAMAGED    = 1295;
      E_NOT_PIPE_PAGE   = 1190;
      E_SALLOC_ARG      = 825;
      E_VOLUME_FULL     = 826;
      E_DEALLOC_ARG     = 828;
      E_BAD_DEALLOC     = 829;
      E_SNUM_RANGE      = 835;
      E_PAST_PEOF       = 839;
      E_FMAP_SHORT      = 840;
      E1_SENTRY_BAD     = 841;
      E_NO_CONTIG       = 843;
      E1_NO_DEV_MOUNTED = 856;
      E_NO_SNUMS        = 854;
      E_ALLOC_HINTS     = 855;
      E2_SENTRY_BAD     = 857;
      E1_DEV_RANGE      = 868;
      E1_DEV_MOUNTED    = 869;
      E_DCB_NOSPACE     = 870;
      E2_DEV_RANGE      = 867;
      E_SPARES_DAMAGED  = 1054;
      E_FS_VERSION      = 866;
      E_BITMAP_NOSPACE  = 864;
      E_DEV_IN_USE      = 1196;


  {type
     pagelabel = record  (* 24 bytes long now *)
                   version: integer;
                   volume : integer;
                   fileid : integer;
                   dataused:integer;
                   abspage: longint;
                   relpage :longint;
                   fwdlink :longint;
                   bkwdlink:longint
                 end;}                        (* defined in twiggy unit *)





(*$S kr_fs *)
function SFVERSION;

begin
  SFVERSION := vercode;
end;










(*$S kr_fs *)
procedure sallocate (*var ecode     : error;
                     device : integer;
                     var whereitis,
                         actualsize : longint;
                         start,
                         size       : longint*);

const
   perrbase = 0;
   free = false;
   taken = true;
var
   lastpage : longint;

begin

(*$IFC DEBUG2*)
  if trace (FS, 3) then writeln ('SALLOCATE:  request for ',size,' pages');
(*$ENDC*)

  with mounttable [device]^ do
  begin
     lastpage := MDDFdata^.geography.lastfspage;
     if (start<0) or (start>lastpage) or (size<=0) then
       ecode := E_SALLOC_ARG
     else
     begin {allocate space}
        actualsize := FIND_SPAN(allocmap, start, size, MDDFdata^.freestart,
                       lastpage, whereitis, free);
        if (actualsize=0) then ecode := E_VOLUME_FULL {sorry, could not find any room}
        else
           begin
              ecode := 0;
              wait_sem (semmap, []);  (* to prevent this from interfering flushfs *)
              mapdirty := true;  (* changed allocmap *)
              FILL_SPAN(allocmap, whereitis, actualsize, taken);
              signal_sem (semmap);
           end; {of allocating the space}
     end; {of parameters out of range}
  end; {of with}

  {if (ecode > 0) and (ecode < 100) then
         ecode := INTERRBASE + SFERRBASE + PERRBASE + ecode;}

(*$IFC DEBUG2*)
  if trace (FS, 3) then writeln ('SALLOCATE:  exit with ecode of ', ecode);
(*$ENDC*)
end;    (* of procedure SALLOCATE *)






  {$S kr_fs }
  procedure deallocate (* var ecode  : error;
                              device : integer;
                              start  : longint;
                              size   : longint *);

  const
     free  = false;
     taken = true;

  var
     stop     : longint;
     how_many : longint;
     lastpage : longint;

  begin
{$IFC DEBUG2}
    if trace(FS, 3) then writeln ('DEALLOCATE  start = ',start,'  size = ',size);
{$ENDC}
    stop := start + size - 1; (* last cell we are trying to deallocate *)
    lastpage := mounttable[device]^.MDDFdata^.geography.lastfspage;
    if (start < 0) or (size <= 0) or (stop > lastpage) then
      ecode := E_DEALLOC_ARG
    else
    begin
      with mounttable[device]^ do
      begin
        wait_sem (semmap, []);       (* to prevent this from interfering flushfs *)
{$IFC DEBUG2}
        how_many := COUNT_SPAN(allocmap, start, size, taken);
{$ELSEC}
        how_many := size;
{$ENDC}
        if how_many = size then
          ecode := 0
        else
          ecode := E_BAD_DEALLOC;
        if how_many > 0 then
        begin
          mapdirty := true;
          Fill_Span(allocmap, start, how_many, free);
        end;
        signal_sem (semmap);
      end;
    end;

{$IFC DEBUG2}
    if trace(FS, 3) then writeln('DEALLOCATE  exit ecode = ',ecode);
{$ENDC}
  end{proc deallocate};





  {$S kr_fs }
  procedure  psio ( var ecode    : integer;
                        device   : integer;
                        sfile    : integer;
                        page_no  : longint;
                        addrBuf  : absptr;
                        nbytes   : longint;
                        op       : ioop );

  label   1;

  var
       actual  : longint;
       plrec   : plrect;
       npages  : longint;
       extra   : integer;
       ptrExtra : ^byte;
       mode     : disk_io_type;
       LoclBuf  : array[0..511] of byte;

  begin
{$IFC SFILBUG}
    if trace(FS, 98) then
    begin
      write('PSIO  ');
      PrOp(op); writeln('  dev = ',device,'  sf = ',sfile,'  pg = ',page_no,
                        '  nbytes = ',nbytes);
    end;
{$ENDC}
    ecode := 0;
    with mounttable[device]^.MDDFdata^ do
    begin
{$IFC BLK512}
      PgOffset(nbytes, npages, extra);
{$ELSEC}
      npages := nbytes div datasize;
      extra := nbytes mod datasize;
{$ENDC}

      with plrec do with plabel do
      begin
        volume := 0;
        datastat := dataok;
        version := 0;
        fileid := sfile;
        dataused := datasize;
        abspage := page_no;
        relpage := 0;
        fwdlink := REDLIGHT;
        bkwdlink := REDLIGHT;
        lflink := REDLIGHT;
        ldataused := datasize;
      end{with};

      if op = READOP then
        mode := WITHOUT_HEADER  {CHAINED_READ is more reliable }
      else
        mode := WITH_HEADER;

      if npages > 0 then
      begin
        lisaio(ecode, device, addrBuf, page_no+geography.firstblock,
               npages, actual, mode, @plrec, op);
        if ecode > 0 then goto 1;
      end{if};

      if extra > 0 then
      begin
        with plrec do with plabel do
        begin
          dataused := extra;
          abspage := page_no + npages;
          relpage := npages;
          fwdlink := REDLIGHT;
          bkwdlink := abspage - 1;
          lflink := REDLIGHT;
          ldataused := extra;
        end{with};
        ptrExtra := pointer(addrBuf + nbytes - extra);
        if op = WRITEOP then
        begin
          moveleft(ptrExtra^, LoclBuf, extra);
          ClearMem(ord(@LoclBuf)+extra, datasize-extra);
        end{if};

        lisaio(ecode, device, ord(@LoclBuf), page_no+npages+geography.firstblock,
               1, actual, mode, @plrec, op);

        if op = READOP then
          moveleft(LoclBuf, ptrExtra^, extra);
      end{if};
    end{with};

  1: (* exit *)
{$IFC SFILBUG}
    if trace(FS, 98) then
    begin
      writeln('PSIO  exit ecode = ',ecode);
    end;
{$ENDC}
  end{proc psio};




  {$S kr_fs }
  procedure  MDDF_IO (* var ecode  : integer;
                            device : integer;
                            addr   : absptr;
                            op     : ioop *);

  begin
    with mounttable[device]^.MDDFdata^ do
      psio(ecode, device, 1 {MDDF snum}, MDDFaddr, addr, sizeof(MDDFdb), op);
  end{proc MDDF_IO};



  {$S kr_fs }
  procedure BitMap_IO (* var ecode  :  error;
                             device :  integer;
                             op     :  ioop;
                             addr   :  absptr *);

  begin
    with mounttable[device]^.MDDFdata^ do
        psio(ecode, device, 2 {bitmap snum}, bitmap_addr, addr, bitmap_bytes, op);
  end{proc BitMap_IO};



  {$S kr_fs }
  function  Old_Volume (* device : integer ) : boolean *);

  begin
      if mounttable[device] <> pointer(badptr1) then
        Old_Volume := (mounttable[device]^.MDDFdata^.fsversion <= REL1_VERSION)
      else
        Old_Volume := FALSE;
  end{func Old_Volume};


  {$S kr_fs }
  function Flat_Catalog (* device : integer ) : boolean *);

  begin
      if mounttable[device] <> pointer(badptr1) then
        Flat_Catalog := (mounttable[device]^.MDDFdata^.fsversion <= PEPSI_VERSION)
      else
        Flat_Catalog := FALSE;
  end{func Flat_Catalog};



(*$S kr_fs *)
procedure  FMAP_IO (* var ecode    : error;
                          device   : integer;
                          ldr_page : longint;
                          rel_page : longint;
                          ptrFmap  : flmap_ptr;
                          op       : ioop *);

begin
  with mounttable[device]^.MDDFdata^ do
  begin
    if rel_page <> REDLIGHT then
      ldr_page := ldr_page + map_offset;
{$IFC DEBUG2}
  if trace(FS,64) then
  begin
    write('FMAP_IO:  page = ',ldr_page:5,'  relpage = ',rel_page:5);
    if op = READOP then write('  read') else write('  write');
  end;
{$ENDC}
    if rel_page = 0 then
    begin
      (*
       *  Reading first section of file map.  For new files, the first section
       *  is below the catalog hint in relative page 0 of the file leader.  For
       *  old files, the first section is relative page 1 of the file leader.
       *)
      if old_volume(device) then
        (* File is OLD:  transfer the full map *)
        vm(ecode, device, ldr_page, sizeof(pagelabel),
           ord(ptrFmap), sizeof(filemap), op)
      else
        (* File is NEW:  transfer the small map *)
        vm(ecode, device, ldr_page, sizeof(pagelabel)+smallmap_offset,
           ord(ptrFmap), sizeof(smallmap), op);
    end
    else
    begin
      (*
       *  Find the requested relative page of file map by chaining through
       *  file map pages.  Scan is only performed if a valid relative page number
       *  is supplied.  Otherwise, the ldr_page is presumed to be the desired
       *  file map absolute page number.
       *)
      if rel_page <> REDLIGHT then
      begin
        while (rel_page > 0) and (ecode <= 0) and (ldr_page <> REDLIGHT) do
          ldr_page := nextpage(device, ldr_page, ecode);  (* reads page label *)
        if ldr_page = REDLIGHT then
          ecode := E_FMAP_DAMAGED;    (* filemap is fudged *)
      end;
      if ecode <= 0 then
        vm(ecode, device, ldr_page, sizeof(pagelabel),
           ord(ptrFmap), sizeof(filemap), op);
    end;
  end;
{$IFC DEBUG2}
  if trace(FS,64) then
  begin
    writeln('   ecode = ',ecode:4);
    PrintFmap(ptrFmap, MAXMAPINDEX);
  end;
{$ENDC}
end; (* of procedure FMAP_IO *)





(*$S kr_fs *)
procedure pglblio (* var p:     pagelabel;
                       device : integer;
                         page:  longint;
                         op:    ioop;
                     var ecode: error     *);

const perrbase = 6;


begin
(*$IFC DEBUG2*)
  if trace (FS, 4) then (*TRACE*)
  begin
    write ('PGLBLIO: '); (*TRACE*)
    if op=readop then write ('read') else write ('write'); (*TRACE*)
    writeln (' page label for device ',device,', page ',page); (*TRACE*)
  end;
(*$ENDC*)


  vm (ecode, device, page, 0, ord(@p), sizeof (pagelabel), op);
                                              (* read/write page label *)

  if ecode > 0 then with p do (* I/O error, return cleared page label *)
  begin
    version := 0;
    datastat := dataok;
    filler := 0;
    volume := 0;
    fileid := 0;
    dataused := 0;
    abspage := 0;
    relpage := 0;
    fwdlink := 0;
    bkwdlink := 0;
  end;
  {if (ecode>0) and (ecode < 100) then
                              ecode := INTERRBASE + SFERRBASE + PERRBASE + ecode;}

(*$IFC DEBUG2*)
  if trace (FS, 4) then writeln ('PGLBLIO:  exit with ecode of ',ecode);
(*$ENDC*)
end; (* of procedure pglblio *)





{*******************************NOT REFERENCED*************************
(*$S fs1 *)
function ABSRELBYTE (* var ecode : integer; device : integer;
                       cpage : longint; coffset : integer;
                       sfile : integer) : longint *);
     (* convert absolute page and offset to relative byte pointer within a file *)
var p : pagelabel;
begin
(*$IFC DEBUG2*)
  if trace (FS, 4) then
    writeln ('ABSRELBYTE: device =', device, ' cpage =', cpage, ' coffset =',
                                                                coffset);
(*$ENDC*)
  absrelbyte := 0;
  ecode := 0;
  if cpage > 0 then    (* should be a page with valid data *)
  begin
    pglblio (p, device, cpage, readop, ecode);
                (* read the page label of the absolute page *)

    if ecode = 0 then
      if p.fileid <> sfile then ecode := E_NOT_PIPE_PAGE
      else
        absrelbyte := p.relpage * mounttable [device]^.MDDFdata^.datasize
                         + coffset;
  end;

(*$IFC DEBUG2*)
  if trace (FS, 4) then writeln ('ABSRELBYTE:  exit with ecode of ',ecode);
(*$ENDC*)
end;  (* function ABSRELBYTE *)
*************************************************************************}




(*$S fs2 *)
procedure CLEAR_DATAUSED (*var ecode : error; device : integer;
                            page : longint; dataused : integer*);

const perrbase = 43;

var p : pagelabel;

begin
(*$IFC DEBUG2*)
  if trace (FS, 6) then (*TRACE*)
    writeln ('CLEAR_DATAUSED:  request to clear page labels from page ',page);
(*$ENDC*)

  pglblio (p, device, page, readop, ecode);
  p.dataused := dataused;
  p.fwdlink := redlight;      (* indicates logical eof to drivers *)
  if ecode = 0 then pglblio (p, device, page, writeop, ecode);

  {if (ecode>0) and (ecode < 100) then
           ecode := INTERRBASE + SFERRBASE + PERRBASE + ecode;}

(*$IFC DEBUG2*)
  if trace (FS, 6) then writeln ('CLEAR_DATAUSED:  exit with ecode of ',ecode);
(*$ENDC*)
end;  (* of procedure CLEAR_DATAUSED *)








(*$S kr_fs *)
function nextpage (*    device : integer;
                         page:   longint;
                    var ecode:  error):  longint*);

const perrbase = 8;

var p : pagelabel;

begin
(*$IFC DEBUG2*)
  if trace (FS, 4) then writeln ('NEXTPAGE: find page after page ',page);(*TRACE*)
(*$ENDC*)
  pglblio (p, device, page, readop, ecode);
  nextpage := p.fwdlink;   (* note:  could be a red light *)
(*$IFC DEBUG2*)
  if trace (FS, 4) then
       writeln ('NEXTPAGE: page ',page,' preceeds page ',p.fwdlink);(*TRACE*)
(*$ENDC*)
end; (* of function nextpage *)
















(*$S kr_fs *)
procedure slist_io (*var ecode:error; device : integer;
                             s_file : integer; op:ioop; var addr:s_entry*);

const perrbase = 10;

var s_file_page : longint;
    s_file_offset : integer;

begin

(*$IFC DEBUG2*)
  if trace (FS, 7) then writeln ('SLIST_IO:  access for s_file number ', s_file);
                                                                     (*TRACE*)
(*$ENDC*)
  if s_file < 0 (* firstfile? *) then ecode := E_SNUM_RANGE else
  begin
    with mounttable [device]^ do
    begin
      if s_file > MDDFdata^.maxfiles then ecode := E_SNUM_RANGE
      else
      begin
        s_file_page := (s_file div MDDFdata^.slist_packing) + MDDFdata^.slist_addr;
        s_file_offset := (s_file mod MDDFdata^.slist_packing) * sizeof (s_entry)
                                + sizeof (pagelabel);
(*$IFC DEBUG2*)
        if trace (FS, 7) then
              writeln ('SLIST_IO:  page ',s_file_page,', offset ',s_file_offset);
(*$ENDC*)
        vm (ecode, device, s_file_page, s_file_offset, ord (@addr),
                         sizeof (s_entry), op);
      end;
    end;
  end;

  {if (ecode>0) and (ecode < 100) then
                             ecode := INTERRBASE + SFERRBASE + PERRBASE + ecode;}

(*$IFC DEBUG2*)
  if trace (FS, 7) then writeln ('SLIST_IO:  exit with ecode of ',ecode);
(*$ENDC*)

end;   (* of procedure SLIST_IO *)






{$IFC DEBUG2}
(*$S kr_fs*)
(*
 *  performance
 *  debug procedure displays a file map
 *)
procedure  PrintFmap (* ptrFmap : flmap_ptr; max_index : integer *);
var j, bnd : integer;
begin
     if ptrFmap = NIL then
       writeln('FileMap   NIL')
     else
     begin
       with ptrFmap^ do
       begin
         if ecount-1 < max_index then
           bnd := ecount-1
         else
           bnd := max_index;
         writeln('FileMap   psize = ',size:4,'  entries = ',ecount:2);
         for j := 0 to bnd do with map[j] do
           writeln('          page ',address:4,'  length ',cpages:4);
       end;
     end;
end;
{$ENDC}




(*$S kr_fs *)
procedure ResetFmap (*     ptrInfo : fminfo_ptr;
                       var ecode   : integer *);

begin
  ecode := 0;
  with ptrInfo^ do
  begin
    if ptrSent = NIL then
    begin
      (* Get page address of file leader *)
      ptrSent := pointer(addrSbuf);
      slist_io(ecode, device, sfile, READOP, ptrSent^);
      if (ecode > 0) or (ptrSent^.hintaddr <= 0) then
      begin
        (* The S-list entry looks bad *)
        ecode := E_BADSENTRY;
        exit(ResetFmap);
      end;
    end;
    map_page := ptrSent^.hintaddr + mounttable[device]^.MDDFdata^.map_offset;

    if ptrFmap = NIL then
    begin
      (* The file map is not buffered anywhere *)
      (* Read the first section of file map into I/O buffer *)
      ptrFmap := pointer(addrFbuf);
      fmap_io(ecode, device, ptrSent^.hintaddr, 0, ptrFmap, READOP);
      cached := FALSE;
    end
    else
    begin
      (* The file map is buffered somewhere, and ptrFmap is valid *)
      cached := TRUE;
    end;
    i := -1;  (* file map index: incremented before used *)
    scan_only := TRUE;  (* by default *)
  end;

{$IFC DEBUG2}
  if trace(FS,64) then with ptrInfo^ do
  begin
    writeln('RESETFMAP:  map_page = ',map_page:5,'  ecode = ',ecode:4);
    PrintFmap(ptrFmap, MAXMAPINDEX);
  end;
{$ENDC}
end;  (* ResetFmap *)



(*$S kr_fs *)
function GetMapEntry (*     ptrInfo : fminfo_ptr;
                        var ecode   : integer ) : fment_ptr *);

var
     j         : integer;
     actual    : longint;
     pred_page : longint;
     ptrEntry  : fment_ptr;

begin
  ecode := 0;
  with ptrInfo^ do
  begin
    i := i + 1;
    if i > ptrFmap^.max_entries then
    begin
      (*  Ran off end of the current map, read-in the next one  *)
      ptrFmap := pointer(addrFbuf);  (* using full file map structure from now on *)
      i := 0;
      pred_page := map_page;
      map_page := nextpage(device, map_page, ecode);
      if ecode > 0 then exit(GetMapEntry);
      if map_page = REDLIGHT then
      begin
        (* Ran off the end of the current file map section *)
        if expand then
        begin
          (* Must allocate a new page to the file map *)
          appendpages(pred_page, device, 1, TRUE, map_page,
                      actual, -sfile, ptrSent, NIL, ecode);
          if ecode > 0 then exit(GetMapEntry);

          cached := FALSE;  (* file map is now buffered by us *)
          (* Initialize the new file map page *)
          with ptrFmap^ do
          begin
            size := 0;
            ecount := 0;
            max_entries := mounttable[device]^.MDDFdata^.map_size - 1;
            for j := 0 to max_entries do with map[j] do
            begin
              address := 0;
              cpages := 0;
            end;
          end;

          (*  Write the initialized file map page  *)
          fmap_io(ecode, device, map_page, REDLIGHT, ptrFmap, WRITEOP);
        end
        else
        begin
          (* No more file map to scan *)
          GetMapEntry := NIL;
          {$IFC DEBUG2}
            if trace(FS,64) then
              writeln('GETMAPENTRY:  nil');
          {$ENDC}
          exit(GetMapEntry);
        end;
      end
      else
      begin
        (*  Read the next file map page  *)
        fmap_io(ecode, device, map_page, REDLIGHT, ptrFmap, READOP);
        cached := FALSE;  (* file map is now buffered by us *)
      end;
    end;
    with ptrFmap^ do
      if (map[i].address <= 0) and scan_only then
        ptrEntry := NIL   (* end of non-expandable file map *)
      else
        ptrEntry := @map[i];
    GetMapEntry := ptrEntry;
  end;

{$IFC DEBUG2}
  if trace(FS,64) then
  begin
    with ptrInfo^ do
      if ptrEntry = NIL then
        writeln('GETMAPENTRY:  nil')
      else with ptrEntry^ do
        writeln('GETMAPENTRY:  page = ',address:5,'  length = ',cpages:5,
                '   ecode = ',ecode:4);
  end;
{$ENDC}
end;  (* GetMapEntry *)



(*$S kr_fs *)
(*
 *  performance
 *  1.  Passed pointer to cached filemap as an argument
 *  2.  Recoded to deal with cached file maps
 *
 *  receives a pointer to the FIRST section of the file map.  If this pointer
 *  is NIL, then assume the first section is not cached anywhere (hence cannot
 *  become inconsistent) and read-in the first section of the file map from disk.
 *)
procedure FMAP_MGR (* var ecode   : integer;
                          device  : integer;
                          snum    : integer;
                          ptrFmap : flmap_ptr;
                          ptrSent : sentry_ptr;
                          request : FmapRequest;
                          page    : longint;
                      var return  : longint *);

label 1, 10;

const perrbase = 12;

var
     ptrEntry   : fment_ptr;
     filepages  : longint;
     Fm         : filemap;
     SlistEntry : s_entry;
     last_page  : longint;
     remove_cnt : integer;
     total_removed : longint;
     mpdirty    : boolean;
     npages     : longint;
     FMinfo     : FmapInfo;
     save_dirty : boolean;



   procedure InitFmap;
   begin
     FMinfo.device := device;
     FMinfo.ptrFmap := ptrFmap;
     FMinfo.ptrSent := ptrSent;
     with FMinfo do
     begin
       addrFbuf := ord(@Fm);
       addrSbuf := ord(@SlistEntry);
       if (request = FMAPPEND) and (snum <> TEMP_SFILE) then
         expand := TRUE
       else
         expand := FALSE;  (* map cannot grow *)
       sfile := snum;
     end;
     ResetFmap(@FMinfo, ecode);
     FMinfo.scan_only := (request <> FMAPPEND);  (* append permission if needed *)
     filepages := FMinfo.ptrFmap^.size;  (* save current size of file in pages *)
   end;  (* InitFmap *)


   (*
    *  seek to a relative page in  the file map
    *  FMAPPEND FMRELEASE FMABSPAGE
    *)
   function AbsPosition (     pgstoskip : longint;    (* relative page number *)
                          var abs_page  : longint;    (* absolute page number *)
                          var ecode     : integer ) : fment_ptr;

   var
       ptrEntry  : fment_ptr;

   begin
   {$IFC DEBUG2}
     if trace(FS,64) then
       writeln('AbsPosition:  skip ',pgstoskip:5,' pages');
   {$ENDC}
   (*  if appending, page = first new abspage of contig chunk size blocks long  *)
   (*  if releasing, page = relpage from which to release pages, inclusive  *)
   (*  converting relpage to abspage is same as releasing  *)

     abs_page := -1;
     if filepages <= 0 then exit(AbsPosition);  (* nowhere to position *)

     (* skip to last page, to which to append, or skip to first relpage to remove *)
     ptrEntry := GetMapEntry(@FMinfo, ecode);
     if ptrEntry = NIL then
     begin
       ecode := E_FMAP_SHORT;
       exit(AbsPosition);
     end;

     (* assumes pgstoskip < pages allocated to file! *)
     while (ptrEntry^.cpages <= pgstoskip) and (ecode <= 0) do
     begin
       pgstoskip := pgstoskip - ptrEntry^.cpages;  (* still positive *)
       ptrEntry := GetMapEntry(@FMinfo, ecode);
       if ptrEntry = NIL then
       begin
         ecode := E_FMAP_SHORT;
         exit(AbsPosition);
       end;
     end;
     abs_page := ptrEntry^.address + pgstoskip;  (* abspage in file *)

     AbsPosition := ptrEntry;
   end;



   (*
    *  seek to a absolute page in  the file map
    *  FMRELPAGE
    *)
   function RelPosition (     abs_page  : longint;    (* relative page number *)
                          var rel_page  : longint;    (* absolute page number *)
                          var ecode     : integer ) : fment_ptr;

   var
        ptrEntry : fment_ptr;
        locl_rel : longint;

   begin
   {$IFC DEBUG2}
     if trace(FS,64) then
       writeln('RelPosition:  map abs page ',abs_page:5);
   {$ENDC}
        (* initialize to scan cached small file map, or large map *)
        rel_page := -1;
        locl_rel := 0;
        if filepages <= 0 then exit(RelPosition);  (* nowhere to position *)

        (* count pages until correct abspage is seen *)
        ptrEntry := GetMapEntry(@FMinfo, ecode);
        if ptrEntry = NIL then
        begin
          ecode := E_FMAP_SHORT;
          exit(RelPosition);
        end;
        while ((abs_page < ptrEntry^.address) or
               (abs_page >= ptrEntry^.address+ptrEntry^.cpages)) and
               (ecode <= 0) do
        begin
          locl_rel := locl_rel + ptrEntry^.cpages;
          if ptrEntry^.address = 0 then
            (* end of map, and abspage not found *)
            exit(RelPosition);
          ptrEntry := GetMapEntry(@FMinfo, ecode);
          if ptrEntry = NIL then
          begin
            ecode := E_FMAP_SHORT;
            exit(RelPosition);
          end;
        end;

        if ecode <= 0 then
          rel_page := locl_rel + (abs_page - ptrEntry^.address);

        RelPosition := ptrEntry;
   end;



(********************************************************************************)
(*                                                                              *)
(*               BEGINNING OF MAIN PART OF PROCEDURE FMAP_MGR                   *)
(*                                                                              *)
(********************************************************************************)
begin

  npages := return;

(*$IFC DEBUG2*)
if trace(FS,64) then
begin
write('FMAP_MGR   ');
case request of
  FMAPPEND:     write('APPEND');
  FMRELEASE:    write('RELEASE');
  FMABSPAGE:    write('ABSPAGE');
  FMRELPAGE:    write('RELPAGE');
end;
writeln('  sfile = ',snum:4,'  page = ',page:4,'  npages = ',npages:4);
end;
(*$ENDC*)

  ecode := 0;
  InitFmap;   (* initialize for scanning file map *)
  if ecode > 0  then goto 1;

  case request of
    FMAPPEND:   begin
                  with FMinfo.ptrFmap^ do
                  begin
                    ptrEntry := AbsPosition(filepages-1, last_page, ecode);
                    size := size + npages;
                  end;
                  mpdirty := TRUE;
                end;
    FMRELEASE:  begin
                  if page >= filepages then  (* Hooray! *)
                  begin
                    if page > filepages then
                      ecode := E_PAST_PEOF;
                    goto 1;
                  end;
                  (* Update file physical size in file map *)
                  with FMinfo.ptrFmap^ do
                  begin
                      ptrEntry := AbsPosition(page, last_page, ecode);
                      size := page;
                  end;
                  mpdirty := TRUE;
                end;
    FMABSPAGE:  begin
                  ptrEntry := AbsPosition(page, return, ecode);
                  exit(Fmap_Mgr);
                end;
    FMRELPAGE:  begin
                  ptrEntry := RelPosition(page, return, ecode);
                  exit(Fmap_Mgr);
                end;
  end;

  if ecode > 0 then   (* no reason this should normally happen *)
  begin
    {*******************************************
    init_fmap;   (* initialize for first page of file map, and read it in *)
    fm.size := filepages;   (* back to original size *)
    mpdirty := true;
    ***************************************************}
    goto 10;
  end;

  if request = FMAPPEND then   (* adding abspage 'page' et al to end of map *)
  begin
    if (filepages > 0) and (last_page + 1 = page) then with ptrEntry^ do
        cpages := cpages + npages  (* contiguous addition *)
    else
    begin      (* non-contiguous addition, requires a new map entry *)
      ptrEntry := GetMapEntry(@FMinfo, ecode);
      if ptrEntry = NIL then
      begin
        ecode := E_FMAP_SHORT;
        exit(Fmap_Mgr);
      end;
      if ecode > 0 then
      begin
        {*********************************
                                (* could have run out of disk space, so might *)
                                (* have to rewrite fm.size on first map page  *)
        init_fmap;   (* initialize for first page of file map, and read it in *)
        fm.size := filepages;   (* back to original size *)
        ***********************************************}
      end
      else
      begin
        with ptrEntry^, FMinfo.ptrFmap^ do
        begin
          address := page;
          cpages := npages;
          ecount := ecount + 1;
        end;
      end;
    end;
    mpdirty := true;
  end
  else
  begin            (* cutting off relpage 'page' on down from map *)
    with ptrEntry^, FMinfo.ptrFmap^ do
    begin
      remove_cnt := cpages - (last_page - address);
      total_removed := remove_cnt;
{$IFC DEBUG2}
  if trace(FS,64) then
    writeln('FMAP_MGR:  total removed = ',total_removed);
{$ENDC}
      cpages := cpages - remove_cnt;
      save_dirty := mounttable[device]^.mapdirty;  (* remember dirty bit *)
      deallocate (ecode, device, last_page, remove_cnt);
            (* free pages in bit map remcount at a time    *)
      if last_page = address then
      begin
        address := 0;
        ecount := ecount - 1;     (* get rid of whole entry *)
      end;
      mpdirty := true;
    end;

    (* Whip through the rest of the map *)
    ptrEntry := GetMapEntry(@FMinfo, ecode);
    while (ecode <= 0) and (ptrEntry <> NIL) do
    begin
      with ptrEntry^, FMinfo.ptrFmap^ do
      begin
        total_removed := total_removed + cpages;
        ecount := ecount - 1;     (* get rid of whole entry *)
        mpdirty := true;
        deallocate (ecode, device, address, cpages);
        address := 0;
        cpages := 0;
        ptrEntry := GetMapEntry(@FMinfo, ecode);
{$IFC DEBUG2}
  if trace(FS,64) then
    writeln('FMAP_MGR:  total removed = ',total_removed);
{$ENDC}
      end;
    end;
    (* Temp file deallocations do not dirty the allocation map *)
    if snum = TEMP_SFILE then
      mounttable[device]^.mapdirty := save_dirty;

    with mounttable[device]^ do
    begin
      wait_sem (semMDDF, []);     (* to prevent this from interfering flushfs *)
      with MDDFdata^ do
        freecount := freecount + total_removed; (* update count of free pages*)
      if snum <> TEMP_SFILE then
        MDDFdirty := true;
      signal_sem (semMDDF);
    end;
  end;

10:

  if mpdirty then   (* map is dirty *)
    if not FMinfo.cached then  (* and map isn't cached *)
      fmap_io(ecode, device, FMinfo.map_page, REDLIGHT, @Fm, WRITEOP);  (* write it *)

1:     (* error exit or normal fall-through *)

  {if (ecode>0) and (ecode < 100) then
                              ecode := INTERRBASE + SFERRBASE + PERRBASE + ecode;}

(*$IFC DEBUG2*)
  if trace (FS, 64) then
  begin
    writeln('FMAP_MGR:  exit with ecode of ', ecode);
    PrintFmap(FMinfo.ptrFmap, MAXMAPINDEX);
  end;
(*$ENDC*)

end;    (* of procedure FMAP_MGR *)








(*$S kr_fs *)
(*
 *  performance
 *  1.  Reads the small map (or the large map for old files)
 *)
function GET_PSIZE (*var ecode : error; device : integer; snum : integer) : longint*);

label 1;

const perrbase = 16;

var saddr : s_entry;
    actual : longint;
    Fm : filemap;
    pgdatasize : integer;

begin

(*$IFC DEBUG2*)
  if trace (FS, 9) then writeln ('GET_PSIZE:  request physical size for sfile ',snum);
(*$ENDC*)

  pgdatasize := mounttable[device]^.MDDFdata^.datasize;

  slist_io (ecode, device, snum, readop, saddr);  (* read s-file entry *)
  if (saddr.hintaddr <= 0) or (ecode > 0) then
  begin
    ecode := E1_SENTRY_BAD;      (* not a valid sfile *)
    goto 1;
  end;

  fmap_io(ecode, device, saddr.hintaddr, 0, @Fm, READOP);

  GET_PSIZE := Fm.size * pgdatasize;

1:
  {if (ecode>0) and (ecode < 100) then
                              ecode := INTERRBASE + SFERRBASE + PERRBASE + ecode;}

(*$IFC DEBUG2*)
  if trace (FS, 9) then writeln ('GET_PSIZE:  physical size = ',fm.size*pgdatasize,
                                                       'bytes; ecode of ', ecode);
(*$ENDC*)
end;   (* of function GET_PSIZE *)





(*$S kr_fs *)
(*
 *  performance
 *  1.  Passed pointer to cached filemap as an argument
 *  2.  Passes pointer on to new fmap_mgr
 *)
procedure APPENDPAGES (*   appendto:    longint;
                           device :     integer;
                           pagecount:   longint;
                           exact:       boolean;
                       var newpage,
                           actualcount: longint;
                           filenum:     integer;
                           ptrSent:     sentry_ptr;
                           ptrFmap:     flmap_ptr;
                       var ecode:       error   *);

label 1;

const perrbase = 18;

var pl:pagelabel;
    newfree, frelpage, start, size, prepage, page, lastpage : longint;
    fnum:integer;
    start_search : longint;
    save_dirty : boolean;

begin
(*$IFC DEBUG2*)
  if trace (FS, 10) then
  begin
    write ('APPENDPAGES: '); (*TRACE*)
    writeln ('appending to page ',appendto,' for file ',filenum);(*TRACE*)
  end;
(*$ENDC*)

         (*  find a contiguous free chunk on the device   *)

  with mounttable[device]^.MDDFdata^ do
  begin
    if (filenum > 0) and (filenum <> rootsnum) then
      (*  search for data page allocation begins 1/10th into the volume  *)
      start_search := geography.lastfspage div 10
    else
      (*  search for hints or rootcat data pages begins at front of volume  *)
      start_search := freestart;
  end;
  if appendto <= 0 then
    start := start_search
  else
    start := appendto;
  save_dirty := mounttable[device]^.mapdirty;  (* remember dirty bit *)
  sallocate (ecode, device, newpage, size, start, pagecount); (* get contiguous chunk *)
  actualcount := size;    (* zero if no space left *)
  if ecode <> 0 then goto 1;
  if (exact) and (size <> pagecount) then   (* couldn't get exact fit *)
  begin
    deallocate (ecode, device, newpage, size);
    actualcount := 0;    (* no exact fit, we allocate nothing *)
    ecode := E_NO_CONTIG;
    goto 1;
  end;
  (* Temp file allocations do not dirty the allocation map *)
  if filenum = TEMP_SFILE then
    mounttable[device]^.mapdirty := save_dirty;

          (* if APPENDTO > 0 then hook new pages to existing ones            *)
          (* if FNUM > 0 then we are allocating for the DATA part of file    *)
          (*                    S O                                          *)
          (* for FNUM < 0 (allocating to LEADER part of s-file), link pages  *)
          (* otherwise, do not link them, but let FMAP_MGR record allocation *)

  fnum := filenum;

  if fnum < 0 then      (* allocating for leader part of s-file *)
  begin
    if appendto > 0 then               (* append free pages to existing leader *)
    begin
      pglblio (pl, device, appendto, readop, ecode);    (* read old page label *)
      fnum := pl.fileid;         (* file id for this list of pages, from label *)
      {fversion := pl.version;}
      frelpage := pl.relpage+1;                 (* relpage for new page *)
      prepage := appendto;        (* later, we will link new stuff to this page *)
      pl.fwdlink := newpage;                    (* link in new page *)
      pglblio (pl, device, appendto, writeop, ecode);   (* write the new label *)
    end
    else                                        (* leader pages for a new file *)
    begin
      frelpage := 0;                            (* first page of a new file *)
      prepage := redlight;                 (* no previously allocated pages *)
    end;

            (* At this point, the existing leader, if any, is attached in the  *)
            (* forward direction only.  We also have some parameters set up    *)
            (* to backward link the new free pages onto the old leader.  Let's *)
            (* hook it up, and run through the page labels of the free pages   *)
            (* so that they will belong to the s-file leader.                  *)



    page := newpage;                    (* beginning of contiguous free chunk *)
    lastpage := newpage + size - 1;     (* last page of contiguous free chunk *)

    pl.volume := 0;
    pl.version := ptrSent^.version;     (* file version for this list of pages *)
    pl.fileid := fnum;                  (* file id for this list of pages *)
    pl.dataused := 0;        (* in case not cleared due to crash problems *)
    pl.datastat := dataok;

    repeat     (* linking up new pages *) {optimize with special procedure that
                                           just writes linked page labels, with-
                                           out going through pglblio, vm, etc.
                                           Avoids read-modify-write and buffering}
      pl.relpage := frelpage;              (* relative position in list *)
      pl.abspage := page;

      if page = newpage then
      begin                                (* connecting front of free chunk *)
        pl.bkwdlink := prepage;
      end
      else
      begin
        pl.bkwdlink := page - 1;        (* link new pages in backwards direction *)
      end;

      if page = lastpage then              (* connecting end of free chunk   *)
      begin
        pl.fwdlink := redlight;
      end
      else
      begin
        pl.fwdlink := page + 1;         (* link new pages in forwards direction *)
      end;


      pglblio (pl, device, page, writeop, ecode);  (* write the new label *)
      if ecode = E_DATABAD then ecode := 0;  (* ignore the datastat bit on free page *)
      frelpage := frelpage + 1;            (* increment through the new pages *)
      page := page + 1;                    (* ditto *)
    until page > lastpage;

                   (* The contiguous free blocks we allocated are now correctly *)
                   (* integrated with the appropriate leader.                   *)


  end;   (* of if fnum < 0 (allocating for leader) *)


  with mounttable [device]^ do
  begin
    wait_sem (semMDDF, []);     (* to prevent this from interfering flushfs *)
    MDDFdata^.freecount := MDDFdata^.freecount - size; (* new count *)
    if filenum <> TEMP_SFILE then
      MDDFdirty := true;
    signal_sem (semMDDF);
  end;

  if fnum > 0 then fmap_mgr(ecode, device, fnum, ptrFmap, ptrSent, FMAPPEND, newpage, size);
                    (* if these were data pages, append new pages in fmap     *)

1:

  {if (ecode>0) and (ecode < 100) then
                             ecode := INTERRBASE + SFERRBASE + PERRBASE + ecode;}


(*$IFC DEBUG2*)
  if trace (FS, 10) then writeln ('APPENDPAGES:  allocated ',size,' pages; ecode is ',
                                                                               ecode);
(*$ENDC*)


end; (* of procedure appendpages *)











(*$S kr_fs *)
(*
 *  performance
 *  1.  Passed pointer to cached filemap as an argument
 *  2.  Passes pointer on to new fmap_mgr
 *)
procedure RELEASEPAGES (* var ecode : error;
                             device : integer;
                               fnum : integer;
                           frompage : longint;
                           ptrFmap  : flmap_ptr;
                           ptrSent  : sentry_ptr *);

const perrbase = 20;

var count, firstpage, curpage, nextp : longint;
    pl : pagelabel;
    quit : boolean;

begin
(*$IFC DEBUG2*)
  if trace (FS, 10) then writeln ('RELEASEPAGES:  request release from relpage ',
                                                                          frompage);
(*$ENDC*)

       (* release allocated pages starting at frompage (a relpage, for data) *)
       (* if they are LEADER pages, they need not be contiguous              *)
       (* if they are DATA pages, then all following data pages are released *)
       (* the FMAP is updated if DATA pages are deallocated                  *)


  if fnum < 0 then                            (* releasing from leader pages *)
  begin
    curpage := frompage;             (* an abspage if fnum < 0 (leader part) *)
                               (* read page label from first page to release *)
    pglblio (pl,device,curpage,readop,ecode);
    if pl.bkwdlink <> redlight then         (* is it first page of an allocated list?*)
    begin
      firstpage := pl.bkwdlink;             (* no, so truncate unreleased end of list*)
      pglblio(pl,device,firstpage,readop,ecode);(*read label of unreleased end of list  *)
      pl.fwdlink := redlight;                 (* this truncates the list               *)
      pglblio (pl, device, firstpage, writeop, ecode);(* and writes out the label      *)
    end;

    firstpage := curpage;                     (* the new first free page               *)
    count := 0;                               (* to count the number of pages released *)
    quit := false;

    repeat
      pglblio (pl, device, curpage, readop, ecode);   (* release pages one at a time   *)

      nextp := pl.fwdlink;                  (* follow linked list until end          *)

      with pl do
      begin
        fileid := 0;
        version := 0;
        datastat := dataok;
        dataused := 0;
        relpage := 0;
        bkwdlink := redlight;        (* do not link free pages *)
        fwdlink  := redlight;        (* do not link free pages *)
      end;

      pglblio (pl, device, curpage, writeop, ecode);

      deallocate (ecode, device, curpage, 1); (* free page in bit map one at a time    *)
      if (ecode > 0) and (ecode <> E_BAD_DEALLOC) then quit := true; (* map inconsistent ok *)

              (*  NOTE:  could clear the data part of the page here, if desired      *)
      count := count + 1;                     (* chalk up another released page        *)
      curpage := nextp;
      if curpage = redlight then quit := true;
    until quit;

    with mounttable [device]^ do
    begin
      wait_sem (semMDDF, []);     (* to prevent this from interfering flushfs *)
      MDDFdata^.freecount := MDDFdata^.freecount + count; (* update count of free pages*)
      MDDFdirty := true;
      signal_sem (semMDDF);
    end;

  end   (* of if fnum < 0 (releasing leader pages) *)

        (* clear file map of entries for data pages released, if any *)
  else
  begin
    fmap_mgr(ecode, device, fnum, ptrFmap, ptrSent, FMRELEASE, frompage, count);
                                                (* note: count not used *)
  end;

  {if (ecode>0) and (ecode < 100) then
                             ecode := INTERRBASE + SFERRBASE + PERRBASE + ecode;}


(*$IFC DEBUG2*)
  if trace (FS, 10) then writeln ('RELEASEPAGES:  exiting with ecode of ',ecode);
(*$ENDC*)

end;  (* of procedure releasepages *)



{$I source/sfileio1.text }
{$I source/sfileio2.text }

END.

