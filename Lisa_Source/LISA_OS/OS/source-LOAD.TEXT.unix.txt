unit Loader;     { Program Loading Routines }

  { Copyright 1983, 1984, Apple Computer Inc. }

interface
uses
  (*$U object/driverdefs.obj *)  DriverDefs,
  (*$U object/hwint.obj *)       HWInt,
  (*$U object/sysglobal.obj *)   GLOBALDATA,
  (*$U object/procprims.obj *)   Proc_Prims,
  (*$U object/mmprim.obj *)      MMPRIMITIVES,
  (*$U object/asynctr.obj *)     asynctr,
  (*$U object/clock.obj *)       clock,
  (*$U object/genio.obj *)       genio,
  (*$U object/twiggy.obj *)      twiggy,
  (*$U object/vmstuff.obj *)     vmstuff,
  (*$U object/sfileio.obj *)     sfileio,
  (*$U object/fsprim.obj *)      fs_primitives,
  (*$U object/fsui.obj *)        FS_Interface,
  (*$U object/mm0.obj *)         MEMORYMANAGER,
  (*$U object/ds0.obj *)         DATASEGS,
  (*$U object/objio.obj *)       ObjIO;


const
  maxIUnit = 128;                { maximum Intrinsic Unit # }
  maxSeg = lusercodemmu;         { maximum code segment (private or shared) # }
  maxFile = 64;                  { maximum library file # }

  IUDir_name = 'system.IUDirectory';    { IU Directory segment name }
  IDir_ldsn = 0;                        { ldsn for binding Directory segment }

  no_FAinfo = $80000000;                { indicates no fetch ahead info in PLCB }



type
  { Intrinsic Units & Shared Segments }
  sSegRange = 1..maxSeg;                    { range of possible shared seg #s }

  pSegRange = 1..maxSeg;                    { range of private seg #s }

  iUnitRange = 1..maxIUnit;                 { range of possible IU #s }

  lFileRange = 1..maxFile;                  { range of possible library file #s }

  lf_list = packed array[lFileRange] of boolean;   { list of library files used
                                                     by a program }

  iu_list = packed array[iUnitRange] of boolean;   { list of Intrinsic Units used
                                                     by a program }

  sseg_list = packed array[sSegRange] of boolean;  { list of shared segments used
                                                     by a program }

  IUuse_list = record  { Intrinsic Unit Use List }
                 high_iunit    : 0..maxiUnit;          { # IUs in list }
                 num_sharedIUs : 0..maxiUnit;          { # shared IUs in list }
                 sum_IUdata    : int4;                 { sum of regular IU data }
                 use_list      : iu_list               { list of IUs used }
               end;

  data_ptr = ^int2;                              { ptr to a piece of shared data }

  IUdata_ptrs = array[iUnitRange] of data_ptr;   { IU data ptr table }

  ptr_UnitDirEntry = ^UnitDirEntry;              { ptr to Unit Directory Entry }

  UnitDirEntry = record  { Unit Directory Entry }
                   uNumber      : iUnitRange;         { IU # for this entry }
                   uName        : ObjName;            { IU name for this entry }
                   uFileNum     : int2;               { file # containing IU }
                   uType        : int1;               { type of this IU }
                   uDatasize    : int4;               { size of data for this IU }
                   uData_ptr    : data_ptr;           { ptr to shared data }
                   uUse_count   : int2                { # users if shared IU }
                 end;


  { Jump Table Definitions }
  jtSegEntry = record  { jump table segment entry }
                 SegmentAddr  : FileAddr;         { ptr to Code of seg in file }
                 SizePacked   : integer;          { size of PackedCode record }
                 SizeUnpacked : integer;          { size of CodeBlock record }
                 MemLoc       : MemAddr           { logical address of segment }
               end;

  jtSegTable = array[psegRange] of jtSegEntry;    { jump table - segment table }

  ptr_JumpTable = ^JumpTable;                     { ptr to a Jump Table }

  JumpTable = record  { program file jump table }
                numSegs    : int2;                { number of private segs }
                segDesc    : jtSegTable           { private segment descriptors }
                { don't care about procedure descriptors }
              end;


  stkInfo_rec = record  { information about a stack segment }
                  max_stksize : int4;     { user specified max size of stack }
                  init_dynstk : int4;     { initial dynamic stack space }
                  init_disk   : int4;     { initial stack disk size }
                  IUdata_size : int4;     { space required for IU globals }
                  comm_size   : int4;     { space for regular unit globals }
                  glob_size   : int4;     { size of program global data }
                  stk_delta   : int4;     { extra bytes below stack base }
                  jt_delta    : int4;     { extra bytes above jump table }
                  dpt_size    : int4;     { size of IU data ptr table }
                  jt_size     : int4      { size of jump table }
                end;



procedure Load_Init;

procedure Setup_IUInfo;

(*$IFC debug2 *)
procedure CodeSwapError (csSdb_ptr : sdb_ptr;  error : int2;  mrbtPtr : mrbt_ptr);
(*$ENDC *)

(*$IFC debug1 *)
procedure ShowCode (segSdb_ptr : sdb_ptr;  mrbtPtr : mrbt_ptr);
(*$ENDC *)

procedure Open_IUDirectory (var IUD_refnum : int2);

procedure Close_IUDirectory (IUD_refnum : int2);

procedure Get_UnitDir_Entry (unit_num : iUnitRange;
                             var uEntry_ptr : ptr_UnitDirEntry);

{procedure Build_DPT (var errnum : int2;  var stk_info : stkInfo_rec;
                     unit_list : IUuse_list;  var dataptr_Table : IUdata_ptrs);

procedure Free_SharedIUs (unit_list : IUuse_list;  last_IUnum : iUnitRange;
                          release : boolean);}

procedure Change_Directory (var errnum : int2;  restartShell : boolean);

procedure List_LibFiles (var errnum : integer;  var progfile : pathname;
                         var file_list : lf_list);

procedure LibFileName (var errnum : integer;  lf_num : integer;
                       var lf_name : pathname);

procedure Get_PName (var errnum : int2;  proc_id : int4;  fullName : boolean;
                     var progname : pathname);

procedure CheckLoaded (var errnum : int2;  var prog_pathname : pathname;
                       var stack_info : stkInfo_rec;  var unit_list : IUuse_list;
                       var loadedJT_ptr : ptr_JumpTable);

procedure Load_Program (var errnum : int2;  progname_ptr : ptr_pathname;
                        obj_ptr : ObjHandle;  loadedJT_ptr : ptr_JumpTable;
                        stack_info : stkInfo_rec;  jt_ptr : ptr_JumpTable;
                        var plcbRP : relptr;  unit_list : IUuse_list;
                        fetch_bitmap : seg_bitmap;  var start_addr : int4);

procedure Unload_Program;

procedure Load_Cleanup;

procedure MM_Setup (stk_refnum, sloc_refnum : int2; jt_ptr : ptr_JumpTable;
                    plcbRP : relptr;  var sl_sdbRP : relptr);

procedure Free_LPs (var fcb_ptr : sfcb_ptr;  disk_num : int2);


implementation

const
  IUDir_file = 'INTRINSIC.LIB';           { name of IU directory file }

  sdseg_blocks = 28;                      { initial size of shared seg }


type
  { Shared Intrinsic Unit Global Data Segment Definitions }
  ptr_LST = ^LST;

  LST = array[0..lusercodemmu] of absptr;

  ptr_shareSeg = ^shareSeg;

  shareSeg = record
               sseg_freePtr : absptr;             { pointer to free pool in seg }
               sseg_size : int2;                  { size of free pool }

               IUTrap1 : int4;                    { longint for IUJSR handler }
               LST_ptr : ptr_LST                  { ptr to LST for ILxxx instrs }
             end;

  { Intrinsic Unit & Shared Segment Directory }
  ptr_SegDirEntry = ^SegDirEntry;           { ptr to Segment Directory Entry }

  SegDirEntry = record  { Segment Directory Entry }
                  sNumber     : sSegRange;         { shared seg # for this entry }
                  sName       : ObjName;           { shared seg name for entry }
                  sSegSize    : int2;              { shared code seg size in mem }
                  sPackedSize : int2;              { seg size on disk, if packed }
                  sFileNum    : lFileRange;        { file # for this shared seg }
                  sFileOffset : FileAddr;          { offset into file for segment }
                  sSegsdb_ptr : sdb_ptr;           { ptr to sdb for this segment }
                  sUse_count  : int2               { # users of this segment }
                end;

  FileDirEntry = record  { File Name Directory Entry }
                   fNumber    : lFileRange;        { lib file # for this entry }
                   fUse_count : int2;              { # segs loaded from file }
                   fName_ptr  : ptr_pathname;      { ptr to name of library file }

                   fFid       : int2;              { 'file id' for lib file }
                 end;

  tPlate = record  { template for setting up string tables }
             tNumber    : int1;                    { # for this entry }
             tUse_count : int2;                    { # of uses of this entry }
             tName_ptr  : ptr_pathname             { ptr to name of this entry }
           end;

  ptr_tPlate = ^tPlate;

  ptr_UDTable = ^UnitDirTable;

  UnitDirTable = array[iUnitRange] of UnitDirEntry;   { table could be smaller }

  ptr_SDTable = ^SegDirTable;

  SegDirTable = array[sSegRange] of SegDirEntry;      { table could be smaller }

  ptr_FDTable = ^FileTable;

  FileTable = array[lFileRange] of FileDirEntry;      { table could be smaller }

  { Program Load Control Block Definitions - PLCB }
  ptr_sdbList = ^sdbList;

  sdbList = array[pSegRange] of sdb_ptr;          { size of list may be less }

  ptr_PLCB = ^PLCB;

  PLCB = record  { Program Load Control Block }
           fwd_chain    : ptr_PLCB;         { forward ptr in PLCB chain }
           bkwd_chain   : ptr_PLCB;         { backward ptr in PLCB chain }
           progfcb_ptr  : sfcb_ptr;         { ptr to FCB for program file }
           n_loads      : int2;             { number of concurrent loads }
           must_delete  : boolean;          { true if program must be unloaded }
           n_pri_segs   : int2;             { number of private segments }
           pSeg_list    : ptr_sdbList;      { ptr to list of private seg SDBs }
           jmpTable     : ptr_JumpTable;    { ptr to copy of program jump table }
           stk_info     : stkInfo_rec;      { info about program's stack needs }
           prog_iuList  : IUuse_list;       { list of Intrinsic Units used }
           prog_segList : sseg_list;        { list of shared segments used }
           prog_bitMap  : seg_bitmap        { bit map for segment pre-loading }
         end;


  { Loader Control Block Definition - LCB }
  ptr_LCB = ^LCB;

  LCB = record  { Loader Control Block }
          plcb_fwdChain  : ptr_PLCB;           { forward ptr for PLCB chain }
          plcb_bkwdChain : ptr_PLCB;           { backward ptr for PLCB chain }
          n_progs_loaded : int2;               { number of programs loaded }
          load_sem       : semaphore;          { for handling concurrent loads }
          sdSegsdb_ptr   : sdb_ptr;            { ptr to shared IU data seg sdb }
          num_IUs        : iUnitRange;         { # IUs in Directory }
          iUnit_Dir      : ptr_UDTable;        { Intrinsic Unit Directory ptr }
          num_sSegs      : sSegRange;          { # shared segs in Directory }
          sSeg_Dir       : ptr_SDTable;        { Shared Segment Directory ptr }
          num_lFiles     : lFileRange;         { # library files in Directory }
          File_Dir       : ptr_FDTable         { File Name Directory ptr }
        end;



(*$IFC debug1 *)
  function Logging : boolean;  external;

  procedure Log (var errnum : integer;  ptr_arr : absptr);  external;
(*$ENDC *)


(*$S init *)

procedure Load_Init;

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  const
    nospace = 10701;                      { no sysglobal space during StartUp }

  var
    ord_ptr : absptr;                     { ptr returned by GetSpace }
    lcb_ptr : ptr_LCB;                    { ptr to LCB }

  begin
    { initialize the LCB }
    if not GetSpace (Sizeof (LCB), b_sysglobal_ptr, ord_ptr) then
      System_Error (nospace);

    lcb_addr := ord_ptr - b_sysglobal_ptr;
    lcb_ptr := pointer(ord_ptr);
    with lcb_ptr^ do
      begin
        plcb_fwdChain := @plcb_fwdChain;
        plcb_bkwdChain := plcb_fwdChain;
        n_progs_loaded := 0;
        Init_sem (load_sem, 1);
        sdSegsdb_ptr := nil
      end
  end { Load_Init };


(*$S ProcStart *)

procedure ShiftUp (var name : e_name);
  { procedure to upshift a file name (e_name) to all upper case }

  var
    shiftDiff : integer;                           { upper/lower case difference }
    i : integer;                                   { for scanning string }
    len : integer;                                 { length of string }

  begin
    shiftDiff := ord('a') - ord('A');
    i := 1;   len := Length (name);

    while i <= len do
      begin
        if ord(name[i]) >= ord('a') then
          if ord(name[i]) <= ord('z') then
            name[i] := chr(ord(name[i]) - shiftDiff);
        i := i + 1
      end
  end { ShiftUp };


procedure OPN_LIBFILE(var errnum: int2; libfile_ptr: ptr_pathname;
                      var fcbptr: sfcb_ptr);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   The library file will be opened at the "sfile" level.   *)
        (*   The following search hierarchy will be used to locaate  *)
        (*   the library file: 1st - Boot disk                       *)
        (*                     2nd - Disk containing progfile        *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   progfile_ptr - ptr to pathname of progfile being created*)
        (*   libfile_ptr  - ptr to pathname of libfile to be opened  *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   errnum - the error return parameter for this            *)
        (*            procedure.  All errors are fatal.              *)
        (*   fcbptr - ptr to fcb of opened file                      *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   Any errors are reported and a code is returned to the   *)
        (*   caller.  Possible error codes are those from the file   *)
        (*   system's LOOKUP_BY_ENAME and OPEN_SFILE                 *)
        (*                                                           *)
        (*************************************************************)
  var
    lib_unit, lib_sfile: int2;

  begin
    PARSE_PATHNAME(errnum,libfile_ptr^,lib_unit,lib_sfile);
    if errnum = 0 then OPEN_SFILE(errnum,lib_sfile,lib_unit,fcbptr);
  end; (*OPN_LIBFILE*)


(*$S ProcComm *)

procedure Open_IUDirectory (* var IUD_refnum : int2 *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  var
    errnum : int2;                      { error return from Open_Dataseg }
    IUD_ptr : absptr;                   { ptr to IU Directory seg - not used }
    IUD_name : pathname;                { pathname for IU Directory segment }

  begin
    IUD_name := Concat ('-', configinfo[bootdev]^.devname, '-', IUDir_name);
    Open_Dataseg (errnum, IUD_name, IUD_refnum, IUD_ptr, IDir_ldsn);
    (*$IFC debug2 *)
    if (errnum <> 0) and Trace (pm, 90) then
      begin
        writeln ('   error opening IU Directory = ', errnum:1);
        readln
      end;
    (*$ENDC *)

    if errnum <= 0 then
      SetAccess_Dataseg (errnum, IUD_refnum, false)   { read/write }
  end { Open_IUDirectory };


procedure Close_IUDirectory (* IUD_refnum : int2 *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  var
    errnum : int2;                      { error return from Close_Dataseg }

  begin
    Close_Dataseg (errnum, IUD_refnum);
    (*$IFC debug2 *)
    if (errnum <> 0) and Trace (pm, 90) then
      begin
        writeln ('   error closing IU Directory = ', errnum:1);
        readln
      end
    (*$ENDC *)
  end { Close_IUDirectory };


(*$S init *)

procedure Setup_Directory (var errnum : int2;  obj_ptr : ObjHandle;
                           IUD_ptr : absptr;  lcb_ptr : ptr_LCB);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to set up the Intrinsic Unit & Shared         *)
        (*   Segment Directory.  Set up involves reading the info    *)
        (*   from the file INTRINSIC.LIB and building the data       *)
        (*   structures in sysglobal.  This directory is made        *)
        (*   resident in sysglobal so that the file need not be      *)
        (*   accessed on every process creation (program load).      *)
        (*   Note that the format of the directory and its location  *)
        (*   in the OS may change later for performance/size         *)
        (*   reasons.                                                *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   errnum : the error return parameter for this            *)
        (*            procedure.  All errors are fatal.              *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This routine is intended to be used only during start   *)
        (*   up to initialize the Directory and later to change the  *)
        (*   Directory dynamically.                                  *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   Any errors are reported and a code is returned to the   *)
        (*   caller.  Note that any errors here are considered       *)
        (*   fatal.  The caller should generate a system error.      *)
        (*                                                           *)
        (*************************************************************)

  var
    thisVersion : ObjBlock;               { local copy of VersionCtrl block }
    prev_block : BlockType;               { type of previous block 'read' }
    obj_block : ObjBlock;                 { 'invariant' block from file }
    obj_varblock : ObjVarBlock;           { 'variant' block from file }
    ord_ptr : absptr;                     { ptr returned by GetSpace }
    done : boolean;                       { true if Directory building completed }


  procedure Recover (error : int2);
    { procedure used by Setup_Directory (and the procedures it uses) to recover
      from errors encountered while building the directory. }

    begin
      (*$IFC debug2 *)
      writeln ('   *** Error building Directory ***');
      writeln ('       recover code = ', error:1,
               '   obj_ptr^.error = ', obj_ptr^.error:1);
      (*$ENDC *)
      errnum := error;
      exit (Setup_Directory)
    end { Recover };


  procedure Do_VersionCtrl;
    { procedure used by Setup_Directory to get the version control information
      from the directory file. }

    begin
      {thisVersion := obj_block;
      with thisVersion.bVersionCtrl do
        oldDir := (FileType = OldObjFile) and (ILibNum = 0)}
    end { Do_VersionCtrl };


  procedure Build_Unit_Directory;
    { procedure used by Setup_Directory to build the Unit portion of the directory.
      The Unit Location Table is read and a Unit Directory Entry is built for
      each entry in the table. }

    var
      i : iUnitRange;                       { loop index for Unit Location Table }
      UDT_size : int2;                      { size of Unit Directory Table }

    begin
      with obj_block.bUnitLocation, lcb_ptr^ do
        begin
          num_IUs := obj_block.NrVariants;
          UDT_size := num_IUs * Sizeof (UnitDirEntry);

          if not GetSpace (UDT_size, IUD_ptr, ord_ptr) then Recover (1)
          else
            iUnit_Dir := pointer(ord_ptr);

          for i := 1 to nUnits do
            begin
              GetObjVar (obj_ptr, UnitLocVariant, obj_varblock);
              if obj_ptr^.error <> 0 then Recover (4);

              with obj_varblock.bUnitLVariant, iUnit_Dir^[i] do
                begin
                  uNumber := UnitNumber;
                  uName := UnitName;
                  uFileNum := FileNumber;
                  uType := UnitType;
                  uDatasize := DataSize;
                  uData_ptr := nil;
                  uUse_count := 0
                end
            end { for }
        end { with obj_block.bUnitLocation, lcb_ptr^ }
    end { Build_Unit_Directory };


  procedure Build_Seg_Directory;
    { procedure used by Setup_Directory to build the Segment porion of the
      directory.  The Segment Location Table is read and a Segment Directory
      Entry is built for each entry in the table. }

    var
      i : sSegRange;                        { loop index for Seg Location Table }
      SDT_size : int2;                      { size of Segment Directory Table }

    begin
      with obj_block.bSegLocation, lcb_ptr^ do
        begin
          num_sSegs := obj_block.NrVariants;
          SDT_size := num_sSegs * Sizeof (SegDirEntry);

          if not GetSpace (SDT_size, IUD_ptr, ord_ptr) then Recover (2)
          else
            sSeg_Dir := pointer(ord_ptr);

          for i := 1 to nSegments do
            begin
              GetObjVar (obj_ptr, SegLocVariant, obj_varblock);
              if obj_ptr^.error <> 0 then Recover (4);

              with obj_varblock.bSegLocVariant, sSeg_Dir^[i] do
                begin
                  sNumber := SegNumber;
                  sName := SegName;
                  sSegSize := SizeUnpacked;
                  sPackedSize := SizePacked;
                  sFileNum := FileNumber;
                  sFileOffset := FileLocation;
                  sSegsdb_ptr := nil;
                  sUse_count := 0
                end
            end { for }
        end { with obj_block.bSegLocation, lcb_ptr^ }
    end { Build_Seg_Directory };


  procedure Build_StringTable;
    { procedure used by Setup_Directory to build a String Table for the Directory.
      The String Table is read from the directory file and set up in memory.  If
      the String Table follows the VersionCtrl block, it is set up as part of the
      Software System Directory.  Otherwise, it is set up as the Files Table. }

    var
      i : int2;                             { loop index for string table }
      SBT_size : int2;                      { size of String Block Table }
      SBT_eSize : int2;                     { size of entry in string table }
      sTable_size : int4;                   { size of string table for names }
      strTable : absptr;                    { ptr to string table in IU Dir seg }
      f_strTable : int4;                    { ptr to string table in file }
      j : sSegRange;                        { for scanning Segment Directory }
      tplate_ptr : ptr_tPlate;              { ptr for setting up string table }
      found : boolean;                      { for re-assigning file #s }

    begin
      with obj_block.bStringBlock do
        begin
          sTable_size := obj_block.NrVariants - nStrings * Sizeof (iStringVariant);
            { set up for File Table }
          SBT_eSize := Sizeof (FileDirEntry);
          SBT_size := nStrings * SBT_eSize + sTable_size;

          if not GetSpace (SBT_size, IUD_ptr, ord_ptr) then Recover (3)
          else
            tplate_ptr := pointer(ord_ptr);

          strTable := ord(tplate_ptr) + nStrings * SBT_eSize;
          GetObjPtr (obj_ptr, f_strTable);
          f_strTable := f_strTable + nStrings * Sizeof (iStringVariant);

          i := 1;
          repeat
            GetObjVar (obj_ptr, StringVariant, obj_varblock);
            if obj_ptr^.error <> 0 then Recover (4);

            with obj_varblock.bStringVariant, tplate_ptr^ do
              begin
                tNumber := ObjectNumber;
                tUse_count := 0;
                tName_ptr := pointer(strTable + NameAddr - f_strTable)
              end;

            tplate_ptr := pointer(ord(tplate_ptr) + SBT_eSize);
            i := i + 1
          until i > nStrings;

          { get the string table from the file }
          GetObjSeq (obj_ptr, pointer(strTable), sTable_size);
          if obj_ptr^.error <> 0 then Recover (4);

          with lcb_ptr^ do
            begin  { finish building File Table }
              num_lFiles := nStrings;
              File_Dir := pointer(ord_ptr);

              { initialize file IDs to 'closed' }
              for i := 1 to num_lFiles do File_Dir^[i].fFid := 0;

              { change file #s in Seg Dir to refer to File Table in memory }
              for j := 1 to num_sSegs do
                begin
                  i := 1;   found := false;
                  while (i <= num_lFiles) and not found do
                    if File_Dir^[i].fNumber = sSeg_Dir^[j].sFileNum then
                      found := true
                    else
                      i := i + 1;

                  if not found then
                    begin  { shouldn't happen if IU Manager works }
                      (*$IFC debug2 *)
                      write ('*** Warning: INTRINSIC.LIB contains ');
                      writeln ('an invalid file #.  Attempting to continue.')
                      (*$ENDC *)
                    end
                  else
                    sSeg_Dir^[j].sFileNum := i   { re-assigned }
                end { for };

              done := true
            end { finish File Table }
        end { with obj_block.bStringBlock };
    end { Build_StringTable };


  begin  { Setup_Directory }
    done := false;
    repeat
      GetObjInvar (obj_ptr, obj_block);
      if obj_ptr^.error > 0 then Recover (4);

      case obj_block.blockHeader of
        VersionCtrl:
          Do_VersionCntrl;

        StringBlock:
          Build_StringTable;   { for Files }

        UnitLocation:
          Build_Unit_Directory;

        SegLocation:
          Build_Seg_Directory;

        otherwise
          Recover (5)
      end { case };

      prev_block := obj_block.blockHeader
    until done;

    errnum := 0
  end { Setup_Directory };


procedure Map_SharedSeg (* segmmu : int2;  mem_size : int4;  init_size : int2;
                           var segSdb_ptr : sdb_ptr *);

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*   Procedure to set up the shared segment to contain the   *)
        (*   global data for shared Intrinsic Units.  Set up         *)
        (*   involves most of the same operations used for making a  *)
        (*   normal (user) data segment - setting up a file to be    *)
        (*   used as the swap space for the segment, creating the    *)
        (*   segment in memory, allocating disk space, and mapping   *)
        (*   the segment in domain 0.  Note that the shared segment  *)
        (*   is only mapped by processes that use shared Intrinsic   *)
        (*   Units and thus require access to the segment.           *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*   None.                                                   *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*   This routine is intended to be used only by             *)
        (*   Get_Shared_Ptr to set up the shared segment.  The set   *)
        (*   up of the shared segment may be changed later to be a   *)
        (*   Start up operation and/or to a more efficient           *)
        (*   algorithm than the current one.                         *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*   Several errors are possible while doing the file        *)
        (*   system operations necessary to set up the segment.      *)
        (*                                                           *)
        (*************************************************************)

  var
    disk_addr : addrdisc;                 { disk address for building segments }
    mem_size : int4;                      { resident size of shared data seg }
    disk_size : int4;                     { disk size of shared data seg }
    length : int4;                        { read-in size for shared seg }
    newlength : int2;                     { initial # blocks for shared seg }
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    sys_mrbt : mrbt_ptr;                  { ptr to system MRBT }
    sseg_ptr : ptr_shareSeg;              { ptr to the shared data segment }
    mysloc_ptr : slocal_ptr;              { ptr to syslocal of calling process }
    mymrbt_ptr : mrbt_ptr;                { ptr to calling process's MRBT }

  begin
    mem_size := sdseg_blocks * mempgsize;
    disk_size := 0;   { makes shared seg resident }
    length := 0;   { to avoid initial read in of useless data }
    newlength := mem_size DIV mempgsize;
    with disk_addr do
      begin
        fid := 0;
        offset := 0
      end;
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    Bld_Seg (data, length, newlength, disk_addr, disk_size, 0,
             lcb_ptr^.sdSegsdb_ptr);

    { map shared segment into process's address space - domain 0 only }
    with lcb_ptr^ do
      begin
        Check_DS (sdSegsdb_ptr);   { make sure it's in memory }
        sdSegsdb_ptr^.lockcount := 1;   { makes seg resident, but movable }

        sys_mrbt := pointer(s_mrbt_addr);
        with sys_mrbt^[shrsegmmu] do
          begin
            access := mmureadwrite;
            sdbRP := ord(sdSegsdb_ptr) - b_sysglobal_ptr;
          end;

        Map_Segment (sdSegsdb_ptr, shrsegmmu, 0, mmureadwrite)
      end { with lcb_ptr^ };

    mysloc_ptr := pointer(b_syslocal_ptr);
    mymrbt_ptr := pointer(mysloc_ptr^.mrbt_addr);
    mymrbt_ptr^[shrsegmmu] := sys_mrbt^[shrsegmmu];

    sseg_ptr := pointer(MMU_Base (shrsegmmu));
    with sseg_ptr^ do
      begin
        { set shared segment up as a system free pool }
        sseg_freePtr := MMU_Base (shrsegmmu) + Sizeof (shareSeg);
        sseg_size := mem_size;
        Init_FreePool (sseg_freePtr, mem_size - Sizeof (shareSeg));
      end
  end { Map_SharedSeg };


procedure Setup_IUInfo;

        (*************************************************************)
        (*                                                           *)
        (* Description:                                              *)
        (*                                                           *)
        (* Input Parameters:                                         *)
        (*                                                           *)
        (* Output Parameters:                                        *)
        (*                                                           *)
        (* Side Effects:                                             *)
        (*                                                           *)
        (* Special Conditions of Use:                                *)
        (*                                                           *)
        (* Error Conditions:                                         *)
        (*                                                           *)
        (*************************************************************)

  const
    JTCacheSize = 5120;                   { 5K for cached program jump tables }
    nDirBuffBlocks = 4;                   { # blocks for directory buffer }
    AEm_Vector = $28;                     { address of A-Emulator vector }

  type
    ptr_IUDirSeg = ^IUDirSeg;

    IUDirSeg = record
                 IUDseg_freePtr : absptr;
                 IUDseg_size : int2
               end;

  var
    lcb_ptr : ptr_LCB;                    { ptr to LCB }
    obj_ptr : ObjHandle;                  { ptr to ObjDescriptor for prog file }
    obj_block : ObjBlock;                 { 'invariant' block from prog file }
    ord_ptr : absptr;                     { ptr returned by GetSpace }
    iujsrHandler : ^absptr;               { ptr to the vector for IUJSR handler }
    IUD_refnum : int2;                    { refnum for IU Directory segment }
    IUD_size : int4;                      { size of IU Directory segment }
    IUD_ptr : absptr;                     { absptr to base of IU Directory seg }
    IUD_disksize : int4;                  { final disk size of IU Directory seg }
    IUDseg_ptr : ptr_IUDirSeg;            { ptr to IU Directory segment }
    errnum : int2;                        { error return from various calls }
    IDfile_info : fs_info;                { file system info on directory file }
    IUD_info : dsInfoRec;                 { data seg info on IU Directory seg }
    IUD_name : pathname;                  { pathname for data seg calls }
    needSize : int4;
    sseg_ptr : ptr_shareSeg;              { ptr to the shared data segment }
    mysloc_ptr : slocal_ptr;              { ptr to syslocal of calling process }
    mymrbt_ptr : mrbt_ptr;                { ptr to calling process's MRBT }


  procedure Recover;
    { procedure used by Setup_IUInfo to recover from any errors that occur while
      trying to set up the data structures for Intrinsic Unit Mgmt. }

    begin
      (*$IFC debug2 *)
      writeln ('   Error in Setup_IUInfo...');
      writeln ('   errnum = ', errnum:1,
               '   obj_ptr^.error = ', obj_ptr^.error:1);
      (*$ENDC *)
      System_Error (10100)
    end { Recover };


  begin  { Setup_IUInfo }
    errnum := 0;

    InitObjFile (obj_ptr, nDirBuffBlocks);
    if obj_ptr = nil then Recover;
    OpenObjFile (obj_ptr, IUDir_file, false { existing file });
    if obj_ptr^.error > 0 then Recover;

    { set up the Intrinsic Directory }
    Info (errnum, obj_ptr^.ObjFile^.refnum, IDfile_info);
    if errnum > 0 then Recover;
    needSize := IDfile_info.size + 512 + JTCacheSize + 1024;

    IUD_name := IUDir_name;
    Open_NR_Dataseg (errnum, IUD_name, IUD_refnum, IUD_ptr, IDir_ldsn);

    if errnum = 313 { not found } then
      begin
        Make_Dataseg (errnum, IUD_name, needSize, needSize,
                      IUD_refnum, IUD_ptr, IDir_ldsn, ds_shared);
        if errnum > 0 then Recover
      end
    else if errnum > 0 then Recover
    else
      begin  { make sure the segment is usable }
        SetAccess_Dataseg (errnum, IUD_refnum, false);   { read/write }
        Info_Dataseg (errnum, IUD_refnum, IUD_info);

        if IUD_info.mem_size < needSize then
          begin  { segment isn't the right size - probably 'old' }
            Kill_Dataseg (errnum, IUD_name);
            if errnum > 0 then Recover;
            Close_Dataseg (errnum, IUD_refnum);
            if errnum > 0 then Recover;
            Make_Dataseg (errnum, IUD_name, needSize, needSize, IUD_refnum,
                          IUD_ptr, IDir_ldsn, ds_shared);
            if errnum > 0 then Recover
          end
        else if IUD_info.mem_size > needSize then
          begin  { probably expanded too far }
            { size down depending on real size and desired size }
            Size_Dataseg (errnum, IUD_refnum,
                          needSize - IUD_info.mem_size, IUD_info.mem_size,
                          needSize - IUD_info.disc_size, IUD_info.disc_size);
            if errnum > 0 then Recover
          end
      end { segment is usable };

    { get ptr to Directory segment SDB for later }
    mysloc_ptr := pointer(b_syslocal_ptr);
    mymrbt_ptr := pointer(mysloc_ptr^.mrbt_addr);
    IUDsdb_ptr := mymrbt_ptr^[maxsysldsnmmu].sdbRP + b_sysglobal_ptr;

    { set directory segment up as a system free pool }
    IUDseg_ptr := pointer(IUD_ptr);
    with IUDseg_ptr^ do
      begin
        IUDseg_freePtr := IUD_ptr + Sizeof (IUDirSeg);
        IUDseg_size := needSize;
        Init_FreePool (IUDseg_freePtr, needSize - Sizeof (IUDirSeg))
      end;

    { set up directory }
    lcb_ptr := pointer(lcb_addr + b_sysglobal_ptr);
    Setup_Directory (errnum, obj_ptr, IUD_ptr, lcb_ptr);
    if errnum <> 0 then Recover;

    { set up the shared segment }
    Map_SharedSeg;

    { set up shared segment structures - IU trap handler }
    GetObjInvar (obj_ptr, obj_block);
    if obj_ptr^.error > 0 then Recover;
    if obj_block.blockHeader <> CodeBlock then Recover
    else
      begin  { use this copy of the handler }
        if not GetSpace (obj_block.NrVariants, MMU_Base (shrsegmmu), ord_ptr) then
          Recover;
        GetObjSeq (obj_ptr, pointer(ord_ptr), obj_block.NrVariants);
        if obj_ptr^.error > 0 then Recover;

        iujsrHandler := pointer(AEm_Vector);
        iujsrHandler^ := ord_ptr
      end;

    { now clean up }
    CloseObjFile (obj_ptr, true)
  end { Setup_IUInfo };


(*$I source/load1.text *)


(*$I source/load2.text *)

end.
ÿ