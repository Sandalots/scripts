CONST
    timeFont        =       fIDm10Pitch;
    legendFont      =       fID15Pitch;

    timeLegend      =       'time';
    alarmLegend     =       'alarm ';

    hourOffset      =        1;             {fields positions within date/time string}
    minOffset       =        4;
    ampmOffset      =        7;
    moOffset        =       11;
    dayOffset       =       14;
    yearOffset      =       17;
    displaySize     =       18;

    endJa           =       31;
    endFe           =       59;
    endMr           =       90;
    endAp           =      120;
    endMy           =      151;
    endJn           =      181;
    endJl           =      212;
    endAu           =      243;
    endSe           =      273;
    endOc           =      304;
    endNo           =      334;
    endDe           =      365;

    cln             =       ':';
    slh             =       '/';

    nullEditString  = '                  ';
                      {123456789012345678}

    uTimeMode       =   1000;
    uAlarm1Mode     =   1001;

    uAlarmOff       =   2000;
    uMaxAlarm       =   2010;

    phDing          =   1001;

TYPE
    NumberStr = STRING[11];


VAR
    editLRect:  LRect;
    hourLRect:  LRect;
    minLRect:   LRect;
    ampmLRect:  LRect;
    moLRect:    LRect;
    dayLRect:   LRect;
    yearLRect:  LRect;

    editRow:    INTEGER;
    editCol:    INTEGER;

    viewLRect:  LRect;
    legendV:    LONGINT;
    legendH:    LONGINT;
    legendLRect:LRect;

    numWidth:   INTEGER;    {display metrics}
    rowHt:      INTEGER;
    fAscent:    INTEGER;
    fDescent:   INTEGER;

    julianDays: ARRAY[0..12] OF INTEGER;

    theWindow:  TClkWindow;
    theDoc:     TClkDocManager;

METHODS OF TClkProcess;


    FUNCTION  TClkProcess.CREATE: TClkProcess;
        VAR osErr:  INTEGER;
            fInfo:  FontInfo;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF := TClkProcess(TProcess.CREATE(NewObject(mainHeap, THISCLASS), mainHeap));

        InitTimer(osErr);
        {$IFC fDbgOK}
        IF osErr > 0 THEN
            BEGIN
            ABCbreak('TClkProcess.CREATE: Error from InitTimer', osErr);
            HALT;
            END;
        {$ENDC}

        TextFont(timeFont);
        TextFace([]);
        GetFontInfo(fInfo);

        WITH fInfo DO
            BEGIN
            rowHt := ascent + descent + leading + 4;
            fAscent := ascent;
            fDescent := descent;
            END;
        numWidth := CharWidth('0');

        editRow := 1;
        editCol := 1;

        SetLRect(editLRect, editCol*numWidth, (editRow-1)*rowHt+fDescent+2,
                            (editCol+1)*numWidth, editRow*rowHt+fDescent+2);
        WITH editLRect DO
            BEGIN
            SetLRect(hourLRect, left+(hourOffset*numWidth), top,
                                left+((hourOffset+2)*numWidth), bottom);
            SetLRect(minLRect,  left+(minOffset*numWidth), top,
                                left+((minOffset+2)*numWidth), bottom);
            SetLRect(ampmLRect, left+(ampmOffset*numWidth), top,
                                left+((ampmOffset+1)*numWidth), bottom);
            SetLRect(moLRect,   left+(moOffset*numWidth), top,
                                left+((moOffset+2)*numWidth), bottom);
            SetLRect(dayLRect,  left+(dayOffset*numWidth), top,
                                left+((dayOffset+2)*numWidth), bottom);
            SetLRect(yearLRect, left+(yearOffset*numWidth), top,
                                left+((yearOffset+2)*numWidth), bottom);
            END;

        TextFont(legendFont);
        GetFontInfo(fInfo);
        WITH fInfo, editLRect DO
            BEGIN
            SetLRect(viewLRect, 0, 0, yearLRect.right+numWidth, top+bottom+ascent+descent+leading);
            legendH := left;
            legendV := bottom+ascent;
            SetLRect(legendLRect, 0, top+bottom, viewLRect.right, viewLRect.bottom);
            END;

        julianDays[00] := 0;
        julianDays[01] := endJa;
        julianDays[02] := endFe;
        julianDays[03] := endMr;
        julianDays[04] := endAp;
        julianDays[05] := endMy;
        julianDays[06] := endJn;
        julianDays[07] := endJl;
        julianDays[08] := endAu;
        julianDays[09] := endSe;
        julianDays[10] := endOc;
        julianDays[11] := endNo;
        julianDays[12] := endDe;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkProcess.Complete(allIsWell: BOOLEAN);
        VAR osErr:  INTEGER;
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        KillTimer(osErr);
        {$IFC fDBGOK}
        IF osErr > 0 THEN
            ABCBreak('Error from KillTimer = ', osErr);
        {$ENDC}
        SUPERSELF.Complete(allIsWell);
        {$IFC fTrace}EP;{$ENDC}
    END;

    PROCEDURE TClkProcess.HandlePrivateEvent(typeOfEvent: INTEGER; fromProcess: LONGINT;
                                                when: LONGINT; otherData: LONGINT);
        VAR osErr:  INTEGER;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF theWindow = NIL THEN
            BEGIN
            StopTimer(osErr);
            {$IFC fDbgOK}
            IF osErr > 0 THEN
                ABCbreak('TClkProcess.HandlePrivateEvent: Error from StopTimer', osErr);
            {$ENDC}
            END
        ELSE
            BEGIN
            theDoc.Bind;
            theWindow .Tick;
            theDoc.Unbind;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;

    FUNCTION  TClkProcess.NewDocManager(volumePrefix: TFilePath; openAsTool: BOOLEAN): TDocManager;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF openAsTool OR (docList.size = 0) THEN
            theDoc := TClkDocManager.CREATE(NIL, mainHeap, volumePrefix, SELF)
        ELSE
            theDoc := NIL;
        NewDocManager := theDoc;
        {$IFC fTrace}EP;{$ENDC}
    END;

BEGIN
    theWindow := NIL;
    theDoc := NIL;
END;



METHODS OF TClkDocManager;


    FUNCTION  TClkDocManager.CREATE(object: TObject; heap: THeap; itsPathPrefix: TFilePath;
                                        itsProcess: TClkProcess): TClkDocManager;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TClkDocManager(TDocManager.CREATE(object, heap, itsPathPrefix));
        SELF.files.shouldSuspend := FALSE;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkDocManager.Free;
    BEGIN
        {$IFC fTrace}BP(4);{$ENDC}
        theWindow := NIL;
        theDoc := NIL;
        SUPERSELF.Free;
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  TClkDocManager.NewWindow(heap: THeap; wmgrID: TWindowID):TWindow;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        theWindow := TClkWindow.CREATE(NIL, heap, wmgrID);
        NewWindow := theWindow;
        {$IFC fTrace}EP;{$ENDC}
    END;


END;


METHODS OF TClkWindow;


    FUNCTION  TClkWindow.CREATE(object: TObject; heap: THeap; itsWmgrID: TWindowID): TClkWindow;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TClkWindow(TWindow.CREATE(object, heap, itsWmgrID, TRUE));
        SELF.alarm := 0;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    PROCEDURE TClkWindow.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('panel: TPanel');
        Field('alarm: INTEGER');
        Field('views: ARRAY[0..0] OF TClkView');
        Field('');
    END;
    {$ENDC}


    PROCEDURE TClkWindow.Activate;
        VAR osErr:  INTEGER;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        StartTimer(osErr);
        SUPERSELF.Activate;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkWindow.BlankStationery;
        VAR panel:          TPanel;
            clkView:        TClkView;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        panel := TPanel.CREATE(NIL, SELF.Heap, SELF, 0, 0, [], []);
        clkView := TClkView.CREATE(NIL, SELF.Heap, panel, 0);
        SELF.panel := panel;
        SELF.views[0] := clkView;
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  TClkWindow.CanDoCommand(cmdNumber: TCmdNumber;VAR checkIt: BOOLEAN): BOOLEAN;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF (cmdNumber >= uAlarmOff) AND (cmdNumber <= uMaxAlarm) THEN
            BEGIN
            CanDoCommand := TRUE;
            checkIt := SELF.alarm = (cmdNumber - uAlarmOff);
            END
        ELSE
            CanDoCommand := SUPERSELF.CanDoCommand(cmdNumber, checkIt);
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  TClkWindow.NewCommand(cmdNumber: TCmdNumber): TCommand;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF (cmdNumber >= uAlarmOff) AND (cmdNumber <= uMaxAlarm) THEN
            BEGIN
            SELF.alarm := cmdNumber - uAlarmOff;
            NewCommand := NIL;
            END
        ELSE
            NewCommand := SUPERSELF.NewCommand(cmdNumber);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkWindow.ShowTime(update: BOOLEAN);
        VAR osErr:  INTEGER;
        PROCEDURE ShowTheTime;
        BEGIN
            SELF.views[0].ShowTime(update);
        END;
    BEGIN
        {$IFC fTrace}BP(12);{$ENDC}
        IF SELF.IsVisible THEN
            SELF.panel.OnAllPadsDo(ShowTheTime)
        ELSE
            BEGIN
            StopTimer(osErr);
            {$IFC fDbgOK}
            IF osErr > 0 THEN
                ABCbreak('TClkWindow.ShowTime: Error from StopTimer', osErr);
            {$ENDC}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkWindow.StashPicture(highTransit: THighTransit);
    BEGIN
        {$IFC fTrace}BP(12);{$ENDC}
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkWindow.Tick;
    BEGIN
        {$IFC fTrace}BP(12);{$ENDC}
        IF SELF.alarm = 1 THEN
            process.Note(phDing);

        WITH SELF DO
            IF alarm > 0 THEN
                alarm := alarm - 1;

        SELF.ShowTime(TRUE);
        {$IFC fTrace}EP;{$ENDC}
    END;


END;


METHODS OF TClkView;

    FUNCTION  TClkView.CREATE(object: TObject; heap: THeap; itsPanel: TPanel;
                                    alarm: INTEGER): TClkView;
        VAR itsExtent:  LRect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TClkView(itsPanel.NewStatusView(object, viewLRect));
        WITH SELF DO
            BEGIN
            editString := nullEditString;
            alarmNum := alarm;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    PROCEDURE TClkView.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('editString: STRING[18]');
        Field('alarmNum: INTEGER');
        Field('');
    END;
    {$ENDC}


    FUNCTION  TClkView.CursorAt(mouseLPt: LPoint): TCursorNumber;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.GetField(mouseLPt) = noBox THEN
            CursorAt := noCursor
        ELSE
            CursorAt := crossCursor;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkView.Draw;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        SELF.ShowTime(FALSE);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkView.EditChar(pos: INTEGER; newChar: CHAR);
        VAR left:       LONGINT;
            tempLRect:  LRect;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        left := editLRect.left + (pos*numWidth);
        SetLRect(tempLRect, left, editLRect.top, left+numWidth, editLRect.bottom);
        FillLRect(tempLRect, lPatWhite);
        MoveToL(left, editRow*rowHt);
        DrawChar(newChar);
        SELF.editString[pos] := newChar;
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  TClkView.GetField(mouseLPt: LPoint): TWhere;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF LPtInLRect(mouseLPt, hourLRect) THEN
            GetField := hourBox
        ELSE IF LPtInLRect(mouseLPt, minLRect) THEN
            GetField := minBox
        ELSE IF LPtInLRect(mouseLPt, ampmLRect) THEN
            GetField := ampmBox
        ELSE IF LPtInLRect(mouseLPt, moLRect) THEN
            GetField := moBox
        ELSE IF LPtInLRect(mouseLPt, dayLRect) THEN
            GetField := dayBox
        ELSE IF LPtInLRect(mouseLPt, yearLRect) THEN
            GetField := yearBox
        ELSE
            GetField := noBox;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TClkView.GetTime;
        VAR editString: TEditString;
            osErr:      INTEGER;
            curTime:    Time_Rec;
            localTime:  Time_Rec;
            strVal:     NumberStr;
            mo:         INTEGER;
            day:        INTEGER;

        PROCEDURE InsertStr(offset: INTEGER);
            VAR i:      INTEGER;
                lgth:   INTEGER;
        BEGIN
            lgth := Length(strVal);
            FOR i := 1 to lgth DO
                editString[offset+1+i-lgth] := strVal[i];
        END;

        PROCEDURE JulianToMoDay(julian: INTEGER; leapYear: BOOLEAN; VAR mo, day: INTEGER);
            VAR feb29:  BOOLEAN;
                i:      INTEGER;
        BEGIN
            feb29 := FALSE;
            IF leapYear AND (julian > endFe) THEN
                BEGIN
                IF julian = endFe+1 THEN
                    feb29 := TRUE;
                julian := julian - 1;
                END;

            i := 12;
            WHILE julianDays[i] >= julian DO
                i := i - 1;

            mo := i+1;
            IF feb29 THEN
                day := 29
            ELSE
                day := julian - julianDays[i];
        END;

    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        editString := nullEditString;

        editString[minOffset-1] := ':';
        editString[dayOffset-1] := '/';
        editString[yearOffset-1] := '/';

        Get_Time(osErr, curTime);
        Convert_Time(osErr, curTime, localTime, FALSE);

        IF localTime.hour > 11 THEN
            BEGIN
            strVal := 'pm';
            IF localTime.hour > 12 THEN
                localTime.hour := localTime.hour -12;
            END
        ELSE
            BEGIN
            strVal := 'am';
            IF localTime.hour = 0 THEN
                localTime.hour := 12;
            END;
        InsertStr(ampmOffset);

        IntToStr(localTime.hour, @strVal);
        IF Length(strVal) = 1 THEN
            strVal := Concat(' ', strval);
        InsertStr(hourOffset);

        IntToStr(localTime.minute, @strVal);
        IF Length(strVal) = 1 THEN
            strVal := Concat('0', strval);
        InsertStr(minOffset);

        JulianToMoDay(localTime.day, (localTime.year MOD 4) = 0, mo, day);

        IntToStr(mo, @strVal);
        IF Length(strVal) = 1 THEN
            strVal := Concat(' ', strval);
        InsertStr(moOffset);

        IntToStr(day, @strVal);
        IF Length(strVal) = 1 THEN
            strVal := Concat('0', strval);
        InsertStr(dayOffset);

        IntToStr(localTime.year, @strVal);
        Delete(strVal, 1, 2);
        InsertStr(yearOffset);

        SELF.editString := editString;
        {$IFC fTrace}EP;{$ENDC}
    END;


(*
&&&
    PROCEDURE TClkView.MousePress(mouseLPt: LPoint);
        VAR panel:              TPanel;
            pickSelection:      TPickSelection;
            pickedBox:          TBox;
            sketchSelection:    TSketchSelection;
            theKind:            INTEGER;

        PROCEDURE DeselectBox(object: TObject);
            VAR box:    TBox;
        BEGIN
            box := TBox(object);
            IF box.isSelected THEN
                BEGIN
                box.ToggleHighlight(SELF);
                IF pickedBox = NIL THEN     {a click in space may be a deselect or a sketch-new-box; we won't}
                    box.isSelected := TRUE; {know which until MouseRelease; save the selection until then}
                END;
        END;

    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        panel := SELF.panel;
        pickedBox := SELF.BoxWith(mouseLPt);

        IF pickedBox = NIL THEN
            BEGIN
            SELF.EachVirtualPart(DeselectBox);
            sketchSelection := TSketchSelection(panel.selection.FreedAndReplacedBy(
                                                  TSketchSelection.CREATE(NIL, SELF.Heap, SELF, mouseLPt)));
            END
        ELSE
            BEGIN
            IF NOT (pickedBox.isSelected OR clickState.fShift)THEN
                SELF.EachVirtualPart(DeselectBox);
            theKind := pickKind;
            IF clickState.fShift OR NOT pickedBox.isSelected THEN
                BEGIN
                IF pickedBox.isSelected THEN
                    theKind := unPickKind;
                pickedBox.ToggleHighlight(SELF);
                END;
            pickSelection := TPickSelection(panel.selection.FreedAndReplacedBy(
                                 TPickSelection.CREATE(NIL, SELF.Heap, SELF, theKind, mouseLPt)));
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;
*)


(*
    FUNCTION  {TClkView.}NoSelection: TSelection;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        NoSelection := TPickSelection.CREATE(NIL, SELF.Heap, SELF, nothingKind, zeroLPt);
        {$IFC fTrace}EP;{$ENDC}
    END;
*)


(*
    PROCEDURE {TClkView.}SetMinViewSize{(VAR minLRect: LRect)};  {+}
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        minLRect := viewLRect;
        {$IFC fTrace}EP;{$ENDC}
    END;
*)


    PROCEDURE TClkView.ShowTime(update: BOOLEAN);
        VAR curDisplay: TEditString;
            editString: TEditString;
            i:          INTEGER;
            s:          S255;
    BEGIN
        {$IFC fTrace}BP(12);{$ENDC}
        IF NOT update THEN
            curDisplay := nullEditString
        ELSE
            curDisplay := SELF.editString;

        SELF.GetTime;
        editString := SELF.editString;

        TextFont(timeFont);
        TextFace([]);

        {Dehilite}

        FOR i := 1 TO editLength DO
            IF curDisplay[i] <> editString[i] THEN
                SELF.EditChar(i, editString[i]);

        IF NOT update THEN
            BEGIN
            FillLRect(legendLRect, lPatWhite);
            MoveToL(legendH, legendV);
            TextFont(legendFont);
            IF SELF.alarmNum = 0 THEN
                DrawString(timeLegend)
            ELSE
                BEGIN
                DrawString(alarmLegend);
                IntToStr(SELF.alarmNum, @s);
                DrawString(s);
                END;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


END;


(*
METHODS OF TPickSelection;


    FUNCTION  {TPickSelection.}CREATE{(object: TObject; heap: THeap; itsView: TView; itsKind: INTEGER;
                                       itsAnchorLPt: LPoint): TPickSelection};
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TPickSelection(TSelection.CREATE(object, heap, itsView, itsKind, itsAnchorLPt));

        SELF.ComputeBoundingBox;
        SELF.showsHighlight := TRUE;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE {TPickSelection.}Free; {++}

        PROCEDURE InvalOtherPanel(object: TObject);
        BEGIN
            IF TPanel(object) <> SELF.view.panel THEN
                TPanel(object).Invalidate;
        END;

    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.window.panels.Each(InvalOtherPanel);
        TSelection.Free;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    PROCEDURE {TPickSelection.}Fields{(PROCEDURE Field(nameAndType: S255))};
    BEGIN
        TSelection.Fields(Field);
        Field('showsHighlight: BOOLEAN');
        Field('');
    END;
    {$ENDC}


    FUNCTION  {TPickSelection.}CanDoCommand{(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN};
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        CASE cmdNumber OF
            uWhite, uLtGray, uGray, uDkGray, uBlack,
            uFront, uBack,
            uCut, uCopy, uClear:
                CanDoCommand := SELF.kind <> nothingKind;

            uPaste:
                CanDoCommand := TRUE;

            OTHERWISE
                CanDoCommand := SUPERSELF.CanDoCommand(cmdNumber, checkIt);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE {TPickSelection.}ComputeBoundingBox;
            VAR n:              INTEGER;
                unitedLRect:    LRect;

        PROCEDURE InvalOtherPanel(object: TObject);
        BEGIN
            IF TPanel(object) <> SELF.view.panel THEN
                TPanel(object).Invalidate;
        END;

        PROCEDURE UniteBox(object: TObject);
            VAR box: TBox;
        BEGIN
            box := TBox(object);
            IF box.isSelected THEN
                BEGIN
                IF n = 0 THEN
                    unitedLRect := box.shapeLRect
                ELSE
                    UnionLRect(unitedLRect, box.shapeLRect, unitedLRect);
                n := n + 1;
                END;
        END;

    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        n := 0;
        SELF.view.EachVirtualPart(UniteBox);
        WITH SELF DO
            IF n = 0 THEN
                BEGIN
                kind := nothingKind;
                boundLRect.botRight := boundLRect.topLeft; {so right place scrolls into view for Undo Clear}
                END
            ELSE
                BEGIN
                kind := pickKind;
                boundLRect := unitedLRect;
                END;

        SELF.window.panels.Each(InvalOtherPanel);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE {TPickSelection.}Highlight{(highTransit: THighTransit)};

        PROCEDURE HiliteBox(object: TObject);
            VAR box:    TBox;
        BEGIN
            box := TBox(object);
            IF box.isSelected THEN
                box.Highlight(highTransit);
        END;

    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        {Make sure we dont show the highlight during draging}
        IF SELF.showsHighlight THEN
            SELF.view.EachVirtualPart(HiliteBox);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE {TPickSelection.}KeyClear;
        VAR dummy: BOOLEAN; {++}
    BEGIN
        {$IFC fTrace}BP(12);{$ENDC}
        IF SELF.CanDoCommand(uClear, dummy) THEN {++}
            SELF.window.PerformCommand(SELF.NewCommand(uClear)); {++}
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE {TPickSelection.}MouseMove{(mouseLPt: LPoint)};
        VAR samView:    TClkView;
            diffLPt:    LPoint;
            diffLRect:  LRect;

        PROCEDURE MoveBox(object: TObject);
        BEGIN
            TBox(object).MoveInAView(samView, diffLPt);
        END;

    BEGIN
       {$IFC fTrace}BP(11);{$ENDC}

       {First test if we want to drag this selection at all}
        IF SELF.kind = pickKind THEN
            BEGIN
            samView := TClkView(SELF.view);

           {How far did mouse move?}
            LPtMinusLPt(mouseLPt, SELF.currLPt, diffLPt);
           {Don't move past view boundaries}
            LRectMinusLRect(samView.extentLRect, SELF.boundLRect, diffLRect);
            LRectHaveLPt(diffLRect, diffLPt);

           {Move it if delta is nonzero}
            IF NOT EqualLPt(diffLPt, zeroLPt) THEN
                BEGIN
          {$H-} OffsetLRect(SELF.boundLRect, diffLPt.h, diffLPt.v); {$H+}
                LPtPlusLPt(SELF.currLPt, diffLPt, mouseLPt);
                SELF.currLPt := mouseLPt;

                IF SELF.showsHighlight THEN
                    BEGIN
                    samView.panel.Highlight(SELF, hOnToOff);
                    SELF.showsHighlight := FALSE;
                    END;

                samView.EachVirtualPart(MoveBox);
                END;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE {TPickSelection.}MouseRelease;
        VAR deltaLPt:   LPoint;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF NOT EqualLPt(SELF.currLPt, SELF.anchorLPt) THEN
            BEGIN
            LPtMinusLPt(SELF.currLPt, SELF.anchorLPt, deltaLPt);
            SELF.window.PerformCommand(TMoveCmd.CREATE(NIL, SELF.Heap, uMoveBoxes, TClkView(SELF.view),
                                                       deltaLPt.h, deltaLPt.v));
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION  {TPickSelection.}NewCommand{(cmdNumber: TCmdNumber): TCommand};
        VAR pasteH:     LONGINT;
            pasteV:     LONGINT;
            samView:    TSamView;
            heap:       THeap;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        NewCommand := NIL;

        samView := TSamView(SELF.view);
        heap := SELF.Heap;

        CASE cmdNumber OF
            uWhite, uLtGray, uGray, uDkGray, uBlack:
                NewCommand := TRecolorCmd.CREATE(NIL, heap, cmdNumber, samView, cmdNumber - uWhite
                                                 + colorWhite);

            uClear:
                NewCommand := TSamClearCmd.CREATE(NIL, heap, cmdNumber, samView, SELF.boundLRect.topLeft);

            uCut, uCopy:
                NewCommand := TSamCutCopyCmd.CREATE(NIL, heap, cmdNumber, samView, cmdNumber = uCut,
                                                     SELF.boundLRect.topLeft);

            uPaste:
                BEGIN
                WITH SELF DO
                    IF kind = nothingKind THEN
                        BEGIN
                        pasteH := samView.clickLPt.h;
                        pastev := samView.clickLPt.v;
                        END
                    ELSE
                        WITH boundLRect DO
                            BEGIN
                            pasteH := (left + right) DIV 2;
                            pasteV := (top + bottom) DIV 2;
                            END;
                NewCommand := TSamPasteCmd.CREATE(NIL, heap, cmdNumber, samView, pasteH, pasteV);
                END;

            uFront, uBack:
                NewCommand := TFrontBackCmd.CREATE(NIL, heap, cmdNumber, samView, cmdNumber = uBack);

            OTHERWISE
                NewCommand := SUPERSELF.NewCommand(cmdNumber);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;

    PROCEDURE {TPickSelection.}Restore;
        PROCEDURE RestSelection(object: TObject);
        BEGIN
            TBox(object).isSelected := TBox(object).wasSelected;
        END;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        SUPERSELF.Restore;
        SELF.view.EachVirtualPart(RestSelection);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE {TPickSelection.}Save;
        PROCEDURE SaveSelection(object: TObject);
        BEGIN
            TBox(object).wasSelected := TBox(object).isSelected;
        END;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        SELF.view.EachVirtualPart(SaveSelection);
        SUPERSELF.Save;
        {$IFC fTrace}EP;{$ENDC}
    END;


END;
*)


ÿ