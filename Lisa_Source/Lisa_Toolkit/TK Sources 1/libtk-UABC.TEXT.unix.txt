{UNIT UABC}
{Copyright 1983, 1984, Apple Computer, Inc.}

                    { *** METHODS NEED TO BE GROUPED INTO RIGHT CATEGORIES *** }
                    { *** ADD reserve IN ALMOST EVERY CLASS ***}

{ UABC2.TEXT  TProcess-TDocDirectory-TDocManager-TClipboard-TCommand-TCutCopyCommand-TPasteCommand}
{ UABC3.TEXT  TImage-TView-TPaginatedView-TPageView-TPrintManager-THeading-TSelection}
{ UABC4.TEXT  TWindow-TDialogBox-TMenuBar-TFont}
{ UABC5.TEXT  TPanel-TBand-TPane-TMarginPad-TBodyPad-TScroller-TScrollBar}


UNIT UABC;

{$SETC IsIntrinsic := TRUE }

{$IFC IsIntrinsic}
INTRINSIC;
{$ENDC}

INTERFACE


USES
    {$U UnitStd     } UnitStd,      {Client should not USE UnitStd}
    {$U UnitHz      } UnitHz,       {Client should not USE UnitHz and MUST NOT USE Storage}
    {$U libtk/UObject     } UObject,      {Client must USE UObject}
    {$U -#BOOT-SysCall} SysCall,     {Client may USE SysCall}
{$IFC LibraryVersion > 20}
    {$U LIBTK/Passwd} Passwd,
{$ENDC}
{$IFC LibraryVersion <= 20}
    {$U FontMgr     } FontMgr,      {Client should USE UFont instead of FontMgr before QuickDraw}
{$ENDC}
    {$U QuickDraw   } QuickDraw,    {Client must USE QuickDraw (unless we provide a type-stub for it)}
{$IFC LibraryVersion > 20}
    {$U FontMgr     } FontMgr,      {Client should USE UFont instead of FontMgr after QuickDraw}
{$ENDC}
    {$U libtk/UDraw       } UDraw,        {Client must USE UDraw}

                                    {Client need not USE anything below this line}
    {$U PMDecl      } PMDecl,
{$IFC libraryVersion <= 20}        { P E P S I }
    {$U PrStd       } PrStd,
{$ENDC}
    {$U WM.Events   } Events,
    {$U WM.Folders  } Folders,
    {$U WM.Menus    } Menus,
    {$U AlertMgr    } AlertMgr,
{$IFC LibraryVersion <= 20}
    {$U PrProcs     } PrProcs,
{$ENDC}
    {$U WMLstd      } WMLstd,
    {$U WMLCrs      } WMLCrs,
    {$U WMLSb       } WMLSb,
    {$U WMLGrow     } WMLGrow,
    {$U Scrap       } Scrap,
{$IFC libraryVersion <= 20}
    {$U PrMgrUtil   } PrMgrUtil,
    {$U PrMgr       } PrMgr,
{$ELSEC}                            { S P R I N G }
    {$U PrStdInfo}    PrStdInfo,
    {$U PrPublic}     PrPublic,
{$ENDC}
    {$U FilerComm   } FilerComm;


{$SETC fDbgABC     := fDbgOK}{FALSE}
{$SETC fRngABC     := fDbgOK}{FALSE}
{$SETC fSymABC     := fSymOK}{FALSE}

{$SETC fDebugMethods := fDbgABC} {if VAR also true, trace entries and/or exits}


CONST

    maxMenus        = 31;   {unfortunate, but menus must be in non-relocatable storage, & this is easiest}
    maxFonts        = 11;
    maxSegments     = 6;
    maxSegSize      = $20000; {128K}
    abortChunkSize  = 32768;  {32k}

    iconNameSeparator = '<';{character separating parts of an icon name}

    stdHHysteresis  = 9;    {amount the mouse must move from anchor before drag starts, unless}
    stdVHysteresis  = 6;    {           TSelection.GetHysteresis is overridden}

    noCursor        = -2;   {                   used when you do not set the cursor}
    hiddenCursor    = -1;   {icrsHidden         Hides the cursor entirely}
    arrowCursor     =  1;   {icrsInactive       Standard arrow cursor}
    crossCursor     =  9;   {icrsLCCross        LisaCalc cross}
    textCursor      = 10;   {icrsXIBeam         Standard text I-Beam}
    checkCursor     = 12;   {icrsCheck          Checkmark}
    smCrossCursor   = 13;   {icrsGECross        LisaDraw cross (smaller than crossCursor)}
    fingerCursor    = 14;   {icrsLFinger        LisaDraw left-pointing finger}

    firstUserCursor = 100;  { this is the smallest user-defined cursor }

    nothingKind     = 0;

    noCmdNumber     = 0;

    docLdsn         = 3;        {ldsn for the first document data segment}
    docDsBytes      = 5120;     {default heap size for a document data segment}
    docExcess       = 2048;     {the virtual data segment may be this much larger than needed for the heap}

    printLdsn       = 2;        {ldsn to hand to LisaPrint}
    ascArwDown      = $1F;
    ascArwLeft      = $1C;
    ascArwRight     = $1D;
    ascArwUp        = $1E;
    ascBackspace    = $08;
    ascClear        = $1B;
    ascEnter        = $03;
    ascReturn       = $0D;
    ascTab          = $09;

 {alert phrase codes must be between 9 and 899}

    phWordDelimiters=  9;

    phTrouble       = 10;   {The tool is having trouble}
    phUnknown       = 11;   {Phrase(error) is undefined for this error}
    phNoText        = 21;
    phNoSel         = 22;
    phNoInsPt       = 23;
    phRevert        = 24;
    phRevBlank      = 25;
    phUnkCmd        = 26;
    phSelCant       = 27;
    phUnchanged     = 28;
    phSaving        = 29;
    phTerminated    = 30;
    phEditClip      = 31;
    phNoClip        = 32;
    phUnkClip       = 33;
    phDialogUp      = 34;
    phCantUndo      = 35;
    phNoCommand     = 36;
    phOlderVersion  = 37;
    phNewerVersion  = 38;
    phConverting    = 39;
    phAborting      = 40;

    phPage          = 41; {+SW+}
    phTitle         = 42; {+SW+}

    phCantSave      = 43;
    phCantRevert    = 44;

    phCountry       = 45;


  {command, selection, and phrase indices used by Dialog Building Block}
    uCreateLayoutBox = 701;    {Command numbers}
    uMoveLayoutBoxes  = 702;
    uCmdLaunchHeading = 703;
    uCmdInstallMargins = 704;

    layPickKind = 119;         {Selection kinds}
    layEditLegendKind = 133;
    frameKind = 161;

    phTooManyChars = 101;      {Phrases}
    phOddEven = 102;
    phOddOnly = 103;
    phEvenOnly  = 104;
    phOddOrEven = 105;
    phMinPage = 106;
    phMaxPage = 107;
    phPageAlignment = 108;
    phAlignment = 109;
    phTopLeft = 110;
    phTopCenter = 111;
    phTopRight = 112;
    phBotLeft = 113;
    phBotCenter = 114;
    phBotRight = 115;
    phLaunchHeading = 116;
    phPageMargins = 117;
    phUnits = 118;
    phInches = 119;
    phCentimeters = 120;
    phLeft = 121;
    phLeftCluster = 122;
    phTop = 123;
    phTopCluster = 124;
    phRight = 125;
    phRightCluster = 126;
    phBottom = 127;
    phBotCluster = 128;
    phInstallMargins = 129;
    phInchTitle= 130;
    phCmTitle = 131;
    phNewHeading = 132; {+SW+}

    phOK = 142;      {client should NOT lightly change the phrases for these, since they are used for}
    phCancel = 143;  {determining text and locations of OK/Cancel buttons for built-in ToolKit dialogs}

    stdBoxWidth  = 17;  {dimensions for default checkboxes}
    stdBoxHeight = 11;
    stdBoxSpacing = 20;

    stdCurvH  = 18;  {for Buttons}
    stdCurvV  = 14;
    stdBtnHeight = 22;

    noIDNumber = -2;
    noId = '';

    IDLength = 9; {the significant length of id strings}

    stdTitleHeight = 10;     {for layout boxes}
    stdSlimTitleHeight = 6;
    stdLeftRightBorder = 3;
    stdBottomBorder = 2;

  {errcodes of other libraries}

    erAborted       = 4033; {user typed Apple-.; Desktop Manager}
    erDuplicateName =  890; {OS & Desktop Manager}
    erInvalidName   =  971; {OS & Desktop Manager}
    erNameNotFound  =  972; {OS & Desktop Manager}

  {ToolKit errCodes must be between 4201 and 4499}

    erPassword      = 4201;
    erVersion       = 4202;
    erBadData       = 4203;
    erCantRead      = 4304;
    erCantWrite     = 4305;
    erDirtyDoc      = 4306;
    erNoMoreDocs    = 4307;
    erNoMemory      = 4308;
    erNoDiskSpace   = 4309;
    erWrongPassword = 4310;
    erMaxToolKit    = 4499;

  {command codes must be between 101 and 999}

    uSetAllAside    = 101;
    uSetAside       = 102;
    uPutAway        = 103;
    uPrFmt          = 104;
    uPrintAsIs      = 111;
    uPrint          = 105;
    uPrMonitor      = 106;
    uSaveVersion    = 107;
    uRevertVersion  = 108;
    utSetAside      = 109;  {Set Aside ^Document^}
    uSetClipAside   = 110;

    {Typing Buzzword}
    uTyping         = 150;

    {The toolkit uses the following only as arguments to selection.CantDoCmd}
    uBackspace      = 151;
    uEnter          = 152;
    uForwardSpace   = 153;
    uReturn         = 154;
    uTab            = 155;

    {The toolkit uses the following only as arguments to process.RememberCommand}
    uSomeCommand    = 156;
    uScrolling      = 157;
    uSplitting      = 158;
    uResizeWindow   = 159;
    uResizePanel    = 160;
    UMousePress     = 161;
    uThumbing       = 162;
    uMoveWindow     = 163;
    uKeyDown        = 164; {could be made the same as uTyping}

    uCopy           = 201;
    uCut            = 202;
    uPaste          = 203;
    uSelAll         = 204;
    uUndoLast       = 205;
    utUndoLast      = 206;  {Undo ^Last Change^}
    utRedoLast      = 207;  {Redo ^Last Change^}
    uClear          = 208;

{$IFC LibraryVersion <= 20}
    uFnt0           = 300;
    uFnt1           = 301;
    uFnt2           = 302;
    uFnt3           = 303;
    uFnt4           = 304;
    uFnt5           = 305;
    uFnt6           = 306;
    uFnt7           = 307;
    uFnt8           = 308;
    uFnt9           = 309;
    uFnt10          = 310;
    uFnt11          = 311;
{$ENDC}
    uModern         = 320 + famModern - famMin;     {should result in 320}
    uClassic        = 320 + famClassic - famMin;

    u20Pitch        = 330 + size20Pitch - sizeMin;  {should result in 330}
    u15Pitch        = 330 + size15Pitch - sizeMin;
    u12Pitch        = 330 + size12Pitch - sizeMin;
    u10Pitch        = 330 + size10Pitch - sizeMin;
    u12Point        = 330 + size12Point - sizeMin;
    u14Point        = 330 + size14Point - sizeMin;
    u18Point        = 330 + size18Point - sizeMin;
    u24Point        = 330 + size24Point - sizeMin;

    uPlain          = 351;
    uBold           = 352;
    uItalic         = 353;
    uUnderline      = 354;
    uShadow         = 355;
    uOutline        = 356;
    uSuperscript    = 357;
    uSubscript      = 358;

    uPrvwMargins    = 401;
    uPrvwBreaks     = 402;
    uPrvwOff        = 403;
    uDesignPages    = 405;

    uShowFullSize   = 406;
    uReduce70Pct    = 407;
    uReduceToFit    = 408;

    uSetHorzBreak   = 411;
    uSetVertBreak   = 412;
    uClearBreaks    = 413;

    uRiseVertically   = 421;
    uRiseHorizontally = 422;

    uAddColumnStrip   = 431;
    uAddRowStrip      = 432;

    uReportEvents   = 501;

    uCountHeap      = 506;

    uCheckIndices   = 509;
    uDumpGlobals    = 510;
    uDumpPrelude    = 511;
    uExperimenting  = 512;
    uReptGarbage    = 513;
    uFreeGarbage    = 514;

    uMainScramble   = 515;
    uDocScramble    = 516;

    uEditDialog     = 521;
    uStopEditDialog = 522;

  { the standard WantMenu will return FALSE for any menus with menuID >= mBuzzword;
    buzzword menus should be assigned IDs >= 100;
    debug menus should be assigned IDs 90-99 }

    {$IFC fDbgABC}
    mBuzzword       = 100;
    {$ELSEC}
    mBuzzword       =  90;
    {$ENDC}

    mnuClipFilePrint = 1000;    {special menuID for Clipboard File/Print}

    firstPrivateEvent = 100; {first event type that you can use in TProcess.SendEvent}

    {$IFC NOT fDbgABC}
    fExperimenting  =   FALSE;  { not experimenting if debug code if off }
    {$ENDC}

TYPE

    TPrinterMetrics = RECORD
        paperRect:     Rect;     {the physical rectangle}
        printRect:     Rect;     {the printable rectangle}
        res:           Point;    {resolution, spots/inch}
        reserve:       ARRAY[0..7] OF BYTE;
        END;

    TPreviewMode = (mPrvwMargins, mPrvwBreaks, mPrvwOff);

    TDiResponse = (diAccept, diDismissDialogBox, diGiveToMainWindow, diRefuse);

    TEnumAbilities = (aBar, aScroll, aSplit);
    TAbilities = SET OF TEnumAbilities;                     {for TPanel.Divide/CREATE argument}

    TUnitsFromEdge = (pixelsFromEdge, percentFromEdge);     {for TPanel.Divide argument}

    TAlertArg = 1..5;
    TAlertCounter = 7..9;

    TAlignment = (aLeft, aRight, aCenter, aJustify);
    TPageAlignment = (aTopLeft, aTopCenter, aTopRight, aBottomLeft, aBottomCenter, aBottomRight);

    TClickState =  RECORD
                   where: Point;
                   when: LONGINT;
                   clickCount: INTEGER;
                   fShift, fOption, fApple: BOOLEAN;
                   END;

    TCmdNumber = INTEGER;       {the unique identifier of a command in a menu (or elsewhere)}

    TCmdPhase = (doPhase, undoPhase, redoPhase);{doPhase first time, then undoPhase & redoPhase alternately}

    TCursorNumber = INTEGER;

    TEnumIcons = (iSkewer, iScrollBack, iFlipBack, iGrayA, iThumb, iGrayB, iFlipFwd, iScrollFwd); {TIcon}

    TMousePhase = (mPress, mMove, mRelease);

    TRevelation = (revealNone, revealSome, revealAll);

    TPrReserve = ARRAY [0..127] OF Byte;       {lengthened}
    TPrelude =
        RECORD
            password:       {2} INTEGER;
            version:        {2} INTEGER;        {*** Should also do ABC version protection***}
            country:        {2} INTEGER;
            language:       {2} INTEGER;
            preludeSize:    {2} INTEGER;        {SIZEOF(TPrelude), which precedes the heap}
            unused:         {6} ARRAY [0..5] OF Byte;
           {The above fields should occupy 16 bytes to meet the Lisa standard}
            printPref:    {128} TPrReserve;
            docSize:        {4} LONGINT;        {sum of the sizes of the consecutive data segments}
            numSegments:    {2} INTEGER;        {no. of segments; all but the last are maxSegSize bytes}
            docDirectory:   {4} TDocDirectory;  {whence one finds the class table and the window}
           {Other fields may be added later}
            END;

    TPPrelude = ^TPrelude;

    TSBoxID = LONGINT; {THSb alias}

    TWindowID = LONGINT; {WindowPtr alias}

    TWmgrCmd =
        RECORD
            cmdNumber:  INTEGER;                {the command number}
            menuIndex:  Byte;                   {the ordinal number of the menu in its menu bar (or file)}
            itemIndex:  Byte;                   {the ordinal number of the item in its menu}
        END;


    TProcess = SUBCLASS OF TObject {only one instance exists (process)}

      {Variables}

      {Creation/Destruction}
        FUNCTION  {TProcess.}CREATE(object: TObject; heap: THeap): TProcess;

      {Debugging}
        {$IFC fDebugMethods}
        PROCEDURE {TProcess.}DontDebug;     {Turn off all debug flags when last document is closed}
        {$ENDC}
        {$IFC fDbgABC}
        PROCEDURE {TProcess.}DumpGlobals;   {Print most global variables on alternate screen}
        {$ENDC}


      {Cursor Tracking}
        PROCEDURE {TProcess.}ChangeCursor(cursorNumber: TCursorNumber);
                    { applications call ChangeCursor if they want to change the cursor shape }
        PROCEDURE {TProcess.}DoCursorChange(cursorNumber: TCursorNumber);
                    { applications implement DoCursorChange to test cursorNumber for one of their
                        cursor shapes; if found, it calls QuickDraw's SetCursor routine, otherwise
                        it calls the generic TProcess.DoCursorChange }
        PROCEDURE {TProcess.}TrackCursor;

      {Error Reporting}
        PROCEDURE {TProcess.}ArgAlert(whichArg: TAlertArg; argText: S255); {whichArg = 1 to 5}
        FUNCTION  {TProcess.}Ask(phraseNumber: INTEGER): INTEGER;
        PROCEDURE {TProcess.}BeginWait(phraseNumber: INTEGER);
        FUNCTION  {TProcess.}Caution(phraseNumber: INTEGER): BOOLEAN;
        PROCEDURE {TProcess.}CountAlert(whichCtr: TAlertCounter; counter: INTEGER);
        PROCEDURE {TProcess.}DrawAlert(phraseNumber: INTEGER; marginLRect: LRect);
        PROCEDURE {TProcess.}EndWait;
        PROCEDURE {TProcess.}GetAlert(phraseNumber: INTEGER; VAR theText: S255);
        PROCEDURE {TProcess.}Note(phraseNumber: INTEGER);
        PROCEDURE {TProcess.}RememberCommand(cmdNumber: TCmdNumber);    { for ^C and ^K in alerts }
        FUNCTION  {TProcess.}Phrase(error: INTEGER): INTEGER;
        PROCEDURE {TProcess.}Stop(phraseNumber: INTEGER);

      {Initiate/Terminate}
        PROCEDURE {TProcess.}Commence(phraseVersion: INTEGER); {process init after the process object exists}
        PROCEDURE {TProcess.}Complete(allIsWell: BOOLEAN);

      {Abort Handling}
        FUNCTION  {TProcess.}AbortRequest: BOOLEAN;
        PROCEDURE {TProcess.}AbortXferSequential(whichWay: xReadWrite; pFirst: Ptr;
                                                 numBytes, chunkSize: LONGINT; fs: TFileScanner);

      {Main Loop}
        PROCEDURE {TProcess.}ObeyEvents(FUNCTION StopCondition: BOOLEAN);
                    {This will return IF: (1) amDying is TRUE (application terminated)
                        or (2) StopCondition returns TRUE (StopCondition is checked
                        only when no events are available, before starting to idle.)}

        PROCEDURE {TProcess.}ObeyFilerEvent;
        PROCEDURE {TProcess.}ObeyTheEvent;
        PROCEDURE {TProcess.}Run;

      {Private Events (Inter-process communication)}
        PROCEDURE {TProcess.}HandlePrivateEvent(typeOfEvent: INTEGER; fromProcess: LONGINT;
                                        when: LONGINT; otherData: LONGINT); DEFAULT;
        PROCEDURE {TProcess.}SendEvent(typeOfEvent: INTEGER; targetProcess: LONGINT; otherData: LONGINT);

      {Memory Management}
        PROCEDURE {TProcess.}BindCurrentDocument;

      {Open/Close Window/Document}
        FUNCTION  {TProcess.}NewDocManager(volumePrefix: TFilePath; openAsTool: BOOLEAN)
                                          : TDocManager; DEFAULT;

      {External Document Support}
        PROCEDURE {TProcess.}CopyExternalDoc(VAR error: INTEGER;
                            externalName, volumePrefix: TFilePath); DEFAULT;
            {This is called if the application puts icons into the clipboard and the user
                then pastes them into a folder or disk.}

        END;


    TDocDirectory = SUBCLASS OF TObject

      {Variables}
        window:         TWindow;
        classWorld:     TClassWorld;

      {Creation/Destruction}
        FUNCTION  {TDocDirectory.}CREATE(object: TObject; heap: THeap; itsWindow: TWindow;
                                         itsClassWorld: TClassWorld): TDocDirectory;

      {Version Conversion}
        PROCEDURE {TDocDirectory.}Adopt;

        END;


    TDocManager = SUBCLASS OF TObject

      {Variables}
        files:
            RECORD
            volumePrefix:   TFilePath;              {Desktop Manager volume and prefix of OS files}
            volume:         TFilePath;              {Desktop Manager volume of OS files; -volname-}
{$IFC LibraryVersion > 20}
            password:       TPassword;              {The password for this document}
{$ENDC}
            saveExists:     BOOLEAN;                {whether Save file is known to exist and seem readable}
            shouldSuspend:  BOOLEAN;                {should we create suspend files?}
            shouldToolSave: BOOLEAN;                {should we create save files if opened as a tool?}
            END;
        dataSegment:
            RECORD
            refnum:         ARRAY [1..maxSegments] OF INTEGER;    {refnums of its data segments}
            preludePtr:     TPPrelude;              {a pointer to the prelude of the data segment}
            changes:        LONGINT;                {How many changes since the last checkpoint}
            END;
        docHeap:            THeap;                  {the heap starts after the prelude}
        window:             TWindow;                {the document's window (it is in the data segment)}
        pendingNote:        INTEGER;                {If <> 0, NOTE alert that was requested while inactive}
        openedAsTool:       BOOLEAN;

      {Creation/Destruction}
        FUNCTION  {TDocManager.}CREATE(object: TObject; heap: THeap; itsPathPrefix: TFilePath): TDocManager;

      {Debugging}
        {$IFC fDbgABC}
        PROCEDURE {TDocManager.}DumpPrelude;        {Print most of prelude on alternate screen}
        {$ENDC}

      {Attributes}
        FUNCTION  {TDocManager.}WindowWithId(wmgrID: TWindowID): TWindow;

      {Process Termination}
        PROCEDURE {TDocManager.}Complete(allIsWell: BOOLEAN);

      {Open/Close Window}
        FUNCTION  {TDocManager.}NewWindow(heap: THeap; wmgrID: TWindowID): TWindow; DEFAULT;

      {Files}
        PROCEDURE {TDocManager.}Close(afterSuspend: BOOLEAN);
          { CloseFiles is for the application to override if it has any of its own files that must be
            closed }
        PROCEDURE {TDocManager.}CloseFiles;
        PROCEDURE {TDocManager.}Open(VAR error: INTEGER; wmgrID: TWindowID; VAR OpenedSuspended:Boolean);
        PROCEDURE {TDocManager.}OpenBlank(VAR error: INTEGER; wmgrID: TWindowID);
        PROCEDURE {TDocManager.}OpenSaved(VAR error: INTEGER; wmgrID: TWindowID);
        PROCEDURE {TDocManager.}OpenSuspended(VAR error: INTEGER; wmgrID: TWindowID);
        PROCEDURE {TDocManager.}RevertVersion(VAR error: INTEGER; wmgrID: TWindowID);
        PROCEDURE {TDocManager.}SaveVersion(VAR error: INTEGER; volumePrefix: TFilePath;
                                            andContinue: BOOLEAN);
        PROCEDURE {TDocManager.}Suspend(VAR error: INTEGER);

      {Data Segment}
        PROCEDURE {TDocManager.}Assimilate(VAR error: INTEGER);
        PROCEDURE {TDocManager.}Bind; DEFAULT;
        PROCEDURE {TDocManager.}ConserveMemory(maxExcess: LONGINT; fGC: BOOLEAN);
                                    {if fGC is TRUE also do a garbage collect -- on debugging versions,
                                        we just report garbage, on non-debugging versions we free it
                                        also.}
        PROCEDURE {TDocManager.}Deactivate;
        FUNCTION  {TDocManager.}DfltHeapSize: LONGINT;
        PROCEDURE {TDocManager.}ExpandMemory(bytesNeeded: LONGINT);
        PROCEDURE {TDocManager.}KillSegments(first, last: INTEGER);
        PROCEDURE {TDocManager.}MakeSegments(VAR error: INTEGER; oldSegments: INTEGER; newDocSize: LONGINT);
        PROCEDURE {TDocManager.}ResumeAfterOpen(VAR error: INTEGER; wmgrID: TWindowID);
        PROCEDURE {TDocManager.}SetSegSize(VAR error: INTEGER; minSize, maxExcess: LONGINT);
        PROCEDURE {TDocManager.}Unbind; DEFAULT;
        END;

    TClipboard = SUBCLASS OF TDocManager

      {Variables}
        hasView:            BOOLEAN;        {FALSE if no tool-kit-specific representation available}
        hasPicture:         BOOLEAN;        {FALSE if no universal picture available}
        hasUniversalText:   BOOLEAN;        {FALSE if no universal text available}
        hasIcon:            BOOLEAN;        {TRUE if there is an icon reference available}
     {****NOTE: The only way into or out of Universal Text is via the Universal Text Building Block****}
        cuttingTool:        LONGINT;        {The tool number of the tool that loaded the Clipboard, or 0}
        cuttingProcessID:   LONGINT;        {The OS process ID of the tool that loaded the Clipboard, or 0}
        clipCopy:           TFileScanner;   {IF <> NIL a scanner on the file containing a copy of the
                                                clipboard before conversion.}

      {Creation/Destruction}
        FUNCTION  {TClipboard.}CREATE(object: TObject; heap: THeap): TClipboard;

      {Editing}
        PROCEDURE {TClipboard.}AboutToCut;      {whether or not data will actually be put in the data seg}
        PROCEDURE {TClipboard.}BeginCut;
        PROCEDURE {TClipboard.}EndCut;

      {Undo}
        PROCEDURE {TClipboard.}CommitCut;
        FUNCTION  {TClipboard.}UndoCut: BOOLEAN; {return TRUE if succeeds}

      {Identification}
        PROCEDURE {TClipboard.}Inspect;
        PROCEDURE {TClipboard.}Publicize;

      {Data Segment}
       {PROCEDURE  TClipboard. Bind;}
       {PROCEDURE  TClipboard. Unbind;}

        END;


    TCommand = SUBCLASS OF TObject

      {Variables}
        cmdNumber:      TCmdNumber;     {the command number of the menu item that describes the command;
                                        usually the same one the user chose, but not necessarily}
        image:          TImage;         {If non-NIL, affects filtering by image.EachVirtualPart}
        undoable:       BOOLEAN;        {TRUE iff this command is undoable}
        doing:          BOOLEAN;        {TRUE if Performing or just did doPhase or redoPhase}
        revelation:     TRevelation;    {revealNone/Some/All of selection before performing command}
        unHiliteBefore: ARRAY [TCmdPhase] OF BOOLEAN; {TRUE -> Toolkit unhilites all selections before
                                                       perform}
        hiliteAfter:    ARRAY [TCmdPhase] OF BOOLEAN; {TRUE -> Toolkit hilites all selections after perform}

      {Creation/Destruction}
        FUNCTION  {TCommand.}CREATE(object: TObject; heap: THeap; itsCmdNumber: TCmdNumber;
                             itsImage: TImage; isUndoable: BOOLEAN; itsRevelation: TRevelation): TCommand;

      {Filtering}
        PROCEDURE {TCommand.}EachVirtualPart(PROCEDURE DoToObject(filteredObj: TObject));
        PROCEDURE {TCommand.}FilterAndDo(actualObj: TObject; PROCEDURE DoToObject(filteredObj: TObject));

      {Command Execution}
        PROCEDURE {TCommand.}Commit; DEFAULT;                        {commit a command}
        PROCEDURE {TCommand.}Perform(cmdPhase: TCmdPhase); DEFAULT;  {do, undo, or redo a command}

        END;


    TCutCopyCommand = SUBCLASS OF TCommand

      {Variables}
        isCut: BOOLEAN;        {TRUE iff this was a cut; FALSE iff a copy}

      {Creation/Destruction}
        FUNCTION  {TCutCopyCommand.}CREATE(object: TObject; heap: THeap; itsCmdNumber: TCmdNumber;
                                        itsImage: TImage; isCutCmd: BOOLEAN): TCutCopyCommand;

      {Command Execution}
       {PROCEDURE  TCutCopyCommand. Commit;}
        PROCEDURE {TCutCopyCommand.}DoCutCopy(clipSelection: TSelection; deleteOriginal: BOOLEAN;
                                              cmdPhase: TCmdPhase); DEFAULT;
                        {the clipboard is already set up; you only have to load data into it in doPhase}
       {PROCEDURE  TCutCopyCommand. Perform(cmdPhase: TCmdPhase);}

        END;


    TPasteCommand = SUBCLASS OF TCommand

      {Creation/Destruction}
        FUNCTION  {TPasteCommand.}CREATE(object: TObject; heap: THeap; itsCmdNumber: TCmdNumber;
                                         itsImage: TImage): TPasteCommand;

      {Command Execution}
        PROCEDURE {TPasteCommand.}DoPaste(clipSelection: TSelection; pic: PicHandle;
                                          cmdPhase: TCmdPhase); DEFAULT;
                        {the clipboard is already set up, except in undoPhase sel & pic are NIL}
       {PROCEDURE  TPasteCommand. Perform(cmdPhase: TCmdPhase);}

        END;


    TImage = SUBCLASS OF TObject

      {Variables}
        extentLRect:        LRect;          {the bounding box for updates; also for default hit-testing}
        view:               TView;
        allowMouseOutside:  BOOLEAN;        {If TRUE, TImage.MouseTrack will NOT force the mouse point
                                                to lie within the extentLRect; TImage.CREATE sets this FALSE}

   {methods}
        FUNCTION  {TImage.}CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsView: TView): TImage;

        FUNCTION  {TImage.}CursorAt(mouseLPt: lPoint): TCursorNumber; DEFAULT;
        PROCEDURE {TImage.}Draw; DEFAULT;
        PROCEDURE {TImage.}EachActualPart(PROCEDURE DoToObject(filteredObj: TObject)); DEFAULT;
        PROCEDURE {TImage.}EachVirtualPart(PROCEDURE DoToObject(filteredObj: TObject)); DEFAULT;
        PROCEDURE {TImage.}FilterAndDo(actualObj: TObject; PROCEDURE DoToObject(filteredObj: TObject));
        PROCEDURE {TImage.}HaveView(view: TView); DEFAULT;
        FUNCTION  {TImage.}Hit(mouseLPt: lPoint): BOOLEAN; DEFAULT;
        PROCEDURE {TImage.}Invalidate;  {does NOT do it on all pads}
        FUNCTION  {TImage.}LaunchLayoutBox(view: TView): TImage; DEFAULT;
        PROCEDURE {TImage.}OffSetBy(deltaLPt: LPoint); DEFAULT;
        PROCEDURE {TImage.}OffSetTo(newTopLeft: LPoint);
        PROCEDURE {TImage.}MouseMove(mouseLPt: lPoint); DEFAULT;
        PROCEDURE {TImage.}MousePress(mouseLPt: lPoint); DEFAULT;
        PROCEDURE {TImage.}MouseRelease; DEFAULT;
        PROCEDURE {TImage.}MouseTrack(mPhase: TMousePhase; mouseLPt: LPoint); DEFAULT;
        PROCEDURE {TImage.}ReactToPrinterChange; DEFAULT;
        PROCEDURE {TImage.}RecalcExtent; DEFAULT;
        PROCEDURE {TImage.}Resize(newExtent: LRect); DEFAULT;
        FUNCTION  {TImage.}SeesSameAs(image: TImage): BOOLEAN; DEFAULT; {$}

        END;


    TView = SUBCLASS OF TImage

      {Variables}
        panel:              TPanel;                     {The panel in which it is viewed}
        clickLPt:           LPoint;                     {The last place the user clicked the mouse button}
        printManager:       TPrintManager;              {NIL if view not printable}
        res:                Point;                      {resolution, spots/inch}

        screenPad:          TPad;      {like noPad, but scales from view coords to screen coords if view
                                        resolution and screen resolution differ
                                        *** CAUTION -- Only for mapping coordinates-- DO NOT try to
                                        Focus this pad or do Invals, etx ***}

        fitPagesPerfectly:  BOOLEAN;  {whether view size should fluctuate automatically so that one always
                                         ends up with an even number of pages}

        isPrintable:        BOOLEAN;                 {Whether this view can be printed}
        isMainView:         BOOLEAN;     {FALSE if an auxiliary view, such as page view or paginated view}
        stdScroll:          LPoint;
        scrollPastEnd:      Point;                {Amount we should scroll past the end of the view}


      {Creation/Destruction}
        FUNCTION  {TView.}CREATE(object: TObject; heap: THeap; itsPanel: TPanel; itsExtent: LRect;
            itsPrintManager: TPrintManager; itsDfltMargins: LRect; itsFitPagesPerfectly:BOOLEAN;
            itsRes: Point; isMainView: BOOLEAN): TView;
       {PROCEDURE  TView. Free;}

      {Attributes}
        PROCEDURE {TView.}BeInPanel(panel: TPanel);
        PROCEDURE {TView.}GetStdScroll(VAR deltaLStd: LPoint);
        FUNCTION  {TView.}MaxPageToPrint: LONGINT;

      {Pagination}
        PROCEDURE {TView.}AddStripOfPages(vhs: VHSelect); DEFAULT;
        FUNCTION  {TView.}ForceBreakAt(vhs: VHSelect; precedingLocation: LONGINT;
            proposedLocation: LONGINT): LONGINT;
        PROCEDURE {TView.}RedoBreaks; DEFAULT;
        PROCEDURE {TView.}RemapManualBreaks(
             FUNCTION NewBreakLocation(vhs: VHSelect; oldBreak: LONGINT): LONGINT);

      {Cross-Panel Drag}
        FUNCTION  {TView.}DoReceive(selection: TSelection; lPtInView: LPoint): BOOLEAN;

      {Direct Display Permission -- per panel}
        FUNCTION  {TView.}OKToDrawIn(lRectInView: LRect): BOOLEAN;  {Default is FALSE; app can override}

      {Cursor tracking - per pane}
        {FUNCTION  TView. CursorAt(mouseLPt: LPoint): TCursorNumber;}

      {Resizing}
       {PROCEDURE  TView. Resize(newExtent: LRect);}
        PROCEDURE {TView.}SetMinViewSize(VAR minLRect: LRect);

      {Clipboard Setup}
        PROCEDURE {TView.}CreateUniversalText;

      {Variables embedded in text}
        PROCEDURE {TView.}SetFunctionValue(keyword: S255; VAR itsValue: S255);

      {Selecting}
        FUNCTION  {TView.}NoSelection: TSelection;
        END;


    TPaginatedView = SUBCLASS OF TView

      {Variables}
        unpaginatedView:    TView;             {the unpaginated view from whence this derives}

        pageSize:   ARRAY[VHSelect] OF LONGINT;  {width/height of a page's representation on the screen,
                                                  in the same metrics as the regular view -- could still
                                                  differ from actual screen space a/c screen horiz/vertical
                                                  resolution}

        workingInMargins:   BOOLEAN;

      {Creation/Destruction}
        FUNCTION  {TPaginatedView.}CREATE(object: TObject; heap: THeap;
                                          itsUnpaginatedView: TView): TPaginatedView;

       {PROCEDURE  TPaginatedView. AddStripOfPages(vhs: VHSelect);}
        PROCEDURE {TPaginatedView.}AdornPageOnScreen;
       {FUNCTION   TPaginatedView. CursorAt(mouseLPt: LPoint): TCursorNumber;}
        PROCEDURE {TPaginatedView.}DepagifyLPoint(pagLPt: LPoint; VAR unPagLPt: LPoint);
        PROCEDURE {TPaginatedView.}DoOnPages(focusOnInterior: BOOLEAN;  PROCEDURE DoOnAPage);
       {PROCEDURE  TPaginatedView. Draw;}
       {PROCEDURE  TPaginatedView. MouseTrack(mPhase: TPhase; mouseLPt: LPoint);}
        PROCEDURE {TPaginatedView.}PagifyLPoint(unPagLPt: LPoint; VAR pagLPt: LPoint);
       {PROCEDURE  TPaginatedView. ReactToPrinterChange;}
       {PROCEDURE  TPaginatedView. RedoBreaks;}

      END;


    TPageView = SUBCLASS OF TView

        FUNCTION  {TPageView.}CREATE(object: TObject; heap: THeap;
                                     itsPrintManager: TPrintManager): TPageView;
       {PROCEDURE  TPageView. Draw;}
        END;


    THeading = SUBCLASS OF TImage      {a header/footer image}

        printManager:           TPrintManager;
        pageAlignment:          TPageAlignment;
        offsetFromAlignment:    LPoint;

        oddOnly:        BOOLEAN;   {to restrict printing only to odd-numbered pages}
        evenOnly:       BOOLEAN;   { ditto even }
        minPage:        LONGINT;   {minimum page number to want this heading}
        maxPage:        LONGINT;   {maximum page number to want it}

      {Creation/Destruction}
        FUNCTION  {THeading.}CREATE(object: TObject; heap: THeap; itsPrintManager: TPrintManager;
                                    itsExtentLRect: LRect; itsPageAlignment: TPageAlignment;
                                    itsOffsetFromAlignment: LPoint): THeading;

      {Attributes}
        PROCEDURE {THeading.}ChangePageAlignment(newPageAlignment: TPageAlignment);

      {Selective Use}
        FUNCTION  {THeading.}ShouldDraw(pageNumber: LONGINT): BOOLEAN;
        FUNCTION  {THeading.}ShouldFrame: BOOLEAN; DEFAULT;

      {Display}
        PROCEDURE {THeading.}AdjustForPage(pageNumber: LONGINT; editing: BOOLEAN); DEFAULT;
        PROCEDURE {THeading.}LocateOnPage(editing: BOOLEAN);
       {PROCEDURE  THeading. Draw;}
        END;


    TPrintManager = SUBCLASS OF TObject
        view:               TView;
        pageView:           TView;

        breaks:             ARRAY[VHSelect] OF TArray; {of LONGINT}
                                    {pagebreak representation: absolute value gives location; negative
                                    signifies manual break; nonnegative signifies automatic pagebreak}

        pageMargins:        LRect;     {in view resolution; top and left are > 0 , bot & right < 0}

        headings:           TList; {OF THeading}

        canEditPages:       BOOLEAN;
        layoutDialogBox:    TDialogBox;

        frameBody:          BOOLEAN;
        paperLRect:         LRect;
        printableLRect:     LRect;

        contentLRect:       LRect;  {the inner rectangle into which chunks of view are stuffed}

        printerMetrics:     TPrinterMetrics;    {physical properties of the printer}

        pageRiseDirection:  VHSelect;
             {if 'h', it means that page numbers rise from left to right fastest;
              if 'v', it means that page numbers rise from top to bottom fastest;
              default value is 'h'}

        FUNCTION  {TPrintManager.}CREATE(object: TObject; heap: THeap): TPrintManager;
        PROCEDURE {TPrintManager.}Init(itsMainView: TView; itsDfltMargins: LRect);
       {PROCEDURE  TPrintmanager. Free;}

        PROCEDURE {TPrintManager.}AddStripOfPages(vhs: VHSelect);
        PROCEDURE {TPrintManager.}ChangeMargins(margins: LRect);
        PROCEDURE {TPrintManager.}ClearPageBreaks(automatic: BOOLEAN);
        PROCEDURE {TPrintManager.}DrawBreaks(manualOnly:  BOOLEAN);
        PROCEDURE {TPrintManager.}DrawOneBreak(pageBreak: LONGINT; vhs: vhSelect);
        PROCEDURE {TPrintManager.}DrawPage;
        PROCEDURE {TPrintManager.}EnterPageEditing;
        PROCEDURE {TPrintManager.}GetPageLimits(pageNumber: LONGINT; VAR viewLRect: LRect);
        FUNCTION  {TPrintManager.}NewPaginatedView(object: TObject): TPaginatedView;
        FUNCTION  {TPrintManager.}NewPageView(object: TObject): TView;
        FUNCTION  {TPrintManager.}PageWith(VAR lPtInView: LPoint; VAR strip: Point): LONGINT;
        PROCEDURE {TPrintManager.}Print(printPref: TPrReserve);
        PROCEDURE {TPrintManager.}ReactToPrinterChange;
        PROCEDURE {TPrintManager.}RedoBreaks;
        PROCEDURE {TPrintManager.}SetBreak(vhs: VHSelect; where: LONGINT; isAutomatic: BOOLEAN);
        PROCEDURE {TPrintManager.}SetDfltHeadings; DEFAULT;
        PROCEDURE {TPrintManager.}SkipPage(pageNumber: LONGINT);

    END; {TPrintManager definition}


    TSelection = SUBCLASS OF TObject

      {Variables}
        window:         TWindow;            {the window in which it was made}
        panel:          TPanel;             {the panel in which it was made}
        view:           TView;              {the view or subview of panel in which it was made}
        kind:           INTEGER;            {0 means no selection, rest of codes are defined by view}
        anchorLPt:      LPoint;             {the place the mouse went down (view-relative)}
        currLPt:        LPoint;             {the place the mouse was last tracked}
        boundLRect:     LRect;              {bounding box of the selection} {+++LSR+++}
        coSelection:    TSelection;         {if non-NIL, a selection to forward unimplemented methods to}
        canCrossPanels: BOOLEAN;            {:=TRUE in MousePress/FALSE in MouseRelease for cross-panel drag}

      {Creation/Destruction}
        FUNCTION  {TSelection.}CREATE(object: TObject; heap: THeap; itsView: TView; itsKind: INTEGER;
                                   itsAnchorLPt: LPoint): TSelection;
       {FUNCTION   TSelection. Clone(heap: THeap): TObject;}    {clones coSelection}
        FUNCTION  {TSelection.}FreedAndReplacedBy(selection: TSelection): TSelection;

      {Attributes}
        PROCEDURE {TSelection.}GetHysteresis(VAR hysterPt: Point); DEFAULT; {rtns a delta from orig panel pt}
        PROCEDURE {TSelection.}HaveView(view: TView);

      {Files}
        PROCEDURE {TSelection.}MarkChanged; DEFAULT;                        {Increment change counters}

      {Command Dispatch}
        FUNCTION  {TSelection.}CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN; DEFAULT;
        PROCEDURE {TSelection.}CantDoCmd(cmdNumber: TCmdNumber); DEFAULT;
        PROCEDURE {TSelection.}CantDoIt; DEFAULT;
        PROCEDURE {TSelection.}DoKey(ascii: CHAR; keycap: Byte; shiftKey, appleKey, optionKey: BOOLEAN);
        FUNCTION  {TSelection.}NewCommand(cmdNumber: TCmdNumber): TCommand; DEFAULT;
        PROCEDURE {TSelection.}PerformCommand(command: TCommand; cmdPhase: TCmdPhase); DEFAULT;

      {Idle}
        PROCEDURE {TSelection.}IdleBegin(centiSeconds: LONGINT); DEFAULT;
        PROCEDURE {TSelection.}IdleContinue(centiSeconds: LONGINT); DEFAULT;
        PROCEDURE {TSelection.}IdleEnd(centiSeconds: LONGINT); DEFAULT;

      {Editing -- to be overridden by applications}
        PROCEDURE {TSelection.}KeyBack(fWord: BOOLEAN); DEFAULT;
        PROCEDURE {TSelection.}KeyChar(ch: CHAR); DEFAULT;
        PROCEDURE {TSelection.}KeyClear; DEFAULT;
        PROCEDURE {TSelection.}KeyEnter(dh, dv: INTEGER); DEFAULT;
        PROCEDURE {TSelection.}KeyForward(fWord: BOOLEAN); DEFAULT;
        PROCEDURE {TSelection.}KeyPause; DEFAULT; {Pause in typing}
        PROCEDURE {TSelection.}KeyReturn; DEFAULT;
        PROCEDURE {TSelection.}KeyTab(fBackward: BOOLEAN); DEFAULT;
        PROCEDURE {TSelection.}SelectParagraphs;

      {Drawing -- per pane}
        PROCEDURE {TSelection.}Highlight(highTransit: THighTransit); DEFAULT;

      {Selecting}
        PROCEDURE {TSelection.}DeSelect; DEFAULT;
        PROCEDURE {TSelection.}DrawGhost; DEFAULT;
        PROCEDURE {TSelection.}MousePress(mouseLPt: LPoint); DEFAULT;
        PROCEDURE {TSelection.}MouseMove(mouseLPt: LPoint); DEFAULT;
        PROCEDURE {TSelection.}MouseRelease; DEFAULT;
        PROCEDURE {TSelection.}MoveBackToAnchor; DEFAULT;   {called when cross-panel drag has been refused}

      {Undo Maintenance}
        PROCEDURE {TSelection.}Restore; DEFAULT;
        PROCEDURE {TSelection.}Save; DEFAULT;

      {Scroll into view}
        PROCEDURE {TSelection.}Reveal(asMuchAsPossible: BOOLEAN); DEFAULT;

        END;


    TWindow = SUBCLASS OF TArea

      {Variables}
        panels:         TList {OF TPanel};          {The panels in the window (at least one)}
        panelTree:      TArea;                      {no panels: NIL, one panel: that; else a TBranchArea}
        dialogBox:      TDialogBox;                 {NIL if SELF IS a dialog box window}
        selectPanel:    TPanel;                     {The panel with the active selection}
        undoSelPanel:   TPanel;                     {The selectPanel during the last command}
        clickPanel:     TPanel;                     {The panel in which the user last clicked in a pane}
        undoClickPanel: TPanel;                     {The clickPanel during the last command}
        selectWindow:   TWindow;                    {The window with the active selection -- either
                                                       SELF or its Dialogbox }
        undoSelWindow:  TWindow;                    {the selectWindow during the last command}
        wmgrID:         TWindowID;                  {ORD(Pointer to the Window Manager's GrafPort)}
        isResizable:    BOOLEAN;                    {Is there a Resize Box}
        believeWmgr:    BOOLEAN;                    {TRUE iff the Toolkit should believe the window
                                                        manager's idea of the size of the window;
                                                        this will be FALSE (for example) if we create
                                                        the window object before the window is put on
                                                        the screen.}
        maxInnerSize:   Point;                      {The window size the user explicitly set with grow
                                                        icon}
        changes:        LONGINT;                    {How many changes since the last save}
        lastCmd:        TCommand;                   {last undoable command object}
        printerMetrics: TPrinterMetrics;            {Properties of the printer currently formatted for}
        pgSzOK:         BOOLEAN;                    {Whether to allow user-defined page-sizes in Fmt For
                                                        Printer dialog}
        pgRgOK:         BOOLEAN;                    {Whether page-range dialog should be enabled in PRINT...
                                                         dialog -- normally TRUE}
        panelToPrint:   TPanel;                     {NB: IF >1 printable panel in window, choice should be
                                                     made by providing separate menu items}
        objectToFree:   TObject;                    {used to stash a reference to an object which should be
                                                        freed at end of event loop}
      {Creation/Destruction}
        FUNCTION  {TWindow.}CREATE(object: TObject; heap: THeap; itsWmgrID: TWindowID; itsResizability
                                  : BOOLEAN): TWindow;
       {PROCEDURE  TWindow. Free;}

      {$IFC fDbgABC}
      {Debugging}
        PROCEDURE {TWindow.}ToggleFlag(VAR flag: BOOLEAN); DEFAULT; {Toggle a debug flag in a menu}
       {$ENDC}

      {Attributes}
       {PROCEDURE  TWindow. GetMinExtent(VAR minExtent: Point; windowIsResizingIt: BOOLEAN);}
        PROCEDURE {TWindow.}GetTitle(VAR title: S255); {Get the window title}
        FUNCTION  {TWindow.}IsActive: BOOLEAN;
        FUNCTION  {TWindow.}IsVisible: BOOLEAN;
        PROCEDURE {TWindow.}SetWmgrId(itsWmgrId: TWindowID); {Also sets port fields of panes}

      {Buttoning}
        PROCEDURE {TWindow.}DownEventAt(mousePt: Point); DEFAULT;
       {FUNCTION   TWindow. DownAt(mousePt: Point): BOOLEAN;}

      {Dialog Box affairs}
        PROCEDURE {TWindow.}PutUpDialogBox(dialogBox: TDialogBox); DEFAULT;
        PROCEDURE {TWindow.}TakeDownDialogBox; DEFAULT;

      {Display}
       {PROCEDURE  TWindow. Focus;}
       {PROCEDURE  TWindow. Frame;}
        PROCEDURE {TWindow.}Highlight(highTransit: THighTransit); DEFAULT;
       {PROCEDURE  TWindow. Refresh(rActions: TActions; highTransit: THighTransit);}
        PROCEDURE {TWindow.}Update(doHilite: BOOLEAN); DEFAULT;

      {Resizing}
        PROCEDURE {TWindow.}DownInSizeBox(mousePt: Point); DEFAULT;
        PROCEDURE {TWindow.}Resize(moving: BOOLEAN); DEFAULT; {Reset size from portRect size (w. adjustments)}
        PROCEDURE {TWindow.}ResizeTo(newSize: Point); DEFAULT; {callable from application}

      {Command Dispatch and Menus}
        FUNCTION  {TWindow.}CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN; DEFAULT;
        FUNCTION  {TWindow.}CanDoStdCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN; DEFAULT;
        PROCEDURE {TWindow.}CommitLast; DEFAULT;
        PROCEDURE {TWindow.}DoCommand(cmdNumber: TCmdNumber); DEFAULT;
        PROCEDURE {TWindow.}LoadMenuBar; DEFAULT;
        PROCEDURE {TWindow.}MenuEventAt(mousePt: Point); DEFAULT;
        FUNCTION  {TWindow.}NewCommand(cmdNumber: TCmdNumber): TCommand; DEFAULT;
        FUNCTION  {TWindow.}NewStdCommand(cmdNumber: TCmdNumber): TCommand;
        PROCEDURE {TWindow.}PerformCommand(newCommand: TCommand);
        PROCEDURE {TWindow.}PerformLast(cmdPhase: TCmdPhase);
        PROCEDURE {TWindow.}SaveCommand(command: TCommand); {NOTE: do not use the arg after calling this;
                                                             use window.lastCmd instead}
        PROCEDURE {TWindow.}SetupMenus;
        PROCEDURE {TWindow.}UndoLast;
        FUNCTION  {TWindow.}WantMenu(menuID: INTEGER; inClipboard: BOOLEAN): BOOLEAN;

      {Miscellaneous}
        PROCEDURE {TWindow.}AbortEvent; {only QuickPort should override this}

      {Selection Maintenance during commands}
        PROCEDURE {TWindow.}RestoreSelection;
        PROCEDURE {TWindow.}RevealSelection(asMuchAsPossible, doHilite: BOOLEAN);
        PROCEDURE {TWindow.}SaveSelection;

      {Desktop}
            {The following 2 methods assume that we are focused on the window before they are called}
        PROCEDURE {TWindow.}Activate;
        PROCEDURE {TWindow.}Deactivate;
        PROCEDURE {TWindow.}BlankStationery; DEFAULT;
        PROCEDURE {TWindow.}StashPicture(highTransit: THighTransit);

{$IFC LibraryVersion > 20}
      {Desktop Manager Communication}
        PROCEDURE {TWindow.}NameToPrefix(VAR error, offset: INTEGER; VAR name, prefix: TFilePath);
        PROCEDURE {TWindow.}PrefixToName(VAR error, offset: INTEGER; VAR prefix, name: TFilePath);

               (*Convert between OS prefix (ie., '-volname-{DxxxTyyy}' and an icon pathname (ie.,
                    '<diskname<foldername1<foldername2<...<iconname').  If an error is returned,
                    offset will point just beyond the part of the name that caused the error, e.g.
                    if '<office<forms<expenses' returns erDuplicateName and the offset is 14
                    (pointing to the third '<') then there is more than one 'forms' folder on the
                    office disk.  Error constants are defined above.

                 NOTE: these methods will likely take a while to execute, since the Desktop Manager
                 must be swapped in to process the request.  Therefore, you should try to minimize the
                 number of times these are called.*)
{$ENDC}

      {Foci of Attention}
        FUNCTION  {TWindow.}CursorFeedback: TCursorNumber;
        PROCEDURE {TWindow.}PickStdCursor;

      {Printing}
        PROCEDURE {TWindow.}AcceptNewPrintingInfo(document: TDocManager; prReserve: TPrReserve);
        PROCEDURE {TWindow.}ChkPrMismatch;
        PROCEDURE {TWindow.}GetPrinterMetrics;
        PROCEDURE {TWindow.}Print(panel: TPanel; nixPgRange: BOOLEAN; nixWholeDialog: BOOLEAN);

      {Filtering}
        PROCEDURE {TWindow.}EachActualPart(PROCEDURE DoToObject(filteredObj: TObject)); {For app to implement}
        PROCEDURE {TWindow.}EachVirtualPart(PROCEDURE DoToObject(filteredObj: TObject));
        PROCEDURE {TWindow.}FilterAndDo(actualObj: TObject; PROCEDURE DoToObject(filteredObj: TObject));
        PROCEDURE {TWindow.}FilterDispatch(actualObj: TObject; image: TImage;
                                           PROCEDURE DoToObject(filteredObj: TObject));

      {Idle}
        PROCEDURE {TWindow.}IdleBegin(centiSeconds: LONGINT);
        PROCEDURE {TWindow.}IdleContinue(centiSeconds: LONGINT);
        PROCEDURE {TWindow.}IdleEnd(centiSeconds: LONGINT);

        END;


    TDialogBox = SUBCLASS OF TWindow

      {Variables}
        keyResponse:                TDiResponse;
        menuResponse:               TDiResponse;
        downInMainWindowResponse:   TDiResponse;

        freeOnDismissal:            BOOLEAN;

      {Creation/Destruction}
        FUNCTION  {TDialogBox.}CREATE(object: TObject; heap: THeap; itsResizability: BOOLEAN;
                                      itsHeight: INTEGER;  itsKeyResponse, itsMenuResponse,
                                      itsDownInMainWindowResponse: TDiResponse): TDialogBox;

      {Attributes}
       {PROCEDURE  TDialogBox. GetMinExtent(VAR minExtent: Point; windowIsResizingIt: BOOLEAN);}

      {Display}
        PROCEDURE {TDialogBox.}Appear;
        PROCEDURE {TDialogBox.}BeDismissed; DEFAULT;
        PROCEDURE {TDialogBox.}Disappear; DEFAULT;

        END;


    TBand = SUBCLASS OF TArea

      {Variables}
        window:         TWindow;
        panes:          TList {OF TPane};
        panel:          TPanel;
        scroller:       TScroller;                  {the scroll box}
        scrollDir:      VHSelect;                   {v if a row of panes with a vertical bar,
                                                     h if a column of panes with a horizontal bar}

      {Creation/Destruction}
        FUNCTION  {TBand.}CREATE(object: TObject; heap: THeap; itsPanel: TPanel; itsInnerRect: Rect;
                              itsScroller: TScroller; itsDir: VHSelect): TBand;
       {PROCEDURE  TBand. Free;}

      {Attributes}
        FUNCTION  {TBand.}ViewLCd: LONGINT;

      {Scrolling}
        PROCEDURE {TBand.}OffsetPanes(deltaLPt: LPoint);
        PROCEDURE {TBand.}ScrollBy(deltaLCd: LONGINT);
                        {A TBand can only scroll in one direction; this also moves the thumb}
        PROCEDURE {TBand.}ScrollStep(icon: TEnumIcons; deltaLStd: LONGINT);
        PROCEDURE {TBand.}ScrollTo(viewLCd: LONGINT);
        FUNCTION  {TBand.}ThumbPos: INTEGER;
        PROCEDURE {TBand.}ThumbTo(newThumbPos: INTEGER);


      {Resizing}
       {PROCEDURE  TBand. ResizeOutside(newOuterRect: Rect);}
        PROCEDURE {TBand.}ResizePanes(newViewLCd: LONGINT);

        END;


    TSideBand = SUBCLASS OF TBand
      {Fields}
        topOrLeft:  BOOLEAN;
        {NOTE: SELF.scroller is NIL}

        FUNCTION  {TSideBand.}CREATE(object: TObject; heap: THeap; itsPanel: TPanel; itsInnerRect: Rect;
                           itsDir: VHSelect; itsTopOrLeft: BOOLEAN;
                           itsViewLCd: LONGINT): TSideBand;

      {Attributes}
        FUNCTION  {TSideBand.}CoBand: TBand;
            {returns the band adjacent to SELF}
        END;


    TPanel = SUBCLASS OF TArea

      {Variables}                                    {panes are listed row-wise in the panes list}
        window:             TWindow;
        panes:              TList {OF TPane};
        currentView:        TView;                          {The view seen through SELF: normal or paginated}
        view:               TView;                          {The unpaginated view seen through SELF }
        paginatedView:      TPaginatedView;                 {NIL if not previewing margins}
        selection:          TSelection;                     {the current selection}
        undoSelection:      TSelection;                     {the selection to be restored for an undo/redo}
        bands:              ARRAY[VHSelect] OF TList;       {redundant... bands[v].at(1) = top row of panes}
        scrollBars:         ARRAY[VHSelect] OF TScrollBar;  {scrollBars[(v,h)]--the (vert,horiz) scroll bars}
        abilities:          ARRAY[VHSelect] OF TAbilities;  {[aBar, aScroll, aSplit, aResize]}
        minInnerDiagonal:   Point;
        resizeBranch:       TBranchArea;                    {the branch that my botRight resizes, or NIL}
        zoomed:             BOOLEAN;
        zoomFactor:         TScaler;
        previewMode:        TPreviewMode;
        lastClick:          RECORD                          {describes the pane the user last clicked}
                            CASE gotPane: BOOLEAN OF
                                TRUE: (clickPane: TPane);   {the last pane the user clicked on}
                                FALSE: (clickPt: Point);    {the innerRect.topLeft of lastClick.pane,
                                                                in the case where the lastClick.pane was
                                                                deleted}
                                END;
        contentRect:        Rect;                           {part of the innerRect not containing side bands}
        tlSideBandSize:     Point;  {size of topLeft side bands}
        brSideBandSize:     Point;
            {NOTE: The sideband sizes refer to the size of the innerRect of the side band;
                        therefore a size of -1 means there is no side band on that side}
        deletedSplits:      TArray; {If NIL, don't remember splits that go away because the panel
                                        shrinks.  Otherwise, this should be a TArray with recordBytes
                                        2.  This is initialized to NIL in TPanel.CREATE; clients can
                                        allocate an array and change the field if they desire.}

      {Creation/Destruction}
        FUNCTION  {TPanel.}CREATE(object: TObject; heap: THeap; itsWindow: TWindow;
                              minHeight, minWidth: INTEGER; itsVAbilities, itsHAbilities: TAbilities): TPanel;
       {PROCEDURE  TPanel. Free;}
        PROCEDURE {TPanel.}HaveView(view: TView);
        FUNCTION  {TPanel.}NewView(object: TObject; itsExtent: LRect; itsPrintManager: TPrintManager;
                                   itsDfltMargins: LRect; itsFitPerfectlyOnPages: BOOLEAN): TView;
        FUNCTION  {TPanel.}NewStatusView(object: TObject; itsExtent: LRect): TView;

      {Attributes}
        PROCEDURE {TPanel.}ComputeContentRect;
        PROCEDURE {TPanel.}DecideAboutBars(newOuterRect: Rect); {Decide if to have scroll bars & resize icon}
       {PROCEDURE  TPanel. GetMinExtent(VAR minExtent: Point; windowIsResizingIt: BOOLEAN);}
       {PROCEDURE  TPanel. GetBorder(VAR border: Rect);}
        FUNCTION  {TPanel.}FindBranchThatIsResized: TBranchArea;
        FUNCTION  {TPanel.}PaneShowing(anLRect: LRect): TPane;  {Returns first pane showing an part
                                                                    of anLRect, else NIL}
        PROCEDURE {TPanel.}SetInnerRect(newInnerRect: Rect); OVERRIDE;
        PROCEDURE {TPanel.}SetOuterRect(newOuterRect: Rect); OVERRIDE;

      {Paneling the window}
        FUNCTION  {TPanel.}Divide(vhs: VHSelect;
                              fromEdgeOfPanel: INTEGER; units: TUnitsFromEdge;
                              whoCanResizeIt: TResizability;
                              minSize: INTEGER; itsVAbilities, itsHAbilities: TAbilities): TPanel;
        PROCEDURE {TPanel.}Insert(panel: TPanel; vhs: VHSelect;
                              fromEdgeOfPanel: INTEGER; units: TUnitsFromEdge;
                              whoCanResizeIt: TResizability);           {Resizes both to share my space}
        PROCEDURE {TPanel.}Remove;                  {Does not Free SELF; Expands sibling to fill my space}
        PROCEDURE {TPanel.}Replace(panel: TPanel);  {Does not Free SELF; Resizes panel to fit my old space}

      {Buttoning}
       {FUNCTION   TPanel. DownAt(mousePt: Point): BOOLEAN;}
        PROCEDURE {TPanel.}DownInSizeBox(mousePt: Point);
        PROCEDURE {TPanel.}HitScroller(vhs: VHSelect; mousePt: Point; scroller: TScroller; icon: TEnumIcons);

      {Selecting}
        PROCEDURE {TPanel.}BeginSelection;
        PROCEDURE {TPanel.}BeSelectPanel(inSelectWindow: BOOLEAN);
 (*     FUNCTION  {TPanel.}NoSelection: TSelection; *)

      {Cursor tracking}
        FUNCTION  {TPanel.}CursorAt(mousePt: Point): TCursorNumber;

      {Display}
       {PROCEDURE  TPanel. Frame;}
        PROCEDURE {TPanel.}Highlight(selection: TSelection; highTransit: THighTransit);
                            { this highlights the selection on all pads }
        PROCEDURE {TPanel.}Invalidate;
                            { this invalidates the whole panel }
        PROCEDURE {TPanel.}InvalLRect(lRectInView: LRect);
                            { this invalidates the given LRect on all pads }
        FUNCTION  {TPanel.}OKToDrawIn(lRectInView: LRect): BOOLEAN;
                            { If this returns FALSE, commands must InvalLRect or XOR, not Draw or Erase }
        PROCEDURE {TPanel.}OnAllPadsDo(PROCEDURE DoOnThePad);
       {PROCEDURE  TPanel. Refresh(rActions: TActions; highTransit: THighTransit);}
        PROCEDURE {TPanel.}Rescroll;
        PROCEDURE {TPanel.}SetZoomFactor(zoomNumerator, zoomDenominator: Point);

      {Page-Previewing}
        PROCEDURE {TPanel.}Preview(newMode: TPreviewMode);

      {Printing}
        PROCEDURE {TPanel.}PrintView(printPref: TPrReserve);

      {Scrolling}
        PROCEDURE {TPanel.}AutoScroll(mousePt: Point);
        PROCEDURE {TPanel.}DoScrolling(inArea: TArea; itsPane: TPane;
                                hOk, vOk: BOOLEAN; VAR deltaLPt: LPoint);
                    {inArea must be a TBand or a TPane; if a TPane then inArea=itsPane;
                     if a TBand then itsPane is any one of the band's panes}
        FUNCTION  {TPanel.}PaneToScroll(VAR anLRect: LRect; hMinToSee, vMinToSee: INTEGER): TPane;
                    {Returns the pane to scroll for showing the minimum desired part ofLRect;
                        if that part is already showing, it returns NIL;
                    NOTE: anLRect is NOT changed}
        PROCEDURE {TPanel.}RevealLRect(VAR anLRect: LRect; hMinToSee, vMinToSee: INTEGER);
                    {Show at least the desired part of the LRect in the pane returned by PaneToShow;
                    NOTE: anLRect is NOT changed}

      {Splitting}
        PROCEDURE {TPanel.}CleanUpPanes(deleteList: TList);
        PROCEDURE {TPanel.}MakeBand(vhs: VHSelect; scroller, prevScroller: TScroller);
        PROCEDURE {TPanel.}MoveSplitBefore(scroller: TScroller; newSkwrCd: INTEGER);
        FUNCTION  {TPanel.}NewBand(heap: THeap; myInnerRect: Rect;
                                   scroller: TScroller; vhs: VHSelect): TBand;
        FUNCTION  {TPanel.}NewPane(heap: THeap; innerRect: Rect; viewedLRect: LRect): TPane;
        PROCEDURE {TPanel.}RemakePanes;
        PROCEDURE {TPanel.}RememberSplit(vhs: VHSelect; atCd: INTEGER);
        PROCEDURE {TPanel.}RepaneOrthogonalBands(vhs: VHSelect);
        PROCEDURE {TPanel.}RestoreSplits;

    {Side Bands}
        PROCEDURE {TPanel.}ShowSideBand(vhs: VHSelect; topOrLeft: BOOLEAN; size: INTEGER; viewLCd: LONGINT);
        PROCEDURE {TPanel.}SideBandRect(vhs: VHSelect; topOrLeft: BOOLEAN; VAR bandRect: Rect);
                {returns the innerRect of the side band, given SELF.contentRect}

      {Resizing}
        PROCEDURE {TPanel.}ResizeBand(vhs: VHSelect; band: TBand; newViewLCd: LONGINT;
                                        fInvalidate: BOOLEAN);
       {PROCEDURE  TPanel. ResizeInside(newInnerRect: Rect);}
       {PROCEDURE  TPanel. ResizeOutside(newOuterRect: Rect);}

        END;


    TPane = SUBCLASS OF TPad

      {Variables}
        currentView:    TView;                      {The view that is currently}
        panel:          TPanel;                     {The containing panel}

      {Creation/Destruction}
        FUNCTION  {TPane.}CREATE(object: TObject; heap: THeap; itsPanel: TPanel; itsInnerRect: Rect;
                                 itsViewedLRect: LRect): TPane;
        PROCEDURE {TPane.}HaveView(view: TView);

      {Attributes}
        PROCEDURE {TPane.}GetScrollLimits(VAR viewedLRect, scrollableLRect: LRect);
       {PROCEDURE  TPane. SetZoomFactor(zoomNumerator, zoomDenominator: Point);}

      {Selecting}
        PROCEDURE {TPane.}MouseTrack(mPhase: TMousePhase; mousePt: Point);
                            {assumes mousePt is in the pane's innerRect}

      {Cursor tracking}
        FUNCTION  {TPane.}CursorAt(mousePt: Point): TCursorNumber;

      {Display}
       {PROCEDURE  TPane. Refresh(rActions: TActions; highTransit: THighTransit);}

      {Resizing}
        PROCEDURE {TPane.}Resize(newInnerRect: Rect; vhs: VHSelect);

      {Scrolling}
        PROCEDURE {TPane.}ScrollBy(VAR deltaLPt: LPoint);
                        {NOTE: deltaLPt is NOT changed; also moves the thumb(s)}
        PROCEDURE {TPane.}ScrollToReveal(VAR anLRect: LRect; hMinToSee, vMinToSee: INTEGER);
                        {NOTE: anLRect is NOT changed}
        END;


    TMarginPad = SUBCLASS OF TPad

      {Variables}
        view:               TView;    {The view seen on the BODY of this page}
        pageNumber:         LONGINT;
        bodyPad:            TBodyPad;

      {Creation/Destruction}
        FUNCTION {TMarginPad.}CREATE(object: TObject; heap: THeap): TMarginPad;

        PROCEDURE {TMarginPad.}Rework(itsView: TView; itsOrigin: Point; itsRes: Point;
                       itsPageNumber: LONGINT; itsZoomFactor: TScaler; itsPort: GrafPtr);
        PROCEDURE {TMarginPad.}SetForPage(itsPageNumber: LONGINT; itsOrigin: Point);

      {Display}
       {PROCEDURE  TMarginPad. Focus;}

      {Process termination and Debugging Assistance}
       {PROCEDURE TMarginPad. Crash;}
       {FUNCTION  TMarginPad. BindHeap(activeVsClip, doBind: BOOLEAN): THeap;}

        END;


    TBodyPad = SUBCLASS OF TPad

      {Variables}
        marginPad:   TMarginPad; {the page shell whose body I am}
        nonNullBody:  Rect;  {the portion of the pad in the range of the mapped view;
          BodyPad.innerRect = nonNullBody unless manual pagebreak or end-of-view forces
          a shortage of view to map into entire inner rect} {someday make this comment comprehensible}

      {Creation/Destruction}
        FUNCTION  {TBodyPad.}CREATE(object: TObject; heap: THeap; itsMarginPad: TMarginPad): TBodyPad;
        PROCEDURE {TBodyPad.}Recompute;
        PROCEDURE {TBodyPad.}SetForPage(itsPageNumber: LONGINT);

      {Display}
       {PROCEDURE  TBodyPad. Focus;}

      END;


    TScroller = SUBCLASS OF TObject

      {Variables}
        scrollBar:      TScrollBar;                     {the scroll bar of which it is part}
        band:           TBand;                          {the object that can respond to scroll events}
        sBoxID:         TSBoxID;                        {the scroll-bar-library representation}

      {Creation/Destruction}
        FUNCTION  {TScroller.}CREATE(object: TObject; heap: THeap; itsScrollBar: TScrollBar; itsId: TSBoxID)
                                    : TScroller;
       {PROCEDURE  TScroller. Free;}

      {Attributes}
        PROCEDURE {TScroller.}GetSize(VAR boxRect: Rect);
        FUNCTION  {TScroller.}ScrollDir: VHSelect;
        PROCEDURE {TScroller.}SetSize(ownerRect: Rect);
        FUNCTION  {TScroller.}ThumbRange: INTEGER;

      {Buttoning}
        PROCEDURE {TScroller.}TrackSkewer(mousePt: Point; VAR newSkwrCd: INTEGER;
                                          VAR scroller, prevScroller: TScroller);
        PROCEDURE {TScroller.}TrackThumb(mousePt: Point; VAR oldThumbPos, newThumbPos: INTEGER);

      {Display}
        PROCEDURE {TScroller.}FillIcon(icon: TEnumIcons; fBlack: BOOLEAN);
        PROCEDURE {TScroller.}MoveThumb(newThumbPos: INTEGER);

      {Splitting}
        PROCEDURE {TScroller.}ResplitAt(newSkwrCd: INTEGER; prevScroller: TScroller);
        PROCEDURE {TScroller.}SplitAt(newSkwrCd: INTEGER; VAR nextScroller: TScroller);

        END;


    TScrollBar = SUBCLASS OF TObject

      {Variables}
        firstBox:   TScroller;                          {the rest are found via the SB Library}
        isVisible:  BOOLEAN;                            {TRUE iff this scroll bar should be drawn}

      {Creation/Destruction}
        FUNCTION  {TScrollBar.}CREATE(object: TObject; heap: THeap; vhs: VHSelect; outerRect: Rect;
                                   itsVisibility: BOOLEAN): TScrollBar;
        PROCEDURE {TScrollBar.}ChangeVisibility(needsBothBars: BOOLEAN;
                                                bandOuterRect: Rect; itsAbilities: TAbilities);

      {Buttoning}
        FUNCTION  {TScrollBar.}DownAt(mousePt: Point; VAR scroller: TScroller; VAR icon: TEnumIcons): BOOLEAN;

      {Display}
        PROCEDURE {TScrollBar.}Draw;
        PROCEDURE {TScrollBar.}Erase;

        END;


    TMenuBar = SUBCLASS OF TObject {only one instance exists (menuBar)}

      {Variables}
        isLoaded:       ARRAY [1..maxMenus] OF BOOLEAN;     {TRUE iff the i'th menu has been inserted}
        mapping:        TArray {OF TWmgrCmd};               {maps command number to menu & item indices}
        numMenus:       INTEGER;                            {how many menus}
        numCommands:    INTEGER;                            {how many commands in all menus together}

      {Creation/Destruction}
        FUNCTION  {TMenuBar.}CREATE(object: TObject; heap: THeap; itsScanner: TFileScanner): TMenuBar;

      {Attributes}
        PROCEDURE {TMenuBar.}Check(cmdNumber: TCmdNumber; checked: BOOLEAN);
        PROCEDURE {TMenuBar.}Enable(cmdNumber: TCmdNumber; canBeChosen: BOOLEAN);
        PROCEDURE {TMenuBar.}BuildCmdName(destCmd, templateCmd: TCmdNumber; param: TPString);
                    {if param is NIL, use the default}
        FUNCTION  {TMenuBar.}GetCmdName(cmdNumber: TCmdNumber; pName: TPString): BOOLEAN;
                    {returns TRUE iff cmdNumber is found (pName will be empty);
                        pName can be NIL, which will save the overhead of returning the
                        menu item, for case where you just want to see if it exists}
        PROCEDURE {TMenuBar.}PutCmdName(cmdNumber: TCmdNumber; pName: TPString);

      {Buttoning}
        FUNCTION  {TMenuBar.}CmdKey(ch: CHAR): TCmdNumber;
        FUNCTION  {TMenuBar.}DownAt(mousePt: Point): TCmdNumber;

      {Display}
        PROCEDURE {TMenuBar.}Draw;
        PROCEDURE {TMenuBar.}EndCmd;
        PROCEDURE {TMenuBar.}HighlightMenu(withCmd: TCmdNumber);
                {call this when the user presses the CLEAR key for example, to highlight
                    the appropriate menu title; you should then call window.DoCommand with
                    an apropriate command number.}

      {Loading}
        PROCEDURE {TMenuBar.}Delete(menuID: INTEGER);
        PROCEDURE {TMenuBar.}Insert(menuID, beforeId: INTEGER);
        PROCEDURE {TMenuBar.}Unload;

      {For Future Use}
        FUNCTION  {TMenuBar.}MenuWithID(menuID: INTEGER): Ptr;
        END;


{$IFC LibraryVersion <= 20 AND FALSE} {do it this way in case we need it back for Pepsi version}
    TFont = SUBCLASS OF TObject

      {Variables}
        family:         INTEGER;                        {Font Manager TFam}

      {Creation/Destruction}
        FUNCTION  {TFont.}CREATE(object: TObject; heap: THeap; itsFamily: INTEGER): TFont;

        END;
{$ENDC}

    { GLOBAL VARIABLES -- EFFECTIVELY, FIELDS OF CLASS TProcess }

VAR

    activeWindowID:     TWindowID;                  {The wmgrID field of the active document, or 0}
    allowAbort:         BOOLEAN;                    {Iff TRUE, allow aborts}
    autoBreakPen:       PenState;                   {pen to use to draw automatic page breaks}
    blinkOffCentiSecs:  LONGINT;                    {Centiseconds to hide the insertion point}
    blinkOnCentiSecs:   LONGINT;                    {Centiseconds to display the insertion point}
    boundClipboard:     TClipboard;                 {The clipboard whose data segment is bound, or NIL}
    boundDocument:      TDocManager;                {The document whose data segment is bound, or NIL}
    cancelString:       STRING[20];                 {The word "Cancel" for use in buttons}
    clickState:         TClickState;                {Shifts and repeats of the last mouse click}
    clipboard:          TClipboard;                 {The Clipboard document manager}
    clipPrintPref:      TPrReserve;                 {the print-preference for the clipboard}
    closedBySuspend:    BOOLEAN;                    {Iff TRUE, closedDocument was just suspended}
    closedDocument:     TDocManager;                {If not NIL, this document was just put away}
    cornerNumberStyle:  TTypeStyle;                 {TypeStyle used for page-numbers in page-preview}
    countryCode:        INTEGER;                    {The country code as read from phrase file}
    currentDocument:    TDocManager;                {The active document OR if running in background, the
                                                        document to use; otherwise NIL}
    currentWindow:      TWindow;                    {currentDocument.window, OR NIL}
    cursorShape:        TCursorNumber;              {The cursor shape as recorded by TProcess.ChangeCursor}
    deferUpdate:        BOOLEAN;                    {set TRUE by app to defer updating while typing}
    dfltNewHeading:     STRING[20]; {+SW+}          {Default value for newly-created headings}
    docList:            TList {OF TDocManager};     {The documents that are open}
    eventTime:          LONGINT;                    {The time of the most recent WM event}
    eventType:          INTEGER;                    {The type number of the most recent WM event}
{$IFC fDbgABC}
    fExperimenting:     BOOLEAN;                    {IF TRUE, enable zoom experimentation etc.}
    fCountHeap:         BOOLEAN;                    {Iff TRUE and IFC fCheckHeap, count objects once per cmd}
{$ENDC}
{$IFC LibraryVersion <= 20 AND FALSE} {do it this way in case we need it back for the Pepsi version}
    fonts:              ARRAY [0..maxFonts] OF TFont;
{$ENDC}
    genClipPic:         BOOLEAN;                    {Iff TRUE, we are generating the Clipboard picture}
    highLevel:          ARRAY [BOOLEAN] OF THighTransit;    {TRUE=>hOffToOn, FALSE=>hOffToDim}
    highToggle:         ARRAY [BOOLEAN] OF THighTransit;    {TRUE=>hOffToOn, FALSE=>hOnToOff}
    idleTime:           LONGINT;                    {The time we finished processing the last user input}
    inBackground:       BOOLEAN;                    {Iff TRUE, currently running in background}
    limboPen:           PenState;                   {pen to use to fill limbo area in paginated view}
    manualBreakPen:     PenState;                   {pen to use to draw manual page breaks}
    marginPattern:      LPattern;                   {pattern to use to fill margins in paginated view}
    menuBar:            TMenuBar;                   {The menus of the application and the Clipboard}
    myProcessID:        LONGINT;                    {The OS ID of this process}
    myTool:             LONGINT;                    {The tool number of this tool}
    normalPen:          PenState;                   {pen state resulting from PenNormal}
    okString:           STRING[20];                 {The word "OK" for use in buttons}
    phraseFile:         TFileScanner;               {The Main Phrase File TFileScanner}
    process:            TProcess;                   {The process object of this process}

    screenRightEdge:    INTEGER;                    {720 for Lisa 1.0 screen}
    scrollRgn:          RgnHandle;                  {what needs to be refreshed because of scroll}
    stdMargins:         LRect;                      {standard page-margins, in screen pixels}
    suspendSuffix:      ARRAY [1..maxSegments] OF STRING[3];
    theBodyPad:         TBodyPad;                   {current BodyPad being written to}
    theMarginPad:       TMarginPad;                 {current MarginPad being written to}
    toolName:           STRING[67];                 {The name of the tool}
    toolPrefix:         TFilePath;                  (*The prefix '{Tnn}' of the OS path name of the tool*)
    toolVolume:         TFilePath;                  {The volume '-name-' on which the tool resides}
    varPage:            STRING[20]; {+SW+}          {The string 'PAGE', for use in heading variables}
    varTitle:           STRING[20]; {+SW+}          {The string 'TITLE' for use in heading variables}
    wordDelimiters:     STRING[67];                 {The delimiters of a Lisa "word" in this language}


PROCEDURE GetPrefixPart(wholeName: S255; VAR filePart: TFilePath); (*'{prefix}'*)
FUNCTION  ToolOfFile(wholeName: S255): LONGINT;
FUNCTION  ToolOfProcess(processId: LONGINT): LONGINT;

{ Used to insert comments into the Universal Graph of Clipboard, so LisaDraw can understand it;
    These procedures only insert comment when we are generating the Universal Graph }
                                { beginning of a series of text drawing ops that should be grouped }
PROCEDURE PicTextBegin(alignment: TAlignment);
PROCEDURE PicTextEnd;           { end of series }
PROCEDURE PicGrpBegin;          { beginning of a series of grouped objects }
PROCEDURE PicGrpEnd;            { end of series }

PROCEDURE InitProcess;

FUNCTION GetTime: LONGINT;
    {This function returns the same "time" as is used in events (see global variable eventTime),
            and in the idle loop}


IMPLEMENTATION

{$I LIBTK/UABC2.TEXT}     {TProcess-TDocDirectory-TDocManager-TClipboard-TCommand-TCutCopyCommand-
                           TPasteCommand}
{$I LIBTK/UABC3.TEXT}     {TImage-TView-TPaginatedView-TPageView-TPrintManager-THeading-TSelection}
{$I LIBTK/UABC4.TEXT}     {TWindow-TDialogBox-TMenuBar-TFont}
{$I LIBTK/UABC5.TEXT}     {TPanel-TBand-TPane-TMarginPad-TBodyPad-TScroller-TScrollBar}

(**********
{$I UABC2.TEXT}     {TProcess-TDocDirectory-TDocManager-TClipboard-TCommand-TCutCopyCommand-TPasteCommand}
{$I UABC3.TEXT}     {TImage-TView-TPaginatedView-TPageView-TPrintManager-THeading-TSelection}
{$I UABC4.TEXT}     {TWindow-TDialogBox-TMenuBar-TFont}
{$I UABC5.TEXT}     {TPanel-TBand-TPane-TMarginPad-TBodyPad-TScroller-TScrollBar}
**********)

END.

