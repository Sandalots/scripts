{UDialog3}  {COPYRIGHT 1984 BY APPLE COMPUTER, INC}

(*
    TPicObject  -- TRectImage -- TTextDialogImage - TFrameSelection  -
    TPlannerView - TLayoutBox - TLegendLayoutBox - ButtonLayoutBox - TTitleTab -
    TLayPickSelection - TLayMoveCommand - TEditLegendSelection  - TDialogDesignWindow

*)

{04/25/84 1610  Switched back to using a paraImage in call to FilterAndDo, as per JKD's latest change,
                   in TLegendLayoutBox.RecalcExtent
                Removed the inval in TLegendLayoutBox.MousePress, fExperimenting or not}
{04/25/84 0015  Added TEditLegendSelection.MousePress, MouseMove and MouseRelease and field tripleClick,
                    to trap triple-click and do a SelectAll with it}
{04/23/84 1210  Removed all references to 'underEdit' field of TDialogImage
                TEditLegendSelection.Deselect, Free, and Restore changed.
                Removed some commented-out code and some unused VAR declarations in the TEditLegendSel
                   methods changed}
{04/17/84 2130  In TEditLegendSelection.CREATE doesn't inval unless fExperimenting
                Removed ABCBreak calls in TEditLegendSelection.CREATE, TFrameSelection.KeyChar
                TLegendLayoutBox.Draw always keys on existence of SELF.textDialogImage, ignoring
                     underEdit flag; underEdit, if this is okay, can vanish completely from the architecture}
{04/17/84 2000  In TLegendLayoutBox.RecalcExtent, try to use TImage.FilterAndDo correctly}
{04/15/84 2000  Spring Prelim Release}
{01/29/84 1754  RELEASE TK8D}
{12/22/83 1927  RELEASE TK8A}


METHODS OF TPicObject;

{$S DlgCold}
FUNCTION  TPicObject.CREATE(object: TObject; heap: THeap; itsId: S255;
            itsView: TView; itsLocation: LPoint; itsPicHandle: PicHandle):  TPicObject;
VAR tempHz:         THeap;
    frameInView:    LRect;
    myPicHandle:    PicHandle;
    boxAtCreation:  Rect;
BEGIN
    {$IFC fTrace}BP(7);{$ENDC}
    boxAtCreation:= itsPicHandle^^.picFrame;
    noPad.rectToLRect(boxAtCreation, frameInView);
    OffsetLRect(frameInView, itsLocation.h, itsLocation.v);

    IF object = NIL THEN
       object := NewObject(heap, THISCLASS);
    SELF := TPicObject(TImageWithID.CREATE(object, heap, frameInView, itsId, itsView, FALSE {no children}));

    SELF.isEditable := FALSE;
    SELF.boxAtCreation := boxAtCreation;
    GetHeap(tempHz);
    SetHeap(SELF.Heap);
    myPicHandle := OpenPicture(SELF.boxAtCreation);   {replay the incoming picture file onto our own heap}
    SELF.picture := myPicHandle;
    DrawPicture(itsPicHandle, SELF.boxAtCreation);
    ClosePicture;
    SetHeap(tempHz);   {restore normal heap}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgCold}
PROCEDURE TPicObject.Free;
BEGIN
   {$IFC fTrace}BP(7);{$ENDC}
   KillPicture(SELF.picture);
   SUPERSELF.Free;
   {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TPicObject.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('picHandle: LONGINT');
    Field('boxAtCreation: Rect');
    Field('');
END;
{$ENDC}


{$S DlgCold}
PROCEDURE TPicObject.Draw;
VAR boxOnPad:   Rect;
BEGIN
   {$IFC fTrace}BP(7);{$ENDC}
   thePad.LRectToRect(SELF.extentLRect, boxOnPad);
   DrawPicture(SELF.picture, boxOnPad);
   {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;


METHODS OF TRectImage;


{$S DlgAlloc}
FUNCTION TRectImage.CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsId: S255;
    itsView: TView; itsPenState: PenState; withChildren: BOOLEAN): TRectImage;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TRectImage(TDialogImage.CREATE(object, heap, itsExtent, itsId, itsView, withChildren));

    SELF.penState := itsPenState;
    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TRectImage.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field(CONCAT('penState: RECORD pnLoc: Point; pnSize: Point; pnMode: INTEGER;',
                 'pnPat: ARRAY[0..7] OF Byte END'));     {actually a packed array--fix}
    Field('');
END;
{$ENDC}


{$S DlgHot}
PROCEDURE TRectImage.Draw;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SetPenState(SELF.penState);  {could first want to scale the pen size, via the Pad...}
    FrameLRect(SELF.extentLRect);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgLayout}
FUNCTION  TRectImage.LaunchLayoutBox(view: TView): TImage;
    VAR newBox:  TLayoutBox;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    newBox := TLayoutBox.CREATE(NIL, SELF.Heap, SELF.extentLRect, noID, NIL,
        view, SELF, stdThinBorders, TRUE, TRUE, FALSE);
    LaunchLayoutBox := newBox;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;


{-------------------------------------------------------------------------------------------------------}


METHODS OF TTextDialogImage;


{$S DlgText}
FUNCTION  TTextDialogImage.CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsId: S255;
              itsView: TView; itsTypeStyle: TTypeStyle; itsInitialChars: S255): TTextDialogImage;
    VAR textimage:  TTextImage;
        editPara:   TEditPara;
        paraFormat: TParaFormat;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TTextDialogImage(TImageWithID.CREATE(object, heap, itsExtent, itsId, itsView,  FALSE));

    textImage := TTextImage.CREATE(NIL, heap, itsView, itsExtent,
         TText.CREATE(NIL, heap, TDialogView(itsView).styleSheet), TRUE);

    textImage.text.txtImgList.InsLast(textImage);

    paraFormat := TParaFormat.CREATE(NIL, heap, NIL);
    paraFormat.dfltTStyle := itsTypeStyle;

    editPara := TEditPara.CREATE(NIL, heap, 0, paraFormat);

    textImage.imageList.InsLast(textImage.NewParaImage(editPara, itsExtent, 0, 0));
    textImage.text.paragraphs.InsLast(editPara);
    editPara.ReplPString(0, editPara.size, @itsInitialChars);

    SELF.textImage := textImage;
    textImage.RecomputeImages(actionNone, TRUE);
    SELF.wouldBeDraggable := TRUE;
    SELF.refCount := 1;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S SgTxtRes}
PROCEDURE TTextDialogImage.Free;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.textImage.text.Free;
    SUPERSELF.Free;
    {$IFC fTrace}EP;{$ENDC}
END;


PROCEDURE TTextDialogImage.ChangeRefCountBy(delta: INTEGER);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.refCount := SELF.refCount + delta;
    IF SELF.refCount <= 0 THEN
        SELF.Free;
    {$IFC fTrace}EP;{$ENDC}
END;


{$IFC fDebugMethods}
{$S DlgDbg}
PROCEDURE TTextDialogImage.Fields(PROCEDURE Field(nameAndType: S255));
BEGIN
    SUPERSELF.Fields(Field);
    Field('textImage: TTextImage');
    Field('wouldBeDraggable: BOOLEAN');
    Field('refCount: INTEGER');
    Field('');
END;
{$ENDC}


{$S DlgHot}
FUNCTION TTextDialogImage.CursorAt(mouseLPt: LPoint): TCursorNumber;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF SELF.Hit(mouseLPt) THEN
        CursorAt := textCursor
    ELSE {not mine}
        CursorAt := noCursor;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S SgTxtRes}
PROCEDURE TTextDialogImage.Draw;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.textImage.Draw;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgLayout}
FUNCTION  TTextDialogImage.LaunchLayoutBox(view: TView): TImage;
    VAR borders:        Rect;
        newBox:         TLayoutBox;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}   {dubious--formerly intended uses in abeyance}
    IF SELF.wouldBeDraggable THEN
        borders := stdPlainBorders
    ELSE
        borders := zeroRect;
    newBox := TLayoutBox.CREATE(NIL, SELF.Heap, SELF.extentLRect, noID, NIL {parent},
        view, SELF, borders, FALSE, FALSE, FALSE);
    newBox.wouldMakeSelection := TRUE;
    newBox.suppressDrawingManipulee := FALSE;
    newBox.isDraggable := SELF.wouldBeDraggable;
    LaunchLayoutBox := newBox;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S SgTxtRes}
PROCEDURE TTextDialogImage.MousePress(mouseLPt: LPoint);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.textImage.MousePress(mouseLPt);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S SgTxtRes}
PROCEDURE TTextDialogImage.OffsetBy(deltaLPt: LPoint);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.textImage.OffsetBy(deltaLPt);
    SUPERSELF.OffsetBy(deltaLPt);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;


METHODS OF TFrameSelection;

{$S DlgHot}
FUNCTION TFrameSelection.CREATE(object: TObject; heap: THeap;
        itsInputFrame: TInputFrame): TFrameSelection;
    VAR coSelection:    TSelection;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF object = NIL THEN
        object := NewObject(heap, THISCLASS);
    SELF := TFrameSelection(TSelection.CREATE(object, heap, itsInputFrame.view,
                                              frameKind, zeroLPt));

    SELF.inputFrame := itsInputFrame;
    SELF.boundLRect := itsInputFrame.textDialogImage.extentLRect;
    coSelection := itsInputFrame.view.NoSelection;  {put non-NIL coSelection}
    SELF.coSelection := coSelection;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
FUNCTION  TFrameSelection.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN;
BEGIN
    {$IFC fTrace}BP(10);{$ENDC}
    CASE cmdNumber OF
        uModern, uClassic,u20Pitch, u15Pitch, u12Pitch, u10Pitch, u12Point, u14Point, u18Point, u24Point,
        uPlain, uBold, uItalic, uUnderline, uShadow, uOutline:
            CanDoCommand := FALSE;   {before coSelection could set to TRUE}

        OTHERWISE
            CanDoCommand := SUPERSELF.CanDoCommand(cmdNumber, checkIt);
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TFrameSelection.KeyChar(ch: CHAR);
    VAR paraImage:      TParaImage;
        maxCharsString: S255;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    paraImage := TParaImage(SELF.inputFrame.textDialogImage.textImage.imageList.First);
    IF (SELF.inputFrame.maxInputChars > paraImage.paragraph.size) OR
       (NOT InClass(SELF.coSelection, TInsertionPoint)) THEN  {can accept more}
        SELF.coSelection.KeyChar(ch)
    ELSE
        BEGIN
        IntToStr(SELF.inputFrame.maxInputChars, @maxCharsString);
        process.ArgAlert(1, maxCharsString);
        process.Stop(phTooManyChars);
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TFrameSelection.KeyEnter(dh, dv: INTEGER);
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    IF (dh <> 0) OR (dv <> 0) THEN
        SELF.KeyTab((dh < 0) OR (dv < 0));  {right and down keys are Forward}
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TFrameSelection.KeyReturn;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SELF.KeyTab(FALSE);
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TFrameSelection.KeyTab(fBackward: BOOLEAN);
    VAR dialogView:     TDialogView;
        dialogImage:    TDialogImage;
        s:              TListScanner;
        passedGo:       BOOLEAN;
        foundSuccessor: BOOLEAN;
        prevInputFrame: TInputFrame;
        nextInputFrame: TInputFrame;
        newFrameSel:    TFrameSelection;
        dialog:         TDialog;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    dialogView := TDialogView(SELF.view);
    prevInputFrame := NIL;
    passedGo := FALSE;
    foundSuccessor := FALSE;
    dialog := TDialog(SELF.inputFrame.parent);
    s := dialog.children.Scanner;
    WHILE s.Scan(dialogImage) DO
        BEGIN
        IF dialogImage = SELF.inputFrame THEN  {found current frame}
            BEGIN
            IF not fBackward THEN
                passedGo := TRUE
            ELSE {back-tab; use most recent input frame, if any}
                BEGIN
                IF prevInputFrame = NIL THEN  {there is none; can't do anything}
                    s.Done {with foundSuccessor still FALSE}
                ELSE {found somebody!}
                    BEGIN
                    nextInputFrame := prevInputFrame;
                    foundSuccessor := TRUE;
                    END;
                END;
            END;
        IF InClass(dialogImage, TInputFrame) THEN
            IF (passedGo AND (dialogImage <> SELF.inputFrame)) OR foundSuccessor THEN
                BEGIN
                IF passedGo THEN
                    nextInputFrame := TInputFrame(dialogImage); {else it's already set, if back-tab}
                SELF.KeyPause;

                dialog.SelectInputFrame(nextInputFrame);

                foundSuccessor := TRUE;
                s.Done;
                END   {forward tabbing actually done}
            ELSE
                prevInputFrame := TInputFrame(dialogImage);
        END; {scan of dialogImages}
    IF NOT foundSuccessor THEN
        SELF.CantDoIt;
    {ELSE
        SELF.window.CommitLast};
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TFrameSelection.MousePress(mouseLPt: LPoint);
{called only if mouse comes BACK down inside alredy-selected Input Frame}
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    SUPERSELF.MousePress(mouseLPt);
    TDialogView(SELF.view).magnetCursor := textCursor;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TFrameSelection.PerformCommand(command: TCommand; cmdPhase: TCmdPhase);
    VAR paragraph:      TParagraph;
        textImage:      TTextImage;
        paraImage:      TParaImage;
        noSelection:    TSelection;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    textImage := SELF.inputFrame.textDialogImage.textImage;
    SUPERSELF.PerformCommand(command, cmdPhase);
    paraImage := TParaImage(textImage.imageList.First);
    paragraph := paraImage.paragraph;
    paragraph.NewStyle(0, paragraph.Size, SELF.inputFrame.inputTypeStyle);
    IF paragraph.size > SELF.inputFrame.maxInputChars THEN
        BEGIN {may need temp para here}
        paragraph.ReplPara(0, paragraph.size, paragraph, 0, SELF.inputFrame.maxInputChars);
        paraImage.changed := TRUE;
        paraImage.InvalLinesWith(0, MAXINT);
        textImage.RecomputeImages(actionNone, TRUE);
        SELF.window.CommitLast;
        noSelection := SELF.FreedAndReplacedBy(SELF.view.NoSelection);
        END;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgHot}
PROCEDURE TFrameSelection.Restore;
BEGIN
    {$IFC fTrace}BP(11);{$ENDC}
    TDialogView(SELF.view).currentDialogImage := SELF.inputFrame;
    SUPERSELF.Restore;
    {$IFC fTrace}EP;{$ENDC}
END;


{$S DlgInit}
END;


METHODS OF TPlannerView;

{$S SgLayout}
    FUNCTION  TPlannerView.CREATE(object: TObject; heap: THeap; itsViewBeingPlanned: TView;
                                     itsPanel: TPanel; itsAllowSketching: BOOLEAN;
                                     itsRetainPickedBox: BOOLEAN): TPlannerView;
        VAR newList:    TList;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TPlannerView(TDialogView.CREATE(object, heap, itsViewBeingPlanned.extentLRect, itsPanel,
                    NIL, itsViewBeingPlanned.res));

        WITH SELF DO
            BEGIN
            viewBeingPlanned := itsViewBeingPlanned;
            allowSketching := itsAllowSketching;
            retainPickedBox := itsRetainPickedBox;
            currentLayoutBox := NIL;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
{$S DlgDbg}
    PROCEDURE TPlannerView.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('viewBeingPlanned: TView');
        Field('allowSketching: BOOLEAN');
        Field('retainPickedBox: BOOLEAN');
        Field('currentLayoutBox: TLayoutBox');
        Field('');
    END;
    {$ENDC}


{$S SgLayout}
    FUNCTION  TPlannerView.CursorAt(mouseLPt: LPoint): TCursorNumber;
    VAR s:          TListScanner;
        layoutBox:  TLayoutBox;
        curCursor:  TCursorNumber;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.mouseIsDown AND (SELF.magnetCursor <> noCursor) THEN
            CursorAt := SELF.magnetCursor
        ELSE
            BEGIN
            curCursor := noCursor;
            s := SELF.rootDialog.children.Scanner;
            WHILE s.Scan(layoutBox) DO
                BEGIN
                curCursor := layoutBox.CursorAt(mouseLPt);
                IF curCursor <> noCursor THEN
                    s.Done
                END;
            CursorAt := curCursor;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TPlannerView.Draw;
        PROCEDURE DrawLayoutBox(obj: TObject);
        VAR layoutBox:    TLayoutBox;
        BEGIN
            layoutBox := TLayoutBox(obj);
            layoutBox.Draw;
        END;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        SELF.EachActualPart(DrawLayoutBox);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TPlannerView.EachActualPart(PROCEDURE DoToObject(filteredObj: TObject));
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
         SELF.rootDialog.children.Each(DoToObject);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
    PROCEDURE TPlannerView.Init(itsListOfImages: TList);
        VAR s:                  TListScanner;
            t:                  TListScanner;
            image:              TImage;
            layoutBox:          TLayoutBox;
            otherLayoutBox:     TLayoutBox;
            nextButton:         TButton;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF itsListOfImages <> NIL THEN
            BEGIN
            s := itsListOfImages.Scanner;       {create parallel structure}
            WHILE s.Scan(image) DO
                BEGIN
                layoutBox := SELF.NewLayoutBox(image);
                IF layoutBox <> NIL THEN
                    SELF.rootDialog.AddImage(layoutBox); {it may well have its own children, already created}
                END;
            END;

        IF InClass(SELF.viewBeingPlanned, TDialogView) THEN {get buttonLayoutBoxes correctly entwined}
            BEGIN
            s := SELF.rootDialog.children.Scanner;
            WHILE s.Scan(layoutBox) DO
                IF InClass(layoutBox, TButtonLayoutBox) THEN
                    BEGIN
                    nextButton := TButton(layoutBox.manipulee).nextSameSizedButton;
                    t := SELF.rootDialog.children.Scanner;
                    WHILE t.Scan(otherLayoutBox) DO
                        IF otherLayoutBox.manipulee = nextButton THEN {found it}
                            BEGIN
                            TButtonLayoutBox(layoutBox).nextSameSizedBox := TButtonLayoutBox(otherLayoutBox);
                            t.Done;
                            END;
                    END;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgAlloc}
    FUNCTION TPlannerView.NewLayoutBox(image: TImage): TLayoutBox;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        NewLayoutBox := TLayoutBox(image.LaunchLayoutBox(SELF));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
    PROCEDURE TPlannerView.MousePress(mouseLPt: LPoint);
    VAR panel:                  TPanel;
        layPickSelection:       TLayPickSelection;
        pickedBox:              TLayoutBox;
        s:                      TListScanner;
        layoutBox:              TLayoutBox;
        madeSelection:          BOOLEAN;
        editLegendSelection:    TEditLegendSelection;
            PROCEDURE InvrtOnThePad;
            BEGIN
                pickedBox.Highlight(hOffToOn);
            END;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        SELF.mouseIsDown := TRUE;
        SELF.magnetCursor := noCursor;
        panel := SELF.panel;
        madeSelection := FALSE;
        IF (panel.selection.kind <> nothingKind) AND (panel.selection.kind <> layPickKind) THEN
            BEGIN
            IF clickState.fShift THEN
                madeSelection := TRUE
            ELSE
            IF InClass(panel.selection, TEditLegendSelection) THEN
                BEGIN
                editLegendSelection := TEditLegendSelection(panel.selection);
                IF LPtInLRect(mouseLPt, editLegendSelection.legendLayoutBox.extentLRect) THEN
                    IF NOT LPtInLRect(mouseLPt, editLegendSelection.legendLayoutBox.titleTab.extentLRect) THEN
                        BEGIN
                        madeSelection := TRUE;
                        SELF.magnetCursor := textCursor;
                        END;
                END;
            END;

        IF madeSelection THEN
            panel.selection.MousePress(mouseLPt)
        ELSE
            BEGIN
            panel.BeginSelection;
            pickedBox := NIL;  {find who wants the mouse}
            s := SELF.rootDialog.children.Scanner;
            WHILE s.Scan(layoutBox) DO
                BEGIN
                layoutBox.ConsiderMouse(mouseLPt, madeSelection, pickedBox);
                IF pickedBox <> NIL THEN
                    pickedBox.ComeForward;
                IF madeSelection THEN
                    s.Done
                ELSE
                IF (pickedBox <> NIL)  THEN {got the title tab of somebody}
                    BEGIN
                    pickedBox.ChangeDragState(TRUE);
                    layPickSelection := TLayPickSelection(panel.selection.FreedAndReplacedBy(
                                    TLayPickSelection.CREATE(NIL, SELF.Heap, SELF, layPickKind, pickedBox,
                                    mouseLPt)));
                    panel.OnAllPadsDo(InvrtOnThePad);
                    SELF.magnetCursor := arrowCursor;
                    s.Done;
                    END
                END;
(*     NB: Here, when/if we allow sketching in layout, we would add code like:

        IF pickedBox = NIL THEN
                IF SELF.allowSketching THEN
                    LaySketchSelection := TLaySketchSelection(panel.selection.FreedAndReplacedBy(
                                    TLaySketchSelection.CREATE(NIL, SELF.Heap, SELF, mouseLPt)))   *)
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
    PROCEDURE TPlannerView.MouseMove(mouseLPt: LPoint);
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        TView.MouseMove(mouseLPt);  {do NOT do what TDialogView would do}
       {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TPlannerView.MouseRelease;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.mouseIsDown := FALSE;
        SELF.magnetCursor := noCursor;
        TView.MouseRelease;         {do NOT do what TDialogView would do except for the above}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TLayoutBox;


{$S SgLayout}
    FUNCTION TLayoutBox.CREATE(object: TObject; heap: THeap; baseExtent: LRect; itsID: S255;
                itsParent: TLayoutBox; itsView: TView; itsManipulee: TImage; itsBorders: Rect;
                itsResizable: BOOLEAN; itsSuppression: BOOLEAN; withChildren: BOOLEAN): TLayoutBox;
        VAR itsTitleTab:    TTitleTab;
            itsExtentLRect: LRect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        LRectAddBorders(baseExtent, itsBorders, itsExtentLRect);
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TLayoutBox(TImageWithID.CREATE(object, heap, itsExtentLRect, itsID, itsView, withChildren));

        IF itsBorders.top = 0 THEN
            itsTitleTab := SELF.NoTitleTab(SELF.Heap)
        ELSE
            itsTitleTab := TTitleTab.CREATE(NIL, heap, SELF,  - itsBorders.bottom - itsBorders.top + 1,
                                                itsID);

        WITH SELF DO
            BEGIN
            parent := itsParent;
            titleTab := itsTitleTab;
            manipulee := itsManipulee;
            suppressDrawingManipulee := itsSuppression;
            wouldMakeSelection := FALSE;
            isResizable := itsResizable;
            isDraggable := TRUE;
            shouldFrame := TRUE;
            borders := itsBorders;
            hasDraggee := FALSE;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.Free;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        Free(SELF.titleTab);
        SUPERSELF.Free;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TLayoutBox.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('manipulee: TImage');
        Field('titleTab: TTitleTab');
        Field('suppressDrawingManipulee: BOOLEAN');
        Field('isResizable: BOOLEAN');
        Field('borders: Rect');
        Field('wouldMakeSelection: BOOLEAN');
        Field('isDraggable: BOOLEAN');
        Field('shouldFrame: BOOLEAN');
        Field('hasDraggee: BOOLEAN');
        Field('');
    END;
    {$S SgLayout}
    {$ENDC}


    PROCEDURE TLayoutBox.ChangeDragState(enteringDrag: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.hasDraggee := enteringDrag;
        IF SELF.parent <> NIL THEN
            IF InClass(SELF.parent, TLayoutBox) THEN
                TLayoutBox(SELF.parent).ChangeDragState(enteringDrag);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE  TLayoutBox.ConsiderMouse(mouseLPt: LPoint; VAR madeSelection: BOOLEAN;
            VAR pickedLayoutBox: TLayoutBox);
        VAR s:          TListScanner;
            layoutBox:  TLayoutBox;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        pickedLayoutBox := NIL;
        madeSelection := FALSE;
        IF NOT SELF.Hit(mouseLPt) THEN
            {it ain't me}
        ELSE
            BEGIN
            IF LRectHasLPt(SELF.titleTab.extentLRect, mouseLPt) THEN
                BEGIN
                pickedLayoutBox := SELF;
                SELF.TabGrabbed;        {so that page status dialog can react now}
                END
            ELSE
            IF SELF.wouldMakeSelection THEN
                BEGIN
                madeSelection := TRUE;
                pickedLayoutBox := SELF;
                SELF.MousePress(mouseLPt);
                END
            ELSE    {not my title tab, and I myself don't make selections; how about it, kids?}
                BEGIN
                IF SELF.children <> NIL THEN
                    BEGIN
                    s := SELF.children.Scanner;
                    WHILE s.Scan(layoutBox) DO
                        BEGIN
                        layoutBox.ConsiderMouse(mouseLPt, madeSelection, pickedLayoutBox);
                        IF madeSelection OR (pickedLayoutBox <> NIL) THEN
                            s.Done;
                        END;
                    END;
                END;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    FUNCTION TLayoutBox.CursorAt(mouseLPt: LPoint): TCursorNumber;
    VAR s:          TListScanner;
        layoutBox:  TLayoutBox;
        curCursor:  TCursorNumber;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        curCursor := noCursor;
        IF SELF.Hit(mouseLPt) THEN
            BEGIN
            IF SELF.titleTab <> NIL THEN
                IF SELF.titleTab.Hit(mouseLPt) THEN
                    curCursor := arrowCursor;

            IF curCursor = noCursor THEN
                IF SELF.children <> NIL THEN
                    BEGIN
                    s := SELF.children.Scanner;
                    WHILE s.Scan(layoutBox) DO
                        BEGIN
                        curCursor := layoutBox.CursorAt(mouseLPt);
                        IF curCursor <> noCursor THEN
                            s.Done;
                        END;
                    END;
            END;
        CursorAt := curCursor;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.Draw;
        PROCEDURE YouDraw(obj: TObject);
            VAR dialogImage: TDialogImage;
        BEGIN
            dialogImage := TDialogImage(obj);
            IF dialogImage.isActive THEN
                dialogImage.Draw;
        END;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF LRectIsVisible(SELF.extentLRect) OR SELF.hasDraggee THEN
            BEGIN
            SELF.EachActualPart(YouDraw);
            SELF.DrawJustMe;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.DrawJustMe;
        VAR titleTab:   TTitleTab;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF LRectIsVisible(SELF.extentLRect) THEN
            BEGIN
            titleTab := SELF.titleTab;
            IF titleTab <> NIL THEN  {currently every layout box MUST have a title tab, so this is
                                      unnecessary}
                IF NOT EmptyLRect(titleTab.extentLRect) THEN
                    titleTab.Draw;

            IF NOT SELF.suppressDrawingManipulee THEN
                IF SELF.manipulee <> NIL THEN
                    SELF.manipulee.Draw;

            PenNormal;
            IF SELF.IsDraggable AND SELF.shouldFrame THEN
            FrameLRect(SELF.extentLRect);  {draw overall box}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.FreeManipulee;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        Free(SELF.manipulee);
        SELF.manipulee := NIL;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.Highlight(highTransit: THighTransit);
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF (SELF.titleTab <> NIL) THEN
            BEGIN
            InvrtLRect(SELF.titleTab.extentLRect);
            PenNormal;
            FrameLRect(SELF.titleTab.extentLRect);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.MousePress(mouseLPT: LPoint);
        VAR layoutBox:  TLayoutBox;
            s:          TListScanner;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.children <> NIL THEN
            BEGIN
            s := SELF.children.Scanner;
            WHILE s.Scan(layoutBox) DO
                IF layoutBox.DownAt(mouseLPt) <> NIL THEN
                    s.Done;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.Move(deltaLPt: LPoint);
    VAR oldLRect:   LRect;
        newLRect:   LRect;
        heading:    THeading;
            PROCEDURE InvalOnThePad;
            BEGIN
                thePad.InvalLRect(oldLRect);
                thePad.InvalLRect(newLRect);
            END;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        oldLRect := SELF.extentLRect;
        SELF.OffsetBy(deltaLPt);
        newLRect := SELF.extentLRect;
        SELF.view.panel.OnAllPadsDo(InvalOnThePad);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgDbg}
    FUNCTION TLayoutBox.NoTitleTab(heap: THeap): TTitleTab;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        NoTitleTab := TTitleTab.CREATE(NIL, heap, SELF, 0, noID);
        {$IFC fTrace}EP;{$ENDC}
    END;
{$S SgLayout}


    PROCEDURE TLayoutBox.OffsetBy(deltaLPt: LPoint);
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF SELF.manipulee <> NIL THEN
            SELF.manipulee.OffsetBy(deltaLPt);   {offset MY manipulee, but not my children's, since my
                                                  my manipulee's OffsetBy will have done that already}
        SELF.OffsetLayoutBoxBy(deltaLPt, TRUE);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.OffsetLayoutBoxBy(deltaLPt: LPoint; textImageAsWell: BOOLEAN);
                                         {does NOT offset manipulee}
        PROCEDURE YouOffset(obj: TObject);
            VAR layoutBox: TLayoutBox;
        BEGIN
            layoutBox := TLayoutBox(obj);
            layoutBox.OffsetLayoutBoxBy(deltaLPt, textImageAsWell);
        END;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.titleTab <> NIL THEN
            SELF.titleTab.OffsetBy(deltaLPt);
  {$H-} OffsetLRect(SELF.extentLRect, deltaLPt.h, deltaLPt.v); {$H+}
        SELF.EachActualPart(YouOffset);  {tells children}
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.RecalcExtent;
        VAR s:              TListScanner;
            newExtent:      LRect;
            layoutBox:      TLayoutBox;
            oldExtent:      LRect;
        PROCEDURE InvalOldAndNew;
            BEGIN
            thePad.InvalLRect(oldExtent);
            thePad.InvalLRect(newExtent);
            END;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        oldExtent := SELF.extentLRect;
        newExtent := SELF.manipulee.extentLRect;

        IF SELF.children <> NIL THEN
            IF SELF.children.Size > 0 THEN
                BEGIN
                newExtent := zeroLRect;
                s := SELF.children.Scanner;
                WHILE s.Scan(layoutBox) DO
                    IF EmptyLRect(newExtent) THEN
                        newExtent := layoutBox.extentLRect
                    ELSE
                        UnionLRect(newExtent, layoutBox.extentLRect, newExtent);
                END;

        LRectAddBorders(newExtent, SELF.borders, newExtent);
        IF NOT equalLRect(oldExtent, newExtent) THEN
            BEGIN
            SELF.Resize(newExtent);
            SELF.view.panel.OnAllPadsDo(InvalOldAndNew);
            END;
        IF SELF.parent <> NIL THEN
            SELF.parent.RecalcExtent;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.Resize(newExtent: LRect);
        VAR newTitleExtent: LRect;
            titleTab:       TTitleTab;
    BEGIN
        {$IFC fTrace}BP(3);{$ENDC}
        titleTab := SELF.titleTab;

        IF titleTab <> NIL THEN
            BEGIN
            newTitleExtent := newExtent;
            newTitleExtent.bottom := newTitleExtent.top +
                 (titleTab.extentLRect.bottom - titleTab.extentLRect.top); {i.e., preserve old height}
            titleTab.Resize(newTitleExtent);
            END;
        SUPERSELF.Resize(newExtentLRect);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLayoutBox.TabGrabbed;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TLegendLayoutBox;


{$S SgLayout}
    FUNCTION  TLegendLayoutBox.CREATE(object: TObject; heap: THeap; itsView: TView; itsLegend: TLegend
            ): TLegendLayoutBox;
    VAR itsTitleTab:    TTitleTab;
        itsExtentLRect: LRect;
        myBorders:      Rect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF itsLegend.wouldBeDraggable THEN
            myBorders := stdPlainBorders
        ELSE
            myBorders := zeroRect;
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TLegendLayoutBox(TLayoutBox.CREATE(object, heap, itsLegend.extentLRect, noID, NIL,
            itsView, itsLegend, myBorders, FALSE, FALSE, FALSE));

        WITH SELF DO
            BEGIN
            isDraggable := itsLegend.wouldBeDraggable;
            shouldFrame := itsLegend.wouldBeDraggable;
            textDialogImage := NIL;
            wouldMakeSelection := TRUE;   {client could override, somehow?}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TLegendLayoutBox.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('textDialogImage: TTextDialogImage');
        Field('');
    END;
    {$S SgLayout}
    {$ENDC}


    FUNCTION TLegendLayoutBox.CursorAt(mouseLPt: LPoint): TCursorNumber;
    VAR  curCursor:  TCursorNumber;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        curCursor := noCursor;
        IF SELF.Hit(mouseLPt) THEN
            IF SELF.titleTab.Hit(mouseLPt) THEN
                curCursor := arrowCursor
            ELSE
            IF SELF.wouldMakeSelection THEN
                curCursor := textCursor;
        CursorAt := curCursor;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLegendLayoutBox.Draw;
        VAR titleTab:           TTitleTab;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF LRectIsVisible(SELF.extentLRect) THEN
            BEGIN
            IF SELF.isDraggable THEN
                SELF.titleTab.Draw;

            IF SELF.textDialogImage <> NIL THEN {+SW+}
                SELF.textDialogImage.Draw
            ELSE
                SELF.manipulee.Draw;

            PenNormal;
            IF SELF.IsDraggable AND SELF.shouldFrame THEN
                FrameLRect(SELF.extentLRect);  {draw overall box}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLegendLayoutBox.MousePress(mouseLPT: LPoint);
        VAR editLegendSelection:    TEditLegendSelection;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        TPlannerView(SELF.view).magnetCursor := textCursor;
        LRectHaveLPt(SELF.manipulee.extentLRect, mouseLPt);
        editLegendSelection := TEditLegendSelection(SELF.view.panel.selection.FreedAndReplacedBy(
                                           TEditLegendSelection.CREATE(NIL, SELF.Heap, SELF, mouseLPT)));
        editLegendSelection.textDialogImage.MousePress(mouseLPt);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLegendLayoutBox.OffsetLayoutBoxBy(deltaLPt: LPoint; textImageAsWell: BOOLEAN);
                                       {does NOT offset manipulee}
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SUPERSELF.OffsetLayoutBoxBy(deltaLPt, textImageAsWell);
        IF NOT textImageAsWell THEN
            deltaLPt.v := 0; {don't do it vertically}
        IF SELF.textDialogImage <> NIL THEN
            SELF.textDialogImage.OffsetBy(deltaLPt);
        {$IFC fTrace}EP;{$ENDC}
    END;


    PROCEDURE TLegendLayoutBox.RecalcExtent;
        VAR newExtent:          LRect;
            oldExtent:          LRect;
            paraImage:          TParaImage;
            textDialogImage:    TTextDialogImage;
            legPara:            TParagraph;
        PROCEDURE InvalOldAndNew;
            BEGIN
            thePad.InvalLRect(oldExtent);
            thePad.InvalLRect(newExtent);
            END;
        PROCEDURE PourItBack(obj: TObject);
            VAR paragraph:  TParagraph;
        BEGIN
            paragraph := TParaImage(obj).paragraph;
            legPara.ReplPara(0, legPara.size, paragraph, 0, paragraph.size);
        END;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        textDialogImage := SELF.textDialogImage;
        IF textDialogImage <> NIL THEN
            BEGIN
            paraImage := TParaImage(textDialogImage.textImage.imageList.First);
            legPara := TLegend(SELF.manipulee).paragraph;
            textDialogImage.textImage.FilterAndDo(paraImage, PourItBack);
            END;
        TLegend(SELF.manipulee).RecalcExtent;

        oldExtent := SELF.extentLRect;
        newExtent := SELF.manipulee.extentLRect;

        LRectAddBorders(newExtent, SELF.borders, newExtent);
        IF NOT equalLRect(oldExtent, newExtent) THEN
            BEGIN
            SELF.Resize(newExtent);
            SELF.view.panel.OnAllPadsDo(InvalOldAndNew);
            END;

        IF SELF.parent <> NIL THEN
            SELF.parent.RecalcExtent;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TButtonLayoutBox;


{$S DlgLayout}
    FUNCTION TButtonLayoutBox.CREATE(object: TObject; heap: THeap; itsButton: TButton;
                                        itsView: TView): TButtonLayoutBox;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TButtonLayoutBox(TLayoutBox.CREATE(object, heap, itsButton.extentLRect, itsButton.id, NIL,
                                                   itsView, itsButton, stdIDBorders, FALSE, TRUE, TRUE));

        SELF.nextSameSizedBox := SELF; {will be correctly set by TPlannerView.CREATE after all layout
                                       boxes made}
        SELF.oldLegendTopLeft := itsButton.legend.extentLRect.topLeft;
        SELF.AddImage(TDialogImage(itsButton.legend.LaunchLayoutBox(itsView)));
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TButtonLayoutBox.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('nextSameSizedBox: TButtonLayoutBox');
        Field('oldLegendTopLeft: LPoint');
        Field('');
    END;
    {$ENDC}


{$S DlgLayout}
    PROCEDURE  TButtonLayoutBox.ConsiderMouse(mouseLPt: LPoint; VAR madeSelection: BOOLEAN;
            VAR pickedLayoutBox: TLayoutBox);
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        pickedLayoutBox := NIL;
        madeSelection := FALSE;
        IF SELF.Hit(mouseLPt) THEN
            BEGIN
            pickedLayoutBox := SELF;
            IF NOT LRectHasLPt(SELF.titleTab.extentLRect, mouseLPt) THEN
            {hit on interior -- hence, editing button text}
                BEGIN
                madeSelection := TRUE;
                LRectHaveLPt(TLayoutBox(SELF.children.First).extentLRect, mouseLPt);
                SELF.MousePress(mouseLPt);
                END;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
    FUNCTION  TButtonLayoutBox.CursorAt(mouseLPt: LPoint): TCursorNumber;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF NOT SELF.Hit(mouseLPt) THEN
            CursorAt := noCursor
        ELSE
        IF SELF.titleTab.Hit(mouseLPt) THEN
            CursorAt := arrowCursor
        ELSE
            CursorAt := textCursor;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
    PROCEDURE  TButtonLayoutBox.DrawJustMe;
        VAR s:          TListScanner;
            layoutBox:  TLayoutBox;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF LRectIsVisible(SELF.extentLRect) THEN
            BEGIN
            SELF.titleTab.Draw;
            TButton(SELF.manipulee).DrawJustMe;  {draws just the roundRect; my child will draw the text}
            PenNormal;
            FrameLRect(SELF.extentLRect);  {draw overall box}
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TButtonLayoutBox.OffsetBy(deltaLPt: LPoint);
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SUPERSELF.OffsetBy(deltaLPt);
  {$H-} LPtPlusLPt(SELF.oldLegendTopLeft, deltaLPt, SELF.oldLegendTopLeft); {$H+}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
    PROCEDURE TButtonLayoutBox.RecalcExtent;
        VAR nextBox:            TButtonLayoutBox;
            oldLegendTopLeft:  LPoint;
            newLegendTopLeft:  LPoint;
            deltaLPt:           LPoint;
            legendBox:          TLegendLayoutBox;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        legendBox := TLegendLayoutBox(SELF.children.First);
        newLegendTopLeft := legendBox.manipulee.extentLRect.topLeft;
        oldLegendTopLeft := SELF.oldLegendTopLeft;
        IF NOT EqualLPt(oldLegendTopLeft, newLegendTopLeft) THEN
            BEGIN
            LPtMinusLPt(newLegendTopLeft, oldLegendTopLeft, deltaLPt);
            legendBox.OffsetLayoutBoxBy(deltaLPt, TRUE);
            SELF.oldLegendTopLeft := newLegendTopLeft;
            END;

        nextBox := SELF;
        REPEAT
            nextBox.RecalcJustMe;
            nextBox := nextBox.nextSameSizedBox;
        UNTIL
            nextBox = SELF;

        IF SELF.parent <> NIL THEN
            SELF.parent.RecalcExtent;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
    PROCEDURE TButtonLayoutBox.RecalcJustMe;  {my manipulee's size may've changed}
        VAR nextBox:    TButtonLayoutBox;
            oldExtent:  LRect;
            newExtent:  LRect;
        PROCEDURE InvalOldAndNew;
            BEGIN
            thePad.InvalLRect(oldExtent);
            thePad.InvalLRect(newExtent);
            END;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        oldExtent := SELF.extentLRect;
        newExtent := SELF.manipulee.extentLRect;
        LRectAddBorders(newExtent, SELF.borders, newExtent);
        SELF.Resize(newExtent);
        SELF.view.panel.OnAllPadsDo(InvalOldAndNew);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TTitleTab;

{$S SgLayout}
    FUNCTION  TTitleTab.CREATE(object: TObject; heap: THeap; itsLayoutBox: TLayoutBox; itsHeight: INTEGER;
        itsCaption: S255): TTitleTab;
        VAR extentLRect:    LRect;
            legend:         TLegend;
            location:       LPoint;
{$IFC libraryVersion <= 20}   {* * * P E P S I * * *}
            fInfo:          TFInfo;
{$ELSEC}                      {* *  S P R I N G  * *}
            fInfo:          FontInfo;
{$ENDC}
            width:          INTEGER;
            newLegTopLeft:  LPoint;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        WITH itsLayoutBox.extentLRect DO
  {$H-}     SetLRect(extentLRect, left, top, right, top + itsHeight);           {$H+}

        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TTitleTab(TImage.CREATE(object, heap, extentLRect, itsLayoutBox.view));

        SELF.layoutBox := itsLayoutBox;

        IF itsCaption <> '' THEN {need to create a TLegend object for it}
            BEGIN
            legend := TLegend.CREATE(NIL, SELF.Heap, itsCaption, SELF.view, zeroLPt, titleTypeStyle);
            WITH itsLayoutBox.extentLRect DO
  {$H-}         SetLPt(newLegTopLeft, (right + left - legend.extentLRect.right) DIV 2,
                                    top + (SELF.view.res.v DIV 30));
  {$H+}     legend.OffsetTo(newLegTopLeft);

            SELF.legend := legend;
            WITH legend.extentLRect DO
                IF right - left > SELF.extentLRect.right - SELF.extentLRect.left THEN
                    SELF.shouldDrawLegend := FALSE
                ELSE
                    SELF.shouldDrawLegend := TRUE;
            END
        ELSE
            BEGIN
            SELF.legend := NIL;
            SELF.shouldDrawLegend := FALSE;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TTitleTab.Free;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        Free(SELF.legend);
        SUPERSELF.Free;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
{$S DlgDbg}
    PROCEDURE TTitleTab.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('layoutBox: TLayoutBox');
        Field('legend: TLegend');
        Field('shouldDrawLegend: BOOLEAN');
        Field('');
    END;
    {$S SgLayout}
    {$ENDC}


{$S SgLayout}
    PROCEDURE TTitleTab.Draw;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        PenNormal;
        FillLRect(SELF.extentLRect, lPatWhite);
        FrameLRect(SELF.extentLRect);
        IF SELF.shouldDrawLegend THEN      {it exists and is small enough to fit}
            SELF.legend.Draw;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TTitleTab.OffsetBy(deltaLPt: LPoint);
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.legend <> NIL THEN
            SELF.legend.OffsetBy(deltaLPt);
        SUPERSELF.OffsetBy(deltaLPt);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TTitleTab.Resize{(newExtent: LRect)};
        VAR myCaption:      S255;
{$IFC libraryVersion <= 20}   {* * * P E P S I * * *}
            fInfo:          TFInfo;
{$ELSEC}                      {* *  S P R I N G  * *}
            fInfo:          FontInfo;
{$ENDC}
            strLocation:    LPoint;
            captionWidth:   INTEGER;
            deltaLPt:       LPoint;
            typeStyle:      TTypeStyle;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}  {this does the wrong thing for high view resolutions; must fix}
        IF SELF.legend <> NIL THEN
            BEGIN
            SELF.legend.GetString(myCaption);
            SELF.legend.paragraph.StyleAt(0, typeStyle);
            SetQDTypeStyle(typeStyle);
            GetFontInfo(fInfo);
            captionWidth := StringWidth(myCaption);
    {$H-}   WITH newExtentLRect, fInfo DO
                SetLPt(strLocation, ((left + right - captionWidth) DIV 2),
                            bottom - descent);      {had had a -2 here}
                {$H+}
            SetLPt(deltaLPt, strLocation.h - SELF.legend.location.h,
                              strLocation.v - SELF.legend.location.v);
            SELF.legend.OffsetBy(deltaLPt); {do more cleverly -- maybe TLegend.OffsetTo}
            WITH SELF.legend.extentLRect DO
                IF right - left > newExtent.right - newExtent.left THEN
                    SELF.shouldDrawLegend := FALSE
                ELSE
                    SELF.shouldDrawLegend := TRUE;
            END;
        SELF.extentLRect := newExtentLRect;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TLayPickSelection;


{$S SgLayout}
    FUNCTION  TLayPickSelection.CREATE(object: TObject; heap: THeap; itsView: TPlannerView; itsKind: INTEGER;
                     itsLayoutBox: TLayoutBox; itsAnchorLPt: LPoint): TLayPickSelection;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TLayPickSelection(TSelection.CREATE(object, heap, itsView, itsKind, itsAnchorLPt));

        SELF.layoutBox := itsLayoutBox;
        SELF.boundLRect := itsLayoutBox.extentLRect;
        itsView.currentLayoutBox := itsLayoutBox;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
{$S DlgDbg}
    PROCEDURE TLayPickSelection.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('layoutBox: TLayoutBox');
        Field('');
    END;
    {$S SgLayout}
    {$ENDC}


{$S SgLayout}
    FUNCTION TLayPickSelection.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        CASE cmdNumber OF
            uClear:
                CanDoCommand := TRUE;
            OTHERWISE
                CanDoCommand := SUPERSELF.CanDoCommand(cmdNumber, checkIt);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TLayPickSelection.Deselect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        TPlannerView(SELF.view).currentLayoutBox := NIL;
        SELF.layoutBox.ChangeDragState(FALSE);
        SUPERSELF.Deselect;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TLayPickSelection.Highlight(highTransit: THighTransit);
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.layoutBox.Highlight(highTransit);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TLayPickSelection.MouseMove(mouseLPt: LPoint);
        VAR diffLPt:        LPoint;
            diffLRect:      LRect;
    BEGIN
       {$IFC fTrace}BP(11);{$ENDC}
           {How far did mouse move?}
            LPtMinusLPt(mouseLPt, SELF.currLPt, diffLPt);
           {Don't move past view boundaries}
            LRectMinusLRect(SELF.view.extentLRect, SELF.layoutBox.extentLRect, diffLRect);
            LRectHaveLPt(diffLRect, diffLPt);

           {Move it if delta is nonzero}
            IF NOT EqualLPt(diffLPt, zeroLPt) THEN
                BEGIN
          {$H-} OffsetLRect(SELF.boundLRect, diffLPt.h, diffLPt.v); {$H+}  {probably discard}
                LPtPlusLPt(SELF.currLPt, diffLPt, mouseLPt);
                SELF.currLPt := mouseLPt;

                SELF.layoutBox.Move(diffLPt);
                END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TLayPickSelection.MouseRelease;
    VAR deltaLPt:       LPoint;
        noSelection:    TSelection;
        manipulee:      TImage;
        parent:         TDialogImage;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF NOT EqualLPt(SELF.currLPt, SELF.anchorLPt) THEN
            BEGIN
            LPtMinusLPt(SELF.currLPt, SELF.anchorLPt, deltaLPt);
            SELF.window.PerformCommand(TLayMoveCmd.CREATE(NIL, SELF.Heap,
                            SELF.layoutBox, deltaLPt.h, deltaLPt.v));
            END;

        manipulee := SELF.layoutBox.manipulee;
        IF manipulee <> NIL THEN
            manipulee.RecalcExtent;  {will send it up the line to its parents}

        parent := SELF.layoutBox.parent;
        IF parent <> NIL THEN  {now send it up the line to my own parents}
            IF InClass(parent, TLayoutBox) THEN
                parent.RecalcExtent;

        IF NOT TPlannerView(SELF.layoutBox.view).retainPickedBox THEN
            SELF.Deselect;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TLayPickSelection.Restore;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        TPlannerView(SELF.view).currentLayoutBox := SELF.layoutBox;
        SUPERSELF.Restore;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TLayMoveCmd;

{$S SgLayout}
    FUNCTION  TLayMoveCmd.CREATE{(object: TObject; heap: THeap; itsLayoutBox: TLayoutBox;
                                    itsHOffset, itsVOffset: LONGINT): TLayMoveCmd};
        VAR retainPickedBox:    BOOLEAN;
            cmdPhase:           TCmdPhase;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TLayMoveCmd(TCommand.CREATE(object, heap, uMoveLayoutBoxes, itsLayoutBox.view,
                    TRUE, revealSome));

        WITH SELF DO
            BEGIN
            layoutBox := itsLayoutbox;
            hOffset := itsHOffset;
            vOffset := itsVOffset;
            retainPickedBox := TPlannerView(itsLayoutBox.view).retainPickedBox;
            WITH SELF DO
                BEGIN
                unHiliteBefore[doPhase] := FALSE;
                hiliteAfter[doPhase] := FALSE;
                END;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
{$S DlgDbg}
    PROCEDURE TLayMoveCmd.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('layoutBox: TLayoutBox');
        Field('hOffset: LONGINT');
        Field('vOffset: LONGINT');
        Field('');
    END;
    {$ENDC}


{$S SgLayout}
    PROCEDURE TLayMoveCmd.Perform(cmdPhase: TCmdPhase);
        VAR plannerView:    TPlannerView;
            panel:      TPanel;
            diffLPt:    LPoint;
    BEGIN
        {$IFC fTrace}BP(12);{$ENDC}
        IF cmdPhase <> doPhase THEN
            BEGIN
            WITH SELF DO {$H-}
                CASE cmdPhase OF
                    redoPhase:
                        SetLPt(diffLPt, hOffset, vOffset);
                    undoPhase:
                        SetLPt(diffLPt, -hOffset, -vOffset);
                    END; {$H+}
            SELF.layoutBox.Move(diffLPt);
            SELF.layoutBox.manipulee.RecalcExtent;
            SELF.layoutBox.RecalcExtent;
            IF NOT TPlannerView(SELF.layoutBox.view).retainPickedBox THEN
                SELF.layoutBox.view.panel.selection.Deselect;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TEditLegendSelection;


{$S SgLayout}
    FUNCTION TEditLegendSelection.CREATE(object: TObject; heap: THeap; itsLegendLayoutBox:
                TLegendLayoutBox; itsAnchorLPt: LPoint): TEditLegendSelection;
        VAR coSelection:        TSelection;
            paragraph:          TParagraph;
            paraImage:          TParaImage;
            hostLegend:         TLegend;
            textDialogImage:    TTextDialogImage;
            textImage:          TTextImage;
            textExtent:         LRect;
            typeStyle:          TTypeStyle;
            hostParagraph:      TParagraph;

            PROCEDURE FindBiggestFont(VAR biggestTypeStyle: TTypeStyle);
            VAR styleChange:    TStyleChange;
{$IFC libraryVersion <= 20}   {* * * P E P S I * * *}
                fInfo:          TFInfo;
{$ELSEC}                      {* *  S P R I N G  * *}
                fInfo:          FontInfo;
{$ENDC}
                i:              INTEGER;
                oldTallest:     INTEGER;
            BEGIN
                oldTallest := 0;
                FOR i := 1 TO hostParagraph.typeStyles.size - 1 DO
                    BEGIN
                    hostParagraph.typeStyles.GetAt(i, @styleChange);
                    hostParagraph.SetTypeStyle(styleChange.newStyle);
                    GetFontInfo(fInfo);
                    WITH fInfo DO
                        IF oldTallest < ascent + descent + leading THEN
                            BEGIN
                            oldTallest := ascent + descent + leading;
                            biggestTypeStyle := styleChange.newStyle;
                            END;
                    END;
            END;

    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TEditLegendSelection(TSelection.CREATE(object, heap, itsLegendLayoutBox.view,
                                                       layEditLegendSelectionKind, itsAnchorLPt));
        IF itsLegendLayoutBox.parent <> NIL THEN
            SELF.boundLRect := itsLegendLayoutBox.parent.extentLRect
        ELSE
            SELF.boundLRect := itsLegendLayoutBox.extentLRect;

        SELF.legendLayoutBox := itsLegendLayoutBox;
        hostLegend := TLegend(itsLegendLayoutBox.manipulee);
        SELF.hostLegend := hostLegend;
        hostParagraph := hostLegend.paragraph;

        SELF.suppressHost := itsLegendLayoutBox.suppressDrawingManipulee;

        coSelection := SELF.panel.view.NoSelection;  {put non-NIL coSelection}
        SELF.coSelection := coSelection;

        hostLegend.paragraph.StyleAt(0, typeStyle); {use paragraph's default if none else}
        FindBiggestFont(typeStyle);

        SetParaExtent(hostLegend.paragraph, SELF.view, hostLegend.location, textExtent);
        textExtent.right := textExtent.left + 10 * SELF.view.res.h;   {ten inches wide}
        textDialogImage := TTextDialogImage.CREATE(NIL, heap, textExtent, noID, SELF.view,
            typeStyle, '');     {start off with an empty guy}
        SELF.textDialogImage := textDialogImage;
        textImage := textDialogImage.textImage;
        paraImage := TParaImage(textImage.imageList.First);
        paragraph := paraImage.paragraph;

        paragraph.ReplPara(0,
            paragraph.size, hostLegend.paragraph, 0, hostLegend.paragraph.size);

        paraImage.changed := TRUE;
        paraImage.InvalLinesWith(0, MAXINT);

        textImage.RecomputeImages(actionNone, TRUE);

        itsLegendLayoutBox.textDialogImage := textDialogImage;
        SELF.textDialogImage := textDialogImage;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    FUNCTION  TEditLegendSelection.Clone(heap: THeap): TObject;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.textDialogImage.ChangeRefCountBy(1);
        Clone := TEditLegendSelection(SUPERSELF.Clone(heap));
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.Deselect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.legendLayoutBox.textDialogImage := NIL; {+SW+}
        SUPERSELF.Deselect;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.Free;
        VAR textDialogImage:    TTextDialogImage;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        textDialogImage := SELF.textDialogImage;  {+SW+} {five lines out}
        SUPERSELF.Free;
        textDialogImage.ChangeRefCountBy(-1);
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TEditLegendSelection.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('legendLayoutBox: TLegendLayoutBox');
        Field('hostLegend: TLegend');
        Field('textDialogImage: TTextDialogImage');
        Field('suppressHost: BOOLEAN');
        Field('tripleClick: BOOLEAN');  {+SW+}
        Field('');
    END;
    {$ENDC}


{$S SgLayout}
    FUNCTION TEditLegendSelection.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN;
    BEGIN
        {$IFC fTrace}BP(10);{$ENDC}
        CASE cmdNumber OF
            uModern, uClassic,u20Pitch, u15Pitch, u12Pitch, u10Pitch, u12Point, u14Point, u18Point, u24Point,
            uPlain, uBold, uItalic, uUnderline, uShadow, uOutline:
                IF SELF.hostLegend.usesSysFont THEN
                    CanDoCommand := FALSE
                ELSE
                    CanDoCommand := SUPERSELF.CanDoCommand(cmdNumber, checkIt);

            OTHERWISE
                CanDoCommand := SUPERSELF.CanDoCommand(cmdNumber, checkIt);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.KeyBack(fWord: BOOLEAN);
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.coSelection.KeyBack(fWord);
        SELF.legendLayoutBox.RecalcExtent;  {will determine current width of the textDialogImage and
                                       adjust layout box + parents accordingly}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.KeyChar(ch: CHAR);
        VAR newExtent:      LRect;
            width:          INTEGER;
            paragraph:      TParagraph;
            i:              INTEGER;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        paragraph := TParaImage(SELF.textDialogImage.textImage.imageList.First).paragraph;
        IF (paragraph.size < 255) OR
                (NOT InClass(SELF.coSelection, TInsertionPoint)) THEN  {can accept more}
            BEGIN
            SELF.coSelection.KeyChar(ch);

            SELF.legendLayoutBox.RecalcExtent;  {will determine current width of the textDialogImage and
                                           adjust layout box + parents accordingly}
            END
        ELSE
            BEGIN
            process.ArgAlert(1, '255');
            process.Stop(phTooManyChars);
            END;

        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.KeyEnter(dh, dv: INTEGER);
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF (dh <> 0) OR (dv <> 0) THEN
            SELF.KeyTab((dh < 0) OR (dv < 0));  {right and down keys are Forward}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.KeyReturn;
        VAR selection:  TSelection;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.Deselect;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.MousePress(mouseLPT: LPoint); {+SW+}
        VAR selection: TSelection;
            textImage:  TTextImage;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF clickState.clickCount < 3 THEN
            SUPERSELF.MousePress(mouseLPt)
        ELSE {triple click; force SelectAll}
            BEGIN
            SELF.tripleClick := TRUE;
            textImage := SELF.textDialogImage.textImage;
            SELF.Highlight(hOnToOff);
            SELF.coSelection.Become(
                    textImage.text.SelectAll(textImage));
            SELF.Highlight(hOffToOn);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.MouseMove(mouseLPT: LPoint); {+SW+}
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF NOT SELF.tripleClick THEN
            SUPERSELF.MouseMove(mouseLPt);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.MouseRelease; {+SW+}
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        IF SELF.tripleClick THEN
            SELF.tripleClick := FALSE
        ELSE
            SUPERSELF.MouseRelease;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.PerformCommand(command: TCommand; cmdPhase: TCmdPhase);
        VAR paragraph:  TParagraph;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SUPERSELF.PerformCommand(command, cmdPhase);
        IF SELF.hostLegend.usesSysFont THEN
            BEGIN
            paragraph := TParaImage(SELF.textDialogImage.textImage.imageList.First).paragraph;
            paragraph.NewStyle(0, paragraph.Size, sysTypeStyle);
            END;
        SELF.legendLayoutBox.RecalcExtent;  {will determine current width of the textDialogImage and
                                       adjust layout box + parents accordingly}
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.Restore;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SELF.legendLayoutBox.textDialogImage := SELF.textDialogImage;
        SUPERSELF.Restore;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S SgLayout}
    PROCEDURE TEditLegendSelection.Reveal(asMuchAsPossible: BOOLEAN);
        TYPE TXLRect = PACKED ARRAY [1..SIZEOF(LRect)] OF CHAR;
        VAR lr:         LRect;
            hMin:       INTEGER;
            vMin:       INTEGER;
    BEGIN
        {$IFC fTrace}BP(7);{$ENDC}
        SELF.coselection.boundLRect := SELF.boundLRect;
        SUPERSELF.Reveal(asMuchAsPossible);
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;


METHODS OF TDialogDesignWindow;


{$S DlgAlloc}
    FUNCTION TDialogDesignWindow.CREATE(object: TObject; heap: THeap;
                itsHostDialogView: TDialogView): TDialogDesignWindow;
        VAR fromBox:    BOOLEAN;
            window:     TWindow;
            htLPt:      LPoint;
            height:     INTEGER;
            htPt:       Point;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        window := itsHostDialogView.panel.window;
        fromBox := InClass(window, TDialogBox);
        IF fromBox THEN
            height :=  window.outerRect.bottom - window.outerRect.top + 15
        ELSE
            BEGIN
            WITH itsHostDialogView.extentLRect DO
      {$H-}     SetLPt(htLPt, 0, bottom - top);  {$H+}
            itsHostDialogView.screenPad.LPtToPt(htLPt, htPt);
            height := MIN(htPt.v + 15, screenBits.bounds.bottom - 30);
            END;

        IF object = NIL THEN
            object := NewObject(heap, THISCLASS);
        SELF := TDialogDesignWindow(TDialogWindow.CREATE(object, heap, TRUE, height,
                                                         diAccept, diAccept, diRefuse));

        WITH SELF DO
            BEGIN
            hostWindow := window;
            hostDialogView := itsHostDialogView;
            fromDialogBox := fromBox;
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


    {$IFC fDebugMethods}
    {$S DlgDbg}
    PROCEDURE TDialogDesignWindow.Fields(PROCEDURE Field(nameAndType: S255));
    BEGIN
        SUPERSELF.Fields(Field);
        Field('hostWindow: TWindow');
        Field('hostDialogView: TDialogView');
        Field('fromDialogBox: BOOLEAN');
        Field('');
    END;
   {$ENDC}


{$S DlgLayout}
    FUNCTION TDialogDesignWindow.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        CASE cmdNumber OF
            uEditDialog:
                CanDoCommand := FALSE;  {override SUPERSELF}
            uStopEditDialog:
                CanDoCommand := TRUE;
            OTHERWISE
                CanDoCommand := SUPERSELF.CanDoCommand(cmdNumber, checkIt);
            END;
        {$IFC fTrace}EP;{$ENDC}
     END;


{$S DlgLayout}
    FUNCTION  TDialogDesignWindow.NewCommand(cmdNumber: TCmdNumber): TCommand;
    BEGIN
        {$IFC fTrace}BP(12);{$ENDC}
        CASE cmdNumber OF
            uStopEditDialog:
                BEGIN
                SELF.RelinquishControl;
                NewCommand := NIL;
                END;
            OTHERWISE
                NewCommand := SUPERSELF.NewCommand(cmdNumber);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
    PROCEDURE TDialogDesignWindow.RelinquishControl;
                {not yet:  install in resourceFile}
        VAR panel:              TPanel;
            plannerView:        TPlannerView;
            dialogWindow:       TDialogWindow;
            newHeight:          INTEGER;
            noSelection:        TSelection;
            newBotRight:        point;
     BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        panel := SELF.selectPanel;
        panel.selection.Deselect;      {should incorporate last text edit, if any}
        panel.window.CommitLast;
        panel.BeginSelection;          {previous didn't really quite do it yet}

        currentWindow.TakeDownDialogBox;                              {take down layout dialog}

        IF SELF.fromDialogBox THEN {editing a dialog box--copy the resizing back to the dialog Window}
            BEGIN
            plannerView := TPlannerView(panel.currentView);
            newHeight := panel.innerRect.bottom;
            dialogWindow := TDialogWindow(plannerView.viewBeingPlanned.panel.window);
            SetPt(newBotRight, screenBits.bounds.right, newHeight);       {transfer its current...}
            currentWindow.PutUpDialogBox(dialogWindow);
            dialogWindow.ResizeTo(newBotRight);                           {height to main dialog}
            IF dialogWindow.selectPanel.selection.kind <> nothingKind THEN
                currentWindow.selectWindow := dialogWindow; {=}
            END;

        SELF.selectPanel.view := NIL;     {kludge to avoid clobbering the main view}
        currentWindow.Focus; {necessary to avoid a later popFocus trying to focus our now departed
                            DialogDesignWindow}
        SELF.Free; {!}
        {$IFC fTrace}EP;{$ENDC}
     END;


{$S DlgLayout}
    PROCEDURE TDialogDesignWindow.Resize(moving: BOOLEAN);
        VAR view:           TView;
            extentLRect:    LRect;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        SUPERSELF.Resize(moving); {moving is always FALSE of course}
        IF SELF.hostWindow.isResizable THEN
            {do nothing, I guess}
        ELSE
            BEGIN
            view := SELF.selectPanel.currentView;
            extentLRect := view.extentLRect;
            extentLRect.bottom := SELF.selectPanel.innerRect.bottom;
            view.Resize(extentLRect);     {that'll be the layout view}
            SELF.hostDialogView.Resize(extentLRect);
            END;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgLayout}
    PROCEDURE TDialogDesignWindow.SeizeControl;
        VAR dialogView:     TDialogView;
            panel:          TPanel;
            children:       TList;
            imageList:      TList;
            dialogBox:      TDialogBox;
            savedSetting:   BOOLEAN;
    BEGIN
        {$IFC fTrace}BP(11);{$ENDC}
        dialogView := SELF.hostDialogView;
        children := dialogView.rootDialog.children;
        IF SELF.fromDialogBox THEN
            BEGIN
            dialogBox := currentWindow.dialogBox;
            savedSetting := dialogBox.freeOnDismissal;
            dialogBox.freeOnDismissal := FALSE;
            currentWindow.TakeDownDialogBox;
            dialogBox.freeOnDismissal := savedSetting;
            END;


        panel := TPanel.CREATE(NIL, SELF.Heap, SELF, 0, SELF.innerRect.right - 23, [aScroll, aBar],
                    [aScroll, aBar]);
        SELF.controlPanel := panel;

        CASE children.Size OF
            0:          ABCBreak('SeizeControl, empty children of dialog view', 0);
            1:          imageList := TDialog(children.First).children;
            OTHERWISE   imageList := children;
            END; {case}

        TPlannerView.CREATE(NIL, SELF.Heap, dialogView, panel, FALSE, FALSE).Init(imageList);

        currentWindow.PutUpDialogBox(SELF);
        panel.BeginSelection;
        {$IFC fTrace}EP;{$ENDC}
    END;


{$S DlgInit}
END;

